{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay/Cone_Decomposition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay", "problem_names": ["lemmas reduced_GB_subset_monic_Polys =\n  punit.reduced_GB_subset_monic_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]", "lemmas reduced_GB_is_monomial_set_Polys =\n  punit.reduced_GB_is_monomial_set_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]", "lemmas is_red_reduced_GB_monomial_lt_GB_Polys =\n  punit.is_red_reduced_GB_monomial_lt_GB_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]", "lemmas reduced_GB_monomial_lt_reduced_GB_Polys =\n  punit.reduced_GB_monomial_lt_reduced_GB_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]", "lemma quot_set_iff: \"a \\<in> A \\<div> x \\<longleftrightarrow> x * a \\<in> A\"", "lemma quot_setI: \"x * a \\<in> A \\<Longrightarrow> a \\<in> A \\<div> x\"", "lemma quot_setD: \"a \\<in> A \\<div> x \\<Longrightarrow> x * a \\<in> A\"", "lemma quot_set_quot_set [simp]: \"A \\<div> x \\<div> y = A \\<div> x * y\"", "lemma quot_set_one [simp]: \"A \\<div> (1::_::monoid_mult) = A\"", "lemma ideal_quot_set_ideal [simp]: \"ideal (ideal B \\<div> x) = (ideal B) \\<div> (x::_::comm_ring)\"", "lemma quot_set_image_times: \"inj ((*) x) \\<Longrightarrow> ((*) x ` A) \\<div> x = A\"", "lemma normal_form:\n  shows \"(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\" (is ?thesis1)\n    and \"\\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\" (is ?thesis2)", "lemma normal_form_unique:\n  assumes \"(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\" and \"\\<not> punit.is_red (punit.reduced_GB F) q\"\n  shows \"normal_form F p = q\"", "lemma normal_form_id_iff: \"normal_form F p = p \\<longleftrightarrow> (\\<not> punit.is_red (punit.reduced_GB F) p)\"", "lemma normal_form_normal_form: \"normal_form F (normal_form F p) = normal_form F p\"", "lemma normal_form_zero: \"normal_form F 0 = 0\"", "lemma normal_form_map_scale: \"normal_form F (c \\<cdot> p) = c \\<cdot> (normal_form F p)\"", "lemma normal_form_uminus: \"normal_form F (- p) = - normal_form F p\"", "lemma normal_form_plus_normal_form:\n  \"normal_form F (normal_form F p + normal_form F q) = normal_form F p + normal_form F q\"", "lemma normal_form_minus_normal_form:\n  \"normal_form F (normal_form F p - normal_form F q) = normal_form F p - normal_form F q\"", "lemma normal_form_ideal_Polys: \"normal_form (ideal F \\<inter> P[X]) = normal_form F\"", "lemma normal_form_diff_in_ideal: \"p - normal_form F p \\<in> ideal F\"", "lemma normal_form_zero_iff: \"normal_form F p = 0 \\<longleftrightarrow> p \\<in> ideal F\"", "lemma normal_form_eq_iff: \"normal_form F p = normal_form F q \\<longleftrightarrow> p - q \\<in> ideal F\"", "lemma Polys_closed_normal_form:\n  assumes \"p \\<in> P[X]\"\n  shows \"normal_form F p \\<in> P[X]\"", "lemma image_normal_form_iff:\n  \"p \\<in> normal_form F ` P[X] \\<longleftrightarrow> (p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p)\"", "lemma direct_decomp_ideal_insert:\n  fixes F and f\n  defines \"I \\<equiv> ideal (insert f F)\"\n  defines \"L \\<equiv> (ideal F \\<div> f) \\<inter> P[X]\"\n  assumes \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\"\n  shows \"direct_decomp (I \\<inter> P[X]) [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\"\n    (is \"direct_decomp _ ?ss\")", "lemma coneI: \"p = a * h \\<Longrightarrow> a \\<in> P[U] \\<Longrightarrow> p \\<in> cone (h, U)\"", "lemma coneE:\n  assumes \"p \\<in> cone (h, U)\"\n  obtains a where \"a \\<in> P[U]\" and \"p = a * h\"", "lemma cone_empty: \"cone (h, {}) = range (\\<lambda>c. c \\<cdot> h)\"", "lemma cone_zero [simp]: \"cone (0, U) = {0}\"", "lemma cone_one [simp]: \"cone (1::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1, U) = P[U]\"", "lemma zero_in_cone: \"0 \\<in> cone hU\"", "lemma tip_in_cone: \"h \\<in> cone (h::_ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1, U)\"", "lemma cone_closed_plus:\n  assumes \"a \\<in> cone hU\" and \"b \\<in> cone hU\"\n  shows \"a + b \\<in> cone hU\"", "lemma cone_closed_uminus:\n  assumes \"(a::_ \\<Rightarrow>\\<^sub>0 _::comm_ring) \\<in> cone hU\"\n  shows \"- a \\<in> cone hU\"", "lemma cone_closed_minus:\n  assumes \"(a::_ \\<Rightarrow>\\<^sub>0 _::comm_ring) \\<in> cone hU\" and \"b \\<in> cone hU\"\n  shows \"a - b \\<in> cone hU\"", "lemma cone_closed_times:\n  assumes \"a \\<in> cone (h, U)\" and \"q \\<in> P[U]\"\n  shows \"q * a \\<in> cone (h, U)\"", "lemma coneD:\n  assumes \"p \\<in> cone (h, U)\" and \"p \\<noteq> 0\"\n  shows \"lpp h adds lpp (p::_ \\<Rightarrow>\\<^sub>0 _::{comm_semiring_0,semiring_no_zero_divisors})\"", "lemma cone_mono_1:\n  assumes \"h' \\<in> P[U]\"\n  shows \"cone (h' * h, U) \\<subseteq> cone (h, U)\"", "lemma cone_mono_2:\n  assumes \"U1 \\<subseteq> U2\"\n  shows \"cone (h, U1) \\<subseteq> cone (h, U2)\"", "lemma cone_subsetD:\n  assumes \"cone (h1, U1) \\<subseteq> cone (h2::_ \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}, U2)\"\n  shows \"h2 dvd h1\" and \"h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2\"", "lemma cone_subset_PolysD:\n  assumes \"cone (h::_ \\<Rightarrow>\\<^sub>0 'a::{comm_semiring_1,semiring_no_zero_divisors}, U) \\<subseteq> P[X]\"\n  shows \"h \\<in> P[X]\" and \"h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X\"", "lemma cone_subset_PolysI:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X\"\n  shows \"cone (h, U) \\<subseteq> P[X]\"", "lemma cone_image_times: \"(*) a ` cone (h, U) = cone (a * h, U)\"", "lemma cone_image_times': \"(*) a ` cone hU = cone (apfst ((*) a) hU)\"", "lemma homogeneous_set_coneI:\n  assumes \"homogeneous h\"\n  shows \"homogeneous_set (cone (h, U))\"", "lemma subspace_cone: \"phull.subspace (cone hU)\"", "lemma direct_decomp_cone_insert:\n  fixes h :: \"_ \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}\"\n  assumes \"x \\<notin> U\"\n  shows \"direct_decomp (cone (h, insert x U))\n                  [cone (h, U), cone (monomial 1 (Poly_Mapping.single x (Suc 0)) * h, insert x U)]\"", "lemma valid_decompI:\n  \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]) \\<Longrightarrow> (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0) \\<Longrightarrow>\n    (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X) \\<Longrightarrow> valid_decomp X ps\"", "lemma valid_decompD:\n  assumes \"valid_decomp X ps\" and \"(h, U) \\<in> set ps\"\n  shows \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\"", "lemma valid_decompD_finite:\n  assumes \"finite X\" and \"valid_decomp X ps\" and \"(h, U) \\<in> set ps\"\n  shows \"finite U\"", "lemma valid_decomp_Nil: \"valid_decomp X []\"", "lemma valid_decomp_concat:\n  assumes \"\\<And>ps. ps \\<in> set pss \\<Longrightarrow> valid_decomp X ps\"\n  shows \"valid_decomp X (concat pss)\"", "lemma valid_decomp_map_times:\n  assumes \"valid_decomp X ps\" and \"s \\<in> P[X]\" and \"s \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 _::semiring_no_zero_divisors)\"\n  shows \"valid_decomp X (map (apfst ((*) s)) ps)\"", "lemma monomial_decompI:\n  \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> is_monomial h) \\<Longrightarrow> (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> punit.lc h = 1) \\<Longrightarrow>\n    monomial_decomp ps\"", "lemma monomial_decompD:\n  assumes \"monomial_decomp ps\" and \"(h, U) \\<in> set ps\"\n  shows \"is_monomial h\" and \"punit.lc h = 1\"", "lemma monomial_decomp_append_iff:\n  \"monomial_decomp (ps @ qs) \\<longleftrightarrow> monomial_decomp ps \\<and> monomial_decomp qs\"", "lemma monomial_decomp_concat:\n  \"(\\<And>ps. ps \\<in> set pss \\<Longrightarrow> monomial_decomp ps) \\<Longrightarrow> monomial_decomp (concat pss)\"", "lemma monomial_decomp_map_times:\n  assumes \"monomial_decomp ps\" and \"is_monomial f\" and \"punit.lc f = (1::'a::semiring_1)\"\n  shows \"monomial_decomp (map (apfst ((*) f)) ps)\"", "lemma monomial_decomp_monomial_in_cone:\n  assumes \"monomial_decomp ps\" and \"hU \\<in> set ps\" and \"a \\<in> cone hU\"\n  shows \"monomial (lookup a t) t \\<in> cone hU\"", "lemma monomial_decomp_sum_list_monomial_in_cone:\n  assumes \"monomial_decomp ps\" and \"a \\<in> sum_list ` listset (map cone ps)\" and \"t \\<in> keys a\"\n  obtains c h U where \"(h, U) \\<in> set ps\" and \"c \\<noteq> 0\" and \"monomial c t \\<in> cone (h, U)\"", "lemma hom_decompI: \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h) \\<Longrightarrow> hom_decomp ps\"", "lemma hom_decompD: \"hom_decomp ps \\<Longrightarrow> (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h\"", "lemma hom_decomp_append_iff: \"hom_decomp (ps @ qs) \\<longleftrightarrow> hom_decomp ps \\<and> hom_decomp qs\"", "lemma hom_decomp_concat: \"(\\<And>ps. ps \\<in> set pss \\<Longrightarrow> hom_decomp ps) \\<Longrightarrow> hom_decomp (concat pss)\"", "lemma hom_decomp_map_times:\n  assumes \"hom_decomp ps\" and \"homogeneous f\"\n  shows \"hom_decomp (map (apfst ((*) f)) ps)\"", "lemma monomial_decomp_imp_hom_decomp:\n  assumes \"monomial_decomp ps\"\n  shows \"hom_decomp ps\"", "lemma cone_decompI: \"direct_decomp T (map cone ps) \\<Longrightarrow> cone_decomp T ps\"", "lemma cone_decompD: \"cone_decomp T ps \\<Longrightarrow> direct_decomp T (map cone ps)\"", "lemma cone_decomp_cone_subset:\n  assumes \"cone_decomp T ps\" and \"hU \\<in> set ps\"\n  shows \"cone hU \\<subseteq> T\"", "lemma cone_decomp_indets:\n  assumes \"cone_decomp T ps\" and \"T \\<subseteq> P[X]\" and \"(h, U) \\<in> set ps\"\n  shows \"h \\<in> P[X]\" and \"h \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 _::{comm_semiring_1,semiring_no_zero_divisors}) \\<Longrightarrow> U \\<subseteq> X\"", "lemma cone_decomp_closed_plus:\n  assumes \"cone_decomp T ps\" and \"a \\<in> T\" and \"b \\<in> T\"\n  shows \"a + b \\<in> T\"", "lemma cone_decomp_closed_uminus:\n  assumes \"cone_decomp T ps\" and \"(a::_ \\<Rightarrow>\\<^sub>0 _::comm_ring) \\<in> T\"\n  shows \"- a \\<in> T\"", "lemma cone_decomp_Nil: \"cone_decomp {0} []\"", "lemma cone_decomp_singleton: \"cone_decomp (cone (t, U)) [(t, U)]\"", "lemma cone_decomp_append:\n  assumes \"direct_decomp T [S1, S2]\" and \"cone_decomp S1 ps\" and \"cone_decomp S2 qs\"\n  shows \"cone_decomp T (ps @ qs)\"", "lemma cone_decomp_concat:\n  assumes \"direct_decomp T ss\" and \"length pss = length ss\"\n    and \"\\<And>i. i < length ss \\<Longrightarrow> cone_decomp (ss ! i) (pss ! i)\"\n  shows \"cone_decomp T (concat pss)\"", "lemma cone_decomp_map_times:\n  assumes \"cone_decomp T ps\"\n  shows \"cone_decomp ((*) s ` T) (map (apfst ((*) (s::_ \\<Rightarrow>\\<^sub>0 _::{comm_ring_1,ring_no_zero_divisors}))) ps)\"", "lemma cone_decomp_perm:\n  assumes \"cone_decomp T ps\" and \"perm ps qs\"\n  shows \"cone_decomp T qs\"", "lemma valid_cone_decomp_subset_Polys:\n  assumes \"valid_decomp X ps\" and \"cone_decomp T ps\"\n  shows \"T \\<subseteq> P[X]\"", "lemma homogeneous_set_cone_decomp:\n  assumes \"cone_decomp T ps\" and \"hom_decomp ps\"\n  shows \"homogeneous_set T\"", "lemma subspace_cone_decomp:\n  assumes \"cone_decomp T ps\"\n  shows \"phull.subspace (T::(_ \\<Rightarrow>\\<^sub>0 _::field) set)\"", "lemma pos_decomp_Nil [simp]: \"[]\\<^sub>+ = []\"", "lemma pos_decomp_subset: \"set (ps\\<^sub>+) \\<subseteq> set ps\"", "lemma pos_decomp_append: \"(ps @ qs)\\<^sub>+ = ps\\<^sub>+ @ qs\\<^sub>+\"", "lemma pos_decomp_concat: \"(concat pss)\\<^sub>+ = concat (map pos_decomp pss)\"", "lemma pos_decomp_map: \"(map (apfst f) ps)\\<^sub>+ = map (apfst f) (ps\\<^sub>+)\"", "lemma card_Diff_pos_decomp: \"card {(h, U) \\<in> set qs - set (qs\\<^sub>+). P h} = card {h. (h, {}) \\<in> set qs \\<and> P h}\"", "lemma standard_decompI:\n  assumes \"\\<And>h U. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h\"\n    and \"\\<And>h U d. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> d \\<Longrightarrow> d \\<le> poly_deg h \\<Longrightarrow>\n          (\\<exists>h' U'. (h', U') \\<in> set ps \\<and> poly_deg h' = d \\<and> card U \\<le> card U')\"\n  shows \"standard_decomp k ps\"", "lemma standard_decompD: \"standard_decomp k ps \\<Longrightarrow> (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h\"", "lemma standard_decompE:\n  assumes \"standard_decomp k ps\" and \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"k \\<le> d\" and \"d \\<le> poly_deg h\"\n  obtains h' U' where \"(h', U') \\<in> set ps\" and \"poly_deg h' = d\" and \"card U \\<le> card U'\"", "lemma standard_decomp_Nil: \"ps\\<^sub>+ = [] \\<Longrightarrow> standard_decomp k ps\"", "lemma standard_decomp_singleton: \"standard_decomp (poly_deg h) [(h, U)]\"", "lemma standard_decomp_concat:\n  assumes \"\\<And>ps. ps \\<in> set pss \\<Longrightarrow> standard_decomp k ps\"\n  shows \"standard_decomp k (concat pss)\"", "lemma standard_decomp_map_times:\n  assumes \"standard_decomp k ps\" and \"valid_decomp X ps\" and \"s \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 'a::semiring_no_zero_divisors)\"\n  shows \"standard_decomp (k + poly_deg s) (map (apfst ((*) s)) ps)\"", "lemma standard_decomp_nonempty_unique:\n  assumes \"finite X\" and \"valid_decomp X ps\" and \"standard_decomp k ps\" and \"ps\\<^sub>+ \\<noteq> []\"\n  shows \"k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\"", "lemma standard_decomp_SucE:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"h \\<in> P[X]\" and \"h \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors})\"\n  obtains ps where \"valid_decomp X ps\" and \"cone_decomp (cone (h, U)) ps\"\n    and \"standard_decomp (Suc (poly_deg h)) ps\"\n    and \"is_monomial h \\<Longrightarrow> punit.lc h = 1 \\<Longrightarrow> monomial_decomp ps\" and \"homogeneous h \\<Longrightarrow> hom_decomp ps\"", "lemma standard_decomp_geE:\n  assumes \"finite X\" and \"valid_decomp X ps\"\n    and \"cone_decomp (T::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) set) ps\"\n    and \"standard_decomp k ps\" and \"k \\<le> d\"\n  obtains qs where \"valid_decomp X qs\" and \"cone_decomp T qs\" and \"standard_decomp d qs\"\n    and \"monomial_decomp ps \\<Longrightarrow> monomial_decomp qs\" and \"hom_decomp ps \\<Longrightarrow> hom_decomp qs\"", "lemma splits_wrtI:\n  assumes \"cone_decomp T (ps @ qs)\"\n    and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\" and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> ideal F\"\n    and \"\\<And>h U. (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\"\n    and \"\\<And>h U a. (h, U) \\<in> set qs \\<Longrightarrow> a \\<in> cone (h, U) \\<Longrightarrow> a \\<in> ideal F \\<Longrightarrow> a = 0\"\n  shows \"splits_wrt (ps, qs) T F\"", "lemma splits_wrtI_valid_decomp:\n  assumes \"valid_decomp X ps\" and \"valid_decomp X qs\" and \"cone_decomp T (ps @ qs)\"\n    and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> ideal F\"\n    and \"\\<And>h U a. (h, U) \\<in> set qs \\<Longrightarrow> a \\<in> cone (h, U) \\<Longrightarrow> a \\<in> ideal F \\<Longrightarrow> a = 0\"\n  shows \"splits_wrt (ps, qs) T F\"", "lemma splits_wrtD:\n  assumes \"splits_wrt (ps, qs) T F\"\n  shows \"cone_decomp T (ps @ qs)\" and \"hU \\<in> set ps \\<Longrightarrow> cone hU \\<subseteq> ideal F \\<inter> P[X]\"\n    and \"hU \\<in> set qs \\<Longrightarrow> cone hU \\<subseteq> P[X]\" and \"hU \\<in> set qs \\<Longrightarrow> cone hU \\<inter> ideal F = {0}\"", "lemma splits_wrt_image_sum_list_fst_subset:\n  assumes \"splits_wrt (ps, qs) T F\"\n  shows \"sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\"", "lemma splits_wrt_image_sum_list_snd_subset:\n  assumes \"splits_wrt (ps, qs) T F\"\n  shows \"sum_list ` listset (map cone qs) \\<subseteq> P[X]\"", "lemma splits_wrt_cone_decomp_1:\n  assumes \"splits_wrt (ps, qs) T F\" and \"monomial_decomp qs\" and \"is_monomial_set (F::(_ \\<Rightarrow>\\<^sub>0 'a::field) set)\"\n        \\<comment>\\<open>The last two assumptions are missing in the paper.\\<close>\n  shows \"cone_decomp (T \\<inter> ideal F) ps\"", "lemma splits_wrt_cone_decomp_2:\n  assumes \"finite X\" and \"splits_wrt (ps, qs) T F\" and \"monomial_decomp qs\" and \"is_monomial_set F\"\n    and \"F \\<subseteq> P[X]\"\n  shows \"cone_decomp (T \\<inter> normal_form F ` P[X]) qs\"", "lemma quot_monomial_ideal_monomial:\n  \"ideal (monomial 1 ` S) \\<div> monomial 1 (Poly_Mapping.single (x::'x) (1::nat)) =\n    ideal (monomial (1::'a::comm_ring_1) ` (\\<lambda>s. s - Poly_Mapping.single x 1) ` S)\"", "lemma lem_4_2_1:\n  assumes \"ideal F \\<div> monomial 1 t = ideal (monomial (1::'a::comm_ring_1) ` S)\"\n  shows \"cone (monomial 1 t, U) \\<subseteq> ideal F \\<longleftrightarrow> 0 \\<in> S\"", "lemma lem_4_2_2:\n  assumes \"ideal F \\<div> monomial 1 t = ideal (monomial (1::'a::comm_ring_1) ` S)\"\n  shows \"cone (monomial 1 t, U) \\<inter> ideal F = {0} \\<longleftrightarrow> S \\<inter> .[U] = {}\"", "lemma max_subset:\n  assumes \"finite A\" and \"B \\<subseteq> A\" and \"P B\"\n  shows \"max_subset A P \\<subseteq> A\" (is ?thesis1)\n    and \"P (max_subset A P)\" (is ?thesis2)\n    and \"card B \\<le> card (max_subset A P)\" (is ?thesis3)", "lemma split_domI':\n  assumes \"finite X\" and \"fst (snd args) \\<subseteq> X\" and \"finite (snd (snd args))\"\n  shows \"split_dom TYPE('a::{zero,one}) args\"", "lemma split_empty:\n  assumes \"finite X\" and \"U \\<subseteq> X\"\n  shows \"split t U {} = ([], [(monomial (1::'a::{zero,one}) t, U)])\"", "lemma split_induct [consumes 3, case_names base1 base2 step]:\n  fixes P :: \"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> _\"\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\"\n  assumes \"\\<And>t U S. U \\<subseteq> X \\<Longrightarrow> finite S \\<Longrightarrow> 0 \\<in> S \\<Longrightarrow> P t U S ([(monomial (1::'a::{zero,one}) t, U)], [])\"\n  assumes \"\\<And>t U S. U \\<subseteq> X \\<Longrightarrow> finite S \\<Longrightarrow> 0 \\<notin> S \\<Longrightarrow> S \\<inter> .[U] = {} \\<Longrightarrow> P t U S ([], [(monomial 1 t, U)])\"\n  assumes \"\\<And>t U S V x ps0 ps1 qs0 qs1. U \\<subseteq> X \\<Longrightarrow> finite S \\<Longrightarrow> 0 \\<notin> S \\<Longrightarrow> S \\<inter> .[U] \\<noteq> {} \\<Longrightarrow> V \\<subseteq> U \\<Longrightarrow>\n              S \\<inter> .[V] = {} \\<Longrightarrow> (\\<And>V'. V' \\<subseteq> U \\<Longrightarrow> S \\<inter> .[V'] = {} \\<Longrightarrow> card V' \\<le> card V) \\<Longrightarrow>\n              x \\<in> U \\<Longrightarrow> x \\<notin> V \\<Longrightarrow> V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {}) \\<Longrightarrow> x = (SOME x'. x' \\<in> U - V) \\<Longrightarrow>\n              (ps0, qs0) = split t (U - {x}) S \\<Longrightarrow>\n              (ps1, qs1) = split (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` S) \\<Longrightarrow>\n              split t U S = (ps0 @ ps1, qs0 @ qs1) \\<Longrightarrow>\n              P t (U - {x}) S (ps0, qs0) \\<Longrightarrow>\n              P (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` S) (ps1, qs1) \\<Longrightarrow>\n              P t U S (ps0 @ ps1, qs0 @ qs1)\"\n  shows \"P t U S (split t U S)\"", "lemma valid_decomp_split:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"t \\<in> .[X]\"\n  shows \"valid_decomp X (fst ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n    and \"valid_decomp X (snd ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n          (is \"valid_decomp _ (snd ?s)\")", "lemma monomial_decomp_split:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\"\n  shows \"monomial_decomp (fst ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n    and \"monomial_decomp (snd ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n          (is \"monomial_decomp (snd ?s)\")", "lemma split_splits_wrt:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"t \\<in> .[X]\"\n    and \"ideal F \\<div> monomial 1 t = ideal (monomial 1 ` S)\"\n  shows \"splits_wrt (split t U S) (cone (monomial (1::'a::{comm_ring_1,ring_no_zero_divisors}) t, U)) F\"", "lemma lem_4_5:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"t \\<in> .[X]\" and \"F \\<subseteq> P[X]\"\n    and \"ideal F \\<div> monomial 1 t = ideal (monomial (1::'a) ` S)\"\n    and \"cone (monomial (1::'a::field) t', V) \\<subseteq> cone (monomial 1 t, U) \\<inter> normal_form F ` P[X]\"\n  shows \"V \\<subseteq> U\" and \"S \\<inter> .[V] = {}\"", "lemma lem_4_6:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"t \\<in> .[X]\" and \"F \\<subseteq> P[X]\"\n    and \"ideal F \\<div> monomial 1 t = ideal (monomial 1 ` S)\"\n  assumes \"cone (monomial 1 t', V) \\<subseteq> cone (monomial 1 t, U) \\<inter> normal_form F ` P[X]\"\n  obtains V' where \"(monomial 1 t, V') \\<in> set (snd (split t U S))\" and \"card V \\<le> card V'\"", "lemma lem_4_7:\n  assumes \"finite X\" and \"S \\<subseteq> .[X]\" and \"g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\"\n    and \"cone_decomp (P[X] \\<inter> ideal (monomial (1::'a::field) ` S)) ps\"\n    and \"monomial_decomp ps\"\n  obtains U where \"(g, U) \\<in> set ps\"", "lemma snd_splitI:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"0 \\<notin> S\"\n  obtains V where \"V \\<subseteq> U\" and \"(monomial 1 t, V) \\<in> set (snd (split t U S))\"", "lemma fst_splitE:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"0 \\<notin> S\"\n    and \"(monomial (1::'a) s, V) \\<in> set (fst (split t U S))\"\n  obtains t' x where \"t' \\<in> .[X]\" and \"x \\<in> X\" and \"V \\<subseteq> U\" and \"0 \\<notin> (\\<lambda>s. s - t') ` S\"\n    and \"s = t' + t + Poly_Mapping.single x 1\"\n    and \"(monomial (1::'a::zero_neq_one) s, V) \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\"\n    and \"set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S))) \\<subseteq> (set (snd (split t U S)) :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) set)\"", "lemma lem_4_8:\n  assumes \"finite X\" and \"finite S\" and \"S \\<subseteq> .[X]\" and \"0 \\<notin> S\"\n    and \"g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\"\n  obtains t U where \"U \\<subseteq> X\" and \"(monomial (1::'a::field) t, U) \\<in> set (snd (split 0 X S))\"\n    and \"poly_deg g = Suc (deg_pm t)\"", "lemma standard_decomp_snd_split:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"S \\<subseteq> .[X]\" and \"t \\<in> .[X]\"\n  shows \"standard_decomp (deg_pm t) (snd (split t U S) :: ((_ \\<Rightarrow>\\<^sub>0 'a::field) \\<times> _) list)\"", "theorem standard_cone_decomp_snd_split:\n  fixes F\n  defines \"G \\<equiv> punit.reduced_GB F\"\n  defines \"ss \\<equiv> (split 0 X (lpp ` G)) :: ((_ \\<Rightarrow>\\<^sub>0 'a::field) \\<times> _) list \\<times> _\"\n  defines \"d \\<equiv> Suc (Max (poly_deg ` fst ` set (snd ss)))\"\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\"\n  shows \"standard_decomp 0 (snd ss)\" (is ?thesis1)\n    and \"cone_decomp (normal_form F ` P[X]) (snd ss)\" (is ?thesis2)\n    and \"(\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> g \\<in> G \\<Longrightarrow> poly_deg g \\<le> d\"", "lemma ideal_decomp_aux:\n  assumes \"finite F\" and \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\"\n  shows \"fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\" (is ?thesis1)\n    and \"ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\" (is ?thesis2)\n    and \"direct_decomp (ideal (insert f F) \\<inter> P[X]) [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\" (is ?thesis3)\n    and \"cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\" (is ?thesis4)\n    and \"f \\<noteq> 0 \\<Longrightarrow> valid_decomp X (snd (ideal_decomp_aux F f))\" (is \"_ \\<Longrightarrow> ?thesis5\")\n    and \"f \\<noteq> 0 \\<Longrightarrow> standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\" (is \"_ \\<Longrightarrow> ?thesis6\")\n    and \"homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))\" (is \"_ \\<Longrightarrow> ?thesis7\")", "lemma ideal_decompE:\n  fixes f0 :: \"_ \\<Rightarrow>\\<^sub>0 'a::field\"\n  assumes \"finite F\" and \"F \\<subseteq> P[X]\" and \"f0 \\<in> P[X]\" and \"\\<And>f. f \\<in> F \\<Longrightarrow> poly_deg f \\<le> poly_deg f0\"\n  obtains T ps where \"valid_decomp X ps\" and \"standard_decomp (poly_deg f0) ps\" and \"cone_decomp T ps\"\n    and \"(\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> hom_decomp ps\"\n    and \"direct_decomp (ideal (insert f0 F) \\<inter> P[X]) [ideal {f0} \\<inter> P[X], T]\"", "lemma exact_decompI:\n  \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]) \\<Longrightarrow> (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X) \\<Longrightarrow>\n    (\\<And>h h' U U'. (h, U) \\<in> set ps \\<Longrightarrow> (h', U') \\<in> set ps \\<Longrightarrow> poly_deg h = poly_deg h' \\<Longrightarrow>\n            m < card U \\<Longrightarrow> m < card U' \\<Longrightarrow> (h, U) = (h', U')) \\<Longrightarrow>\n    exact_decomp m ps\"", "lemma exact_decompD:\n  assumes \"exact_decomp m ps\" and \"(h, U) \\<in> set ps\"\n  shows \"h \\<in> P[X]\" and \"U \\<subseteq> X\"\n    and \"(h', U') \\<in> set ps \\<Longrightarrow> poly_deg h = poly_deg h' \\<Longrightarrow> m < card U \\<Longrightarrow> m < card U' \\<Longrightarrow>\n            (h, U) = (h', U')\"", "lemma exact_decompI_zero:\n  assumes \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\" and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X\"\n    and \"\\<And>h h' U U'. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> (h', U') \\<in> set (ps\\<^sub>+) \\<Longrightarrow> poly_deg h = poly_deg h' \\<Longrightarrow>\n              (h, U) = (h', U')\"\n  shows \"exact_decomp 0 ps\"", "lemma exact_decompD_zero:\n  assumes \"exact_decomp 0 ps\" and \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"(h', U') \\<in> set (ps\\<^sub>+)\"\n    and \"poly_deg h = poly_deg h'\"\n  shows \"(h, U) = (h', U')\"", "lemma exact_decomp_imp_valid_decomp:\n  assumes \"exact_decomp m ps\" and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0\"\n  shows \"valid_decomp X ps\"", "lemma exact_decomp_card_X:\n  assumes \"valid_decomp X ps\" and \"card X \\<le> m\"\n  shows \"exact_decomp m ps\"", "lemma \\<a>: \"standard_decomp k ps \\<Longrightarrow> standard_decomp (\\<a> ps) ps\"", "lemma \\<a>_Nil:\n  assumes \"ps\\<^sub>+ = []\"\n  shows \"\\<a> ps = 0\"", "lemma \\<a>_nonempty:\n  assumes \"valid_decomp X ps\" and \"standard_decomp k ps\" and \"ps\\<^sub>+ \\<noteq> []\"\n  shows \"\\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\"", "lemma \\<a>_nonempty_unique:\n  assumes \"valid_decomp X ps\" and \"standard_decomp k ps\" and \"ps\\<^sub>+ \\<noteq> []\"\n  shows \"\\<a> ps = k\"", "lemma \\<b>:\n  shows \"\\<a> ps \\<le> \\<b> ps i\" and \"(h, U) \\<in> set ps \\<Longrightarrow> i \\<le> card U \\<Longrightarrow> poly_deg h < \\<b> ps i\"", "lemma \\<b>_le:\n  \"\\<a> ps \\<le> d \\<Longrightarrow> (\\<And>h' U'. (h', U') \\<in> set ps \\<Longrightarrow> i \\<le> card U' \\<Longrightarrow> poly_deg h' < d) \\<Longrightarrow> \\<b> ps i \\<le> d\"", "lemma \\<b>_decreasing:\n  assumes \"i \\<le> j\"\n  shows \"\\<b> ps j \\<le> \\<b> ps i\"", "lemma \\<b>_Nil:\n  assumes \"ps\\<^sub>+ = []\" and \"Suc 0 \\<le> i\"\n  shows \"\\<b> ps i = 0\"", "lemma \\<b>_zero:\n  assumes \"ps \\<noteq> []\"\n  shows \"Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0\"", "lemma \\<b>_one:\n  assumes \"valid_decomp X ps\" and \"standard_decomp k ps\"\n  shows \"\\<b> ps (Suc 0) = (if ps\\<^sub>+ = [] then 0 else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\"", "lemma \\<b>_card_X:\n  assumes \"exact_decomp m ps\" and \"Suc (card X) \\<le> i\"\n  shows \"\\<b> ps i = \\<a> ps\"", "lemma lem_6_1_1:\n  assumes \"standard_decomp k ps\" and \"exact_decomp m ps\" and \"Suc 0 \\<le> i\"\n    and \"i \\<le> card X\" and \"\\<b> ps (Suc i) \\<le> d\" and \"d < \\<b> ps i\"\n  obtains h U where \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"poly_deg h = d\" and \"card U = i\"", "lemma monomial_decomp_shift_list:\n  assumes \"monomial_decomp ps\" and \"hU \\<in> set ps\"\n  shows \"monomial_decomp (shift_list hU x ps)\"", "lemma hom_decomp_shift_list:\n  assumes \"hom_decomp ps\" and \"hU \\<in> set ps\"\n  shows \"hom_decomp (shift_list hU x ps)\"", "lemma valid_decomp_shift_list:\n  assumes \"valid_decomp X ps\" and \"(h, U) \\<in> set ps\" and \"x \\<in> U\"\n  shows \"valid_decomp X (shift_list (h, U) x ps)\"", "lemma standard_decomp_shift_list:\n  assumes \"standard_decomp k ps\" and \"(h1, U1) \\<in> set ps\" and \"(h2, U2) \\<in> set ps\"\n    and \"poly_deg h1 = poly_deg h2\" and \"card U2 \\<le> card U1\" and \"(h1, U1) \\<noteq> (h2, U2)\" and \"x \\<in> U2\"\n  shows \"standard_decomp k (shift_list (h2, U2) x ps)\"", "lemma cone_decomp_shift_list:\n  assumes \"valid_decomp X ps\" and \"cone_decomp T ps\" and \"(h, U) \\<in> set ps\" and \"x \\<in> U\"\n  shows \"cone_decomp T (shift_list (h, U) x ps)\"", "lemma shift2_invI:\n  \"valid_decomp X qs \\<Longrightarrow> standard_decomp k qs \\<Longrightarrow> exact_decomp (Suc m) qs \\<Longrightarrow>\n    (\\<And>d0. d0 < d \\<Longrightarrow> card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1) \\<Longrightarrow>\n    shift2_inv qs\"", "lemma shift2_invD:\n  assumes \"shift2_inv qs\"\n  shows \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"d0 < d \\<Longrightarrow> card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1\"", "lemma shift1_invI:\n  \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} \\<Longrightarrow> shift2_inv qs \\<Longrightarrow> shift1_inv (qs, B)\"", "lemma shift1_invD:\n  assumes \"shift1_inv (qs, B)\"\n  shows \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\" and \"shift2_inv qs\"", "lemma shift1_inv_finite_snd:\n  assumes \"shift1_inv (qs, B)\"\n  shows \"finite B\"", "lemma shift1_inv_some_snd:\n  assumes \"shift1_inv (qs, B)\" and \"1 < card B\" and \"(h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\"\n  shows \"(h, U) \\<in> B\" and \"(h, U) \\<in> set qs\" and \"poly_deg h = d\" and \"card U = Suc m\"", "lemma shift1_inv_preserved:\n  assumes \"shift1_inv (qs, B)\" and \"1 < card B\" and \"(h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\"\n    and \"x = (SOME y. y \\<in> U)\"\n  shows \"shift1_inv (shift_list (h, U) x qs, B - {(h, U)})\"", "lemma shift1_domI:\n  assumes \"shift1_inv args\"\n  shows \"shift1_dom args\"", "lemma shift1_induct [consumes 1, case_names base step]:\n  assumes \"shift1_inv args\"\n  assumes \"\\<And>qs B. shift1_inv (qs, B) \\<Longrightarrow> card B \\<le> 1 \\<Longrightarrow> P (qs, B) (qs, B)\"\n  assumes \"\\<And>qs B h U x. shift1_inv (qs, B) \\<Longrightarrow> 1 < card B \\<Longrightarrow>\n            (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m) \\<Longrightarrow> x = (SOME y. y \\<in> U) \\<Longrightarrow>\n            finite U \\<Longrightarrow> x \\<in> U \\<Longrightarrow> card (U - {x}) = m \\<Longrightarrow>\n            P (shift_list (h, U) x qs, B - {(h, U)}) (shift1 (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n            P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\"\n  shows \"P args (shift1 args)\"", "lemma shift1_1:\n  assumes \"shift1_inv args\" and \"d0 \\<le> d\"\n  shows \"card {q \\<in> set (fst (shift1 args)). poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1\"", "lemma shift1_2:\n  \"shift1_inv args \\<Longrightarrow>\n    card {q \\<in> set (fst (shift1 args)). m < card (snd q)} \\<le> card {q \\<in> set (fst args). m < card (snd q)}\"", "lemma shift1_3: \"shift1_inv args \\<Longrightarrow> cone_decomp T (fst args) \\<Longrightarrow> cone_decomp T (fst (shift1 args))\"", "lemma shift1_4:\n  \"shift1_inv args \\<Longrightarrow>\n    Max (poly_deg ` fst ` set (fst args)) \\<le> Max (poly_deg ` fst ` set (fst (shift1 args)))\"", "lemma shift1_5: \"shift1_inv args \\<Longrightarrow> fst (shift1 args) = [] \\<longleftrightarrow> fst args = []\"", "lemma shift1_6: \"shift1_inv args \\<Longrightarrow> monomial_decomp (fst args) \\<Longrightarrow> monomial_decomp (fst (shift1 args))\"", "lemma shift1_7: \"shift1_inv args \\<Longrightarrow> hom_decomp (fst args) \\<Longrightarrow> hom_decomp (fst (shift1 args))\"", "lemma shift2_inv_preserved:\n  assumes \"shift2_inv d qs\"\n  shows \"shift2_inv (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\"", "lemma shift2_1: \"shift2_inv d qs \\<Longrightarrow> shift2_inv c (shift2 c d qs)\"", "lemma shift2_2:\n  \"shift2_inv d qs \\<Longrightarrow>\n    card {q \\<in> set (shift2 c d qs). m < card (snd q)} \\<le> card {q \\<in> set qs. m < card (snd q)}\"", "lemma shift2_3: \"shift2_inv d qs \\<Longrightarrow> cone_decomp T qs \\<Longrightarrow> cone_decomp T (shift2 c d qs)\"", "lemma shift2_4:\n  \"shift2_inv d qs \\<Longrightarrow> Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))\"", "lemma shift2_5:\n  \"shift2_inv d qs \\<Longrightarrow> shift2 c d qs = [] \\<longleftrightarrow> qs = []\"", "lemma shift2_6:\n  \"shift2_inv d qs \\<Longrightarrow> monomial_decomp qs \\<Longrightarrow> monomial_decomp (shift2 c d qs)\"", "lemma shift2_7:\n  \"shift2_inv d qs \\<Longrightarrow> hom_decomp qs \\<Longrightarrow> hom_decomp (shift2 c d qs)\"", "lemma shift2_inv_init:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"shift2_inv k qs\"", "lemma shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"valid_decomp X (shift qs)\" and \"standard_decomp k (shift qs)\" and \"exact_decomp m (shift qs)\"", "lemma monomial_decomp_shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"monomial_decomp qs\"\n  shows \"monomial_decomp (shift qs)\"", "lemma hom_decomp_shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"hom_decomp qs\"\n  shows \"hom_decomp (shift qs)\"", "lemma cone_decomp_shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"cone_decomp T qs\"\n  shows \"cone_decomp T (shift qs)\"", "lemma Max_shift_ge:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (shift qs))\"", "lemma shift_Nil_iff:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"shift qs = [] \\<longleftrightarrow> qs = []\"", "lemma exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\"\n  shows \"valid_decomp X (exact_aux k m qs)\" (is ?thesis1)\n    and \"standard_decomp k (exact_aux k m qs)\" (is ?thesis2)\n    and \"exact_decomp 0 (exact_aux k m qs)\" (is ?thesis3)", "lemma monomial_decomp_exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\" and \"monomial_decomp qs\"\n  shows \"monomial_decomp (exact_aux k m qs)\"", "lemma hom_decomp_exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\" and \"hom_decomp qs\"\n  shows \"hom_decomp (exact_aux k m qs)\"", "lemma cone_decomp_exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\" and \"cone_decomp T qs\"\n  shows \"cone_decomp T (exact_aux k m qs)\"", "lemma Max_exact_aux_ge:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\"\n  shows \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (exact_aux k m qs))\"", "lemma exact_aux_Nil_iff:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\"\n  shows \"exact_aux k m qs = [] \\<longleftrightarrow> qs = []\"", "lemma exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\"\n  shows \"valid_decomp X (exact k qs)\" (is ?thesis1)\n    and \"standard_decomp k (exact k qs)\" (is ?thesis2)\n    and \"exact_decomp 0 (exact k qs)\" (is ?thesis3)", "lemma monomial_decomp_exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"monomial_decomp qs\"\n  shows \"monomial_decomp (exact k qs)\"", "lemma hom_decomp_exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"hom_decomp qs\"\n  shows \"hom_decomp (exact k qs)\"", "lemma cone_decomp_exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"cone_decomp T qs\"\n  shows \"cone_decomp T (exact k qs)\"", "lemma Max_exact_ge:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\"\n  shows \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (exact k qs))\"", "lemma exact_Nil_iff:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\"\n  shows \"exact k qs = [] \\<longleftrightarrow> qs = []\"", "lemma normal_form_exact_decompE:\n  assumes \"F \\<subseteq> P[X]\"\n  obtains qs where \"valid_decomp X qs\" and \"standard_decomp 0 qs\" and \"monomial_decomp qs\"\n    and \"cone_decomp (normal_form F ` P[X]) qs\" and \"exact_decomp 0 qs\"\n    and \"\\<And>g. (\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\""], "translations": [["", "lemmas reduced_GB_subset_monic_Polys =\n  punit.reduced_GB_subset_monic_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]"], ["", "lemmas reduced_GB_is_monomial_set_Polys =\n  punit.reduced_GB_is_monomial_set_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]"], ["", "lemmas is_red_reduced_GB_monomial_lt_GB_Polys =\n  punit.is_red_reduced_GB_monomial_lt_GB_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]"], ["", "lemmas reduced_GB_monomial_lt_reduced_GB_Polys =\n  punit.reduced_GB_monomial_lt_reduced_GB_dgrad_p_set[simplified, OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum]"], ["", "end"], ["", "subsection \\<open>Quotient Ideals\\<close>"], ["", "definition quot_set :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> 'a::semigroup_mult set\" (infixl \"\\<div>\" 55)\n  where \"quot_set A x = (*) x -` A\""], ["", "lemma quot_set_iff: \"a \\<in> A \\<div> x \\<longleftrightarrow> x * a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> A \\<div> x) = (x * a \\<in> A)", "by (simp add: quot_set_def)"], ["", "lemma quot_setI: \"x * a \\<in> A \\<Longrightarrow> a \\<in> A \\<div> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * a \\<in> A \\<Longrightarrow> a \\<in> A \\<div> x", "by (simp only: quot_set_iff)"], ["", "lemma quot_setD: \"a \\<in> A \\<div> x \\<Longrightarrow> x * a \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A \\<div> x \\<Longrightarrow> x * a \\<in> A", "by (simp only: quot_set_iff)"], ["", "lemma quot_set_quot_set [simp]: \"A \\<div> x \\<div> y = A \\<div> x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<div> x \\<div> y = A \\<div> x * y", "by (rule set_eqI) (simp add: quot_set_iff mult.assoc)"], ["", "lemma quot_set_one [simp]: \"A \\<div> (1::_::monoid_mult) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<div> (1::'a) = A", "by (rule set_eqI) (simp add: quot_set_iff)"], ["", "lemma ideal_quot_set_ideal [simp]: \"ideal (ideal B \\<div> x) = (ideal B) \\<div> (x::_::comm_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (ideal B \\<div> x) = ideal B \\<div> x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ideal (ideal B \\<div> x) \\<subseteq> ideal B \\<div> x\n 2. ideal B \\<div> x \\<subseteq> ideal (ideal B \\<div> x)", "show \"ideal (ideal B \\<div> x) \\<subseteq> ideal B \\<div> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (ideal B \\<div> x) \\<subseteq> ideal B \\<div> x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> ideal (ideal B \\<div> x) \\<Longrightarrow>\n       xa \\<in> ideal B \\<div> x", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> ideal (ideal B \\<div> x) \\<Longrightarrow>\n       xa \\<in> ideal B \\<div> x", "assume \"b \\<in> ideal (ideal B \\<div> x)\""], ["proof (state)\nthis:\n  b \\<in> ideal (ideal B \\<div> x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> ideal (ideal B \\<div> x) \\<Longrightarrow>\n       xa \\<in> ideal B \\<div> x", "thus \"b \\<in> ideal B \\<div> x\""], ["proof (prove)\nusing this:\n  b \\<in> ideal (ideal B \\<div> x)\n\ngoal (1 subgoal):\n 1. b \\<in> ideal B \\<div> x", "proof (induct b rule: ideal.span_induct')"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<in> ideal B \\<div> x\n 2. \\<And>a q p.\n       \\<lbrakk>a \\<in> ideal (ideal B \\<div> x); a \\<in> ideal B \\<div> x;\n        p \\<in> ideal B \\<div> x; q \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> a + q * p \\<in> ideal B \\<div> x", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (0::'a) \\<in> ideal B \\<div> x\n 2. \\<And>a q p.\n       \\<lbrakk>a \\<in> ideal (ideal B \\<div> x); a \\<in> ideal B \\<div> x;\n        p \\<in> ideal B \\<div> x; q \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> a + q * p \\<in> ideal B \\<div> x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> ideal B \\<div> x", "by (simp add: quot_set_iff ideal.span_zero)"], ["proof (state)\nthis:\n  (0::'a) \\<in> ideal B \\<div> x\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> ideal (ideal B \\<div> x); a \\<in> ideal B \\<div> x;\n        p \\<in> ideal B \\<div> x; q \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> a + q * p \\<in> ideal B \\<div> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> ideal (ideal B \\<div> x); a \\<in> ideal B \\<div> x;\n        p \\<in> ideal B \\<div> x; q \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> a + q * p \\<in> ideal B \\<div> x", "case (step b q p)"], ["proof (state)\nthis:\n  b \\<in> ideal (ideal B \\<div> x)\n  b \\<in> ideal B \\<div> x\n  p \\<in> ideal B \\<div> x\n  q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> ideal (ideal B \\<div> x); a \\<in> ideal B \\<div> x;\n        p \\<in> ideal B \\<div> x; q \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> a + q * p \\<in> ideal B \\<div> x", "hence \"x * b \\<in> ideal B\" and \"x * p \\<in> ideal B\""], ["proof (prove)\nusing this:\n  b \\<in> ideal (ideal B \\<div> x)\n  b \\<in> ideal B \\<div> x\n  p \\<in> ideal B \\<div> x\n  q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x * b \\<in> ideal B &&& x * p \\<in> ideal B", "by (simp_all add: quot_set_iff)"], ["proof (state)\nthis:\n  x * b \\<in> ideal B\n  x * p \\<in> ideal B\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> ideal (ideal B \\<div> x); a \\<in> ideal B \\<div> x;\n        p \\<in> ideal B \\<div> x; q \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> a + q * p \\<in> ideal B \\<div> x", "hence \"x * b + q * (x * p) \\<in> ideal B\""], ["proof (prove)\nusing this:\n  x * b \\<in> ideal B\n  x * p \\<in> ideal B\n\ngoal (1 subgoal):\n 1. x * b + q * (x * p) \\<in> ideal B", "by (intro ideal.span_add ideal.span_scale[where c=q])"], ["proof (state)\nthis:\n  x * b + q * (x * p) \\<in> ideal B\n\ngoal (1 subgoal):\n 1. \\<And>a q p.\n       \\<lbrakk>a \\<in> ideal (ideal B \\<div> x); a \\<in> ideal B \\<div> x;\n        p \\<in> ideal B \\<div> x; q \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> a + q * p \\<in> ideal B \\<div> x", "thus ?case"], ["proof (prove)\nusing this:\n  x * b + q * (x * p) \\<in> ideal B\n\ngoal (1 subgoal):\n 1. b + q * p \\<in> ideal B \\<div> x", "by (simp only: quot_set_iff algebra_simps)"], ["proof (state)\nthis:\n  b + q * p \\<in> ideal B \\<div> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> ideal B \\<div> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal (ideal B \\<div> x) \\<subseteq> ideal B \\<div> x\n\ngoal (1 subgoal):\n 1. ideal B \\<div> x \\<subseteq> ideal (ideal B \\<div> x)", "qed (fact ideal.span_superset)"], ["", "lemma quot_set_image_times: \"inj ((*) x) \\<Longrightarrow> ((*) x ` A) \\<div> x = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*) x) \\<Longrightarrow> (*) x ` A \\<div> x = A", "by (simp add: quot_set_def inj_vimage_image_eq)"], ["", "subsection \\<open>Direct Decompositions of Polynomial Rings\\<close>"], ["", "context pm_powerprod\nbegin"], ["", "definition normal_form :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) set \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::field) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::field)\"\n  where \"normal_form F p = (SOME q. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and> \\<not> punit.is_red (punit.reduced_GB F) q)\""], ["", "text \\<open>Of course, @{const normal_form} could be defined in a much more general context.\\<close>"], ["", "context\n  fixes X :: \"'x set\"\n  assumes fin_X: \"finite X\"\nbegin"], ["", "context\n  fixes F :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::field) set\"\n  assumes F_sub: \"F \\<subseteq> P[X]\"\nbegin"], ["", "lemma normal_form:\n  shows \"(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\" (is ?thesis1)\n    and \"\\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p) &&&\n    \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n 2. \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"finite (punit.reduced_GB F)\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. finite (punit.reduced_GB F)", "by (rule finite_reduced_GB_Polys)"], ["proof (state)\nthis:\n  finite (punit.reduced_GB F)\n\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n 2. \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "hence \"wfP (punit.red (punit.reduced_GB F))\\<inverse>\\<inverse>\""], ["proof (prove)\nusing this:\n  finite (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. wfP (punit.red (punit.reduced_GB F))\\<inverse>\\<inverse>", "by (rule punit.red_wf_finite)"], ["proof (state)\nthis:\n  wfP (punit.red (punit.reduced_GB F))\\<inverse>\\<inverse>\n\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n 2. \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "then"], ["proof (chain)\npicking this:\n  wfP (punit.red (punit.reduced_GB F))\\<inverse>\\<inverse>", "obtain q where \"(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\"\n    and \"\\<not> punit.is_red (punit.reduced_GB F) q\""], ["proof (prove)\nusing this:\n  wfP (punit.red (punit.reduced_GB F))\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q;\n         \\<not> punit.is_red (punit.reduced_GB F) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding punit.is_red_def not_not"], ["proof (prove)\nusing this:\n  wfP (punit.red (punit.reduced_GB F))\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q;\n         relation.is_final (punit.red (punit.reduced_GB F)) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule relation.wf_imp_nf_ex)"], ["proof (state)\nthis:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\n  \\<not> punit.is_red (punit.reduced_GB F) q\n\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n 2. \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "hence \"(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and> \\<not> punit.is_red (punit.reduced_GB F) q\""], ["proof (prove)\nusing this:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\n  \\<not> punit.is_red (punit.reduced_GB F) q\n\ngoal (1 subgoal):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) q", ".."], ["proof (state)\nthis:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and>\n  \\<not> punit.is_red (punit.reduced_GB F) q\n\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n 2. \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "hence \"?thesis1 \\<and> ?thesis2\""], ["proof (prove)\nusing this:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and>\n  \\<not> punit.is_red (punit.reduced_GB F) q\n\ngoal (1 subgoal):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p\n     (normal_form F p) \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "unfolding normal_form_def"], ["proof (prove)\nusing this:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and>\n  \\<not> punit.is_red (punit.reduced_GB F) q\n\ngoal (1 subgoal):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p\n     (SOME q.\n         (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and>\n         \\<not> punit.is_red (punit.reduced_GB F) q) \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F)\n            (SOME q.\n                (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q \\<and>\n                \\<not> punit.is_red (punit.reduced_GB F) q)", "by (rule someI)"], ["proof (state)\nthis:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p\n   (normal_form F p) \\<and>\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\n\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n 2. \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "thus ?thesis1 and ?thesis2"], ["proof (prove)\nusing this:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p\n   (normal_form F p) \\<and>\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\n\ngoal (1 subgoal):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p) &&&\n    \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "by simp_all"], ["proof (state)\nthis:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_form_unique:\n  assumes \"(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\" and \"\\<not> punit.is_red (punit.reduced_GB F) q\"\n  shows \"normal_form F p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F p = q", "proof (rule relation.ChurchRosser_unique_final)"], ["proof (state)\ngoal (5 subgoals):\n 1. relation.is_ChurchRosser ?r\n 2. ?r\\<^sup>*\\<^sup>* ?a (normal_form F p)\n 3. ?r\\<^sup>*\\<^sup>* ?a q\n 4. relation.is_final ?r (normal_form F p)\n 5. relation.is_final ?r q", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"punit.is_Groebner_basis (punit.reduced_GB F)\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis (punit.reduced_GB F)", "by (rule reduced_GB_is_GB_Polys)"], ["proof (state)\nthis:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n\ngoal (5 subgoals):\n 1. relation.is_ChurchRosser ?r\n 2. ?r\\<^sup>*\\<^sup>* ?a (normal_form F p)\n 3. ?r\\<^sup>*\\<^sup>* ?a q\n 4. relation.is_final ?r (normal_form F p)\n 5. relation.is_final ?r q", "thus \"relation.is_ChurchRosser (punit.red (punit.reduced_GB F))\""], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. relation.is_ChurchRosser (punit.red (punit.reduced_GB F))", "by (simp only: punit.is_Groebner_basis_def)"], ["proof (state)\nthis:\n  relation.is_ChurchRosser (punit.red (punit.reduced_GB F))\n\ngoal (4 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* ?a (normal_form F p)\n 2. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* ?a q\n 3. relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)\n 4. relation.is_final (punit.red (punit.reduced_GB F)) q", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* ?a (normal_form F p)\n 2. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* ?a q\n 3. relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)\n 4. relation.is_final (punit.red (punit.reduced_GB F)) q", "show \"(punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)", "by (rule normal_form)"], ["proof (state)\nthis:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p (normal_form F p)\n\ngoal (3 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\n 2. relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)\n 3. relation.is_final (punit.red (punit.reduced_GB F)) q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\n 2. relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)\n 3. relation.is_final (punit.red (punit.reduced_GB F)) q", "have \"\\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)", "by (rule normal_form)"], ["proof (state)\nthis:\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\n\ngoal (3 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\n 2. relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)\n 3. relation.is_final (punit.red (punit.reduced_GB F)) q", "thus \"relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)\""], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\n\ngoal (1 subgoal):\n 1. relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)", "by (simp add: punit.is_red_def)"], ["proof (state)\nthis:\n  relation.is_final (punit.red (punit.reduced_GB F)) (normal_form F p)\n\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\n 2. relation.is_final (punit.red (punit.reduced_GB F)) q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q\n 2. relation.is_final (punit.red (punit.reduced_GB F)) q", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<not> punit.is_red (punit.reduced_GB F) q", "show \"relation.is_final (punit.red (punit.reduced_GB F)) q\""], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB F) q\n\ngoal (1 subgoal):\n 1. relation.is_final (punit.red (punit.reduced_GB F)) q", "by (simp add: punit.is_red_def)"], ["proof (state)\nthis:\n  relation.is_final (punit.red (punit.reduced_GB F)) q\n\ngoal (1 subgoal):\n 1. (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* p q", "qed fact"], ["", "lemma normal_form_id_iff: \"normal_form F p = p \\<longleftrightarrow> (\\<not> punit.is_red (punit.reduced_GB F) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (normal_form F p = p) = (\\<not> punit.is_red (punit.reduced_GB F) p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. normal_form F p = p \\<Longrightarrow>\n    \\<not> punit.is_red (punit.reduced_GB F) p\n 2. \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    normal_form F p = p", "assume \"normal_form F p = p\""], ["proof (state)\nthis:\n  normal_form F p = p\n\ngoal (2 subgoals):\n 1. normal_form F p = p \\<Longrightarrow>\n    \\<not> punit.is_red (punit.reduced_GB F) p\n 2. \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    normal_form F p = p", "with normal_form(2)[of p]"], ["proof (chain)\npicking this:\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\n  normal_form F p = p", "show \"\\<not> punit.is_red (punit.reduced_GB F) p\""], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F p)\n  normal_form F p = p\n\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB F) p", "by simp"], ["proof (state)\nthis:\n  \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    normal_form F p = p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    normal_form F p = p", "assume \"\\<not> punit.is_red (punit.reduced_GB F) p\""], ["proof (state)\nthis:\n  \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    normal_form F p = p", "with rtranclp.rtrancl_refl"], ["proof (chain)\npicking this:\n  ?r\\<^sup>*\\<^sup>* ?a ?a\n  \\<not> punit.is_red (punit.reduced_GB F) p", "show \"normal_form F p = p\""], ["proof (prove)\nusing this:\n  ?r\\<^sup>*\\<^sup>* ?a ?a\n  \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. normal_form F p = p", "by (rule normal_form_unique)"], ["proof (state)\nthis:\n  normal_form F p = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_form_normal_form: \"normal_form F (normal_form F p) = normal_form F p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F (normal_form F p) = normal_form F p", "by (simp add: normal_form_id_iff normal_form)"], ["", "lemma normal_form_zero: \"normal_form F 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F 0 = 0", "by (simp add: normal_form_id_iff punit.irred_0)"], ["", "lemma normal_form_map_scale: \"normal_form F (c \\<cdot> p) = c \\<cdot> (normal_form F p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F (c \\<cdot> p) = c \\<cdot> normal_form F p", "by (intro normal_form_unique punit.is_irred_map_scale normal_form)\n    (simp add: punit.map_scale_eq_monom_mult punit.red_rtrancl_mult normal_form)"], ["", "lemma normal_form_uminus: \"normal_form F (- p) = - normal_form F p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F (- p) = - normal_form F p", "by (intro normal_form_unique punit.red_rtrancl_uminus normal_form)\n      (simp add: punit.is_red_uminus normal_form)"], ["", "lemma normal_form_plus_normal_form:\n  \"normal_form F (normal_form F p + normal_form F q) = normal_form F p + normal_form F q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F (normal_form F p + normal_form F q) =\n    normal_form F p + normal_form F q", "by (intro normal_form_unique rtranclp.rtrancl_refl punit.is_irred_plus normal_form)"], ["", "lemma normal_form_minus_normal_form:\n  \"normal_form F (normal_form F p - normal_form F q) = normal_form F p - normal_form F q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F (normal_form F p - normal_form F q) =\n    normal_form F p - normal_form F q", "by (intro normal_form_unique rtranclp.rtrancl_refl punit.is_irred_minus normal_form)"], ["", "lemma normal_form_ideal_Polys: \"normal_form (ideal F \\<inter> P[X]) = normal_form F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form (ideal F \\<inter> P[X]) = normal_form F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normal_form (ideal F \\<inter> P[X]) = normal_form F", "let ?F = \"ideal F \\<inter> P[X]\""], ["proof (state)\ngoal (1 subgoal):\n 1. normal_form (ideal F \\<inter> P[X]) = normal_form F", "from fin_X"], ["proof (chain)\npicking this:\n  finite X", "have eq: \"punit.reduced_GB ?F = punit.reduced_GB F\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. punit.reduced_GB (ideal F \\<inter> P[X]) = punit.reduced_GB F", "proof (rule reduced_GB_unique_Polys)"], ["proof (state)\ngoal (3 subgoals):\n 1. ideal F \\<inter> P[X] \\<subseteq> P[X]\n 2. punit.is_reduced_GB (punit.reduced_GB F)\n 3. ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "show \"punit.is_reduced_GB (punit.reduced_GB F)\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.is_reduced_GB (punit.reduced_GB F)", "by (rule reduced_GB_is_reduced_GB_Polys)"], ["proof (state)\nthis:\n  punit.is_reduced_GB (punit.reduced_GB F)\n\ngoal (2 subgoals):\n 1. ideal F \\<inter> P[X] \\<subseteq> P[X]\n 2. ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ideal F \\<inter> P[X] \\<subseteq> P[X]\n 2. ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"ideal (punit.reduced_GB F) = ideal F\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. ideal (punit.reduced_GB F) = ideal F", "by (rule reduced_GB_ideal_Polys)"], ["proof (state)\nthis:\n  ideal (punit.reduced_GB F) = ideal F\n\ngoal (2 subgoals):\n 1. ideal F \\<inter> P[X] \\<subseteq> P[X]\n 2. ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "also"], ["proof (state)\nthis:\n  ideal (punit.reduced_GB F) = ideal F\n\ngoal (2 subgoals):\n 1. ideal F \\<inter> P[X] \\<subseteq> P[X]\n 2. ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "have \"\\<dots> = ideal (ideal F \\<inter> P[X])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F = ideal (ideal F \\<inter> P[X])", "proof (intro subset_antisym ideal.span_subset_spanI)"], ["proof (state)\ngoal (2 subgoals):\n 1. F \\<subseteq> ideal (ideal F \\<inter> P[X])\n 2. ideal F \\<inter> P[X] \\<subseteq> ideal F", "from ideal.span_superset[of F] F_sub"], ["proof (chain)\npicking this:\n  F \\<subseteq> ideal F\n  F \\<subseteq> P[X]", "have \"F \\<subseteq> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> ideal F\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. F \\<subseteq> ideal F \\<inter> P[X]", "by simp"], ["proof (state)\nthis:\n  F \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (2 subgoals):\n 1. F \\<subseteq> ideal (ideal F \\<inter> P[X])\n 2. ideal F \\<inter> P[X] \\<subseteq> ideal F", "thus \"F \\<subseteq> ideal (ideal F \\<inter> P[X])\""], ["proof (prove)\nusing this:\n  F \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. F \\<subseteq> ideal (ideal F \\<inter> P[X])", "using ideal.span_superset"], ["proof (prove)\nusing this:\n  F \\<subseteq> ideal F \\<inter> P[X]\n  ?S \\<subseteq> ideal ?S\n\ngoal (1 subgoal):\n 1. F \\<subseteq> ideal (ideal F \\<inter> P[X])", "by (rule subset_trans)"], ["proof (state)\nthis:\n  F \\<subseteq> ideal (ideal F \\<inter> P[X])\n\ngoal (1 subgoal):\n 1. ideal F \\<inter> P[X] \\<subseteq> ideal F", "qed blast"], ["proof (state)\nthis:\n  ideal F = ideal (ideal F \\<inter> P[X])\n\ngoal (2 subgoals):\n 1. ideal F \\<inter> P[X] \\<subseteq> P[X]\n 2. ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "finally"], ["proof (chain)\npicking this:\n  ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "show \"ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])\""], ["proof (prove)\nusing this:\n  ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])\n\ngoal (1 subgoal):\n 1. ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])", "."], ["proof (state)\nthis:\n  ideal (punit.reduced_GB F) = ideal (ideal F \\<inter> P[X])\n\ngoal (1 subgoal):\n 1. ideal F \\<inter> P[X] \\<subseteq> P[X]", "qed blast"], ["proof (state)\nthis:\n  punit.reduced_GB (ideal F \\<inter> P[X]) = punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. normal_form (ideal F \\<inter> P[X]) = normal_form F", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form (ideal F \\<inter> P[X]) = normal_form F", "by (rule ext) (simp only: normal_form_def eq)"], ["proof (state)\nthis:\n  normal_form (ideal F \\<inter> P[X]) = normal_form F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_form_diff_in_ideal: \"p - normal_form F p \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - normal_form F p \\<in> ideal F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p - normal_form F p \\<in> ideal F", "from normal_form(1)"], ["proof (chain)\npicking this:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* ?p (normal_form F ?p)", "have \"p - normal_form F p \\<in> ideal (punit.reduced_GB F)\""], ["proof (prove)\nusing this:\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* ?p (normal_form F ?p)\n\ngoal (1 subgoal):\n 1. p - normal_form F p \\<in> ideal (punit.reduced_GB F)", "by (rule punit.red_rtranclp_diff_in_pmdl[simplified])"], ["proof (state)\nthis:\n  p - normal_form F p \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. p - normal_form F p \\<in> ideal F", "also"], ["proof (state)\nthis:\n  p - normal_form F p \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. p - normal_form F p \\<in> ideal F", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"\\<dots> = ideal F\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. ideal (punit.reduced_GB F) = ideal F", "by (rule reduced_GB_ideal_Polys)"], ["proof (state)\nthis:\n  ideal (punit.reduced_GB F) = ideal F\n\ngoal (1 subgoal):\n 1. p - normal_form F p \\<in> ideal F", "finally"], ["proof (chain)\npicking this:\n  p - normal_form F p \\<in> ideal F", "show ?thesis"], ["proof (prove)\nusing this:\n  p - normal_form F p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - normal_form F p \\<in> ideal F", "."], ["proof (state)\nthis:\n  p - normal_form F p \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_form_zero_iff: \"normal_form F p = 0 \\<longleftrightarrow> p \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (normal_form F p = 0) = (p \\<in> ideal F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. normal_form F p = 0 \\<Longrightarrow> p \\<in> ideal F\n 2. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "assume \"normal_form F p = 0\""], ["proof (state)\nthis:\n  normal_form F p = 0\n\ngoal (2 subgoals):\n 1. normal_form F p = 0 \\<Longrightarrow> p \\<in> ideal F\n 2. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "with normal_form_diff_in_ideal[of p]"], ["proof (chain)\npicking this:\n  p - normal_form F p \\<in> ideal F\n  normal_form F p = 0", "show \"p \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p - normal_form F p \\<in> ideal F\n  normal_form F p = 0\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "assume \"p \\<in> ideal F\""], ["proof (state)\nthis:\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "hence \"p - (p - normal_form F p) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - (p - normal_form F p) \\<in> ideal F", "using normal_form_diff_in_ideal"], ["proof (prove)\nusing this:\n  p \\<in> ideal F\n  ?p - normal_form F ?p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - (p - normal_form F p) \\<in> ideal F", "by (rule ideal.span_diff)"], ["proof (state)\nthis:\n  p - (p - normal_form F p) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "also"], ["proof (state)\nthis:\n  p - (p - normal_form F p) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"\\<dots> = ideal (punit.reduced_GB F)\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. ideal F = ideal (punit.reduced_GB F)", "by (rule reduced_GB_ideal_Polys[symmetric])"], ["proof (state)\nthis:\n  ideal F = ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "finally"], ["proof (chain)\npicking this:\n  p - (p - normal_form F p) \\<in> ideal (punit.reduced_GB F)", "have *: \"normal_form F p \\<in> ideal (punit.reduced_GB F)\""], ["proof (prove)\nusing this:\n  p - (p - normal_form F p) \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<in> ideal (punit.reduced_GB F)", "by simp"], ["proof (state)\nthis:\n  normal_form F p \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F \\<Longrightarrow> normal_form F p = 0", "show \"normal_form F p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F p = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"punit.is_Groebner_basis (punit.reduced_GB F)\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis (punit.reduced_GB F)", "by (rule reduced_GB_is_GB_Polys)"], ["proof (state)\nthis:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "note *"], ["proof (state)\nthis:\n  normal_form F p \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  normal_form F p \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "assume \"normal_form F p \\<noteq> 0\""], ["proof (state)\nthis:\n  normal_form F p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n  normal_form F p \\<in> ideal (punit.reduced_GB F)\n  normal_form F p \\<noteq> 0", "obtain g where \"g \\<in> punit.reduced_GB F\" and \"g \\<noteq> 0\"\n      and a: \"lpp g adds lpp (normal_form F p)\""], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n  normal_form F p \\<in> ideal (punit.reduced_GB F)\n  normal_form F p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> punit.reduced_GB F; g \\<noteq> 0;\n         lpp g adds lpp (normal_form F p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.GB_adds_lt[simplified])"], ["proof (state)\nthis:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  lpp g adds lpp (normal_form F p)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "note this(1, 2)"], ["proof (state)\nthis:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "from \\<open>normal_form F p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  normal_form F p \\<noteq> 0", "have \"lpp (normal_form F p) \\<in> keys (normal_form F p)\""], ["proof (prove)\nusing this:\n  normal_form F p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp (normal_form F p) \\<in> keys (normal_form F p)", "by (rule punit.lt_in_keys)"], ["proof (state)\nthis:\n  lpp (normal_form F p) \\<in> keys (normal_form F p)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  lpp (normal_form F p) \\<in> keys (normal_form F p)", "have \"punit.is_red (punit.reduced_GB F) (normal_form F p)\""], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  lpp (normal_form F p) \\<in> keys (normal_form F p)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) (normal_form F p)", "using a"], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  lpp (normal_form F p) \\<in> keys (normal_form F p)\n  lpp g adds lpp (normal_form F p)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) (normal_form F p)", "by (rule punit.is_red_addsI[simplified])"], ["proof (state)\nthis:\n  punit.is_red (punit.reduced_GB F) (normal_form F p)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<noteq> 0 \\<Longrightarrow> False", "with normal_form(2)"], ["proof (chain)\npicking this:\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F ?p)\n  punit.is_red (punit.reduced_GB F) (normal_form F p)", "show False"], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB F) (normal_form F ?p)\n  punit.is_red (punit.reduced_GB F) (normal_form F p)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normal_form F p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_form_eq_iff: \"normal_form F p = normal_form F q \\<longleftrightarrow> p - q \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)", "have \"p - q - (normal_form F p - normal_form F q) = (p - normal_form F p) - (q - normal_form F q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - q - (normal_form F p - normal_form F q) =\n    p - normal_form F p - (q - normal_form F q)", "by simp"], ["proof (state)\nthis:\n  p - q - (normal_form F p - normal_form F q) =\n  p - normal_form F p - (q - normal_form F q)\n\ngoal (1 subgoal):\n 1. (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)", "also"], ["proof (state)\nthis:\n  p - q - (normal_form F p - normal_form F q) =\n  p - normal_form F p - (q - normal_form F q)\n\ngoal (1 subgoal):\n 1. (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)", "from normal_form_diff_in_ideal normal_form_diff_in_ideal"], ["proof (chain)\npicking this:\n  ?p - normal_form F ?p \\<in> ideal F\n  ?p - normal_form F ?p \\<in> ideal F", "have \"\\<dots> \\<in> ideal F\""], ["proof (prove)\nusing this:\n  ?p - normal_form F ?p \\<in> ideal F\n  ?p - normal_form F ?p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - normal_form F p - (q - normal_form F q) \\<in> ideal F", "by (rule ideal.span_diff)"], ["proof (state)\nthis:\n  p - normal_form F p - (q - normal_form F q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)", "finally"], ["proof (chain)\npicking this:\n  p - q - (normal_form F p - normal_form F q) \\<in> ideal F", "have *: \"p - q - (normal_form F p - normal_form F q) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p - q - (normal_form F p - normal_form F q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - q - (normal_form F p - normal_form F q) \\<in> ideal F", "."], ["proof (state)\nthis:\n  p - q - (normal_form F p - normal_form F q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. normal_form F p = normal_form F q \\<Longrightarrow> p - q \\<in> ideal F\n 2. p - q \\<in> ideal F \\<Longrightarrow> normal_form F p = normal_form F q", "assume \"normal_form F p = normal_form F q\""], ["proof (state)\nthis:\n  normal_form F p = normal_form F q\n\ngoal (2 subgoals):\n 1. normal_form F p = normal_form F q \\<Longrightarrow> p - q \\<in> ideal F\n 2. p - q \\<in> ideal F \\<Longrightarrow> normal_form F p = normal_form F q", "with *"], ["proof (chain)\npicking this:\n  p - q - (normal_form F p - normal_form F q) \\<in> ideal F\n  normal_form F p = normal_form F q", "show \"p - q \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p - q - (normal_form F p - normal_form F q) \\<in> ideal F\n  normal_form F p = normal_form F q\n\ngoal (1 subgoal):\n 1. p - q \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  p - q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - q \\<in> ideal F \\<Longrightarrow> normal_form F p = normal_form F q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p - q \\<in> ideal F \\<Longrightarrow> normal_form F p = normal_form F q", "assume \"p - q \\<in> ideal F\""], ["proof (state)\nthis:\n  p - q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - q \\<in> ideal F \\<Longrightarrow> normal_form F p = normal_form F q", "hence \"p - q - (p - q - (normal_form F p - normal_form F q)) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p - q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - q - (p - q - (normal_form F p - normal_form F q)) \\<in> ideal F", "using *"], ["proof (prove)\nusing this:\n  p - q \\<in> ideal F\n  p - q - (normal_form F p - normal_form F q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - q - (p - q - (normal_form F p - normal_form F q)) \\<in> ideal F", "by (rule ideal.span_diff)"], ["proof (state)\nthis:\n  p - q - (p - q - (normal_form F p - normal_form F q)) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p - q \\<in> ideal F \\<Longrightarrow> normal_form F p = normal_form F q", "hence \"normal_form F (normal_form F p - normal_form F q) = 0\""], ["proof (prove)\nusing this:\n  p - q - (p - q - (normal_form F p - normal_form F q)) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. normal_form F (normal_form F p - normal_form F q) = 0", "by (simp add: normal_form_zero_iff)"], ["proof (state)\nthis:\n  normal_form F (normal_form F p - normal_form F q) = 0\n\ngoal (1 subgoal):\n 1. p - q \\<in> ideal F \\<Longrightarrow> normal_form F p = normal_form F q", "thus \"normal_form F p = normal_form F q\""], ["proof (prove)\nusing this:\n  normal_form F (normal_form F p - normal_form F q) = 0\n\ngoal (1 subgoal):\n 1. normal_form F p = normal_form F q", "by (simp add: normal_form_minus_normal_form)"], ["proof (state)\nthis:\n  normal_form F p = normal_form F q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (normal_form F p = normal_form F q) = (p - q \\<in> ideal F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Polys_closed_normal_form:\n  assumes \"p \\<in> P[X]\"\n  shows \"normal_form F p \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form F p \\<in> P[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normal_form F p \\<in> P[X]", "from fin_X F_sub"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"punit.reduced_GB F \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.reduced_GB F \\<subseteq> P[X]", "by (rule reduced_GB_Polys)"], ["proof (state)\nthis:\n  punit.reduced_GB F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. normal_form F p \\<in> P[X]", "with fin_X"], ["proof (chain)\npicking this:\n  finite X\n  punit.reduced_GB F \\<subseteq> P[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  finite X\n  punit.reduced_GB F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. normal_form F p \\<in> P[X]", "using assms normal_form(1)"], ["proof (prove)\nusing this:\n  finite X\n  punit.reduced_GB F \\<subseteq> P[X]\n  p \\<in> P[X]\n  (punit.red (punit.reduced_GB F))\\<^sup>*\\<^sup>* ?p (normal_form F ?p)\n\ngoal (1 subgoal):\n 1. normal_form F p \\<in> P[X]", "by (rule punit.dgrad_p_set_closed_red_rtrancl[OF dickson_grading_varnum, where m=0, simplified dgrad_p_set_varnum])"], ["proof (state)\nthis:\n  normal_form F p \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_normal_form_iff:\n  \"p \\<in> normal_form F ` P[X] \\<longleftrightarrow> (p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> normal_form F ` P[X]) =\n    (p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<in> normal_form F ` P[X] \\<Longrightarrow>\n    p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\n 2. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "assume \"p \\<in> normal_form F ` P[X]\""], ["proof (state)\nthis:\n  p \\<in> normal_form F ` P[X]\n\ngoal (2 subgoals):\n 1. p \\<in> normal_form F ` P[X] \\<Longrightarrow>\n    p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\n 2. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "then"], ["proof (chain)\npicking this:\n  p \\<in> normal_form F ` P[X]", "obtain q where \"q \\<in> P[X]\" and p: \"p = normal_form F q\""], ["proof (prove)\nusing this:\n  p \\<in> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[X]; p = normal_form F q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<in> P[X]\n  p = normal_form F q\n\ngoal (2 subgoals):\n 1. p \\<in> normal_form F ` P[X] \\<Longrightarrow>\n    p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\n 2. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "from this(1)"], ["proof (chain)\npicking this:\n  q \\<in> P[X]", "show \"p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\""], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p", "unfolding p"], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. normal_form F q \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) (normal_form F q)", "by (intro conjI Polys_closed_normal_form normal_form)"], ["proof (state)\nthis:\n  p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "assume \"p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\""], ["proof (state)\nthis:\n  p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "hence \"p \\<in> P[X]\" and \"\\<not> punit.is_red (punit.reduced_GB F) p\""], ["proof (prove)\nusing this:\n  p \\<in> P[X] \\<and> \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] &&& \\<not> punit.is_red (punit.reduced_GB F) p", "by simp_all"], ["proof (state)\nthis:\n  p \\<in> P[X]\n  \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "from this(2)"], ["proof (chain)\npicking this:\n  \\<not> punit.is_red (punit.reduced_GB F) p", "have \"normal_form F p = p\""], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB F) p\n\ngoal (1 subgoal):\n 1. normal_form F p = p", "by (simp add: normal_form_id_iff)"], ["proof (state)\nthis:\n  normal_form F p = p\n\ngoal (1 subgoal):\n 1. p \\<in> P[X] \\<and>\n    \\<not> punit.is_red (punit.reduced_GB F) p \\<Longrightarrow>\n    p \\<in> normal_form F ` P[X]", "from this[symmetric] \\<open>p \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  p = normal_form F p\n  p \\<in> P[X]", "show \"p \\<in> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  p = normal_form F p\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. p \\<in> normal_form F ` P[X]", "by (rule image_eqI)"], ["proof (state)\nthis:\n  p \\<in> normal_form F ` P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma direct_decomp_ideal_insert:\n  fixes F and f\n  defines \"I \\<equiv> ideal (insert f F)\"\n  defines \"L \\<equiv> (ideal F \\<div> f) \\<inter> P[X]\"\n  assumes \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\"\n  shows \"direct_decomp (I \\<inter> P[X]) [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\"\n    (is \"direct_decomp _ ?ss\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (I \\<inter> P[X])\n     [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]", "proof (rule direct_decompI_alt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<Longrightarrow>\n       sum_list qs \\<in> I \\<inter> P[X]\n 2. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "fix qs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<Longrightarrow>\n       sum_list qs \\<in> I \\<inter> P[X]\n 2. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "assume \"qs \\<in> listset ?ss\""], ["proof (state)\nthis:\n  qs \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<Longrightarrow>\n       sum_list qs \\<in> I \\<inter> P[X]\n 2. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "then"], ["proof (chain)\npicking this:\n  qs \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]", "obtain x y where x: \"x \\<in> ideal F \\<inter> P[X]\" and y: \"y \\<in> (*) f ` normal_form L ` P[X]\"\n    and qs: \"qs = [x, y]\""], ["proof (prove)\nusing this:\n  qs \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> ideal F \\<inter> P[X];\n         y \\<in> (*) f ` normal_form L ` P[X]; qs = [x, y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  x \\<in> ideal F \\<inter> P[X]\n  y \\<in> (*) f ` normal_form L ` P[X]\n  qs = [x, y]\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<Longrightarrow>\n       sum_list qs \\<in> I \\<inter> P[X]\n 2. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "have \"sum_list qs = x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list qs = x + y", "by (simp add: qs)"], ["proof (state)\nthis:\n  sum_list qs = x + y\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<Longrightarrow>\n       sum_list qs \\<in> I \\<inter> P[X]\n 2. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "also"], ["proof (state)\nthis:\n  sum_list qs = x + y\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<Longrightarrow>\n       sum_list qs \\<in> I \\<inter> P[X]\n 2. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "have \"\\<dots> \\<in> I \\<inter> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> I \\<inter> P[X]", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> ideal (insert f F) \\<inter> P[X]", "proof (intro IntI ideal.span_add Polys_closed_plus)"], ["proof (state)\ngoal (4 subgoals):\n 1. x \\<in> ideal (insert f F)\n 2. y \\<in> ideal (insert f F)\n 3. x \\<in> P[X]\n 4. y \\<in> P[X]", "have \"ideal F \\<subseteq> ideal (insert f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F \\<subseteq> ideal (insert f F)", "by (rule ideal.span_mono) blast"], ["proof (state)\nthis:\n  ideal F \\<subseteq> ideal (insert f F)\n\ngoal (4 subgoals):\n 1. x \\<in> ideal (insert f F)\n 2. y \\<in> ideal (insert f F)\n 3. x \\<in> P[X]\n 4. y \\<in> P[X]", "with x"], ["proof (chain)\npicking this:\n  x \\<in> ideal F \\<inter> P[X]\n  ideal F \\<subseteq> ideal (insert f F)", "show \"x \\<in> ideal (insert f F)\" and \"x \\<in> P[X]\""], ["proof (prove)\nusing this:\n  x \\<in> ideal F \\<inter> P[X]\n  ideal F \\<subseteq> ideal (insert f F)\n\ngoal (1 subgoal):\n 1. x \\<in> ideal (insert f F) &&& x \\<in> P[X]", "by blast+"], ["proof (state)\nthis:\n  x \\<in> ideal (insert f F)\n  x \\<in> P[X]\n\ngoal (2 subgoals):\n 1. y \\<in> ideal (insert f F)\n 2. y \\<in> P[X]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> ideal (insert f F)\n 2. y \\<in> P[X]", "from y"], ["proof (chain)\npicking this:\n  y \\<in> (*) f ` normal_form L ` P[X]", "obtain p where \"p \\<in> P[X]\" and y: \"y = f * normal_form L p\""], ["proof (prove)\nusing this:\n  y \\<in> (*) f ` normal_form L ` P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> P[X]; y = f * normal_form L p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> P[X]\n  y = f * normal_form L p\n\ngoal (2 subgoals):\n 1. y \\<in> ideal (insert f F)\n 2. y \\<in> P[X]", "have \"f \\<in> ideal (insert f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> ideal (insert f F)", "by (rule ideal.span_base) simp"], ["proof (state)\nthis:\n  f \\<in> ideal (insert f F)\n\ngoal (2 subgoals):\n 1. y \\<in> ideal (insert f F)\n 2. y \\<in> P[X]", "hence \"normal_form L p * f \\<in> ideal (insert f F)\""], ["proof (prove)\nusing this:\n  f \\<in> ideal (insert f F)\n\ngoal (1 subgoal):\n 1. normal_form L p * f \\<in> ideal (insert f F)", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  normal_form L p * f \\<in> ideal (insert f F)\n\ngoal (2 subgoals):\n 1. y \\<in> ideal (insert f F)\n 2. y \\<in> P[X]", "thus \"y \\<in> ideal (insert f F)\""], ["proof (prove)\nusing this:\n  normal_form L p * f \\<in> ideal (insert f F)\n\ngoal (1 subgoal):\n 1. y \\<in> ideal (insert f F)", "by (simp only: mult.commute y)"], ["proof (state)\nthis:\n  y \\<in> ideal (insert f F)\n\ngoal (1 subgoal):\n 1. y \\<in> P[X]", "have \"L \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<subseteq> P[X]", "by (simp add: L_def)"], ["proof (state)\nthis:\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. y \\<in> P[X]", "hence \"normal_form L p \\<in> P[X]\""], ["proof (prove)\nusing this:\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L p \\<in> P[X]", "using \\<open>p \\<in> P[X]\\<close>"], ["proof (prove)\nusing this:\n  L \\<subseteq> P[X]\n  p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L p \\<in> P[X]", "by (rule Polys_closed_normal_form)"], ["proof (state)\nthis:\n  normal_form L p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. y \\<in> P[X]", "with assms(4)"], ["proof (chain)\npicking this:\n  f \\<in> P[X]\n  normal_form L p \\<in> P[X]", "show \"y \\<in> P[X]\""], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n  normal_form L p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. y \\<in> P[X]", "unfolding y"], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n  normal_form L p \\<in> P[X]\n\ngoal (1 subgoal):\n 1. f * normal_form L p \\<in> P[X]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  y \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x + y \\<in> I \\<inter> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<Longrightarrow>\n       sum_list qs \\<in> I \\<inter> P[X]\n 2. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "finally"], ["proof (chain)\npicking this:\n  sum_list qs \\<in> I \\<inter> P[X]", "show \"sum_list qs \\<in> I \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  sum_list qs \\<in> I \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. sum_list qs \\<in> I \\<inter> P[X]", "."], ["proof (state)\nthis:\n  sum_list qs \\<in> I \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "assume \"a \\<in> I \\<inter> P[X]\""], ["proof (state)\nthis:\n  a \\<in> I \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "hence \"a \\<in> I\" and \"a \\<in> P[X]\""], ["proof (prove)\nusing this:\n  a \\<in> I \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. a \\<in> I &&& a \\<in> P[X]", "by simp_all"], ["proof (state)\nthis:\n  a \\<in> I\n  a \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "from assms(3, 4)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  f \\<in> P[X]", "have \"insert f F \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. insert f F \\<subseteq> P[X]", "by simp"], ["proof (state)\nthis:\n  insert f F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "then"], ["proof (chain)\npicking this:\n  insert f F \\<subseteq> P[X]", "obtain F0 q0 where \"F0 \\<subseteq> insert f F\" and \"finite F0\" and q0: \"\\<And>f0. q0 f0 \\<in> P[X]\"\n    and a: \"a = (\\<Sum>f0\\<in>F0. q0 f0 * f0)\""], ["proof (prove)\nusing this:\n  insert f F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>F0 q0.\n        \\<lbrakk>F0 \\<subseteq> insert f F; finite F0;\n         \\<And>f0. q0 f0 \\<in> P[X];\n         a = (\\<Sum>f0\\<in>F0. q0 f0 * f0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>a \\<in> P[X]\\<close> \\<open>a \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  insert f F \\<subseteq> P[X]\n  a \\<in> P[X]\n  a \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>F0 q0.\n        \\<lbrakk>F0 \\<subseteq> insert f F; finite F0;\n         \\<And>f0. q0 f0 \\<in> P[X];\n         a = (\\<Sum>f0\\<in>F0. q0 f0 * f0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding I_def"], ["proof (prove)\nusing this:\n  insert f F \\<subseteq> P[X]\n  a \\<in> P[X]\n  a \\<in> ideal (insert f F)\n\ngoal (1 subgoal):\n 1. (\\<And>F0 q0.\n        \\<lbrakk>F0 \\<subseteq> insert f F; finite F0;\n         \\<And>f0. q0 f0 \\<in> P[X];\n         a = (\\<Sum>f0\\<in>F0. q0 f0 * f0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_idealE_Polys) blast"], ["proof (state)\nthis:\n  F0 \\<subseteq> insert f F\n  finite F0\n  q0 ?f0.6 \\<in> P[X]\n  a = (\\<Sum>f0\\<in>F0. q0 f0 * f0)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "obtain q a' where a': \"a' \\<in> ideal F\" and \"a' \\<in> P[X]\" and \"q \\<in> P[X]\" and a: \"a = q * f + a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' q.\n        \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n         a = q * f + a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"f \\<in> F0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<in> F0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<notin> F0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  f \\<in> F0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<in> F0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<notin> F0\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>F0 \\<subseteq> insert f F\\<close>"], ["proof (chain)\npicking this:\n  F0 \\<subseteq> insert f F\n  f \\<in> F0", "have \"F0 - {f} \\<subseteq> F\""], ["proof (prove)\nusing this:\n  F0 \\<subseteq> insert f F\n  f \\<in> F0\n\ngoal (1 subgoal):\n 1. F0 - {f} \\<subseteq> F", "by blast"], ["proof (state)\nthis:\n  F0 - {f} \\<subseteq> F\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<in> F0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<notin> F0\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "have \"(\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal (F0 - {f})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal (F0 - {f})", "by (rule ideal.sum_in_spanI)"], ["proof (state)\nthis:\n  (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal (F0 - {f})\n\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "also"], ["proof (state)\nthis:\n  (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal (F0 - {f})\n\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "from \\<open>F0 - {f} \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F0 - {f} \\<subseteq> F", "have \"\\<dots> \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  F0 - {f} \\<subseteq> F\n\ngoal (1 subgoal):\n 1. ideal (F0 - {f}) \\<subseteq> ideal F", "by (rule ideal.span_mono)"], ["proof (state)\nthis:\n  ideal (F0 - {f}) \\<subseteq> ideal F\n\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal F", "show \"(\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal F", "."], ["proof (state)\nthis:\n  (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> ideal F\n\ngoal (3 subgoals):\n 1. (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> P[X]\n 2. ?q6 \\<in> P[X]\n 3. a = ?q6 * f + (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> P[X]\n 2. ?q6 \\<in> P[X]\n 3. a = ?q6 * f + (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0)", "show \"(\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> P[X]", "proof (intro Polys_closed_sum Polys_closed_times q0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "fix f0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "assume \"f0 \\<in> F0 - {f}\""], ["proof (state)\nthis:\n  f0 \\<in> F0 - {f}\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "also"], ["proof (state)\nthis:\n  f0 \\<in> F0 - {f}\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "have \"\\<dots> \\<subseteq> F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F0 - {f} \\<subseteq> F0", "by blast"], ["proof (state)\nthis:\n  F0 - {f} \\<subseteq> F0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "also"], ["proof (state)\nthis:\n  F0 - {f} \\<subseteq> F0\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "have \"\\<dots> \\<subseteq> insert f F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F0 \\<subseteq> insert f F", "by fact"], ["proof (state)\nthis:\n  F0 \\<subseteq> insert f F\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "also"], ["proof (state)\nthis:\n  F0 \\<subseteq> insert f F\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "have \"\\<dots> \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert f F \\<subseteq> P[X]", "by fact"], ["proof (state)\nthis:\n  insert f F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> F0 - {f} \\<Longrightarrow> a \\<in> P[X]", "finally"], ["proof (chain)\npicking this:\n  f0 \\<in> P[X]", "show \"f0 \\<in> P[X]\""], ["proof (prove)\nusing this:\n  f0 \\<in> P[X]\n\ngoal (1 subgoal):\n 1. f0 \\<in> P[X]", "."], ["proof (state)\nthis:\n  f0 \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0) \\<in> P[X]\n\ngoal (2 subgoals):\n 1. ?q6 \\<in> P[X]\n 2. a = ?q6 * f + (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ?q6 \\<in> P[X]\n 2. a = ?q6 * f + (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0)", "from \\<open>finite F0\\<close> True"], ["proof (chain)\npicking this:\n  finite F0\n  f \\<in> F0", "show \"a = q0 f * f + (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0)\""], ["proof (prove)\nusing this:\n  finite F0\n  f \\<in> F0\n\ngoal (1 subgoal):\n 1. a = q0 f * f + (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0)", "by (simp only: a sum.remove)"], ["proof (state)\nthis:\n  a = q0 f * f + (\\<Sum>f0\\<in>F0 - {f}. q0 f0 * f0)\n\ngoal (1 subgoal):\n 1. q0 f \\<in> P[X]", "qed fact"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<notin> F0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<notin> F0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  f \\<notin> F0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<notin> F0\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>F0 \\<subseteq> insert f F\\<close>"], ["proof (chain)\npicking this:\n  F0 \\<subseteq> insert f F\n  f \\<notin> F0", "have \"F0 \\<subseteq> F\""], ["proof (prove)\nusing this:\n  F0 \\<subseteq> insert f F\n  f \\<notin> F0\n\ngoal (1 subgoal):\n 1. F0 \\<subseteq> F", "by blast"], ["proof (state)\nthis:\n  F0 \\<subseteq> F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a' q.\n                \\<lbrakk>a' \\<in> ideal F; a' \\<in> P[X]; q \\<in> P[X];\n                 a = q * f + a'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     f \\<notin> F0\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "have \"a \\<in> ideal F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> ideal F0", "unfolding a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f0\\<in>F0. q0 f0 * f0) \\<in> ideal F0", "by (rule ideal.sum_in_spanI)"], ["proof (state)\nthis:\n  a \\<in> ideal F0\n\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "also"], ["proof (state)\nthis:\n  a \\<in> ideal F0\n\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "from \\<open>F0 \\<subseteq> F\\<close>"], ["proof (chain)\npicking this:\n  F0 \\<subseteq> F", "have \"\\<dots> \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  F0 \\<subseteq> F\n\ngoal (1 subgoal):\n 1. ideal F0 \\<subseteq> ideal F", "by (rule ideal.span_mono)"], ["proof (state)\nthis:\n  ideal F0 \\<subseteq> ideal F\n\ngoal (4 subgoals):\n 1. ?a'6 \\<in> ideal F\n 2. ?a'6 \\<in> P[X]\n 3. ?q6 \\<in> P[X]\n 4. a = ?q6 * f + ?a'6", "finally"], ["proof (chain)\npicking this:\n  a \\<in> ideal F", "show \"a \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a \\<in> ideal F", "."], ["proof (state)\nthis:\n  a \\<in> ideal F\n\ngoal (3 subgoals):\n 1. a \\<in> P[X]\n 2. ?q6 \\<in> P[X]\n 3. a = ?q6 * f + a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<in> P[X]\n 2. ?q6 \\<in> P[X]\n 3. a = ?q6 * f + a", "show \"a = 0 * f + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = 0 * f + a", "by simp"], ["proof (state)\nthis:\n  a = 0 * f + a\n\ngoal (2 subgoals):\n 1. a \\<in> P[X]\n 2. 0 \\<in> P[X]", "qed (fact \\<open>a \\<in> P[X]\\<close>, fact zero_in_Polys)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a' \\<in> ideal F\n  a' \\<in> P[X]\n  q \\<in> P[X]\n  a = q * f + a'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "let ?a = \"f * (normal_form L q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "have \"L \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<subseteq> P[X]", "by (simp add: L_def)"], ["proof (state)\nthis:\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "hence \"normal_form L q \\<in> P[X]\""], ["proof (prove)\nusing this:\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L q \\<in> P[X]", "using \\<open>q \\<in> P[X]\\<close>"], ["proof (prove)\nusing this:\n  L \\<subseteq> P[X]\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L q \\<in> P[X]", "by (rule Polys_closed_normal_form)"], ["proof (state)\nthis:\n  normal_form L q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "with assms(4)"], ["proof (chain)\npicking this:\n  f \\<in> P[X]\n  normal_form L q \\<in> P[X]", "have \"?a \\<in> P[X]\""], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n  normal_form L q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. f * normal_form L q \\<in> P[X]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  f * normal_form L q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "from \\<open>L \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  L \\<subseteq> P[X]", "have \"q - normal_form L q \\<in> ideal L\""], ["proof (prove)\nusing this:\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. q - normal_form L q \\<in> ideal L", "by (rule normal_form_diff_in_ideal)"], ["proof (state)\nthis:\n  q - normal_form L q \\<in> ideal L\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "also"], ["proof (state)\nthis:\n  q - normal_form L q \\<in> ideal L\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "have \"\\<dots> \\<subseteq> ideal (ideal F \\<div> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal L \\<subseteq> ideal (ideal F \\<div> f)", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal ((ideal F \\<div> f) \\<inter> P[X])\n    \\<subseteq> ideal (ideal F \\<div> f)", "by (rule ideal.span_mono) blast"], ["proof (state)\nthis:\n  ideal L \\<subseteq> ideal (ideal F \\<div> f)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "finally"], ["proof (chain)\npicking this:\n  q - normal_form L q \\<in> ideal (ideal F \\<div> f)", "have \"f * (q - normal_form L q) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  q - normal_form L q \\<in> ideal (ideal F \\<div> f)\n\ngoal (1 subgoal):\n 1. f * (q - normal_form L q) \\<in> ideal F", "by (simp add: quot_set_iff)"], ["proof (state)\nthis:\n  f * (q - normal_form L q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "with \\<open>a' \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  a' \\<in> ideal F\n  f * (q - normal_form L q) \\<in> ideal F", "have \"a' + f * (q - normal_form L q) \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a' \\<in> ideal F\n  f * (q - normal_form L q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a' + f * (q - normal_form L q) \\<in> ideal F", "by (rule ideal.span_add)"], ["proof (state)\nthis:\n  a' + f * (q - normal_form L q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "hence \"a - ?a \\<in> ideal F\""], ["proof (prove)\nusing this:\n  a' + f * (q - normal_form L q) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a - f * normal_form L q \\<in> ideal F", "by (simp add: a algebra_simps)"], ["proof (state)\nthis:\n  a - f * normal_form L q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "define qs where \"qs = [a - ?a, ?a]\""], ["proof (state)\nthis:\n  qs = [a - f * normal_form L q, f * normal_form L q]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> I \\<inter> P[X] \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset\n                    [ideal F \\<inter> P[X],\n                     (*) f ` normal_form L ` P[X]] \\<and>\n          a = sum_list qs", "show \"\\<exists>!qs\\<in>listset ?ss. a = sum_list qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qs", "proof (intro ex1I conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?a \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "have \"a - ?a \\<in> ideal F \\<inter> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - f * normal_form L q \\<in> ideal F \\<inter> P[X]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a - f * normal_form L q \\<in> ideal F\n 2. a - f * normal_form L q \\<in> P[X]", "from assms(4) \\<open>a \\<in> P[X]\\<close> \\<open>normal_form L q \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> P[X]\n  a \\<in> P[X]\n  normal_form L q \\<in> P[X]", "show \"a - ?a \\<in> P[X]\""], ["proof (prove)\nusing this:\n  f \\<in> P[X]\n  a \\<in> P[X]\n  normal_form L q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. a - f * normal_form L q \\<in> P[X]", "by (intro Polys_closed_minus Polys_closed_times)"], ["proof (state)\nthis:\n  a - f * normal_form L q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. a - f * normal_form L q \\<in> ideal F", "qed fact"], ["proof (state)\nthis:\n  a - f * normal_form L q \\<in> ideal F \\<inter> P[X]\n\ngoal (3 subgoals):\n 1. ?a \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "moreover"], ["proof (state)\nthis:\n  a - f * normal_form L q \\<in> ideal F \\<inter> P[X]\n\ngoal (3 subgoals):\n 1. ?a \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "from \\<open>q \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[X]", "have \"?a \\<in> (*) f ` normal_form L ` P[X]\""], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. f * normal_form L q \\<in> (*) f ` normal_form L ` P[X]", "by (intro imageI)"], ["proof (state)\nthis:\n  f * normal_form L q \\<in> (*) f ` normal_form L ` P[X]\n\ngoal (3 subgoals):\n 1. ?a \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset\n                 [ideal F \\<inter> P[X],\n                  (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "ultimately"], ["proof (chain)\npicking this:\n  a - f * normal_form L q \\<in> ideal F \\<inter> P[X]\n  f * normal_form L q \\<in> (*) f ` normal_form L ` P[X]", "show \"qs \\<in> listset ?ss\""], ["proof (prove)\nusing this:\n  a - f * normal_form L q \\<in> ideal F \\<inter> P[X]\n  f * normal_form L q \\<in> (*) f ` normal_form L ` P[X]\n\ngoal (1 subgoal):\n 1. qs \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]", "using qs_def"], ["proof (prove)\nusing this:\n  a - f * normal_form L q \\<in> ideal F \\<inter> P[X]\n  f * normal_form L q \\<in> (*) f ` normal_form L ` P[X]\n  qs = [a - f * normal_form L q, f * normal_form L q]\n\ngoal (1 subgoal):\n 1. qs \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]", "by (rule listset_doubletonI)"], ["proof (state)\nthis:\n  qs \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "fix qs0"], ["proof (state)\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "assume \"qs0 \\<in> listset ?ss \\<and> a = sum_list qs0\""], ["proof (state)\nthis:\n  qs0\n  \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n  a = sum_list qs0\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "hence \"qs0 \\<in> listset ?ss\" and \"a = sum_list qs0\""], ["proof (prove)\nusing this:\n  qs0\n  \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n  a = sum_list qs0\n\ngoal (1 subgoal):\n 1. qs0\n    \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] &&&\n    a = sum_list qs0", "by simp_all"], ["proof (state)\nthis:\n  qs0 \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n  a = sum_list qs0\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from this(1)"], ["proof (chain)\npicking this:\n  qs0 \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]", "obtain x y where \"x \\<in> ideal F \\<inter> P[X]\" and \"y \\<in> (*) f ` normal_form L ` P[X]\"\n      and qs0: \"qs0 = [x, y]\""], ["proof (prove)\nusing this:\n  qs0 \\<in> listset [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]]\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> ideal F \\<inter> P[X];\n         y \\<in> (*) f ` normal_form L ` P[X]; qs0 = [x, y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  x \\<in> ideal F \\<inter> P[X]\n  y \\<in> (*) f ` normal_form L ` P[X]\n  qs0 = [x, y]\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from this(2)"], ["proof (chain)\npicking this:\n  y \\<in> (*) f ` normal_form L ` P[X]", "obtain a0 where \"a0 \\<in> P[X]\" and y: \"y = f * normal_form L a0\""], ["proof (prove)\nusing this:\n  y \\<in> (*) f ` normal_form L ` P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>a0.\n        \\<lbrakk>a0 \\<in> P[X]; y = f * normal_form L a0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a0 \\<in> P[X]\n  y = f * normal_form L a0\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from \\<open>x \\<in> ideal F \\<inter> P[X]\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> ideal F \\<inter> P[X]", "have \"x \\<in> ideal F\""], ["proof (prove)\nusing this:\n  x \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  x \\<in> ideal F\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "have x: \"x = a - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = a - y", "by (simp add: \\<open>a = sum_list qs0\\<close> qs0)"], ["proof (state)\nthis:\n  x = a - y\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "have \"f * (normal_form L q - normal_form L a0) = x - (a - ?a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * (normal_form L q - normal_form L a0) = x - (a - f * normal_form L q)", "by (simp add: x y a algebra_simps)"], ["proof (state)\nthis:\n  f * (normal_form L q - normal_form L a0) = x - (a - f * normal_form L q)\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "also"], ["proof (state)\nthis:\n  f * (normal_form L q - normal_form L a0) = x - (a - f * normal_form L q)\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from \\<open>x \\<in> ideal F\\<close> \\<open>a - ?a \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> ideal F\n  a - f * normal_form L q \\<in> ideal F", "have \"\\<dots> \\<in> ideal F\""], ["proof (prove)\nusing this:\n  x \\<in> ideal F\n  a - f * normal_form L q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x - (a - f * normal_form L q) \\<in> ideal F", "by (rule ideal.span_diff)"], ["proof (state)\nthis:\n  x - (a - f * normal_form L q) \\<in> ideal F\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "finally"], ["proof (chain)\npicking this:\n  f * (normal_form L q - normal_form L a0) \\<in> ideal F", "have \"normal_form L q - normal_form L a0 \\<in> ideal F \\<div> f\""], ["proof (prove)\nusing this:\n  f * (normal_form L q - normal_form L a0) \\<in> ideal F\n\ngoal (1 subgoal):\n 1. normal_form L q - normal_form L a0 \\<in> ideal F \\<div> f", "by (rule quot_setI)"], ["proof (state)\nthis:\n  normal_form L q - normal_form L a0 \\<in> ideal F \\<div> f\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "moreover"], ["proof (state)\nthis:\n  normal_form L q - normal_form L a0 \\<in> ideal F \\<div> f\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from \\<open>L \\<subseteq> P[X]\\<close> \\<open>q \\<in> P[X]\\<close> \\<open>a0 \\<in> P[X]\\<close>"], ["proof (chain)\npicking this:\n  L \\<subseteq> P[X]\n  q \\<in> P[X]\n  a0 \\<in> P[X]", "have \"normal_form L q - normal_form L a0 \\<in> P[X]\""], ["proof (prove)\nusing this:\n  L \\<subseteq> P[X]\n  q \\<in> P[X]\n  a0 \\<in> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L q - normal_form L a0 \\<in> P[X]", "by (intro Polys_closed_minus Polys_closed_normal_form)"], ["proof (state)\nthis:\n  normal_form L q - normal_form L a0 \\<in> P[X]\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "ultimately"], ["proof (chain)\npicking this:\n  normal_form L q - normal_form L a0 \\<in> ideal F \\<div> f\n  normal_form L q - normal_form L a0 \\<in> P[X]", "have \"normal_form L q - normal_form L a0 \\<in> L\""], ["proof (prove)\nusing this:\n  normal_form L q - normal_form L a0 \\<in> ideal F \\<div> f\n  normal_form L q - normal_form L a0 \\<in> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L q - normal_form L a0 \\<in> L", "by (simp add: L_def)"], ["proof (state)\nthis:\n  normal_form L q - normal_form L a0 \\<in> L\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "also"], ["proof (state)\nthis:\n  normal_form L q - normal_form L a0 \\<in> L\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "have \"\\<dots> \\<subseteq> ideal L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<subseteq> ideal L", "by (fact ideal.span_superset)"], ["proof (state)\nthis:\n  L \\<subseteq> ideal L\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "finally"], ["proof (chain)\npicking this:\n  normal_form L q - normal_form L a0 \\<in> ideal L", "have \"normal_form L q - normal_form L a0 = 0\""], ["proof (prove)\nusing this:\n  normal_form L q - normal_form L a0 \\<in> ideal L\n\ngoal (1 subgoal):\n 1. normal_form L q - normal_form L a0 = 0", "using \\<open>L \\<subseteq> P[X]\\<close>"], ["proof (prove)\nusing this:\n  normal_form L q - normal_form L a0 \\<in> ideal L\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L q - normal_form L a0 = 0", "by (simp only: normal_form_minus_normal_form flip: normal_form_zero_iff)"], ["proof (state)\nthis:\n  normal_form L q - normal_form L a0 = 0\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa\n       \\<in> listset\n              [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "thus \"qs0 = qs\""], ["proof (prove)\nusing this:\n  normal_form L q - normal_form L a0 = 0\n\ngoal (1 subgoal):\n 1. qs0 = qs", "by (simp add: qs0 qs_def x y)"], ["proof (state)\nthis:\n  qs0 = qs\n\ngoal (1 subgoal):\n 1. a = sum_list qs", "qed (simp_all add: qs_def)"], ["proof (state)\nthis:\n  \\<exists>!qs.\n     qs \\<in> listset\n               [ideal F \\<inter> P[X], (*) f ` normal_form L ` P[X]] \\<and>\n     a = sum_list qs\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary direct_decomp_ideal_normal_form:\n  assumes \"F \\<subseteq> P[X]\"\n  shows \"direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "from assms one_in_Polys"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  1 \\<in> P[?X]", "have \"direct_decomp (ideal (insert 1 F) \\<inter> P[X]) [ideal F \\<inter> P[X],\n                                                (*) 1 ` normal_form ((ideal F \\<div> 1) \\<inter> P[X]) ` P[X]]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  1 \\<in> P[?X]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert 1 F) \\<inter> P[X])\n     [ideal F \\<inter> P[X],\n      (*) 1 ` normal_form ((ideal F \\<div> 1) \\<inter> P[X]) ` P[X]]", "by (rule direct_decomp_ideal_insert)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert 1 F) \\<inter> P[X])\n   [ideal F \\<inter> P[X],\n    (*) 1 ` normal_form ((ideal F \\<div> 1) \\<inter> P[X]) ` P[X]]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "moreover"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert 1 F) \\<inter> P[X])\n   [ideal F \\<inter> P[X],\n    (*) 1 ` normal_form ((ideal F \\<div> 1) \\<inter> P[X]) ` P[X]]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "have \"ideal (insert 1 F) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (insert 1 F) = UNIV", "by (simp add: ideal_eq_UNIV_iff_contains_one ideal.span_base)"], ["proof (state)\nthis:\n  ideal (insert 1 F) = UNIV\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "moreover"], ["proof (state)\nthis:\n  ideal (insert 1 F) = UNIV\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"((*) 1 \\<circ> normal_form F) ` P[X] = normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. ((*) 1 \\<circ> normal_form F) ` P[X] = normal_form F ` P[X]", "by (rule image_cong) simp"], ["proof (state)\nthis:\n  ((*) 1 \\<circ> normal_form F) ` P[X] = normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "ultimately"], ["proof (chain)\npicking this:\n  direct_decomp (ideal (insert 1 F) \\<inter> P[X])\n   [ideal F \\<inter> P[X],\n    (*) 1 ` normal_form ((ideal F \\<div> 1) \\<inter> P[X]) ` P[X]]\n  ideal (insert 1 F) = UNIV\n  ((*) 1 \\<circ> normal_form F) ` P[X] = normal_form F ` P[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert 1 F) \\<inter> P[X])\n   [ideal F \\<inter> P[X],\n    (*) 1 ` normal_form ((ideal F \\<div> 1) \\<inter> P[X]) ` P[X]]\n  ideal (insert 1 F) = UNIV\n  ((*) 1 \\<circ> normal_form F) ` P[X] = normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "using assms"], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert 1 F) \\<inter> P[X])\n   [ideal F \\<inter> P[X],\n    (*) 1 ` normal_form ((ideal F \\<div> 1) \\<inter> P[X]) ` P[X]]\n  ideal (insert 1 F) = UNIV\n  ((*) 1 \\<circ> normal_form F) ` P[X] = normal_form F ` P[X]\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]", "by (simp add: image_comp normal_form_ideal_Polys)"], ["proof (state)\nthis:\n  direct_decomp P[X] [ideal F \\<inter> P[X], normal_form F ` P[X]]\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Basic Cone Decompositions\\<close>"], ["", "definition cone :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_0) set\"\n  where \"cone hU = (*) (fst hU) ` P[snd hU]\""], ["", "lemma coneI: \"p = a * h \\<Longrightarrow> a \\<in> P[U] \\<Longrightarrow> p \\<in> cone (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = a * h; a \\<in> P[U]\\<rbrakk>\n    \\<Longrightarrow> p \\<in> cone (h, U)", "by (auto simp: cone_def mult.commute[of a])"], ["", "lemma coneE:\n  assumes \"p \\<in> cone (h, U)\"\n  obtains a where \"a \\<in> P[U]\" and \"p = a * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> P[U]; p = a * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> P[U]; p = a * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: cone_def mult.commute)"], ["", "lemma cone_empty: \"cone (h, {}) = range (\\<lambda>c. c \\<cdot> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (h, {}) = range (\\<lambda>c. c \\<cdot> h)", "by (auto simp: Polys_empty map_scale_eq_times intro: coneI elim!: coneE)"], ["", "lemma cone_zero [simp]: \"cone (0, U) = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (0, U) = {0}", "by (auto simp: cone_def intro: zero_in_Polys)"], ["", "lemma cone_one [simp]: \"cone (1::_ \\<Rightarrow>\\<^sub>0 'a::comm_semiring_1, U) = P[U]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (1, U) = P[U]", "by (auto simp: cone_def)"], ["", "lemma zero_in_cone: \"0 \\<in> cone hU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> cone hU", "by (auto simp: cone_def intro!: image_eqI zero_in_Polys)"], ["", "corollary empty_not_in_map_cone: \"{} \\<notin> set (map cone ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> set (map cone ps)", "using zero_in_cone"], ["proof (prove)\nusing this:\n  0 \\<in> cone ?hU\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (map cone ps)", "by fastforce"], ["", "lemma tip_in_cone: \"h \\<in> cone (h::_ \\<Rightarrow>\\<^sub>0 _::comm_semiring_1, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> cone (h, U)", "using _ one_in_Polys"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  1 \\<in> P[?X]\n\ngoal (1 subgoal):\n 1. h \\<in> cone (h, U)", "by (rule coneI) simp"], ["", "lemma cone_closed_plus:\n  assumes \"a \\<in> cone hU\" and \"b \\<in> cone hU\"\n  shows \"a + b \\<in> cone hU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> cone hU\n  b \\<in> cone hU\n  hU = (h, U)", "have \"a \\<in> cone (h, U)\" and \"b \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  a \\<in> cone hU\n  b \\<in> cone hU\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. a \\<in> cone (h, U) &&& b \\<in> cone (h, U)", "by simp_all"], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n  b \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "from this(1)"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)", "obtain a' where \"a' \\<in> P[U]\" and a: \"a = a' * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> P[U]; a = a' * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a' \\<in> P[U]\n  a = a' * h\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "from \\<open>b \\<in> cone (h, U)\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> cone (h, U)", "obtain b' where \"b' \\<in> P[U]\" and b: \"b = b' * h\""], ["proof (prove)\nusing this:\n  b \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b' \\<in> P[U]; b = b' * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  b' \\<in> P[U]\n  b = b' * h\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "have \"a + b = (a' + b') * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = (a' + b') * h", "by (simp only: a b algebra_simps)"], ["proof (state)\nthis:\n  a + b = (a' + b') * h\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "moreover"], ["proof (state)\nthis:\n  a + b = (a' + b') * h\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "from \\<open>a' \\<in> P[U]\\<close> \\<open>b' \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  a' \\<in> P[U]\n  b' \\<in> P[U]", "have \"a' + b' \\<in> P[U]\""], ["proof (prove)\nusing this:\n  a' \\<in> P[U]\n  b' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. a' + b' \\<in> P[U]", "by (rule Polys_closed_plus)"], ["proof (state)\nthis:\n  a' + b' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "ultimately"], ["proof (chain)\npicking this:\n  a + b = (a' + b') * h\n  a' + b' \\<in> P[U]", "show ?thesis"], ["proof (prove)\nusing this:\n  a + b = (a' + b') * h\n  a' + b' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone hU", "unfolding hU"], ["proof (prove)\nusing this:\n  a + b = (a' + b') * h\n  a' + b' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  a + b \\<in> cone hU\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_closed_uminus:\n  assumes \"(a::_ \\<Rightarrow>\\<^sub>0 _::comm_ring) \\<in> cone hU\"\n  shows \"- a \\<in> cone hU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "with assms"], ["proof (chain)\npicking this:\n  a \\<in> cone hU\n  hU = (h, U)", "have \"a \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  a \\<in> cone hU\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. a \\<in> cone (h, U)", "by simp"], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "from this(1)"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)", "obtain a' where \"a' \\<in> P[U]\" and a: \"a = a' * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> P[U]; a = a' * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a' \\<in> P[U]\n  a = a' * h\n\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "have \"- a = (- a') * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a = - a' * h", "by (simp add: a)"], ["proof (state)\nthis:\n  - a = - a' * h\n\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "moreover"], ["proof (state)\nthis:\n  - a = - a' * h\n\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "from \\<open>a' \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  a' \\<in> P[U]", "have \"- a' \\<in> P[U]\""], ["proof (prove)\nusing this:\n  a' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. - a' \\<in> P[U]", "by (rule Polys_closed_uminus)"], ["proof (state)\nthis:\n  - a' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "ultimately"], ["proof (chain)\npicking this:\n  - a = - a' * h\n  - a' \\<in> P[U]", "show ?thesis"], ["proof (prove)\nusing this:\n  - a = - a' * h\n  - a' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. - a \\<in> cone hU", "unfolding hU"], ["proof (prove)\nusing this:\n  - a = - a' * h\n  - a' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. - a \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  - a \\<in> cone hU\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_closed_minus:\n  assumes \"(a::_ \\<Rightarrow>\\<^sub>0 _::comm_ring) \\<in> cone hU\" and \"b \\<in> cone hU\"\n  shows \"a - b \\<in> cone hU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b \\<in> cone hU", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a - b \\<in> cone hU", "from assms(2)"], ["proof (chain)\npicking this:\n  b \\<in> cone hU", "have \"- b \\<in> cone hU\""], ["proof (prove)\nusing this:\n  b \\<in> cone hU\n\ngoal (1 subgoal):\n 1. - b \\<in> cone hU", "by (rule cone_closed_uminus)"], ["proof (state)\nthis:\n  - b \\<in> cone hU\n\ngoal (1 subgoal):\n 1. a - b \\<in> cone hU", "with assms(1)"], ["proof (chain)\npicking this:\n  a \\<in> cone hU\n  - b \\<in> cone hU", "have \"a + (- b) \\<in> cone hU\""], ["proof (prove)\nusing this:\n  a \\<in> cone hU\n  - b \\<in> cone hU\n\ngoal (1 subgoal):\n 1. a + - b \\<in> cone hU", "by (rule cone_closed_plus)"], ["proof (state)\nthis:\n  a + - b \\<in> cone hU\n\ngoal (1 subgoal):\n 1. a - b \\<in> cone hU", "thus ?thesis"], ["proof (prove)\nusing this:\n  a + - b \\<in> cone hU\n\ngoal (1 subgoal):\n 1. a - b \\<in> cone hU", "by simp"], ["proof (state)\nthis:\n  a - b \\<in> cone hU\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_closed_times:\n  assumes \"a \\<in> cone (h, U)\" and \"q \\<in> P[U]\"\n  shows \"q * a \\<in> cone (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * a \\<in> cone (h, U)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q * a \\<in> cone (h, U)", "from assms(1)"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)", "obtain a' where \"a' \\<in> P[U]\" and a: \"a = a' * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> P[U]; a = a' * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a' \\<in> P[U]\n  a = a' * h\n\ngoal (1 subgoal):\n 1. q * a \\<in> cone (h, U)", "have \"q * a = (q * a') * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * a = q * a' * h", "by (simp only: a ac_simps)"], ["proof (state)\nthis:\n  q * a = q * a' * h\n\ngoal (1 subgoal):\n 1. q * a \\<in> cone (h, U)", "moreover"], ["proof (state)\nthis:\n  q * a = q * a' * h\n\ngoal (1 subgoal):\n 1. q * a \\<in> cone (h, U)", "from assms(2) \\<open>a' \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[U]\n  a' \\<in> P[U]", "have \"q * a' \\<in> P[U]\""], ["proof (prove)\nusing this:\n  q \\<in> P[U]\n  a' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. q * a' \\<in> P[U]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  q * a' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. q * a \\<in> cone (h, U)", "ultimately"], ["proof (chain)\npicking this:\n  q * a = q * a' * h\n  q * a' \\<in> P[U]", "show ?thesis"], ["proof (prove)\nusing this:\n  q * a = q * a' * h\n  q * a' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. q * a \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  q * a \\<in> cone (h, U)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cone_closed_monom_mult:\n  assumes \"a \\<in> cone (h, U)\" and \"t \\<in> .[U]\"\n  shows \"punit.monom_mult c t a \\<in> cone (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.punit.monom_mult c t a \\<in> cone (h, U)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.punit.monom_mult c t a \\<in> cone (h, U)", "from assms(2)"], ["proof (chain)\npicking this:\n  t \\<in> .[U]", "have \"monomial c t \\<in> P[U]\""], ["proof (prove)\nusing this:\n  t \\<in> .[U]\n\ngoal (1 subgoal):\n 1. monomial c t \\<in> P[U]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial c t \\<in> P[U]\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult c t a \\<in> cone (h, U)", "with assms(1)"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)\n  monomial c t \\<in> P[U]", "have \"monomial c t * a \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n  monomial c t \\<in> P[U]\n\ngoal (1 subgoal):\n 1. monomial c t * a \\<in> cone (h, U)", "by (rule cone_closed_times)"], ["proof (state)\nthis:\n  monomial c t * a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult c t a \\<in> cone (h, U)", "thus ?thesis"], ["proof (prove)\nusing this:\n  monomial c t * a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult c t a \\<in> cone (h, U)", "by (simp only: times_monomial_left)"], ["proof (state)\nthis:\n  local.punit.monom_mult c t a \\<in> cone (h, U)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coneD:\n  assumes \"p \\<in> cone (h, U)\" and \"p \\<noteq> 0\"\n  shows \"lpp h adds lpp (p::_ \\<Rightarrow>\\<^sub>0 _::{comm_semiring_0,semiring_no_zero_divisors})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "from assms(1)"], ["proof (chain)\npicking this:\n  p \\<in> cone (h, U)", "obtain a where p: \"p = a * h\""], ["proof (prove)\nusing this:\n  p \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = a * h \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  p = a * h\n\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "with assms(2)"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = a * h", "have \"a \\<noteq> 0\" and \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = a * h\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& h \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "hence \"lpp p = lpp a + lpp h\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp p = lpp a + lpp h", "unfolding p"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp (a * h) = lpp a + lpp h", "by (rule lp_times)"], ["proof (state)\nthis:\n  lpp p = lpp a + lpp h\n\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "also"], ["proof (state)\nthis:\n  lpp p = lpp a + lpp h\n\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "have \"\\<dots> = lpp h + lpp a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lpp a + lpp h = lpp h + lpp a", "by (rule add.commute)"], ["proof (state)\nthis:\n  lpp a + lpp h = lpp h + lpp a\n\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "finally"], ["proof (chain)\npicking this:\n  lpp p = lpp h + lpp a", "show ?thesis"], ["proof (prove)\nusing this:\n  lpp p = lpp h + lpp a\n\ngoal (1 subgoal):\n 1. lpp h adds lpp p", "by (rule addsI)"], ["proof (state)\nthis:\n  lpp h adds lpp p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_mono_1:\n  assumes \"h' \\<in> P[U]\"\n  shows \"cone (h' * h, U) \\<subseteq> cone (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (h' * h, U) \\<subseteq> cone (h, U)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h' * h, U) \\<Longrightarrow> x \\<in> cone (h, U)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h' * h, U) \\<Longrightarrow> x \\<in> cone (h, U)", "assume \"p \\<in> cone (h' * h, U)\""], ["proof (state)\nthis:\n  p \\<in> cone (h' * h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h' * h, U) \\<Longrightarrow> x \\<in> cone (h, U)", "then"], ["proof (chain)\npicking this:\n  p \\<in> cone (h' * h, U)", "obtain a' where \"a' \\<in> P[U]\" and \"p = a' * (h' * h)\""], ["proof (prove)\nusing this:\n  p \\<in> cone (h' * h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> P[U]; p = a' * (h' * h)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a' \\<in> P[U]\n  p = a' * (h' * h)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h' * h, U) \\<Longrightarrow> x \\<in> cone (h, U)", "from this(2)"], ["proof (chain)\npicking this:\n  p = a' * (h' * h)", "have \"p = a' * h' * h\""], ["proof (prove)\nusing this:\n  p = a' * (h' * h)\n\ngoal (1 subgoal):\n 1. p = a' * h' * h", "by (simp only: mult.assoc)"], ["proof (state)\nthis:\n  p = a' * h' * h\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h' * h, U) \\<Longrightarrow> x \\<in> cone (h, U)", "moreover"], ["proof (state)\nthis:\n  p = a' * h' * h\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h' * h, U) \\<Longrightarrow> x \\<in> cone (h, U)", "from \\<open>a' \\<in> P[U]\\<close> assms"], ["proof (chain)\npicking this:\n  a' \\<in> P[U]\n  h' \\<in> P[U]", "have \"a' * h' \\<in> P[U]\""], ["proof (prove)\nusing this:\n  a' \\<in> P[U]\n  h' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. a' * h' \\<in> P[U]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  a' * h' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h' * h, U) \\<Longrightarrow> x \\<in> cone (h, U)", "ultimately"], ["proof (chain)\npicking this:\n  p = a' * h' * h\n  a' * h' \\<in> P[U]", "show \"p \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  p = a' * h' * h\n  a' * h' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. p \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  p \\<in> cone (h, U)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_mono_2:\n  assumes \"U1 \\<subseteq> U2\"\n  shows \"cone (h, U1) \\<subseteq> cone (h, U2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (h, U1) \\<subseteq> cone (h, U2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "from assms"], ["proof (chain)\npicking this:\n  U1 \\<subseteq> U2", "have \"P[U1] \\<subseteq> P[U2]\""], ["proof (prove)\nusing this:\n  U1 \\<subseteq> U2\n\ngoal (1 subgoal):\n 1. P[U1] \\<subseteq> P[U2]", "by (rule Polys_mono)"], ["proof (state)\nthis:\n  P[U1] \\<subseteq> P[U2]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "assume \"p \\<in> cone (h, U1)\""], ["proof (state)\nthis:\n  p \\<in> cone (h, U1)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "then"], ["proof (chain)\npicking this:\n  p \\<in> cone (h, U1)", "obtain a where \"a \\<in> P[U1]\" and \"p = a * h\""], ["proof (prove)\nusing this:\n  p \\<in> cone (h, U1)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> P[U1]; p = a * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a \\<in> P[U1]\n  p = a * h\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "note this(2)"], ["proof (state)\nthis:\n  p = a * h\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "moreover"], ["proof (state)\nthis:\n  p = a * h\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "from \\<open>a \\<in> P[U1]\\<close> \\<open>P[U1] \\<subseteq> P[U2]\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> P[U1]\n  P[U1] \\<subseteq> P[U2]", "have \"a \\<in> P[U2]\""], ["proof (prove)\nusing this:\n  a \\<in> P[U1]\n  P[U1] \\<subseteq> P[U2]\n\ngoal (1 subgoal):\n 1. a \\<in> P[U2]", ".."], ["proof (state)\nthis:\n  a \\<in> P[U2]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U1) \\<Longrightarrow> x \\<in> cone (h, U2)", "ultimately"], ["proof (chain)\npicking this:\n  p = a * h\n  a \\<in> P[U2]", "show \"p \\<in> cone (h, U2)\""], ["proof (prove)\nusing this:\n  p = a * h\n  a \\<in> P[U2]\n\ngoal (1 subgoal):\n 1. p \\<in> cone (h, U2)", "by (rule coneI)"], ["proof (state)\nthis:\n  p \\<in> cone (h, U2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_subsetD:\n  assumes \"cone (h1, U1) \\<subseteq> cone (h2::_ \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}, U2)\"\n  shows \"h2 dvd h1\" and \"h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h2 dvd h1 &&& (h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. h2 dvd h1\n 2. h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2", "from tip_in_cone assms"], ["proof (chain)\npicking this:\n  ?h \\<in> cone (?h, ?U)\n  cone (h1, U1) \\<subseteq> cone (h2, U2)", "have \"h1 \\<in> cone (h2, U2)\""], ["proof (prove)\nusing this:\n  ?h \\<in> cone (?h, ?U)\n  cone (h1, U1) \\<subseteq> cone (h2, U2)\n\ngoal (1 subgoal):\n 1. h1 \\<in> cone (h2, U2)", ".."], ["proof (state)\nthis:\n  h1 \\<in> cone (h2, U2)\n\ngoal (2 subgoals):\n 1. h2 dvd h1\n 2. h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2", "then"], ["proof (chain)\npicking this:\n  h1 \\<in> cone (h2, U2)", "obtain a1' where \"a1' \\<in> P[U2]\" and h1: \"h1 = a1' * h2\""], ["proof (prove)\nusing this:\n  h1 \\<in> cone (h2, U2)\n\ngoal (1 subgoal):\n 1. (\\<And>a1'.\n        \\<lbrakk>a1' \\<in> P[U2]; h1 = a1' * h2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a1' \\<in> P[U2]\n  h1 = a1' * h2\n\ngoal (2 subgoals):\n 1. h2 dvd h1\n 2. h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2", "from this(2)"], ["proof (chain)\npicking this:\n  h1 = a1' * h2", "have \"h1 = h2 * a1'\""], ["proof (prove)\nusing this:\n  h1 = a1' * h2\n\ngoal (1 subgoal):\n 1. h1 = h2 * a1'", "by (simp only: mult.commute)"], ["proof (state)\nthis:\n  h1 = h2 * a1'\n\ngoal (2 subgoals):\n 1. h2 dvd h1\n 2. h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2", "thus \"h2 dvd h1\""], ["proof (prove)\nusing this:\n  h1 = h2 * a1'\n\ngoal (1 subgoal):\n 1. h2 dvd h1", ".."], ["proof (state)\nthis:\n  h2 dvd h1\n\ngoal (1 subgoal):\n 1. h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2", "assume \"h1 \\<noteq> 0\""], ["proof (state)\nthis:\n  h1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2", "with h1"], ["proof (chain)\npicking this:\n  h1 = a1' * h2\n  h1 \\<noteq> 0", "have \"a1' \\<noteq> 0\" and \"h2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h1 = a1' * h2\n  h1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a1' \\<noteq> 0 &&& h2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a1' \\<noteq> 0\n  h2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h1 \\<noteq> 0 \\<Longrightarrow> U1 \\<subseteq> U2", "show \"U1 \\<subseteq> U2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U1 \\<subseteq> U2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "assume \"x \\<in> U1\""], ["proof (state)\nthis:\n  x \\<in> U1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "hence \"monomial (1::'a) (Poly_Mapping.single x 1) \\<in> P[U1]\" (is \"?p \\<in> _\")"], ["proof (prove)\nusing this:\n  x \\<in> U1\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) \\<in> P[U1]", "by (intro Polys_closed_monomial PPs_closed_single)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) \\<in> P[U1]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "with refl"], ["proof (chain)\npicking this:\n  ?t = ?t\n  monomial (1::'a) (monomial 1 x) \\<in> P[U1]", "have \"?p * h1 \\<in> cone (h1, U1)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  monomial (1::'a) (monomial 1 x) \\<in> P[U1]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h1, U1)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h1, U1)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "hence \"?p * h1 \\<in> cone (h2, U2)\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h1, U1)\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h2, U2)", "using assms"], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h1, U1)\n  cone (h1, U1) \\<subseteq> cone (h2, U2)\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h2, U2)", ".."], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h2, U2)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "then"], ["proof (chain)\npicking this:\n  monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h2, U2)", "obtain a where \"a \\<in> P[U2]\" and \"?p * h1 = a * h2\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * h1 \\<in> cone (h2, U2)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> P[U2];\n         monomial (1::'a) (monomial 1 x) * h1 = a * h2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a \\<in> P[U2]\n  monomial (1::'a) (monomial 1 x) * h1 = a * h2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "from this(2)"], ["proof (chain)\npicking this:\n  monomial (1::'a) (monomial 1 x) * h1 = a * h2", "have \"(?p * a1') * h2 = a * h2\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * h1 = a * h2\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * a1' * h2 = a * h2", "by (simp only: h1 ac_simps)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) * a1' * h2 = a * h2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "hence \"?p * a1' = a\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * a1' * h2 = a * h2\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * a1' = a", "using \\<open>h2 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * a1' * h2 = a * h2\n  h2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * a1' = a", "by (rule times_canc_right)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) * a1' = a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "with \\<open>a \\<in> P[U2]\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> P[U2]\n  monomial (1::'a) (monomial 1 x) * a1' = a", "have \"a1' * ?p \\<in> P[U2]\""], ["proof (prove)\nusing this:\n  a \\<in> P[U2]\n  monomial (1::'a) (monomial 1 x) * a1' = a\n\ngoal (1 subgoal):\n 1. a1' * monomial (1::'a) (monomial 1 x) \\<in> P[U2]", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  a1' * monomial (1::'a) (monomial 1 x) \\<in> P[U2]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "hence \"?p \\<in> P[U2]\""], ["proof (prove)\nusing this:\n  a1' * monomial (1::'a) (monomial 1 x) \\<in> P[U2]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) \\<in> P[U2]", "using \\<open>a1' \\<in> P[U2]\\<close> \\<open>a1' \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  a1' * monomial (1::'a) (monomial 1 x) \\<in> P[U2]\n  a1' \\<in> P[U2]\n  a1' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) \\<in> P[U2]", "by (rule times_in_PolysD)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) \\<in> P[U2]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U1 \\<Longrightarrow> x \\<in> U2", "thus \"x \\<in> U2\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) \\<in> P[U2]\n\ngoal (1 subgoal):\n 1. x \\<in> U2", "by (simp add: Polys_def PPs_def)"], ["proof (state)\nthis:\n  x \\<in> U2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U1 \\<subseteq> U2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_subset_PolysD:\n  assumes \"cone (h::_ \\<Rightarrow>\\<^sub>0 'a::{comm_semiring_1,semiring_no_zero_divisors}, U) \\<subseteq> P[X]\"\n  shows \"h \\<in> P[X]\" and \"h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& (h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. h \\<in> P[X]\n 2. h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X", "from tip_in_cone assms"], ["proof (chain)\npicking this:\n  ?h \\<in> cone (?h, ?U)\n  cone (h, U) \\<subseteq> P[X]", "show \"h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  ?h \\<in> cone (?h, ?U)\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. h \\<in> P[X]", ".."], ["proof (state)\nthis:\n  h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X", "assume \"h \\<noteq> 0\""], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X", "show \"U \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "assume \"x \\<in> U\""], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "hence \"monomial (1::'a) (Poly_Mapping.single x 1) \\<in> P[U]\" (is \"?p \\<in> _\")"], ["proof (prove)\nusing this:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) \\<in> P[U]", "by (intro Polys_closed_monomial PPs_closed_single)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "with refl"], ["proof (chain)\npicking this:\n  ?t = ?t\n  monomial (1::'a) (monomial 1 x) \\<in> P[U]", "have \"?p * h \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  monomial (1::'a) (monomial 1 x) \\<in> P[U]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * h \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) * h \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "hence \"?p * h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * h \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * h \\<in> P[X]", "using assms"], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * h \\<in> cone (h, U)\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) * h \\<in> P[X]", ".."], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) * h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "hence \"h * ?p \\<in> P[X]\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) * h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. h * monomial (1::'a) (monomial 1 x) \\<in> P[X]", "by (simp only: mult.commute)"], ["proof (state)\nthis:\n  h * monomial (1::'a) (monomial 1 x) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "hence \"?p \\<in> P[X]\""], ["proof (prove)\nusing this:\n  h * monomial (1::'a) (monomial 1 x) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) \\<in> P[X]", "using \\<open>h \\<in> P[X]\\<close> \\<open>h \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  h * monomial (1::'a) (monomial 1 x) \\<in> P[X]\n  h \\<in> P[X]\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial 1 x) \\<in> P[X]", "by (rule times_in_PolysD)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial 1 x) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> X", "thus \"x \\<in> X\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial 1 x) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by (simp add: Polys_def PPs_def)"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_subset_PolysI:\n  assumes \"h \\<in> P[X]\" and \"h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X\"\n  shows \"cone (h, U) \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "proof (cases \"h = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. h \\<noteq> 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]", "case True"], ["proof (state)\nthis:\n  h = 0\n\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. h \\<noteq> 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]", "thus ?thesis"], ["proof (prove)\nusing this:\n  h = 0\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "by (simp add: zero_in_Polys)"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]", "case False"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]", "hence \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule assms(2))"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]", "hence \"P[U] \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. P[U] \\<subseteq> P[X]", "by (rule Polys_mono)"], ["proof (state)\nthis:\n  P[U] \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> P[X]", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> P[X]", "assume \"a \\<in> cone (h, U)\""], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)", "obtain q where \"q \\<in> P[U]\" and a: \"a = q * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[U]; a = q * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[U]\n  a = q * h\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> P[X]", "from this(1) \\<open>P[U] \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[U]\n  P[U] \\<subseteq> P[X]", "have \"q \\<in> P[X]\""], ["proof (prove)\nusing this:\n  q \\<in> P[U]\n  P[U] \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", ".."], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> P[X]", "from this assms(1)"], ["proof (chain)\npicking this:\n  q \\<in> P[X]\n  h \\<in> P[X]", "show \"a \\<in> P[X]\""], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n  h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. a \\<in> P[X]", "unfolding a"], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n  h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. q * h \\<in> P[X]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  a \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_image_times: \"(*) a ` cone (h, U) = cone (a * h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) a ` cone (h, U) = cone (a * h, U)", "by (auto simp: ac_simps image_image intro!: image_eqI coneI elim!: coneE)"], ["", "lemma cone_image_times': \"(*) a ` cone hU = cone (apfst ((*) a) hU)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) a ` cone hU = cone (apfst ((*) a) hU)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (*) a ` cone hU = cone (apfst ((*) a) hU)", "obtain h U where \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (*) a ` cone hU = cone (apfst ((*) a) hU)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (*) a ` cone hU = cone (apfst ((*) a) hU)", "by (simp add: cone_image_times)"], ["proof (state)\nthis:\n  (*) a ` cone hU = cone (apfst ((*) a) hU)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_set_coneI:\n  assumes \"homogeneous h\"\n  shows \"homogeneous_set (cone (h, U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous_set (cone (h, U))", "proof (rule homogeneous_setI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n.\n       a \\<in> cone (h, U) \\<Longrightarrow>\n       hom_component a n \\<in> cone (h, U)", "fix a n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a n.\n       a \\<in> cone (h, U) \\<Longrightarrow>\n       hom_component a n \\<in> cone (h, U)", "assume \"a \\<in> cone (h, U)\""], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>a n.\n       a \\<in> cone (h, U) \\<Longrightarrow>\n       hom_component a n \\<in> cone (h, U)", "then"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)", "obtain q where \"q \\<in> P[U]\" and a: \"a = q * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[U]; a = q * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[U]\n  a = q * h\n\ngoal (1 subgoal):\n 1. \\<And>a n.\n       a \\<in> cone (h, U) \\<Longrightarrow>\n       hom_component a n \\<in> cone (h, U)", "from this(1)"], ["proof (chain)\npicking this:\n  q \\<in> P[U]", "show \"hom_component a n \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  q \\<in> P[U]\n\ngoal (1 subgoal):\n 1. hom_component a n \\<in> cone (h, U)", "unfolding a"], ["proof (prove)\nusing this:\n  q \\<in> P[U]\n\ngoal (1 subgoal):\n 1. hom_component (q * h) n \\<in> cone (h, U)", "proof (induct q rule: poly_mapping_plus_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> P[U] \\<Longrightarrow> hom_component (0 * h) n \\<in> cone (h, U)\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "case 1"], ["proof (state)\nthis:\n  0 \\<in> P[U]\n\ngoal (2 subgoals):\n 1. 0 \\<in> P[U] \\<Longrightarrow> hom_component (0 * h) n \\<in> cone (h, U)\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component (0 * h) n \\<in> cone (h, U)", "by (simp add: zero_in_cone)"], ["proof (state)\nthis:\n  hom_component (0 * h) n \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "case (2 p c t)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  t \\<notin> keys p\n  p \\<in> P[U] \\<Longrightarrow> hom_component (p * h) n \\<in> cone (h, U)\n  monomial c t + p \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "have \"p \\<in> P[U]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P[U]", "proof (intro PolysI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "assume \"s \\<in> keys p\""], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "moreover"], ["proof (state)\nthis:\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "from 2(2) this"], ["proof (chain)\npicking this:\n  t \\<notin> keys p\n  s \\<in> keys p", "have \"s \\<notin> keys (monomial c t)\""], ["proof (prove)\nusing this:\n  t \\<notin> keys p\n  s \\<in> keys p\n\ngoal (1 subgoal):\n 1. s \\<notin> keys (monomial c t)", "by auto"], ["proof (state)\nthis:\n  s \\<notin> keys (monomial c t)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> keys p\n  s \\<notin> keys (monomial c t)", "have \"s \\<in> keys (monomial c t + p)\""], ["proof (prove)\nusing this:\n  s \\<in> keys p\n  s \\<notin> keys (monomial c t)\n\ngoal (1 subgoal):\n 1. s \\<in> keys (monomial c t + p)", "by (rule in_keys_plusI2)"], ["proof (state)\nthis:\n  s \\<in> keys (monomial c t + p)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "also"], ["proof (state)\nthis:\n  s \\<in> keys (monomial c t + p)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "from 2(4)"], ["proof (chain)\npicking this:\n  monomial c t + p \\<in> P[U]", "have \"\\<dots> \\<subseteq> .[U]\""], ["proof (prove)\nusing this:\n  monomial c t + p \\<in> P[U]\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) \\<subseteq> .[U]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys (monomial c t + p) \\<subseteq> .[U]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> keys p \\<Longrightarrow> x \\<in> .[U]", "finally"], ["proof (chain)\npicking this:\n  s \\<in> .[U]", "show \"s \\<in> .[U]\""], ["proof (prove)\nusing this:\n  s \\<in> .[U]\n\ngoal (1 subgoal):\n 1. s \\<in> .[U]", "."], ["proof (state)\nthis:\n  s \\<in> .[U]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "hence *: \"hom_component (p * h) n \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  p \\<in> P[U]\n\ngoal (1 subgoal):\n 1. hom_component (p * h) n \\<in> cone (h, U)", "by (rule 2(3))"], ["proof (state)\nthis:\n  hom_component (p * h) n \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "from 2(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "have \"t \\<in> keys (monomial c t)\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (monomial c t)", "by simp"], ["proof (state)\nthis:\n  t \\<in> keys (monomial c t)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "hence \"t \\<in> keys (monomial c t + p)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (monomial c t)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (monomial c t + p)", "using 2(2)"], ["proof (prove)\nusing this:\n  t \\<in> keys (monomial c t)\n  t \\<notin> keys p\n\ngoal (1 subgoal):\n 1. t \\<in> keys (monomial c t + p)", "by (rule in_keys_plusI1)"], ["proof (state)\nthis:\n  t \\<in> keys (monomial c t + p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "also"], ["proof (state)\nthis:\n  t \\<in> keys (monomial c t + p)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "from 2(4)"], ["proof (chain)\npicking this:\n  monomial c t + p \\<in> P[U]", "have \"\\<dots> \\<subseteq> .[U]\""], ["proof (prove)\nusing this:\n  monomial c t + p \\<in> P[U]\n\ngoal (1 subgoal):\n 1. keys (monomial c t + p) \\<subseteq> .[U]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys (monomial c t + p) \\<subseteq> .[U]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "finally"], ["proof (chain)\npicking this:\n  t \\<in> .[U]", "have \"monomial c t \\<in> P[U]\""], ["proof (prove)\nusing this:\n  t \\<in> .[U]\n\ngoal (1 subgoal):\n 1. monomial c t \\<in> P[U]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial c t \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "with refl"], ["proof (chain)\npicking this:\n  ?t = ?t\n  monomial c t \\<in> P[U]", "have \"monomial c t * h \\<in> cone (h, U)\" (is \"?h \\<in> _\")"], ["proof (prove)\nusing this:\n  ?t = ?t\n  monomial c t \\<in> P[U]\n\ngoal (1 subgoal):\n 1. monomial c t * h \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial c t * h \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "from assms"], ["proof (chain)\npicking this:\n  homogeneous h", "have \"homogeneous ?h\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. homogeneous (monomial c t * h)", "by (simp add: homogeneous_times)"], ["proof (state)\nthis:\n  homogeneous (monomial c t * h)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "hence \"hom_component ?h n = (?h when n = poly_deg ?h)\""], ["proof (prove)\nusing this:\n  homogeneous (monomial c t * h)\n\ngoal (1 subgoal):\n 1. hom_component (monomial c t * h) n =\n    (monomial c t * h when n = poly_deg (monomial c t * h))", "by (rule hom_component_of_homogeneous)"], ["proof (state)\nthis:\n  hom_component (monomial c t * h) n =\n  (monomial c t * h when n = poly_deg (monomial c t * h))\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "with \\<open>?h \\<in> cone (h, U)\\<close>"], ["proof (chain)\npicking this:\n  monomial c t * h \\<in> cone (h, U)\n  hom_component (monomial c t * h) n =\n  (monomial c t * h when n = poly_deg (monomial c t * h))", "have **: \"hom_component ?h n \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  monomial c t * h \\<in> cone (h, U)\n  hom_component (monomial c t * h) n =\n  (monomial c t * h when n = poly_deg (monomial c t * h))\n\ngoal (1 subgoal):\n 1. hom_component (monomial c t * h) n \\<in> cone (h, U)", "by (simp add: when_def zero_in_cone)"], ["proof (state)\nthis:\n  hom_component (monomial c t * h) n \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "have \"hom_component ((monomial c t + p) * h) n = hom_component ?h n + hom_component (p * h) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_component ((monomial c t + p) * h) n =\n    hom_component (monomial c t * h) n + hom_component (p * h) n", "by (simp only: distrib_right hom_component_plus)"], ["proof (state)\nthis:\n  hom_component ((monomial c t + p) * h) n =\n  hom_component (monomial c t * h) n + hom_component (p * h) n\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "also"], ["proof (state)\nthis:\n  hom_component ((monomial c t + p) * h) n =\n  hom_component (monomial c t * h) n + hom_component (p * h) n\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "from ** *"], ["proof (chain)\npicking this:\n  hom_component (monomial c t * h) n \\<in> cone (h, U)\n  hom_component (p * h) n \\<in> cone (h, U)", "have \"\\<dots> \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  hom_component (monomial c t * h) n \\<in> cone (h, U)\n  hom_component (p * h) n \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. hom_component (monomial c t * h) n + hom_component (p * h) n\n    \\<in> cone (h, U)", "by (rule cone_closed_plus)"], ["proof (state)\nthis:\n  hom_component (monomial c t * h) n + hom_component (p * h) n\n  \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        p \\<in> P[U] \\<Longrightarrow>\n        hom_component (p * h) n \\<in> cone (h, U);\n        monomial c t + p \\<in> P[U]\\<rbrakk>\n       \\<Longrightarrow> hom_component ((monomial c t + p) * h) n\n                         \\<in> cone (h, U)", "finally"], ["proof (chain)\npicking this:\n  hom_component ((monomial c t + p) * h) n \\<in> cone (h, U)", "show ?case"], ["proof (prove)\nusing this:\n  hom_component ((monomial c t + p) * h) n \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. hom_component ((monomial c t + p) * h) n \\<in> cone (h, U)", "."], ["proof (state)\nthis:\n  hom_component ((monomial c t + p) * h) n \\<in> cone (h, U)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hom_component a n \\<in> cone (h, U)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subspace_cone: \"phull.subspace (cone hU)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phull.subspace (cone hU)", "using zero_in_cone cone_closed_plus"], ["proof (prove)\nusing this:\n  0 \\<in> cone ?hU\n  \\<lbrakk>?a \\<in> cone ?hU; ?b \\<in> cone ?hU\\<rbrakk>\n  \\<Longrightarrow> ?a + ?b \\<in> cone ?hU\n\ngoal (1 subgoal):\n 1. phull.subspace (cone hU)", "proof (rule phull.subspaceI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cone hU\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> y \\<in> cone hU\n 3. \\<And>c x. x \\<in> cone hU \\<Longrightarrow> c \\<cdot> x \\<in> cone hU", "fix c a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cone hU\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> y \\<in> cone hU\n 3. \\<And>c x. x \\<in> cone hU \\<Longrightarrow> c \\<cdot> x \\<in> cone hU", "assume \"a \\<in> cone hU\""], ["proof (state)\nthis:\n  a \\<in> cone hU\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cone hU\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> y \\<in> cone hU\n 3. \\<And>c x. x \\<in> cone hU \\<Longrightarrow> c \\<cdot> x \\<in> cone hU", "moreover"], ["proof (state)\nthis:\n  a \\<in> cone hU\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cone hU\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> y \\<in> cone hU\n 3. \\<And>c x. x \\<in> cone hU \\<Longrightarrow> c \\<cdot> x \\<in> cone hU", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cone hU\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> y \\<in> cone hU\n 3. \\<And>c x. x \\<in> cone hU \\<Longrightarrow> c \\<cdot> x \\<in> cone hU", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> cone hU\n  hU = (h, U)", "have \"a \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  a \\<in> cone hU\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. a \\<in> cone (h, U)", "by simp"], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cone hU\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> y \\<in> cone hU\n 3. \\<And>c x. x \\<in> cone hU \\<Longrightarrow> c \\<cdot> x \\<in> cone hU", "thus \"c \\<cdot> a \\<in> cone hU\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. c \\<cdot> a \\<in> cone hU", "unfolding hU punit.map_scale_eq_monom_mult"], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult c 0 a \\<in> cone (h, U)", "using zero_in_PPs"], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult c 0 a \\<in> cone (h, U)", "by (rule cone_closed_monom_mult)"], ["proof (state)\nthis:\n  c \\<cdot> a \\<in> cone hU\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cone hU\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cone hU; y \\<in> cone hU\\<rbrakk>\n       \\<Longrightarrow> y \\<in> cone hU", "qed"], ["", "lemma direct_decomp_cone_insert:\n  fixes h :: \"_ \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}\"\n  assumes \"x \\<notin> U\"\n  shows \"direct_decomp (cone (h, insert x U))\n                  [cone (h, U), cone (monomial 1 (Poly_Mapping.single x (Suc 0)) * h, insert x U)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x U))\n     [cone (h, U),\n      cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x U))\n     [cone (h, U),\n      cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]", "let ?x = \"Poly_Mapping.single x (Suc 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x U))\n     [cone (h, U),\n      cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]", "define xx where \"xx = monomial (1::'a) ?x\""], ["proof (state)\nthis:\n  xx = monomial (1::'a) (monomial (Suc 0) x)\n\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x U))\n     [cone (h, U),\n      cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]", "show \"direct_decomp (cone (h, insert x U)) [cone (h, U), cone (xx * h, insert x U)]\"\n    (is \"direct_decomp _ ?ss\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x U))\n     [cone (h, U), cone (xx * h, insert x U)]", "proof (rule direct_decompI_alt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "fix qs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "assume \"qs \\<in> listset ?ss\""], ["proof (state)\nthis:\n  qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "then"], ["proof (chain)\npicking this:\n  qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)]", "obtain a b where \"a \\<in> cone (h, U)\" and b: \"b \\<in> cone (xx * h, insert x U)\"\n      and qs: \"qs = [a, b]\""], ["proof (prove)\nusing this:\n  qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> cone (h, U); b \\<in> cone (xx * h, insert x U);\n         qs = [a, b]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n  b \\<in> cone (xx * h, insert x U)\n  qs = [a, b]\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "note this(1)"], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "also"], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have \"cone (h, U) \\<subseteq> cone (h, insert x U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> cone (h, insert x U)", "by (rule cone_mono_2) blast"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> cone (h, insert x U)\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "finally"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, insert x U)", "have a: \"a \\<in> cone (h, insert x U)\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, insert x U)\n\ngoal (1 subgoal):\n 1. a \\<in> cone (h, insert x U)", "."], ["proof (state)\nthis:\n  a \\<in> cone (h, insert x U)\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have \"cone (xx * h, insert x U) \\<subseteq> cone (h, insert x U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (xx * h, insert x U) \\<subseteq> cone (h, insert x U)", "by (rule cone_mono_1) (simp add: xx_def Polys_def PPs_closed_single)"], ["proof (state)\nthis:\n  cone (xx * h, insert x U) \\<subseteq> cone (h, insert x U)\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "with b"], ["proof (chain)\npicking this:\n  b \\<in> cone (xx * h, insert x U)\n  cone (xx * h, insert x U) \\<subseteq> cone (h, insert x U)", "have \"b \\<in> cone (h, insert x U)\""], ["proof (prove)\nusing this:\n  b \\<in> cone (xx * h, insert x U)\n  cone (xx * h, insert x U) \\<subseteq> cone (h, insert x U)\n\ngoal (1 subgoal):\n 1. b \\<in> cone (h, insert x U)", ".."], ["proof (state)\nthis:\n  b \\<in> cone (h, insert x U)\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "with a"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, insert x U)\n  b \\<in> cone (h, insert x U)", "have \"a + b \\<in> cone (h, insert x U)\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, insert x U)\n  b \\<in> cone (h, insert x U)\n\ngoal (1 subgoal):\n 1. a + b \\<in> cone (h, insert x U)", "by (rule cone_closed_plus)"], ["proof (state)\nthis:\n  a + b \\<in> cone (h, insert x U)\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       qs \\<in> listset\n                 [cone (h, U), cone (xx * h, insert x U)] \\<Longrightarrow>\n       sum_list qs \\<in> cone (h, insert x U)\n 2. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "thus \"sum_list qs \\<in> cone (h, insert x U)\""], ["proof (prove)\nusing this:\n  a + b \\<in> cone (h, insert x U)\n\ngoal (1 subgoal):\n 1. sum_list qs \\<in> cone (h, insert x U)", "by (simp add: qs)"], ["proof (state)\nthis:\n  sum_list qs \\<in> cone (h, insert x U)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "assume \"a \\<in> cone (h, insert x U)\""], ["proof (state)\nthis:\n  a \\<in> cone (h, insert x U)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "then"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, insert x U)", "obtain q where \"q \\<in> P[insert x U]\" and a: \"a = q * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, insert x U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[insert x U]; a = q * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[insert x U]\n  a = q * h\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "define qU where \"qU = except q (- .[U])\""], ["proof (state)\nthis:\n  qU = except q (- .[U])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "define qx where \"qx = except q .[U]\""], ["proof (state)\nthis:\n  qx = except q .[U]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have q: \"q = qU + qx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = qU + qx", "by (simp only: qU_def qx_def add.commute flip: except_decomp)"], ["proof (state)\nthis:\n  q = qU + qx\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have \"qU \\<in> P[U]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qU \\<in> P[U]", "by (rule PolysI) (simp add: qU_def keys_except)"], ["proof (state)\nthis:\n  qU \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have x_adds: \"?x adds t\" if \"t \\<in> keys qx\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (Suc 0) x adds t", "unfolding adds_poly_mapping le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. lookup (monomial (Suc 0) x) xa \\<le> lookup t xa", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. lookup (monomial (Suc 0) x) xa \\<le> lookup t xa", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. lookup (monomial (Suc 0) x) xa \\<le> lookup t xa", "show \"lookup ?x y \\<le> lookup t y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial (Suc 0) x) y \\<le> lookup t y", "proof (cases \"y = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "case True"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "from that"], ["proof (chain)\npicking this:\n  t \\<in> keys qx", "have \"t \\<in> keys q\" and \"t \\<notin> .[U]\""], ["proof (prove)\nusing this:\n  t \\<in> keys qx\n\ngoal (1 subgoal):\n 1. t \\<in> keys q &&& t \\<notin> .[U]", "by (simp_all add: qx_def keys_except)"], ["proof (state)\nthis:\n  t \\<in> keys q\n  t \\<notin> .[U]\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "from \\<open>q \\<in> P[insert x U]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[insert x U]", "have \"keys q \\<subseteq> .[insert x U]\""], ["proof (prove)\nusing this:\n  q \\<in> P[insert x U]\n\ngoal (1 subgoal):\n 1. keys q \\<subseteq> .[insert x U]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys q \\<subseteq> .[insert x U]\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "with \\<open>t \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys q\n  keys q \\<subseteq> .[insert x U]", "have \"t \\<in> .[insert x U]\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n  keys q \\<subseteq> .[insert x U]\n\ngoal (1 subgoal):\n 1. t \\<in> .[insert x U]", ".."], ["proof (state)\nthis:\n  t \\<in> .[insert x U]\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "hence \"keys t \\<subseteq> insert x U\""], ["proof (prove)\nusing this:\n  t \\<in> .[insert x U]\n\ngoal (1 subgoal):\n 1. keys t \\<subseteq> insert x U", "by (rule PPsD)"], ["proof (state)\nthis:\n  keys t \\<subseteq> insert x U\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "moreover"], ["proof (state)\nthis:\n  keys t \\<subseteq> insert x U\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "from \\<open>t \\<notin> .[U]\\<close>"], ["proof (chain)\npicking this:\n  t \\<notin> .[U]", "have \"\\<not> keys t \\<subseteq> U\""], ["proof (prove)\nusing this:\n  t \\<notin> .[U]\n\ngoal (1 subgoal):\n 1. \\<not> keys t \\<subseteq> U", "by (simp add: PPs_def)"], ["proof (state)\nthis:\n  \\<not> keys t \\<subseteq> U\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "ultimately"], ["proof (chain)\npicking this:\n  keys t \\<subseteq> insert x U\n  \\<not> keys t \\<subseteq> U", "have \"x \\<in> keys t\""], ["proof (prove)\nusing this:\n  keys t \\<subseteq> insert x U\n  \\<not> keys t \\<subseteq> U\n\ngoal (1 subgoal):\n 1. x \\<in> keys t", "by blast"], ["proof (state)\nthis:\n  x \\<in> keys t\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> lookup (monomial (Suc 0) x) y \\<le> lookup t y\n 2. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> keys t\n\ngoal (1 subgoal):\n 1. lookup (monomial (Suc 0) x) y \\<le> lookup t y", "by (simp add: lookup_single True in_keys_iff)"], ["proof (state)\nthis:\n  lookup (monomial (Suc 0) x) y \\<le> lookup t y\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    lookup (monomial (Suc 0) x) y \\<le> lookup t y", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. lookup (monomial (Suc 0) x) y \\<le> lookup t y", "by (simp add: lookup_single)"], ["proof (state)\nthis:\n  lookup (monomial (Suc 0) x) y \\<le> lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (monomial (Suc 0) x) y \\<le> lookup t y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t7 \\<in> keys qx \\<Longrightarrow> monomial (Suc 0) x adds ?t7\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "define qx' where \"qx' = Poly_Mapping.map_key ((+) ?x) qx\""], ["proof (state)\nthis:\n  qx' = Poly_Mapping.map_key ((+) (monomial (Suc 0) x)) qx\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have lookup_qx': \"lookup qx' = (\\<lambda>t. lookup qx (?x + t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup qx' = (\\<lambda>t. lookup qx (monomial (Suc 0) x + t))", "by (rule ext) (simp add: qx'_def map_key.rep_eq)"], ["proof (state)\nthis:\n  lookup qx' = (\\<lambda>t. lookup qx (monomial (Suc 0) x + t))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have \"qx' * xx = punit.monom_mult 1 ?x qx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qx' * xx = local.punit.monom_mult (1::'a) (monomial (Suc 0) x) qx'", "by (simp only: xx_def mult.commute flip: times_monomial_left)"], ["proof (state)\nthis:\n  qx' * xx = local.punit.monom_mult (1::'a) (monomial (Suc 0) x) qx'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "also"], ["proof (state)\nthis:\n  qx' * xx = local.punit.monom_mult (1::'a) (monomial (Suc 0) x) qx'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have \"\\<dots> = qx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial (Suc 0) x) qx' = qx", "by (auto simp: punit.lookup_monom_mult lookup_qx' add.commute[of ?x] adds_minus\n              simp flip: not_in_keys_iff_lookup_eq_zero dest: x_adds intro!: poly_mapping_eqI)"], ["proof (state)\nthis:\n  local.punit.monom_mult (1::'a) (monomial (Suc 0) x) qx' = qx\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "finally"], ["proof (chain)\npicking this:\n  qx' * xx = qx", "have qx: \"qx = qx' * xx\""], ["proof (prove)\nusing this:\n  qx' * xx = qx\n\ngoal (1 subgoal):\n 1. qx = qx' * xx", "by (rule sym)"], ["proof (state)\nthis:\n  qx = qx' * xx\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "have \"qx' \\<in> P[insert x U]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qx' \\<in> P[insert x U]", "proof (intro PolysI subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "assume \"t \\<in> keys qx'\""], ["proof (state)\nthis:\n  t \\<in> keys qx'\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "hence \"t + ?x \\<in> keys qx\""], ["proof (prove)\nusing this:\n  t \\<in> keys qx'\n\ngoal (1 subgoal):\n 1. t + monomial (Suc 0) x \\<in> keys qx", "by (simp only: lookup_qx' in_keys_iff not_False_eq_True add.commute)"], ["proof (state)\nthis:\n  t + monomial (Suc 0) x \\<in> keys qx\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "also"], ["proof (state)\nthis:\n  t + monomial (Suc 0) x \\<in> keys qx\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "have \"\\<dots> \\<subseteq> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys qx \\<subseteq> keys q", "by (auto simp: qx_def keys_except)"], ["proof (state)\nthis:\n  keys qx \\<subseteq> keys q\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "also"], ["proof (state)\nthis:\n  keys qx \\<subseteq> keys q\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "from \\<open>q \\<in> P[insert x U]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[insert x U]", "have \"\\<dots> \\<subseteq> .[insert x U]\""], ["proof (prove)\nusing this:\n  q \\<in> P[insert x U]\n\ngoal (1 subgoal):\n 1. keys q \\<subseteq> .[insert x U]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys q \\<subseteq> .[insert x U]\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "finally"], ["proof (chain)\npicking this:\n  t + monomial (Suc 0) x \\<in> .[insert x U]", "have \"(t + ?x) - ?x \\<in> .[insert x U]\""], ["proof (prove)\nusing this:\n  t + monomial (Suc 0) x \\<in> .[insert x U]\n\ngoal (1 subgoal):\n 1. t + monomial (Suc 0) x - monomial (Suc 0) x \\<in> .[insert x U]", "by (rule PPs_closed_minus)"], ["proof (state)\nthis:\n  t + monomial (Suc 0) x - monomial (Suc 0) x \\<in> .[insert x U]\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> keys qx' \\<Longrightarrow> xa \\<in> .[insert x U]", "thus \"t \\<in> .[insert x U]\""], ["proof (prove)\nusing this:\n  t + monomial (Suc 0) x - monomial (Suc 0) x \\<in> .[insert x U]\n\ngoal (1 subgoal):\n 1. t \\<in> .[insert x U]", "by simp"], ["proof (state)\nthis:\n  t \\<in> .[insert x U]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qx' \\<in> P[insert x U]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "define qs where \"qs = [qU * h, qx' * (xx * h)]\""], ["proof (state)\nthis:\n  qs = [qU * h, qx' * (xx * h)]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> cone (h, insert x U) \\<Longrightarrow>\n       \\<exists>!qs.\n          qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n          a = sum_list qs", "show \"\\<exists>!qs\\<in>listset ?ss. a = sum_list qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!qs.\n       qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qs", "proof (intro ex1I conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?a \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "from refl \\<open>qU \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  ?t = ?t\n  qU \\<in> P[U]", "have \"qU * h \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  qU \\<in> P[U]\n\ngoal (1 subgoal):\n 1. qU * h \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  qU * h \\<in> cone (h, U)\n\ngoal (3 subgoals):\n 1. ?a \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "moreover"], ["proof (state)\nthis:\n  qU * h \\<in> cone (h, U)\n\ngoal (3 subgoals):\n 1. ?a \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "from refl \\<open>qx' \\<in> P[insert x U]\\<close>"], ["proof (chain)\npicking this:\n  ?t = ?t\n  qx' \\<in> P[insert x U]", "have \"qx' * (xx * h) \\<in> cone (xx * h, insert x U)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  qx' \\<in> P[insert x U]\n\ngoal (1 subgoal):\n 1. qx' * (xx * h) \\<in> cone (xx * h, insert x U)", "by (rule coneI)"], ["proof (state)\nthis:\n  qx' * (xx * h) \\<in> cone (xx * h, insert x U)\n\ngoal (3 subgoals):\n 1. ?a \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n 2. a = sum_list ?a\n 3. \\<And>qs.\n       qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qs \\<Longrightarrow>\n       qs = ?a", "ultimately"], ["proof (chain)\npicking this:\n  qU * h \\<in> cone (h, U)\n  qx' * (xx * h) \\<in> cone (xx * h, insert x U)", "show \"qs \\<in> listset ?ss\""], ["proof (prove)\nusing this:\n  qU * h \\<in> cone (h, U)\n  qx' * (xx * h) \\<in> cone (xx * h, insert x U)\n\ngoal (1 subgoal):\n 1. qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)]", "using qs_def"], ["proof (prove)\nusing this:\n  qU * h \\<in> cone (h, U)\n  qx' * (xx * h) \\<in> cone (xx * h, insert x U)\n  qs = [qU * h, qx' * (xx * h)]\n\ngoal (1 subgoal):\n 1. qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)]", "by (rule listset_doubletonI)"], ["proof (state)\nthis:\n  qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "fix qs0"], ["proof (state)\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "assume \"qs0 \\<in> listset ?ss \\<and> a = sum_list qs0\""], ["proof (state)\nthis:\n  qs0 \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n  a = sum_list qs0\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "hence \"qs0 \\<in> listset ?ss\" and a0: \"a = sum_list qs0\""], ["proof (prove)\nusing this:\n  qs0 \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n  a = sum_list qs0\n\ngoal (1 subgoal):\n 1. qs0 \\<in> listset [cone (h, U), cone (xx * h, insert x U)] &&&\n    a = sum_list qs0", "by simp_all"], ["proof (state)\nthis:\n  qs0 \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n  a = sum_list qs0\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from this(1)"], ["proof (chain)\npicking this:\n  qs0 \\<in> listset [cone (h, U), cone (xx * h, insert x U)]", "obtain p1 p2 where \"p1 \\<in> cone (h, U)\" and p2: \"p2 \\<in> cone (xx * h, insert x U)\"\n        and qs0: \"qs0 = [p1, p2]\""], ["proof (prove)\nusing this:\n  qs0 \\<in> listset [cone (h, U), cone (xx * h, insert x U)]\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p1 \\<in> cone (h, U); p2 \\<in> cone (xx * h, insert x U);\n         qs0 = [p1, p2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  p1 \\<in> cone (h, U)\n  p2 \\<in> cone (xx * h, insert x U)\n  qs0 = [p1, p2]\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from this(1)"], ["proof (chain)\npicking this:\n  p1 \\<in> cone (h, U)", "obtain qU0 where \"qU0 \\<in> P[U]\" and p1: \"p1 = qU0 * h\""], ["proof (prove)\nusing this:\n  p1 \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>qU0.\n        \\<lbrakk>qU0 \\<in> P[U]; p1 = qU0 * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  qU0 \\<in> P[U]\n  p1 = qU0 * h\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "from p2"], ["proof (chain)\npicking this:\n  p2 \\<in> cone (xx * h, insert x U)", "obtain qx0 where p2: \"p2 = qx0 * (xx * h)\""], ["proof (prove)\nusing this:\n  p2 \\<in> cone (xx * h, insert x U)\n\ngoal (1 subgoal):\n 1. (\\<And>qx0.\n        p2 = qx0 * (xx * h) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  p2 = qx0 * (xx * h)\n\ngoal (2 subgoals):\n 1. a = sum_list qs\n 2. \\<And>qsa.\n       qsa \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n       a = sum_list qsa \\<Longrightarrow>\n       qsa = qs", "show \"qs0 = qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs0 = qs", "proof (cases \"h = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow> qs0 = qs\n 2. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "case True"], ["proof (state)\nthis:\n  h = 0\n\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow> qs0 = qs\n 2. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "thus ?thesis"], ["proof (prove)\nusing this:\n  h = 0\n\ngoal (1 subgoal):\n 1. qs0 = qs", "by (simp add: qs_def qs0 p1 p2)"], ["proof (state)\nthis:\n  qs0 = qs\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "case False"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "from a0"], ["proof (chain)\npicking this:\n  a = sum_list qs0", "have \"(qU - qU0) * h = (qx0 - qx') * xx * h\""], ["proof (prove)\nusing this:\n  a = sum_list qs0\n\ngoal (1 subgoal):\n 1. (qU - qU0) * h = (qx0 - qx') * xx * h", "by (simp add: a qs0 p1 p2 q qx algebra_simps)"], ["proof (state)\nthis:\n  (qU - qU0) * h = (qx0 - qx') * xx * h\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "hence eq: \"qU - qU0 = (qx0 - qx') * xx\""], ["proof (prove)\nusing this:\n  (qU - qU0) * h = (qx0 - qx') * xx * h\n\ngoal (1 subgoal):\n 1. qU - qU0 = (qx0 - qx') * xx", "using False"], ["proof (prove)\nusing this:\n  (qU - qU0) * h = (qx0 - qx') * xx * h\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. qU - qU0 = (qx0 - qx') * xx", "by (rule times_canc_right)"], ["proof (state)\nthis:\n  qU - qU0 = (qx0 - qx') * xx\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "have \"qx0 = qx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qx0 = qx'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "assume \"qx0 \\<noteq> qx'\""], ["proof (state)\nthis:\n  qx0 \\<noteq> qx'\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "hence \"qx0 - qx' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  qx0 \\<noteq> qx'\n\ngoal (1 subgoal):\n 1. qx0 - qx' \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  qx0 - qx' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  qx0 - qx' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "have \"xx \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx \\<noteq> 0", "by (simp add: xx_def monomial_0_iff)"], ["proof (state)\nthis:\n  xx \\<noteq> 0\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  qx0 - qx' \\<noteq> 0\n  xx \\<noteq> 0", "have \"lpp ((qx0 - qx') * xx) = lpp (qx0 - qx') + lpp xx\""], ["proof (prove)\nusing this:\n  qx0 - qx' \\<noteq> 0\n  xx \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp ((qx0 - qx') * xx) = lpp (qx0 - qx') + lpp xx", "by (rule lp_times)"], ["proof (state)\nthis:\n  lpp ((qx0 - qx') * xx) = lpp (qx0 - qx') + lpp xx\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lpp ((qx0 - qx') * xx) = lpp (qx0 - qx') + lpp xx\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "have \"lpp xx = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lpp xx = monomial (Suc 0) x", "by (simp add: xx_def punit.lt_monomial)"], ["proof (state)\nthis:\n  lpp xx = monomial (Suc 0) x\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lpp ((qx0 - qx') * xx) = lpp (qx0 - qx') + monomial (Suc 0) x", "have \"?x adds lpp (qU - qU0)\""], ["proof (prove)\nusing this:\n  lpp ((qx0 - qx') * xx) = lpp (qx0 - qx') + monomial (Suc 0) x\n\ngoal (1 subgoal):\n 1. monomial (Suc 0) x adds lpp (qU - qU0)", "by (simp add: eq)"], ["proof (state)\nthis:\n  monomial (Suc 0) x adds lpp (qU - qU0)\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "hence \"lookup ?x x \\<le> lookup (lpp (qU - qU0)) x\""], ["proof (prove)\nusing this:\n  monomial (Suc 0) x adds lpp (qU - qU0)\n\ngoal (1 subgoal):\n 1. lookup (monomial (Suc 0) x) x \\<le> lookup (lpp (qU - qU0)) x", "by (simp only: adds_poly_mapping le_fun_def)"], ["proof (state)\nthis:\n  lookup (monomial (Suc 0) x) x \\<le> lookup (lpp (qU - qU0)) x\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "hence \"x \\<in> keys (lpp (qU - qU0))\""], ["proof (prove)\nusing this:\n  lookup (monomial (Suc 0) x) x \\<le> lookup (lpp (qU - qU0)) x\n\ngoal (1 subgoal):\n 1. x \\<in> keys (lpp (qU - qU0))", "by (simp add: in_keys_iff lookup_single)"], ["proof (state)\nthis:\n  x \\<in> keys (lpp (qU - qU0))\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x \\<in> keys (lpp (qU - qU0))\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "have \"lpp (qU - qU0) \\<in> keys (qU - qU0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lpp (qU - qU0) \\<in> keys (qU - qU0)", "proof (rule punit.lt_in_keys)"], ["proof (state)\ngoal (1 subgoal):\n 1. qU - qU0 \\<noteq> 0", "from \\<open>qx0 - qx' \\<noteq> 0\\<close> \\<open>xx \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  qx0 - qx' \\<noteq> 0\n  xx \\<noteq> 0", "show \"qU - qU0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  qx0 - qx' \\<noteq> 0\n  xx \\<noteq> 0\n\ngoal (1 subgoal):\n 1. qU - qU0 \\<noteq> 0", "unfolding eq"], ["proof (prove)\nusing this:\n  qx0 - qx' \\<noteq> 0\n  xx \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (qx0 - qx') * xx \\<noteq> 0", "by (rule times_not_zero)"], ["proof (state)\nthis:\n  qU - qU0 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lpp (qU - qU0) \\<in> keys (qU - qU0)\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> keys (lpp (qU - qU0))\n  lpp (qU - qU0) \\<in> keys (qU - qU0)", "have \"x \\<in> indets (qU - qU0)\""], ["proof (prove)\nusing this:\n  x \\<in> keys (lpp (qU - qU0))\n  lpp (qU - qU0) \\<in> keys (qU - qU0)\n\ngoal (1 subgoal):\n 1. x \\<in> indets (qU - qU0)", "by (rule in_indetsI)"], ["proof (state)\nthis:\n  x \\<in> indets (qU - qU0)\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "from \\<open>qU \\<in> P[U]\\<close> \\<open>qU0 \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  qU \\<in> P[U]\n  qU0 \\<in> P[U]", "have \"qU - qU0 \\<in> P[U]\""], ["proof (prove)\nusing this:\n  qU \\<in> P[U]\n  qU0 \\<in> P[U]\n\ngoal (1 subgoal):\n 1. qU - qU0 \\<in> P[U]", "by (rule Polys_closed_minus)"], ["proof (state)\nthis:\n  qU - qU0 \\<in> P[U]\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "hence \"indets (qU - qU0) \\<subseteq> U\""], ["proof (prove)\nusing this:\n  qU - qU0 \\<in> P[U]\n\ngoal (1 subgoal):\n 1. indets (qU - qU0) \\<subseteq> U", "by (rule PolysD)"], ["proof (state)\nthis:\n  indets (qU - qU0) \\<subseteq> U\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "with \\<open>x \\<in> indets (qU - qU0)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> indets (qU - qU0)\n  indets (qU - qU0) \\<subseteq> U", "have \"x \\<in> U\""], ["proof (prove)\nusing this:\n  x \\<in> indets (qU - qU0)\n  indets (qU - qU0) \\<subseteq> U\n\ngoal (1 subgoal):\n 1. x \\<in> U", ".."], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. qx0 \\<noteq> qx' \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  x \\<notin> U\n  x \\<in> U", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qx0 = qx'\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "moreover"], ["proof (state)\nthis:\n  qx0 = qx'\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "from this eq"], ["proof (chain)\npicking this:\n  qx0 = qx'\n  qU - qU0 = (qx0 - qx') * xx", "have \"qU0 = qU\""], ["proof (prove)\nusing this:\n  qx0 = qx'\n  qU - qU0 = (qx0 - qx') * xx\n\ngoal (1 subgoal):\n 1. qU0 = qU", "by simp"], ["proof (state)\nthis:\n  qU0 = qU\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow> qs0 = qs", "ultimately"], ["proof (chain)\npicking this:\n  qx0 = qx'\n  qU0 = qU", "show ?thesis"], ["proof (prove)\nusing this:\n  qx0 = qx'\n  qU0 = qU\n\ngoal (1 subgoal):\n 1. qs0 = qs", "by (simp only: qs_def qs0 p1 p2)"], ["proof (state)\nthis:\n  qs0 = qs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qs0 = qs\n\ngoal (1 subgoal):\n 1. a = sum_list qs", "qed (simp_all add: qs_def a q qx, simp only: algebra_simps)"], ["proof (state)\nthis:\n  \\<exists>!qs.\n     qs \\<in> listset [cone (h, U), cone (xx * h, insert x U)] \\<and>\n     a = sum_list qs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  direct_decomp (cone (h, insert x U))\n   [cone (h, U), cone (xx * h, insert x U)]\n\ngoal:\nNo subgoals!", "qed"], ["", "definition valid_decomp :: \"'x set \\<Rightarrow> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<times> 'x set) list \\<Rightarrow> bool\"\n  where \"valid_decomp X ps \\<longleftrightarrow> ((\\<forall>(h, U)\\<in>set ps. h \\<in> P[X] \\<and> h \\<noteq> 0 \\<and> U \\<subseteq> X))\""], ["", "definition monomial_decomp :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{one,zero}) \\<times> 'x set) list \\<Rightarrow> bool\"\n  where \"monomial_decomp ps \\<longleftrightarrow> (\\<forall>hU\\<in>set ps. is_monomial (fst hU) \\<and> punit.lc (fst hU) = 1)\""], ["", "definition hom_decomp :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{one,zero}) \\<times> 'x set) list \\<Rightarrow> bool\"\n  where \"hom_decomp ps \\<longleftrightarrow> (\\<forall>hU\\<in>set ps. homogeneous (fst hU))\""], ["", "definition cone_decomp :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) set \\<Rightarrow>\n                            ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_semiring_0) \\<times> 'x set) list \\<Rightarrow> bool\"\n  where \"cone_decomp T ps \\<longleftrightarrow> direct_decomp T (map cone ps)\""], ["", "lemma valid_decompI:\n  \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]) \\<Longrightarrow> (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0) \\<Longrightarrow>\n    (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X) \\<Longrightarrow> valid_decomp X ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X];\n     \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0;\n     \\<And>h U.\n        (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> valid_decomp X ps", "unfolding valid_decomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X];\n     \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0;\n     \\<And>h U.\n        (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(h, U)\\<in>set ps.\n                         h \\<in> P[X] \\<and>\n                         h \\<noteq> 0 \\<and> U \\<subseteq> X", "by blast"], ["", "lemma valid_decompD:\n  assumes \"valid_decomp X ps\" and \"(h, U) \\<in> set ps\"\n  shows \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "using assms"], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "unfolding valid_decomp_def"], ["proof (prove)\nusing this:\n  \\<forall>(h, U)\\<in>set ps.\n     h \\<in> P[X] \\<and> h \\<noteq> 0 \\<and> U \\<subseteq> X\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "by blast+"], ["", "lemma valid_decompD_finite:\n  assumes \"finite X\" and \"valid_decomp X ps\" and \"(h, U) \\<in> set ps\"\n  shows \"finite U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite U", "from assms(2, 3)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. finite U", "thus ?thesis"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. finite U", "using assms(1)"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_decomp_Nil: \"valid_decomp X []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X []", "by (simp add: valid_decomp_def)"], ["", "lemma valid_decomp_concat:\n  assumes \"\\<And>ps. ps \\<in> set pss \\<Longrightarrow> valid_decomp X ps\"\n  shows \"valid_decomp X (concat pss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (concat pss)", "proof (rule valid_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (concat pss) \\<Longrightarrow> U \\<subseteq> X", "fix h U"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (concat pss) \\<Longrightarrow> U \\<subseteq> X", "assume \"(h, U) \\<in> set (concat pss)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (concat pss)\n\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (concat pss) \\<Longrightarrow> U \\<subseteq> X", "then"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (concat pss)", "obtain ps where \"ps \\<in> set pss\" and \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (concat pss)\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>ps \\<in> set pss; (h, U) \\<in> set ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_concat"], ["proof (prove)\nusing this:\n  (h, U) \\<in> \\<Union> (set ` set pss)\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>ps \\<in> set pss; (h, U) \\<in> set ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  ps \\<in> set pss\n  (h, U) \\<in> set ps\n\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (concat pss) \\<Longrightarrow> U \\<subseteq> X", "from this(1)"], ["proof (chain)\npicking this:\n  ps \\<in> set pss", "have \"valid_decomp X ps\""], ["proof (prove)\nusing this:\n  ps \\<in> set pss\n\ngoal (1 subgoal):\n 1. valid_decomp X ps", "by (rule assms)"], ["proof (state)\nthis:\n  valid_decomp X ps\n\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set (concat pss) \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (concat pss) \\<Longrightarrow> U \\<subseteq> X", "thus \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "using \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary valid_decomp_append:\n  assumes \"valid_decomp X ps\" and \"valid_decomp X qs\"\n  shows \"valid_decomp X (ps @ qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (ps @ qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_decomp X (ps @ qs)", "have \"valid_decomp X (concat [ps, qs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (concat [ps, qs])", "by (rule valid_decomp_concat) (auto simp: assms)"], ["proof (state)\nthis:\n  valid_decomp X (concat [ps, qs])\n\ngoal (1 subgoal):\n 1. valid_decomp X (ps @ qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X (concat [ps, qs])\n\ngoal (1 subgoal):\n 1. valid_decomp X (ps @ qs)", "by simp"], ["proof (state)\nthis:\n  valid_decomp X (ps @ qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_decomp_map_times:\n  assumes \"valid_decomp X ps\" and \"s \\<in> P[X]\" and \"s \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 _::semiring_no_zero_divisors)\"\n  shows \"valid_decomp X (map (apfst ((*) s)) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (map (apfst ((*) s)) ps)", "proof (rule valid_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "fix h U"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "assume \"(h, U) \\<in> set (map (apfst ((*) s)) ps)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (map (apfst ((*) s)) ps)\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "then"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (map (apfst ((*) s)) ps)", "obtain x where \"x \\<in> set ps\" and \"(h, U) = apfst ((*) s) x\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (map (apfst ((*) s)) ps)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set ps; (h, U) = apfst ((*) s) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_map"], ["proof (prove)\nusing this:\n  (h, U) \\<in> apfst ((*) s) ` set ps\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set ps; (h, U) = apfst ((*) s) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> set ps\n  (h, U) = apfst ((*) s) x\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "moreover"], ["proof (state)\nthis:\n  x \\<in> set ps\n  (h, U) = apfst ((*) s) x\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "obtain a b where \"x = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set ps\n  (h, U) = apfst ((*) s) x\n  x = (a, b)", "have h: \"h = s * a\" and \"(a, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  x \\<in> set ps\n  (h, U) = apfst ((*) s) x\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. h = s * a &&& (a, U) \\<in> set ps", "by simp_all"], ["proof (state)\nthis:\n  h = s * a\n  (a, U) \\<in> set ps\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "from assms(1) this(2)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (a, U) \\<in> set ps", "have \"a \\<in> P[X]\" and \"a \\<noteq> 0\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (a, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. a \\<in> P[X] &&& a \\<noteq> 0 &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  a \\<in> P[X]\n  a \\<noteq> 0\n  U \\<subseteq> X\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 3. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "from assms(2) this(1)"], ["proof (chain)\npicking this:\n  s \\<in> P[X]\n  a \\<in> P[X]", "show \"h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  s \\<in> P[X]\n  a \\<in> P[X]\n\ngoal (1 subgoal):\n 1. h \\<in> P[X]", "unfolding h"], ["proof (prove)\nusing this:\n  s \\<in> P[X]\n  a \\<in> P[X]\n\ngoal (1 subgoal):\n 1. s * a \\<in> P[X]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  h \\<in> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       h \\<noteq> 0\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "from assms(3) \\<open>a \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  s \\<noteq> 0\n  a \\<noteq> 0", "show \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "unfolding h"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s * a \\<noteq> 0", "by (rule times_not_zero)"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) s)) ps) \\<Longrightarrow>\n       U \\<subseteq> X", "from \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "show \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "."], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decompI:\n  \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> is_monomial h) \\<Longrightarrow> (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> punit.lc h = 1) \\<Longrightarrow>\n    monomial_decomp ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> is_monomial h;\n     \\<And>h U.\n        (h, U) \\<in> set ps \\<Longrightarrow> lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp ps", "by (auto simp: monomial_decomp_def)"], ["", "lemma monomial_decompD:\n  assumes \"monomial_decomp ps\" and \"(h, U) \\<in> set ps\"\n  shows \"is_monomial h\" and \"punit.lc h = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial h &&& lcf h = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. is_monomial h &&& lcf h = (1::'a)", "by (auto simp: monomial_decomp_def)"], ["", "lemma monomial_decomp_append_iff:\n  \"monomial_decomp (ps @ qs) \\<longleftrightarrow> monomial_decomp ps \\<and> monomial_decomp qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (ps @ qs) =\n    (monomial_decomp ps \\<and> monomial_decomp qs)", "by (auto simp: monomial_decomp_def)"], ["", "lemma monomial_decomp_concat:\n  \"(\\<And>ps. ps \\<in> set pss \\<Longrightarrow> monomial_decomp ps) \\<Longrightarrow> monomial_decomp (concat pss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        ps \\<in> set pss \\<Longrightarrow>\n        monomial_decomp ps) \\<Longrightarrow>\n    monomial_decomp (concat pss)", "by (induct pss) (auto simp: monomial_decomp_def)"], ["", "lemma monomial_decomp_map_times:\n  assumes \"monomial_decomp ps\" and \"is_monomial f\" and \"punit.lc f = (1::'a::semiring_1)\"\n  shows \"monomial_decomp (map (apfst ((*) f)) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (map (apfst ((*) f)) ps)", "proof (rule monomial_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "assume \"(h, U) \\<in> set (map (apfst ((*) f)) ps)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (map (apfst ((*) f)) ps)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "then"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (map (apfst ((*) f)) ps)", "obtain x where \"x \\<in> set ps\" and \"(h, U) = apfst ((*) f) x\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (map (apfst ((*) f)) ps)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set ps; (h, U) = apfst ((*) f) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_map"], ["proof (prove)\nusing this:\n  (h, U) \\<in> apfst ((*) f) ` set ps\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set ps; (h, U) = apfst ((*) f) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "moreover"], ["proof (state)\nthis:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "obtain a b where \"x = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n  x = (a, b)", "have h: \"h = f * a\" and \"(a, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. h = f * a &&& (a, U) \\<in> set ps", "by simp_all"], ["proof (state)\nthis:\n  h = f * a\n  (a, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "from assms(1) this(2)"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  (a, U) \\<in> set ps", "have \"is_monomial a\" and \"punit.lc a = 1\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  (a, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. is_monomial a &&& lcf a = (1::'a)", "by (rule monomial_decompD)+"], ["proof (state)\nthis:\n  is_monomial a\n  lcf a = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "from this(1)"], ["proof (chain)\npicking this:\n  is_monomial a", "have \"monomial (punit.lc a) (lpp a) = a\""], ["proof (prove)\nusing this:\n  is_monomial a\n\ngoal (1 subgoal):\n 1. monomial (lcf a) (lpp a) = a", "by (rule punit.monomial_eq_itself)"], ["proof (state)\nthis:\n  monomial (lcf a) (lpp a) = a\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "moreover"], ["proof (state)\nthis:\n  monomial (lcf a) (lpp a) = a\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "define t where \"t = lpp a\""], ["proof (state)\nthis:\n  t = lpp a\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  monomial (lcf a) (lpp a) = a\n  t = lpp a", "have a: \"a = monomial 1 t\""], ["proof (prove)\nusing this:\n  monomial (lcf a) (lpp a) = a\n  t = lpp a\n\ngoal (1 subgoal):\n 1. a = monomial (1::'a) t", "by (simp only: \\<open>punit.lc a = 1\\<close>)"], ["proof (state)\nthis:\n  a = monomial (1::'a) t\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "from assms(2)"], ["proof (chain)\npicking this:\n  is_monomial f", "have \"monomial (punit.lc f) (lpp f) = f\""], ["proof (prove)\nusing this:\n  is_monomial f\n\ngoal (1 subgoal):\n 1. monomial (lcf f) (lpp f) = f", "by (rule punit.monomial_eq_itself)"], ["proof (state)\nthis:\n  monomial (lcf f) (lpp f) = f\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "moreover"], ["proof (state)\nthis:\n  monomial (lcf f) (lpp f) = f\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "define s where \"s = lpp f\""], ["proof (state)\nthis:\n  s = lpp f\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "ultimately"], ["proof (chain)\npicking this:\n  monomial (lcf f) (lpp f) = f\n  s = lpp f", "have f: \"f = monomial 1 s\""], ["proof (prove)\nusing this:\n  monomial (lcf f) (lpp f) = f\n  s = lpp f\n\ngoal (1 subgoal):\n 1. f = monomial (1::'a) s", "by (simp only: assms(3))"], ["proof (state)\nthis:\n  f = monomial (1::'a) s\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       is_monomial h\n 2. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "show \"is_monomial h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial h", "by (simp add: h a f times_monomial_monomial monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial h\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       lcf h = (1::'a)", "show \"punit.lc h = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcf h = (1::'a)", "by (simp add: h a f times_monomial_monomial)"], ["proof (state)\nthis:\n  lcf h = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decomp_monomial_in_cone:\n  assumes \"monomial_decomp ps\" and \"hU \\<in> set ps\" and \"a \\<in> cone hU\"\n  shows \"monomial (lookup a t) t \\<in> cone hU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup a t) t \\<in> cone hU", "proof (cases \"t \\<in> keys a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "case True"], ["proof (state)\nthis:\n  t \\<in> keys a\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "with assms(2)"], ["proof (chain)\npicking this:\n  hU \\<in> set ps\n  hU = (h, U)", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  hU \\<in> set ps\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "with assms(1)"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps", "have \"is_monomial h\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. is_monomial h", "by (rule monomial_decompD)"], ["proof (state)\nthis:\n  is_monomial h\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "then"], ["proof (chain)\npicking this:\n  is_monomial h", "obtain c s where h: \"h = monomial c s\""], ["proof (prove)\nusing this:\n  is_monomial h\n\ngoal (1 subgoal):\n 1. (\\<And>s c. h = monomial c s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_monomial_monomial)"], ["proof (state)\nthis:\n  h = monomial c s\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "from assms(3)"], ["proof (chain)\npicking this:\n  a \\<in> cone hU", "obtain q where \"q \\<in> P[U]\" and \"a = q * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone hU\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[U]; a = q * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding hU"], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[U]; a = q * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[U]\n  a = q * h\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "from this(2)"], ["proof (chain)\npicking this:\n  a = q * h", "have \"a = h * q\""], ["proof (prove)\nusing this:\n  a = q * h\n\ngoal (1 subgoal):\n 1. a = h * q", "by (simp only: mult.commute)"], ["proof (state)\nthis:\n  a = h * q\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "also"], ["proof (state)\nthis:\n  a = h * q\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "have \"\\<dots> = punit.monom_mult c s q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h * q = local.punit.monom_mult c s q", "by (simp only: h times_monomial_left)"], ["proof (state)\nthis:\n  h * q = local.punit.monom_mult c s q\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "finally"], ["proof (chain)\npicking this:\n  a = local.punit.monom_mult c s q", "have a: \"a = punit.monom_mult c s q\""], ["proof (prove)\nusing this:\n  a = local.punit.monom_mult c s q\n\ngoal (1 subgoal):\n 1. a = local.punit.monom_mult c s q", "."], ["proof (state)\nthis:\n  a = local.punit.monom_mult c s q\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "with True"], ["proof (chain)\npicking this:\n  t \\<in> keys a\n  a = local.punit.monom_mult c s q", "have \"t \\<in> keys (punit.monom_mult c s q)\""], ["proof (prove)\nusing this:\n  t \\<in> keys a\n  a = local.punit.monom_mult c s q\n\ngoal (1 subgoal):\n 1. t \\<in> keys (local.punit.monom_mult c s q)", "by simp"], ["proof (state)\nthis:\n  t \\<in> keys (local.punit.monom_mult c s q)\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "hence \"t \\<in> (+) s ` keys q\""], ["proof (prove)\nusing this:\n  t \\<in> keys (local.punit.monom_mult c s q)\n\ngoal (1 subgoal):\n 1. t \\<in> (+) s ` keys q", "using punit.keys_monom_mult_subset[simplified]"], ["proof (prove)\nusing this:\n  t \\<in> keys (local.punit.monom_mult c s q)\n  keys (local.punit.monom_mult ?c ?t ?p) \\<subseteq> (+) ?t ` keys ?p\n\ngoal (1 subgoal):\n 1. t \\<in> (+) s ` keys q", ".."], ["proof (state)\nthis:\n  t \\<in> (+) s ` keys q\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "then"], ["proof (chain)\npicking this:\n  t \\<in> (+) s ` keys q", "obtain u where \"u \\<in> keys q\" and t: \"t = s + u\""], ["proof (prove)\nusing this:\n  t \\<in> (+) s ` keys q\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> keys q; t = s + u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> keys q\n  t = s + u\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "note this(1)"], ["proof (state)\nthis:\n  u \\<in> keys q\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "also"], ["proof (state)\nthis:\n  u \\<in> keys q\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "from \\<open>q \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[U]", "have \"keys q \\<subseteq> .[U]\""], ["proof (prove)\nusing this:\n  q \\<in> P[U]\n\ngoal (1 subgoal):\n 1. keys q \\<subseteq> .[U]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys q \\<subseteq> .[U]\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "finally"], ["proof (chain)\npicking this:\n  u \\<in> .[U]", "have \"u \\<in> .[U]\""], ["proof (prove)\nusing this:\n  u \\<in> .[U]\n\ngoal (1 subgoal):\n 1. u \\<in> .[U]", "."], ["proof (state)\nthis:\n  u \\<in> .[U]\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "have \"monomial (lookup a t) t = monomial (lookup q u) u * h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (lookup a t) t = monomial (lookup q u) u * h", "by (simp add: a t punit.lookup_monom_mult h times_monomial_monomial mult.commute)"], ["proof (state)\nthis:\n  monomial (lookup a t) t = monomial (lookup q u) u * h\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "moreover"], ["proof (state)\nthis:\n  monomial (lookup a t) t = monomial (lookup q u) u * h\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "from \\<open>u \\<in> .[U]\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> .[U]", "have \"monomial (lookup q u) u \\<in> P[U]\""], ["proof (prove)\nusing this:\n  u \\<in> .[U]\n\ngoal (1 subgoal):\n 1. monomial (lookup q u) u \\<in> P[U]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (lookup q u) u \\<in> P[U]\n\ngoal (2 subgoals):\n 1. t \\<in> keys a \\<Longrightarrow> monomial (lookup a t) t \\<in> cone hU\n 2. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "ultimately"], ["proof (chain)\npicking this:\n  monomial (lookup a t) t = monomial (lookup q u) u * h\n  monomial (lookup q u) u \\<in> P[U]", "show ?thesis"], ["proof (prove)\nusing this:\n  monomial (lookup a t) t = monomial (lookup q u) u * h\n  monomial (lookup q u) u \\<in> P[U]\n\ngoal (1 subgoal):\n 1. monomial (lookup a t) t \\<in> cone hU", "unfolding hU"], ["proof (prove)\nusing this:\n  monomial (lookup a t) t = monomial (lookup q u) u * h\n  monomial (lookup q u) u \\<in> P[U]\n\ngoal (1 subgoal):\n 1. monomial (lookup a t) t \\<in> cone (h, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial (lookup a t) t \\<in> cone hU\n\ngoal (1 subgoal):\n 1. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "case False"], ["proof (state)\nthis:\n  t \\<notin> keys a\n\ngoal (1 subgoal):\n 1. t \\<notin> keys a \\<Longrightarrow>\n    monomial (lookup a t) t \\<in> cone hU", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<notin> keys a\n\ngoal (1 subgoal):\n 1. monomial (lookup a t) t \\<in> cone hU", "by (simp add: zero_in_cone in_keys_iff)"], ["proof (state)\nthis:\n  monomial (lookup a t) t \\<in> cone hU\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decomp_sum_list_monomial_in_cone:\n  assumes \"monomial_decomp ps\" and \"a \\<in> sum_list ` listset (map cone ps)\" and \"t \\<in> keys a\"\n  obtains c h U where \"(h, U) \\<in> set ps\" and \"c \\<noteq> 0\" and \"monomial c t \\<in> cone (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  a \\<in> sum_list ` listset (map cone ps)", "obtain qs where qs_in: \"qs \\<in> listset (map cone ps)\" and a: \"a = sum_list qs\""], ["proof (prove)\nusing this:\n  a \\<in> sum_list ` listset (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> listset (map cone ps); a = sum_list qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  qs \\<in> listset (map cone ps)\n  a = sum_list qs\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(3) keys_sum_list_subset"], ["proof (chain)\npicking this:\n  t \\<in> keys a\n  keys (sum_list ?ps) \\<subseteq> Keys (set ?ps)", "have \"t \\<in> Keys (set qs)\""], ["proof (prove)\nusing this:\n  t \\<in> keys a\n  keys (sum_list ?ps) \\<subseteq> Keys (set ?ps)\n\ngoal (1 subgoal):\n 1. t \\<in> Keys (set qs)", "unfolding a"], ["proof (prove)\nusing this:\n  t \\<in> keys (sum_list qs)\n  keys (sum_list ?ps) \\<subseteq> Keys (set ?ps)\n\ngoal (1 subgoal):\n 1. t \\<in> Keys (set qs)", ".."], ["proof (state)\nthis:\n  t \\<in> Keys (set qs)\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  t \\<in> Keys (set qs)", "obtain q where \"q \\<in> set qs\" and \"t \\<in> keys q\""], ["proof (prove)\nusing this:\n  t \\<in> Keys (set qs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set qs; t \\<in> keys q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  q \\<in> set qs\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1)"], ["proof (chain)\npicking this:\n  q \\<in> set qs", "obtain i where \"i < length qs\" and q: \"q = qs ! i\""], ["proof (prove)\nusing this:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length qs; q = qs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length qs\n  q = qs ! i\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  i < length qs\n  q = qs ! i\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from qs_in"], ["proof (chain)\npicking this:\n  qs \\<in> listset (map cone ps)", "have \"length qs = length (map cone ps)\""], ["proof (prove)\nusing this:\n  qs \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. length qs = length (map cone ps)", "by (rule listsetD)"], ["proof (state)\nthis:\n  length qs = length (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  i < length qs\n  q = qs ! i\n  length qs = length (map cone ps)", "have \"i < length (map cone ps)\""], ["proof (prove)\nusing this:\n  i < length qs\n  q = qs ! i\n  length qs = length (map cone ps)\n\ngoal (1 subgoal):\n 1. i < length (map cone ps)", "by simp"], ["proof (state)\nthis:\n  i < length (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  i < length (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from qs_in this"], ["proof (chain)\npicking this:\n  qs \\<in> listset (map cone ps)\n  i < length (map cone ps)", "have \"qs ! i \\<in> (map cone ps) ! i\""], ["proof (prove)\nusing this:\n  qs \\<in> listset (map cone ps)\n  i < length (map cone ps)\n\ngoal (1 subgoal):\n 1. qs ! i \\<in> map cone ps ! i", "by (rule listsetD)"], ["proof (state)\nthis:\n  qs ! i \\<in> map cone ps ! i\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  i < length (map cone ps)\n  qs ! i \\<in> map cone ps ! i", "have \"ps ! i \\<in> set ps\" and \"q \\<in> cone (ps ! i)\""], ["proof (prove)\nusing this:\n  i < length (map cone ps)\n  qs ! i \\<in> map cone ps ! i\n\ngoal (1 subgoal):\n 1. ps ! i \\<in> set ps &&& q \\<in> cone (ps ! i)", "by (simp_all add: q)"], ["proof (state)\nthis:\n  ps ! i \\<in> set ps\n  q \\<in> cone (ps ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1)"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  ps ! i \\<in> set ps\n  q \\<in> cone (ps ! i)", "have *: \"monomial (lookup q t) t \\<in> cone (ps ! i)\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  ps ! i \\<in> set ps\n  q \\<in> cone (ps ! i)\n\ngoal (1 subgoal):\n 1. monomial (lookup q t) t \\<in> cone (ps ! i)", "by (rule monomial_decomp_monomial_in_cone)"], ["proof (state)\nthis:\n  monomial (lookup q t) t \\<in> cone (ps ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain h U where psi: \"ps ! i = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. ps ! i = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. ps ! i = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ps ! i = (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set ps; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (?h11, ?U11) \\<in> set ps\n 2. ?c11 \\<noteq> (0::'a)\n 3. monomial ?c11 t \\<in> cone (?h11, ?U11)", "from \\<open>ps ! i \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  ps ! i \\<in> set ps", "show \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  ps ! i \\<in> set ps\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by (simp only: psi)"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. ?c11 \\<noteq> (0::'a)\n 2. monomial ?c11 t \\<in> cone (h, U)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ?c11 \\<noteq> (0::'a)\n 2. monomial ?c11 t \\<in> cone (h, U)", "from \\<open>t \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys q", "show \"lookup q t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. lookup q t \\<noteq> (0::'a)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup q t \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. monomial (lookup q t) t \\<in> cone (h, U)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial (lookup q t) t \\<in> cone (h, U)", "from *"], ["proof (chain)\npicking this:\n  monomial (lookup q t) t \\<in> cone (ps ! i)", "show \"monomial (lookup q t) t \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  monomial (lookup q t) t \\<in> cone (ps ! i)\n\ngoal (1 subgoal):\n 1. monomial (lookup q t) t \\<in> cone (h, U)", "by (simp only: psi)"], ["proof (state)\nthis:\n  monomial (lookup q t) t \\<in> cone (h, U)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_decompI: \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h) \\<Longrightarrow> hom_decomp ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        (h, U) \\<in> set ps \\<Longrightarrow>\n        homogeneous h) \\<Longrightarrow>\n    hom_decomp ps", "by (auto simp: hom_decomp_def)"], ["", "lemma hom_decompD: \"hom_decomp ps \\<Longrightarrow> (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hom_decomp ps; (h, U) \\<in> set ps\\<rbrakk>\n    \\<Longrightarrow> homogeneous h", "by (auto simp: hom_decomp_def)"], ["", "lemma hom_decomp_append_iff: \"hom_decomp (ps @ qs) \\<longleftrightarrow> hom_decomp ps \\<and> hom_decomp qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (ps @ qs) = (hom_decomp ps \\<and> hom_decomp qs)", "by (auto simp: hom_decomp_def)"], ["", "lemma hom_decomp_concat: \"(\\<And>ps. ps \\<in> set pss \\<Longrightarrow> hom_decomp ps) \\<Longrightarrow> hom_decomp (concat pss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        ps \\<in> set pss \\<Longrightarrow> hom_decomp ps) \\<Longrightarrow>\n    hom_decomp (concat pss)", "by (induct pss) (auto simp: hom_decomp_def)"], ["", "lemma hom_decomp_map_times:\n  assumes \"hom_decomp ps\" and \"homogeneous f\"\n  shows \"hom_decomp (map (apfst ((*) f)) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (map (apfst ((*) f)) ps)", "proof (rule hom_decompI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "fix h U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "assume \"(h, U) \\<in> set (map (apfst ((*) f)) ps)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (map (apfst ((*) f)) ps)\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "then"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (map (apfst ((*) f)) ps)", "obtain x where \"x \\<in> set ps\" and \"(h, U) = apfst ((*) f) x\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (map (apfst ((*) f)) ps)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set ps; (h, U) = apfst ((*) f) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_map"], ["proof (prove)\nusing this:\n  (h, U) \\<in> apfst ((*) f) ` set ps\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set ps; (h, U) = apfst ((*) f) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "moreover"], ["proof (state)\nthis:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "obtain a b where \"x = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>a b. x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n  x = (a, b)", "have h: \"h = f * a\" and \"(a, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  x \\<in> set ps\n  (h, U) = apfst ((*) f) x\n  x = (a, b)\n\ngoal (1 subgoal):\n 1. h = f * a &&& (a, U) \\<in> set ps", "by simp_all"], ["proof (state)\nthis:\n  h = f * a\n  (a, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "from assms(1) this(2)"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  (a, U) \\<in> set ps", "have \"homogeneous a\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  (a, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. homogeneous a", "by (rule hom_decompD)"], ["proof (state)\nthis:\n  homogeneous a\n\ngoal (1 subgoal):\n 1. \\<And>h U.\n       (h, U) \\<in> set (map (apfst ((*) f)) ps) \\<Longrightarrow>\n       homogeneous h", "with assms(2)"], ["proof (chain)\npicking this:\n  homogeneous f\n  homogeneous a", "show \"homogeneous h\""], ["proof (prove)\nusing this:\n  homogeneous f\n  homogeneous a\n\ngoal (1 subgoal):\n 1. homogeneous h", "unfolding h"], ["proof (prove)\nusing this:\n  homogeneous f\n  homogeneous a\n\ngoal (1 subgoal):\n 1. homogeneous (f * a)", "by (rule homogeneous_times)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decomp_imp_hom_decomp:\n  assumes \"monomial_decomp ps\"\n  shows \"hom_decomp ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp ps", "proof (rule hom_decompI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h", "fix h U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h", "with assms"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps", "have \"is_monomial h\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. is_monomial h", "by (rule monomial_decompD)"], ["proof (state)\nthis:\n  is_monomial h\n\ngoal (1 subgoal):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h", "then"], ["proof (chain)\npicking this:\n  is_monomial h", "obtain c t where h: \"h = monomial c t\""], ["proof (prove)\nusing this:\n  is_monomial h\n\ngoal (1 subgoal):\n 1. (\\<And>t c. h = monomial c t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_monomial_monomial)"], ["proof (state)\nthis:\n  h = monomial c t\n\ngoal (1 subgoal):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> homogeneous h", "show \"homogeneous h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous h", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous (monomial c t)", "by (fact homogeneous_monomial)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decompI: \"direct_decomp T (map cone ps) \\<Longrightarrow> cone_decomp T ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps) \\<Longrightarrow> cone_decomp T ps", "unfolding cone_decomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps) \\<Longrightarrow>\n    direct_decomp T (map cone ps)", "by blast"], ["", "lemma cone_decompD: \"cone_decomp T ps \\<Longrightarrow> direct_decomp T (map cone ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T ps \\<Longrightarrow> direct_decomp T (map cone ps)", "unfolding cone_decomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps) \\<Longrightarrow>\n    direct_decomp T (map cone ps)", "by blast"], ["", "lemma cone_decomp_cone_subset:\n  assumes \"cone_decomp T ps\" and \"hU \\<in> set ps\"\n  shows \"cone hU \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone hU \\<subseteq> T", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "assume \"p \\<in> cone hU\""], ["proof (state)\nthis:\n  p \\<in> cone hU\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "from assms(2)"], ["proof (chain)\npicking this:\n  hU \\<in> set ps", "obtain i where \"i < length ps\" and hU: \"hU = ps ! i\""], ["proof (prove)\nusing this:\n  hU \\<in> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length ps; hU = ps ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length ps\n  hU = ps ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "define qs where \"qs = (map 0 ps)[i := p]\""], ["proof (state)\nthis:\n  qs = (map 0 ps)[i := p]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "have \"sum_list qs \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list qs \\<in> T", "proof (intro direct_decompD listsetI)"], ["proof (state)\ngoal (3 subgoals):\n 1. direct_decomp T ?ss\n 2. length qs = length ?ss\n 3. \\<And>i. i < length ?ss \\<Longrightarrow> qs ! i \\<in> ?ss ! i", "from assms(1)"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "show \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (2 subgoals):\n 1. length qs = length (map cone ps)\n 2. \\<And>i.\n       i < length (map cone ps) \\<Longrightarrow>\n       qs ! i \\<in> map cone ps ! i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length qs = length (map cone ps)\n 2. \\<And>i.\n       i < length (map cone ps) \\<Longrightarrow>\n       qs ! i \\<in> map cone ps ! i", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. length qs = length (map cone ps)\n 2. \\<And>i.\n       i < length (map cone ps) \\<Longrightarrow>\n       qs ! i \\<in> map cone ps ! i", "assume \"j < length (map cone ps)\""], ["proof (state)\nthis:\n  j < length (map cone ps)\n\ngoal (2 subgoals):\n 1. length qs = length (map cone ps)\n 2. \\<And>i.\n       i < length (map cone ps) \\<Longrightarrow>\n       qs ! i \\<in> map cone ps ! i", "with \\<open>i < length ps\\<close> \\<open>p \\<in> cone hU\\<close>"], ["proof (chain)\npicking this:\n  i < length ps\n  p \\<in> cone hU\n  j < length (map cone ps)", "show \"qs ! j \\<in> map cone ps ! j\""], ["proof (prove)\nusing this:\n  i < length ps\n  p \\<in> cone hU\n  j < length (map cone ps)\n\ngoal (1 subgoal):\n 1. qs ! j \\<in> map cone ps ! j", "by (auto simp: qs_def nth_list_update zero_in_cone hU)"], ["proof (state)\nthis:\n  qs ! j \\<in> map cone ps ! j\n\ngoal (1 subgoal):\n 1. length qs = length (map cone ps)", "qed (simp add: qs_def)"], ["proof (state)\nthis:\n  sum_list qs \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "also"], ["proof (state)\nthis:\n  sum_list qs \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "have \"sum_list qs = qs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list qs = qs ! i", "by (rule sum_list_eq_nthI) (simp_all add: qs_def \\<open>i < length ps\\<close>)"], ["proof (state)\nthis:\n  sum_list qs = qs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "also"], ["proof (state)\nthis:\n  sum_list qs = qs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "from \\<open>i < length ps\\<close>"], ["proof (chain)\npicking this:\n  i < length ps", "have \"\\<dots> = p\""], ["proof (prove)\nusing this:\n  i < length ps\n\ngoal (1 subgoal):\n 1. qs ! i = p", "by (simp add: qs_def)"], ["proof (state)\nthis:\n  qs ! i = p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone hU \\<Longrightarrow> x \\<in> T", "finally"], ["proof (chain)\npicking this:\n  p \\<in> T", "show \"p \\<in> T\""], ["proof (prove)\nusing this:\n  p \\<in> T\n\ngoal (1 subgoal):\n 1. p \\<in> T", "."], ["proof (state)\nthis:\n  p \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_indets:\n  assumes \"cone_decomp T ps\" and \"T \\<subseteq> P[X]\" and \"(h, U) \\<in> set ps\"\n  shows \"h \\<in> P[X]\" and \"h \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 _::{comm_semiring_1,semiring_no_zero_divisors}) \\<Longrightarrow> U \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& (h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. h \\<in> P[X]\n 2. h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X", "from assms(1, 3)"], ["proof (chain)\npicking this:\n  cone_decomp T ps\n  (h, U) \\<in> set ps", "have \"cone (h, U) \\<subseteq> T\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> T", "by (rule cone_decomp_cone_subset)"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> T\n\ngoal (2 subgoals):\n 1. h \\<in> P[X]\n 2. h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X", "hence \"cone (h, U) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  cone (h, U) \\<subseteq> T\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "using assms(2)"], ["proof (prove)\nusing this:\n  cone (h, U) \\<subseteq> T\n  T \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "by (rule subset_trans)"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. h \\<in> P[X]\n 2. h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X", "thus \"h \\<in> P[X]\" and \"h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& (h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X)", "by (rule cone_subset_PolysD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0 \\<Longrightarrow> U \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_closed_plus:\n  assumes \"cone_decomp T ps\" and \"a \\<in> T\" and \"b \\<in> T\"\n  shows \"a + b \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b \\<in> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + b \\<in> T", "from assms(1)"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "have dd: \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "then"], ["proof (chain)\npicking this:\n  direct_decomp T (map cone ps)", "obtain qsa where qsa: \"qsa \\<in> listset (map cone ps)\" and a: \"a = sum_list qsa\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>qsa.\n        \\<lbrakk>qsa \\<in> listset (map cone ps); a = sum_list qsa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n  a \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>qsa.\n        \\<lbrakk>qsa \\<in> listset (map cone ps); a = sum_list qsa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  qsa \\<in> listset (map cone ps)\n  a = sum_list qsa\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "from dd assms(3)"], ["proof (chain)\npicking this:\n  direct_decomp T (map cone ps)\n  b \\<in> T", "obtain qsb where qsb: \"qsb \\<in> listset (map cone ps)\" and b: \"b = sum_list qsb\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n  b \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>qsb.\n        \\<lbrakk>qsb \\<in> listset (map cone ps); b = sum_list qsb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  qsb \\<in> listset (map cone ps)\n  b = sum_list qsb\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "from qsa"], ["proof (chain)\npicking this:\n  qsa \\<in> listset (map cone ps)", "have \"length qsa = length (map cone ps)\""], ["proof (prove)\nusing this:\n  qsa \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. length qsa = length (map cone ps)", "by (rule listsetD)"], ["proof (state)\nthis:\n  length qsa = length (map cone ps)\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "moreover"], ["proof (state)\nthis:\n  length qsa = length (map cone ps)\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "from qsb"], ["proof (chain)\npicking this:\n  qsb \\<in> listset (map cone ps)", "have \"length qsb = length (map cone ps)\""], ["proof (prove)\nusing this:\n  qsb \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. length qsb = length (map cone ps)", "by (rule listsetD)"], ["proof (state)\nthis:\n  length qsb = length (map cone ps)\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "ultimately"], ["proof (chain)\npicking this:\n  length qsa = length (map cone ps)\n  length qsb = length (map cone ps)", "have \"a + b = sum_list (map2 (+) qsa qsb)\""], ["proof (prove)\nusing this:\n  length qsa = length (map cone ps)\n  length qsb = length (map cone ps)\n\ngoal (1 subgoal):\n 1. a + b = sum_list (map2 (+) qsa qsb)", "by (simp only: sum_list_map2_plus a b)"], ["proof (state)\nthis:\n  a + b = sum_list (map2 (+) qsa qsb)\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "also"], ["proof (state)\nthis:\n  a + b = sum_list (map2 (+) qsa qsb)\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "from dd"], ["proof (chain)\npicking this:\n  direct_decomp T (map cone ps)", "have \"sum_list (map2 (+) qsa qsb) \\<in> T\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. sum_list (map2 (+) qsa qsb) \\<in> T", "proof (rule direct_decompD)"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 (+) qsa qsb \\<in> listset (map cone ps)", "from qsa qsb"], ["proof (chain)\npicking this:\n  qsa \\<in> listset (map cone ps)\n  qsb \\<in> listset (map cone ps)", "show \"map2 (+) qsa qsb \\<in> listset (map cone ps)\""], ["proof (prove)\nusing this:\n  qsa \\<in> listset (map cone ps)\n  qsb \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. map2 (+) qsa qsb \\<in> listset (map cone ps)", "proof (rule listset_closed_map2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y1 y2.\n       \\<lbrakk>x \\<in> set (map cone ps); y1 \\<in> x; y2 \\<in> x\\<rbrakk>\n       \\<Longrightarrow> y1 + y2 \\<in> x", "fix c p1 p2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y1 y2.\n       \\<lbrakk>x \\<in> set (map cone ps); y1 \\<in> x; y2 \\<in> x\\<rbrakk>\n       \\<Longrightarrow> y1 + y2 \\<in> x", "assume \"c \\<in> set (map cone ps)\""], ["proof (state)\nthis:\n  c \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y1 y2.\n       \\<lbrakk>x \\<in> set (map cone ps); y1 \\<in> x; y2 \\<in> x\\<rbrakk>\n       \\<Longrightarrow> y1 + y2 \\<in> x", "then"], ["proof (chain)\npicking this:\n  c \\<in> set (map cone ps)", "obtain hU where c: \"c = cone hU\""], ["proof (prove)\nusing this:\n  c \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>hU. c = cone hU \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = cone hU\n\ngoal (1 subgoal):\n 1. \\<And>x y1 y2.\n       \\<lbrakk>x \\<in> set (map cone ps); y1 \\<in> x; y2 \\<in> x\\<rbrakk>\n       \\<Longrightarrow> y1 + y2 \\<in> x", "assume \"p1 \\<in> c\" and \"p2 \\<in> c\""], ["proof (state)\nthis:\n  p1 \\<in> c\n  p2 \\<in> c\n\ngoal (1 subgoal):\n 1. \\<And>x y1 y2.\n       \\<lbrakk>x \\<in> set (map cone ps); y1 \\<in> x; y2 \\<in> x\\<rbrakk>\n       \\<Longrightarrow> y1 + y2 \\<in> x", "thus \"p1 + p2 \\<in> c\""], ["proof (prove)\nusing this:\n  p1 \\<in> c\n  p2 \\<in> c\n\ngoal (1 subgoal):\n 1. p1 + p2 \\<in> c", "unfolding c"], ["proof (prove)\nusing this:\n  p1 \\<in> cone hU\n  p2 \\<in> cone hU\n\ngoal (1 subgoal):\n 1. p1 + p2 \\<in> cone hU", "by (rule cone_closed_plus)"], ["proof (state)\nthis:\n  p1 + p2 \\<in> c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map2 (+) qsa qsb \\<in> listset (map cone ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map2 (+) qsa qsb) \\<in> T\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "finally"], ["proof (chain)\npicking this:\n  a + b \\<in> T", "show ?thesis"], ["proof (prove)\nusing this:\n  a + b \\<in> T\n\ngoal (1 subgoal):\n 1. a + b \\<in> T", "."], ["proof (state)\nthis:\n  a + b \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_closed_uminus:\n  assumes \"cone_decomp T ps\" and \"(a::_ \\<Rightarrow>\\<^sub>0 _::comm_ring) \\<in> T\"\n  shows \"- a \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a \\<in> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - a \\<in> T", "from assms(1)"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "have dd: \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. - a \\<in> T", "then"], ["proof (chain)\npicking this:\n  direct_decomp T (map cone ps)", "obtain qsa where qsa: \"qsa \\<in> listset (map cone ps)\" and a: \"a = sum_list qsa\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>qsa.\n        \\<lbrakk>qsa \\<in> listset (map cone ps); a = sum_list qsa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n  a \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>qsa.\n        \\<lbrakk>qsa \\<in> listset (map cone ps); a = sum_list qsa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  qsa \\<in> listset (map cone ps)\n  a = sum_list qsa\n\ngoal (1 subgoal):\n 1. - a \\<in> T", "from qsa"], ["proof (chain)\npicking this:\n  qsa \\<in> listset (map cone ps)", "have \"length qsa = length (map cone ps)\""], ["proof (prove)\nusing this:\n  qsa \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. length qsa = length (map cone ps)", "by (rule listsetD)"], ["proof (state)\nthis:\n  length qsa = length (map cone ps)\n\ngoal (1 subgoal):\n 1. - a \\<in> T", "have \"- a = sum_list (map uminus qsa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a = sum_list (map uminus qsa)", "unfolding a"], ["proof (prove)\ngoal (1 subgoal):\n 1. - sum_list qsa = sum_list (map uminus qsa)", "by (induct qsa, simp_all)"], ["proof (state)\nthis:\n  - a = sum_list (map uminus qsa)\n\ngoal (1 subgoal):\n 1. - a \\<in> T", "also"], ["proof (state)\nthis:\n  - a = sum_list (map uminus qsa)\n\ngoal (1 subgoal):\n 1. - a \\<in> T", "from dd"], ["proof (chain)\npicking this:\n  direct_decomp T (map cone ps)", "have \"\\<dots> \\<in> T\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. sum_list (map uminus qsa) \\<in> T", "proof (rule direct_decompD)"], ["proof (state)\ngoal (1 subgoal):\n 1. map uminus qsa \\<in> listset (map cone ps)", "from qsa"], ["proof (chain)\npicking this:\n  qsa \\<in> listset (map cone ps)", "show \"map uminus qsa \\<in> listset (map cone ps)\""], ["proof (prove)\nusing this:\n  qsa \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. map uminus qsa \\<in> listset (map cone ps)", "proof (rule listset_closed_map)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map cone ps); y \\<in> x\\<rbrakk>\n       \\<Longrightarrow> - y \\<in> x", "fix c p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map cone ps); y \\<in> x\\<rbrakk>\n       \\<Longrightarrow> - y \\<in> x", "assume \"c \\<in> set (map cone ps)\""], ["proof (state)\nthis:\n  c \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map cone ps); y \\<in> x\\<rbrakk>\n       \\<Longrightarrow> - y \\<in> x", "then"], ["proof (chain)\npicking this:\n  c \\<in> set (map cone ps)", "obtain hU where c: \"c = cone hU\""], ["proof (prove)\nusing this:\n  c \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>hU. c = cone hU \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = cone hU\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map cone ps); y \\<in> x\\<rbrakk>\n       \\<Longrightarrow> - y \\<in> x", "assume \"p \\<in> c\""], ["proof (state)\nthis:\n  p \\<in> c\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map cone ps); y \\<in> x\\<rbrakk>\n       \\<Longrightarrow> - y \\<in> x", "thus \"- p \\<in> c\""], ["proof (prove)\nusing this:\n  p \\<in> c\n\ngoal (1 subgoal):\n 1. - p \\<in> c", "unfolding c"], ["proof (prove)\nusing this:\n  p \\<in> cone hU\n\ngoal (1 subgoal):\n 1. - p \\<in> cone hU", "by (rule cone_closed_uminus)"], ["proof (state)\nthis:\n  - p \\<in> c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map uminus qsa \\<in> listset (map cone ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map uminus qsa) \\<in> T\n\ngoal (1 subgoal):\n 1. - a \\<in> T", "finally"], ["proof (chain)\npicking this:\n  - a \\<in> T", "show ?thesis"], ["proof (prove)\nusing this:\n  - a \\<in> T\n\ngoal (1 subgoal):\n 1. - a \\<in> T", "."], ["proof (state)\nthis:\n  - a \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cone_decomp_closed_minus:\n  assumes \"cone_decomp T ps\" and \"(a::_ \\<Rightarrow>\\<^sub>0 _::comm_ring) \\<in> T\" and \"b \\<in> T\"\n  shows \"a - b \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b \\<in> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a - b \\<in> T", "from assms(1, 3)"], ["proof (chain)\npicking this:\n  cone_decomp T ps\n  b \\<in> T", "have \"- b \\<in> T\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n  b \\<in> T\n\ngoal (1 subgoal):\n 1. - b \\<in> T", "by (rule cone_decomp_closed_uminus)"], ["proof (state)\nthis:\n  - b \\<in> T\n\ngoal (1 subgoal):\n 1. a - b \\<in> T", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  cone_decomp T ps\n  a \\<in> T\n  - b \\<in> T", "have \"a + (- b) \\<in> T\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n  a \\<in> T\n  - b \\<in> T\n\ngoal (1 subgoal):\n 1. a + - b \\<in> T", "by (rule cone_decomp_closed_plus)"], ["proof (state)\nthis:\n  a + - b \\<in> T\n\ngoal (1 subgoal):\n 1. a - b \\<in> T", "thus ?thesis"], ["proof (prove)\nusing this:\n  a + - b \\<in> T\n\ngoal (1 subgoal):\n 1. a - b \\<in> T", "by simp"], ["proof (state)\nthis:\n  a - b \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_Nil: \"cone_decomp {0} []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp {0} []", "by (auto simp: cone_decomp_def intro: direct_decompI_alt)"], ["", "lemma cone_decomp_singleton: \"cone_decomp (cone (t, U)) [(t, U)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp (cone (t, U)) [(t, U)]", "by (simp add: cone_decomp_def direct_decomp_singleton)"], ["", "lemma cone_decomp_append:\n  assumes \"direct_decomp T [S1, S2]\" and \"cone_decomp S1 ps\" and \"cone_decomp S2 qs\"\n  shows \"cone_decomp T (ps @ qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (ps @ qs)", "proof (rule cone_decompI)"], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "from assms(2)"], ["proof (chain)\npicking this:\n  cone_decomp S1 ps", "have \"direct_decomp S1 (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp S1 ps\n\ngoal (1 subgoal):\n 1. direct_decomp S1 (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp S1 (map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "with assms(1)"], ["proof (chain)\npicking this:\n  direct_decomp T [S1, S2]\n  direct_decomp S1 (map cone ps)", "have \"direct_decomp T ([S2] @ map cone ps)\""], ["proof (prove)\nusing this:\n  direct_decomp T [S1, S2]\n  direct_decomp S1 (map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T ([S2] @ map cone ps)", "by (rule direct_decomp_direct_decomp)"], ["proof (state)\nthis:\n  direct_decomp T ([S2] @ map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "hence \"direct_decomp T (S2 # map cone ps)\""], ["proof (prove)\nusing this:\n  direct_decomp T ([S2] @ map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (S2 # map cone ps)", "by simp"], ["proof (state)\nthis:\n  direct_decomp T (S2 # map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "moreover"], ["proof (state)\nthis:\n  direct_decomp T (S2 # map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "from assms(3)"], ["proof (chain)\npicking this:\n  cone_decomp S2 qs", "have \"direct_decomp S2 (map cone qs)\""], ["proof (prove)\nusing this:\n  cone_decomp S2 qs\n\ngoal (1 subgoal):\n 1. direct_decomp S2 (map cone qs)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp S2 (map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "ultimately"], ["proof (chain)\npicking this:\n  direct_decomp T (S2 # map cone ps)\n  direct_decomp S2 (map cone qs)", "have \"direct_decomp T (map cone ps @ map cone qs)\""], ["proof (prove)\nusing this:\n  direct_decomp T (S2 # map cone ps)\n  direct_decomp S2 (map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps @ map cone qs)", "by (intro direct_decomp_direct_decomp)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps @ map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "thus \"direct_decomp T (map cone (ps @ qs))\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps @ map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (ps @ qs))", "by simp"], ["proof (state)\nthis:\n  direct_decomp T (map cone (ps @ qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_concat:\n  assumes \"direct_decomp T ss\" and \"length pss = length ss\"\n    and \"\\<And>i. i < length ss \\<Longrightarrow> cone_decomp (ss ! i) (pss ! i)\"\n  shows \"cone_decomp T (concat pss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (concat pss)", "using assms(2, 1, 3)"], ["proof (prove)\nusing this:\n  length pss = length ss\n  direct_decomp T ss\n  ?i11 < length ss \\<Longrightarrow> cone_decomp (ss ! ?i11) (pss ! ?i11)\n\ngoal (1 subgoal):\n 1. cone_decomp T (concat pss)", "proof (induct pss ss arbitrary: T rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>direct_decomp T [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           cone_decomp ([] ! i) ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat [])\n 2. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "case Nil"], ["proof (state)\nthis:\n  direct_decomp T []\n  ?i11 < length [] \\<Longrightarrow> cone_decomp ([] ! ?i11) ([] ! ?i11)\n\ngoal (2 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>direct_decomp T [];\n        \\<And>i.\n           i < length [] \\<Longrightarrow>\n           cone_decomp ([] ! i) ([] ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat [])\n 2. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "from Nil(1)"], ["proof (chain)\npicking this:\n  direct_decomp T []", "show ?case"], ["proof (prove)\nusing this:\n  direct_decomp T []\n\ngoal (1 subgoal):\n 1. cone_decomp T (concat [])", "by (simp add: cone_decomp_def)"], ["proof (state)\nthis:\n  cone_decomp T (concat [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "case (Cons ps pss s ss)"], ["proof (state)\nthis:\n  length pss = length ss\n  \\<lbrakk>direct_decomp ?T11 ss;\n   \\<And>i.\n      i < length ss \\<Longrightarrow>\n      cone_decomp (ss ! i) (pss ! i)\\<rbrakk>\n  \\<Longrightarrow> cone_decomp ?T11 (concat pss)\n  direct_decomp T (s # ss)\n  ?i11 < length (s # ss) \\<Longrightarrow>\n  cone_decomp ((s # ss) ! ?i11) ((ps # pss) ! ?i11)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "have \"0 < length (s # ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (s # ss)", "by simp"], ["proof (state)\nthis:\n  0 < length (s # ss)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "hence \"cone_decomp ((s # ss) ! 0) ((ps # pss) ! 0)\""], ["proof (prove)\nusing this:\n  0 < length (s # ss)\n\ngoal (1 subgoal):\n 1. cone_decomp ((s # ss) ! 0) ((ps # pss) ! 0)", "by (rule Cons.prems)"], ["proof (state)\nthis:\n  cone_decomp ((s # ss) ! 0) ((ps # pss) ! 0)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "hence \"cone_decomp s ps\""], ["proof (prove)\nusing this:\n  cone_decomp ((s # ss) ! 0) ((ps # pss) ! 0)\n\ngoal (1 subgoal):\n 1. cone_decomp s ps", "by simp"], ["proof (state)\nthis:\n  cone_decomp s ps\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "hence *: \"direct_decomp s (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp s ps\n\ngoal (1 subgoal):\n 1. direct_decomp s (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp s (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "with Cons.prems(1)"], ["proof (chain)\npicking this:\n  direct_decomp T (s # ss)\n  direct_decomp s (map cone ps)", "have \"direct_decomp T (ss @ map cone ps)\""], ["proof (prove)\nusing this:\n  direct_decomp T (s # ss)\n  direct_decomp s (map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (ss @ map cone ps)", "by (rule direct_decomp_direct_decomp)"], ["proof (state)\nthis:\n  direct_decomp T (ss @ map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "hence 1: \"direct_decomp T [sum_list ` listset ss, sum_list ` listset (map cone ps)]\"\n    and 2: \"direct_decomp (sum_list ` listset ss) ss\""], ["proof (prove)\nusing this:\n  direct_decomp T (ss @ map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T\n     [sum_list ` listset ss, sum_list ` listset (map cone ps)] &&&\n    direct_decomp (sum_list ` listset ss) ss", "by (auto dest: direct_decomp_appendD intro!: empty_not_in_map_cone)"], ["proof (state)\nthis:\n  direct_decomp T [sum_list ` listset ss, sum_list ` listset (map cone ps)]\n  direct_decomp (sum_list ` listset ss) ss\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "note 1"], ["proof (state)\nthis:\n  direct_decomp T [sum_list ` listset ss, sum_list ` listset (map cone ps)]\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "moreover"], ["proof (state)\nthis:\n  direct_decomp T [sum_list ` listset ss, sum_list ` listset (map cone ps)]\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "from 2"], ["proof (chain)\npicking this:\n  direct_decomp (sum_list ` listset ss) ss", "have \"cone_decomp (sum_list ` listset ss) (concat pss)\""], ["proof (prove)\nusing this:\n  direct_decomp (sum_list ` listset ss) ss\n\ngoal (1 subgoal):\n 1. cone_decomp (sum_list ` listset ss) (concat pss)", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ss \\<Longrightarrow> cone_decomp (ss ! i) (pss ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ss \\<Longrightarrow> cone_decomp (ss ! i) (pss ! i)", "assume \"i < length ss\""], ["proof (state)\nthis:\n  i < length ss\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ss \\<Longrightarrow> cone_decomp (ss ! i) (pss ! i)", "hence \"Suc i < length (s # ss)\""], ["proof (prove)\nusing this:\n  i < length ss\n\ngoal (1 subgoal):\n 1. Suc i < length (s # ss)", "by simp"], ["proof (state)\nthis:\n  Suc i < length (s # ss)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ss \\<Longrightarrow> cone_decomp (ss ! i) (pss ! i)", "hence \"cone_decomp ((s # ss) ! Suc i) ((ps # pss) ! Suc i)\""], ["proof (prove)\nusing this:\n  Suc i < length (s # ss)\n\ngoal (1 subgoal):\n 1. cone_decomp ((s # ss) ! Suc i) ((ps # pss) ! Suc i)", "by (rule Cons.prems)"], ["proof (state)\nthis:\n  cone_decomp ((s # ss) ! Suc i) ((ps # pss) ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ss \\<Longrightarrow> cone_decomp (ss ! i) (pss ! i)", "thus \"cone_decomp (ss ! i) (pss ! i)\""], ["proof (prove)\nusing this:\n  cone_decomp ((s # ss) ! Suc i) ((ps # pss) ! Suc i)\n\ngoal (1 subgoal):\n 1. cone_decomp (ss ! i) (pss ! i)", "by simp"], ["proof (state)\nthis:\n  cone_decomp (ss ! i) (pss ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone_decomp (sum_list ` listset ss) (concat pss)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "moreover"], ["proof (state)\nthis:\n  cone_decomp (sum_list ` listset ss) (concat pss)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "have \"cone_decomp (sum_list ` listset (map cone ps)) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp (sum_list ` listset (map cone ps)) ps", "proof (intro cone_decompI direct_decompI refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on sum_list (listset (map cone ps))", "from *"], ["proof (chain)\npicking this:\n  direct_decomp s (map cone ps)", "show \"inj_on sum_list (listset (map cone ps))\""], ["proof (prove)\nusing this:\n  direct_decomp s (map cone ps)\n\ngoal (1 subgoal):\n 1. inj_on sum_list (listset (map cone ps))", "by (simp only: direct_decomp_def bij_betw_def)"], ["proof (state)\nthis:\n  inj_on sum_list (listset (map cone ps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone_decomp (sum_list ` listset (map cone ps)) ps\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "ultimately"], ["proof (chain)\npicking this:\n  direct_decomp T [sum_list ` listset ss, sum_list ` listset (map cone ps)]\n  cone_decomp (sum_list ` listset ss) (concat pss)\n  cone_decomp (sum_list ` listset (map cone ps)) ps", "have \"cone_decomp T (concat pss @ ps)\""], ["proof (prove)\nusing this:\n  direct_decomp T [sum_list ` listset ss, sum_list ` listset (map cone ps)]\n  cone_decomp (sum_list ` listset ss) (concat pss)\n  cone_decomp (sum_list ` listset (map cone ps)) ps\n\ngoal (1 subgoal):\n 1. cone_decomp T (concat pss @ ps)", "by (rule cone_decomp_append)"], ["proof (state)\nthis:\n  cone_decomp T (concat pss @ ps)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "hence \"direct_decomp T (map cone (concat pss) @ map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T (concat pss @ ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone (concat pss) @ map cone ps)", "by (simp add: cone_decomp_def)"], ["proof (state)\nthis:\n  direct_decomp T (map cone (concat pss) @ map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "hence \"direct_decomp T (map cone ps @ map cone (concat pss))\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone (concat pss) @ map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps @ map cone (concat pss))", "using perm_append_swap"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone (concat pss) @ map cone ps)\n  ?xs @ ?ys <~~> ?ys @ ?xs\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps @ map cone (concat pss))", "by (rule direct_decomp_perm)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps @ map cone (concat pss))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys T.\n       \\<lbrakk>length xs = length ys;\n        \\<And>T.\n           \\<lbrakk>direct_decomp T ys;\n            \\<And>i.\n               i < length ys \\<Longrightarrow>\n               cone_decomp (ys ! i) (xs ! i)\\<rbrakk>\n           \\<Longrightarrow> cone_decomp T (concat xs);\n        direct_decomp T (y # ys);\n        \\<And>i.\n           i < length (y # ys) \\<Longrightarrow>\n           cone_decomp ((y # ys) ! i) ((x # xs) ! i)\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (concat (x # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps @ map cone (concat pss))\n\ngoal (1 subgoal):\n 1. cone_decomp T (concat (ps # pss))", "by (simp add: cone_decomp_def)"], ["proof (state)\nthis:\n  cone_decomp T (concat (ps # pss))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_map_times:\n  assumes \"cone_decomp T ps\"\n  shows \"cone_decomp ((*) s ` T) (map (apfst ((*) (s::_ \\<Rightarrow>\\<^sub>0 _::{comm_ring_1,ring_no_zero_divisors}))) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp ((*) s ` T) (map (apfst ((*) s)) ps)", "proof (rule cone_decompI)"], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))", "from assms"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "have \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))", "hence \"direct_decomp ((*) s ` T) (map ((`) ((*) s)) (map cone ps))\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp ((*) s ` T) (map ((`) ((*) s)) (map cone ps))", "by (rule direct_decomp_image_times) (rule times_canc_left)"], ["proof (state)\nthis:\n  direct_decomp ((*) s ` T) (map ((`) ((*) s)) (map cone ps))\n\ngoal (1 subgoal):\n 1. direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))", "also"], ["proof (state)\nthis:\n  direct_decomp ((*) s ` T) (map ((`) ((*) s)) (map cone ps))\n\ngoal (1 subgoal):\n 1. direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))", "have \"map ((`) ((*) s)) (map cone ps) = map cone (map (apfst ((*) s)) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((`) ((*) s)) (map cone ps) = map cone (map (apfst ((*) s)) ps)", "by (simp add: cone_image_times')"], ["proof (state)\nthis:\n  map ((`) ((*) s)) (map cone ps) = map cone (map (apfst ((*) s)) ps)\n\ngoal (1 subgoal):\n 1. direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))", "finally"], ["proof (chain)\npicking this:\n  direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))", "show \"direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))\""], ["proof (prove)\nusing this:\n  direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))\n\ngoal (1 subgoal):\n 1. direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))", "."], ["proof (state)\nthis:\n  direct_decomp ((*) s ` T) (map cone (map (apfst ((*) s)) ps))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_perm:\n  assumes \"cone_decomp T ps\" and \"perm ps qs\"\n  shows \"cone_decomp T qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T qs", "using assms(1)"], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. cone_decomp T qs", "unfolding cone_decomp_def"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone qs)", "proof (rule direct_decomp_perm)"], ["proof (state)\ngoal (1 subgoal):\n 1. map cone ps <~~> map cone qs", "from assms(2)"], ["proof (chain)\npicking this:\n  ps <~~> qs", "show \"perm (map cone ps) (map cone qs)\""], ["proof (prove)\nusing this:\n  ps <~~> qs\n\ngoal (1 subgoal):\n 1. map cone ps <~~> map cone qs", "by (induct ps qs rule: perm.induct) auto"], ["proof (state)\nthis:\n  map cone ps <~~> map cone qs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_cone_decomp_subset_Polys:\n  assumes \"valid_decomp X ps\" and \"cone_decomp T ps\"\n  shows \"T \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> P[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<in> P[X]", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<in> P[X]", "assume \"p \\<in> T\""], ["proof (state)\nthis:\n  p \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<in> P[X]", "from assms(2)"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "have \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  direct_decomp T (map cone ps)", "obtain qs where \"qs \\<in> listset (map cone ps)\" and p: \"p = sum_list qs\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> listset (map cone ps); p = sum_list qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p \\<in> T\\<close>"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps)\n  p \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>qs \\<in> listset (map cone ps); p = sum_list qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  qs \\<in> listset (map cone ps)\n  p = sum_list qs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<in> P[X]", "from assms(1) this(1)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  qs \\<in> listset (map cone ps)", "show \"p \\<in> P[X]\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  qs \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. p \\<in> P[X]", "unfolding p"], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  qs \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. sum_list qs \\<in> P[X]", "proof (induct ps arbitrary: qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X []; qs \\<in> listset (map cone [])\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]\n 2. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "case Nil"], ["proof (state)\nthis:\n  valid_decomp X []\n  qs \\<in> listset (map cone [])\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X []; qs \\<in> listset (map cone [])\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]\n 2. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "from Nil(2)"], ["proof (chain)\npicking this:\n  qs \\<in> listset (map cone [])", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<in> listset (map cone [])\n\ngoal (1 subgoal):\n 1. sum_list qs \\<in> P[X]", "by (simp add: zero_in_Polys)"], ["proof (state)\nthis:\n  sum_list qs \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "case (Cons a ps)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ps; ?qs11 \\<in> listset (map cone ps)\\<rbrakk>\n  \\<Longrightarrow> sum_list ?qs11 \\<in> P[X]\n  valid_decomp X (a # ps)\n  qs \\<in> listset (map cone (a # ps))\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "obtain h U where a: \"a = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. a = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. a = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "hence \"(h, U) \\<in> set (a # ps)\""], ["proof (prove)\nusing this:\n  a = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (a # ps)", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set (a # ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "with Cons.prems(1)"], ["proof (chain)\npicking this:\n  valid_decomp X (a # ps)\n  (h, U) \\<in> set (a # ps)", "have \"h \\<in> P[X]\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X (a # ps)\n  (h, U) \\<in> set (a # ps)\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "hence \"cone a \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. cone a \\<subseteq> P[X]", "unfolding a"], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "by (rule cone_subset_PolysI)"], ["proof (state)\nthis:\n  cone a \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  valid_decomp X (a # ps)", "have \"valid_decomp X ps\""], ["proof (prove)\nusing this:\n  valid_decomp X (a # ps)\n\ngoal (1 subgoal):\n 1. valid_decomp X ps", "by (simp add: valid_decomp_def)"], ["proof (state)\nthis:\n  valid_decomp X ps\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  qs \\<in> listset (map cone (a # ps))", "have \"qs \\<in> listset (cone a # map cone ps)\""], ["proof (prove)\nusing this:\n  qs \\<in> listset (map cone (a # ps))\n\ngoal (1 subgoal):\n 1. qs \\<in> listset (cone a # map cone ps)", "by simp"], ["proof (state)\nthis:\n  qs \\<in> listset (cone a # map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  qs \\<in> listset (cone a # map cone ps)", "obtain q qs' where \"q \\<in> cone a\" and qs': \"qs' \\<in> listset (map cone ps)\" and qs: \"qs = q # qs'\""], ["proof (prove)\nusing this:\n  qs \\<in> listset (cone a # map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>q qs'.\n        \\<lbrakk>q \\<in> cone a; qs' \\<in> listset (map cone ps);\n         qs = q # qs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_ConsE)"], ["proof (state)\nthis:\n  q \\<in> cone a\n  qs' \\<in> listset (map cone ps)\n  qs = q # qs'\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "from this(1) \\<open>cone a \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> cone a\n  cone a \\<subseteq> P[X]", "have \"q \\<in> P[X]\""], ["proof (prove)\nusing this:\n  q \\<in> cone a\n  cone a \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. q \\<in> P[X]", ".."], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "moreover"], ["proof (state)\nthis:\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "from \\<open>valid_decomp X ps\\<close> qs'"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  qs' \\<in> listset (map cone ps)", "have \"sum_list qs' \\<in> P[X]\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  qs' \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. sum_list qs' \\<in> P[X]", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  sum_list qs' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "ultimately"], ["proof (chain)\npicking this:\n  q \\<in> P[X]\n  sum_list qs' \\<in> P[X]", "have \"q + sum_list qs' \\<in> P[X]\""], ["proof (prove)\nusing this:\n  q \\<in> P[X]\n  sum_list qs' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. q + sum_list qs' \\<in> P[X]", "by (rule Polys_closed_plus)"], ["proof (state)\nthis:\n  q + sum_list qs' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>a ps qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X ps;\n                    qs \\<in> listset (map cone ps)\\<rbrakk>\n                   \\<Longrightarrow> sum_list qs \\<in> P[X];\n        valid_decomp X (a # ps);\n        qs \\<in> listset (map cone (a # ps))\\<rbrakk>\n       \\<Longrightarrow> sum_list qs \\<in> P[X]", "thus ?case"], ["proof (prove)\nusing this:\n  q + sum_list qs' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. sum_list qs \\<in> P[X]", "by (simp add: qs)"], ["proof (state)\nthis:\n  sum_list qs \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma homogeneous_set_cone_decomp:\n  assumes \"cone_decomp T ps\" and \"hom_decomp ps\"\n  shows \"homogeneous_set T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homogeneous_set T", "proof (rule homogeneous_set_direct_decomp)"], ["proof (state)\ngoal (2 subgoals):\n 1. direct_decomp T ?ss\n 2. \\<And>s. s \\<in> set ?ss \\<Longrightarrow> homogeneous_set s", "from assms(1)"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "show \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "fix cn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "assume \"cn \\<in> set (map cone ps)\""], ["proof (state)\nthis:\n  cn \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "then"], ["proof (chain)\npicking this:\n  cn \\<in> set (map cone ps)", "obtain hU where \"hU \\<in> set ps\" and cn: \"cn = cone hU\""], ["proof (prove)\nusing this:\n  cn \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>hU.\n        \\<lbrakk>hU \\<in> set ps; cn = cone hU\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_map"], ["proof (prove)\nusing this:\n  cn \\<in> cone ` set ps\n\ngoal (1 subgoal):\n 1. (\\<And>hU.\n        \\<lbrakk>hU \\<in> set ps; cn = cone hU\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  hU \\<in> set ps\n  cn = cone hU\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "moreover"], ["proof (state)\nthis:\n  hU \\<in> set ps\n  cn = cone hU\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "ultimately"], ["proof (chain)\npicking this:\n  hU \\<in> set ps\n  cn = cone hU\n  hU = (h, U)", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  hU \\<in> set ps\n  cn = cone hU\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "with assms(2)"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  (h, U) \\<in> set ps", "have \"homogeneous h\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_decompD)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> homogeneous_set s", "thus \"homogeneous_set cn\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. homogeneous_set cn", "unfolding cn hU"], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. homogeneous_set (cone (h, U))", "by (rule homogeneous_set_coneI)"], ["proof (state)\nthis:\n  homogeneous_set cn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subspace_cone_decomp:\n  assumes \"cone_decomp T ps\"\n  shows \"phull.subspace (T::(_ \\<Rightarrow>\\<^sub>0 _::field) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phull.subspace T", "proof (rule phull.subspace_direct_decomp)"], ["proof (state)\ngoal (2 subgoals):\n 1. direct_decomp T ?ss\n 2. \\<And>s. s \\<in> set ?ss \\<Longrightarrow> phull.subspace s", "from assms"], ["proof (chain)\npicking this:\n  cone_decomp T ps", "show \"direct_decomp T (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "fix cn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "assume \"cn \\<in> set (map cone ps)\""], ["proof (state)\nthis:\n  cn \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "then"], ["proof (chain)\npicking this:\n  cn \\<in> set (map cone ps)", "obtain hU where \"hU \\<in> set ps\" and cn: \"cn = cone hU\""], ["proof (prove)\nusing this:\n  cn \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>hU.\n        \\<lbrakk>hU \\<in> set ps; cn = cone hU\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_map"], ["proof (prove)\nusing this:\n  cn \\<in> cone ` set ps\n\ngoal (1 subgoal):\n 1. (\\<And>hU.\n        \\<lbrakk>hU \\<in> set ps; cn = cone hU\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  hU \\<in> set ps\n  cn = cone hU\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> phull.subspace s", "show \"phull.subspace cn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phull.subspace cn", "unfolding cn"], ["proof (prove)\ngoal (1 subgoal):\n 1. phull.subspace (cone hU)", "by (rule subspace_cone)"], ["proof (state)\nthis:\n  phull.subspace cn\n\ngoal:\nNo subgoals!", "qed"], ["", "definition pos_decomp :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<Rightarrow> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list\"\n    (\"(_\\<^sub>+)\" [1000] 999)\n    where \"pos_decomp ps = filter (\\<lambda>p. snd p \\<noteq> {}) ps\""], ["", "definition standard_decomp :: \"nat \\<Rightarrow> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<times> 'x set) list \\<Rightarrow> bool\"\n  where \"standard_decomp k ps \\<longleftrightarrow> (\\<forall>(h, U)\\<in>set (ps\\<^sub>+). k \\<le> poly_deg h \\<and>\n                                      (\\<forall>d. k \\<le> d \\<longrightarrow> d \\<le> poly_deg h \\<longrightarrow>\n                                        (\\<exists>(h', U')\\<in>set ps. poly_deg h' = d \\<and> card U \\<le> card U')))\""], ["", "lemma pos_decomp_Nil [simp]: \"[]\\<^sub>+ = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. []\\<^sub>+ = []", "by (simp add: pos_decomp_def)"], ["", "lemma pos_decomp_subset: \"set (ps\\<^sub>+) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ps\\<^sub>+) \\<subseteq> set ps", "by (simp add: pos_decomp_def)"], ["", "lemma pos_decomp_append: \"(ps @ qs)\\<^sub>+ = ps\\<^sub>+ @ qs\\<^sub>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps @ qs)\\<^sub>+ = ps\\<^sub>+ @ qs\\<^sub>+", "by (simp add: pos_decomp_def)"], ["", "lemma pos_decomp_concat: \"(concat pss)\\<^sub>+ = concat (map pos_decomp pss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (concat pss)\\<^sub>+ = concat (map pos_decomp pss)", "by (metis (mono_tags, lifting) filter_concat map_eq_conv pos_decomp_def)"], ["", "lemma pos_decomp_map: \"(map (apfst f) ps)\\<^sub>+ = map (apfst f) (ps\\<^sub>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (apfst f) ps)\\<^sub>+ = map (apfst f) (ps\\<^sub>+)", "by (metis (mono_tags, lifting) pos_decomp_def filter_cong filter_map o_apply snd_apfst)"], ["", "lemma card_Diff_pos_decomp: \"card {(h, U) \\<in> set qs - set (qs\\<^sub>+). P h} = card {h. (h, {}) \\<in> set qs \\<and> P h}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h} =\n    card {h. (h, {}) \\<in> set qs \\<and> P h}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h} =\n    card {h. (h, {}) \\<in> set qs \\<and> P h}", "have \"{h. (h, {}) \\<in> set qs \\<and> P h} = fst ` {(h, U) \\<in> set qs - set (qs\\<^sub>+). P h}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {h. (h, {}) \\<in> set qs \\<and> P h} =\n    fst ` {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}", "by (auto simp: pos_decomp_def image_Collect)"], ["proof (state)\nthis:\n  {h. (h, {}) \\<in> set qs \\<and> P h} =\n  fst ` {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}\n\ngoal (1 subgoal):\n 1. card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h} =\n    card {h. (h, {}) \\<in> set qs \\<and> P h}", "also"], ["proof (state)\nthis:\n  {h. (h, {}) \\<in> set qs \\<and> P h} =\n  fst ` {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}\n\ngoal (1 subgoal):\n 1. card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h} =\n    card {h. (h, {}) \\<in> set qs \\<and> P h}", "have \"card \\<dots> = card {(h, U) \\<in> set qs - set (qs\\<^sub>+). P h}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (fst ` {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}) =\n    card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}", "by (rule card_image, auto simp: pos_decomp_def intro: inj_onI)"], ["proof (state)\nthis:\n  card (fst ` {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}) =\n  card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}\n\ngoal (1 subgoal):\n 1. card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h} =\n    card {h. (h, {}) \\<in> set qs \\<and> P h}", "finally"], ["proof (chain)\npicking this:\n  card {h. (h, {}) \\<in> set qs \\<and> P h} =\n  card\n   {a. case a of\n       (h, U) \\<Rightarrow>\n         (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}", "show ?thesis"], ["proof (prove)\nusing this:\n  card {h. (h, {}) \\<in> set qs \\<and> P h} =\n  card\n   {a. case a of\n       (h, U) \\<Rightarrow>\n         (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h}\n\ngoal (1 subgoal):\n 1. card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h} =\n    card {h. (h, {}) \\<in> set qs \\<and> P h}", "by (rule sym)"], ["proof (state)\nthis:\n  card {(h, U). (h, U) \\<in> set qs - set (qs\\<^sub>+) \\<and> P h} =\n  card {h. (h, {}) \\<in> set qs \\<and> P h}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_decompI:\n  assumes \"\\<And>h U. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h\"\n    and \"\\<And>h U d. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> d \\<Longrightarrow> d \\<le> poly_deg h \\<Longrightarrow>\n          (\\<exists>h' U'. (h', U') \\<in> set ps \\<and> poly_deg h' = d \\<and> card U \\<le> card U')\"\n  shows \"standard_decomp k ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp k ps", "unfolding standard_decomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(h, U)\\<in>set (ps\\<^sub>+).\n       k \\<le> poly_deg h \\<and>\n       (\\<forall>d\\<ge>k.\n           d \\<le> poly_deg h \\<longrightarrow>\n           (\\<exists>(h', U')\\<in>set ps.\n               poly_deg h' = d \\<and> card U \\<le> card U'))", "using assms"], ["proof (prove)\nusing this:\n  (?h13, ?U13) \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n  k \\<le> poly_deg ?h13\n  \\<lbrakk>(?h13, ?U13) \\<in> set (ps\\<^sub>+); k \\<le> ?d13;\n   ?d13 \\<le> poly_deg ?h13\\<rbrakk>\n  \\<Longrightarrow> \\<exists>h' U'.\n                       (h', U') \\<in> set ps \\<and>\n                       poly_deg h' = ?d13 \\<and> card ?U13 \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<forall>(h, U)\\<in>set (ps\\<^sub>+).\n       k \\<le> poly_deg h \\<and>\n       (\\<forall>d\\<ge>k.\n           d \\<le> poly_deg h \\<longrightarrow>\n           (\\<exists>(h', U')\\<in>set ps.\n               poly_deg h' = d \\<and> card U \\<le> card U'))", "by blast"], ["", "lemma standard_decompD: \"standard_decomp k ps \\<Longrightarrow> (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>standard_decomp k ps; (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> poly_deg h", "unfolding standard_decomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(h, U)\\<in>set (ps\\<^sub>+).\n                k \\<le> poly_deg h \\<and>\n                (\\<forall>d\\<ge>k.\n                    d \\<le> poly_deg h \\<longrightarrow>\n                    (\\<exists>(h', U')\\<in>set ps.\n                        poly_deg h' = d \\<and> card U \\<le> card U'));\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> k \\<le> poly_deg h", "by blast"], ["", "lemma standard_decompE:\n  assumes \"standard_decomp k ps\" and \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"k \\<le> d\" and \"d \\<le> poly_deg h\"\n  obtains h' U' where \"(h', U') \\<in> set ps\" and \"poly_deg h' = d\" and \"card U \\<le> card U'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding standard_decomp_def"], ["proof (prove)\nusing this:\n  \\<forall>(h, U)\\<in>set (ps\\<^sub>+).\n     k \\<le> poly_deg h \\<and>\n     (\\<forall>d\\<ge>k.\n         d \\<le> poly_deg h \\<longrightarrow>\n         (\\<exists>(h', U')\\<in>set ps.\n             poly_deg h' = d \\<and> card U \\<le> card U'))\n  (h, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma standard_decomp_Nil: \"ps\\<^sub>+ = [] \\<Longrightarrow> standard_decomp k ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> standard_decomp k ps", "by (simp add: standard_decomp_def)"], ["", "lemma standard_decomp_singleton: \"standard_decomp (poly_deg h) [(h, U)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (poly_deg h) [(h, U)]", "by (simp add: standard_decomp_def pos_decomp_def)"], ["", "lemma standard_decomp_concat:\n  assumes \"\\<And>ps. ps \\<in> set pss \\<Longrightarrow> standard_decomp k ps\"\n  shows \"standard_decomp k (concat pss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp k (concat pss)", "proof (rule standard_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((concat pss)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((concat pss)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"(h, U) \\<in> set ((concat pss)\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ((concat pss)\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((concat pss)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "then"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ((concat pss)\\<^sub>+)", "obtain ps where \"ps \\<in> set pss\" and *: \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ((concat pss)\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>ps \\<in> set pss; (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: pos_decomp_concat)"], ["proof (state)\nthis:\n  ps \\<in> set pss\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((concat pss)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from this(1)"], ["proof (chain)\npicking this:\n  ps \\<in> set pss", "have \"standard_decomp k ps\""], ["proof (prove)\nusing this:\n  ps \\<in> set pss\n\ngoal (1 subgoal):\n 1. standard_decomp k ps", "by (rule assms)"], ["proof (state)\nthis:\n  standard_decomp k ps\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((concat pss)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "thus \"k \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "using *"], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  k \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"k \\<le> d\" and \"d \\<le> poly_deg h\""], ["proof (state)\nthis:\n  k \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with \\<open>standard_decomp k ps\\<close> *"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h", "obtain h' U' where \"(h', U') \\<in> set ps\" and \"poly_deg h' = d\"\n    and \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "note this(2, 3)"], ["proof (state)\nthis:\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from \\<open>(h', U') \\<in> set ps\\<close> \\<open>ps \\<in> set pss\\<close>"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps\n  ps \\<in> set pss", "have \"(h', U') \\<in> set (concat pss)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n  ps \\<in> set pss\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (concat pss)", "by auto"], ["proof (state)\nthis:\n  (h', U') \\<in> set (concat pss)\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((concat pss)\\<^sub>+); k \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (concat pss) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  poly_deg h' = d\n  card U \\<le> card U'\n  (h', U') \\<in> set (concat pss)", "show \"\\<exists>h' U'. (h', U') \\<in> set (concat pss) \\<and> poly_deg h' = d \\<and> card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  poly_deg h' = d\n  card U \\<le> card U'\n  (h', U') \\<in> set (concat pss)\n\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set (concat pss) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "by blast"], ["proof (state)\nthis:\n  \\<exists>h' U'.\n     (h', U') \\<in> set (concat pss) \\<and>\n     poly_deg h' = d \\<and> card U \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary standard_decomp_append:\n  assumes \"standard_decomp k ps\" and \"standard_decomp k qs\"\n  shows \"standard_decomp k (ps @ qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp k (ps @ qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. standard_decomp k (ps @ qs)", "have \"standard_decomp k (concat [ps, qs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp k (concat [ps, qs])", "by (rule standard_decomp_concat) (auto simp: assms)"], ["proof (state)\nthis:\n  standard_decomp k (concat [ps, qs])\n\ngoal (1 subgoal):\n 1. standard_decomp k (ps @ qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  standard_decomp k (concat [ps, qs])\n\ngoal (1 subgoal):\n 1. standard_decomp k (ps @ qs)", "by simp"], ["proof (state)\nthis:\n  standard_decomp k (ps @ qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_decomp_map_times:\n  assumes \"standard_decomp k ps\" and \"valid_decomp X ps\" and \"s \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 'a::semiring_no_zero_divisors)\"\n  shows \"standard_decomp (k + poly_deg s) (map (apfst ((*) s)) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (k + poly_deg s) (map (apfst ((*) s)) ps)", "proof (rule standard_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "then"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+)", "obtain h0 where 1: \"(h0, U) \\<in> set (ps\\<^sub>+)\" and h: \"h = s * h0\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h0.\n        \\<lbrakk>(h0, U) \\<in> set (ps\\<^sub>+); h = s * h0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: pos_decomp_map)"], ["proof (state)\nthis:\n  (h0, U) \\<in> set (ps\\<^sub>+)\n  h = s * h0\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from this(1) pos_decomp_subset"], ["proof (chain)\npicking this:\n  (h0, U) \\<in> set (ps\\<^sub>+)\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps", "have \"(h0, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  (h0, U) \\<in> set (ps\\<^sub>+)\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps\n\ngoal (1 subgoal):\n 1. (h0, U) \\<in> set ps", ".."], ["proof (state)\nthis:\n  (h0, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with assms(2)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h0, U) \\<in> set ps", "have \"h0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h0, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h0 \\<noteq> 0", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  h0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with assms(3)"], ["proof (chain)\npicking this:\n  s \\<noteq> 0\n  h0 \\<noteq> 0", "have deg_h: \"poly_deg h = poly_deg s + poly_deg h0\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  h0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg h = poly_deg s + poly_deg h0", "unfolding h"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  h0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg (s * h0) = poly_deg s + poly_deg h0", "by (rule poly_deg_times)"], ["proof (state)\nthis:\n  poly_deg h = poly_deg s + poly_deg h0\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  poly_deg h = poly_deg s + poly_deg h0\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from assms(1) 1"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h0, U) \\<in> set (ps\\<^sub>+)", "have \"k \\<le> poly_deg h0\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h0, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h0", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  k \\<le> poly_deg h0\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+) \\<Longrightarrow>\n       k + poly_deg s \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  poly_deg h = poly_deg s + poly_deg h0\n  k \\<le> poly_deg h0", "show \"k + poly_deg s \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  poly_deg h = poly_deg s + poly_deg h0\n  k \\<le> poly_deg h0\n\ngoal (1 subgoal):\n 1. k + poly_deg s \\<le> poly_deg h", "by simp"], ["proof (state)\nthis:\n  k + poly_deg s \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"k + poly_deg s \\<le> d\" and \"d \\<le> poly_deg h\""], ["proof (state)\nthis:\n  k + poly_deg s \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "hence \"k \\<le> d - poly_deg s\" and \"d - poly_deg s \\<le> poly_deg h0\""], ["proof (prove)\nusing this:\n  k + poly_deg s \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. k \\<le> d - poly_deg s &&& d - poly_deg s \\<le> poly_deg h0", "by (simp_all add: deg_h)"], ["proof (state)\nthis:\n  k \\<le> d - poly_deg s\n  d - poly_deg s \\<le> poly_deg h0\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with assms(1) 1"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h0, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d - poly_deg s\n  d - poly_deg s \\<le> poly_deg h0", "obtain h' U' where 2: \"(h', U') \\<in> set ps\" and \"poly_deg h' = d - poly_deg s\"\n    and \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h0, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d - poly_deg s\n  d - poly_deg s \\<le> poly_deg h0\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d - poly_deg s;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  poly_deg h' = d - poly_deg s\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from assms(2) this(1)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h', U') \\<in> set ps", "have \"h' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h', U') \\<in> set ps\n\ngoal (1 subgoal):\n 1. h' \\<noteq> 0", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  h' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with assms(3)"], ["proof (chain)\npicking this:\n  s \\<noteq> 0\n  h' \\<noteq> 0", "have deg_h': \"poly_deg (s * h') = poly_deg s + poly_deg h'\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  h' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg (s * h') = poly_deg s + poly_deg h'", "by (rule poly_deg_times)"], ["proof (state)\nthis:\n  poly_deg (s * h') = poly_deg s + poly_deg h'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from 2"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps", "have \"(s * h', U') \\<in> set (map (apfst ((*) s)) ps)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n\ngoal (1 subgoal):\n 1. (s * h', U') \\<in> set (map (apfst ((*) s)) ps)", "by force"], ["proof (state)\nthis:\n  (s * h', U') \\<in> set (map (apfst ((*) s)) ps)\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  (s * h', U') \\<in> set (map (apfst ((*) s)) ps)\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from \\<open>k + poly_deg s \\<le> d\\<close> \\<open>poly_deg h' = d - poly_deg s\\<close>"], ["proof (chain)\npicking this:\n  k + poly_deg s \\<le> d\n  poly_deg h' = d - poly_deg s", "have \"poly_deg (s * h') = d\""], ["proof (prove)\nusing this:\n  k + poly_deg s \\<le> d\n  poly_deg h' = d - poly_deg s\n\ngoal (1 subgoal):\n 1. poly_deg (s * h') = d", "by (simp add: deg_h')"], ["proof (state)\nthis:\n  poly_deg (s * h') = d\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((map (apfst ((*) s)) ps)\\<^sub>+);\n        k + poly_deg s \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (map (apfst ((*) s)) ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  (s * h', U') \\<in> set (map (apfst ((*) s)) ps)\n  poly_deg (s * h') = d", "show \"\\<exists>h' U'. (h', U') \\<in> set (map (apfst ((*) s)) ps) \\<and> poly_deg h' = d \\<and> card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  (s * h', U') \\<in> set (map (apfst ((*) s)) ps)\n  poly_deg (s * h') = d\n\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set (map (apfst ((*) s)) ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "using \\<open>card U \\<le> card U'\\<close>"], ["proof (prove)\nusing this:\n  (s * h', U') \\<in> set (map (apfst ((*) s)) ps)\n  poly_deg (s * h') = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set (map (apfst ((*) s)) ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>h' U'.\n     (h', U') \\<in> set (map (apfst ((*) s)) ps) \\<and>\n     poly_deg h' = d \\<and> card U \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_decomp_nonempty_unique:\n  assumes \"finite X\" and \"valid_decomp X ps\" and \"standard_decomp k ps\" and \"ps\\<^sub>+ \\<noteq> []\"\n  shows \"k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "let ?A = \"poly_deg ` fst ` set (ps\\<^sub>+)\""], ["proof (state)\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "define m where \"m = Min ?A\""], ["proof (state)\nthis:\n  m = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "have \"finite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set (ps\\<^sub>+))", "by simp"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "moreover"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "from assms(4)"], ["proof (chain)\npicking this:\n  ps\\<^sub>+ \\<noteq> []", "have \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "ultimately"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}", "have \"m \\<in> ?A\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. m \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "unfolding m_def"], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (poly_deg ` fst ` set (ps\\<^sub>+))\n    \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "by (rule Min_in)"], ["proof (state)\nthis:\n  m \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "then"], ["proof (chain)\npicking this:\n  m \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "obtain h U where \"(h, U) \\<in> set (ps\\<^sub>+)\" and m: \"m = poly_deg h\""], ["proof (prove)\nusing this:\n  m \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); m = poly_deg h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  m = poly_deg h\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "have m_min: \"m \\<le> poly_deg h'\" if \"(h', U') \\<in> set (ps\\<^sub>+)\" for h' U'"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> poly_deg h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> poly_deg h'", "from that"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set (ps\\<^sub>+)", "have \"poly_deg (fst (h', U')) \\<in> ?A\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg (fst (h', U')) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "by (intro imageI)"], ["proof (state)\nthis:\n  poly_deg (fst (h', U')) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. m \\<le> poly_deg h'", "with \\<open>finite ?A\\<close>"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg (fst (h', U')) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "have \"m \\<le> poly_deg (fst (h', U'))\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg (fst (h', U')) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. m \\<le> poly_deg (fst (h', U'))", "unfolding m_def"], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg (fst (h', U')) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. Min (poly_deg ` fst ` set (ps\\<^sub>+)) \\<le> poly_deg (fst (h', U'))", "by (rule Min_le)"], ["proof (state)\nthis:\n  m \\<le> poly_deg (fst (h', U'))\n\ngoal (1 subgoal):\n 1. m \\<le> poly_deg h'", "thus ?thesis"], ["proof (prove)\nusing this:\n  m \\<le> poly_deg (fst (h', U'))\n\ngoal (1 subgoal):\n 1. m \\<le> poly_deg h'", "by simp"], ["proof (state)\nthis:\n  m \\<le> poly_deg h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?h'13, ?U'13) \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n  m \\<le> poly_deg ?h'13\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "proof (rule linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "assume \"k < m\""], ["proof (state)\nthis:\n  k < m\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "hence \"k \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  k < m\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "by (simp add: m)"], ["proof (state)\nthis:\n  k \\<le> poly_deg h\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "with assms(3) \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close> le_refl"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  ?n \\<le> ?n\n  k \\<le> poly_deg h", "obtain h' U'\n      where \"(h', U') \\<in> set ps\" and \"poly_deg h' = k\" and \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  ?n \\<le> ?n\n  k \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = k;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  poly_deg h' = k\n  card U \\<le> card U'\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "from this(2) \\<open>k < m\\<close>"], ["proof (chain)\npicking this:\n  poly_deg h' = k\n  k < m", "have \"\\<not> m \\<le> poly_deg h'\""], ["proof (prove)\nusing this:\n  poly_deg h' = k\n  k < m\n\ngoal (1 subgoal):\n 1. \\<not> m \\<le> poly_deg h'", "by simp"], ["proof (state)\nthis:\n  \\<not> m \\<le> poly_deg h'\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "with m_min"], ["proof (chain)\npicking this:\n  (?h'13, ?U'13) \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n  m \\<le> poly_deg ?h'13\n  \\<not> m \\<le> poly_deg h'", "have \"(h', U') \\<notin> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (?h'13, ?U'13) \\<in> set (ps\\<^sub>+) \\<Longrightarrow>\n  m \\<le> poly_deg ?h'13\n  \\<not> m \\<le> poly_deg h'\n\ngoal (1 subgoal):\n 1. (h', U') \\<notin> set (ps\\<^sub>+)", "by blast"], ["proof (state)\nthis:\n  (h', U') \\<notin> set (ps\\<^sub>+)\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "with \\<open>(h', U') \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps\n  (h', U') \\<notin> set (ps\\<^sub>+)", "have \"U' = {}\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n  (h', U') \\<notin> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. U' = {}", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  U' = {}\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "with \\<open>card U \\<le> card U'\\<close>"], ["proof (chain)\npicking this:\n  card U \\<le> card U'\n  U' = {}", "have \"U = {} \\<or> infinite U\""], ["proof (prove)\nusing this:\n  card U \\<le> card U'\n  U' = {}\n\ngoal (1 subgoal):\n 1. U = {} \\<or> infinite U", "by (simp add: card_eq_0_iff)"], ["proof (state)\nthis:\n  U = {} \\<or> infinite U\n\ngoal (3 subgoals):\n 1. ?x < ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. ?x = ?y \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 3. ?y < ?x \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "thus ?thesis"], ["proof (prove)\nusing this:\n  U = {} \\<or> infinite U\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. U = {} \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. infinite U \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "assume \"U = {}\""], ["proof (state)\nthis:\n  U = {}\n\ngoal (2 subgoals):\n 1. U = {} \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. infinite U \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "with \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  U = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  U = {}\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. infinite U \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite U \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "assume \"infinite U\""], ["proof (state)\nthis:\n  infinite U\n\ngoal (1 subgoal):\n 1. infinite U \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "moreover"], ["proof (state)\nthis:\n  infinite U\n\ngoal (1 subgoal):\n 1. infinite U \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "from assms(1, 2)"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps", "have \"finite U\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps\n\ngoal (1 subgoal):\n 1. finite U", "proof (rule valid_decompD_finite)"], ["proof (state)\ngoal (1 subgoal):\n 1. (?h, U) \\<in> set ps", "from \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "show \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. infinite U \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "ultimately"], ["proof (chain)\npicking this:\n  infinite U\n  finite U", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite U\n  finite U\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", ".."], ["proof (state)\nthis:\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (2 subgoals):\n 1. k = m \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. m < k \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. k = m \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. m < k \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "assume \"m < k\""], ["proof (state)\nthis:\n  m < k\n\ngoal (2 subgoals):\n 1. k = m \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. m < k \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "hence \"\\<not> k \\<le> m\""], ["proof (prove)\nusing this:\n  m < k\n\ngoal (1 subgoal):\n 1. \\<not> k \\<le> m", "by simp"], ["proof (state)\nthis:\n  \\<not> k \\<le> m\n\ngoal (2 subgoals):\n 1. k = m \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. m < k \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "moreover"], ["proof (state)\nthis:\n  \\<not> k \\<le> m\n\ngoal (2 subgoals):\n 1. k = m \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. m < k \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "from assms(3) \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"k \\<le> m\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> m", "unfolding m"], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  k \\<le> m\n\ngoal (2 subgoals):\n 1. k = m \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. m < k \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> k \\<le> m\n  k \\<le> m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> k \\<le> m\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", ".."], ["proof (state)\nthis:\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. k = m \\<Longrightarrow> k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "qed (simp only: m_def)"], ["proof (state)\nthis:\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_decomp_SucE:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"h \\<in> P[X]\" and \"h \\<noteq> (0::_ \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors})\"\n  obtains ps where \"valid_decomp X ps\" and \"cone_decomp (cone (h, U)) ps\"\n    and \"standard_decomp (Suc (poly_deg h)) ps\"\n    and \"is_monomial h \\<Longrightarrow> punit.lc h = 1 \\<Longrightarrow> monomial_decomp ps\" and \"homogeneous h \\<Longrightarrow> hom_decomp ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, U)) ps;\n         standard_decomp (Suc (poly_deg h)) ps;\n         \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n         \\<Longrightarrow> monomial_decomp ps;\n         homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, U)) ps;\n         standard_decomp (Suc (poly_deg h)) ps;\n         \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n         \\<Longrightarrow> monomial_decomp ps;\n         homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2, 1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite X", "have \"finite U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, U)) ps;\n         standard_decomp (Suc (poly_deg h)) ps;\n         \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n         \\<Longrightarrow> monomial_decomp ps;\n         homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite U\n\ngoal (1 subgoal):\n 1. thesis", "using assms(2) that"], ["proof (prove)\nusing this:\n  finite U\n  U \\<subseteq> X\n  \\<lbrakk>valid_decomp X ?ps13; cone_decomp (cone (h, U)) ?ps13;\n   standard_decomp (Suc (poly_deg h)) ?ps13;\n   \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n   \\<Longrightarrow> monomial_decomp ?ps13;\n   homogeneous h \\<Longrightarrow> hom_decomp ?ps13\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof (induct U arbitrary: thesis rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>{} \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, {})) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> X\n  \\<lbrakk>valid_decomp X ?ps13; cone_decomp (cone (h, {})) ?ps13;\n   standard_decomp (Suc (poly_deg h)) ?ps13;\n   \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n   \\<Longrightarrow> monomial_decomp ?ps13;\n   homogeneous h \\<Longrightarrow> hom_decomp ?ps13\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>{} \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, {})) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from assms(3, 4)"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  h \\<noteq> 0", "have \"valid_decomp X [(h, {})]\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. valid_decomp X [(h, {})]", "by (simp add: valid_decomp_def)"], ["proof (state)\nthis:\n  valid_decomp X [(h, {})]\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>{} \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, {})) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  valid_decomp X [(h, {})]\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>{} \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, {})) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "note cone_decomp_singleton"], ["proof (state)\nthis:\n  cone_decomp (cone (?t, ?U)) [(?t, ?U)]\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>{} \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, {})) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  cone_decomp (cone (?t, ?U)) [(?t, ?U)]\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>{} \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, {})) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"standard_decomp (Suc (poly_deg h)) [(h, {})]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (Suc (poly_deg h)) [(h, {})]", "by (rule standard_decomp_Nil) (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  standard_decomp (Suc (poly_deg h)) [(h, {})]\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>{} \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, {})) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  valid_decomp X [(h, {})]\n  cone_decomp (cone (?t, ?U)) [(?t, ?U)]\n  standard_decomp (Suc (poly_deg h)) [(h, {})]", "show ?case"], ["proof (prove)\nusing this:\n  valid_decomp X [(h, {})]\n  cone_decomp (cone (?t, ?U)) [(?t, ?U)]\n  standard_decomp (Suc (poly_deg h)) [(h, {})]\n\ngoal (1 subgoal):\n 1. thesis", "by (rule empty) (simp_all add: monomial_decomp_def hom_decomp_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (insert x U)"], ["proof (state)\nthis:\n  finite U\n  x \\<notin> U\n  \\<lbrakk>U \\<subseteq> X;\n   \\<And>ps.\n      \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, U)) ps;\n       standard_decomp (Suc (poly_deg h)) ps;\n       \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp ps;\n       homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n      \\<Longrightarrow> ?thesis13\\<rbrakk>\n  \\<Longrightarrow> ?thesis13\n  insert x U \\<subseteq> X\n  \\<lbrakk>valid_decomp X ?ps13; cone_decomp (cone (h, insert x U)) ?ps13;\n   standard_decomp (Suc (poly_deg h)) ?ps13;\n   \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n   \\<Longrightarrow> monomial_decomp ?ps13;\n   homogeneous h \\<Longrightarrow> hom_decomp ?ps13\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from insert.prems(1)"], ["proof (chain)\npicking this:\n  insert x U \\<subseteq> X", "have \"x \\<in> X\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  insert x U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X &&& U \\<subseteq> X", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> X\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from this(2)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "obtain ps where 0: \"valid_decomp X ps\" and 1: \"cone_decomp (cone (h, U)) ps\"\n      and 2: \"standard_decomp (Suc (poly_deg h)) ps\"\n      and 3: \"is_monomial h \\<Longrightarrow> punit.lc h = 1 \\<Longrightarrow> monomial_decomp ps\"\n      and 4: \"homogeneous h \\<Longrightarrow> hom_decomp ps\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<And>ps.\n        \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, U)) ps;\n         standard_decomp (Suc (poly_deg h)) ps;\n         \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n         \\<Longrightarrow> monomial_decomp ps;\n         homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule insert.hyps) blast"], ["proof (state)\nthis:\n  valid_decomp X ps\n  cone_decomp (cone (h, U)) ps\n  standard_decomp (Suc (poly_deg h)) ps\n  \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n  \\<Longrightarrow> monomial_decomp ps\n  homogeneous h \\<Longrightarrow> hom_decomp ps\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "let ?x = \"monomial (1::'a) (Poly_Mapping.single x (Suc 0))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"?x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial (Suc 0) x) \\<noteq> 0", "by (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial (Suc 0) x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "with assms(4)"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\n  monomial (1::'a) (monomial (Suc 0) x) \\<noteq> 0", "have deg: \"poly_deg (?x * h) = Suc (poly_deg h)\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  monomial (1::'a) (monomial (Suc 0) x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg (monomial (1::'a) (monomial (Suc 0) x) * h) = Suc (poly_deg h)", "by (simp add: poly_deg_times poly_deg_monomial deg_pm_single)"], ["proof (state)\nthis:\n  poly_deg (monomial (1::'a) (monomial (Suc 0) x) * h) = Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "define qs where \"qs = [(?x * h, insert x U)]\""], ["proof (state)\nthis:\n  qs = [(monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>F \\<subseteq> X;\n            \\<And>ps.\n               \\<lbrakk>valid_decomp X ps; cone_decomp (cone (h, F)) ps;\n                standard_decomp (Suc (poly_deg h)) ps;\n                \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp ps;\n                homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> X;\n        \\<And>ps.\n           \\<lbrakk>valid_decomp X ps;\n            cone_decomp (cone (h, insert x F)) ps;\n            standard_decomp (Suc (poly_deg h)) ps;\n            \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n            \\<Longrightarrow> monomial_decomp ps;\n            homogeneous h \\<Longrightarrow> hom_decomp ps\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule insert.prems)"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_decomp X ?ps13\n 2. cone_decomp (cone (h, insert x U)) ?ps13\n 3. standard_decomp (Suc (poly_deg h)) ?ps13\n 4. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp ?ps13\n 5. homogeneous h \\<Longrightarrow> hom_decomp ?ps13", "from \\<open>x \\<in> X\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> X", "have \"?x \\<in> P[X]\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial (Suc 0) x) \\<in> P[X]", "by (intro Polys_closed_monomial PPs_closed_single)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial (Suc 0) x) \\<in> P[X]\n\ngoal (5 subgoals):\n 1. valid_decomp X ?ps13\n 2. cone_decomp (cone (h, insert x U)) ?ps13\n 3. standard_decomp (Suc (poly_deg h)) ?ps13\n 4. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp ?ps13\n 5. homogeneous h \\<Longrightarrow> hom_decomp ?ps13", "hence \"?x * h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial (Suc 0) x) \\<in> P[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial (Suc 0) x) * h \\<in> P[X]", "using assms(3)"], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial (Suc 0) x) \\<in> P[X]\n  h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial (Suc 0) x) * h \\<in> P[X]", "by (rule Polys_closed_times)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<in> P[X]\n\ngoal (5 subgoals):\n 1. valid_decomp X ?ps13\n 2. cone_decomp (cone (h, insert x U)) ?ps13\n 3. standard_decomp (Suc (poly_deg h)) ?ps13\n 4. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp ?ps13\n 5. homogeneous h \\<Longrightarrow> hom_decomp ?ps13", "moreover"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<in> P[X]\n\ngoal (5 subgoals):\n 1. valid_decomp X ?ps13\n 2. cone_decomp (cone (h, insert x U)) ?ps13\n 3. standard_decomp (Suc (poly_deg h)) ?ps13\n 4. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp ?ps13\n 5. homogeneous h \\<Longrightarrow> hom_decomp ?ps13", "from \\<open>?x \\<noteq> 0\\<close> assms(4)"], ["proof (chain)\npicking this:\n  monomial (1::'a) (monomial (Suc 0) x) \\<noteq> 0\n  h \\<noteq> 0", "have \"?x * h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial (Suc 0) x) \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (monomial (Suc 0) x) * h \\<noteq> 0", "by (rule times_not_zero)"], ["proof (state)\nthis:\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<noteq> 0\n\ngoal (5 subgoals):\n 1. valid_decomp X ?ps13\n 2. cone_decomp (cone (h, insert x U)) ?ps13\n 3. standard_decomp (Suc (poly_deg h)) ?ps13\n 4. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp ?ps13\n 5. homogeneous h \\<Longrightarrow> hom_decomp ?ps13", "ultimately"], ["proof (chain)\npicking this:\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<in> P[X]\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<noteq> 0", "have \"valid_decomp X qs\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<in> P[X]\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. valid_decomp X qs", "using insert.hyps(1) \\<open>x \\<in> X\\<close> \\<open>U \\<subseteq> X\\<close>"], ["proof (prove)\nusing this:\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<in> P[X]\n  monomial (1::'a) (monomial (Suc 0) x) * h \\<noteq> 0\n  finite U\n  x \\<in> X\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. valid_decomp X qs", "by (simp add: qs_def valid_decomp_def)"], ["proof (state)\nthis:\n  valid_decomp X qs\n\ngoal (5 subgoals):\n 1. valid_decomp X ?ps13\n 2. cone_decomp (cone (h, insert x U)) ?ps13\n 3. standard_decomp (Suc (poly_deg h)) ?ps13\n 4. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp ?ps13\n 5. homogeneous h \\<Longrightarrow> hom_decomp ?ps13", "with 0"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  valid_decomp X qs", "show \"valid_decomp X (ps @ qs)\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (ps @ qs)", "by (rule valid_decomp_append)"], ["proof (state)\nthis:\n  valid_decomp X (ps @ qs)\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (h, insert x U)) (ps @ qs)\n 2. standard_decomp (Suc (poly_deg h)) (ps @ qs)\n 3. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 4. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. cone_decomp (cone (h, insert x U)) (ps @ qs)\n 2. standard_decomp (Suc (poly_deg h)) (ps @ qs)\n 3. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 4. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "show \"cone_decomp (cone (h, insert x U)) (ps @ qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp (cone (h, insert x U)) (ps @ qs)", "proof (rule cone_decomp_append)"], ["proof (state)\ngoal (3 subgoals):\n 1. direct_decomp (cone (h, insert x U)) [?S1.0, ?S2.0]\n 2. cone_decomp ?S1.0 ps\n 3. cone_decomp ?S2.0 qs", "show \"direct_decomp (cone (h, insert x U)) [cone (h, U), cone (?x * h, insert x U)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x U))\n     [cone (h, U),\n      cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]", "using insert.hyps(2)"], ["proof (prove)\nusing this:\n  x \\<notin> U\n\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x U))\n     [cone (h, U),\n      cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]", "by (rule direct_decomp_cone_insert)"], ["proof (state)\nthis:\n  direct_decomp (cone (h, insert x U))\n   [cone (h, U),\n    cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]\n\ngoal (2 subgoals):\n 1. cone_decomp (cone (h, U)) ps\n 2. cone_decomp\n     (cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)) qs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cone_decomp (cone (h, U)) ps\n 2. cone_decomp\n     (cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)) qs", "show \"cone_decomp (cone (?x * h, insert x U)) qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp\n     (cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)) qs", "by (simp add: qs_def cone_decomp_singleton)"], ["proof (state)\nthis:\n  cone_decomp (cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x U))\n   qs\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (h, U)) ps", "qed (fact 1)"], ["proof (state)\nthis:\n  cone_decomp (cone (h, insert x U)) (ps @ qs)\n\ngoal (3 subgoals):\n 1. standard_decomp (Suc (poly_deg h)) (ps @ qs)\n 2. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 3. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. standard_decomp (Suc (poly_deg h)) (ps @ qs)\n 2. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 3. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "from standard_decomp_singleton[of \"?x * h\" \"insert x U\"]"], ["proof (chain)\npicking this:\n  standard_decomp (poly_deg (monomial (1::'a) (monomial (Suc 0) x) * h))\n   [(monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]", "have \"standard_decomp (Suc (poly_deg h)) qs\""], ["proof (prove)\nusing this:\n  standard_decomp (poly_deg (monomial (1::'a) (monomial (Suc 0) x) * h))\n   [(monomial (1::'a) (monomial (Suc 0) x) * h, insert x U)]\n\ngoal (1 subgoal):\n 1. standard_decomp (Suc (poly_deg h)) qs", "by (simp add: deg qs_def)"], ["proof (state)\nthis:\n  standard_decomp (Suc (poly_deg h)) qs\n\ngoal (3 subgoals):\n 1. standard_decomp (Suc (poly_deg h)) (ps @ qs)\n 2. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 3. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "with 2"], ["proof (chain)\npicking this:\n  standard_decomp (Suc (poly_deg h)) ps\n  standard_decomp (Suc (poly_deg h)) qs", "show \"standard_decomp (Suc (poly_deg h)) (ps @ qs)\""], ["proof (prove)\nusing this:\n  standard_decomp (Suc (poly_deg h)) ps\n  standard_decomp (Suc (poly_deg h)) qs\n\ngoal (1 subgoal):\n 1. standard_decomp (Suc (poly_deg h)) (ps @ qs)", "by (rule standard_decomp_append)"], ["proof (state)\nthis:\n  standard_decomp (Suc (poly_deg h)) (ps @ qs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 2. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 2. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "assume \"is_monomial h\" and \"punit.lc h = 1\""], ["proof (state)\nthis:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 2. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "hence \"monomial_decomp ps\""], ["proof (prove)\nusing this:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. monomial_decomp ps", "by (rule 3)"], ["proof (state)\nthis:\n  monomial_decomp ps\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 2. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "moreover"], ["proof (state)\nthis:\n  monomial_decomp ps\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 2. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "have \"monomial_decomp qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp qs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial_decomp qs", "have \"is_monomial (?x * h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial (monomial (1::'a) (monomial (Suc 0) x) * h)", "by (metis \\<open>is_monomial h\\<close> is_monomial_monomial monomial_is_monomial mult.commute\n              mult.right_neutral mult_single)"], ["proof (state)\nthis:\n  is_monomial (monomial (1::'a) (monomial (Suc 0) x) * h)\n\ngoal (1 subgoal):\n 1. monomial_decomp qs", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_monomial (monomial (1::'a) (monomial (Suc 0) x) * h)\n\ngoal (1 subgoal):\n 1. monomial_decomp qs", "by (simp add: monomial_decomp_def qs_def lc_times \\<open>punit.lc h = 1\\<close>)"], ["proof (state)\nthis:\n  monomial_decomp qs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial_decomp qs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (ps @ qs)\n 2. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "ultimately"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  monomial_decomp qs", "show \"monomial_decomp (ps @ qs)\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (ps @ qs)", "by (simp only: monomial_decomp_append_iff)"], ["proof (state)\nthis:\n  monomial_decomp (ps @ qs)\n\ngoal (1 subgoal):\n 1. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "assume \"homogeneous h\""], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "hence \"hom_decomp ps\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. hom_decomp ps", "by (rule 4)"], ["proof (state)\nthis:\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "moreover"], ["proof (state)\nthis:\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "from \\<open>homogeneous h\\<close>"], ["proof (chain)\npicking this:\n  homogeneous h", "have \"hom_decomp qs\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. hom_decomp qs", "by (simp add: hom_decomp_def qs_def homogeneous_times)"], ["proof (state)\nthis:\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. homogeneous h \\<Longrightarrow> hom_decomp (ps @ qs)", "ultimately"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  hom_decomp qs", "show \"hom_decomp (ps @ qs)\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp (ps @ qs)", "by (simp only: hom_decomp_append_iff)"], ["proof (state)\nthis:\n  hom_decomp (ps @ qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_decomp_geE:\n  assumes \"finite X\" and \"valid_decomp X ps\"\n    and \"cone_decomp (T::(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) set) ps\"\n    and \"standard_decomp k ps\" and \"k \\<le> d\"\n  obtains qs where \"valid_decomp X qs\" and \"cone_decomp T qs\" and \"standard_decomp d qs\"\n    and \"monomial_decomp ps \\<Longrightarrow> monomial_decomp qs\" and \"hom_decomp ps \\<Longrightarrow> hom_decomp qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; cone_decomp T qs; standard_decomp d qs;\n         monomial_decomp ps \\<Longrightarrow> monomial_decomp qs;\n         hom_decomp ps \\<Longrightarrow> hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; cone_decomp T qs; standard_decomp d qs;\n         monomial_decomp ps \\<Longrightarrow> monomial_decomp qs;\n         hom_decomp ps \\<Longrightarrow> hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>qs. valid_decomp X qs \\<and> cone_decomp T qs \\<and> standard_decomp (k + i) qs \\<and>\n              (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and> (hom_decomp ps \\<longrightarrow> hom_decomp qs)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>qs.\n       valid_decomp X qs \\<and>\n       cone_decomp T qs \\<and>\n       standard_decomp (k + i) qs \\<and>\n       (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n       (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>qs.\n       valid_decomp X qs \\<and>\n       cone_decomp T qs \\<and>\n       standard_decomp (k + 0) qs \\<and>\n       (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n       (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n 2. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>qs.\n       valid_decomp X qs \\<and>\n       cone_decomp T qs \\<and>\n       standard_decomp (k + 0) qs \\<and>\n       (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n       (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n 2. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "from assms(2, 3, 4)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  cone_decomp T ps\n  standard_decomp k ps", "show ?case"], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  cone_decomp T ps\n  standard_decomp k ps\n\ngoal (1 subgoal):\n 1. \\<exists>qs.\n       valid_decomp X qs \\<and>\n       cone_decomp T qs \\<and>\n       standard_decomp (k + 0) qs \\<and>\n       (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n       (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "unfolding add_0_right"], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  cone_decomp T ps\n  standard_decomp k ps\n\ngoal (1 subgoal):\n 1. \\<exists>qs.\n       valid_decomp X qs \\<and>\n       cone_decomp T qs \\<and>\n       standard_decomp k qs \\<and>\n       (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n       (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + 0) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "case (Suc i)"], ["proof (state)\nthis:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + i) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + i) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "obtain qs where 0: \"valid_decomp X qs\" and 1: \"cone_decomp T qs\"\n      and 2: \"standard_decomp (k + i) qs\" and 3: \"monomial_decomp ps \\<Longrightarrow> monomial_decomp qs\"\n      and 4: \"hom_decomp ps \\<Longrightarrow> hom_decomp qs\""], ["proof (prove)\nusing this:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + i) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; cone_decomp T qs;\n         standard_decomp (k + i) qs;\n         monomial_decomp ps \\<Longrightarrow> monomial_decomp qs;\n         hom_decomp ps \\<Longrightarrow> hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_decomp X qs\n  cone_decomp T qs\n  standard_decomp (k + i) qs\n  monomial_decomp ps \\<Longrightarrow> monomial_decomp qs\n  hom_decomp ps \\<Longrightarrow> hom_decomp qs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "let ?P = \"\\<lambda>hU. poly_deg (fst hU) \\<noteq> k + i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "define rs where \"rs = filter (- ?P) qs\""], ["proof (state)\nthis:\n  rs = filter (- (\\<lambda>hU. poly_deg (fst hU) \\<noteq> k + i)) qs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "define ss where \"ss = filter ?P qs\""], ["proof (state)\nthis:\n  ss = filter (\\<lambda>hU. poly_deg (fst hU) \\<noteq> k + i) qs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "have \"set rs \\<subseteq> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set rs \\<subseteq> set qs", "by (auto simp: rs_def)"], ["proof (state)\nthis:\n  set rs \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "have \"set ss \\<subseteq> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ss \\<subseteq> set qs", "by (auto simp: ss_def)"], ["proof (state)\nthis:\n  set ss \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "define f where \"f = (\\<lambda>hU. SOME ps'. valid_decomp X ps' \\<and> cone_decomp (cone hU) ps' \\<and>\n                                        standard_decomp (Suc (poly_deg ((fst hU)::('x \\<Rightarrow>\\<^sub>0 _) \\<Rightarrow>\\<^sub>0 'a))) ps' \\<and>\n                                        (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n                                        (hom_decomp ps \\<longrightarrow> hom_decomp ps'))\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>hU.\n      SOME ps'.\n         valid_decomp X ps' \\<and>\n         cone_decomp (cone hU) ps' \\<and>\n         standard_decomp (Suc (poly_deg (fst hU))) ps' \\<and>\n         (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n         (hom_decomp ps \\<longrightarrow> hom_decomp ps'))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "have \"valid_decomp X (f hU) \\<and> cone_decomp (cone hU) (f hU) \\<and> standard_decomp (Suc (k + i)) (f hU) \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and> (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))\"\n      if \"hU \\<in> set rs\" for hU"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "with that"], ["proof (chain)\npicking this:\n  hU \\<in> set rs\n  hU = (h, U)", "have eq: \"poly_deg (fst hU) = k + i\""], ["proof (prove)\nusing this:\n  hU \\<in> set rs\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. poly_deg (fst hU) = k + i", "by (simp add: rs_def)"], ["proof (state)\nthis:\n  poly_deg (fst hU) = k + i\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "from that \\<open>set rs \\<subseteq> set qs\\<close>"], ["proof (chain)\npicking this:\n  hU \\<in> set rs\n  set rs \\<subseteq> set qs", "have \"(h, U) \\<in> set qs\""], ["proof (prove)\nusing this:\n  hU \\<in> set rs\n  set rs \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", "unfolding hU"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set rs\n  set rs \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", ".."], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "with 0"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs", "have \"U \\<subseteq> X\" and \"h \\<in> P[X]\" and \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X &&& h \\<in> P[X] &&& h \\<noteq> 0", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  h \\<in> P[X]\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "with assms(1)"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  h \\<in> P[X]\n  h \\<noteq> 0", "obtain ps' where \"valid_decomp X ps'\" and \"cone_decomp (cone (h, U)) ps'\"\n        and \"standard_decomp (Suc (poly_deg h)) ps'\"\n        and md: \"is_monomial h \\<Longrightarrow> punit.lc h = 1 \\<Longrightarrow> monomial_decomp ps'\"\n        and hd: \"homogeneous h \\<Longrightarrow> hom_decomp ps'\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  h \\<in> P[X]\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>ps'.\n        \\<lbrakk>valid_decomp X ps'; cone_decomp (cone (h, U)) ps';\n         standard_decomp (Suc (poly_deg h)) ps';\n         \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n         \\<Longrightarrow> monomial_decomp ps';\n         homogeneous h \\<Longrightarrow> hom_decomp ps'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decomp_SucE) blast"], ["proof (state)\nthis:\n  valid_decomp X ps'\n  cone_decomp (cone (h, U)) ps'\n  standard_decomp (Suc (poly_deg h)) ps'\n  \\<lbrakk>is_monomial h; lcf h = (1::'a)\\<rbrakk>\n  \\<Longrightarrow> monomial_decomp ps'\n  homogeneous h \\<Longrightarrow> hom_decomp ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "note this(1-3)"], ["proof (state)\nthis:\n  valid_decomp X ps'\n  cone_decomp (cone (h, U)) ps'\n  standard_decomp (Suc (poly_deg h)) ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "moreover"], ["proof (state)\nthis:\n  valid_decomp X ps'\n  cone_decomp (cone (h, U)) ps'\n  standard_decomp (Suc (poly_deg h)) ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "have \"monomial_decomp ps'\" if \"monomial_decomp ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp ps'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial_decomp ps'", "from that"], ["proof (chain)\npicking this:\n  monomial_decomp ps", "have \"monomial_decomp qs\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n\ngoal (1 subgoal):\n 1. monomial_decomp qs", "by (rule 3)"], ["proof (state)\nthis:\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp ps'", "hence \"is_monomial h\" and \"punit.lc h = 1\""], ["proof (prove)\nusing this:\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. is_monomial h &&& lcf h = (1::'a)", "using \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (prove)\nusing this:\n  monomial_decomp qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. is_monomial h &&& lcf h = (1::'a)", "by (rule monomial_decompD)+"], ["proof (state)\nthis:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. monomial_decomp ps'", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. monomial_decomp ps'", "by (rule md)"], ["proof (state)\nthis:\n  monomial_decomp ps'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial_decomp ps \\<Longrightarrow> monomial_decomp ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "moreover"], ["proof (state)\nthis:\n  monomial_decomp ps \\<Longrightarrow> monomial_decomp ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "have \"hom_decomp ps'\" if \"hom_decomp ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp ps'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_decomp ps'", "from that"], ["proof (chain)\npicking this:\n  hom_decomp ps", "have \"hom_decomp qs\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. hom_decomp qs", "by (rule 4)"], ["proof (state)\nthis:\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp ps'", "hence \"homogeneous h\""], ["proof (prove)\nusing this:\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. homogeneous h", "using \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (prove)\nusing this:\n  hom_decomp qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_decompD)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. hom_decomp ps'", "thus ?thesis"], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. hom_decomp ps'", "by (rule hd)"], ["proof (state)\nthis:\n  hom_decomp ps'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hom_decomp ps \\<Longrightarrow> hom_decomp ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "ultimately"], ["proof (chain)\npicking this:\n  valid_decomp X ps'\n  cone_decomp (cone (h, U)) ps'\n  standard_decomp (Suc (poly_deg h)) ps'\n  monomial_decomp ps \\<Longrightarrow> monomial_decomp ps'\n  hom_decomp ps \\<Longrightarrow> hom_decomp ps'", "have \"valid_decomp X ps' \\<and> cone_decomp (cone hU) ps' \\<and>\n          standard_decomp (Suc (poly_deg (fst hU))) ps' \\<and> (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp ps')\""], ["proof (prove)\nusing this:\n  valid_decomp X ps'\n  cone_decomp (cone (h, U)) ps'\n  standard_decomp (Suc (poly_deg h)) ps'\n  monomial_decomp ps \\<Longrightarrow> monomial_decomp ps'\n  hom_decomp ps \\<Longrightarrow> hom_decomp ps'\n\ngoal (1 subgoal):\n 1. valid_decomp X ps' \\<and>\n    cone_decomp (cone hU) ps' \\<and>\n    standard_decomp (Suc (poly_deg (fst hU))) ps' \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp ps')", "by (simp add: hU)"], ["proof (state)\nthis:\n  valid_decomp X ps' \\<and>\n  cone_decomp (cone hU) ps' \\<and>\n  standard_decomp (Suc (poly_deg (fst hU))) ps' \\<and>\n  (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n  (hom_decomp ps \\<longrightarrow> hom_decomp ps')\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X ps' \\<and>\n  cone_decomp (cone hU) ps' \\<and>\n  standard_decomp (Suc (poly_deg (fst hU))) ps' \\<and>\n  (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n  (hom_decomp ps \\<longrightarrow> hom_decomp ps')\n\ngoal (1 subgoal):\n 1. valid_decomp X (f hU) \\<and>\n    cone_decomp (cone hU) (f hU) \\<and>\n    standard_decomp (Suc (k + i)) (f hU) \\<and>\n    (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n    (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))", "unfolding f_def eq"], ["proof (prove)\nusing this:\n  valid_decomp X ps' \\<and>\n  cone_decomp (cone hU) ps' \\<and>\n  standard_decomp (Suc (k + i)) ps' \\<and>\n  (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n  (hom_decomp ps \\<longrightarrow> hom_decomp ps')\n\ngoal (1 subgoal):\n 1. valid_decomp X\n     (SOME ps'.\n         valid_decomp X ps' \\<and>\n         cone_decomp (cone hU) ps' \\<and>\n         standard_decomp (Suc (k + i)) ps' \\<and>\n         (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n         (hom_decomp ps \\<longrightarrow> hom_decomp ps')) \\<and>\n    cone_decomp (cone hU)\n     (SOME ps'.\n         valid_decomp X ps' \\<and>\n         cone_decomp (cone hU) ps' \\<and>\n         standard_decomp (Suc (k + i)) ps' \\<and>\n         (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n         (hom_decomp ps \\<longrightarrow> hom_decomp ps')) \\<and>\n    standard_decomp (Suc (k + i))\n     (SOME ps'.\n         valid_decomp X ps' \\<and>\n         cone_decomp (cone hU) ps' \\<and>\n         standard_decomp (Suc (k + i)) ps' \\<and>\n         (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n         (hom_decomp ps \\<longrightarrow> hom_decomp ps')) \\<and>\n    (monomial_decomp ps \\<longrightarrow>\n     monomial_decomp\n      (SOME ps'.\n          valid_decomp X ps' \\<and>\n          cone_decomp (cone hU) ps' \\<and>\n          standard_decomp (Suc (k + i)) ps' \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp ps'))) \\<and>\n    (hom_decomp ps \\<longrightarrow>\n     hom_decomp\n      (SOME ps'.\n          valid_decomp X ps' \\<and>\n          cone_decomp (cone hU) ps' \\<and>\n          standard_decomp (Suc (k + i)) ps' \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp ps') \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp ps')))", "by (rule someI)"], ["proof (state)\nthis:\n  valid_decomp X (f hU) \\<and>\n  cone_decomp (cone hU) (f hU) \\<and>\n  standard_decomp (Suc (k + i)) (f hU) \\<and>\n  (monomial_decomp ps \\<longrightarrow> monomial_decomp (f hU)) \\<and>\n  (hom_decomp ps \\<longrightarrow> hom_decomp (f hU))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?hU14 \\<in> set rs \\<Longrightarrow>\n  valid_decomp X (f ?hU14) \\<and>\n  cone_decomp (cone ?hU14) (f ?hU14) \\<and>\n  standard_decomp (Suc (k + i)) (f ?hU14) \\<and>\n  (monomial_decomp ps \\<longrightarrow> monomial_decomp (f ?hU14)) \\<and>\n  (hom_decomp ps \\<longrightarrow> hom_decomp (f ?hU14))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "hence f1: \"\\<And>ps. ps \\<in> set (map f rs) \\<Longrightarrow> valid_decomp X ps\"\n      and f2: \"\\<And>hU. hU \\<in> set rs \\<Longrightarrow> cone_decomp (cone hU) (f hU)\"\n      and f3: \"\\<And>ps. ps \\<in> set (map f rs) \\<Longrightarrow> standard_decomp (Suc (k + i)) ps\"\n      and f4: \"\\<And>ps'. monomial_decomp ps \\<Longrightarrow> ps' \\<in> set (map f rs) \\<Longrightarrow> monomial_decomp ps'\"\n      and f5: \"\\<And>ps'. hom_decomp ps \\<Longrightarrow> ps' \\<in> set (map f rs) \\<Longrightarrow> hom_decomp ps'\""], ["proof (prove)\nusing this:\n  ?hU14 \\<in> set rs \\<Longrightarrow>\n  valid_decomp X (f ?hU14) \\<and>\n  cone_decomp (cone ?hU14) (f ?hU14) \\<and>\n  standard_decomp (Suc (k + i)) (f ?hU14) \\<and>\n  (monomial_decomp ps \\<longrightarrow> monomial_decomp (f ?hU14)) \\<and>\n  (hom_decomp ps \\<longrightarrow> hom_decomp (f ?hU14))\n\ngoal (1 subgoal):\n 1. ((\\<And>ps.\n         ps \\<in> set (map f rs) \\<Longrightarrow> valid_decomp X ps) &&&\n     (\\<And>hU.\n         hU \\<in> set rs \\<Longrightarrow>\n         cone_decomp (cone hU) (f hU))) &&&\n    (\\<And>ps.\n        ps \\<in> set (map f rs) \\<Longrightarrow>\n        standard_decomp (Suc (k + i)) ps) &&&\n    (\\<And>ps'.\n        \\<lbrakk>monomial_decomp ps; ps' \\<in> set (map f rs)\\<rbrakk>\n        \\<Longrightarrow> monomial_decomp ps') &&&\n    (\\<And>ps'.\n        \\<lbrakk>hom_decomp ps; ps' \\<in> set (map f rs)\\<rbrakk>\n        \\<Longrightarrow> hom_decomp ps')", "by auto"], ["proof (state)\nthis:\n  ?ps14 \\<in> set (map f rs) \\<Longrightarrow> valid_decomp X ?ps14\n  ?hU14 \\<in> set rs \\<Longrightarrow> cone_decomp (cone ?hU14) (f ?hU14)\n  ?ps14 \\<in> set (map f rs) \\<Longrightarrow>\n  standard_decomp (Suc (k + i)) ?ps14\n  \\<lbrakk>monomial_decomp ps; ?ps'14 \\<in> set (map f rs)\\<rbrakk>\n  \\<Longrightarrow> monomial_decomp ?ps'14\n  \\<lbrakk>hom_decomp ps; ?ps'14 \\<in> set (map f rs)\\<rbrakk>\n  \\<Longrightarrow> hom_decomp ?ps'14\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "define rs' where \"rs' = concat (map f rs)\""], ["proof (state)\nthis:\n  rs' = concat (map f rs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs) \\<Longrightarrow>\n       \\<exists>qs.\n          valid_decomp X qs \\<and>\n          cone_decomp T qs \\<and>\n          standard_decomp (k + Suc i) qs \\<and>\n          (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n          (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>qs.\n       valid_decomp X qs \\<and>\n       cone_decomp T qs \\<and>\n       standard_decomp (k + Suc i) qs \\<and>\n       (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n       (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "unfolding add_Suc_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>qs.\n       valid_decomp X qs \\<and>\n       cone_decomp T qs \\<and>\n       standard_decomp (Suc (k + i)) qs \\<and>\n       (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n       (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "proof (intro exI conjI impI)"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_decomp X ?qs\n 2. cone_decomp T ?qs\n 3. standard_decomp (Suc (k + i)) ?qs\n 4. monomial_decomp ps \\<Longrightarrow> monomial_decomp ?qs\n 5. hom_decomp ps \\<Longrightarrow> hom_decomp ?qs", "have \"valid_decomp X ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X ss", "proof (rule valid_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> U \\<subseteq> X", "fix h U"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> U \\<subseteq> X", "assume \"(h, U) \\<in> set ss\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ss\n\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> U \\<subseteq> X", "hence \"(h, U) \\<in> set qs\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ss\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", "using \\<open>set ss \\<subseteq> set qs\\<close>"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ss\n  set ss \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", ".."], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U. (h, U) \\<in> set ss \\<Longrightarrow> U \\<subseteq> X", "with 0"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs", "show \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_decomp X ss\n\ngoal (5 subgoals):\n 1. valid_decomp X ?qs\n 2. cone_decomp T ?qs\n 3. standard_decomp (Suc (k + i)) ?qs\n 4. monomial_decomp ps \\<Longrightarrow> monomial_decomp ?qs\n 5. hom_decomp ps \\<Longrightarrow> hom_decomp ?qs", "moreover"], ["proof (state)\nthis:\n  valid_decomp X ss\n\ngoal (5 subgoals):\n 1. valid_decomp X ?qs\n 2. cone_decomp T ?qs\n 3. standard_decomp (Suc (k + i)) ?qs\n 4. monomial_decomp ps \\<Longrightarrow> monomial_decomp ?qs\n 5. hom_decomp ps \\<Longrightarrow> hom_decomp ?qs", "have \"valid_decomp X rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X rs'", "unfolding rs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (concat (map f rs))", "using f1"], ["proof (prove)\nusing this:\n  ?ps14 \\<in> set (map f rs) \\<Longrightarrow> valid_decomp X ?ps14\n\ngoal (1 subgoal):\n 1. valid_decomp X (concat (map f rs))", "by (rule valid_decomp_concat)"], ["proof (state)\nthis:\n  valid_decomp X rs'\n\ngoal (5 subgoals):\n 1. valid_decomp X ?qs\n 2. cone_decomp T ?qs\n 3. standard_decomp (Suc (k + i)) ?qs\n 4. monomial_decomp ps \\<Longrightarrow> monomial_decomp ?qs\n 5. hom_decomp ps \\<Longrightarrow> hom_decomp ?qs", "ultimately"], ["proof (chain)\npicking this:\n  valid_decomp X ss\n  valid_decomp X rs'", "show \"valid_decomp X (ss @ rs')\""], ["proof (prove)\nusing this:\n  valid_decomp X ss\n  valid_decomp X rs'\n\ngoal (1 subgoal):\n 1. valid_decomp X (ss @ rs')", "by (rule valid_decomp_append)"], ["proof (state)\nthis:\n  valid_decomp X (ss @ rs')\n\ngoal (4 subgoals):\n 1. cone_decomp T (ss @ rs')\n 2. standard_decomp (Suc (k + i)) (ss @ rs')\n 3. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 4. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. cone_decomp T (ss @ rs')\n 2. standard_decomp (Suc (k + i)) (ss @ rs')\n 3. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 4. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "from 1"], ["proof (chain)\npicking this:\n  cone_decomp T qs", "have \"direct_decomp T (map cone qs)\""], ["proof (prove)\nusing this:\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone qs)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone qs)\n\ngoal (4 subgoals):\n 1. cone_decomp T (ss @ rs')\n 2. standard_decomp (Suc (k + i)) (ss @ rs')\n 3. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 4. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "hence \"direct_decomp T ((map cone ss) @ (map cone rs))\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ss @ map cone rs)", "unfolding ss_def rs_def"], ["proof (prove)\nusing this:\n  direct_decomp T (map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T\n     (map cone (filter (\\<lambda>hU. poly_deg (fst hU) \\<noteq> k + i) qs) @\n      map cone\n       (filter (- (\\<lambda>hU. poly_deg (fst hU) \\<noteq> k + i)) qs))", "by (rule direct_decomp_split_map)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ss @ map cone rs)\n\ngoal (4 subgoals):\n 1. cone_decomp T (ss @ rs')\n 2. standard_decomp (Suc (k + i)) (ss @ rs')\n 3. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 4. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "hence ss: \"cone_decomp (sum_list ` listset (map cone ss)) ss\"\n        and \"cone_decomp (sum_list ` listset (map cone rs)) rs\"\n        and T: \"direct_decomp T [sum_list ` listset (map cone ss), sum_list ` listset (map cone rs)]\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ss @ map cone rs)\n\ngoal (1 subgoal):\n 1. cone_decomp (sum_list ` listset (map cone ss)) ss &&&\n    cone_decomp (sum_list ` listset (map cone rs)) rs &&&\n    direct_decomp T\n     [sum_list ` listset (map cone ss), sum_list ` listset (map cone rs)]", "by (auto simp: cone_decomp_def dest: direct_decomp_appendD intro!: empty_not_in_map_cone)"], ["proof (state)\nthis:\n  cone_decomp (sum_list ` listset (map cone ss)) ss\n  cone_decomp (sum_list ` listset (map cone rs)) rs\n  direct_decomp T\n   [sum_list ` listset (map cone ss), sum_list ` listset (map cone rs)]\n\ngoal (4 subgoals):\n 1. cone_decomp T (ss @ rs')\n 2. standard_decomp (Suc (k + i)) (ss @ rs')\n 3. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 4. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "from this(2)"], ["proof (chain)\npicking this:\n  cone_decomp (sum_list ` listset (map cone rs)) rs", "have \"direct_decomp (sum_list ` listset (map cone rs)) (map cone rs)\""], ["proof (prove)\nusing this:\n  cone_decomp (sum_list ` listset (map cone rs)) rs\n\ngoal (1 subgoal):\n 1. direct_decomp (sum_list ` listset (map cone rs)) (map cone rs)", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp (sum_list ` listset (map cone rs)) (map cone rs)\n\ngoal (4 subgoals):\n 1. cone_decomp T (ss @ rs')\n 2. standard_decomp (Suc (k + i)) (ss @ rs')\n 3. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 4. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "hence \"cone_decomp (sum_list ` listset (map cone rs)) rs'\""], ["proof (prove)\nusing this:\n  direct_decomp (sum_list ` listset (map cone rs)) (map cone rs)\n\ngoal (1 subgoal):\n 1. cone_decomp (sum_list ` listset (map cone rs)) rs'", "unfolding rs'_def"], ["proof (prove)\nusing this:\n  direct_decomp (sum_list ` listset (map cone rs)) (map cone rs)\n\ngoal (1 subgoal):\n 1. cone_decomp (sum_list ` listset (map cone rs)) (concat (map f rs))", "proof (rule cone_decomp_concat)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map f rs) = length (map cone rs)\n 2. \\<And>i.\n       i < length (map cone rs) \\<Longrightarrow>\n       cone_decomp (map cone rs ! i) (map f rs ! i)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map f rs) = length (map cone rs)\n 2. \\<And>i.\n       i < length (map cone rs) \\<Longrightarrow>\n       cone_decomp (map cone rs ! i) (map f rs ! i)", "assume *: \"i < length (map cone rs)\""], ["proof (state)\nthis:\n  i < length (map cone rs)\n\ngoal (2 subgoals):\n 1. length (map f rs) = length (map cone rs)\n 2. \\<And>i.\n       i < length (map cone rs) \\<Longrightarrow>\n       cone_decomp (map cone rs ! i) (map f rs ! i)", "hence \"rs ! i \\<in> set rs\""], ["proof (prove)\nusing this:\n  i < length (map cone rs)\n\ngoal (1 subgoal):\n 1. rs ! i \\<in> set rs", "by simp"], ["proof (state)\nthis:\n  rs ! i \\<in> set rs\n\ngoal (2 subgoals):\n 1. length (map f rs) = length (map cone rs)\n 2. \\<And>i.\n       i < length (map cone rs) \\<Longrightarrow>\n       cone_decomp (map cone rs ! i) (map f rs ! i)", "hence \"cone_decomp (cone (rs ! i)) (f (rs ! i))\""], ["proof (prove)\nusing this:\n  rs ! i \\<in> set rs\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (rs ! i)) (f (rs ! i))", "by (rule f2)"], ["proof (state)\nthis:\n  cone_decomp (cone (rs ! i)) (f (rs ! i))\n\ngoal (2 subgoals):\n 1. length (map f rs) = length (map cone rs)\n 2. \\<And>i.\n       i < length (map cone rs) \\<Longrightarrow>\n       cone_decomp (map cone rs ! i) (map f rs ! i)", "with *"], ["proof (chain)\npicking this:\n  i < length (map cone rs)\n  cone_decomp (cone (rs ! i)) (f (rs ! i))", "show \"cone_decomp (map cone rs ! i) (map f rs ! i)\""], ["proof (prove)\nusing this:\n  i < length (map cone rs)\n  cone_decomp (cone (rs ! i)) (f (rs ! i))\n\ngoal (1 subgoal):\n 1. cone_decomp (map cone rs ! i) (map f rs ! i)", "by simp"], ["proof (state)\nthis:\n  cone_decomp (map cone rs ! i) (map f rs ! i)\n\ngoal (1 subgoal):\n 1. length (map f rs) = length (map cone rs)", "qed simp"], ["proof (state)\nthis:\n  cone_decomp (sum_list ` listset (map cone rs)) rs'\n\ngoal (4 subgoals):\n 1. cone_decomp T (ss @ rs')\n 2. standard_decomp (Suc (k + i)) (ss @ rs')\n 3. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 4. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "with T ss"], ["proof (chain)\npicking this:\n  direct_decomp T\n   [sum_list ` listset (map cone ss), sum_list ` listset (map cone rs)]\n  cone_decomp (sum_list ` listset (map cone ss)) ss\n  cone_decomp (sum_list ` listset (map cone rs)) rs'", "show \"cone_decomp T (ss @ rs')\""], ["proof (prove)\nusing this:\n  direct_decomp T\n   [sum_list ` listset (map cone ss), sum_list ` listset (map cone rs)]\n  cone_decomp (sum_list ` listset (map cone ss)) ss\n  cone_decomp (sum_list ` listset (map cone rs)) rs'\n\ngoal (1 subgoal):\n 1. cone_decomp T (ss @ rs')", "by (rule cone_decomp_append)"], ["proof (state)\nthis:\n  cone_decomp T (ss @ rs')\n\ngoal (3 subgoals):\n 1. standard_decomp (Suc (k + i)) (ss @ rs')\n 2. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 3. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. standard_decomp (Suc (k + i)) (ss @ rs')\n 2. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 3. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "have \"standard_decomp (Suc (k + i)) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (Suc (k + i)) ss", "proof (rule standard_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ss\\<^sub>+) \\<Longrightarrow>\n       Suc (k + i) \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ss\\<^sub>+) \\<Longrightarrow>\n       Suc (k + i) \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"(h, U) \\<in> set (ss\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (ss\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ss\\<^sub>+) \\<Longrightarrow>\n       Suc (k + i) \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "hence \"(h, U) \\<in> set (qs\\<^sub>+)\" and \"poly_deg h \\<noteq> k + i\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ss\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (qs\\<^sub>+) &&& poly_deg h \\<noteq> k + i", "by (simp_all add: pos_decomp_def ss_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (qs\\<^sub>+)\n  poly_deg h \\<noteq> k + i\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ss\\<^sub>+) \\<Longrightarrow>\n       Suc (k + i) \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from 2 this(1)"], ["proof (chain)\npicking this:\n  standard_decomp (k + i) qs\n  (h, U) \\<in> set (qs\\<^sub>+)", "have \"k + i \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  standard_decomp (k + i) qs\n  (h, U) \\<in> set (qs\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k + i \\<le> poly_deg h", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  k + i \\<le> poly_deg h\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ss\\<^sub>+) \\<Longrightarrow>\n       Suc (k + i) \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with \\<open>poly_deg h \\<noteq> k + i\\<close>"], ["proof (chain)\npicking this:\n  poly_deg h \\<noteq> k + i\n  k + i \\<le> poly_deg h", "show \"Suc (k + i) \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  poly_deg h \\<noteq> k + i\n  k + i \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. Suc (k + i) \\<le> poly_deg h", "by simp"], ["proof (state)\nthis:\n  Suc (k + i) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix d'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"Suc (k + i) \\<le> d'\" and \"d' \\<le> poly_deg h\""], ["proof (state)\nthis:\n  Suc (k + i) \\<le> d'\n  d' \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from this(1)"], ["proof (chain)\npicking this:\n  Suc (k + i) \\<le> d'", "have \"k + i \\<le> d'\" and \"d' \\<noteq> k + i\""], ["proof (prove)\nusing this:\n  Suc (k + i) \\<le> d'\n\ngoal (1 subgoal):\n 1. k + i \\<le> d' &&& d' \\<noteq> k + i", "by simp_all"], ["proof (state)\nthis:\n  k + i \\<le> d'\n  d' \\<noteq> k + i\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from 2 \\<open>(h, U) \\<in> set (qs\\<^sub>+)\\<close> this(1)"], ["proof (chain)\npicking this:\n  standard_decomp (k + i) qs\n  (h, U) \\<in> set (qs\\<^sub>+)\n  k + i \\<le> d'", "obtain h' U'\n          where \"(h', U') \\<in> set qs\" and \"poly_deg h' = d'\" and \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp (k + i) qs\n  (h, U) \\<in> set (qs\\<^sub>+)\n  k + i \\<le> d'\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set qs; poly_deg h' = d';\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>d' \\<le> poly_deg h\\<close>"], ["proof (prove)\nusing this:\n  standard_decomp (k + i) qs\n  (h, U) \\<in> set (qs\\<^sub>+)\n  k + i \\<le> d'\n  d' \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set qs; poly_deg h' = d';\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs\n  poly_deg h' = d'\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs\n  poly_deg h' = d'\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from \\<open>d' \\<noteq> k + i\\<close> this(1, 2)"], ["proof (chain)\npicking this:\n  d' \\<noteq> k + i\n  (h', U') \\<in> set qs\n  poly_deg h' = d'", "have \"(h', U') \\<in> set ss\""], ["proof (prove)\nusing this:\n  d' \\<noteq> k + i\n  (h', U') \\<in> set qs\n  poly_deg h' = d'\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set ss", "by (simp add: ss_def)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ss\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set (ss\\<^sub>+); Suc (k + i) \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set ss \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set qs\n  poly_deg h' = d'\n  card U \\<le> card U'\n  (h', U') \\<in> set ss", "show \"\\<exists>h' U'. (h', U') \\<in> set ss \\<and> poly_deg h' = d' \\<and> card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set qs\n  poly_deg h' = d'\n  card U \\<le> card U'\n  (h', U') \\<in> set ss\n\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set ss \\<and>\n       poly_deg h' = d' \\<and> card U \\<le> card U'", "by blast"], ["proof (state)\nthis:\n  \\<exists>h' U'.\n     (h', U') \\<in> set ss \\<and>\n     poly_deg h' = d' \\<and> card U \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  standard_decomp (Suc (k + i)) ss\n\ngoal (3 subgoals):\n 1. standard_decomp (Suc (k + i)) (ss @ rs')\n 2. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 3. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "moreover"], ["proof (state)\nthis:\n  standard_decomp (Suc (k + i)) ss\n\ngoal (3 subgoals):\n 1. standard_decomp (Suc (k + i)) (ss @ rs')\n 2. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 3. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "have \"standard_decomp (Suc (k + i)) rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (Suc (k + i)) rs'", "unfolding rs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (Suc (k + i)) (concat (map f rs))", "using f3"], ["proof (prove)\nusing this:\n  ?ps14 \\<in> set (map f rs) \\<Longrightarrow>\n  standard_decomp (Suc (k + i)) ?ps14\n\ngoal (1 subgoal):\n 1. standard_decomp (Suc (k + i)) (concat (map f rs))", "by (rule standard_decomp_concat)"], ["proof (state)\nthis:\n  standard_decomp (Suc (k + i)) rs'\n\ngoal (3 subgoals):\n 1. standard_decomp (Suc (k + i)) (ss @ rs')\n 2. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 3. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "ultimately"], ["proof (chain)\npicking this:\n  standard_decomp (Suc (k + i)) ss\n  standard_decomp (Suc (k + i)) rs'", "show \"standard_decomp (Suc (k + i)) (ss @ rs')\""], ["proof (prove)\nusing this:\n  standard_decomp (Suc (k + i)) ss\n  standard_decomp (Suc (k + i)) rs'\n\ngoal (1 subgoal):\n 1. standard_decomp (Suc (k + i)) (ss @ rs')", "by (rule standard_decomp_append)"], ["proof (state)\nthis:\n  standard_decomp (Suc (k + i)) (ss @ rs')\n\ngoal (2 subgoals):\n 1. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 2. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 2. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "assume *: \"monomial_decomp ps\""], ["proof (state)\nthis:\n  monomial_decomp ps\n\ngoal (2 subgoals):\n 1. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 2. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "hence \"monomial_decomp qs\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n\ngoal (1 subgoal):\n 1. monomial_decomp qs", "by (rule 3)"], ["proof (state)\nthis:\n  monomial_decomp qs\n\ngoal (2 subgoals):\n 1. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 2. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "hence \"monomial_decomp ss\""], ["proof (prove)\nusing this:\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp ss", "by (simp add: monomial_decomp_def ss_def)"], ["proof (state)\nthis:\n  monomial_decomp ss\n\ngoal (2 subgoals):\n 1. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 2. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "moreover"], ["proof (state)\nthis:\n  monomial_decomp ss\n\ngoal (2 subgoals):\n 1. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 2. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "have \"monomial_decomp rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp rs'", "unfolding rs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (concat (map f rs))", "using f4[OF *]"], ["proof (prove)\nusing this:\n  ?ps'14 \\<in> set (map f rs) \\<Longrightarrow> monomial_decomp ?ps'14\n\ngoal (1 subgoal):\n 1. monomial_decomp (concat (map f rs))", "by (rule monomial_decomp_concat)"], ["proof (state)\nthis:\n  monomial_decomp rs'\n\ngoal (2 subgoals):\n 1. monomial_decomp ps \\<Longrightarrow> monomial_decomp (ss @ rs')\n 2. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "ultimately"], ["proof (chain)\npicking this:\n  monomial_decomp ss\n  monomial_decomp rs'", "show \"monomial_decomp (ss @ rs')\""], ["proof (prove)\nusing this:\n  monomial_decomp ss\n  monomial_decomp rs'\n\ngoal (1 subgoal):\n 1. monomial_decomp (ss @ rs')", "by (simp only: monomial_decomp_append_iff)"], ["proof (state)\nthis:\n  monomial_decomp (ss @ rs')\n\ngoal (1 subgoal):\n 1. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "assume *: \"hom_decomp ps\""], ["proof (state)\nthis:\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "hence \"hom_decomp qs\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. hom_decomp qs", "by (rule 4)"], ["proof (state)\nthis:\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "hence \"hom_decomp ss\""], ["proof (prove)\nusing this:\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp ss", "by (simp add: hom_decomp_def ss_def)"], ["proof (state)\nthis:\n  hom_decomp ss\n\ngoal (1 subgoal):\n 1. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "moreover"], ["proof (state)\nthis:\n  hom_decomp ss\n\ngoal (1 subgoal):\n 1. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "have \"hom_decomp rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp rs'", "unfolding rs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (concat (map f rs))", "using f5[OF *]"], ["proof (prove)\nusing this:\n  ?ps'14 \\<in> set (map f rs) \\<Longrightarrow> hom_decomp ?ps'14\n\ngoal (1 subgoal):\n 1. hom_decomp (concat (map f rs))", "by (rule hom_decomp_concat)"], ["proof (state)\nthis:\n  hom_decomp rs'\n\ngoal (1 subgoal):\n 1. hom_decomp ps \\<Longrightarrow> hom_decomp (ss @ rs')", "ultimately"], ["proof (chain)\npicking this:\n  hom_decomp ss\n  hom_decomp rs'", "show \"hom_decomp (ss @ rs')\""], ["proof (prove)\nusing this:\n  hom_decomp ss\n  hom_decomp rs'\n\ngoal (1 subgoal):\n 1. hom_decomp (ss @ rs')", "by (simp only: hom_decomp_append_iff)"], ["proof (state)\nthis:\n  hom_decomp (ss @ rs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + Suc i) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + ?i13) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; cone_decomp T qs; standard_decomp d qs;\n         monomial_decomp ps \\<Longrightarrow> monomial_decomp qs;\n         hom_decomp ps \\<Longrightarrow> hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + ?i13) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)", "obtain qs where 1: \"valid_decomp X qs\" and 2: \"cone_decomp T qs\"\n    and \"standard_decomp (k + (d - k)) qs\" and 4: \"monomial_decomp ps \\<Longrightarrow> monomial_decomp qs\"\n    and 5: \"hom_decomp ps \\<Longrightarrow> hom_decomp qs\""], ["proof (prove)\nusing this:\n  \\<exists>qs.\n     valid_decomp X qs \\<and>\n     cone_decomp T qs \\<and>\n     standard_decomp (k + ?i13) qs \\<and>\n     (monomial_decomp ps \\<longrightarrow> monomial_decomp qs) \\<and>\n     (hom_decomp ps \\<longrightarrow> hom_decomp qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; cone_decomp T qs;\n         standard_decomp (k + (d - k)) qs;\n         monomial_decomp ps \\<Longrightarrow> monomial_decomp qs;\n         hom_decomp ps \\<Longrightarrow> hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_decomp X qs\n  cone_decomp T qs\n  standard_decomp (k + (d - k)) qs\n  monomial_decomp ps \\<Longrightarrow> monomial_decomp qs\n  hom_decomp ps \\<Longrightarrow> hom_decomp qs\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; cone_decomp T qs; standard_decomp d qs;\n         monomial_decomp ps \\<Longrightarrow> monomial_decomp qs;\n         hom_decomp ps \\<Longrightarrow> hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(3) assms(5)"], ["proof (chain)\npicking this:\n  standard_decomp (k + (d - k)) qs\n  k \\<le> d", "have \"standard_decomp d qs\""], ["proof (prove)\nusing this:\n  standard_decomp (k + (d - k)) qs\n  k \\<le> d\n\ngoal (1 subgoal):\n 1. standard_decomp d qs", "by simp"], ["proof (state)\nthis:\n  standard_decomp d qs\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; cone_decomp T qs; standard_decomp d qs;\n         monomial_decomp ps \\<Longrightarrow> monomial_decomp qs;\n         hom_decomp ps \\<Longrightarrow> hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with 1 2"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  cone_decomp T qs\n  standard_decomp d qs", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  cone_decomp T qs\n  standard_decomp d qs\n\ngoal (1 subgoal):\n 1. thesis", "using 4 5"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  cone_decomp T qs\n  standard_decomp d qs\n  monomial_decomp ps \\<Longrightarrow> monomial_decomp qs\n  hom_decomp ps \\<Longrightarrow> hom_decomp qs\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Splitting w.r.t. Ideals\\<close>"], ["", "context\n  fixes X :: \"'x set\"\nbegin"], ["", "definition splits_wrt :: \"(((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<times> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list) \\<Rightarrow>\n                          (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::comm_ring_1) set \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) set \\<Rightarrow> bool\"\n  where \"splits_wrt pqs T F \\<longleftrightarrow> cone_decomp T (fst pqs @ snd pqs) \\<and>\n                                (\\<forall>hU\\<in>set (fst pqs). cone hU \\<subseteq> ideal F \\<inter> P[X]) \\<and>\n                                (\\<forall>(h, U)\\<in>set (snd pqs). cone (h, U) \\<subseteq> P[X] \\<and> cone (h, U) \\<inter> ideal F = {0})\""], ["", "lemma splits_wrtI:\n  assumes \"cone_decomp T (ps @ qs)\"\n    and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\" and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> ideal F\"\n    and \"\\<And>h U. (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\"\n    and \"\\<And>h U a. (h, U) \\<in> set qs \\<Longrightarrow> a \\<in> cone (h, U) \\<Longrightarrow> a \\<in> ideal F \\<Longrightarrow> a = 0\"\n  shows \"splits_wrt (ps, qs) T F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt (ps, qs) T F", "unfolding splits_wrt_def fst_conv snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (ps @ qs) \\<and>\n    (\\<forall>hU\\<in>set ps.\n        cone hU \\<subseteq> ideal F \\<inter> P[X]) \\<and>\n    (\\<forall>(h, U)\\<in>set qs.\n        cone (h, U) \\<subseteq> P[X] \\<and>\n        cone (h, U) \\<inter> ideal F = {0})", "proof (intro conjI ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>hU.\n       hU \\<in> set ps \\<Longrightarrow>\n       cone hU \\<subseteq> ideal F \\<inter> P[X]\n 3. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "fix hU"], ["proof (state)\ngoal (3 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>hU.\n       hU \\<in> set ps \\<Longrightarrow>\n       cone hU \\<subseteq> ideal F \\<inter> P[X]\n 3. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "assume \"hU \\<in> set ps\""], ["proof (state)\nthis:\n  hU \\<in> set ps\n\ngoal (3 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>hU.\n       hU \\<in> set ps \\<Longrightarrow>\n       cone hU \\<subseteq> ideal F \\<inter> P[X]\n 3. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "moreover"], ["proof (state)\nthis:\n  hU \\<in> set ps\n\ngoal (3 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>hU.\n       hU \\<in> set ps \\<Longrightarrow>\n       cone hU \\<subseteq> ideal F \\<inter> P[X]\n 3. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (3 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>hU.\n       hU \\<in> set ps \\<Longrightarrow>\n       cone hU \\<subseteq> ideal F \\<inter> P[X]\n 3. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "ultimately"], ["proof (chain)\npicking this:\n  hU \\<in> set ps\n  hU = (h, U)", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  hU \\<in> set ps\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (3 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>hU.\n       hU \\<in> set ps \\<Longrightarrow>\n       cone hU \\<subseteq> ideal F \\<inter> P[X]\n 3. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "hence \"cone (h, U) \\<subseteq> P[X]\" and \"h \\<in> ideal F\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X] &&& h \\<in> ideal F", "by (rule assms)+"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n  h \\<in> ideal F\n\ngoal (3 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>hU.\n       hU \\<in> set ps \\<Longrightarrow>\n       cone hU \\<subseteq> ideal F \\<inter> P[X]\n 3. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "from _ this(1)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  cone (h, U) \\<subseteq> P[X]", "show \"cone hU \\<subseteq> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. cone hU \\<subseteq> ideal F \\<inter> P[X]", "unfolding hU"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> ideal F \\<inter> P[X]", "proof (rule Int_greatest)"], ["proof (state)\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> ideal F", "show \"cone (h, U) \\<subseteq> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> ideal F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> ideal F", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> ideal F", "assume \"a \\<in> cone (h, U)\""], ["proof (state)\nthis:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> ideal F", "then"], ["proof (chain)\npicking this:\n  a \\<in> cone (h, U)", "obtain a' where \"a' \\<in> P[U]\" and a: \"a = a' * h\""], ["proof (prove)\nusing this:\n  a \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> P[U]; a = a' * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a' \\<in> P[U]\n  a = a' * h\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> cone (h, U) \\<Longrightarrow> x \\<in> ideal F", "from \\<open>h \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  h \\<in> ideal F", "show \"a \\<in> ideal F\""], ["proof (prove)\nusing this:\n  h \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a \\<in> ideal F", "unfolding a"], ["proof (prove)\nusing this:\n  h \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a' * h \\<in> ideal F", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  a \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone hU \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "fix hU"], ["proof (state)\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "assume \"hU \\<in> set qs\""], ["proof (state)\nthis:\n  hU \\<in> set qs\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "moreover"], ["proof (state)\nthis:\n  hU \\<in> set qs\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "ultimately"], ["proof (chain)\npicking this:\n  hU \\<in> set qs\n  hU = (h, U)", "have \"(h, U) \\<in> set qs\""], ["proof (prove)\nusing this:\n  hU \\<in> set qs\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "hence \"cone (h, U) \\<subseteq> P[X]\" and \"\\<And>a. a \\<in> cone (h, U) \\<Longrightarrow> a \\<in> ideal F \\<Longrightarrow> a = 0\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X] &&&\n    (\\<And>a.\n        \\<lbrakk>a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n        \\<Longrightarrow> a = 0)", "by (rule assms)+"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n  \\<lbrakk>?a14 \\<in> cone (h, U); ?a14 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a14 = 0\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "moreover"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n  \\<lbrakk>?a14 \\<in> cone (h, U); ?a14 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a14 = 0\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "have \"0 \\<in> cone (h, U) \\<inter> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> cone (h, U) \\<inter> ideal F", "by (simp add: zero_in_cone ideal.span_zero)"], ["proof (state)\nthis:\n  0 \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (2 subgoals):\n 1. cone_decomp T (ps @ qs)\n 2. \\<And>x.\n       x \\<in> set qs \\<Longrightarrow>\n       case x of\n       (h, U) \\<Rightarrow>\n         cone (h, U) \\<subseteq> P[X] \\<and>\n         cone (h, U) \\<inter> ideal F = {0}", "ultimately"], ["proof (chain)\npicking this:\n  cone (h, U) \\<subseteq> P[X]\n  \\<lbrakk>?a14 \\<in> cone (h, U); ?a14 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a14 = 0\n  0 \\<in> cone (h, U) \\<inter> ideal F", "show \"case hU of (h, U) \\<Rightarrow> cone (h, U) \\<subseteq> P[X] \\<and> cone (h, U) \\<inter> ideal F = {0}\""], ["proof (prove)\nusing this:\n  cone (h, U) \\<subseteq> P[X]\n  \\<lbrakk>?a14 \\<in> cone (h, U); ?a14 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a14 = 0\n  0 \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. case hU of\n    (h, U) \\<Rightarrow>\n      cone (h, U) \\<subseteq> P[X] \\<and> cone (h, U) \\<inter> ideal F = {0}", "by (fastforce simp: hU)"], ["proof (state)\nthis:\n  case hU of\n  (h, U) \\<Rightarrow>\n    cone (h, U) \\<subseteq> P[X] \\<and> cone (h, U) \\<inter> ideal F = {0}\n\ngoal (1 subgoal):\n 1. cone_decomp T (ps @ qs)", "qed (fact assms)+"], ["", "lemma splits_wrtI_valid_decomp:\n  assumes \"valid_decomp X ps\" and \"valid_decomp X qs\" and \"cone_decomp T (ps @ qs)\"\n    and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> ideal F\"\n    and \"\\<And>h U a. (h, U) \\<in> set qs \\<Longrightarrow> a \\<in> cone (h, U) \\<Longrightarrow> a \\<in> ideal F \\<Longrightarrow> a = 0\"\n  shows \"splits_wrt (ps, qs) T F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt (ps, qs) T F", "using assms(3) _ _ _ assms(5)"], ["proof (prove)\nusing this:\n  cone_decomp T (ps @ qs)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<lbrakk>(?h14, ?U14) \\<in> set qs; ?a14 \\<in> cone (?h14, ?U14);\n   ?a14 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a14 = 0\n\ngoal (1 subgoal):\n 1. splits_wrt (ps, qs) T F", "proof (rule splits_wrtI)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 6. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "fix h U"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 6. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (6 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 6. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "thus \"h \\<in> ideal F\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> ideal F", "by (rule assms(4))"], ["proof (state)\nthis:\n  h \\<in> ideal F\n\ngoal (5 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "from assms(1) \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"h \\<in> P[X]\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (5 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "thus \"cone (h, U) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "by (rule cone_subset_PolysI)"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "fix h U"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "assume \"(h, U) \\<in> set qs\""], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "with assms(2)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs", "have \"h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. h \\<in> P[X]", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  h \\<in> P[X]\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "moreover"], ["proof (state)\nthis:\n  h \\<in> P[X]\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "from assms(2) \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs", "have \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set qs \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "ultimately"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  U \\<subseteq> X", "show \"cone (h, U) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X]", "by (rule cone_subset_PolysI)"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X]\n\ngoal (3 subgoals):\n 1. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> (?h15 h U a, ?U15 h U a) \\<in> set qs\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> cone (?h15 h U a, ?U15 h U a)\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set qs; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a \\<in> ideal F", "qed"], ["", "lemma splits_wrtD:\n  assumes \"splits_wrt (ps, qs) T F\"\n  shows \"cone_decomp T (ps @ qs)\" and \"hU \\<in> set ps \\<Longrightarrow> cone hU \\<subseteq> ideal F \\<inter> P[X]\"\n    and \"hU \\<in> set qs \\<Longrightarrow> cone hU \\<subseteq> P[X]\" and \"hU \\<in> set qs \\<Longrightarrow> cone hU \\<inter> ideal F = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cone_decomp T (ps @ qs) &&&\n     (hU \\<in> set ps \\<Longrightarrow>\n      cone hU \\<subseteq> ideal F \\<inter> P[X])) &&&\n    (hU \\<in> set qs \\<Longrightarrow> cone hU \\<subseteq> P[X]) &&&\n    (hU \\<in> set qs \\<Longrightarrow> cone hU \\<inter> ideal F = {0})", "using assms"], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n\ngoal (1 subgoal):\n 1. (cone_decomp T (ps @ qs) &&&\n     (hU \\<in> set ps \\<Longrightarrow>\n      cone hU \\<subseteq> ideal F \\<inter> P[X])) &&&\n    (hU \\<in> set qs \\<Longrightarrow> cone hU \\<subseteq> P[X]) &&&\n    (hU \\<in> set qs \\<Longrightarrow> cone hU \\<inter> ideal F = {0})", "by (fastforce simp: splits_wrt_def)+"], ["", "lemma splits_wrt_image_sum_list_fst_subset:\n  assumes \"splits_wrt (ps, qs) T F\"\n  shows \"sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "assume x_in: \"x \\<in> sum_list ` listset (map cone ps)\""], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map cone ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "have \"listset (map cone ps) \\<subseteq> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listset (map cone ps)\n    \\<subseteq> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "proof (rule listset_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map cone ps) =\n    length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>_. ideal F \\<inter> P[X]) ps) \\<Longrightarrow>\n       map cone ps ! i\n       \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map cone ps) =\n    length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>_. ideal F \\<inter> P[X]) ps) \\<Longrightarrow>\n       map cone ps ! i\n       \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "assume i: \"i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\""], ["proof (state)\nthis:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (2 subgoals):\n 1. length (map cone ps) =\n    length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>_. ideal F \\<inter> P[X]) ps) \\<Longrightarrow>\n       map cone ps ! i\n       \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "hence \"ps ! i \\<in> set ps\""], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. ps ! i \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  ps ! i \\<in> set ps\n\ngoal (2 subgoals):\n 1. length (map cone ps) =\n    length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>_. ideal F \\<inter> P[X]) ps) \\<Longrightarrow>\n       map cone ps ! i\n       \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "with assms(1)"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F\n  ps ! i \\<in> set ps", "have \"cone (ps ! i) \\<subseteq> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n  ps ! i \\<in> set ps\n\ngoal (1 subgoal):\n 1. cone (ps ! i) \\<subseteq> ideal F \\<inter> P[X]", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (ps ! i) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (2 subgoals):\n 1. length (map cone ps) =\n    length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>_. ideal F \\<inter> P[X]) ps) \\<Longrightarrow>\n       map cone ps ! i\n       \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "with i"], ["proof (chain)\npicking this:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n  cone (ps ! i) \\<subseteq> ideal F \\<inter> P[X]", "show \"map cone ps ! i \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i\""], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n  cone (ps ! i) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. map cone ps ! i\n    \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "by simp"], ["proof (state)\nthis:\n  map cone ps ! i \\<subseteq> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i\n\ngoal (1 subgoal):\n 1. length (map cone ps) =\n    length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "qed simp"], ["proof (state)\nthis:\n  listset (map cone ps)\n  \\<subseteq> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "hence \"sum_list ` listset (map cone ps) \\<subseteq> sum_list ` listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\""], ["proof (prove)\nusing this:\n  listset (map cone ps)\n  \\<subseteq> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps)\n    \\<subseteq> sum_list `\n                listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "by (rule image_mono)"], ["proof (state)\nthis:\n  sum_list ` listset (map cone ps)\n  \\<subseteq> sum_list `\n              listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "with x_in"], ["proof (chain)\npicking this:\n  x \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps)\n  \\<subseteq> sum_list `\n              listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "have \"x \\<in> sum_list ` listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\""], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps)\n  \\<subseteq> sum_list `\n              listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. x \\<in> sum_list ` listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", ".."], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "then"], ["proof (chain)\npicking this:\n  x \\<in> sum_list ` listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "obtain xs where xs: \"xs \\<in> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\" and x: \"x = sum_list xs\""], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> listset\n                           (map (\\<lambda>_. ideal F \\<inter> P[X]) ps);\n         x = sum_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  xs \\<in> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n  x = sum_list xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "have 1: \"y \\<in> ideal F \\<inter> P[X]\" if \"y \\<in> set xs\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "from that"], ["proof (chain)\npicking this:\n  y \\<in> set xs", "obtain i where \"i < length xs\" and y: \"y = xs ! i\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; y = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length xs\n  y = xs ! i\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "moreover"], ["proof (state)\nthis:\n  i < length xs\n  y = xs ! i\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "from xs"], ["proof (chain)\npicking this:\n  xs \\<in> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "have \"length xs = length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\""], ["proof (prove)\nusing this:\n  xs \\<in> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. length xs = length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "by (rule listsetD)"], ["proof (state)\nthis:\n  length xs = length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "ultimately"], ["proof (chain)\npicking this:\n  i < length xs\n  y = xs ! i\n  length xs = length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "have \"i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\""], ["proof (prove)\nusing this:\n  i < length xs\n  y = xs ! i\n  length xs = length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "by simp"], ["proof (state)\nthis:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "moreover"], ["proof (state)\nthis:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "from xs this"], ["proof (chain)\npicking this:\n  xs \\<in> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)", "have \"xs ! i \\<in> (map (\\<lambda>_. ideal F \\<inter> P[X]) ps) ! i\""], ["proof (prove)\nusing this:\n  xs \\<in> listset (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "by (rule listsetD)"], ["proof (state)\nthis:\n  xs ! i \\<in> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "ultimately"], ["proof (chain)\npicking this:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n  xs ! i \\<in> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i", "show \"y \\<in> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>_. ideal F \\<inter> P[X]) ps)\n  xs ! i \\<in> map (\\<lambda>_. ideal F \\<inter> P[X]) ps ! i\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "by (simp add: y)"], ["proof (state)\nthis:\n  y \\<in> ideal F \\<inter> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y14 \\<in> set xs \\<Longrightarrow> ?y14 \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n       x \\<in> ideal F \\<inter> P[X]", "show \"x \\<in> ideal F \\<inter> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ideal F \\<inter> P[X]", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs \\<in> ideal F \\<inter> P[X]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list xs \\<in> ideal F\n 2. sum_list xs \\<in> P[X]", "show \"sum_list xs \\<in> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs \\<in> ideal F", "proof (rule ideal.span_closed_sum_list[simplified])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> ideal F", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> ideal F", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> ideal F", "hence \"y \\<in> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "by (rule 1)"], ["proof (state)\nthis:\n  y \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> ideal F", "thus \"y \\<in> ideal F\""], ["proof (prove)\nusing this:\n  y \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  y \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list xs \\<in> ideal F\n\ngoal (1 subgoal):\n 1. sum_list xs \\<in> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list xs \\<in> P[X]", "show \"sum_list xs \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs \\<in> P[X]", "proof (rule Polys_closed_sum_list)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "hence \"y \\<in> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. y \\<in> ideal F \\<inter> P[X]", "by (rule 1)"], ["proof (state)\nthis:\n  y \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "thus \"y \\<in> P[X]\""], ["proof (prove)\nusing this:\n  y \\<in> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. y \\<in> P[X]", "by simp"], ["proof (state)\nthis:\n  y \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list xs \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> ideal F \\<inter> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splits_wrt_image_sum_list_snd_subset:\n  assumes \"splits_wrt (ps, qs) T F\"\n  shows \"sum_list ` listset (map cone qs) \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs) \\<subseteq> P[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n       x \\<in> P[X]", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n       x \\<in> P[X]", "assume x_in: \"x \\<in> sum_list ` listset (map cone qs)\""], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map cone qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n       x \\<in> P[X]", "have \"listset (map cone qs) \\<subseteq> listset (map (\\<lambda>_. P[X]) qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. listset (map cone qs) \\<subseteq> listset (map (\\<lambda>_. P[X]) qs)", "proof (rule listset_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map cone qs) = length (map (\\<lambda>_. P[X]) qs)\n 2. \\<And>i.\n       i < length (map (\\<lambda>_. P[X]) qs) \\<Longrightarrow>\n       map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map cone qs) = length (map (\\<lambda>_. P[X]) qs)\n 2. \\<And>i.\n       i < length (map (\\<lambda>_. P[X]) qs) \\<Longrightarrow>\n       map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i", "assume i: \"i < length (map (\\<lambda>_. P[X]) qs)\""], ["proof (state)\nthis:\n  i < length (map (\\<lambda>_. P[X]) qs)\n\ngoal (2 subgoals):\n 1. length (map cone qs) = length (map (\\<lambda>_. P[X]) qs)\n 2. \\<And>i.\n       i < length (map (\\<lambda>_. P[X]) qs) \\<Longrightarrow>\n       map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i", "hence \"qs ! i \\<in> set qs\""], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. qs ! i \\<in> set qs", "by simp"], ["proof (state)\nthis:\n  qs ! i \\<in> set qs\n\ngoal (2 subgoals):\n 1. length (map cone qs) = length (map (\\<lambda>_. P[X]) qs)\n 2. \\<And>i.\n       i < length (map (\\<lambda>_. P[X]) qs) \\<Longrightarrow>\n       map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i", "with assms(1)"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F\n  qs ! i \\<in> set qs", "have \"cone (qs ! i) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n  qs ! i \\<in> set qs\n\ngoal (1 subgoal):\n 1. cone (qs ! i) \\<subseteq> P[X]", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (qs ! i) \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. length (map cone qs) = length (map (\\<lambda>_. P[X]) qs)\n 2. \\<And>i.\n       i < length (map (\\<lambda>_. P[X]) qs) \\<Longrightarrow>\n       map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i", "with i"], ["proof (chain)\npicking this:\n  i < length (map (\\<lambda>_. P[X]) qs)\n  cone (qs ! i) \\<subseteq> P[X]", "show \"map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i\""], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>_. P[X]) qs)\n  cone (qs ! i) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i", "by simp"], ["proof (state)\nthis:\n  map cone qs ! i \\<subseteq> map (\\<lambda>_. P[X]) qs ! i\n\ngoal (1 subgoal):\n 1. length (map cone qs) = length (map (\\<lambda>_. P[X]) qs)", "qed simp"], ["proof (state)\nthis:\n  listset (map cone qs) \\<subseteq> listset (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n       x \\<in> P[X]", "hence \"sum_list ` listset (map cone qs) \\<subseteq> sum_list ` listset (map (\\<lambda>_. P[X]) qs)\""], ["proof (prove)\nusing this:\n  listset (map cone qs) \\<subseteq> listset (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs)\n    \\<subseteq> sum_list ` listset (map (\\<lambda>_. P[X]) qs)", "by (rule image_mono)"], ["proof (state)\nthis:\n  sum_list ` listset (map cone qs)\n  \\<subseteq> sum_list ` listset (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n       x \\<in> P[X]", "with x_in"], ["proof (chain)\npicking this:\n  x \\<in> sum_list ` listset (map cone qs)\n  sum_list ` listset (map cone qs)\n  \\<subseteq> sum_list ` listset (map (\\<lambda>_. P[X]) qs)", "have \"x \\<in> sum_list ` listset (map (\\<lambda>_. P[X]) qs)\""], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map cone qs)\n  sum_list ` listset (map cone qs)\n  \\<subseteq> sum_list ` listset (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. x \\<in> sum_list ` listset (map (\\<lambda>_. P[X]) qs)", ".."], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n       x \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  x \\<in> sum_list ` listset (map (\\<lambda>_. P[X]) qs)", "obtain xs where xs: \"xs \\<in> listset (map (\\<lambda>_. P[X]) qs)\" and x: \"x = sum_list xs\""], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> listset (map (\\<lambda>_. P[X]) qs);\n         x = sum_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  xs \\<in> listset (map (\\<lambda>_. P[X]) qs)\n  x = sum_list xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n       x \\<in> P[X]", "show \"x \\<in> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> P[X]", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs \\<in> P[X]", "proof (rule Polys_closed_sum_list)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "assume \"y \\<in> set xs\""], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  y \\<in> set xs", "obtain i where \"i < length xs\" and y: \"y = xs ! i\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; y = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length xs\n  y = xs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "moreover"], ["proof (state)\nthis:\n  i < length xs\n  y = xs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "from xs"], ["proof (chain)\npicking this:\n  xs \\<in> listset (map (\\<lambda>_. P[X]) qs)", "have \"length xs = length (map (\\<lambda>_. P[X]::(_ \\<Rightarrow>\\<^sub>0 'a) set) qs)\""], ["proof (prove)\nusing this:\n  xs \\<in> listset (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. length xs = length (map (\\<lambda>_. P[X]) qs)", "by (rule listsetD)"], ["proof (state)\nthis:\n  length xs = length (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "ultimately"], ["proof (chain)\npicking this:\n  i < length xs\n  y = xs ! i\n  length xs = length (map (\\<lambda>_. P[X]) qs)", "have \"i < length (map (\\<lambda>_. P[X]) qs)\""], ["proof (prove)\nusing this:\n  i < length xs\n  y = xs ! i\n  length xs = length (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. i < length (map (\\<lambda>_. P[X]) qs)", "by simp"], ["proof (state)\nthis:\n  i < length (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "moreover"], ["proof (state)\nthis:\n  i < length (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "from xs this"], ["proof (chain)\npicking this:\n  xs \\<in> listset (map (\\<lambda>_. P[X]) qs)\n  i < length (map (\\<lambda>_. P[X]) qs)", "have \"xs ! i \\<in> (map (\\<lambda>_. P[X]) qs) ! i\""], ["proof (prove)\nusing this:\n  xs \\<in> listset (map (\\<lambda>_. P[X]) qs)\n  i < length (map (\\<lambda>_. P[X]) qs)\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> map (\\<lambda>_. P[X]) qs ! i", "by (rule listsetD)"], ["proof (state)\nthis:\n  xs ! i \\<in> map (\\<lambda>_. P[X]) qs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<in> P[X]", "ultimately"], ["proof (chain)\npicking this:\n  i < length (map (\\<lambda>_. P[X]) qs)\n  xs ! i \\<in> map (\\<lambda>_. P[X]) qs ! i", "show \"y \\<in> P[X]\""], ["proof (prove)\nusing this:\n  i < length (map (\\<lambda>_. P[X]) qs)\n  xs ! i \\<in> map (\\<lambda>_. P[X]) qs ! i\n\ngoal (1 subgoal):\n 1. y \\<in> P[X]", "by (simp add: y)"], ["proof (state)\nthis:\n  y \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma splits_wrt_cone_decomp_1:\n  assumes \"splits_wrt (ps, qs) T F\" and \"monomial_decomp qs\" and \"is_monomial_set (F::(_ \\<Rightarrow>\\<^sub>0 'a::field) set)\"\n        \\<comment>\\<open>The last two assumptions are missing in the paper.\\<close>\n  shows \"cone_decomp (T \\<inter> ideal F) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> ideal F) ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> ideal F) ps", "from assms(1)"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F", "have *: \"cone_decomp T (ps @ qs)\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n\ngoal (1 subgoal):\n 1. cone_decomp T (ps @ qs)", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone_decomp T (ps @ qs)\n\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> ideal F) ps", "hence \"direct_decomp T (map cone ps @ map cone qs)\""], ["proof (prove)\nusing this:\n  cone_decomp T (ps @ qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps @ map cone qs)", "by (simp add: cone_decomp_def)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps @ map cone qs)\n\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> ideal F) ps", "hence 1: \"direct_decomp (sum_list ` listset (map cone ps)) (map cone ps)\"\n    and 2: \"direct_decomp T [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps @ map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp (sum_list ` listset (map cone ps)) (map cone ps) &&&\n    direct_decomp T\n     [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]", "by (auto dest: direct_decomp_appendD intro!: empty_not_in_map_cone)"], ["proof (state)\nthis:\n  direct_decomp (sum_list ` listset (map cone ps)) (map cone ps)\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> ideal F) ps", "let ?ss = \"[sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> ideal F) ps", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> ideal F) ps", "proof (intro cone_decompI direct_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on sum_list (listset (map cone ps))\n 2. sum_list ` listset (map cone ps) = T \\<inter> ideal F", "from 1"], ["proof (chain)\npicking this:\n  direct_decomp (sum_list ` listset (map cone ps)) (map cone ps)", "show \"inj_on sum_list (listset (map cone ps))\""], ["proof (prove)\nusing this:\n  direct_decomp (sum_list ` listset (map cone ps)) (map cone ps)\n\ngoal (1 subgoal):\n 1. inj_on sum_list (listset (map cone ps))", "by (simp only: direct_decomp_def bij_betw_def)"], ["proof (state)\nthis:\n  inj_on sum_list (listset (map cone ps))\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) = T \\<inter> ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) = T \\<inter> ideal F", "from assms(1)"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F", "have \"sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]", "by (rule splits_wrt_image_sum_list_fst_subset)"], ["proof (state)\nthis:\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) = T \\<inter> ideal F", "hence sub: \"sum_list ` listset (map cone ps) \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) \\<subseteq> ideal F", "by simp"], ["proof (state)\nthis:\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) = T \\<inter> ideal F", "show \"sum_list ` listset (map cone ps) = T \\<inter> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) = T \\<inter> ideal F", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> sum_list ` listset (map cone ps)) =\n       (x \\<in> T \\<inter> ideal F)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> sum_list ` listset (map cone ps)) =\n       (x \\<in> T \\<inter> ideal F)", "show \"x \\<in> sum_list ` listset (map cone ps) \\<longleftrightarrow> x \\<in> T \\<inter> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> sum_list ` listset (map cone ps)) =\n    (x \\<in> T \\<inter> ideal F)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n    x \\<in> T \\<inter> ideal F\n 2. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "assume x_in: \"x \\<in> sum_list ` listset (map cone ps)\""], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map cone ps)\n\ngoal (2 subgoals):\n 1. x \\<in> sum_list ` listset (map cone ps) \\<Longrightarrow>\n    x \\<in> T \\<inter> ideal F\n 2. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "show \"x \\<in> T \\<inter> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F", "proof (intro IntI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> ideal F", "have \"map (\\<lambda>_. 0) qs \\<in> listset (map cone qs)\" (is \"?ys \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>_. 0) qs \\<in> listset (map cone qs)", "by (induct qs) (auto intro: listset_ConsI zero_in_cone simp del: listset.simps(2))"], ["proof (state)\nthis:\n  map (\\<lambda>_. 0) qs \\<in> listset (map cone qs)\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> ideal F", "hence \"sum_list ?ys \\<in> sum_list ` listset (map cone qs)\""], ["proof (prove)\nusing this:\n  map (\\<lambda>_. 0) qs \\<in> listset (map cone qs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<leftarrow>qs. 0) \\<in> sum_list ` listset (map cone qs)", "by (rule imageI)"], ["proof (state)\nthis:\n  (\\<Sum>_\\<leftarrow>qs. 0) \\<in> sum_list ` listset (map cone qs)\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> ideal F", "hence \"0 \\<in> sum_list ` listset (map cone qs)\""], ["proof (prove)\nusing this:\n  (\\<Sum>_\\<leftarrow>qs. 0) \\<in> sum_list ` listset (map cone qs)\n\ngoal (1 subgoal):\n 1. 0 \\<in> sum_list ` listset (map cone qs)", "by simp"], ["proof (state)\nthis:\n  0 \\<in> sum_list ` listset (map cone qs)\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> ideal F", "with x_in"], ["proof (chain)\npicking this:\n  x \\<in> sum_list ` listset (map cone ps)\n  0 \\<in> sum_list ` listset (map cone qs)", "have \"[x, 0] \\<in> listset ?ss\""], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map cone ps)\n  0 \\<in> sum_list ` listset (map cone qs)\n\ngoal (1 subgoal):\n 1. [x, 0]\n    \\<in> listset\n           [sum_list ` listset (map cone ps),\n            sum_list ` listset (map cone qs)]", "using refl"], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map cone ps)\n  0 \\<in> sum_list ` listset (map cone qs)\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. [x, 0]\n    \\<in> listset\n           [sum_list ` listset (map cone ps),\n            sum_list ` listset (map cone qs)]", "by (rule listset_doubletonI)"], ["proof (state)\nthis:\n  [x, 0]\n  \\<in> listset\n         [sum_list ` listset (map cone ps),\n          sum_list ` listset (map cone qs)]\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> ideal F", "with 2"], ["proof (chain)\npicking this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  [x, 0]\n  \\<in> listset\n         [sum_list ` listset (map cone ps),\n          sum_list ` listset (map cone qs)]", "have \"sum_list [x, 0] \\<in> T\""], ["proof (prove)\nusing this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  [x, 0]\n  \\<in> listset\n         [sum_list ` listset (map cone ps),\n          sum_list ` listset (map cone qs)]\n\ngoal (1 subgoal):\n 1. sum_list [x, 0] \\<in> T", "by (rule direct_decompD)"], ["proof (state)\nthis:\n  sum_list [x, 0] \\<in> T\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> ideal F", "thus \"x \\<in> T\""], ["proof (prove)\nusing this:\n  sum_list [x, 0] \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> T", "by simp"], ["proof (state)\nthis:\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> ideal F", "from x_in sub"], ["proof (chain)\npicking this:\n  x \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F", "show \"x \\<in> ideal F\""], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> ideal F", ".."], ["proof (state)\nthis:\n  x \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> T \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "assume \"x \\<in> T \\<inter> ideal F\""], ["proof (state)\nthis:\n  x \\<in> T \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "hence \"x \\<in> T\" and \"x \\<in> ideal F\""], ["proof (prove)\nusing this:\n  x \\<in> T \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T &&& x \\<in> ideal F", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> T\n  x \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "from 2 this(1)"], ["proof (chain)\npicking this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  x \\<in> T", "obtain xs where \"xs \\<in> listset ?ss\" and x: \"x = sum_list xs\""], ["proof (prove)\nusing this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> listset\n                           [sum_list ` listset (map cone ps),\n                            sum_list ` listset (map cone qs)];\n         x = sum_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  xs \\<in> listset\n            [sum_list ` listset (map cone ps),\n             sum_list ` listset (map cone qs)]\n  x = sum_list xs\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "from this(1)"], ["proof (chain)\npicking this:\n  xs \\<in> listset\n            [sum_list ` listset (map cone ps),\n             sum_list ` listset (map cone qs)]", "obtain p q where p: \"p \\<in> sum_list ` listset (map cone ps)\"\n          and q: \"q \\<in> sum_list ` listset (map cone qs)\" and xs: \"xs = [p, q]\""], ["proof (prove)\nusing this:\n  xs \\<in> listset\n            [sum_list ` listset (map cone ps),\n             sum_list ` listset (map cone qs)]\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>p \\<in> sum_list ` listset (map cone ps);\n         q \\<in> sum_list ` listset (map cone qs); xs = [p, q]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  p \\<in> sum_list ` listset (map cone ps)\n  q \\<in> sum_list ` listset (map cone qs)\n  xs = [p, q]\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "from \\<open>x \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> ideal F", "have \"p + q \\<in> ideal F\""], ["proof (prove)\nusing this:\n  x \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p + q \\<in> ideal F", "by (simp add: x xs)"], ["proof (state)\nthis:\n  p + q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "moreover"], ["proof (state)\nthis:\n  p + q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "from p sub"], ["proof (chain)\npicking this:\n  p \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F", "have \"p \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F", ".."], ["proof (state)\nthis:\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "ultimately"], ["proof (chain)\npicking this:\n  p + q \\<in> ideal F\n  p \\<in> ideal F", "have \"p + q - p \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p + q \\<in> ideal F\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p + q - p \\<in> ideal F", "by (rule ideal.span_diff)"], ["proof (state)\nthis:\n  p + q - p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "hence \"q \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p + q - p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. q \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  q \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "have \"q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "assume \"q \\<noteq> 0\""], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "hence \"keys q \\<noteq> {}\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys q \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  keys q \\<noteq> {}", "obtain t where \"t \\<in> keys q\""], ["proof (prove)\nusing this:\n  keys q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> keys q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "with assms(2) q"], ["proof (chain)\npicking this:\n  monomial_decomp qs\n  q \\<in> sum_list ` listset (map cone qs)\n  t \\<in> keys q", "obtain c h U where \"(h, U) \\<in> set qs\" and \"c \\<noteq> 0\"\n            and \"monomial c t \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  monomial_decomp qs\n  q \\<in> sum_list ` listset (map cone qs)\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set qs; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule monomial_decomp_sum_list_monomial_in_cone)"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n  c \\<noteq> (0::'a)\n  monomial c t \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n  c \\<noteq> (0::'a)\n  monomial c t \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "from assms(3) \\<open>q \\<in> ideal F\\<close> \\<open>t \\<in> keys q\\<close>"], ["proof (chain)\npicking this:\n  is_monomial_set F\n  q \\<in> ideal F\n  t \\<in> keys q", "have \"monomial c t \\<in> ideal F\""], ["proof (prove)\nusing this:\n  is_monomial_set F\n  q \\<in> ideal F\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. monomial c t \\<in> ideal F", "by (rule punit.monomial_pmdl_field[simplified])"], ["proof (state)\nthis:\n  monomial c t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set qs\n  c \\<noteq> (0::'a)\n  monomial c t \\<in> cone (h, U)\n  monomial c t \\<in> ideal F", "have \"monomial c t \\<in> cone (h, U) \\<inter> ideal F\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set qs\n  c \\<noteq> (0::'a)\n  monomial c t \\<in> cone (h, U)\n  monomial c t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. monomial c t \\<in> cone (h, U) \\<inter> ideal F", "by simp"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "from assms(1) \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F\n  (h, U) \\<in> set qs", "have \"\\<dots> = {0}\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<inter> ideal F = {0}", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h, U) \\<inter> ideal F = {0}\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  monomial c t \\<in> {0}", "have \"c = 0\""], ["proof (prove)\nusing this:\n  monomial c t \\<in> {0}\n\ngoal (1 subgoal):\n 1. c = (0::'a)", "by (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  c = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = 0\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> ideal F \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone ps)", "with p"], ["proof (chain)\npicking this:\n  p \\<in> sum_list ` listset (map cone ps)\n  q = 0", "show \"x \\<in> sum_list ` listset (map cone ps)\""], ["proof (prove)\nusing this:\n  p \\<in> sum_list ` listset (map cone ps)\n  q = 0\n\ngoal (1 subgoal):\n 1. x \\<in> sum_list ` listset (map cone ps)", "by (simp add: x xs)"], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map cone ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> sum_list ` listset (map cone ps)) = (x \\<in> T \\<inter> ideal F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list ` listset (map cone ps) = T \\<inter> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone_decomp (T \\<inter> ideal F) ps\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Together, Theorems \\<open>splits_wrt_image_sum_list_fst_subset\\<close> and \\<open>splits_wrt_cone_decomp_1\\<close>\n  imply that @{term ps} is also a cone decomposition of @{term \"T \\<inter> ideal F \\<inter> P[X]\"}.\\<close>"], ["", "lemma splits_wrt_cone_decomp_2:\n  assumes \"finite X\" and \"splits_wrt (ps, qs) T F\" and \"monomial_decomp qs\" and \"is_monomial_set F\"\n    and \"F \\<subseteq> P[X]\"\n  shows \"cone_decomp (T \\<inter> normal_form F ` P[X]) qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "from assms(2)"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F", "have *: \"cone_decomp T (ps @ qs)\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n\ngoal (1 subgoal):\n 1. cone_decomp T (ps @ qs)", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone_decomp T (ps @ qs)\n\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "hence \"direct_decomp T (map cone ps @ map cone qs)\""], ["proof (prove)\nusing this:\n  cone_decomp T (ps @ qs)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ps @ map cone qs)", "by (simp add: cone_decomp_def)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ps @ map cone qs)\n\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "hence 1: \"direct_decomp (sum_list ` listset (map cone qs)) (map cone qs)\"\n    and 2: \"direct_decomp T [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ps @ map cone qs)\n\ngoal (1 subgoal):\n 1. direct_decomp (sum_list ` listset (map cone qs)) (map cone qs) &&&\n    direct_decomp T\n     [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]", "by (auto dest: direct_decomp_appendD intro!: empty_not_in_map_cone)"], ["proof (state)\nthis:\n  direct_decomp (sum_list ` listset (map cone qs)) (map cone qs)\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "let ?ss = \"[sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "let ?G = \"punit.reduced_GB F\""], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "from assms(1, 5)"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"?G \\<subseteq> P[X]\" and G_is_GB: \"punit.is_Groebner_basis ?G\"\n    and ideal_G: \"ideal ?G = ideal F\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.reduced_GB F \\<subseteq> P[X] &&&\n    punit.is_Groebner_basis (punit.reduced_GB F) &&&\n    ideal (punit.reduced_GB F) = ideal F", "by (rule reduced_GB_Polys, rule reduced_GB_is_GB_Polys, rule reduced_GB_ideal_Polys)"], ["proof (state)\nthis:\n  punit.reduced_GB F \\<subseteq> P[X]\n  punit.is_Groebner_basis (punit.reduced_GB F)\n  ideal (punit.reduced_GB F) = ideal F\n\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp (T \\<inter> normal_form F ` P[X]) qs", "proof (intro cone_decompI direct_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on sum_list (listset (map cone qs))\n 2. sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]", "from 1"], ["proof (chain)\npicking this:\n  direct_decomp (sum_list ` listset (map cone qs)) (map cone qs)", "show \"inj_on sum_list (listset (map cone qs))\""], ["proof (prove)\nusing this:\n  direct_decomp (sum_list ` listset (map cone qs)) (map cone qs)\n\ngoal (1 subgoal):\n 1. inj_on sum_list (listset (map cone qs))", "by (simp only: direct_decomp_def bij_betw_def)"], ["proof (state)\nthis:\n  inj_on sum_list (listset (map cone qs))\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]", "from assms(2)"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F", "have \"sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]", "by (rule splits_wrt_image_sum_list_fst_subset)"], ["proof (state)\nthis:\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]", "hence sub: \"sum_list ` listset (map cone ps) \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone ps) \\<subseteq> ideal F", "by simp"], ["proof (state)\nthis:\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]", "show \"sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> sum_list ` listset (map cone qs)) =\n       (x \\<in> T \\<inter> normal_form F ` P[X])", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> sum_list ` listset (map cone qs)) =\n       (x \\<in> T \\<inter> normal_form F ` P[X])", "show \"x \\<in> sum_list ` listset (map cone qs) \\<longleftrightarrow> x \\<in> T \\<inter> normal_form F ` P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> sum_list ` listset (map cone qs)) =\n    (x \\<in> T \\<inter> normal_form F ` P[X])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n    x \\<in> T \\<inter> normal_form F ` P[X]\n 2. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "assume x_in: \"x \\<in> sum_list ` listset (map cone qs)\""], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map cone qs)\n\ngoal (2 subgoals):\n 1. x \\<in> sum_list ` listset (map cone qs) \\<Longrightarrow>\n    x \\<in> T \\<inter> normal_form F ` P[X]\n 2. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "show \"x \\<in> T \\<inter> normal_form F ` P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X]", "proof (intro IntI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> normal_form F ` P[X]", "have \"map (\\<lambda>_. 0) ps \\<in> listset (map cone ps)\" (is \"?ys \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>_. 0) ps \\<in> listset (map cone ps)", "by (induct ps) (auto intro: listset_ConsI zero_in_cone simp del: listset.simps(2))"], ["proof (state)\nthis:\n  map (\\<lambda>_. 0) ps \\<in> listset (map cone ps)\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> normal_form F ` P[X]", "hence \"sum_list ?ys \\<in> sum_list ` listset (map cone ps)\""], ["proof (prove)\nusing this:\n  map (\\<lambda>_. 0) ps \\<in> listset (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<leftarrow>ps. 0) \\<in> sum_list ` listset (map cone ps)", "by (rule imageI)"], ["proof (state)\nthis:\n  (\\<Sum>_\\<leftarrow>ps. 0) \\<in> sum_list ` listset (map cone ps)\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> normal_form F ` P[X]", "hence \"0 \\<in> sum_list ` listset (map cone ps)\""], ["proof (prove)\nusing this:\n  (\\<Sum>_\\<leftarrow>ps. 0) \\<in> sum_list ` listset (map cone ps)\n\ngoal (1 subgoal):\n 1. 0 \\<in> sum_list ` listset (map cone ps)", "by simp"], ["proof (state)\nthis:\n  0 \\<in> sum_list ` listset (map cone ps)\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> normal_form F ` P[X]", "from this x_in"], ["proof (chain)\npicking this:\n  0 \\<in> sum_list ` listset (map cone ps)\n  x \\<in> sum_list ` listset (map cone qs)", "have \"[0, x] \\<in> listset ?ss\""], ["proof (prove)\nusing this:\n  0 \\<in> sum_list ` listset (map cone ps)\n  x \\<in> sum_list ` listset (map cone qs)\n\ngoal (1 subgoal):\n 1. [0, x]\n    \\<in> listset\n           [sum_list ` listset (map cone ps),\n            sum_list ` listset (map cone qs)]", "using refl"], ["proof (prove)\nusing this:\n  0 \\<in> sum_list ` listset (map cone ps)\n  x \\<in> sum_list ` listset (map cone qs)\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. [0, x]\n    \\<in> listset\n           [sum_list ` listset (map cone ps),\n            sum_list ` listset (map cone qs)]", "by (rule listset_doubletonI)"], ["proof (state)\nthis:\n  [0, x]\n  \\<in> listset\n         [sum_list ` listset (map cone ps),\n          sum_list ` listset (map cone qs)]\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> normal_form F ` P[X]", "with 2"], ["proof (chain)\npicking this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  [0, x]\n  \\<in> listset\n         [sum_list ` listset (map cone ps),\n          sum_list ` listset (map cone qs)]", "have \"sum_list [0, x] \\<in> T\""], ["proof (prove)\nusing this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  [0, x]\n  \\<in> listset\n         [sum_list ` listset (map cone ps),\n          sum_list ` listset (map cone qs)]\n\ngoal (1 subgoal):\n 1. sum_list [0, x] \\<in> T", "by (rule direct_decompD)"], ["proof (state)\nthis:\n  sum_list [0, x] \\<in> T\n\ngoal (2 subgoals):\n 1. x \\<in> T\n 2. x \\<in> normal_form F ` P[X]", "thus \"x \\<in> T\""], ["proof (prove)\nusing this:\n  sum_list [0, x] \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> T", "by simp"], ["proof (state)\nthis:\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "from assms(2)"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F", "have \"sum_list ` listset (map cone qs) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n\ngoal (1 subgoal):\n 1. sum_list ` listset (map cone qs) \\<subseteq> P[X]", "by (rule splits_wrt_image_sum_list_snd_subset)"], ["proof (state)\nthis:\n  sum_list ` listset (map cone qs) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "with x_in"], ["proof (chain)\npicking this:\n  x \\<in> sum_list ` listset (map cone qs)\n  sum_list ` listset (map cone qs) \\<subseteq> P[X]", "have \"x \\<in> P[X]\""], ["proof (prove)\nusing this:\n  x \\<in> sum_list ` listset (map cone qs)\n  sum_list ` listset (map cone qs) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> P[X]", ".."], ["proof (state)\nthis:\n  x \\<in> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "moreover"], ["proof (state)\nthis:\n  x \\<in> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "have \"\\<not> punit.is_red ?G x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB F) x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "assume \"punit.is_red ?G x\""], ["proof (state)\nthis:\n  punit.is_red (punit.reduced_GB F) x\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  punit.is_red (punit.reduced_GB F) x", "obtain g t where \"g \\<in> ?G\" and \"t \\<in> keys x\" and \"g \\<noteq> 0\" and adds: \"lpp g adds t\""], ["proof (prove)\nusing this:\n  punit.is_red (punit.reduced_GB F) x\n\ngoal (1 subgoal):\n 1. (\\<And>g t.\n        \\<lbrakk>g \\<in> punit.reduced_GB F; t \\<in> keys x; g \\<noteq> 0;\n         lpp g adds t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.is_red_addsE[simplified])"], ["proof (state)\nthis:\n  g \\<in> punit.reduced_GB F\n  t \\<in> keys x\n  g \\<noteq> 0\n  lpp g adds t\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "from assms(3) x_in this(2)"], ["proof (chain)\npicking this:\n  monomial_decomp qs\n  x \\<in> sum_list ` listset (map cone qs)\n  t \\<in> keys x", "obtain c h U where \"(h, U) \\<in> set qs\" and \"c \\<noteq> 0\"\n              and \"monomial c t \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  monomial_decomp qs\n  x \\<in> sum_list ` listset (map cone qs)\n  t \\<in> keys x\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set qs; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule monomial_decomp_sum_list_monomial_in_cone)"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n  c \\<noteq> (0::'a)\n  monomial c t \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "note this(3)"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "have \"monomial c t \\<in> ideal ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c t \\<in> ideal (punit.reduced_GB F)", "proof (rule punit.is_red_monomial_monomial_set_in_pmdl[simplified])"], ["proof (state)\ngoal (3 subgoals):\n 1. is_monomial (monomial c t)\n 2. is_monomial_set (punit.reduced_GB F)\n 3. punit.is_red (punit.reduced_GB F) (monomial c t)", "from \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "show \"is_monomial (monomial c t)\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. is_monomial (monomial c t)", "by (rule monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial (monomial c t)\n\ngoal (2 subgoals):\n 1. is_monomial_set (punit.reduced_GB F)\n 2. punit.is_red (punit.reduced_GB F) (monomial c t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. is_monomial_set (punit.reduced_GB F)\n 2. punit.is_red (punit.reduced_GB F) (monomial c t)", "from assms(1, 5, 4)"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]\n  is_monomial_set F", "show \"is_monomial_set ?G\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n  is_monomial_set F\n\ngoal (1 subgoal):\n 1. is_monomial_set (punit.reduced_GB F)", "by (rule reduced_GB_is_monomial_set_Polys)"], ["proof (state)\nthis:\n  is_monomial_set (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) (monomial c t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) (monomial c t)", "from \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "have \"t \\<in> keys (monomial c t)\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (monomial c t)", "by simp"], ["proof (state)\nthis:\n  t \\<in> keys (monomial c t)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) (monomial c t)", "with \\<open>g \\<in> ?G\\<close> \\<open>g \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  t \\<in> keys (monomial c t)", "show \"punit.is_red ?G (monomial c t)\""], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  t \\<in> keys (monomial c t)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) (monomial c t)", "using adds"], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  t \\<in> keys (monomial c t)\n  lpp g adds t\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) (monomial c t)", "by (rule punit.is_red_addsI[simplified])"], ["proof (state)\nthis:\n  punit.is_red (punit.reduced_GB F) (monomial c t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial c t \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  monomial c t \\<in> cone (h, U)\n  monomial c t \\<in> ideal (punit.reduced_GB F)", "have \"monomial c t \\<in> cone (h, U) \\<inter> ideal F\""], ["proof (prove)\nusing this:\n  monomial c t \\<in> cone (h, U)\n  monomial c t \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. monomial c t \\<in> cone (h, U) \\<inter> ideal F", "by (simp add: ideal_G)"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "from assms(2) \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F\n  (h, U) \\<in> set qs", "have \"\\<dots> = {0}\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<inter> ideal F = {0}", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h, U) \\<inter> ideal F = {0}\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  monomial c t \\<in> {0}", "have \"c = 0\""], ["proof (prove)\nusing this:\n  monomial c t \\<in> {0}\n\ngoal (1 subgoal):\n 1. c = (0::'a)", "by (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x \\<Longrightarrow> False", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  c = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> punit.is_red (punit.reduced_GB F) x\n\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> P[X]\n  \\<not> punit.is_red (punit.reduced_GB F) x", "show \"x \\<in> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  x \\<in> P[X]\n  \\<not> punit.is_red (punit.reduced_GB F) x\n\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "using assms(1, 5)"], ["proof (prove)\nusing this:\n  x \\<in> P[X]\n  \\<not> punit.is_red (punit.reduced_GB F) x\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> normal_form F ` P[X]", "by (simp add: image_normal_form_iff)"], ["proof (state)\nthis:\n  x \\<in> normal_form F ` P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> T \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "assume \"x \\<in> T \\<inter> normal_form F ` P[X]\""], ["proof (state)\nthis:\n  x \\<in> T \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "hence \"x \\<in> T\" and \"x \\<in> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  x \\<in> T \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> T &&& x \\<in> normal_form F ` P[X]", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> T\n  x \\<in> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "from this(2) assms(1, 5)"], ["proof (chain)\npicking this:\n  x \\<in> normal_form F ` P[X]\n  finite X\n  F \\<subseteq> P[X]", "have \"x \\<in> P[X]\" and irred: \"\\<not> punit.is_red ?G x\""], ["proof (prove)\nusing this:\n  x \\<in> normal_form F ` P[X]\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. x \\<in> P[X] &&& \\<not> punit.is_red (punit.reduced_GB F) x", "by (simp_all add: image_normal_form_iff)"], ["proof (state)\nthis:\n  x \\<in> P[X]\n  \\<not> punit.is_red (punit.reduced_GB F) x\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "from 2 \\<open>x \\<in> T\\<close>"], ["proof (chain)\npicking this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  x \\<in> T", "obtain xs where \"xs \\<in> listset ?ss\" and x: \"x = sum_list xs\""], ["proof (prove)\nusing this:\n  direct_decomp T\n   [sum_list ` listset (map cone ps), sum_list ` listset (map cone qs)]\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs \\<in> listset\n                           [sum_list ` listset (map cone ps),\n                            sum_list ` listset (map cone qs)];\n         x = sum_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule direct_decompE)"], ["proof (state)\nthis:\n  xs \\<in> listset\n            [sum_list ` listset (map cone ps),\n             sum_list ` listset (map cone qs)]\n  x = sum_list xs\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "from this(1)"], ["proof (chain)\npicking this:\n  xs \\<in> listset\n            [sum_list ` listset (map cone ps),\n             sum_list ` listset (map cone qs)]", "obtain p q where p: \"p \\<in> sum_list ` listset (map cone ps)\"\n          and q: \"q \\<in> sum_list ` listset (map cone qs)\" and xs: \"xs = [p, q]\""], ["proof (prove)\nusing this:\n  xs \\<in> listset\n            [sum_list ` listset (map cone ps),\n             sum_list ` listset (map cone qs)]\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>p \\<in> sum_list ` listset (map cone ps);\n         q \\<in> sum_list ` listset (map cone qs); xs = [p, q]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  p \\<in> sum_list ` listset (map cone ps)\n  q \\<in> sum_list ` listset (map cone qs)\n  xs = [p, q]\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "have \"x = p + q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = p + q", "by (simp add: x xs)"], ["proof (state)\nthis:\n  x = p + q\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "from p sub"], ["proof (chain)\npicking this:\n  p \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F", "have \"p \\<in> ideal F\""], ["proof (prove)\nusing this:\n  p \\<in> sum_list ` listset (map cone ps)\n  sum_list ` listset (map cone ps) \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. p \\<in> ideal F", ".."], ["proof (state)\nthis:\n  p \\<in> ideal F\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "have \"p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "assume \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "hence \"keys p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys p \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  keys p \\<noteq> {}", "obtain t where \"t \\<in> keys p\""], ["proof (prove)\nusing this:\n  keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>t. t \\<in> keys p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "from assms(4) \\<open>p \\<in> ideal F\\<close> \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  is_monomial_set F\n  p \\<in> ideal F\n  t \\<in> keys p", "have 3: \"monomial c t \\<in> ideal F\" for c"], ["proof (prove)\nusing this:\n  is_monomial_set F\n  p \\<in> ideal F\n  t \\<in> keys p\n\ngoal (1 subgoal):\n 1. monomial c t \\<in> ideal F", "by (rule punit.monomial_pmdl_field[simplified])"], ["proof (state)\nthis:\n  monomial ?c14 t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"t \\<notin> keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> keys q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow> False", "assume \"t \\<in> keys q\""], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow> False", "with assms(3) q"], ["proof (chain)\npicking this:\n  monomial_decomp qs\n  q \\<in> sum_list ` listset (map cone qs)\n  t \\<in> keys q", "obtain c h U where \"(h, U) \\<in> set qs\" and \"c \\<noteq> 0\"\n              and \"monomial c t \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  monomial_decomp qs\n  q \\<in> sum_list ` listset (map cone qs)\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>h U c.\n        \\<lbrakk>(h, U) \\<in> set qs; c \\<noteq> (0::'a);\n         monomial c t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule monomial_decomp_sum_list_monomial_in_cone)"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n  c \\<noteq> (0::'a)\n  monomial c t \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow> False", "from this(3) 3"], ["proof (chain)\npicking this:\n  monomial c t \\<in> cone (h, U)\n  monomial ?c14 t \\<in> ideal F", "have \"monomial c t \\<in> cone (h, U) \\<inter> ideal F\""], ["proof (prove)\nusing this:\n  monomial c t \\<in> cone (h, U)\n  monomial ?c14 t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. monomial c t \\<in> cone (h, U) \\<inter> ideal F", "by simp"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  monomial c t \\<in> cone (h, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow> False", "from assms(2) \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  splits_wrt (ps, qs) T F\n  (h, U) \\<in> set qs", "have \"\\<dots> = {0}\""], ["proof (prove)\nusing this:\n  splits_wrt (ps, qs) T F\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<inter> ideal F = {0}", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h, U) \\<inter> ideal F = {0}\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  monomial c t \\<in> {0}", "have \"c = 0\""], ["proof (prove)\nusing this:\n  monomial c t \\<in> {0}\n\ngoal (1 subgoal):\n 1. c = (0::'a)", "by (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<in> keys q \\<Longrightarrow> False", "with \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  c = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  c = (0::'a)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>t \\<in> keys p\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys p\n  t \\<notin> keys q", "have \"t \\<in> keys x\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys x", "unfolding \\<open>x = p + q\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  t \\<notin> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys (p + q)", "by (rule in_keys_plusI1)"], ["proof (state)\nthis:\n  t \\<in> keys x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"punit.is_red ?G x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "note G_is_GB"], ["proof (state)\nthis:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "moreover"], ["proof (state)\nthis:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "from 3"], ["proof (chain)\npicking this:\n  monomial ?c14 t \\<in> ideal F", "have \"monomial 1 t \\<in> ideal ?G\""], ["proof (prove)\nusing this:\n  monomial ?c14 t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. monomial (1::'a) t \\<in> ideal (punit.reduced_GB F)", "by (simp only: ideal_G)"], ["proof (state)\nthis:\n  monomial (1::'a) t \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "moreover"], ["proof (state)\nthis:\n  monomial (1::'a) t \\<in> ideal (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "have \"monomial (1::'a) t \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) t \\<noteq> 0", "by (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  monomial (1::'a) t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "ultimately"], ["proof (chain)\npicking this:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n  monomial (1::'a) t \\<in> ideal (punit.reduced_GB F)\n  monomial (1::'a) t \\<noteq> 0", "obtain g where \"g \\<in> ?G\" and \"g \\<noteq> 0\"\n              and \"lpp g adds lpp (monomial (1::'a) t)\""], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis (punit.reduced_GB F)\n  monomial (1::'a) t \\<in> ideal (punit.reduced_GB F)\n  monomial (1::'a) t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> punit.reduced_GB F; g \\<noteq> 0;\n         lpp g adds lpp (monomial (1::'a) t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.GB_adds_lt[simplified])"], ["proof (state)\nthis:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  lpp g adds lpp (monomial (1::'a) t)\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "from this(3)"], ["proof (chain)\npicking this:\n  lpp g adds lpp (monomial (1::'a) t)", "have \"lpp g adds t\""], ["proof (prove)\nusing this:\n  lpp g adds lpp (monomial (1::'a) t)\n\ngoal (1 subgoal):\n 1. lpp g adds t", "by (simp add: punit.lt_monomial)"], ["proof (state)\nthis:\n  lpp g adds t\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "with \\<open>g \\<in> ?G\\<close> \\<open>g \\<noteq> 0\\<close> \\<open>t \\<in> keys x\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  t \\<in> keys x\n  lpp g adds t", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  g \\<noteq> 0\n  t \\<in> keys x\n  lpp g adds t\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB F) x", "by (rule punit.is_red_addsI[simplified])"], ["proof (state)\nthis:\n  punit.is_red (punit.reduced_GB F) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  punit.is_red (punit.reduced_GB F) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "with irred"], ["proof (chain)\npicking this:\n  \\<not> punit.is_red (punit.reduced_GB F) x\n  punit.is_red (punit.reduced_GB F) x", "show False"], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB F) x\n  punit.is_red (punit.reduced_GB F) x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. x \\<in> T \\<inter> normal_form F ` P[X] \\<Longrightarrow>\n    x \\<in> sum_list ` listset (map cone qs)", "with q"], ["proof (chain)\npicking this:\n  q \\<in> sum_list ` listset (map cone qs)\n  p = 0", "show \"x \\<in> sum_list ` listset (map cone qs)\""], ["proof (prove)\nusing this:\n  q \\<in> sum_list ` listset (map cone qs)\n  p = 0\n\ngoal (1 subgoal):\n 1. x \\<in> sum_list ` listset (map cone qs)", "by (simp add: x xs)"], ["proof (state)\nthis:\n  x \\<in> sum_list ` listset (map cone qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> sum_list ` listset (map cone qs)) =\n  (x \\<in> T \\<inter> normal_form F ` P[X])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list ` listset (map cone qs) = T \\<inter> normal_form F ` P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone_decomp (T \\<inter> normal_form F ` P[X]) qs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quot_monomial_ideal_monomial:\n  \"ideal (monomial 1 ` S) \\<div> monomial 1 (Poly_Mapping.single (x::'x) (1::nat)) =\n    ideal (monomial (1::'a::comm_ring_1) ` (\\<lambda>s. s - Poly_Mapping.single x 1) ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (monomial (1::'a) ` S) \\<div> monomial (1::'a) (monomial 1 x) =\n    ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> ideal (monomial (1::'a) ` S) \\<div>\n                 monomial (1::'a) (monomial 1 x)) =\n       (xa \\<in> ideal\n                  (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "let ?x = \"Poly_Mapping.single x (1::nat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> ideal (monomial (1::'a) ` S) \\<div>\n                 monomial (1::'a) (monomial 1 x)) =\n       (xa \\<in> ideal\n                  (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> ideal (monomial (1::'a) ` S) \\<div>\n                 monomial (1::'a) (monomial 1 x)) =\n       (xa \\<in> ideal\n                  (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "have \"a \\<in> ideal (monomial 1 ` S) \\<div> monomial 1 ?x \\<longleftrightarrow> punit.monom_mult 1 ?x a \\<in> ideal (monomial (1::'a) ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> ideal (monomial (1::'a) ` S) \\<div>\n             monomial (1::'a) (monomial 1 x)) =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) a\n     \\<in> ideal (monomial (1::'a) ` S))", "by (simp only: quot_set_iff times_monomial_left)"], ["proof (state)\nthis:\n  (a \\<in> ideal (monomial (1::'a) ` S) \\<div>\n           monomial (1::'a) (monomial 1 x)) =\n  (local.punit.monom_mult (1::'a) (monomial 1 x) a\n   \\<in> ideal (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> ideal (monomial (1::'a) ` S) \\<div>\n                 monomial (1::'a) (monomial 1 x)) =\n       (xa \\<in> ideal\n                  (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "also"], ["proof (state)\nthis:\n  (a \\<in> ideal (monomial (1::'a) ` S) \\<div>\n           monomial (1::'a) (monomial 1 x)) =\n  (local.punit.monom_mult (1::'a) (monomial 1 x) a\n   \\<in> ideal (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> ideal (monomial (1::'a) ` S) \\<div>\n                 monomial (1::'a) (monomial 1 x)) =\n       (xa \\<in> ideal\n                  (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "have \"\\<dots> \\<longleftrightarrow> a \\<in> ideal (monomial 1 ` (\\<lambda>s. s - ?x) ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) a\n     \\<in> ideal (monomial (1::'a) ` S)) =\n    (a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "proof (induct a rule: poly_mapping_plus_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) 0\n     \\<in> ideal (monomial (1::'a) ` S)) =\n    (0 \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        (local.punit.monom_mult (1::'a) (monomial 1 x) p\n         \\<in> ideal (monomial (1::'a) ` S)) =\n        (p \\<in> ideal\n                  (monomial (1::'a) `\n                   (\\<lambda>s. s - monomial 1 x) ` S))\\<rbrakk>\n       \\<Longrightarrow> (local.punit.monom_mult (1::'a) (monomial 1 x)\n                           (monomial c t + p)\n                          \\<in> ideal (monomial (1::'a) ` S)) =\n                         (monomial c t + p\n                          \\<in> ideal\n                                 (monomial (1::'a) `\n                                  (\\<lambda>s. s - monomial 1 x) ` S))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) 0\n     \\<in> ideal (monomial (1::'a) ` S)) =\n    (0 \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n 2. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        (local.punit.monom_mult (1::'a) (monomial 1 x) p\n         \\<in> ideal (monomial (1::'a) ` S)) =\n        (p \\<in> ideal\n                  (monomial (1::'a) `\n                   (\\<lambda>s. s - monomial 1 x) ` S))\\<rbrakk>\n       \\<Longrightarrow> (local.punit.monom_mult (1::'a) (monomial 1 x)\n                           (monomial c t + p)\n                          \\<in> ideal (monomial (1::'a) ` S)) =\n                         (monomial c t + p\n                          \\<in> ideal\n                                 (monomial (1::'a) `\n                                  (\\<lambda>s. s - monomial 1 x) ` S))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) 0\n     \\<in> ideal (monomial (1::'a) ` S)) =\n    (0 \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "by (simp add: ideal.span_zero)"], ["proof (state)\nthis:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) 0\n   \\<in> ideal (monomial (1::'a) ` S)) =\n  (0 \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        (local.punit.monom_mult (1::'a) (monomial 1 x) p\n         \\<in> ideal (monomial (1::'a) ` S)) =\n        (p \\<in> ideal\n                  (monomial (1::'a) `\n                   (\\<lambda>s. s - monomial 1 x) ` S))\\<rbrakk>\n       \\<Longrightarrow> (local.punit.monom_mult (1::'a) (monomial 1 x)\n                           (monomial c t + p)\n                          \\<in> ideal (monomial (1::'a) ` S)) =\n                         (monomial c t + p\n                          \\<in> ideal\n                                 (monomial (1::'a) `\n                                  (\\<lambda>s. s - monomial 1 x) ` S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        (local.punit.monom_mult (1::'a) (monomial 1 x) p\n         \\<in> ideal (monomial (1::'a) ` S)) =\n        (p \\<in> ideal\n                  (monomial (1::'a) `\n                   (\\<lambda>s. s - monomial 1 x) ` S))\\<rbrakk>\n       \\<Longrightarrow> (local.punit.monom_mult (1::'a) (monomial 1 x)\n                           (monomial c t + p)\n                          \\<in> ideal (monomial (1::'a) ` S)) =\n                         (monomial c t + p\n                          \\<in> ideal\n                                 (monomial (1::'a) `\n                                  (\\<lambda>s. s - monomial 1 x) ` S))", "case (2 a c t)"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  t \\<notin> keys a\n  (local.punit.monom_mult (1::'a) (monomial 1 x) a\n   \\<in> ideal (monomial (1::'a) ` S)) =\n  (a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        (local.punit.monom_mult (1::'a) (monomial 1 x) p\n         \\<in> ideal (monomial (1::'a) ` S)) =\n        (p \\<in> ideal\n                  (monomial (1::'a) `\n                   (\\<lambda>s. s - monomial 1 x) ` S))\\<rbrakk>\n       \\<Longrightarrow> (local.punit.monom_mult (1::'a) (monomial 1 x)\n                           (monomial c t + p)\n                          \\<in> ideal (monomial (1::'a) ` S)) =\n                         (monomial c t + p\n                          \\<in> ideal\n                                 (monomial (1::'a) `\n                                  (\\<lambda>s. s - monomial 1 x) ` S))", "let ?S = \"monomial (1::'a) ` (\\<lambda>s. s - ?x) ` S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p c t.\n       \\<lbrakk>c \\<noteq> (0::'a); t \\<notin> keys p;\n        (local.punit.monom_mult (1::'a) (monomial 1 x) p\n         \\<in> ideal (monomial (1::'a) ` S)) =\n        (p \\<in> ideal\n                  (monomial (1::'a) `\n                   (\\<lambda>s. s - monomial 1 x) ` S))\\<rbrakk>\n       \\<Longrightarrow> (local.punit.monom_mult (1::'a) (monomial 1 x)\n                           (monomial c t + p)\n                          \\<in> ideal (monomial (1::'a) ` S)) =\n                         (monomial c t + p\n                          \\<in> ideal\n                                 (monomial (1::'a) `\n                                  (\\<lambda>s. s - monomial 1 x) ` S))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n     \\<in> ideal (monomial (1::'a) ` S)) =\n    (monomial c t + a\n     \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "assume 0: \"punit.monom_mult 1 ?x (monomial c t + a) \\<in> ideal (monomial 1 ` S)\""], ["proof (state)\nthis:\n  local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "have \"is_monomial_set (monomial (1::'a) ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial_set (monomial (1::'a) ` S)", "by (auto intro!: is_monomial_setI monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "moreover"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from 0"], ["proof (chain)\npicking this:\n  local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n  \\<in> ideal (monomial (1::'a) ` S)", "have 1: \"monomial c (?x + t) + punit.monom_mult 1 ?x a \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c (monomial 1 x + t) +\n    local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "by (simp add: punit.monom_mult_monomial punit.monom_mult_dist_right)"], ["proof (state)\nthis:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "moreover"], ["proof (state)\nthis:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "have \"?x + t \\<in> keys (monomial c (?x + t) + punit.monom_mult 1 ?x a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (monomial c (monomial 1 x + t) +\n            local.punit.monom_mult (1::'a) (monomial 1 x) a)", "proof (intro in_keys_plusI1 notI)"], ["proof (state)\ngoal (2 subgoals):\n 1. monomial 1 x + t \\<in> keys (monomial c (monomial 1 x + t))\n 2. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "from 2(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "show \"?x + t \\<in> keys (monomial c (?x + t))\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. monomial 1 x + t \\<in> keys (monomial c (monomial 1 x + t))", "by simp"], ["proof (state)\nthis:\n  monomial 1 x + t \\<in> keys (monomial c (monomial 1 x + t))\n\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "assume \"?x + t \\<in> keys (punit.monom_mult 1 ?x a)\""], ["proof (state)\nthis:\n  monomial 1 x + t\n  \\<in> keys (local.punit.monom_mult (1::'a) (monomial 1 x) a)\n\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  monomial 1 x + t\n  \\<in> keys (local.punit.monom_mult (1::'a) (monomial 1 x) a)\n\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "have \"\\<dots> \\<subseteq> (+) ?x ` keys a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (local.punit.monom_mult (1::'a) (monomial 1 x) a)\n    \\<subseteq> (+) (monomial 1 x) ` keys a", "by (rule punit.keys_monom_mult_subset[simplified])"], ["proof (state)\nthis:\n  keys (local.punit.monom_mult (1::'a) (monomial 1 x) a)\n  \\<subseteq> (+) (monomial 1 x) ` keys a\n\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  monomial 1 x + t \\<in> (+) (monomial 1 x) ` keys a", "obtain s where \"s \\<in> keys a\" and \"?x + t = ?x + s\""], ["proof (prove)\nusing this:\n  monomial 1 x + t \\<in> (+) (monomial 1 x) ` keys a\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys a;\n         monomial 1 x + t = monomial 1 x + s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys a\n  monomial 1 x + t = monomial 1 x + s\n\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "from this(2)"], ["proof (chain)\npicking this:\n  monomial 1 x + t = monomial 1 x + s", "have \"t = s\""], ["proof (prove)\nusing this:\n  monomial 1 x + t = monomial 1 x + s\n\ngoal (1 subgoal):\n 1. t = s", "by simp"], ["proof (state)\nthis:\n  t = s\n\ngoal (1 subgoal):\n 1. monomial 1 x + t\n    \\<in> keys\n           (local.punit.monom_mult (1::'a) (monomial 1 x)\n             a) \\<Longrightarrow>\n    False", "with \\<open>s \\<in> keys a\\<close> 2(2)"], ["proof (chain)\npicking this:\n  s \\<in> keys a\n  t \\<notin> keys a\n  t = s", "show False"], ["proof (prove)\nusing this:\n  s \\<in> keys a\n  t \\<notin> keys a\n  t = s\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial 1 x + t\n  \\<in> keys\n         (monomial c (monomial 1 x + t) +\n          local.punit.monom_mult (1::'a) (monomial 1 x) a)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "ultimately"], ["proof (chain)\npicking this:\n  is_monomial_set (monomial (1::'a) ` S)\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n  monomial 1 x + t\n  \\<in> keys\n         (monomial c (monomial 1 x + t) +\n          local.punit.monom_mult (1::'a) (monomial 1 x) a)", "obtain f where \"f \\<in> monomial (1::'a) ` S\" and adds: \"lpp f adds ?x + t\""], ["proof (prove)\nusing this:\n  is_monomial_set (monomial (1::'a) ` S)\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n  monomial 1 x + t\n  \\<in> keys\n         (monomial c (monomial 1 x + t) +\n          local.punit.monom_mult (1::'a) (monomial 1 x) a)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> monomial (1::'a) ` S;\n         lpp f adds monomial 1 x + t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.keys_monomial_pmdl[simplified])"], ["proof (state)\nthis:\n  f \\<in> monomial (1::'a) ` S\n  lpp f adds monomial 1 x + t\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from this(1)"], ["proof (chain)\npicking this:\n  f \\<in> monomial (1::'a) ` S", "obtain s where \"s \\<in> S\" and f: \"f = monomial 1 s\""], ["proof (prove)\nusing this:\n  f \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; f = monomial (1::'a) s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> S\n  f = monomial (1::'a) s\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from adds"], ["proof (chain)\npicking this:\n  lpp f adds monomial 1 x + t", "have \"s adds ?x + t\""], ["proof (prove)\nusing this:\n  lpp f adds monomial 1 x + t\n\ngoal (1 subgoal):\n 1. s adds monomial 1 x + t", "by (simp add: f punit.lt_monomial)"], ["proof (state)\nthis:\n  s adds monomial 1 x + t\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "hence \"s - ?x adds t\""], ["proof (prove)\nusing this:\n  s adds monomial 1 x + t\n\ngoal (1 subgoal):\n 1. s - monomial 1 x adds t", "by (metis (no_types, lifting) add_minus_2 adds_minus adds_triv_right plus_minus_assoc_pm_nat_1)"], ["proof (state)\nthis:\n  s - monomial 1 x adds t\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "then"], ["proof (chain)\npicking this:\n  s - monomial 1 x adds t", "obtain s' where t: \"t = (s - ?x) + s'\""], ["proof (prove)\nusing this:\n  s - monomial 1 x adds t\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        t = s - monomial 1 x + s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule addsE)"], ["proof (state)\nthis:\n  t = s - monomial 1 x + s'\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"monomial 1 (s - ?x) \\<in> ?S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (s - monomial 1 x)\n    \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S", "by (intro imageI)"], ["proof (state)\nthis:\n  monomial (1::'a) (s - monomial 1 x)\n  \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "also"], ["proof (state)\nthis:\n  monomial (1::'a) (s - monomial 1 x)\n  \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "have \"\\<dots> \\<subseteq> ideal ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S\n    \\<subseteq> ideal\n                 (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (rule ideal.span_superset)"], ["proof (state)\nthis:\n  monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S\n  \\<subseteq> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "finally"], ["proof (chain)\npicking this:\n  monomial (1::'a) (s - monomial 1 x)\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "have \"monomial c s' * monomial 1 (s - ?x) \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (s - monomial 1 x)\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c s' * monomial (1::'a) (s - monomial 1 x)\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  monomial c s' * monomial (1::'a) (s - monomial 1 x)\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "hence \"monomial c t \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  monomial c s' * monomial (1::'a) (s - monomial 1 x)\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (simp add: times_monomial_monomial t add.commute)"], ["proof (state)\nthis:\n  monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "moreover"], ["proof (state)\nthis:\n  monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "have \"a \\<in> ideal ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "from \\<open>f \\<in> monomial 1 ` S\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> monomial (1::'a) ` S", "have \"f \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  f \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. f \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  f \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "hence \"punit.monom_mult c (?x + t - s) f \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  f \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult c (monomial 1 x + t - s) f\n    \\<in> ideal (monomial (1::'a) ` S)", "by (rule punit.pmdl_closed_monom_mult[simplified])"], ["proof (state)\nthis:\n  local.punit.monom_mult c (monomial 1 x + t - s) f\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "with \\<open>s adds ?x + t\\<close>"], ["proof (chain)\npicking this:\n  s adds monomial 1 x + t\n  local.punit.monom_mult c (monomial 1 x + t - s) f\n  \\<in> ideal (monomial (1::'a) ` S)", "have \"monomial c (?x + t) \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  s adds monomial 1 x + t\n  local.punit.monom_mult c (monomial 1 x + t - s) f\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)", "by (simp add: f punit.monom_mult_monomial adds_minus)"], ["proof (state)\nthis:\n  monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "with 1"], ["proof (chain)\npicking this:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n  monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)", "have \"monomial c (?x + t) + punit.monom_mult 1 ?x a - monomial c (?x + t) \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n  monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c (monomial 1 x + t) +\n    local.punit.monom_mult (1::'a) (monomial 1 x) a -\n    monomial c (monomial 1 x + t)\n    \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_diff)"], ["proof (state)\nthis:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a -\n  monomial c (monomial 1 x + t)\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a -\n  monomial c (monomial 1 x + t)\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (simp add: 2(3) del: One_nat_def)"], ["proof (state)\nthis:\n  a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (2 subgoals):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S) \\<Longrightarrow>\n    monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n 2. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "ultimately"], ["proof (chain)\npicking this:\n  monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "show \"monomial c t + a \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (rule ideal.span_add)"], ["proof (state)\nthis:\n  monomial c t + a\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "have \"is_monomial_set ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial_set (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (auto intro!: is_monomial_setI monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "moreover"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "assume 1: \"monomial c t + a \\<in> ideal ?S\""], ["proof (state)\nthis:\n  monomial c t + a\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "moreover"], ["proof (state)\nthis:\n  monomial c t + a\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from _ 2(2)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  t \\<notin> keys a", "have \"t \\<in> keys (monomial c t + a)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  t \\<notin> keys a\n\ngoal (1 subgoal):\n 1. t \\<in> keys (monomial c t + a)", "proof (rule in_keys_plusI1)"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys (monomial c t)", "from 2(1)"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)", "show \"t \\<in> keys (monomial c t)\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<in> keys (monomial c t)", "by simp"], ["proof (state)\nthis:\n  t \\<in> keys (monomial c t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> keys (monomial c t + a)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "ultimately"], ["proof (chain)\npicking this:\n  is_monomial_set (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  monomial c t + a\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  t \\<in> keys (monomial c t + a)", "obtain f where \"f \\<in> ?S\" and adds: \"lpp f adds t\""], ["proof (prove)\nusing this:\n  is_monomial_set (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  monomial c t + a\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  t \\<in> keys (monomial c t + a)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> monomial (1::'a) `\n                         (\\<lambda>s. s - monomial 1 x) ` S;\n         lpp f adds t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.keys_monomial_pmdl[simplified])"], ["proof (state)\nthis:\n  f \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S\n  lpp f adds t\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from this(1)"], ["proof (chain)\npicking this:\n  f \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S", "obtain s where \"s \\<in> S\" and f: \"f = monomial 1 (s - ?x)\""], ["proof (prove)\nusing this:\n  f \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; f = monomial (1::'a) (s - monomial 1 x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> S\n  f = monomial (1::'a) (s - monomial 1 x)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from adds"], ["proof (chain)\npicking this:\n  lpp f adds t", "have \"s - ?x adds t\""], ["proof (prove)\nusing this:\n  lpp f adds t\n\ngoal (1 subgoal):\n 1. s - monomial 1 x adds t", "by (simp add: f punit.lt_monomial)"], ["proof (state)\nthis:\n  s - monomial 1 x adds t\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "hence \"s adds ?x + t\""], ["proof (prove)\nusing this:\n  s - monomial 1 x adds t\n\ngoal (1 subgoal):\n 1. s adds monomial 1 x + t", "by (auto simp: adds_poly_mapping le_fun_def lookup_add lookup_minus lookup_single when_def\n            split: if_splits)"], ["proof (state)\nthis:\n  s adds monomial 1 x + t\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "then"], ["proof (chain)\npicking this:\n  s adds monomial 1 x + t", "obtain s' where t: \"?x + t = s + s'\""], ["proof (prove)\nusing this:\n  s adds monomial 1 x + t\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        monomial 1 x + t = s + s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule addsE)"], ["proof (state)\nthis:\n  monomial 1 x + t = s + s'\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "from \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"monomial 1 s \\<in> monomial 1 ` S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. monomial (1::'b) s \\<in> monomial (1::'b) ` S", "by (rule imageI)"], ["proof (state)\nthis:\n  monomial (1::?'b15) s \\<in> monomial (1::?'b15) ` S\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "also"], ["proof (state)\nthis:\n  monomial (1::?'b15) s \\<in> monomial (1::?'b15) ` S\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "have \"\\<dots> \\<subseteq> ideal (monomial 1 ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'b) ` S \\<subseteq> ideal (monomial (1::'b) ` S)", "by (rule ideal.span_superset)"], ["proof (state)\nthis:\n  monomial (1::?'b16) ` S \\<subseteq> ideal (monomial (1::?'b16) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "finally"], ["proof (chain)\npicking this:\n  monomial (1::?'b17) s \\<in> ideal (monomial (1::?'b17) ` S)", "have \"monomial c s' * monomial 1 s \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial (1::?'b17) s \\<in> ideal (monomial (1::?'b17) ` S)\n\ngoal (1 subgoal):\n 1. monomial c s' * monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  monomial c s' * monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "hence \"monomial c (?x + t) \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial c s' * monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)", "by (simp only: t) (simp add: times_monomial_monomial add.commute)"], ["proof (state)\nthis:\n  monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "moreover"], ["proof (state)\nthis:\n  monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "have \"punit.monom_mult 1 ?x a \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "from \\<open>f \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S", "have \"f \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  f \\<in> monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S\n\ngoal (1 subgoal):\n 1. f \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  f \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "hence \"punit.monom_mult c (t - (s - ?x)) f \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  f \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult c (t - (s - monomial 1 x)) f\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (rule punit.pmdl_closed_monom_mult[simplified])"], ["proof (state)\nthis:\n  local.punit.monom_mult c (t - (s - monomial 1 x)) f\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "with \\<open>s - ?x adds t\\<close>"], ["proof (chain)\npicking this:\n  s - monomial 1 x adds t\n  local.punit.monom_mult c (t - (s - monomial 1 x)) f\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "have \"monomial c t \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  s - monomial 1 x adds t\n  local.punit.monom_mult c (t - (s - monomial 1 x)) f\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (simp add: f punit.monom_mult_monomial adds_minus)"], ["proof (state)\nthis:\n  monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "with 1"], ["proof (chain)\npicking this:\n  monomial c t + a\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "have \"monomial c t + a - monomial c t \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  monomial c t + a\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n  monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a - monomial c t\n    \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (rule ideal.span_diff)"], ["proof (state)\nthis:\n  monomial c t + a - monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  monomial c t + a - monomial c t\n  \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "by (simp add: 2(3) del: One_nat_def)"], ["proof (state)\nthis:\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "ultimately"], ["proof (chain)\npicking this:\n  monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)", "have \"monomial c (?x + t) + punit.monom_mult 1 ?x a \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial c (monomial 1 x + t) \\<in> ideal (monomial (1::'a) ` S)\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c (monomial 1 x + t) +\n    local.punit.monom_mult (1::'a) (monomial 1 x) a\n    \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_add)"], ["proof (state)\nthis:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial c t + a\n    \\<in> ideal\n           (monomial (1::'a) `\n            (\\<lambda>s. s - monomial 1 x) ` S) \\<Longrightarrow>\n    local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "thus \"punit.monom_mult 1 ?x (monomial c t + a) \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial c (monomial 1 x + t) +\n  local.punit.monom_mult (1::'a) (monomial 1 x) a\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n    \\<in> ideal (monomial (1::'a) ` S)", "by (simp add: punit.monom_mult_monomial punit.monom_mult_dist_right)"], ["proof (state)\nthis:\n  local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n  \\<in> ideal (monomial (1::'a) ` S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) (monomial c t + a)\n   \\<in> ideal (monomial (1::'a) ` S)) =\n  (monomial c t + a\n   \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) a\n   \\<in> ideal (monomial (1::'a) ` S)) =\n  (a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> ideal (monomial (1::'a) ` S) \\<div>\n                 monomial (1::'a) (monomial 1 x)) =\n       (xa \\<in> ideal\n                  (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "finally"], ["proof (chain)\npicking this:\n  (a \\<in> ideal (monomial (1::'a) ` S) \\<div>\n           monomial (1::'a) (monomial 1 x)) =\n  (a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "show \"a \\<in> ideal (monomial 1 ` S) \\<div> monomial 1 ?x \\<longleftrightarrow> a \\<in> ideal (monomial 1 ` (\\<lambda>s. s - ?x) ` S)\""], ["proof (prove)\nusing this:\n  (a \\<in> ideal (monomial (1::'a) ` S) \\<div>\n           monomial (1::'a) (monomial 1 x)) =\n  (a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n\ngoal (1 subgoal):\n 1. (a \\<in> ideal (monomial (1::'a) ` S) \\<div>\n             monomial (1::'a) (monomial 1 x)) =\n    (a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))", "."], ["proof (state)\nthis:\n  (a \\<in> ideal (monomial (1::'a) ` S) \\<div>\n           monomial (1::'a) (monomial 1 x)) =\n  (a \\<in> ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lem_4_2_1:\n  assumes \"ideal F \\<div> monomial 1 t = ideal (monomial (1::'a::comm_ring_1) ` S)\"\n  shows \"cone (monomial 1 t, U) \\<subseteq> ideal F \\<longleftrightarrow> 0 \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cone (monomial (1::'a) t, U) \\<subseteq> ideal F) = (0 \\<in> S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "have \"monomial 1 t \\<in> cone (monomial (1::'a) t, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)", "by (rule tip_in_cone)"], ["proof (state)\nthis:\n  monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "also"], ["proof (state)\nthis:\n  monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "assume \"cone (monomial 1 t, U) \\<subseteq> ideal F\""], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<subseteq> ideal F\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "finally"], ["proof (chain)\npicking this:\n  monomial (1::'a) t \\<in> ideal F", "have *: \"monomial 1 t * 1 \\<in> ideal F\""], ["proof (prove)\nusing this:\n  monomial (1::'a) t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. monomial (1::'a) t * 1 \\<in> ideal F", "by simp"], ["proof (state)\nthis:\n  monomial (1::'a) t * 1 \\<in> ideal F\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "have \"is_monomial_set (monomial (1::'a) ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial_set (monomial (1::'a) ` S)", "by (auto intro!: is_monomial_setI monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "moreover"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "from *"], ["proof (chain)\npicking this:\n  monomial (1::'a) t * 1 \\<in> ideal F", "have \"1 \\<in> ideal (monomial (1::'a) ` S)\""], ["proof (prove)\nusing this:\n  monomial (1::'a) t * 1 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal (monomial (1::'a) ` S)", "by (simp only: quot_set_iff flip: assms)"], ["proof (state)\nthis:\n  1 \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "moreover"], ["proof (state)\nthis:\n  1 \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "have \"0 \\<in> keys (1::_ \\<Rightarrow>\\<^sub>0 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<in> keys 1", "by simp"], ["proof (state)\nthis:\n  (0::?'b15) \\<in> keys 1\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "ultimately"], ["proof (chain)\npicking this:\n  is_monomial_set (monomial (1::'a) ` S)\n  1 \\<in> ideal (monomial (1::'a) ` S)\n  (0::?'b15) \\<in> keys 1", "obtain g where \"g \\<in> monomial (1::'a) ` S\" and adds: \"lpp g adds 0\""], ["proof (prove)\nusing this:\n  is_monomial_set (monomial (1::'a) ` S)\n  1 \\<in> ideal (monomial (1::'a) ` S)\n  (0::?'b15) \\<in> keys 1\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> monomial (1::'a) ` S; lpp g adds 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.keys_monomial_pmdl[simplified])"], ["proof (state)\nthis:\n  g \\<in> monomial (1::'a) ` S\n  lpp g adds 0\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "from this(1)"], ["proof (chain)\npicking this:\n  g \\<in> monomial (1::'a) ` S", "obtain s where \"s \\<in> S\" and g: \"g = monomial 1 s\""], ["proof (prove)\nusing this:\n  g \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; g = monomial (1::'a) s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> S\n  g = monomial (1::'a) s\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "from adds"], ["proof (chain)\npicking this:\n  lpp g adds 0", "have \"s adds 0\""], ["proof (prove)\nusing this:\n  lpp g adds 0\n\ngoal (1 subgoal):\n 1. s adds 0", "by (simp add: g punit.lt_monomial flip: single_one)"], ["proof (state)\nthis:\n  s adds 0\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F \\<Longrightarrow>\n    0 \\<in> S\n 2. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "with \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s adds 0", "show \"0 \\<in> S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s adds 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> S", "by (simp only: adds_zero)"], ["proof (state)\nthis:\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "assume \"0 \\<in> S\""], ["proof (state)\nthis:\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "hence \"monomial 1 0 \\<in> monomial (1::'a) ` S\""], ["proof (prove)\nusing this:\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. monomial (1::'a) 0 \\<in> monomial (1::'a) ` S", "by (rule imageI)"], ["proof (state)\nthis:\n  monomial (1::'a) 0 \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "hence \"1 \\<in> ideal (monomial (1::'a) ` S)\""], ["proof (prove)\nusing this:\n  monomial (1::'a) 0 \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal (monomial (1::'a) ` S)", "unfolding single_one"], ["proof (prove)\nusing this:\n  1 \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  1 \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "hence eq: \"ideal F \\<div> monomial 1 t = UNIV\" (is \"_ \\<div> ?t = _\")"], ["proof (prove)\nusing this:\n  1 \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) t = UNIV", "by (simp only: assms ideal_eq_UNIV_iff_contains_one)"], ["proof (state)\nthis:\n  ideal F \\<div> monomial (1::'a) t = UNIV\n\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "show \"cone (monomial 1 t, U) \\<subseteq> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (monomial (1::'a) t, U) \\<Longrightarrow>\n       x \\<in> ideal F", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (monomial (1::'a) t, U) \\<Longrightarrow>\n       x \\<in> ideal F", "assume \"a \\<in> cone (?t, U)\""], ["proof (state)\nthis:\n  a \\<in> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (monomial (1::'a) t, U) \\<Longrightarrow>\n       x \\<in> ideal F", "then"], ["proof (chain)\npicking this:\n  a \\<in> cone (monomial (1::'a) t, U)", "obtain q where a: \"a = q * ?t\""], ["proof (prove)\nusing this:\n  a \\<in> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        a = q * monomial (1::'a) t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  a = q * monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (monomial (1::'a) t, U) \\<Longrightarrow>\n       x \\<in> ideal F", "have \"q \\<in> ideal F \\<div> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> ideal F \\<div> monomial (1::'a) t", "by (simp add: eq)"], ["proof (state)\nthis:\n  q \\<in> ideal F \\<div> monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cone (monomial (1::'a) t, U) \\<Longrightarrow>\n       x \\<in> ideal F", "thus \"a \\<in> ideal F\""], ["proof (prove)\nusing this:\n  q \\<in> ideal F \\<div> monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. a \\<in> ideal F", "by (simp only: a quot_set_iff mult.commute)"], ["proof (state)\nthis:\n  a \\<in> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<subseteq> ideal F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lem_4_2_2:\n  assumes \"ideal F \\<div> monomial 1 t = ideal (monomial (1::'a::comm_ring_1) ` S)\"\n  shows \"cone (monomial 1 t, U) \\<inter> ideal F = {0} \\<longleftrightarrow> S \\<inter> .[U] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}) =\n    (S \\<inter> .[U] = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "let ?t = \"monomial (1::'a) t\""], ["proof (state)\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "assume eq: \"cone (?t, U) \\<inter> ideal F = {0}\""], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "{"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "hence \"monomial 1 s \\<in> monomial (1::'a) ` S\" (is \"?s \\<in> _\")"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<in> monomial (1::'a) ` S", "by (rule imageI)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> monomial (1::'a) ` S\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "hence \"?s \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "also"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "have \"\\<dots> = ideal F \\<div> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (monomial (1::'a) ` S) = ideal F \\<div> monomial (1::'a) t", "by (simp only: assms)"], ["proof (state)\nthis:\n  ideal (monomial (1::'a) ` S) = ideal F \\<div> monomial (1::'a) t\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "finally"], ["proof (chain)\npicking this:\n  monomial (1::'a) s \\<in> ideal F \\<div> monomial (1::'a) t", "have *: \"?s * ?t \\<in> ideal F\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s \\<in> ideal F \\<div> monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F", "by (simp only: quot_set_iff mult.commute)"], ["proof (state)\nthis:\n  monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "assume \"s \\<in> .[U]\""], ["proof (state)\nthis:\n  s \\<in> .[U]\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "hence \"?s \\<in> P[U]\""], ["proof (prove)\nusing this:\n  s \\<in> .[U]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<in> P[U]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> P[U]\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "with refl"], ["proof (chain)\npicking this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[U]", "have \"?s * ?t \\<in> cone (?t, U)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[U]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * monomial (1::'a) t\n    \\<in> cone (monomial (1::'a) t, U)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial (1::'a) s * monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "with *"], ["proof (chain)\npicking this:\n  monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F\n  monomial (1::'a) s * monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)", "have \"?s * ?t \\<in> cone (?t, U) \\<inter> ideal F\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F\n  monomial (1::'a) s * monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * monomial (1::'a) t\n    \\<in> cone (monomial (1::'a) t, U) \\<inter> ideal F", "by simp"], ["proof (state)\nthis:\n  monomial (1::'a) s * monomial (1::'a) t\n  \\<in> cone (monomial (1::'a) t, U) \\<inter> ideal F\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "hence False"], ["proof (prove)\nusing this:\n  monomial (1::'a) s * monomial (1::'a) t\n  \\<in> cone (monomial (1::'a) t, U) \\<inter> ideal F\n\ngoal (1 subgoal):\n 1. False", "by (simp add: eq times_monomial_monomial monomial_0_iff)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s16 \\<in> S; ?s16 \\<in> .[U]\\<rbrakk> \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0} \\<Longrightarrow>\n    S \\<inter> .[U] = {}\n 2. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "thus \"S \\<inter> .[U] = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?s16 \\<in> S; ?s16 \\<in> .[U]\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {}", "by blast"], ["proof (state)\nthis:\n  S \\<inter> .[U] = {}\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "let ?t = \"monomial (1::'a) t\""], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "assume eq: \"S \\<inter> .[U] = {}\""], ["proof (state)\nthis:\n  S \\<inter> .[U] = {}\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "{"], ["proof (state)\nthis:\n  S \\<inter> .[U] = {}\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "assume \"a \\<in> cone (?t, U)\""], ["proof (state)\nthis:\n  a \\<in> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "then"], ["proof (chain)\npicking this:\n  a \\<in> cone (monomial (1::'a) t, U)", "obtain q where \"q \\<in> P[U]\" and a: \"a = q * ?t\""], ["proof (prove)\nusing this:\n  a \\<in> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[U]; a = q * monomial (1::'a) t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[U]\n  a = q * monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "assume \"a \\<in> ideal F\""], ["proof (state)\nthis:\n  a \\<in> ideal F\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "have \"a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "assume \"a \\<noteq> 0\""], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "hence \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by (auto simp: a)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "from \\<open>a \\<in> ideal F\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> ideal F", "have *: \"q \\<in> ideal F \\<div> ?t\""], ["proof (prove)\nusing this:\n  a \\<in> ideal F\n\ngoal (1 subgoal):\n 1. q \\<in> ideal F \\<div> monomial (1::'a) t", "by (simp only: quot_set_iff a mult.commute)"], ["proof (state)\nthis:\n  q \\<in> ideal F \\<div> monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "have \"is_monomial_set (monomial (1::'a) ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial_set (monomial (1::'a) ` S)", "by (auto intro!: is_monomial_setI monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  q \\<in> ideal F \\<div> monomial (1::'a) t", "have q_in: \"q \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  q \\<in> ideal F \\<div> monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. q \\<in> ideal (monomial (1::'a) ` S)", "by (simp only: assms)"], ["proof (state)\nthis:\n  q \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  q \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "from \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have \"lpp q \\<in> keys q\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp q \\<in> keys q", "by (rule punit.lt_in_keys)"], ["proof (state)\nthis:\n  lpp q \\<in> keys q\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  is_monomial_set (monomial (1::'a) ` S)\n  q \\<in> ideal (monomial (1::'a) ` S)\n  lpp q \\<in> keys q", "obtain g where \"g \\<in> monomial (1::'a) ` S\" and adds: \"lpp g adds lpp q\""], ["proof (prove)\nusing this:\n  is_monomial_set (monomial (1::'a) ` S)\n  q \\<in> ideal (monomial (1::'a) ` S)\n  lpp q \\<in> keys q\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> monomial (1::'a) ` S; lpp g adds lpp q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.keys_monomial_pmdl[simplified])"], ["proof (state)\nthis:\n  g \\<in> monomial (1::'a) ` S\n  lpp g adds lpp q\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  g \\<in> monomial (1::'a) ` S", "obtain s where \"s \\<in> S\" and g: \"g = monomial 1 s\""], ["proof (prove)\nusing this:\n  g \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; g = monomial (1::'a) s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> S\n  g = monomial (1::'a) s\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "from \\<open>q \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> 0", "have \"lpp q \\<in> keys q\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp q \\<in> keys q", "by (rule punit.lt_in_keys)"], ["proof (state)\nthis:\n  lpp q \\<in> keys q\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lpp q \\<in> keys q\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "from \\<open>q \\<in> P[U]\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> P[U]", "have \"\\<dots> \\<subseteq> .[U]\""], ["proof (prove)\nusing this:\n  q \\<in> P[U]\n\ngoal (1 subgoal):\n 1. keys q \\<subseteq> .[U]", "by (rule PolysD)"], ["proof (state)\nthis:\n  keys q \\<subseteq> .[U]\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lpp q \\<in> .[U]", "have \"lpp q \\<in> .[U]\""], ["proof (prove)\nusing this:\n  lpp q \\<in> .[U]\n\ngoal (1 subgoal):\n 1. lpp q \\<in> .[U]", "."], ["proof (state)\nthis:\n  lpp q \\<in> .[U]\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  lpp q \\<in> .[U]\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "from adds"], ["proof (chain)\npicking this:\n  lpp g adds lpp q", "have \"s adds lpp q\""], ["proof (prove)\nusing this:\n  lpp g adds lpp q\n\ngoal (1 subgoal):\n 1. s adds lpp q", "by (simp add: g punit.lt_monomial)"], ["proof (state)\nthis:\n  s adds lpp q\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  lpp q \\<in> .[U]\n  s adds lpp q", "have \"s \\<in> .[U]\""], ["proof (prove)\nusing this:\n  lpp q \\<in> .[U]\n  s adds lpp q\n\ngoal (1 subgoal):\n 1. s \\<in> .[U]", "by (rule PPs_closed_adds)"], ["proof (state)\nthis:\n  s \\<in> .[U]\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> False", "with eq \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  S \\<inter> .[U] = {}\n  s \\<in> S\n  s \\<in> .[U]", "show False"], ["proof (prove)\nusing this:\n  S \\<inter> .[U] = {}\n  s \\<in> S\n  s \\<in> .[U]\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = 0\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?a16 \\<in> cone (monomial (1::'a) t, U);\n   ?a16 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a16 = 0\n\ngoal (1 subgoal):\n 1. S \\<inter> .[U] = {} \\<Longrightarrow>\n    cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "thus \"cone (?t, U) \\<inter> ideal F = {0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a16 \\<in> cone (monomial (1::'a) t, U);\n   ?a16 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a16 = 0\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "using zero_in_cone ideal.span_zero"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a16 \\<in> cone (monomial (1::'a) t, U);\n   ?a16 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a16 = 0\n  0 \\<in> cone ?hU\n  (0::?'a) \\<in> ideal ?S\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "by blast"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Function \\<open>split\\<close>\\<close>"], ["", "definition max_subset :: \"'a set \\<Rightarrow> ('a set \\<Rightarrow> bool) \\<Rightarrow> 'a set\"\n  where \"max_subset A P = (ARG_MAX card B. B \\<subseteq> A \\<and> P B)\""], ["", "lemma max_subset:\n  assumes \"finite A\" and \"B \\<subseteq> A\" and \"P B\"\n  shows \"max_subset A P \\<subseteq> A\" (is ?thesis1)\n    and \"P (max_subset A P)\" (is ?thesis2)\n    and \"card B \\<le> card (max_subset A P)\" (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_subset A P \\<subseteq> A &&&\n    P (max_subset A P) &&& card B \\<le> card (max_subset A P)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. max_subset A P \\<subseteq> A\n 2. P (max_subset A P)\n 3. card B \\<le> card (max_subset A P)", "from assms(2, 3)"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  P B", "have \"B \\<subseteq> A \\<and> P B\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  P B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<and> P B", "by simp"], ["proof (state)\nthis:\n  B \\<subseteq> A \\<and> P B\n\ngoal (3 subgoals):\n 1. max_subset A P \\<subseteq> A\n 2. P (max_subset A P)\n 3. card B \\<le> card (max_subset A P)", "moreover"], ["proof (state)\nthis:\n  B \\<subseteq> A \\<and> P B\n\ngoal (3 subgoals):\n 1. max_subset A P \\<subseteq> A\n 2. P (max_subset A P)\n 3. card B \\<le> card (max_subset A P)", "have \"\\<forall>C. C \\<subseteq> A \\<and> P C \\<longrightarrow> card C < Suc (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C.\n       C \\<subseteq> A \\<and> P C \\<longrightarrow> card C < Suc (card A)", "proof (intro allI impI, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>C \\<subseteq> A; P C\\<rbrakk>\n       \\<Longrightarrow> card C < Suc (card A)", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>C \\<subseteq> A; P C\\<rbrakk>\n       \\<Longrightarrow> card C < Suc (card A)", "assume \"C \\<subseteq> A\""], ["proof (state)\nthis:\n  C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>C \\<subseteq> A; P C\\<rbrakk>\n       \\<Longrightarrow> card C < Suc (card A)", "with assms(1)"], ["proof (chain)\npicking this:\n  finite A\n  C \\<subseteq> A", "have \"card C \\<le> card A\""], ["proof (prove)\nusing this:\n  finite A\n  C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. card C \\<le> card A", "by (rule card_mono)"], ["proof (state)\nthis:\n  card C \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>C \\<subseteq> A; P C\\<rbrakk>\n       \\<Longrightarrow> card C < Suc (card A)", "thus \"card C < Suc (card A)\""], ["proof (prove)\nusing this:\n  card C \\<le> card A\n\ngoal (1 subgoal):\n 1. card C < Suc (card A)", "by simp"], ["proof (state)\nthis:\n  card C < Suc (card A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C.\n     C \\<subseteq> A \\<and> P C \\<longrightarrow> card C < Suc (card A)\n\ngoal (3 subgoals):\n 1. max_subset A P \\<subseteq> A\n 2. P (max_subset A P)\n 3. card B \\<le> card (max_subset A P)", "ultimately"], ["proof (chain)\npicking this:\n  B \\<subseteq> A \\<and> P B\n  \\<forall>C.\n     C \\<subseteq> A \\<and> P C \\<longrightarrow> card C < Suc (card A)", "have \"?thesis1 \\<and> ?thesis2\" and ?thesis3"], ["proof (prove)\nusing this:\n  B \\<subseteq> A \\<and> P B\n  \\<forall>C.\n     C \\<subseteq> A \\<and> P C \\<longrightarrow> card C < Suc (card A)\n\ngoal (1 subgoal):\n 1. max_subset A P \\<subseteq> A \\<and> P (max_subset A P) &&&\n    card B \\<le> card (max_subset A P)", "unfolding max_subset_def"], ["proof (prove)\nusing this:\n  B \\<subseteq> A \\<and> P B\n  \\<forall>C.\n     C \\<subseteq> A \\<and> P C \\<longrightarrow> card C < Suc (card A)\n\ngoal (1 subgoal):\n 1. (ARG_MAX card B. B \\<subseteq> A \\<and> P B) \\<subseteq> A \\<and>\n    P (ARG_MAX card B. B \\<subseteq> A \\<and> P B) &&&\n    card B \\<le> card (ARG_MAX card B. B \\<subseteq> A \\<and> P B)", "by (rule arg_max_natI, rule arg_max_nat_le)"], ["proof (state)\nthis:\n  max_subset A P \\<subseteq> A \\<and> P (max_subset A P)\n  card B \\<le> card (max_subset A P)\n\ngoal (3 subgoals):\n 1. max_subset A P \\<subseteq> A\n 2. P (max_subset A P)\n 3. card B \\<le> card (max_subset A P)", "thus ?thesis1 and ?thesis2 and ?thesis3"], ["proof (prove)\nusing this:\n  max_subset A P \\<subseteq> A \\<and> P (max_subset A P)\n  card B \\<le> card (max_subset A P)\n\ngoal (1 subgoal):\n 1. max_subset A P \\<subseteq> A &&&\n    P (max_subset A P) &&& card B \\<le> card (max_subset A P)", "by simp_all"], ["proof (state)\nthis:\n  max_subset A P \\<subseteq> A\n  P (max_subset A P)\n  card B \\<le> card (max_subset A P)\n\ngoal:\nNo subgoals!", "qed"], ["", "function (domintros) split :: \"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'x set \\<Rightarrow> ('x \\<Rightarrow>\\<^sub>0 nat) set \\<Rightarrow>\n                                ((((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> ('x set)) list) \\<times>\n                                 (((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{zero,one}) \\<times> ('x set)) list))\"\n  where\n    \"split t U S =\n      (if 0 \\<in> S then\n        ([(monomial 1 t, U)], [])\n      else if S \\<inter> .[U] = {} then\n        ([], [(monomial 1 t, U)])\n      else\n        let x = SOME x'. x' \\<in> U - (max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            (ps0, qs0) = split t (U - {x}) S;\n            (ps1, qs1) = split (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` S) in\n          (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>t U S. x = (t, U, S) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>t U S ta Ua Sa.\n       (t, U, S) = (ta, Ua, Sa) \\<Longrightarrow>\n       (if 0 \\<in> S then ([(monomial (1::'a) t, U)], [])\n        else if S \\<inter> .[U] = {} then ([], [(monomial (1::'a) t, U)])\n             else let x = SOME x'.\n                             x' \\<in> U -\nmax_subset U (\\<lambda>V. S \\<inter> .[V] = {});\n                      (ps0, qs0) = split_sumC (t, U - {x}, S);\n                      (ps1, qs1) =\n                        split_sumC\n                         (monomial 1 x + t, U,\n                          (\\<lambda>f. f - monomial 1 x) ` S)\n                  in (ps0 @ ps1, qs0 @ qs1)) =\n       (if 0 \\<in> Sa then ([(monomial (1::'a) ta, Ua)], [])\n        else if Sa \\<inter> .[Ua] = {}\n             then ([], [(monomial (1::'a) ta, Ua)])\n             else let x = SOME x'.\n                             x' \\<in> Ua -\nmax_subset Ua (\\<lambda>V. Sa \\<inter> .[V] = {});\n                      (ps0, qs0) = split_sumC (ta, Ua - {x}, Sa);\n                      (ps1, qs1) =\n                        split_sumC\n                         (monomial 1 x + ta, Ua,\n                          (\\<lambda>f. f - monomial 1 x) ` Sa)\n                  in (ps0 @ ps1, qs0 @ qs1))", "by auto"], ["", "text \\<open>Function @{const split} is not executable, because this is not necessary.\n  With some effort, it could be made executable, though.\\<close>"], ["", "lemma split_domI':\n  assumes \"finite X\" and \"fst (snd args) \\<subseteq> X\" and \"finite (snd (snd args))\"\n  shows \"split_dom TYPE('a::{zero,one}) args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_dom TYPE('a) args", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. split_dom TYPE('a) args", "let ?m = \"\\<lambda>args'. card (fst (snd args')) + sum deg_pm (snd (snd args'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. split_dom TYPE('a) args", "from wf_measure[of ?m] assms(2, 3)"], ["proof (chain)\npicking this:\n  wf (measure\n       (\\<lambda>args'.\n           card (fst (snd args')) + sum deg_pm (snd (snd args'))))\n  fst (snd args) \\<subseteq> X\n  finite (snd (snd args))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf (measure\n       (\\<lambda>args'.\n           card (fst (snd args')) + sum deg_pm (snd (snd args'))))\n  fst (snd args) \\<subseteq> X\n  finite (snd (snd args))\n\ngoal (1 subgoal):\n 1. split_dom TYPE('a) args", "proof (induct args)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "case (less args)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y20, args)\n           \\<in> measure\n                  (\\<lambda>args'.\n                      card (fst (snd args')) +\n                      sum deg_pm (snd (snd args')));\n   fst (snd ?y20) \\<subseteq> X; finite (snd (snd ?y20))\\<rbrakk>\n  \\<Longrightarrow> split_dom TYPE('a) ?y20\n  fst (snd args) \\<subseteq> X\n  finite (snd (snd args))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "obtain t U F where args: \"args = (t, U, F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t U F.\n        args = (t, U, F) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>t U F.\n        args = (t, U, F) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  args = (t, U, F)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "from less.prems"], ["proof (chain)\npicking this:\n  fst (snd args) \\<subseteq> X\n  finite (snd (snd args))", "have \"U \\<subseteq> X\" and \"finite F\""], ["proof (prove)\nusing this:\n  fst (snd args) \\<subseteq> X\n  finite (snd (snd args))\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X &&& finite F", "by (simp_all only: args fst_conv snd_conv)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite F\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "from this(1) assms(1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite X", "have \"finite U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "have IH: \"split_dom TYPE('a) (t', U', F')\"\n      if \"U' \\<subseteq> X\" and \"finite F'\" and \"card U' + sum deg_pm F' < card U + sum deg_pm F\"\n      for t' U' F'"], ["proof (prove)\ngoal (1 subgoal):\n 1. split_dom TYPE('a) (t', U', F')", "using less.hyps that"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y20, args)\n           \\<in> measure\n                  (\\<lambda>args'.\n                      card (fst (snd args')) +\n                      sum deg_pm (snd (snd args')));\n   fst (snd ?y20) \\<subseteq> X; finite (snd (snd ?y20))\\<rbrakk>\n  \\<Longrightarrow> split_dom TYPE('a) ?y20\n  U' \\<subseteq> X\n  finite F'\n  card U' + sum deg_pm F' < card U + sum deg_pm F\n\ngoal (1 subgoal):\n 1. split_dom TYPE('a) (t', U', F')", "by (simp add: args)"], ["proof (state)\nthis:\n  \\<lbrakk>?U'20 \\<subseteq> X; finite ?F'20;\n   card ?U'20 + sum deg_pm ?F'20 < card U + sum deg_pm F\\<rbrakk>\n  \\<Longrightarrow> split_dom TYPE('a) (?t'20, ?U'20, ?F'20)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "define S where \"S = max_subset U (\\<lambda>V. F \\<inter> .[V] = {})\""], ["proof (state)\nthis:\n  S = max_subset U (\\<lambda>V. F \\<inter> .[V] = {})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "define x where \"x = (SOME x'. x' \\<in> U \\<and> x' \\<notin> S)\""], ["proof (state)\nthis:\n  x = (SOME x'. x' \\<in> U \\<and> x' \\<notin> S)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x)\n                            \\<in> measure\n                                   (\\<lambda>args'.\n card (fst (snd args')) + sum deg_pm (snd (snd args')));\n                    fst (snd y) \\<subseteq> X; finite (snd (snd y))\\<rbrakk>\n                   \\<Longrightarrow> split_dom TYPE('a) y;\n        fst (snd x) \\<subseteq> X; finite (snd (snd x))\\<rbrakk>\n       \\<Longrightarrow> split_dom TYPE('a) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. split_dom TYPE('a) args", "unfolding args"], ["proof (prove)\ngoal (1 subgoal):\n 1. split_dom TYPE('a) (t, U, F)", "proof (rule split.domintros, simp_all only: x_def[symmetric] S_def[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"0 \\<notin> F\" and \"f \\<in> F\" and \"f \\<in> .[U]\""], ["proof (state)\nthis:\n  0 \\<notin> F\n  f \\<in> F\n  f \\<in> .[U]\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  0 \\<notin> F", "have \"F \\<inter> .[{}] = {}\""], ["proof (prove)\nusing this:\n  0 \\<notin> F\n\ngoal (1 subgoal):\n 1. F \\<inter> .[{}] = {}", "by simp"], ["proof (state)\nthis:\n  F \\<inter> .[{}] = {}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>finite U\\<close> empty_subsetI"], ["proof (chain)\npicking this:\n  finite U\n  {} \\<subseteq> ?A\n  F \\<inter> .[{}] = {}", "have \"S \\<subseteq> U\" and \"F \\<inter> .[S] = {}\""], ["proof (prove)\nusing this:\n  finite U\n  {} \\<subseteq> ?A\n  F \\<inter> .[{}] = {}\n\ngoal (1 subgoal):\n 1. S \\<subseteq> U &&& F \\<inter> .[S] = {}", "unfolding S_def"], ["proof (prove)\nusing this:\n  finite U\n  {} \\<subseteq> ?A\n  F \\<inter> .[{}] = {}\n\ngoal (1 subgoal):\n 1. max_subset U (\\<lambda>V. F \\<inter> .[V] = {}) \\<subseteq> U &&&\n    F \\<inter> .[max_subset U (\\<lambda>V. F \\<inter> .[V] = {})] = {}", "by (rule max_subset)+"], ["proof (state)\nthis:\n  S \\<subseteq> U\n  F \\<inter> .[S] = {}\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x \\<in> U \\<and> x \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> U \\<and> x \\<notin> S", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x'. x' \\<in> U \\<and> x' \\<notin> S) \\<in> U \\<and>\n    (SOME x'. x' \\<in> U \\<and> x' \\<notin> S) \\<notin> S", "proof (rule someI_ex)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> U \\<and> x \\<notin> S", "from \\<open>f \\<in> F\\<close> \\<open>f \\<in> .[U]\\<close> \\<open>F \\<inter> .[S] = {}\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> F\n  f \\<in> .[U]\n  F \\<inter> .[S] = {}", "have \"S \\<noteq> U\""], ["proof (prove)\nusing this:\n  f \\<in> F\n  f \\<in> .[U]\n  F \\<inter> .[S] = {}\n\ngoal (1 subgoal):\n 1. S \\<noteq> U", "by blast"], ["proof (state)\nthis:\n  S \\<noteq> U\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> U \\<and> x \\<notin> S", "with \\<open>S \\<subseteq> U\\<close>"], ["proof (chain)\npicking this:\n  S \\<subseteq> U\n  S \\<noteq> U", "show \"\\<exists>y. y \\<in> U \\<and> y \\<notin> S\""], ["proof (prove)\nusing this:\n  S \\<subseteq> U\n  S \\<noteq> U\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in> U \\<and> y \\<notin> S", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. y \\<in> U \\<and> y \\<notin> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> U \\<and> x \\<notin> S\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"x \\<in> U\" and \"x \\<notin> S\""], ["proof (prove)\nusing this:\n  x \\<in> U \\<and> x \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<in> U &&& x \\<notin> S", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> U\n  x \\<notin> S\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  x \\<in> U\n  x \\<notin> S\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<not> split_dom TYPE('a) (t, U - {x}, F)\""], ["proof (state)\nthis:\n  \\<not> split_dom TYPE('a) (t, U - {x}, F)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> split_dom TYPE('a) (t, U - {x}, F)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "from _ \\<open>finite F\\<close>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite F", "have \"split_dom TYPE('a) (t, U - {x}, F)\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite F\n\ngoal (1 subgoal):\n 1. split_dom TYPE('a) (t, U - {x}, F)", "proof (rule IH)"], ["proof (state)\ngoal (2 subgoals):\n 1. U - {x} \\<subseteq> X\n 2. card (U - {x}) + sum deg_pm F < card U + sum deg_pm F", "from \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "show \"U - {x} \\<subseteq> X\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U - {x} \\<subseteq> X", "by blast"], ["proof (state)\nthis:\n  U - {x} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. card (U - {x}) + sum deg_pm F < card U + sum deg_pm F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card (U - {x}) + sum deg_pm F < card U + sum deg_pm F", "from \\<open>finite U\\<close> \\<open>x \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  finite U\n  x \\<in> U", "have \"card (U - {x}) < card U\""], ["proof (prove)\nusing this:\n  finite U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. card (U - {x}) < card U", "by (rule card_Diff1_less)"], ["proof (state)\nthis:\n  card (U - {x}) < card U\n\ngoal (1 subgoal):\n 1. card (U - {x}) + sum deg_pm F < card U + sum deg_pm F", "thus \"card (U - {x}) + sum deg_pm F < card U + sum deg_pm F\""], ["proof (prove)\nusing this:\n  card (U - {x}) < card U\n\ngoal (1 subgoal):\n 1. card (U - {x}) + sum deg_pm F < card U + sum deg_pm F", "by simp"], ["proof (state)\nthis:\n  card (U - {x}) + sum deg_pm F < card U + sum deg_pm F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  split_dom TYPE('a) (t, U - {x}, F)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>0 \\<notin> F; \\<not> split_dom TYPE('a) (t, U - {x}, F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> split_dom TYPE('a) (t, U - {x}, F)\n  split_dom TYPE('a) (t, U - {x}, F)", "show False"], ["proof (prove)\nusing this:\n  \\<not> split_dom TYPE('a) (t, U - {x}, F)\n  split_dom TYPE('a) (t, U - {x}, F)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<not> split_dom TYPE('a) (t, U - {x}, F) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<not> split_dom TYPE('a) (t, U - {x}, F) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "let ?args = \"(Poly_Mapping.single x (Suc 0) + t, U, (\\<lambda>f. f - Poly_Mapping.single x (Suc 0)) ` F)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<not> split_dom TYPE('a) ?args\""], ["proof (state)\nthis:\n  \\<not> split_dom TYPE('a)\n          (monomial (Suc 0) x + t, U,\n           (\\<lambda>f. f - monomial (Suc 0) x) ` F)\n\ngoal (1 subgoal):\n 1. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> split_dom TYPE('a)\n          (monomial (Suc 0) x + t, U,\n           (\\<lambda>f. f - monomial (Suc 0) x) ` F)\n\ngoal (1 subgoal):\n 1. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "have \"split_dom TYPE('a) ?args\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. split_dom TYPE('a)\n     (monomial (Suc 0) x + t, U, (\\<lambda>f. f - monomial (Suc 0) x) ` F)", "proof (rule IH)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n 2. card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    < card U + sum deg_pm F", "from \\<open>finite F\\<close>"], ["proof (chain)\npicking this:\n  finite F", "show \"finite ((\\<lambda>f. f - Poly_Mapping.single x (Suc 0)) ` F)\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>f. f - monomial (Suc 0) x) ` F)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n\ngoal (1 subgoal):\n 1. card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    < card U + sum deg_pm F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    < card U + sum deg_pm F", "have \"sum deg_pm ((\\<lambda>f. f - Poly_Mapping.single x (Suc 0)) ` F) \\<le>\n                sum (deg_pm \\<circ> (\\<lambda>f. f - Poly_Mapping.single x (Suc 0))) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    \\<le> sum (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) F", "using \\<open>finite F\\<close>"], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    \\<le> sum (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) F", "by (rule sum_image_le) simp"], ["proof (state)\nthis:\n  sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n  \\<le> sum (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) F\n\ngoal (1 subgoal):\n 1. card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    < card U + sum deg_pm F", "also"], ["proof (state)\nthis:\n  sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n  \\<le> sum (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) F\n\ngoal (1 subgoal):\n 1. card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    < card U + sum deg_pm F", "from \\<open>finite F\\<close>"], ["proof (chain)\npicking this:\n  finite F", "have \"\\<dots> < sum deg_pm F\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. sum (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) F\n    < sum deg_pm F", "proof (rule sum_strict_mono_ex1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>xa\\<in>F.\n       (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) xa\n       \\<le> deg_pm xa\n 2. \\<exists>a\\<in>F.\n       (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) a < deg_pm a", "show \"\\<forall>f\\<in>F. (deg_pm \\<circ> (\\<lambda>f. f - Poly_Mapping.single x (Suc 0))) f \\<le> deg_pm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F.\n       (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n       \\<le> deg_pm f", "by (simp add: deg_pm_minus_le)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>F.\n     (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f \\<le> deg_pm f\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>F.\n       (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) a < deg_pm a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>F.\n       (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) a < deg_pm a", "show \"\\<exists>f\\<in>F. (deg_pm \\<circ> (\\<lambda>f. f - Poly_Mapping.single x (Suc 0))) f < deg_pm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>F.\n       (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f < deg_pm f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "assume *: \"\\<not> (\\<exists>f\\<in>F. (deg_pm \\<circ> (\\<lambda>f. f - Poly_Mapping.single x (Suc 0))) f < deg_pm f)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>f\\<in>F.\n             (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n             < deg_pm f)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "note \\<open>finite U\\<close>"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "from \\<open>x \\<in> U\\<close> \\<open>S \\<subseteq> U\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> U\n  S \\<subseteq> U", "have \"insert x S \\<subseteq> U\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  S \\<subseteq> U\n\ngoal (1 subgoal):\n 1. insert x S \\<subseteq> U", "by (rule insert_subsetI)"], ["proof (state)\nthis:\n  insert x S \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  insert x S \\<subseteq> U\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "have \"F \\<inter> .[insert x S] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "assume \"s \\<in> F\""], ["proof (state)\nthis:\n  s \\<in> F\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "with *"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>f\\<in>F.\n             (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n             < deg_pm f)\n  s \\<in> F", "have \"\\<not> deg_pm (s - Poly_Mapping.single x (Suc 0)) < deg_pm s\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>f\\<in>F.\n             (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n             < deg_pm f)\n  s \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> deg_pm (s - monomial (Suc 0) x) < deg_pm s", "by simp"], ["proof (state)\nthis:\n  \\<not> deg_pm (s - monomial (Suc 0) x) < deg_pm s\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "with deg_pm_minus_le[of s \"Poly_Mapping.single x (Suc 0)\"]"], ["proof (chain)\npicking this:\n  deg_pm (s - monomial (Suc 0) x) \\<le> deg_pm s\n  \\<not> deg_pm (s - monomial (Suc 0) x) < deg_pm s", "have \"deg_pm (s - Poly_Mapping.single x (Suc 0)) = deg_pm s\""], ["proof (prove)\nusing this:\n  deg_pm (s - monomial (Suc 0) x) \\<le> deg_pm s\n  \\<not> deg_pm (s - monomial (Suc 0) x) < deg_pm s\n\ngoal (1 subgoal):\n 1. deg_pm (s - monomial (Suc 0) x) = deg_pm s", "by simp"], ["proof (state)\nthis:\n  deg_pm (s - monomial (Suc 0) x) = deg_pm s\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "hence \"keys s \\<inter> keys (Poly_Mapping.single x (Suc 0)) = {}\""], ["proof (prove)\nusing this:\n  deg_pm (s - monomial (Suc 0) x) = deg_pm s\n\ngoal (1 subgoal):\n 1. keys s \\<inter> keys (monomial (Suc 0) x) = {}", "by (simp only: deg_pm_minus_id_iff)"], ["proof (state)\nthis:\n  keys s \\<inter> keys (monomial (Suc 0) x) = {}\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "hence \"x \\<notin> keys s\""], ["proof (prove)\nusing this:\n  keys s \\<inter> keys (monomial (Suc 0) x) = {}\n\ngoal (1 subgoal):\n 1. x \\<notin> keys s", "by simp"], ["proof (state)\nthis:\n  x \\<notin> keys s\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "moreover"], ["proof (state)\nthis:\n  x \\<notin> keys s\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "assume \"s \\<in> .[insert x S]\""], ["proof (state)\nthis:\n  s \\<in> .[insert x S]\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> keys s\n  s \\<in> .[insert x S]", "have \"s \\<in> .[S]\""], ["proof (prove)\nusing this:\n  x \\<notin> keys s\n  s \\<in> .[insert x S]\n\ngoal (1 subgoal):\n 1. s \\<in> .[S]", "by (fastforce simp: PPs_def)"], ["proof (state)\nthis:\n  s \\<in> .[S]\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "with \\<open>s \\<in> F\\<close> \\<open>F \\<inter> .[S] = {}\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> F\n  F \\<inter> .[S] = {}\n  s \\<in> .[S]", "have False"], ["proof (prove)\nusing this:\n  s \\<in> F\n  F \\<inter> .[S] = {}\n  s \\<in> .[S]\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s22 \\<in> F; ?s22 \\<in> .[insert x S]\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s22 \\<in> F; ?s22 \\<in> .[insert x S]\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. F \\<inter> .[insert x S] = {}", "by blast"], ["proof (state)\nthis:\n  F \\<inter> .[insert x S] = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F \\<inter> .[insert x S] = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  finite U\n  insert x S \\<subseteq> U\n  F \\<inter> .[insert x S] = {}", "have \"card (insert x S) \\<le> card S\""], ["proof (prove)\nusing this:\n  finite U\n  insert x S \\<subseteq> U\n  F \\<inter> .[insert x S] = {}\n\ngoal (1 subgoal):\n 1. card (insert x S) \\<le> card S", "unfolding S_def"], ["proof (prove)\nusing this:\n  finite U\n  insert x (max_subset U (\\<lambda>V. F \\<inter> .[V] = {})) \\<subseteq> U\n  F \\<inter> .[insert x (max_subset U (\\<lambda>V. F \\<inter> .[V] = {}))] =\n  {}\n\ngoal (1 subgoal):\n 1. card (insert x (max_subset U (\\<lambda>V. F \\<inter> .[V] = {})))\n    \\<le> card (max_subset U (\\<lambda>V. F \\<inter> .[V] = {}))", "by (rule max_subset)"], ["proof (state)\nthis:\n  card (insert x S) \\<le> card S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  card (insert x S) \\<le> card S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "from \\<open>S \\<subseteq> U\\<close> \\<open>finite U\\<close>"], ["proof (chain)\npicking this:\n  S \\<subseteq> U\n  finite U", "have \"finite S\""], ["proof (prove)\nusing this:\n  S \\<subseteq> U\n  finite U\n\ngoal (1 subgoal):\n 1. finite S", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>f\\<in>F.\n               (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f\n               < deg_pm f) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  card (insert x S) \\<le> card S\n  finite S", "show False"], ["proof (prove)\nusing this:\n  card (insert x S) \\<le> card S\n  finite S\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x \\<notin> S\\<close>"], ["proof (prove)\nusing this:\n  card (insert x S) \\<le> card S\n  finite S\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f\\<in>F.\n     (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) f < deg_pm f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (deg_pm \\<circ> (\\<lambda>f. f - monomial (Suc 0) x)) F < sum deg_pm F\n\ngoal (1 subgoal):\n 1. card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    < card U + sum deg_pm F", "finally"], ["proof (chain)\npicking this:\n  sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F) < sum deg_pm F", "show \"card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F) < card U + sum deg_pm F\""], ["proof (prove)\nusing this:\n  sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F) < sum deg_pm F\n\ngoal (1 subgoal):\n 1. card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n    < card U + sum deg_pm F", "by simp"], ["proof (state)\nthis:\n  card U + sum deg_pm ((\\<lambda>f. f - monomial (Suc 0) x) ` F)\n  < card U + sum deg_pm F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  split_dom TYPE('a)\n   (monomial (Suc 0) x + t, U, (\\<lambda>f. f - monomial (Suc 0) x) ` F)\n\ngoal (1 subgoal):\n 1. \\<And>ab ba xb ya xa.\n       \\<lbrakk>0 \\<notin> F; (ab, ba) = split t (U - {x}) F;\n        (xb, ya) = split t (U - {x}) F;\n        \\<not> split_dom TYPE('a)\n                (monomial (Suc 0) x + t, U,\n                 (\\<lambda>xa. xa - monomial (Suc 0) x) ` F);\n        xa \\<in> F; xa \\<in> .[U]\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> split_dom TYPE('a)\n          (monomial (Suc 0) x + t, U,\n           (\\<lambda>f. f - monomial (Suc 0) x) ` F)\n  split_dom TYPE('a)\n   (monomial (Suc 0) x + t, U, (\\<lambda>f. f - monomial (Suc 0) x) ` F)", "show False"], ["proof (prove)\nusing this:\n  \\<not> split_dom TYPE('a)\n          (monomial (Suc 0) x + t, U,\n           (\\<lambda>f. f - monomial (Suc 0) x) ` F)\n  split_dom TYPE('a)\n   (monomial (Suc 0) x + t, U, (\\<lambda>f. f - monomial (Suc 0) x) ` F)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<not> split_dom TYPE('a)\n          (monomial (Suc 0) x + t, U,\n           (\\<lambda>f. f - monomial (Suc 0) x) ` F) \\<Longrightarrow>\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  split_dom TYPE('a) args\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  split_dom TYPE('a) args\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary split_domI: \"finite X \\<Longrightarrow> U \\<subseteq> X \\<Longrightarrow> finite S \\<Longrightarrow> split_dom TYPE('a::{zero,one}) (t, U, S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; U \\<subseteq> X; finite S\\<rbrakk>\n    \\<Longrightarrow> split_dom TYPE('a) (t, U, S)", "using split_domI'[of \"(t, U, S)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite X; fst (snd (t, U, S)) \\<subseteq> X;\n   finite (snd (snd (t, U, S)))\\<rbrakk>\n  \\<Longrightarrow> split_dom TYPE(?'a) (t, U, S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; U \\<subseteq> X; finite S\\<rbrakk>\n    \\<Longrightarrow> split_dom TYPE('a) (t, U, S)", "by simp"], ["", "lemma split_empty:\n  assumes \"finite X\" and \"U \\<subseteq> X\"\n  shows \"split t U {} = ([], [(monomial (1::'a::{zero,one}) t, U)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split t U {} = ([], [(monomial (1::'a) t, U)])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. split t U {} = ([], [(monomial (1::'a) t, U)])", "have \"finite {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {}", ".."], ["proof (state)\nthis:\n  finite {}\n\ngoal (1 subgoal):\n 1. split t U {} = ([], [(monomial (1::'a) t, U)])", "with assms"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite {}", "have \"split_dom TYPE('a) (t, U, {})\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite {}\n\ngoal (1 subgoal):\n 1. split_dom TYPE('a) (t, U, {})", "by (rule split_domI)"], ["proof (state)\nthis:\n  split_dom TYPE('a) (t, U, {})\n\ngoal (1 subgoal):\n 1. split t U {} = ([], [(monomial (1::'a) t, U)])", "thus ?thesis"], ["proof (prove)\nusing this:\n  split_dom TYPE('a) (t, U, {})\n\ngoal (1 subgoal):\n 1. split t U {} = ([], [(monomial (1::'a) t, U)])", "by (simp add: split.psimps)"], ["proof (state)\nthis:\n  split t U {} = ([], [(monomial (1::'a) t, U)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_induct [consumes 3, case_names base1 base2 step]:\n  fixes P :: \"('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> _\"\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\"\n  assumes \"\\<And>t U S. U \\<subseteq> X \\<Longrightarrow> finite S \\<Longrightarrow> 0 \\<in> S \\<Longrightarrow> P t U S ([(monomial (1::'a::{zero,one}) t, U)], [])\"\n  assumes \"\\<And>t U S. U \\<subseteq> X \\<Longrightarrow> finite S \\<Longrightarrow> 0 \\<notin> S \\<Longrightarrow> S \\<inter> .[U] = {} \\<Longrightarrow> P t U S ([], [(monomial 1 t, U)])\"\n  assumes \"\\<And>t U S V x ps0 ps1 qs0 qs1. U \\<subseteq> X \\<Longrightarrow> finite S \\<Longrightarrow> 0 \\<notin> S \\<Longrightarrow> S \\<inter> .[U] \\<noteq> {} \\<Longrightarrow> V \\<subseteq> U \\<Longrightarrow>\n              S \\<inter> .[V] = {} \\<Longrightarrow> (\\<And>V'. V' \\<subseteq> U \\<Longrightarrow> S \\<inter> .[V'] = {} \\<Longrightarrow> card V' \\<le> card V) \\<Longrightarrow>\n              x \\<in> U \\<Longrightarrow> x \\<notin> V \\<Longrightarrow> V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {}) \\<Longrightarrow> x = (SOME x'. x' \\<in> U - V) \\<Longrightarrow>\n              (ps0, qs0) = split t (U - {x}) S \\<Longrightarrow>\n              (ps1, qs1) = split (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` S) \\<Longrightarrow>\n              split t U S = (ps0 @ ps1, qs0 @ qs1) \\<Longrightarrow>\n              P t (U - {x}) S (ps0, qs0) \\<Longrightarrow>\n              P (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` S) (ps1, qs1) \\<Longrightarrow>\n              P t U S (ps0 @ ps1, qs0 @ qs1)\"\n  shows \"P t U S (split t U S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t U S (split t U S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P t U S (split t U S)", "from assms(1-3)"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite S", "have \"split_dom TYPE('a) (t, U, S)\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n\ngoal (1 subgoal):\n 1. split_dom TYPE('a) (t, U, S)", "by (rule split_domI)"], ["proof (state)\nthis:\n  split_dom TYPE('a) (t, U, S)\n\ngoal (1 subgoal):\n 1. P t U S (split t U S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  split_dom TYPE('a) (t, U, S)\n\ngoal (1 subgoal):\n 1. P t U S (split t U S)", "using assms(2,3)"], ["proof (prove)\nusing this:\n  split_dom TYPE('a) (t, U, S)\n  U \\<subseteq> X\n  finite S\n\ngoal (1 subgoal):\n 1. P t U S (split t U S)", "proof (induct t U S rule: split.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S.\n       \\<lbrakk>split_dom TYPE('a) (t, U, S);\n        \\<And>x.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            U - {x} \\<subseteq> X; finite S\\<rbrakk>\n           \\<Longrightarrow> P t (U - {x}) S (split t (U - {x}) S);\n        \\<And>x xa xb y.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            xa = split t (U - {x}) S; (xb, y) = xa; U \\<subseteq> X;\n            finite ((\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n           \\<Longrightarrow> P (monomial 1 x + t) U\n                              ((\\<lambda>f. f - monomial 1 x) ` S)\n                              (split (monomial 1 x + t) U\n                                ((\\<lambda>f. f - monomial 1 x) ` S));\n        U \\<subseteq> X; finite S\\<rbrakk>\n       \\<Longrightarrow> P t U S (split t U S)", "case step: (1 t U F)"], ["proof (state)\nthis:\n  split_dom TYPE('a) (t, U, F)\n  \\<lbrakk>0 \\<notin> F; F \\<inter> .[U] \\<noteq> {};\n   ?x19 =\n   (SOME x'. x' \\<in> U - max_subset U (\\<lambda>V. F \\<inter> .[V] = {}));\n   U - {?x19} \\<subseteq> X; finite F\\<rbrakk>\n  \\<Longrightarrow> P t (U - {?x19}) F (split t (U - {?x19}) F)\n  \\<lbrakk>0 \\<notin> F; F \\<inter> .[U] \\<noteq> {};\n   ?x19 =\n   (SOME x'. x' \\<in> U - max_subset U (\\<lambda>V. F \\<inter> .[V] = {}));\n   ?xa19 = split t (U - {?x19}) F; (?xb19, ?y19) = ?xa19; U \\<subseteq> X;\n   finite ((\\<lambda>f. f - monomial 1 ?x19) ` F)\\<rbrakk>\n  \\<Longrightarrow> P (monomial 1 ?x19 + t) U\n                     ((\\<lambda>f. f - monomial 1 ?x19) ` F)\n                     (split (monomial 1 ?x19 + t) U\n                       ((\\<lambda>f. f - monomial 1 ?x19) ` F))\n  U \\<subseteq> X\n  finite F\n\ngoal (1 subgoal):\n 1. \\<And>t U S.\n       \\<lbrakk>split_dom TYPE('a) (t, U, S);\n        \\<And>x.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            U - {x} \\<subseteq> X; finite S\\<rbrakk>\n           \\<Longrightarrow> P t (U - {x}) S (split t (U - {x}) S);\n        \\<And>x xa xb y.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            xa = split t (U - {x}) S; (xb, y) = xa; U \\<subseteq> X;\n            finite ((\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n           \\<Longrightarrow> P (monomial 1 x + t) U\n                              ((\\<lambda>f. f - monomial 1 x) ` S)\n                              (split (monomial 1 x + t) U\n                                ((\\<lambda>f. f - monomial 1 x) ` S));\n        U \\<subseteq> X; finite S\\<rbrakk>\n       \\<Longrightarrow> P t U S (split t U S)", "from step(4) assms(1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite X", "have \"finite U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. \\<And>t U S.\n       \\<lbrakk>split_dom TYPE('a) (t, U, S);\n        \\<And>x.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            U - {x} \\<subseteq> X; finite S\\<rbrakk>\n           \\<Longrightarrow> P t (U - {x}) S (split t (U - {x}) S);\n        \\<And>x xa xb y.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            xa = split t (U - {x}) S; (xb, y) = xa; U \\<subseteq> X;\n            finite ((\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n           \\<Longrightarrow> P (monomial 1 x + t) U\n                              ((\\<lambda>f. f - monomial 1 x) ` S)\n                              (split (monomial 1 x + t) U\n                                ((\\<lambda>f. f - monomial 1 x) ` S));\n        U \\<subseteq> X; finite S\\<rbrakk>\n       \\<Longrightarrow> P t U S (split t U S)", "define S where \"S = max_subset U (\\<lambda>V. F \\<inter> .[V] = {})\""], ["proof (state)\nthis:\n  S = max_subset U (\\<lambda>V. F \\<inter> .[V] = {})\n\ngoal (1 subgoal):\n 1. \\<And>t U S.\n       \\<lbrakk>split_dom TYPE('a) (t, U, S);\n        \\<And>x.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            U - {x} \\<subseteq> X; finite S\\<rbrakk>\n           \\<Longrightarrow> P t (U - {x}) S (split t (U - {x}) S);\n        \\<And>x xa xb y.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            xa = split t (U - {x}) S; (xb, y) = xa; U \\<subseteq> X;\n            finite ((\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n           \\<Longrightarrow> P (monomial 1 x + t) U\n                              ((\\<lambda>f. f - monomial 1 x) ` S)\n                              (split (monomial 1 x + t) U\n                                ((\\<lambda>f. f - monomial 1 x) ` S));\n        U \\<subseteq> X; finite S\\<rbrakk>\n       \\<Longrightarrow> P t U S (split t U S)", "define x where \"x = (SOME x'. x' \\<in> U \\<and> x' \\<notin> S)\""], ["proof (state)\nthis:\n  x = (SOME x'. x' \\<in> U \\<and> x' \\<notin> S)\n\ngoal (1 subgoal):\n 1. \\<And>t U S.\n       \\<lbrakk>split_dom TYPE('a) (t, U, S);\n        \\<And>x.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            U - {x} \\<subseteq> X; finite S\\<rbrakk>\n           \\<Longrightarrow> P t (U - {x}) S (split t (U - {x}) S);\n        \\<And>x xa xb y.\n           \\<lbrakk>0 \\<notin> S; S \\<inter> .[U] \\<noteq> {};\n            x =\n            (SOME x'.\n                x' \\<in> U -\n                         max_subset U (\\<lambda>V. S \\<inter> .[V] = {}));\n            xa = split t (U - {x}) S; (xb, y) = xa; U \\<subseteq> X;\n            finite ((\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n           \\<Longrightarrow> P (monomial 1 x + t) U\n                              ((\\<lambda>f. f - monomial 1 x) ` S)\n                              (split (monomial 1 x + t) U\n                                ((\\<lambda>f. f - monomial 1 x) ` S));\n        U \\<subseteq> X; finite S\\<rbrakk>\n       \\<Longrightarrow> P t U S (split t U S)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t U F (split t U F)", "proof (simp add: split.psimps[OF step(1)] S_def[symmetric] x_def[symmetric] split: prod.split, intro allI conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<in> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([(monomial (1::'a) t, U)], [])\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([], [(monomial (1::'a) t, U)])\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<in> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([(monomial (1::'a) t, U)], [])\n 4. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "assume \"0 \\<in> F\""], ["proof (state)\nthis:\n  0 \\<in> F\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<in> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([(monomial (1::'a) t, U)], [])\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([], [(monomial (1::'a) t, U)])\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<in> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([(monomial (1::'a) t, U)], [])\n 4. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "with step(4, 5)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite F\n  0 \\<in> F", "show \"P t U F ([(monomial 1 t, U)], [])\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite F\n  0 \\<in> F\n\ngoal (1 subgoal):\n 1. P t U F ([(monomial (1::'a) t, U)], [])", "by (rule assms(4))"], ["proof (state)\nthis:\n  P t U F ([(monomial (1::'a) t, U)], [])\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([], [(monomial (1::'a) t, U)])\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<in> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([(monomial (1::'a) t, U)], [])\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "thus \"P t U F ([(monomial 1 t, U)], [])\""], ["proof (prove)\nusing this:\n  P t U F ([(monomial (1::'a) t, U)], [])\n\ngoal (1 subgoal):\n 1. P t U F ([(monomial (1::'a) t, U)], [])", "."], ["proof (state)\nthis:\n  P t U F ([(monomial (1::'a) t, U)], [])\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([], [(monomial (1::'a) t, U)])\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([], [(monomial (1::'a) t, U)])\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "assume \"0 \\<notin> F\" and \"F \\<inter> .[U] = {}\""], ["proof (state)\nthis:\n  0 \\<notin> F\n  F \\<inter> .[U] = {}\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] = {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F ([], [(monomial (1::'a) t, U)])\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "with step(4, 5)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite F\n  0 \\<notin> F\n  F \\<inter> .[U] = {}", "show \"P t U F ([], [(monomial 1 t, U)])\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite F\n  0 \\<notin> F\n  F \\<inter> .[U] = {}\n\ngoal (1 subgoal):\n 1. P t U F ([], [(monomial (1::'a) t, U)])", "by (rule assms(5))"], ["proof (state)\nthis:\n  P t U F ([], [(monomial (1::'a) t, U)])\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "fix ps0 qs0 ps1 qs1 :: \"((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "assume \"split (Poly_Mapping.single x (Suc 0) + t) U ((\\<lambda>f. f - Poly_Mapping.single x (Suc 0)) ` F) = (ps1, qs1)\""], ["proof (state)\nthis:\n  split (monomial (Suc 0) x + t) U\n   ((\\<lambda>f. f - monomial (Suc 0) x) ` F) =\n  (ps1, qs1)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "hence PQ1[symmetric]: \"split (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` F) = (ps1, qs1)\""], ["proof (prove)\nusing this:\n  split (monomial (Suc 0) x + t) U\n   ((\\<lambda>f. f - monomial (Suc 0) x) ` F) =\n  (ps1, qs1)\n\ngoal (1 subgoal):\n 1. split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F) =\n    (ps1, qs1)", "by simp"], ["proof (state)\nthis:\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "assume PQ0[symmetric]: \"split t (U - {x}) F = (ps0, qs0)\""], ["proof (state)\nthis:\n  (ps0, qs0) = split t (U - {x}) F\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "assume \"F \\<inter> .[U] \\<noteq> {}\" and \"0 \\<notin> F\""], ["proof (state)\nthis:\n  F \\<inter> .[U] \\<noteq> {}\n  0 \\<notin> F\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "from this(2)"], ["proof (chain)\npicking this:\n  0 \\<notin> F", "have \"F \\<inter> .[{}] = {}\""], ["proof (prove)\nusing this:\n  0 \\<notin> F\n\ngoal (1 subgoal):\n 1. F \\<inter> .[{}] = {}", "by simp"], ["proof (state)\nthis:\n  F \\<inter> .[{}] = {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "with \\<open>finite U\\<close> empty_subsetI"], ["proof (chain)\npicking this:\n  finite U\n  {} \\<subseteq> ?A\n  F \\<inter> .[{}] = {}", "have \"S \\<subseteq> U\" and \"F \\<inter> .[S] = {}\""], ["proof (prove)\nusing this:\n  finite U\n  {} \\<subseteq> ?A\n  F \\<inter> .[{}] = {}\n\ngoal (1 subgoal):\n 1. S \\<subseteq> U &&& F \\<inter> .[S] = {}", "unfolding S_def"], ["proof (prove)\nusing this:\n  finite U\n  {} \\<subseteq> ?A\n  F \\<inter> .[{}] = {}\n\ngoal (1 subgoal):\n 1. max_subset U (\\<lambda>V. F \\<inter> .[V] = {}) \\<subseteq> U &&&\n    F \\<inter> .[max_subset U (\\<lambda>V. F \\<inter> .[V] = {})] = {}", "by (rule max_subset)+"], ["proof (state)\nthis:\n  S \\<subseteq> U\n  F \\<inter> .[S] = {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "have S_max: \"card S' \\<le> card S\" if \"S' \\<subseteq> U\" and \"F \\<inter> .[S'] = {}\" for S'"], ["proof (prove)\ngoal (1 subgoal):\n 1. card S' \\<le> card S", "using \\<open>finite U\\<close> that"], ["proof (prove)\nusing this:\n  finite U\n  S' \\<subseteq> U\n  F \\<inter> .[S'] = {}\n\ngoal (1 subgoal):\n 1. card S' \\<le> card S", "unfolding S_def"], ["proof (prove)\nusing this:\n  finite U\n  S' \\<subseteq> U\n  F \\<inter> .[S'] = {}\n\ngoal (1 subgoal):\n 1. card S' \\<le> card (max_subset U (\\<lambda>V. F \\<inter> .[V] = {}))", "by (rule max_subset)"], ["proof (state)\nthis:\n  \\<lbrakk>?S'19 \\<subseteq> U; F \\<inter> .[?S'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?S'19 \\<le> card S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "have \"x \\<in> U \\<and> x \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> U \\<and> x \\<notin> S", "unfolding x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x'. x' \\<in> U \\<and> x' \\<notin> S) \\<in> U \\<and>\n    (SOME x'. x' \\<in> U \\<and> x' \\<notin> S) \\<notin> S", "proof (rule someI_ex)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> U \\<and> x \\<notin> S", "from \\<open>F \\<inter> .[U] \\<noteq> {}\\<close> \\<open>F \\<inter> .[S] = {}\\<close>"], ["proof (chain)\npicking this:\n  F \\<inter> .[U] \\<noteq> {}\n  F \\<inter> .[S] = {}", "have \"S \\<noteq> U\""], ["proof (prove)\nusing this:\n  F \\<inter> .[U] \\<noteq> {}\n  F \\<inter> .[S] = {}\n\ngoal (1 subgoal):\n 1. S \\<noteq> U", "by blast"], ["proof (state)\nthis:\n  S \\<noteq> U\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> U \\<and> x \\<notin> S", "with \\<open>S \\<subseteq> U\\<close>"], ["proof (chain)\npicking this:\n  S \\<subseteq> U\n  S \\<noteq> U", "show \"\\<exists>y. y \\<in> U \\<and> y \\<notin> S\""], ["proof (prove)\nusing this:\n  S \\<subseteq> U\n  S \\<noteq> U\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in> U \\<and> y \\<notin> S", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. y \\<in> U \\<and> y \\<notin> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> U \\<and> x \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "hence \"x \\<in> U\" and \"x \\<notin> S\""], ["proof (prove)\nusing this:\n  x \\<in> U \\<and> x \\<notin> S\n\ngoal (1 subgoal):\n 1. x \\<in> U &&& x \\<notin> S", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> U\n  x \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>split (monomial (Suc 0) x + t) U\n                 ((\\<lambda>xa. xa - monomial (Suc 0) x) ` F) =\n                (x1a, x2a);\n        split t (U - {x}) F = (x1, x2); F \\<inter> .[U] \\<noteq> {};\n        0 \\<notin> F\\<rbrakk>\n       \\<Longrightarrow> P t U F (x1 @ x1a, x2 @ x2a)", "from step(4, 5) \\<open>0 \\<notin> F\\<close> \\<open>F \\<inter> .[U] \\<noteq> {}\\<close> \\<open>S \\<subseteq> U\\<close> \\<open>F \\<inter> .[S] = {}\\<close> S_max \\<open>x \\<in> U\\<close> \\<open>x \\<notin> S\\<close> S_def _ PQ0 PQ1"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite F\n  0 \\<notin> F\n  F \\<inter> .[U] \\<noteq> {}\n  S \\<subseteq> U\n  F \\<inter> .[S] = {}\n  \\<lbrakk>?S'19 \\<subseteq> U; F \\<inter> .[?S'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?S'19 \\<le> card S\n  x \\<in> U\n  x \\<notin> S\n  S = max_subset U (\\<lambda>V. F \\<inter> .[V] = {})\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  (ps0, qs0) = split t (U - {x}) F\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F)", "show \"P t U F (ps0 @ ps1, qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite F\n  0 \\<notin> F\n  F \\<inter> .[U] \\<noteq> {}\n  S \\<subseteq> U\n  F \\<inter> .[S] = {}\n  \\<lbrakk>?S'19 \\<subseteq> U; F \\<inter> .[?S'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?S'19 \\<le> card S\n  x \\<in> U\n  x \\<notin> S\n  S = max_subset U (\\<lambda>V. F \\<inter> .[V] = {})\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  (ps0, qs0) = split t (U - {x}) F\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F)\n\ngoal (1 subgoal):\n 1. P t U F (ps0 @ ps1, qs0 @ qs1)", "proof (rule assms(6))"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> V' \\<subseteq> U\n 2. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> F \\<inter> .[V'] = {}\n 3. x = (SOME x'. x' \\<in> U - S)\n 4. split t U F = (ps0 @ ps1, qs0 @ qs1)\n 5. P t (U - {x}) F (ps0, qs0)\n 6. P (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F) (ps1, qs1)", "show \"P t (U - {x}) F (ps0, qs0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t (U - {x}) F (ps0, qs0)", "unfolding PQ0"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t (U - {x}) F (split t (U - {x}) F)", "using \\<open>0 \\<notin> F\\<close> \\<open>F \\<inter> .[U] \\<noteq> {}\\<close> _ _ step(5)"], ["proof (prove)\nusing this:\n  0 \\<notin> F\n  F \\<inter> .[U] \\<noteq> {}\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite F\n\ngoal (1 subgoal):\n 1. P t (U - {x}) F (split t (U - {x}) F)", "proof (rule step(2))"], ["proof (state)\ngoal (2 subgoals):\n 1. x =\n    (SOME x'. x' \\<in> U - max_subset U (\\<lambda>V. F \\<inter> .[V] = {}))\n 2. U - {x} \\<subseteq> X", "from \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "show \"U - {x} \\<subseteq> X\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U - {x} \\<subseteq> X", "by fastforce"], ["proof (state)\nthis:\n  U - {x} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x =\n    (SOME x'. x' \\<in> U - max_subset U (\\<lambda>V. F \\<inter> .[V] = {}))", "qed (simp add: x_def S_def)"], ["proof (state)\nthis:\n  P t (U - {x}) F (ps0, qs0)\n\ngoal (5 subgoals):\n 1. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> V' \\<subseteq> U\n 2. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> F \\<inter> .[V'] = {}\n 3. x = (SOME x'. x' \\<in> U - S)\n 4. split t U F = (ps0 @ ps1, qs0 @ qs1)\n 5. P (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F) (ps1, qs1)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> V' \\<subseteq> U\n 2. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> F \\<inter> .[V'] = {}\n 3. x = (SOME x'. x' \\<in> U - S)\n 4. split t U F = (ps0 @ ps1, qs0 @ qs1)\n 5. P (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F) (ps1, qs1)", "show \"P (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` F) (ps1, qs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F) (ps1, qs1)", "unfolding PQ1"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F)\n     (split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F))", "using \\<open>0 \\<notin> F\\<close> \\<open>F \\<inter> .[U] \\<noteq> {}\\<close> _ refl PQ0 \\<open>U \\<subseteq> X\\<close>"], ["proof (prove)\nusing this:\n  0 \\<notin> F\n  F \\<inter> .[U] \\<noteq> {}\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?t = ?t\n  (ps0, qs0) = split t (U - {x}) F\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. P (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F)\n     (split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F))", "proof (rule step(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. x =\n    (SOME x'. x' \\<in> U - max_subset U (\\<lambda>V. F \\<inter> .[V] = {}))\n 2. finite ((\\<lambda>f. f - monomial 1 x) ` F)", "from \\<open>finite F\\<close>"], ["proof (chain)\npicking this:\n  finite F", "show \"finite ((\\<lambda>f. f - Poly_Mapping.single x 1) ` F)\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>f. f - monomial 1 x) ` F)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite ((\\<lambda>f. f - monomial 1 x) ` F)\n\ngoal (1 subgoal):\n 1. x =\n    (SOME x'. x' \\<in> U - max_subset U (\\<lambda>V. F \\<inter> .[V] = {}))", "qed (simp add: x_def S_def)"], ["proof (state)\nthis:\n  P (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` F) (ps1, qs1)\n\ngoal (4 subgoals):\n 1. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> V' \\<subseteq> U\n 2. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> F \\<inter> .[V'] = {}\n 3. x = (SOME x'. x' \\<in> U - S)\n 4. split t U F = (ps0 @ ps1, qs0 @ qs1)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> V' \\<subseteq> U\n 2. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> F \\<inter> .[V'] = {}\n 3. x = (SOME x'. x' \\<in> U - S)\n 4. split t U F = (ps0 @ ps1, qs0 @ qs1)", "show \"split t U F = (ps0 @ ps1, qs0 @ qs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split t U F = (ps0 @ ps1, qs0 @ qs1)", "using \\<open>0 \\<notin> F\\<close> \\<open>F \\<inter> .[U] \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  0 \\<notin> F\n  F \\<inter> .[U] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. split t U F = (ps0 @ ps1, qs0 @ qs1)", "by (simp add: split.psimps[OF step(1)] Let_def flip: S_def x_def PQ0 PQ1 del: One_nat_def)"], ["proof (state)\nthis:\n  split t U F = (ps0 @ ps1, qs0 @ qs1)\n\ngoal (3 subgoals):\n 1. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> V' \\<subseteq> U\n 2. \\<And>V'.\n       \\<lbrakk>V' \\<subseteq> U; F \\<inter> .[V'] = {}\\<rbrakk>\n       \\<Longrightarrow> F \\<inter> .[V'] = {}\n 3. x = (SOME x'. x' \\<in> U - S)", "qed (assumption+, simp add: x_def S_def)"], ["proof (state)\nthis:\n  P t U F (ps0 @ ps1, qs0 @ qs1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P t U F (split t U F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P t U S (split t U S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_decomp_split:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"t \\<in> .[X]\"\n  shows \"valid_decomp X (fst ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n    and \"valid_decomp X (snd ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n          (is \"valid_decomp _ (snd ?s)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (fst (split t U S)) &&&\n    valid_decomp X (snd (split t U S))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. valid_decomp X (fst (split t U S))\n 2. valid_decomp X (snd (split t U S))", "from assms"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  t \\<in> .[X]", "have \"valid_decomp X (fst ?s) \\<and> valid_decomp X (snd ?s)\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (fst (split t U S)) \\<and>\n    valid_decomp X (snd (split t U S))", "proof (induct t U S rule: split_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X\n                          (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n                         valid_decomp X\n                          (snd ([(monomial (1::'a) t, U)], []))\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         valid_decomp X\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "case (base1 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<in> S\n  t \\<in> .[X]\n\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X\n                          (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n                         valid_decomp X\n                          (snd ([(monomial (1::'a) t, U)], []))\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         valid_decomp X\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "from base1(1, 4)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  t \\<in> .[X]", "show ?case"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n    valid_decomp X (snd ([(monomial (1::'a) t, U)], []))", "by (simp add: valid_decomp_def monomial_0_iff Polys_closed_monomial)"], ["proof (state)\nthis:\n  valid_decomp X (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n  valid_decomp X (snd ([(monomial (1::'a) t, U)], []))\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         valid_decomp X\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         valid_decomp X\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "case (base2 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] = {}\n  t \\<in> .[X]\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         valid_decomp X\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "from base2(1, 5)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  t \\<in> .[X]", "show ?case"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n    valid_decomp X (snd ([], [(monomial (1::'a) t, U)]))", "by (simp add: valid_decomp_def monomial_0_iff Polys_closed_monomial)"], ["proof (state)\nthis:\n  valid_decomp X (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n  valid_decomp X (snd ([], [(monomial (1::'a) t, U)]))\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "case (step t U S V x ps0 ps1 qs0 qs1)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] \\<noteq> {}\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>?V'19 \\<subseteq> U; S \\<inter> .[?V'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?V'19 \\<le> card V\n  x \\<in> U\n  x \\<notin> V\n  V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {})\n  x = (SOME x'. x' \\<in> U - V)\n  (ps0, qs0) = split t (U - {x}) S\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S)\n  split t U S = (ps0 @ ps1, qs0 @ qs1)\n  t \\<in> .[X] \\<Longrightarrow>\n  valid_decomp X (fst (ps0, qs0)) \\<and> valid_decomp X (snd (ps0, qs0))\n  monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n  valid_decomp X (fst (ps1, qs1)) \\<and> valid_decomp X (snd (ps1, qs1))\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "from step.hyps(8, 1)"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<subseteq> X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", ".."], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "hence \"Poly_Mapping.single x 1 \\<in> .[X]\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. monomial 1 x \\<in> .[X]", "by (rule PPs_closed_single)"], ["proof (state)\nthis:\n  monomial 1 x \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "hence \"Poly_Mapping.single x 1 + t \\<in> .[X]\""], ["proof (prove)\nusing this:\n  monomial 1 x \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial 1 x + t \\<in> .[X]", "using step.prems"], ["proof (prove)\nusing this:\n  monomial 1 x \\<in> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial 1 x + t \\<in> .[X]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  monomial 1 x + t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps0, qs0)) \\<and>\n        valid_decomp X (snd (ps0, qs0));\n        monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n        valid_decomp X (fst (ps1, qs1)) \\<and>\n        valid_decomp X (snd (ps1, qs1));\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "with step.hyps(15, 16) step.prems"], ["proof (chain)\npicking this:\n  t \\<in> .[X] \\<Longrightarrow>\n  valid_decomp X (fst (ps0, qs0)) \\<and> valid_decomp X (snd (ps0, qs0))\n  monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n  valid_decomp X (fst (ps1, qs1)) \\<and> valid_decomp X (snd (ps1, qs1))\n  t \\<in> .[X]\n  monomial 1 x + t \\<in> .[X]", "show ?case"], ["proof (prove)\nusing this:\n  t \\<in> .[X] \\<Longrightarrow>\n  valid_decomp X (fst (ps0, qs0)) \\<and> valid_decomp X (snd (ps0, qs0))\n  monomial 1 x + t \\<in> .[X] \\<Longrightarrow>\n  valid_decomp X (fst (ps1, qs1)) \\<and> valid_decomp X (snd (ps1, qs1))\n  t \\<in> .[X]\n  monomial 1 x + t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n    valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))", "by (simp add: valid_decomp_append)"], ["proof (state)\nthis:\n  valid_decomp X (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n  valid_decomp X (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_decomp X (fst (split t U S)) \\<and>\n  valid_decomp X (snd (split t U S))\n\ngoal (2 subgoals):\n 1. valid_decomp X (fst (split t U S))\n 2. valid_decomp X (snd (split t U S))", "thus \"valid_decomp X (fst ?s)\" and \"valid_decomp X (snd ?s)\""], ["proof (prove)\nusing this:\n  valid_decomp X (fst (split t U S)) \\<and>\n  valid_decomp X (snd (split t U S))\n\ngoal (1 subgoal):\n 1. valid_decomp X (fst (split t U S)) &&&\n    valid_decomp X (snd (split t U S))", "by simp_all"], ["proof (state)\nthis:\n  valid_decomp X (fst (split t U S))\n  valid_decomp X (snd (split t U S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decomp_split:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\"\n  shows \"monomial_decomp (fst ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n    and \"monomial_decomp (snd ((split t U S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a::zero_neq_one) \\<times> _) list))))\"\n          (is \"monomial_decomp (snd ?s)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (fst (split t U S)) &&&\n    monomial_decomp (snd (split t U S))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. monomial_decomp (fst (split t U S))\n 2. monomial_decomp (snd (split t U S))", "from assms"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite S", "have \"monomial_decomp (fst ?s) \\<and> monomial_decomp (snd ?s)\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst (split t U S)) \\<and>\n    monomial_decomp (snd (split t U S))", "proof (induct t U S rule: split_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n                         monomial_decomp\n                          (snd ([(monomial (1::'a) t, U)], []))\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         monomial_decomp\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "case (base1 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n                         monomial_decomp\n                          (snd ([(monomial (1::'a) t, U)], []))\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         monomial_decomp\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "from base1(1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n    monomial_decomp (snd ([(monomial (1::'a) t, U)], []))", "by (simp add: monomial_decomp_def monomial_is_monomial)"], ["proof (state)\nthis:\n  monomial_decomp (fst ([(monomial (1::'a) t, U)], [])) \\<and>\n  monomial_decomp (snd ([(monomial (1::'a) t, U)], []))\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         monomial_decomp\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         monomial_decomp\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "case (base2 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] = {}\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n                         monomial_decomp\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "from base2(1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n    monomial_decomp (snd ([], [(monomial (1::'a) t, U)]))", "by (simp add: monomial_decomp_def monomial_is_monomial)"], ["proof (state)\nthis:\n  monomial_decomp (fst ([], [(monomial (1::'a) t, U)])) \\<and>\n  monomial_decomp (snd ([], [(monomial (1::'a) t, U)]))\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "case (step t U S V x ps0 ps1 qs0 qs1)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] \\<noteq> {}\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>?V'19 \\<subseteq> U; S \\<inter> .[?V'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?V'19 \\<le> card V\n  x \\<in> U\n  x \\<notin> V\n  V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {})\n  x = (SOME x'. x' \\<in> U - V)\n  (ps0, qs0) = split t (U - {x}) S\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S)\n  split t U S = (ps0 @ ps1, qs0 @ qs1)\n  monomial_decomp (fst (ps0, qs0)) \\<and> monomial_decomp (snd (ps0, qs0))\n  monomial_decomp (fst (ps1, qs1)) \\<and> monomial_decomp (snd (ps1, qs1))\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        monomial_decomp (fst (ps0, qs0)) \\<and>\n        monomial_decomp (snd (ps0, qs0));\n        monomial_decomp (fst (ps1, qs1)) \\<and>\n        monomial_decomp (snd (ps1, qs1))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n                         monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "from step.hyps(15, 16)"], ["proof (chain)\npicking this:\n  monomial_decomp (fst (ps0, qs0)) \\<and> monomial_decomp (snd (ps0, qs0))\n  monomial_decomp (fst (ps1, qs1)) \\<and> monomial_decomp (snd (ps1, qs1))", "show ?case"], ["proof (prove)\nusing this:\n  monomial_decomp (fst (ps0, qs0)) \\<and> monomial_decomp (snd (ps0, qs0))\n  monomial_decomp (fst (ps1, qs1)) \\<and> monomial_decomp (snd (ps1, qs1))\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n    monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))", "by (auto simp: monomial_decomp_def)"], ["proof (state)\nthis:\n  monomial_decomp (fst (ps0 @ ps1, qs0 @ qs1)) \\<and>\n  monomial_decomp (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial_decomp (fst (split t U S)) \\<and>\n  monomial_decomp (snd (split t U S))\n\ngoal (2 subgoals):\n 1. monomial_decomp (fst (split t U S))\n 2. monomial_decomp (snd (split t U S))", "thus \"monomial_decomp (fst ?s)\" and \"monomial_decomp (snd ?s)\""], ["proof (prove)\nusing this:\n  monomial_decomp (fst (split t U S)) \\<and>\n  monomial_decomp (snd (split t U S))\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst (split t U S)) &&&\n    monomial_decomp (snd (split t U S))", "by simp_all"], ["proof (state)\nthis:\n  monomial_decomp (fst (split t U S))\n  monomial_decomp (snd (split t U S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_splits_wrt:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"t \\<in> .[X]\"\n    and \"ideal F \\<div> monomial 1 t = ideal (monomial 1 ` S)\"\n  shows \"splits_wrt (split t U S) (cone (monomial (1::'a::{comm_ring_1,ring_no_zero_divisors}) t, U)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt (split t U S) (cone (monomial (1::'a) t, U)) F", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. splits_wrt (split t U S) (cone (monomial (1::'a) t, U)) F", "proof (induct t U S rule: split_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([(monomial (1::'a) t, U)], [])\n                          (cone (monomial (1::'a) t, U)) F\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([], [(monomial (1::'a) t, U)])\n                          (cone (monomial (1::'a) t, U)) F\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "case (base1 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<in> S\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([(monomial (1::'a) t, U)], [])\n                          (cone (monomial (1::'a) t, U)) F\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([], [(monomial (1::'a) t, U)])\n                          (cone (monomial (1::'a) t, U)) F\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "from base1(3)"], ["proof (chain)\npicking this:\n  0 \\<in> S", "have \"cone (monomial 1 t, U) \\<subseteq> ideal F\""], ["proof (prove)\nusing this:\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "by (simp only: lem_4_2_1 base1(5))"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<subseteq> ideal F\n\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([(monomial (1::'a) t, U)], [])\n                          (cone (monomial (1::'a) t, U)) F\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([], [(monomial (1::'a) t, U)])\n                          (cone (monomial (1::'a) t, U)) F\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt ([(monomial (1::'a) t, U)], [])\n     (cone (monomial (1::'a) t, U)) F", "proof (rule splits_wrtI)"], ["proof (state)\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "fix h0 U0"], ["proof (state)\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "assume \"(h0, U0) \\<in> set [(monomial (1::'a) t, U)]\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set [(monomial (1::'a) t, U)]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence h0: \"h0 = monomial 1 t\" and \"U0 = U\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set [(monomial (1::'a) t, U)]\n\ngoal (1 subgoal):\n 1. h0 = monomial (1::'a) t &&& U0 = U", "by simp_all"], ["proof (state)\nthis:\n  h0 = monomial (1::'a) t\n  U0 = U\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "note this(1)"], ["proof (state)\nthis:\n  h0 = monomial (1::'a) t\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "also"], ["proof (state)\nthis:\n  h0 = monomial (1::'a) t\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "have \"monomial 1 t \\<in> cone (monomial (1::'a) t, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)", "by (fact tip_in_cone)"], ["proof (state)\nthis:\n  monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "also"], ["proof (state)\nthis:\n  monomial (1::'a) t \\<in> cone (monomial (1::'a) t, U)\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "have \"\\<dots> \\<subseteq> ideal F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t, U) \\<subseteq> ideal F", "by fact"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<subseteq> ideal F\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "finally"], ["proof (chain)\npicking this:\n  h0 \\<in> ideal F", "show \"h0 \\<in> ideal F\""], ["proof (prove)\nusing this:\n  h0 \\<in> ideal F\n\ngoal (1 subgoal):\n 1. h0 \\<in> ideal F", "."], ["proof (state)\nthis:\n  h0 \\<in> ideal F\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from base1(4)"], ["proof (chain)\npicking this:\n  t \\<in> .[X]", "have \"h0 \\<in> P[X]\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. h0 \\<in> P[X]", "unfolding h0"], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) t \\<in> P[X]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  h0 \\<in> P[X]\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "moreover"], ["proof (state)\nthis:\n  h0 \\<in> P[X]\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from base1(1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "have \"U0 \\<subseteq> X\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U0 \\<subseteq> X", "by (simp only: \\<open>U0 = U\\<close>)"], ["proof (state)\nthis:\n  U0 \\<subseteq> X\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "ultimately"], ["proof (chain)\npicking this:\n  h0 \\<in> P[X]\n  U0 \\<subseteq> X", "show \"cone (h0, U0) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  h0 \\<in> P[X]\n  U0 \\<subseteq> X\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> P[X]", "by (rule cone_subset_PolysI)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal (3 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([(monomial (1::'a) t, U)] @ [])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set []; a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "qed (simp_all add: cone_decomp_singleton \\<open>U \\<subseteq> X\\<close>)"], ["proof (state)\nthis:\n  splits_wrt ([(monomial (1::'a) t, U)], []) (cone (monomial (1::'a) t, U))\n   F\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([], [(monomial (1::'a) t, U)])\n                          (cone (monomial (1::'a) t, U)) F\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([], [(monomial (1::'a) t, U)])\n                          (cone (monomial (1::'a) t, U)) F\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "case (base2 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] = {}\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([], [(monomial (1::'a) t, U)])\n                          (cone (monomial (1::'a) t, U)) F\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "from base2(4)"], ["proof (chain)\npicking this:\n  S \\<inter> .[U] = {}", "have \"cone (monomial 1 t, U) \\<inter> ideal F = {0}\""], ["proof (prove)\nusing this:\n  S \\<inter> .[U] = {}\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "by (simp only: lem_4_2_2 base2(6))"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt ([], [(monomial (1::'a) t, U)])\n                          (cone (monomial (1::'a) t, U)) F\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt ([], [(monomial (1::'a) t, U)])\n     (cone (monomial (1::'a) t, U)) F", "proof (rule splits_wrtI)"], ["proof (state)\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "fix h0 U0"], ["proof (state)\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "assume \"(h0, U0) \\<in> set [(monomial (1::'a) t, U)]\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set [(monomial (1::'a) t, U)]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence h0: \"h0 = monomial 1 t\" and \"U0 = U\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set [(monomial (1::'a) t, U)]\n\ngoal (1 subgoal):\n 1. h0 = monomial (1::'a) t &&& U0 = U", "by simp_all"], ["proof (state)\nthis:\n  h0 = monomial (1::'a) t\n  U0 = U\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "note this(1)"], ["proof (state)\nthis:\n  h0 = monomial (1::'a) t\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "also"], ["proof (state)\nthis:\n  h0 = monomial (1::'a) t\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from base2(5)"], ["proof (chain)\npicking this:\n  t \\<in> .[X]", "have \"monomial 1 t \\<in> P[X]\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> P[X]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::?'b20) t \\<in> P[X]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "finally"], ["proof (chain)\npicking this:\n  h0 \\<in> P[X]", "have \"h0 \\<in> P[X]\""], ["proof (prove)\nusing this:\n  h0 \\<in> P[X]\n\ngoal (1 subgoal):\n 1. h0 \\<in> P[X]", "."], ["proof (state)\nthis:\n  h0 \\<in> P[X]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "moreover"], ["proof (state)\nthis:\n  h0 \\<in> P[X]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from base2(1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "have \"U0 \\<subseteq> X\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U0 \\<subseteq> X", "by (simp only: \\<open>U0 = U\\<close>)"], ["proof (state)\nthis:\n  U0 \\<subseteq> X\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set [(monomial (1::'a) t, U)] \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "ultimately"], ["proof (chain)\npicking this:\n  h0 \\<in> P[X]\n  U0 \\<subseteq> X", "show \"cone (h0, U0) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  h0 \\<in> P[X]\n  U0 \\<subseteq> X\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> P[X]", "by (rule cone_subset_PolysI)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "fix h0 U0 a"], ["proof (state)\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "assume \"(h0, U0) \\<in> set [(monomial (1::'a) t, U)]\" and \"a \\<in> cone (h0, U0)\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set [(monomial (1::'a) t, U)]\n  a \\<in> cone (h0, U0)\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence \"a \\<in> cone (monomial 1 t, U)\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set [(monomial (1::'a) t, U)]\n  a \\<in> cone (h0, U0)\n\ngoal (1 subgoal):\n 1. a \\<in> cone (monomial (1::'a) t, U)", "by simp"], ["proof (state)\nthis:\n  a \\<in> cone (monomial (1::'a) t, U)\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "moreover"], ["proof (state)\nthis:\n  a \\<in> cone (monomial (1::'a) t, U)\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "assume \"a \\<in> ideal F\""], ["proof (state)\nthis:\n  a \\<in> ideal F\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> cone (monomial (1::'a) t, U)\n  a \\<in> ideal F", "have \"a \\<in> cone (monomial 1 t, U) \\<inter> ideal F\""], ["proof (prove)\nusing this:\n  a \\<in> cone (monomial (1::'a) t, U)\n  a \\<in> ideal F\n\ngoal (1 subgoal):\n 1. a \\<in> cone (monomial (1::'a) t, U) \\<inter> ideal F", "by (rule IntI)"], ["proof (state)\nthis:\n  a \\<in> cone (monomial (1::'a) t, U) \\<inter> ideal F\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "also"], ["proof (state)\nthis:\n  a \\<in> cone (monomial (1::'a) t, U) \\<inter> ideal F\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "have \"\\<dots> = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}", "by fact"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t, U) \\<inter> ideal F = {0}\n\ngoal (4 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set [(monomial (1::'a) t, U)];\n        a \\<in> cone (h, U); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "finally"], ["proof (chain)\npicking this:\n  a \\<in> {0}", "show \"a = 0\""], ["proof (prove)\nusing this:\n  a \\<in> {0}\n\ngoal (1 subgoal):\n 1. a = 0", "by simp"], ["proof (state)\nthis:\n  a = 0\n\ngoal (3 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U))\n     ([] @ [(monomial (1::'a) t, U)])\n 2. \\<And>h U.\n       (h, U) \\<in> set [] \\<Longrightarrow> cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U. (h, U) \\<in> set [] \\<Longrightarrow> h \\<in> ideal F", "qed (simp_all add: cone_decomp_singleton \\<open>U \\<subseteq> X\\<close>)"], ["proof (state)\nthis:\n  splits_wrt ([], [(monomial (1::'a) t, U)]) (cone (monomial (1::'a) t, U))\n   F\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "case (step t U S V x ps0 ps1 qs0 qs1)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] \\<noteq> {}\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>?V'19 \\<subseteq> U; S \\<inter> .[?V'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?V'19 \\<le> card V\n  x \\<in> U\n  x \\<notin> V\n  V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {})\n  x = (SOME x'. x' \\<in> U - V)\n  (ps0, qs0) = split t (U - {x}) S\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S)\n  split t U S = (ps0 @ ps1, qs0 @ qs1)\n  \\<lbrakk>t \\<in> .[X];\n   ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\\<rbrakk>\n  \\<Longrightarrow> splits_wrt (ps0, qs0)\n                     (cone (monomial (1::'a) t, U - {x})) F\n  \\<lbrakk>monomial 1 x + t \\<in> .[X];\n   ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n   ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n  \\<Longrightarrow> splits_wrt (ps1, qs1)\n                     (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "let ?x = \"Poly_Mapping.single x 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "from step.prems"], ["proof (chain)\npicking this:\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)", "have 0: \"splits_wrt (ps0, qs0) (cone (monomial 1 t, U - {x})) F\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F", "by (rule step.hyps)"], ["proof (state)\nthis:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "have 1: \"splits_wrt (ps1, qs1) (cone (monomial 1 (?x + t), U)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F", "proof (rule step.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. monomial 1 x + t \\<in> .[X]\n 2. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "from step.hyps(8, 1)"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<subseteq> X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", ".."], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. monomial 1 x + t \\<in> .[X]\n 2. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "hence \"?x \\<in> .[X]\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. monomial 1 x \\<in> .[X]", "by (rule PPs_closed_single)"], ["proof (state)\nthis:\n  monomial 1 x \\<in> .[X]\n\ngoal (2 subgoals):\n 1. monomial 1 x + t \\<in> .[X]\n 2. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "thus \"?x + t \\<in> .[X]\""], ["proof (prove)\nusing this:\n  monomial 1 x \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial 1 x + t \\<in> .[X]", "using step.prems(1)"], ["proof (prove)\nusing this:\n  monomial 1 x \\<in> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial 1 x + t \\<in> .[X]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  monomial 1 x + t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "have \"ideal F \\<div> monomial 1 (?x + t) = ideal F \\<div> monomial 1 t \\<div> monomial 1 ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal F \\<div> monomial (1::'a) t \\<div> monomial (1::'a) (monomial 1 x)", "by (simp add: times_monomial_monomial add.commute)"], ["proof (state)\nthis:\n  ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n  ideal F \\<div> monomial (1::'a) t \\<div> monomial (1::'a) (monomial 1 x)\n\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "also"], ["proof (state)\nthis:\n  ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n  ideal F \\<div> monomial (1::'a) t \\<div> monomial (1::'a) (monomial 1 x)\n\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "have \"\\<dots> = ideal (monomial 1 ` S) \\<div> monomial 1 ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) t \\<div>\n    monomial (1::'a) (monomial 1 x) =\n    ideal (monomial (1::'a) ` S) \\<div> monomial (1::'a) (monomial 1 x)", "by (simp only: step.prems)"], ["proof (state)\nthis:\n  ideal F \\<div> monomial (1::'a) t \\<div> monomial (1::'a) (monomial 1 x) =\n  ideal (monomial (1::'a) ` S) \\<div> monomial (1::'a) (monomial 1 x)\n\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)", "finally"], ["proof (chain)\npicking this:\n  ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n  ideal (monomial (1::'a) ` S) \\<div> monomial (1::'a) (monomial 1 x)", "show \"ideal F \\<div> monomial 1 (?x + t) = ideal (monomial 1 ` (\\<lambda>s. s - ?x) ` S)\""], ["proof (prove)\nusing this:\n  ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n  ideal (monomial (1::'a) ` S) \\<div> monomial (1::'a) (monomial 1 x)\n\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n    ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)", "by (simp only: quot_monomial_ideal_monomial)"], ["proof (state)\nthis:\n  ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n  ideal (monomial (1::'a) ` (\\<lambda>s. s - monomial 1 x) ` S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) t =\n         ideal (monomial (1::'a) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps0, qs0)\n                           (cone (monomial (1::'a) t, U - {x})) F;\n        \\<lbrakk>monomial 1 x + t \\<in> .[X];\n         ideal F \\<div> monomial (1::'a) (monomial 1 x + t) =\n         ideal\n          (monomial (1::'a) ` (\\<lambda>f. f - monomial 1 x) ` S)\\<rbrakk>\n        \\<Longrightarrow> splits_wrt (ps1, qs1)\n                           (cone (monomial (1::'a) (monomial 1 x + t), U))\n                           F;\n        t \\<in> .[X];\n        ideal F \\<div> monomial (1::'a) t =\n        ideal (monomial (1::'a) ` S)\\<rbrakk>\n       \\<Longrightarrow> splits_wrt (ps0 @ ps1, qs0 @ qs1)\n                          (cone (monomial (1::'a) t, U)) F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial (1::'a) t, U)) F", "proof (rule splits_wrtI)"], ["proof (state)\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from step.hyps(8)"], ["proof (chain)\npicking this:\n  x \\<in> U", "have U: \"insert x U = U\""], ["proof (prove)\nusing this:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. insert x U = U", "by blast"], ["proof (state)\nthis:\n  insert x U = U\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "have \"direct_decomp (cone (monomial (1::'a) t, insert x (U - {x})))\n                      [cone (monomial 1 t, U - {x}),\n                       cone (monomial 1 (monomial (Suc 0) x) * monomial 1 t, insert x (U - {x}))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (cone (monomial (1::'a) t, insert x (U - {x})))\n     [cone (monomial (1::'a) t, U - {x}),\n      cone\n       (monomial (1::'a) (monomial (Suc 0) x) * monomial (1::'a) t,\n        insert x (U - {x}))]", "by (rule direct_decomp_cone_insert) simp"], ["proof (state)\nthis:\n  direct_decomp (cone (monomial (1::'a) t, insert x (U - {x})))\n   [cone (monomial (1::'a) t, U - {x}),\n    cone\n     (monomial (1::'a) (monomial (Suc 0) x) * monomial (1::'a) t,\n      insert x (U - {x}))]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence \"direct_decomp (cone (monomial (1::'a) t, U))\n                      [cone (monomial 1 t, U - {x}), cone (monomial 1 (?x + t), U)]\""], ["proof (prove)\nusing this:\n  direct_decomp (cone (monomial (1::'a) t, insert x (U - {x})))\n   [cone (monomial (1::'a) t, U - {x}),\n    cone\n     (monomial (1::'a) (monomial (Suc 0) x) * monomial (1::'a) t,\n      insert x (U - {x}))]\n\ngoal (1 subgoal):\n 1. direct_decomp (cone (monomial (1::'a) t, U))\n     [cone (monomial (1::'a) t, U - {x}),\n      cone (monomial (1::'a) (monomial 1 x + t), U)]", "by (simp add: U times_monomial_monomial)"], ["proof (state)\nthis:\n  direct_decomp (cone (monomial (1::'a) t, U))\n   [cone (monomial (1::'a) t, U - {x}),\n    cone (monomial (1::'a) (monomial 1 x + t), U)]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "moreover"], ["proof (state)\nthis:\n  direct_decomp (cone (monomial (1::'a) t, U))\n   [cone (monomial (1::'a) t, U - {x}),\n    cone (monomial (1::'a) (monomial 1 x + t), U)]\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from 0"], ["proof (chain)\npicking this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F", "have \"cone_decomp (cone (monomial 1 t, U - {x})) (ps0 @ qs0)\""], ["proof (prove)\nusing this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (monomial (1::'a) t, U - {x})) (ps0 @ qs0)", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone_decomp (cone (monomial (1::'a) t, U - {x})) (ps0 @ qs0)\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "moreover"], ["proof (state)\nthis:\n  cone_decomp (cone (monomial (1::'a) t, U - {x})) (ps0 @ qs0)\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from 1"], ["proof (chain)\npicking this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F", "have \"cone_decomp (cone (monomial 1 (?x + t), U)) (ps1 @ qs1)\""], ["proof (prove)\nusing this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (monomial (1::'a) (monomial 1 x + t), U)) (ps1 @ qs1)", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone_decomp (cone (monomial (1::'a) (monomial 1 x + t), U)) (ps1 @ qs1)\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "ultimately"], ["proof (chain)\npicking this:\n  direct_decomp (cone (monomial (1::'a) t, U))\n   [cone (monomial (1::'a) t, U - {x}),\n    cone (monomial (1::'a) (monomial 1 x + t), U)]\n  cone_decomp (cone (monomial (1::'a) t, U - {x})) (ps0 @ qs0)\n  cone_decomp (cone (monomial (1::'a) (monomial 1 x + t), U)) (ps1 @ qs1)", "have \"cone_decomp (cone (monomial 1 t, U)) ((ps0 @ qs0) @ (ps1 @ qs1))\""], ["proof (prove)\nusing this:\n  direct_decomp (cone (monomial (1::'a) t, U))\n   [cone (monomial (1::'a) t, U - {x}),\n    cone (monomial (1::'a) (monomial 1 x + t), U)]\n  cone_decomp (cone (monomial (1::'a) t, U - {x})) (ps0 @ qs0)\n  cone_decomp (cone (monomial (1::'a) (monomial 1 x + t), U)) (ps1 @ qs1)\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ qs0) @ ps1 @ qs1)", "by (rule cone_decomp_append)"], ["proof (state)\nthis:\n  cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ qs0) @ ps1 @ qs1)\n\ngoal (5 subgoals):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 4. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 5. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "thus \"cone_decomp (cone (monomial 1 t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ qs0) @ ps1 @ qs1)\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)", "by (rule cone_decomp_perm) (metis append.assoc perm_append1 perm_append2 perm_append_swap)"], ["proof (state)\nthis:\n  cone_decomp (cone (monomial (1::'a) t, U)) ((ps0 @ ps1) @ qs0 @ qs1)\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "fix h0 U0"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "assume \"(h0, U0) \\<in> set (ps0 @ ps1)\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set (ps0 @ ps1)\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence \"(h0, U0) \\<in> set ps0 \\<union> set ps1\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set (ps0 @ ps1)\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set ps0 \\<union> set ps1", "by simp"], ["proof (state)\nthis:\n  (h0, U0) \\<in> set ps0 \\<union> set ps1\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence \"cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set ps0 \\<union> set ps1\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (h0, U0) \\<in> set ps0 \\<Longrightarrow>\n    cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]\n 2. (h0, U0) \\<in> set ps1 \\<Longrightarrow>\n    cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "assume \"(h0, U0) \\<in> set ps0\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set ps0\n\ngoal (2 subgoals):\n 1. (h0, U0) \\<in> set ps0 \\<Longrightarrow>\n    cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]\n 2. (h0, U0) \\<in> set ps1 \\<Longrightarrow>\n    cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "with 0"], ["proof (chain)\npicking this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n  (h0, U0) \\<in> set ps0", "show ?thesis"], ["proof (prove)\nusing this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n  (h0, U0) \\<in> set ps0\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set ps1 \\<Longrightarrow>\n    cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set ps1 \\<Longrightarrow>\n    cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "assume \"(h0, U0) \\<in> set ps1\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set ps1\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set ps1 \\<Longrightarrow>\n    cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "with 1"], ["proof (chain)\npicking this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n  (h0, U0) \\<in> set ps1", "show ?thesis"], ["proof (prove)\nusing this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n  (h0, U0) \\<in> set ps1\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence *: \"cone (h0, U0) \\<subseteq> ideal F\" and \"cone (h0, U0) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  cone (h0, U0) \\<subseteq> ideal F \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> ideal F &&& cone (h0, U0) \\<subseteq> P[X]", "by simp_all"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> ideal F\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal (4 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 3. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 4. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from this(2)"], ["proof (chain)\npicking this:\n  cone (h0, U0) \\<subseteq> P[X]", "show \"cone (h0, U0) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> P[X]", "."], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (ps0 @ ps1) \\<Longrightarrow> h \\<in> ideal F\n 2. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 3. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from tip_in_cone *"], ["proof (chain)\npicking this:\n  ?h \\<in> cone (?h, ?U)\n  cone (h0, U0) \\<subseteq> ideal F", "show \"h0 \\<in> ideal F\""], ["proof (prove)\nusing this:\n  ?h \\<in> cone (?h, ?U)\n  cone (h0, U0) \\<subseteq> ideal F\n\ngoal (1 subgoal):\n 1. h0 \\<in> ideal F", ".."], ["proof (state)\nthis:\n  h0 \\<in> ideal F\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "fix h0 U0"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "assume \"(h0, U0) \\<in> set (qs0 @ qs1)\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set (qs0 @ qs1)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "hence \"(h0, U0) \\<in> set qs0 \\<union> set qs1\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set qs0 \\<union> set qs1", "by simp"], ["proof (state)\nthis:\n  (h0, U0) \\<in> set qs0 \\<union> set qs1\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (qs0 @ qs1) \\<Longrightarrow>\n       cone (h, U) \\<subseteq> P[X]\n 2. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "thus \"cone (h0, U0) \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set qs0 \\<union> set qs1\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> P[X]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (h0, U0) \\<in> set qs0 \\<Longrightarrow> cone (h0, U0) \\<subseteq> P[X]\n 2. (h0, U0) \\<in> set qs1 \\<Longrightarrow> cone (h0, U0) \\<subseteq> P[X]", "assume \"(h0, U0) \\<in> set qs0\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set qs0\n\ngoal (2 subgoals):\n 1. (h0, U0) \\<in> set qs0 \\<Longrightarrow> cone (h0, U0) \\<subseteq> P[X]\n 2. (h0, U0) \\<in> set qs1 \\<Longrightarrow> cone (h0, U0) \\<subseteq> P[X]", "with 0"], ["proof (chain)\npicking this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n  (h0, U0) \\<in> set qs0", "show ?thesis"], ["proof (prove)\nusing this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n  (h0, U0) \\<in> set qs0\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> P[X]", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set qs1 \\<Longrightarrow> cone (h0, U0) \\<subseteq> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set qs1 \\<Longrightarrow> cone (h0, U0) \\<subseteq> P[X]", "assume \"(h0, U0) \\<in> set qs1\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set qs1\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set qs1 \\<Longrightarrow> cone (h0, U0) \\<subseteq> P[X]", "with 1"], ["proof (chain)\npicking this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n  (h0, U0) \\<in> set qs1", "show ?thesis"], ["proof (prove)\nusing this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n  (h0, U0) \\<in> set qs1\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<subseteq> P[X]", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone (h0, U0) \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "from \\<open>(h0, U0) \\<in> set qs0 \\<union> set qs1\\<close>"], ["proof (chain)\npicking this:\n  (h0, U0) \\<in> set qs0 \\<union> set qs1", "have \"cone (h0, U0) \\<inter> ideal F = {0}\""], ["proof (prove)\nusing this:\n  (h0, U0) \\<in> set qs0 \\<union> set qs1\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<inter> ideal F = {0}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (h0, U0) \\<in> set qs0 \\<Longrightarrow>\n    cone (h0, U0) \\<inter> ideal F = {0}\n 2. (h0, U0) \\<in> set qs1 \\<Longrightarrow>\n    cone (h0, U0) \\<inter> ideal F = {0}", "assume \"(h0, U0) \\<in> set qs0\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set qs0\n\ngoal (2 subgoals):\n 1. (h0, U0) \\<in> set qs0 \\<Longrightarrow>\n    cone (h0, U0) \\<inter> ideal F = {0}\n 2. (h0, U0) \\<in> set qs1 \\<Longrightarrow>\n    cone (h0, U0) \\<inter> ideal F = {0}", "with 0"], ["proof (chain)\npicking this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n  (h0, U0) \\<in> set qs0", "show ?thesis"], ["proof (prove)\nusing this:\n  splits_wrt (ps0, qs0) (cone (monomial (1::'a) t, U - {x})) F\n  (h0, U0) \\<in> set qs0\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<inter> ideal F = {0}", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<inter> ideal F = {0}\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set qs1 \\<Longrightarrow>\n    cone (h0, U0) \\<inter> ideal F = {0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set qs1 \\<Longrightarrow>\n    cone (h0, U0) \\<inter> ideal F = {0}", "assume \"(h0, U0) \\<in> set qs1\""], ["proof (state)\nthis:\n  (h0, U0) \\<in> set qs1\n\ngoal (1 subgoal):\n 1. (h0, U0) \\<in> set qs1 \\<Longrightarrow>\n    cone (h0, U0) \\<inter> ideal F = {0}", "with 1"], ["proof (chain)\npicking this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n  (h0, U0) \\<in> set qs1", "show ?thesis"], ["proof (prove)\nusing this:\n  splits_wrt (ps1, qs1) (cone (monomial (1::'a) (monomial 1 x + t), U)) F\n  (h0, U0) \\<in> set qs1\n\ngoal (1 subgoal):\n 1. cone (h0, U0) \\<inter> ideal F = {0}", "by (rule splits_wrtD)"], ["proof (state)\nthis:\n  cone (h0, U0) \\<inter> ideal F = {0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone (h0, U0) \\<inter> ideal F = {0}\n\ngoal (1 subgoal):\n 1. \\<And>h U a.\n       \\<lbrakk>(h, U) \\<in> set (qs0 @ qs1); a \\<in> cone (h, U);\n        a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "thus \"\\<And>a. a \\<in> cone (h0, U0) \\<Longrightarrow> a \\<in> ideal F \\<Longrightarrow> a = 0\""], ["proof (prove)\nusing this:\n  cone (h0, U0) \\<inter> ideal F = {0}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> cone (h0, U0); a \\<in> ideal F\\<rbrakk>\n       \\<Longrightarrow> a = 0", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?a20 \\<in> cone (h0, U0); ?a20 \\<in> ideal F\\<rbrakk>\n  \\<Longrightarrow> ?a20 = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial (1::'a) t, U)) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lem_4_5:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"t \\<in> .[X]\" and \"F \\<subseteq> P[X]\"\n    and \"ideal F \\<div> monomial 1 t = ideal (monomial (1::'a) ` S)\"\n    and \"cone (monomial (1::'a::field) t', V) \\<subseteq> cone (monomial 1 t, U) \\<inter> normal_form F ` P[X]\"\n  shows \"V \\<subseteq> U\" and \"S \\<inter> .[V] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> U &&& S \\<inter> .[V] = {}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<subseteq> U\n 2. S \\<inter> .[V] = {}", "let ?t = \"monomial (1::'a) t\""], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<subseteq> U\n 2. S \\<inter> .[V] = {}", "let ?t' = \"monomial (1::'a) t'\""], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<subseteq> U\n 2. S \\<inter> .[V] = {}", "from assms(6)"], ["proof (chain)\npicking this:\n  cone (monomial (1::'a) t', V)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]", "have 1: \"cone (?t', V) \\<subseteq> cone (?t, U)\" and 2: \"cone (?t', V) \\<subseteq> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  cone (monomial (1::'a) t', V)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t', V)\n    \\<subseteq> cone (monomial (1::'a) t, U) &&&\n    cone (monomial (1::'a) t', V) \\<subseteq> normal_form F ` P[X]", "by blast+"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t', V) \\<subseteq> cone (monomial (1::'a) t, U)\n  cone (monomial (1::'a) t', V) \\<subseteq> normal_form F ` P[X]\n\ngoal (2 subgoals):\n 1. V \\<subseteq> U\n 2. S \\<inter> .[V] = {}", "from this(1)"], ["proof (chain)\npicking this:\n  cone (monomial (1::'a) t', V) \\<subseteq> cone (monomial (1::'a) t, U)", "show \"V \\<subseteq> U\""], ["proof (prove)\nusing this:\n  cone (monomial (1::'a) t', V) \\<subseteq> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. V \\<subseteq> U", "by (rule cone_subsetD) (simp add: monomial_0_iff)"], ["proof (state)\nthis:\n  V \\<subseteq> U\n\ngoal (1 subgoal):\n 1. S \\<inter> .[V] = {}", "show \"S \\<inter> .[V] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> .[V] = {}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<inter> .[V] \\<subseteq> {}\n 2. {} \\<subseteq> S \\<inter> .[V]", "let ?t = \"monomial (1::'a) t\""], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<inter> .[V] \\<subseteq> {}\n 2. {} \\<subseteq> S \\<inter> .[V]", "let ?t' = \"monomial (1::'a) t'\""], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<inter> .[V] \\<subseteq> {}\n 2. {} \\<subseteq> S \\<inter> .[V]", "show \"S \\<inter> .[V] \\<subseteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> .[V] \\<subseteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "assume \"s \\<in> S \\<inter> .[V]\""], ["proof (state)\nthis:\n  s \\<in> S \\<inter> .[V]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "hence \"s \\<in> S\" and \"s \\<in> .[V]\""], ["proof (prove)\nusing this:\n  s \\<in> S \\<inter> .[V]\n\ngoal (1 subgoal):\n 1. s \\<in> S &&& s \\<in> .[V]", "by simp_all"], ["proof (state)\nthis:\n  s \\<in> S\n  s \\<in> .[V]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "from this(2)"], ["proof (chain)\npicking this:\n  s \\<in> .[V]", "have \"monomial (1::'a) s \\<in> P[V]\" (is \"?s \\<in> _\")"], ["proof (prove)\nusing this:\n  s \\<in> .[V]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<in> P[V]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> P[V]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "with refl"], ["proof (chain)\npicking this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[V]", "have \"?s * ?t \\<in> cone (?t, V)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[V]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * monomial (1::'a) t\n    \\<in> cone (monomial (1::'a) t, V)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial (1::'a) s * monomial (1::'a) t \\<in> cone (monomial (1::'a) t, V)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "from tip_in_cone 1"], ["proof (chain)\npicking this:\n  ?h \\<in> cone (?h, ?U)\n  cone (monomial (1::'a) t', V) \\<subseteq> cone (monomial (1::'a) t, U)", "have \"?t' \\<in> cone (?t, U)\""], ["proof (prove)\nusing this:\n  ?h \\<in> cone (?h, ?U)\n  cone (monomial (1::'a) t', V) \\<subseteq> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. monomial (1::'a) t' \\<in> cone (monomial (1::'a) t, U)", ".."], ["proof (state)\nthis:\n  monomial (1::'a) t' \\<in> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "then"], ["proof (chain)\npicking this:\n  monomial (1::'a) t' \\<in> cone (monomial (1::'a) t, U)", "obtain s' where \"s' \\<in> P[U]\" and t': \"?t' = s' * ?t\""], ["proof (prove)\nusing this:\n  monomial (1::'a) t' \\<in> cone (monomial (1::'a) t, U)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> P[U];\n         monomial (1::'a) t' = s' * monomial (1::'a) t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  s' \\<in> P[U]\n  monomial (1::'a) t' = s' * monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "note this(1)"], ["proof (state)\nthis:\n  s' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "also"], ["proof (state)\nthis:\n  s' \\<in> P[U]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "from assms(2)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "have \"P[U] \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. P[U] \\<subseteq> P[X]", "by (rule Polys_mono)"], ["proof (state)\nthis:\n  P[U] \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "finally"], ["proof (chain)\npicking this:\n  s' \\<in> P[X]", "have \"s' \\<in> P[X]\""], ["proof (prove)\nusing this:\n  s' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. s' \\<in> P[X]", "."], ["proof (state)\nthis:\n  s' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "have \"s' * ?s * ?t = ?s * ?t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s * monomial (1::'a) t =\n    monomial (1::'a) s * monomial (1::'a) t'", "by (simp add: t')"], ["proof (state)\nthis:\n  s' * monomial (1::'a) s * monomial (1::'a) t =\n  monomial (1::'a) s * monomial (1::'a) t'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "also"], ["proof (state)\nthis:\n  s' * monomial (1::'a) s * monomial (1::'a) t =\n  monomial (1::'a) s * monomial (1::'a) t'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "from refl \\<open>?s \\<in> P[V]\\<close>"], ["proof (chain)\npicking this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[V]", "have \"\\<dots> \\<in> cone (?t', V)\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  monomial (1::'a) s \\<in> P[V]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * monomial (1::'a) t'\n    \\<in> cone (monomial (1::'a) t', V)", "by (rule coneI)"], ["proof (state)\nthis:\n  monomial (1::'a) s * monomial (1::'a) t'\n  \\<in> cone (monomial (1::'a) t', V)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "finally"], ["proof (chain)\npicking this:\n  s' * monomial (1::'a) s * monomial (1::'a) t\n  \\<in> cone (monomial (1::'a) t', V)", "have \"s' * ?s * ?t \\<in> cone (?t', V)\""], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s * monomial (1::'a) t\n  \\<in> cone (monomial (1::'a) t', V)\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s * monomial (1::'a) t\n    \\<in> cone (monomial (1::'a) t', V)", "."], ["proof (state)\nthis:\n  s' * monomial (1::'a) s * monomial (1::'a) t\n  \\<in> cone (monomial (1::'a) t', V)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "hence 1: \"s' * ?s * ?t \\<in> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s * monomial (1::'a) t\n  \\<in> cone (monomial (1::'a) t', V)\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s * monomial (1::'a) t \\<in> normal_form F ` P[X]", "using 2"], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s * monomial (1::'a) t\n  \\<in> cone (monomial (1::'a) t', V)\n  cone (monomial (1::'a) t', V) \\<subseteq> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s * monomial (1::'a) t \\<in> normal_form F ` P[X]", ".."], ["proof (state)\nthis:\n  s' * monomial (1::'a) s * monomial (1::'a) t \\<in> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "from \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"?s \\<in> monomial 1 ` S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<in> monomial (1::'a) ` S", "by (rule imageI)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "hence \"?s \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "hence \"s' * ?s \\<in> ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_scale)"], ["proof (state)\nthis:\n  s' * monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "hence \"s' * ?s \\<in> ideal F \\<div> ?t\""], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s \\<in> ideal F \\<div> monomial (1::'a) t", "by (simp only: assms(5))"], ["proof (state)\nthis:\n  s' * monomial (1::'a) s \\<in> ideal F \\<div> monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "hence \"s' * ?s * ?t \\<in> ideal F\""], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s \\<in> ideal F \\<div> monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F", "by (simp only: quot_set_iff mult.commute)"], ["proof (state)\nthis:\n  s' * monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "hence \"s' * ?s * ?t \\<in> ideal F \\<inter> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s * monomial (1::'a) t\n    \\<in> ideal F \\<inter> normal_form F ` P[X]", "using 1"], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s * monomial (1::'a) t \\<in> ideal F\n  s' * monomial (1::'a) s * monomial (1::'a) t \\<in> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. s' * monomial (1::'a) s * monomial (1::'a) t\n    \\<in> ideal F \\<inter> normal_form F ` P[X]", "by (rule IntI)"], ["proof (state)\nthis:\n  s' * monomial (1::'a) s * monomial (1::'a) t\n  \\<in> ideal F \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "also"], ["proof (state)\nthis:\n  s' * monomial (1::'a) s * monomial (1::'a) t\n  \\<in> ideal F \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "from assms(1, 4)"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"\\<dots> \\<subseteq> {0}\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. ideal F \\<inter> normal_form F ` P[X] \\<subseteq> {0}", "by (auto simp: normal_form_normal_form simp flip: normal_form_zero_iff)"], ["proof (state)\nthis:\n  ideal F \\<inter> normal_form F ` P[X] \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "finally"], ["proof (chain)\npicking this:\n  s' * monomial (1::'a) s * monomial (1::'a) t \\<in> {0}", "have \"?s * ?t' = 0\""], ["proof (prove)\nusing this:\n  s' * monomial (1::'a) s * monomial (1::'a) t \\<in> {0}\n\ngoal (1 subgoal):\n 1. monomial (1::'a) s * monomial (1::'a) t' = 0", "by (simp add: t' ac_simps)"], ["proof (state)\nthis:\n  monomial (1::'a) s * monomial (1::'a) t' = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<inter> .[V] \\<Longrightarrow> x \\<in> {}", "thus \"s \\<in> {}\""], ["proof (prove)\nusing this:\n  monomial (1::'a) s * monomial (1::'a) t' = 0\n\ngoal (1 subgoal):\n 1. s \\<in> {}", "by (simp add: times_monomial_monomial monomial_0_iff)"], ["proof (state)\nthis:\n  s \\<in> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<inter> .[V] \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. {} \\<subseteq> S \\<inter> .[V]", "qed (fact empty_subsetI)"], ["proof (state)\nthis:\n  S \\<inter> .[V] = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lem_4_6:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"t \\<in> .[X]\" and \"F \\<subseteq> P[X]\"\n    and \"ideal F \\<div> monomial 1 t = ideal (monomial 1 ` S)\"\n  assumes \"cone (monomial 1 t', V) \\<subseteq> cone (monomial 1 t, U) \\<inter> normal_form F ` P[X]\"\n  obtains V' where \"(monomial 1 t, V') \\<in> set (snd (split t U S))\" and \"card V \\<le> card V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (split t U S));\n         card V \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (split t U S));\n         card V \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?t = \"monomial (1::'a) t\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (split t U S));\n         card V \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?t' = \"monomial (1::'a) t'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (split t U S));\n         card V \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(7)"], ["proof (chain)\npicking this:\n  cone (monomial (1::'a) t', V)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]", "have \"cone (?t', V) \\<subseteq> cone (?t, U)\" and \"cone (?t', V) \\<subseteq> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  cone (monomial (1::'a) t', V)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) t', V)\n    \\<subseteq> cone (monomial (1::'a) t, U) &&&\n    cone (monomial (1::'a) t', V) \\<subseteq> normal_form F ` P[X]", "by blast+"], ["proof (state)\nthis:\n  cone (monomial (1::'a) t', V) \\<subseteq> cone (monomial (1::'a) t, U)\n  cone (monomial (1::'a) t', V) \\<subseteq> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (split t U S));\n         card V \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1, 2, 4, 5, 6, 7)"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  t \\<in> .[X]\n  F \\<subseteq> P[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n  cone (monomial (1::'a) t', V)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]", "have \"V \\<subseteq> U\" and \"S \\<inter> .[V] = {}\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  t \\<in> .[X]\n  F \\<subseteq> P[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n  cone (monomial (1::'a) t', V)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. V \\<subseteq> U &&& S \\<inter> .[V] = {}", "by (rule lem_4_5)+"], ["proof (state)\nthis:\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (split t U S));\n         card V \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1, 2, 3)"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>(monomial (1::'b) t, ?V'19) \\<in> set (snd (split t U S));\n   card V \\<le> card ?V'19\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof (induct t U S arbitrary: V thesis rule: split_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; V \\<subseteq> U;\n        S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([(monomial (1::'b) t, U)], []));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([], [(monomial (1::'b) t, U)]));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base1 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<in> S\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>(monomial (1::'b) t, ?V'19)\n           \\<in> set (snd ([(monomial (1::'b) t, U)], []));\n   card V \\<le> card ?V'19\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (3 subgoals):\n 1. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; V \\<subseteq> U;\n        S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([(monomial (1::'b) t, U)], []));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([], [(monomial (1::'b) t, U)]));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from base1.hyps(3)"], ["proof (chain)\npicking this:\n  0 \\<in> S", "have \"0 \\<in> S \\<inter> .[V]\""], ["proof (prove)\nusing this:\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<inter> .[V]", "using zero_in_PPs"], ["proof (prove)\nusing this:\n  0 \\<in> S\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. 0 \\<in> S \\<inter> .[V]", "by (rule IntI)"], ["proof (state)\nthis:\n  0 \\<in> S \\<inter> .[V]\n\ngoal (3 subgoals):\n 1. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; V \\<subseteq> U;\n        S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([(monomial (1::'b) t, U)], []));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([], [(monomial (1::'b) t, U)]));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<in> S \\<inter> .[V]\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add: base1.prems(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([], [(monomial (1::'b) t, U)]));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([], [(monomial (1::'b) t, U)]));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base2 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] = {}\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>(monomial (1::'b) t, ?V'19)\n           \\<in> set (snd ([], [(monomial (1::'b) t, U)]));\n   card V \\<le> card ?V'19\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>t U S V thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd ([], [(monomial (1::'b) t, U)]));\n            card V \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule base2.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. (monomial (1::'b) t, ?V'19)\n    \\<in> set (snd ([], [(monomial (1::'b) t, U)]))\n 2. card V \\<le> card ?V'19", "from base2.hyps(1) assms(1)"], ["proof (chain)\npicking this:\n  U \\<subseteq> X\n  finite X", "have \"finite U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal (2 subgoals):\n 1. (monomial (1::'b) t, ?V'19)\n    \\<in> set (snd ([], [(monomial (1::'b) t, U)]))\n 2. card V \\<le> card ?V'19", "thus \"card V \\<le> card U\""], ["proof (prove)\nusing this:\n  finite U\n\ngoal (1 subgoal):\n 1. card V \\<le> card U", "using base2.prems(1)"], ["proof (prove)\nusing this:\n  finite U\n  V \\<subseteq> U\n\ngoal (1 subgoal):\n 1. card V \\<le> card U", "by (rule card_mono)"], ["proof (state)\nthis:\n  card V \\<le> card U\n\ngoal (1 subgoal):\n 1. (monomial (1::'b) t, U) \\<in> set (snd ([], [(monomial (1::'b) t, U)]))", "qed simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step t U S V0 x ps0 ps1 qs0 qs1)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] \\<noteq> {}\n  V0 \\<subseteq> U\n  S \\<inter> .[V0] = {}\n  \\<lbrakk>?V'19 \\<subseteq> U; S \\<inter> .[?V'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?V'19 \\<le> card V0\n  x \\<in> U\n  x \\<notin> V0\n  V0 = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {})\n  x = (SOME x'. x' \\<in> U - V0)\n  (ps0, qs0) = split t (U - {x}) S\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S)\n  split t U S = (ps0 @ ps1, qs0 @ qs1)\n  \\<lbrakk>?V19 \\<subseteq> U - {x}; S \\<inter> .[?V19] = {};\n   \\<And>V'.\n      \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n       card ?V19 \\<le> card V'\\<rbrakk>\n      \\<Longrightarrow> ?thesis19\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n  \\<lbrakk>?V19 \\<subseteq> U;\n   (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[?V19] = {};\n   \\<And>V'.\n      \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n               \\<in> set (snd (ps1, qs1));\n       card ?V19 \\<le> card V'\\<rbrakk>\n      \\<Longrightarrow> ?thesis19\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>(monomial (1::'b) t, ?V'19)\n           \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n   card V \\<le> card ?V'19\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from step.prems(1, 2)"], ["proof (chain)\npicking this:\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}", "have 0: \"card V \\<le> card V0\""], ["proof (prove)\nusing this:\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n\ngoal (1 subgoal):\n 1. card V \\<le> card V0", "by (rule step.hyps)"], ["proof (state)\nthis:\n  card V \\<le> card V0\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from step.hyps(5, 9)"], ["proof (chain)\npicking this:\n  V0 \\<subseteq> U\n  x \\<notin> V0", "have \"V0 \\<subseteq> U - {x}\""], ["proof (prove)\nusing this:\n  V0 \\<subseteq> U\n  x \\<notin> V0\n\ngoal (1 subgoal):\n 1. V0 \\<subseteq> U - {x}", "by blast"], ["proof (state)\nthis:\n  V0 \\<subseteq> U - {x}\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  V0 \\<subseteq> U - {x}", "obtain V' where 1: \"(monomial 1 t, V') \\<in> set (snd (ps0, qs0))\" and 2: \"card V0 \\<le> card V'\""], ["proof (prove)\nusing this:\n  V0 \\<subseteq> U - {x}\n\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n         card V0 \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step.hyps(6)"], ["proof (prove)\nusing this:\n  V0 \\<subseteq> U - {x}\n  S \\<inter> .[V0] = {}\n\ngoal (1 subgoal):\n 1. (\\<And>V'.\n        \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n         card V0 \\<le> card V'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule step.hyps)"], ["proof (state)\nthis:\n  (monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0))\n  card V0 \\<le> card V'\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 Va thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U - {x}; S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V thesis.\n           \\<lbrakk>V \\<subseteq> U;\n            (\\<lambda>f. f - monomial 1 x) ` S \\<inter> .[V] = {};\n            \\<And>V'.\n               \\<lbrakk>(monomial (1::'b) (monomial 1 x + t), V')\n                        \\<in> set (snd (ps1, qs1));\n                card V \\<le> card V'\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        Va \\<subseteq> U; S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>(monomial (1::'b) t, V')\n                    \\<in> set (snd (ps0 @ ps1, qs0 @ qs1));\n            card Va \\<le> card V'\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. (monomial (1::'b) t, ?V'19) \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\n 2. card V \\<le> card ?V'19", "from 1"], ["proof (chain)\npicking this:\n  (monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0))", "show \"(monomial 1 t, V') \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\nusing this:\n  (monomial (1::'b) t, V') \\<in> set (snd (ps0, qs0))\n\ngoal (1 subgoal):\n 1. (monomial (1::'b) t, V') \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))", "by simp"], ["proof (state)\nthis:\n  (monomial (1::'b) t, V') \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal (1 subgoal):\n 1. card V \\<le> card V'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card V \\<le> card V'", "from 0 2"], ["proof (chain)\npicking this:\n  card V \\<le> card V0\n  card V0 \\<le> card V'", "show \"card V \\<le> card V'\""], ["proof (prove)\nusing this:\n  card V \\<le> card V0\n  card V0 \\<le> card V'\n\ngoal (1 subgoal):\n 1. card V \\<le> card V'", "by (rule le_trans)"], ["proof (state)\nthis:\n  card V \\<le> card V'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lem_4_7:\n  assumes \"finite X\" and \"S \\<subseteq> .[X]\" and \"g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\"\n    and \"cone_decomp (P[X] \\<inter> ideal (monomial (1::'a::field) ` S)) ps\"\n    and \"monomial_decomp ps\"\n  obtains U where \"(g, U) \\<in> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?S = \"monomial (1::'a) ` S\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?G = \"punit.reduced_GB ?S\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms(1)"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  S \\<subseteq> .[X]", "have \"?S \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) ` S \\<subseteq> P[X]", "by (auto intro: Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"is_monomial_set ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial_set (monomial (1::'a) ` S)", "by (auto intro!: is_monomial_setI monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n  is_monomial_set (monomial (1::'a) ` S)", "have \"is_monomial_set ?G\""], ["proof (prove)\nusing this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))", "by (rule reduced_GB_is_monomial_set_Polys)"], ["proof (state)\nthis:\n  is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"is_monomial g\""], ["proof (prove)\nusing this:\n  is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. is_monomial g", "using assms(3)"], ["proof (prove)\nusing this:\n  is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. is_monomial g", "by (rule is_monomial_setD)"], ["proof (state)\nthis:\n  is_monomial g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_monomial g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by (rule monomial_not_0)"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1) \\<open>?S \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]", "have \"punit.is_monic_set ?G\""], ["proof (prove)\nusing this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))", "by (rule reduced_GB_is_monic_set_Polys)"], ["proof (state)\nthis:\n  punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  g \\<noteq> 0\n  punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))", "have \"punit.lc g = 1\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. lcf g = (1::'a)", "using assms(3)"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. lcf g = (1::'a)", "by (simp add: punit.is_monic_set_def)"], ["proof (state)\nthis:\n  lcf g = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  lcf g = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define t where \"t = lpp g\""], ["proof (state)\nthis:\n  t = lpp g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  t = lpp g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>is_monomial g\\<close>"], ["proof (chain)\npicking this:\n  is_monomial g", "have \"monomial (punit.lc g) (lpp g) = g\""], ["proof (prove)\nusing this:\n  is_monomial g\n\ngoal (1 subgoal):\n 1. monomial (lcf g) (lpp g) = g", "by (rule punit.monomial_eq_itself)"], ["proof (state)\nthis:\n  monomial (lcf g) (lpp g) = g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  lcf g = (1::'a)\n  t = lpp g\n  monomial (lcf g) (lpp g) = g", "have g: \"g = monomial 1 t\""], ["proof (prove)\nusing this:\n  lcf g = (1::'a)\n  t = lpp g\n  monomial (lcf g) (lpp g) = g\n\ngoal (1 subgoal):\n 1. g = monomial (1::'a) t", "by simp"], ["proof (state)\nthis:\n  g = monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"t \\<in> keys g\""], ["proof (prove)\nusing this:\n  g = monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. t \\<in> keys g", "by simp"], ["proof (state)\nthis:\n  t \\<in> keys g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(3)"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)", "have \"g \\<in> ideal ?G\""], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. g \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  g \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  g \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1) \\<open>?S \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]", "have ideal_G: \"\\<dots> = ideal ?S\""], ["proof (prove)\nusing this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. ideal (punit.reduced_GB (monomial (1::'a) ` S)) =\n    ideal (monomial (1::'a) ` S)", "by (rule reduced_GB_ideal_Polys)"], ["proof (state)\nthis:\n  ideal (punit.reduced_GB (monomial (1::'a) ` S)) =\n  ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  g \\<in> ideal (monomial (1::'a) ` S)", "have \"g \\<in> ideal ?S\""], ["proof (prove)\nusing this:\n  g \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. g \\<in> ideal (monomial (1::'a) ` S)", "."], ["proof (state)\nthis:\n  g \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  g \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(3)"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)", "have \"g \\<in> P[X]\""], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. g \\<in> P[X]", "by rule (intro reduced_GB_Polys assms(1) \\<open>?S \\<subseteq> P[X]\\<close>)"], ["proof (state)\nthis:\n  g \\<in> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  g \\<in> ideal (monomial (1::'a) ` S)\n  g \\<in> P[X]", "have \"g \\<in> P[X] \\<inter> ideal ?S\""], ["proof (prove)\nusing this:\n  g \\<in> ideal (monomial (1::'a) ` S)\n  g \\<in> P[X]\n\ngoal (1 subgoal):\n 1. g \\<in> P[X] \\<inter> ideal (monomial (1::'a) ` S)", "by simp"], ["proof (state)\nthis:\n  g \\<in> P[X] \\<inter> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(4)"], ["proof (chain)\npicking this:\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S)) ps\n  g \\<in> P[X] \\<inter> ideal (monomial (1::'a) ` S)", "have \"g \\<in> sum_list ` listset (map cone ps)\""], ["proof (prove)\nusing this:\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S)) ps\n  g \\<in> P[X] \\<inter> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. g \\<in> sum_list ` listset (map cone ps)", "by (simp only: cone_decomp_def direct_decompD)"], ["proof (state)\nthis:\n  g \\<in> sum_list ` listset (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(5)"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  g \\<in> sum_list ` listset (map cone ps)", "obtain d h U where *: \"(h, U) \\<in> set ps\" and \"d \\<noteq> 0\" and \"monomial d t \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  g \\<in> sum_list ` listset (map cone ps)\n\ngoal (1 subgoal):\n 1. (\\<And>h U d.\n        \\<lbrakk>(h, U) \\<in> set ps; d \\<noteq> (0::'a);\n         monomial d t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<in> keys g\\<close>"], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  g \\<in> sum_list ` listset (map cone ps)\n  t \\<in> keys g\n\ngoal (1 subgoal):\n 1. (\\<And>h U d.\n        \\<lbrakk>(h, U) \\<in> set ps; d \\<noteq> (0::'a);\n         monomial d t \\<in> cone (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule monomial_decomp_sum_list_monomial_in_cone)"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n  d \\<noteq> (0::'a)\n  monomial d t \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(3) zero_in_PPs"], ["proof (chain)\npicking this:\n  monomial d t \\<in> cone (h, U)\n  0 \\<in> .[?X]", "have \"punit.monom_mult (1 / d) 0 (monomial d t) \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  monomial d t \\<in> cone (h, U)\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult ((1::'a) / d) 0 (monomial d t) \\<in> cone (h, U)", "by (rule cone_closed_monom_mult)"], ["proof (state)\nthis:\n  local.punit.monom_mult ((1::'a) / d) 0 (monomial d t) \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>d \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  d \\<noteq> (0::'a)\n  local.punit.monom_mult ((1::'a) / d) 0 (monomial d t) \\<in> cone (h, U)", "have \"g \\<in> cone (h, U)\""], ["proof (prove)\nusing this:\n  d \\<noteq> (0::'a)\n  local.punit.monom_mult ((1::'a) / d) 0 (monomial d t) \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. g \\<in> cone (h, U)", "by (simp add: g punit.monom_mult_monomial)"], ["proof (state)\nthis:\n  g \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  g \\<in> cone (h, U)", "obtain q where \"q \\<in> P[U]\" and g': \"g = q * h\""], ["proof (prove)\nusing this:\n  g \\<in> cone (h, U)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[U]; g = q * h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule coneE)"], ["proof (state)\nthis:\n  q \\<in> P[U]\n  g = q * h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>g \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have \"q \\<noteq> 0\" and \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& h \\<noteq> 0", "by (auto simp: g')"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence lt_g': \"lpp g = lpp q + lpp h\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp g = lpp q + lpp h", "unfolding g'"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lpp (q * h) = lpp q + lpp h", "by (rule lp_times)"], ["proof (state)\nthis:\n  lpp g = lpp q + lpp h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence adds1: \"lpp h adds t\""], ["proof (prove)\nusing this:\n  lpp g = lpp q + lpp h\n\ngoal (1 subgoal):\n 1. lpp h adds t", "by (simp add: t_def)"], ["proof (state)\nthis:\n  lpp h adds t\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(5) *"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps", "have \"is_monomial h\" and \"punit.lc h = 1\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. is_monomial h &&& lcf h = (1::'a)", "by (rule monomial_decompD)+"], ["proof (state)\nthis:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(1)"], ["proof (chain)\npicking this:\n  is_monomial h", "have \"monomial (punit.lc h) (lpp h) = h\""], ["proof (prove)\nusing this:\n  is_monomial h\n\ngoal (1 subgoal):\n 1. monomial (lcf h) (lpp h) = h", "by (rule punit.monomial_eq_itself)"], ["proof (state)\nthis:\n  monomial (lcf h) (lpp h) = h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  monomial (lcf h) (lpp h) = h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define s where \"s = lpp h\""], ["proof (state)\nthis:\n  s = lpp h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_monomial h\n  lcf h = (1::'a)\n  monomial (lcf h) (lpp h) = h\n  s = lpp h", "have h: \"h = monomial 1 s\""], ["proof (prove)\nusing this:\n  is_monomial h\n  lcf h = (1::'a)\n  monomial (lcf h) (lpp h) = h\n  s = lpp h\n\ngoal (1 subgoal):\n 1. h = monomial (1::'a) s", "by simp"], ["proof (state)\nthis:\n  h = monomial (1::'a) s\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"punit.lc q = punit.lc g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcf q = lcf g", "by (simp add: g' lc_times \\<open>punit.lc h = 1\\<close>)"], ["proof (state)\nthis:\n  lcf q = lcf g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"punit.lc q = 1\""], ["proof (prove)\nusing this:\n  lcf q = lcf g\n\ngoal (1 subgoal):\n 1. lcf q = (1::'a)", "by (simp only: \\<open>punit.lc g = 1\\<close>)"], ["proof (state)\nthis:\n  lcf q = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note tip_in_cone"], ["proof (state)\nthis:\n  ?h \\<in> cone (?h, ?U)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  ?h \\<in> cone (?h, ?U)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(4) *"], ["proof (chain)\npicking this:\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S)) ps\n  (h, U) \\<in> set ps", "have \"cone (h, U) \\<subseteq> P[X] \\<inter> ideal ?S\""], ["proof (prove)\nusing this:\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S)) ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. cone (h, U) \\<subseteq> P[X] \\<inter> ideal (monomial (1::'a) ` S)", "by (rule cone_decomp_cone_subset)"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X] \\<inter> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  cone (h, U) \\<subseteq> P[X] \\<inter> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<subseteq> ideal ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P[X] \\<inter> ideal (monomial (1::'a) ` S)\n    \\<subseteq> ideal (punit.reduced_GB (monomial (1::'a) ` S))", "by (simp add: ideal_G)"], ["proof (state)\nthis:\n  P[X] \\<inter> ideal (monomial (1::'a) ` S)\n  \\<subseteq> ideal (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  h \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))", "have \"h \\<in> ideal ?G\""], ["proof (prove)\nusing this:\n  h \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. h \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))", "."], ["proof (state)\nthis:\n  h \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1) \\<open>?S \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]", "have \"punit.is_Groebner_basis ?G\""], ["proof (prove)\nusing this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis (punit.reduced_GB (monomial (1::'a) ` S))", "by (rule reduced_GB_is_GB_Polys)"], ["proof (state)\nthis:\n  punit.is_Groebner_basis (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  punit.is_Groebner_basis (punit.reduced_GB (monomial (1::'a) ` S))", "obtain g' where \"g' \\<in> ?G\" and \"g' \\<noteq> 0\" and adds2: \"lpp g' adds lpp h\""], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g' \\<in> punit.reduced_GB (monomial (1::'a) ` S);\n         g' \\<noteq> 0; lpp g' adds lpp h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>h \\<in> ideal ?G\\<close> \\<open>h \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  punit.is_Groebner_basis (punit.reduced_GB (monomial (1::'a) ` S))\n  h \\<in> ideal (punit.reduced_GB (monomial (1::'a) ` S))\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>g' \\<in> punit.reduced_GB (monomial (1::'a) ` S);\n         g' \\<noteq> 0; lpp g' adds lpp h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule punit.GB_adds_lt[simplified])"], ["proof (state)\nthis:\n  g' \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  g' \\<noteq> 0\n  lpp g' adds lpp h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(3) adds1"], ["proof (chain)\npicking this:\n  lpp g' adds lpp h\n  lpp h adds t", "have \"lpp g' adds t\""], ["proof (prove)\nusing this:\n  lpp g' adds lpp h\n  lpp h adds t\n\ngoal (1 subgoal):\n 1. lpp g' adds t", "by (rule adds_trans)"], ["proof (state)\nthis:\n  lpp g' adds t\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with _ \\<open>g' \\<noteq> 0\\<close> \\<open>t \\<in> keys g\\<close>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  g' \\<noteq> 0\n  t \\<in> keys g\n  lpp g' adds t", "have \"punit.is_red {g'} g\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  g' \\<noteq> 0\n  t \\<in> keys g\n  lpp g' adds t\n\ngoal (1 subgoal):\n 1. punit.is_red {g'} g", "by (rule punit.is_red_addsI[simplified]) simp"], ["proof (state)\nthis:\n  punit.is_red {g'} g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"g' = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g' = g", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. g' \\<noteq> g \\<Longrightarrow> False", "assume \"g' \\<noteq> g\""], ["proof (state)\nthis:\n  g' \\<noteq> g\n\ngoal (1 subgoal):\n 1. g' \\<noteq> g \\<Longrightarrow> False", "with \\<open>g' \\<in> ?G\\<close>"], ["proof (chain)\npicking this:\n  g' \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  g' \\<noteq> g", "have \"{g'} \\<subseteq> ?G - {g}\""], ["proof (prove)\nusing this:\n  g' \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  g' \\<noteq> g\n\ngoal (1 subgoal):\n 1. {g'} \\<subseteq> punit.reduced_GB (monomial (1::'a) ` S) - {g}", "by simp"], ["proof (state)\nthis:\n  {g'} \\<subseteq> punit.reduced_GB (monomial (1::'a) ` S) - {g}\n\ngoal (1 subgoal):\n 1. g' \\<noteq> g \\<Longrightarrow> False", "with \\<open>punit.is_red {g'} g\\<close>"], ["proof (chain)\npicking this:\n  punit.is_red {g'} g\n  {g'} \\<subseteq> punit.reduced_GB (monomial (1::'a) ` S) - {g}", "have red: \"punit.is_red (?G - {g}) g\""], ["proof (prove)\nusing this:\n  punit.is_red {g'} g\n  {g'} \\<subseteq> punit.reduced_GB (monomial (1::'a) ` S) - {g}\n\ngoal (1 subgoal):\n 1. punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g", "by (rule punit.is_red_subset)"], ["proof (state)\nthis:\n  punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g\n\ngoal (1 subgoal):\n 1. g' \\<noteq> g \\<Longrightarrow> False", "from assms(1) \\<open>?S \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]", "have \"punit.is_auto_reduced ?G\""], ["proof (prove)\nusing this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.is_auto_reduced (punit.reduced_GB (monomial (1::'a) ` S))", "by (rule reduced_GB_is_auto_reduced_Polys)"], ["proof (state)\nthis:\n  punit.is_auto_reduced (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. g' \\<noteq> g \\<Longrightarrow> False", "hence \"\\<not> punit.is_red (?G - {g}) g\""], ["proof (prove)\nusing this:\n  punit.is_auto_reduced (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g", "using assms(3)"], ["proof (prove)\nusing this:\n  punit.is_auto_reduced (punit.reduced_GB (monomial (1::'a) ` S))\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. \\<not> punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g", "by (rule punit.is_auto_reducedD)"], ["proof (state)\nthis:\n  \\<not> punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g\n\ngoal (1 subgoal):\n 1. g' \\<noteq> g \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g\n\ngoal (1 subgoal):\n 1. False", "using red"], ["proof (prove)\nusing this:\n  \\<not> punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g\n  punit.is_red (punit.reduced_GB (monomial (1::'a) ` S) - {g}) g\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g' = g\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with adds2"], ["proof (chain)\npicking this:\n  lpp g' adds lpp h\n  g' = g", "have \"t adds lpp h\""], ["proof (prove)\nusing this:\n  lpp g' adds lpp h\n  g' = g\n\ngoal (1 subgoal):\n 1. t adds lpp h", "by (simp only: t_def)"], ["proof (state)\nthis:\n  t adds lpp h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with adds1"], ["proof (chain)\npicking this:\n  lpp h adds t\n  t adds lpp h", "have \"lpp h = t\""], ["proof (prove)\nusing this:\n  lpp h adds t\n  t adds lpp h\n\ngoal (1 subgoal):\n 1. lpp h = t", "by (rule adds_antisym)"], ["proof (state)\nthis:\n  lpp h = t\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"lpp q = 0\""], ["proof (prove)\nusing this:\n  lpp h = t\n\ngoal (1 subgoal):\n 1. lpp q = 0", "using lt_g'"], ["proof (prove)\nusing this:\n  lpp h = t\n  lpp g = lpp q + lpp h\n\ngoal (1 subgoal):\n 1. lpp q = 0", "by (simp add: t_def)"], ["proof (state)\nthis:\n  lpp q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"monomial (punit.lc q) 0 = q\""], ["proof (prove)\nusing this:\n  lpp q = 0\n\ngoal (1 subgoal):\n 1. monomial (lcf q) 0 = q", "by (rule punit.lt_eq_min_term_monomial[simplified])"], ["proof (state)\nthis:\n  monomial (lcf q) 0 = q\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"g = h\""], ["proof (prove)\nusing this:\n  monomial (lcf q) 0 = q\n\ngoal (1 subgoal):\n 1. g = h", "by (simp add: \\<open>punit.lc q = 1\\<close> g')"], ["proof (state)\nthis:\n  g = h\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with *"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  g = h", "have \"(g, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  g = h\n\ngoal (1 subgoal):\n 1. (g, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (g, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set ps \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (g, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_splitI:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"0 \\<notin> S\"\n  obtains V where \"V \\<subseteq> U\" and \"(monomial 1 t, V) \\<in> set (snd (split t U S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<subseteq> U;\n         (monomial (1::'a) t, V) \\<in> set (snd (split t U S))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<subseteq> U;\n         (monomial (1::'a) t, V) \\<in> set (snd (split t U S))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct t U S arbitrary: thesis rule: split_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base1 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<in> S\n  \\<lbrakk>?V19 \\<subseteq> U;\n   (monomial (1::'a) t, ?V19)\n   \\<in> set (snd ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> S\n\ngoal (3 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "from base1.prems(2) base1.hyps(3)"], ["proof (chain)\npicking this:\n  0 \\<notin> S\n  0 \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<notin> S\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base2 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] = {}\n  \\<lbrakk>?V19 \\<subseteq> U;\n   (monomial (1::'a) t, ?V19)\n   \\<in> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> S\n\ngoal (2 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "from subset_refl"], ["proof (chain)\npicking this:\n  ?A \\<subseteq> ?A", "show ?case"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. thesis", "by (rule base2.prems) simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step t U S V0 x ps0 ps1 qs0 qs1)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] \\<noteq> {}\n  V0 \\<subseteq> U\n  S \\<inter> .[V0] = {}\n  \\<lbrakk>?V'19 \\<subseteq> U; S \\<inter> .[?V'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?V'19 \\<le> card V0\n  x \\<in> U\n  x \\<notin> V0\n  V0 = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {})\n  x = (SOME x'. x' \\<in> U - V0)\n  (ps0, qs0) = split t (U - {x}) S\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S)\n  split t U S = (ps0 @ ps1, qs0 @ qs1)\n  \\<lbrakk>\\<And>V.\n              \\<lbrakk>V \\<subseteq> U - {x};\n               (monomial (1::'a) t, V) \\<in> set (snd (ps0, qs0))\\<rbrakk>\n              \\<Longrightarrow> ?thesis19;\n   0 \\<notin> S\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n  \\<lbrakk>\\<And>V.\n              \\<lbrakk>V \\<subseteq> U;\n               (monomial (1::'a) (monomial 1 x + t), V)\n               \\<in> set (snd (ps1, qs1))\\<rbrakk>\n              \\<Longrightarrow> ?thesis19;\n   0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n  \\<lbrakk>?V19 \\<subseteq> U;\n   (monomial (1::'a) t, ?V19)\n   \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "from step.hyps(3)"], ["proof (chain)\npicking this:\n  0 \\<notin> S", "obtain V where 1: \"V \\<subseteq> U - {x}\" and 2: \"(monomial 1 t, V) \\<in> set (snd (ps0, qs0))\""], ["proof (prove)\nusing this:\n  0 \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<subseteq> U - {x};\n         (monomial (1::'a) t, V) \\<in> set (snd (ps0, qs0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step.hyps(15)"], ["proof (prove)\nusing this:\n  0 \\<notin> S\n  \\<lbrakk>\\<And>V.\n              \\<lbrakk>V \\<subseteq> U - {x};\n               (monomial (1::'a) t, V) \\<in> set (snd (ps0, qs0))\\<rbrakk>\n              \\<Longrightarrow> ?thesis19;\n   0 \\<notin> S\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<subseteq> U - {x};\n         (monomial (1::'a) t, V) \\<in> set (snd (ps0, qs0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  V \\<subseteq> U - {x}\n  (monomial (1::'a) t, V) \\<in> set (snd (ps0, qs0))\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U - {x};\n                        (monomial (1::'a) t, V)\n                        \\<in> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>V.\n                       \\<lbrakk>V \\<subseteq> U;\n                        (monomial (1::'a) (monomial 1 x + t), V)\n                        \\<in> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>V.\n           \\<lbrakk>V \\<subseteq> U;\n            (monomial (1::'a) t, V)\n            \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?V19 \\<subseteq> U\n 2. (monomial (1::'a) t, ?V19) \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))", "from 1"], ["proof (chain)\npicking this:\n  V \\<subseteq> U - {x}", "show \"V \\<subseteq> U\""], ["proof (prove)\nusing this:\n  V \\<subseteq> U - {x}\n\ngoal (1 subgoal):\n 1. V \\<subseteq> U", "by blast"], ["proof (state)\nthis:\n  V \\<subseteq> U\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) t, V) \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (monomial (1::'a) t, V) \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))", "from 2"], ["proof (chain)\npicking this:\n  (monomial (1::'a) t, V) \\<in> set (snd (ps0, qs0))", "show \"(monomial 1 t, V) \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) t, V) \\<in> set (snd (ps0, qs0))\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) t, V) \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))", "by fastforce"], ["proof (state)\nthis:\n  (monomial (1::'a) t, V) \\<in> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fst_splitE:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"0 \\<notin> S\"\n    and \"(monomial (1::'a) s, V) \\<in> set (fst (split t U S))\"\n  obtains t' x where \"t' \\<in> .[X]\" and \"x \\<in> X\" and \"V \\<subseteq> U\" and \"0 \\<notin> (\\<lambda>s. s - t') ` S\"\n    and \"s = t' + t + Poly_Mapping.single x 1\"\n    and \"(monomial (1::'a::zero_neq_one) s, V) \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\"\n    and \"set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S))) \\<subseteq> (set (snd (split t U S)) :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t' x.\n        \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n         0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n         (monomial (1::'a) s, V)\n         \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n         set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n         \\<subseteq> set (snd (split t U S))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  (monomial (1::'a) s, V) \\<in> set (fst (split t U S))\n\ngoal (1 subgoal):\n 1. (\\<And>t' x.\n        \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n         0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n         (monomial (1::'a) s, V)\n         \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n         set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n         \\<subseteq> set (snd (split t U S))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct t U S arbitrary: thesis rule: split_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base1 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<in> S\n  \\<lbrakk>?t'19 \\<in> .[X]; ?x19 \\<in> X; V \\<subseteq> U;\n   0 \\<notin> (\\<lambda>s. s - ?t'19) ` S; s = ?t'19 + t + monomial 1 ?x19;\n   (monomial (1::'a) s, V)\n   \\<in> set (fst (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)));\n   set (snd (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n   \\<subseteq> set (snd ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> S\n  (monomial (1::'a) s, V) \\<in> set (fst ([(monomial (1::'a) t, U)], []))\n\ngoal (3 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst ([(monomial (1::'a) t, U)], []))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "from base1.prems(2) base1.hyps(3)"], ["proof (chain)\npicking this:\n  0 \\<notin> S\n  0 \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<notin> S\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (base2 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] = {}\n  \\<lbrakk>?t'19 \\<in> .[X]; ?x19 \\<in> X; V \\<subseteq> U;\n   0 \\<notin> (\\<lambda>s. s - ?t'19) ` S; s = ?t'19 + t + monomial 1 ?x19;\n   (monomial (1::'a) s, V)\n   \\<in> set (fst (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)));\n   set (snd (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n   \\<subseteq> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> S\n  (monomial (1::'a) s, V) \\<in> set (fst ([], [(monomial (1::'a) t, U)]))\n\ngoal (2 subgoals):\n 1. \\<And>t U S thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {};\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst ([], [(monomial (1::'a) t, U)]))\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "from base2.prems(3)"], ["proof (chain)\npicking this:\n  (monomial (1::'a) s, V) \\<in> set (fst ([], [(monomial (1::'a) t, U)]))", "show ?case"], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V) \\<in> set (fst ([], [(monomial (1::'a) t, U)]))\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step t U S V0 x ps0 ps1 qs0 qs1)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] \\<noteq> {}\n  V0 \\<subseteq> U\n  S \\<inter> .[V0] = {}\n  \\<lbrakk>?V'19 \\<subseteq> U; S \\<inter> .[?V'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?V'19 \\<le> card V0\n  x \\<in> U\n  x \\<notin> V0\n  V0 = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {})\n  x = (SOME x'. x' \\<in> U - V0)\n  (ps0, qs0) = split t (U - {x}) S\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S)\n  split t U S = (ps0 @ ps1, qs0 @ qs1)\n  \\<lbrakk>\\<And>t' xa.\n              \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U - {x};\n               0 \\<notin> (\\<lambda>s. s - t') ` S;\n               s = t' + t + monomial 1 xa;\n               (monomial (1::'a) s, V)\n               \\<in> set (fst (split (t' + t) V\n                                ((\\<lambda>s. s - t') ` S)));\n               set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n               \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n              \\<Longrightarrow> ?thesis19;\n   0 \\<notin> S; (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n  \\<lbrakk>\\<And>t' xa.\n              \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n               0 \\<notin> (\\<lambda>s. s - t') `\n                          (\\<lambda>f. f - monomial 1 x) ` S;\n               s = t' + (monomial 1 x + t) + monomial 1 xa;\n               (monomial (1::'a) s, V)\n               \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n                                ((\\<lambda>s. s - t') `\n                                 (\\<lambda>f. f - monomial 1 x) ` S)));\n               set (snd (split (t' + (monomial 1 x + t)) V\n                          ((\\<lambda>s. s - t') `\n                           (\\<lambda>f. f - monomial 1 x) ` S)))\n               \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n              \\<Longrightarrow> ?thesis19;\n   0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n   (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n  \\<lbrakk>?t'19 \\<in> .[X]; ?x19 \\<in> X; V \\<subseteq> U;\n   0 \\<notin> (\\<lambda>s. s - ?t'19) ` S; s = ?t'19 + t + monomial 1 ?x19;\n   (monomial (1::'a) s, V)\n   \\<in> set (fst (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)));\n   set (snd (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n   \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n  \\<Longrightarrow> thesis\n  0 \\<notin> S\n  (monomial (1::'a) s, V) \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\n\ngoal (1 subgoal):\n 1. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "from step.prems(3)"], ["proof (chain)\npicking this:\n  (monomial (1::'a) s, V) \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))", "have \"(monomial 1 s, V) \\<in> set ps0 \\<union> set ps1\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V) \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<union> set ps1", "by simp"], ["proof (state)\nthis:\n  (monomial (1::'a) s, V) \\<in> set ps0 \\<union> set ps1\n\ngoal (1 subgoal):\n 1. \\<And>t U S Va x ps0 ps1 qs0 qs1 thesis.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; Va \\<subseteq> U;\n        S \\<inter> .[Va] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card Va;\n        x \\<in> U; x \\<notin> Va;\n        Va = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - Va); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X;\n                        V \\<subseteq> U - {x};\n                        0 \\<notin> (\\<lambda>s. s - t') ` S;\n                        s = t' + t + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + t) V\n   ((\\<lambda>s. s - t') ` S)));\n                        set (snd (split (t' + t) V\n                                   ((\\<lambda>s. s - t') ` S)))\n                        \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>t' xa.\n                       \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n                        0 \\<notin> (\\<lambda>s. s - t') `\n                                   (\\<lambda>f. f - monomial 1 x) ` S;\n                        s = t' + (monomial 1 x + t) + monomial 1 xa;\n                        (monomial (1::'a) s, V)\n                        \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n   ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)));\n                        set (snd (split (t' + (monomial 1 x + t)) V\n                                   ((\\<lambda>s. s - t') `\n                                    (\\<lambda>f. f - monomial 1 x) ` S)))\n                        \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n            (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>t' x.\n           \\<lbrakk>t' \\<in> .[X]; x \\<in> X; V \\<subseteq> U;\n            0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x;\n            (monomial (1::'a) s, V)\n            \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n            set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n            \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 \\<notin> S;\n        (monomial (1::'a) s, V)\n        \\<in> set (fst (ps0 @ ps1, qs0 @ qs1))\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V) \\<in> set ps0 \\<union> set ps1\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "assume \"(monomial 1 s, V) \\<in> set ps0\""], ["proof (state)\nthis:\n  (monomial (1::'a) s, V) \\<in> set ps0\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "hence \"(monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V) \\<in> set ps0\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))", "by (simp only: fst_conv)"], ["proof (state)\nthis:\n  (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "with step.hyps(3)"], ["proof (chain)\npicking this:\n  0 \\<notin> S\n  (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))", "obtain t' x' where \"t' \\<in> .[X]\" and \"x' \\<in> X\" and \"V \\<subseteq> U - {x}\"\n      and \"0 \\<notin> (\\<lambda>s. s - t') ` S\" and \"s = t' + t + Poly_Mapping.single x' 1\"\n      and \"(monomial (1::'a) s, V) \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\"\n      and \"set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S))) \\<subseteq> set (snd (ps0, qs0))\""], ["proof (prove)\nusing this:\n  0 \\<notin> S\n  (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\n\ngoal (1 subgoal):\n 1. (\\<And>t' x'.\n        \\<lbrakk>t' \\<in> .[X]; x' \\<in> X; V \\<subseteq> U - {x};\n         0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x';\n         (monomial (1::'a) s, V)\n         \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n         set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n         \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step.hyps(15)"], ["proof (prove)\nusing this:\n  0 \\<notin> S\n  (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\n  \\<lbrakk>\\<And>t' xa.\n              \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U - {x};\n               0 \\<notin> (\\<lambda>s. s - t') ` S;\n               s = t' + t + monomial 1 xa;\n               (monomial (1::'a) s, V)\n               \\<in> set (fst (split (t' + t) V\n                                ((\\<lambda>s. s - t') ` S)));\n               set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n               \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n              \\<Longrightarrow> ?thesis19;\n   0 \\<notin> S; (monomial (1::'a) s, V) \\<in> set (fst (ps0, qs0))\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n\ngoal (1 subgoal):\n 1. (\\<And>t' x'.\n        \\<lbrakk>t' \\<in> .[X]; x' \\<in> X; V \\<subseteq> U - {x};\n         0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + t + monomial 1 x';\n         (monomial (1::'a) s, V)\n         \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)));\n         set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n         \\<subseteq> set (snd (ps0, qs0))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in> .[X]\n  x' \\<in> X\n  V \\<subseteq> U - {x}\n  0 \\<notin> (\\<lambda>s. s - t') ` S\n  s = t' + t + monomial 1 x'\n  (monomial (1::'a) s, V)\n  \\<in> set (fst (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n  set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (ps0, qs0))\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "note this(7)"], ["proof (state)\nthis:\n  set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (ps0, qs0))\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (ps0, qs0))\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "have \"set (snd (ps0, qs0)) \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (ps0, qs0)) \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "by simp"], ["proof (state)\nthis:\n  set (snd (ps0, qs0)) \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "have \"set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S))) \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\nusing this:\n  set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal (1 subgoal):\n 1. set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "."], ["proof (state)\nthis:\n  set (snd (split (t' + t) V ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "from \\<open>V \\<subseteq> U - {x}\\<close>"], ["proof (chain)\npicking this:\n  V \\<subseteq> U - {x}", "have \"V \\<subseteq> U\""], ["proof (prove)\nusing this:\n  V \\<subseteq> U - {x}\n\ngoal (1 subgoal):\n 1. V \\<subseteq> U", "by blast"], ["proof (state)\nthis:\n  V \\<subseteq> U\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V) \\<in> set ps0 \\<Longrightarrow> thesis\n 2. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule step.prems) fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "assume \"(monomial 1 s, V) \\<in> set ps1\""], ["proof (state)\nthis:\n  (monomial (1::'a) s, V) \\<in> set ps1\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V) \\<in> set ps1 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"0 \\<in> (\\<lambda>f. f - Poly_Mapping.single x 1) ` S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis\n 2. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  0 \\<in> (\\<lambda>f. f - monomial 1 x) ` S\n\ngoal (2 subgoals):\n 1. 0 \\<in> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis\n 2. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "from step.hyps(2)"], ["proof (chain)\npicking this:\n  finite S", "have fin: \"finite ((\\<lambda>f. f - Poly_Mapping.single x 1) ` S)\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>f. f - monomial 1 x) ` S)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite ((\\<lambda>f. f - monomial 1 x) ` S)\n\ngoal (2 subgoals):\n 1. 0 \\<in> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis\n 2. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "have \"split (Poly_Mapping.single x 1 + t) U ((\\<lambda>f. f - Poly_Mapping.single x 1) ` S) =\n              ([(monomial (1::'a) (Poly_Mapping.single x 1 + t), U)], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S) =\n    ([(monomial (1::'a) (monomial 1 x + t), U)], [])", "by (simp only: split.psimps[OF split_domI, OF assms(1) step.hyps(1) fin] True if_True)"], ["proof (state)\nthis:\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S) =\n  ([(monomial (1::'a) (monomial 1 x + t), U)], [])\n\ngoal (2 subgoals):\n 1. 0 \\<in> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis\n 2. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "hence \"ps1 = [(monomial 1 (Poly_Mapping.single x 1 + t), U)]\""], ["proof (prove)\nusing this:\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S) =\n  ([(monomial (1::'a) (monomial 1 x + t), U)], [])\n\ngoal (1 subgoal):\n 1. ps1 = [(monomial (1::'a) (monomial 1 x + t), U)]", "by (simp only: step.hyps(13)[symmetric] prod.inject)"], ["proof (state)\nthis:\n  ps1 = [(monomial (1::'a) (monomial 1 x + t), U)]\n\ngoal (2 subgoals):\n 1. 0 \\<in> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis\n 2. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "with \\<open>(monomial 1 s, V) \\<in> set ps1\\<close>"], ["proof (chain)\npicking this:\n  (monomial (1::'a) s, V) \\<in> set ps1\n  ps1 = [(monomial (1::'a) (monomial 1 x + t), U)]", "have s: \"s = Poly_Mapping.single x 1 + t\" and \"V = U\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V) \\<in> set ps1\n  ps1 = [(monomial (1::'a) (monomial 1 x + t), U)]\n\ngoal (1 subgoal):\n 1. s = monomial 1 x + t &&& V = U", "by (auto dest!: monomial_inj)"], ["proof (state)\nthis:\n  s = monomial 1 x + t\n  V = U\n\ngoal (2 subgoals):\n 1. 0 \\<in> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis\n 2. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (7 subgoals):\n 1. ?t'19 \\<in> .[X]\n 2. ?x19 \\<in> X\n 3. V \\<subseteq> U\n 4. 0 \\<notin> (\\<lambda>s. s - ?t'19) ` S\n 5. s = ?t'19 + t + monomial 1 ?x19\n 6. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n 7. set (snd (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"0 \\<in> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> .[X]", "by (fact zero_in_PPs)"], ["proof (state)\nthis:\n  0 \\<in> .[X]\n\ngoal (6 subgoals):\n 1. ?x19 \\<in> X\n 2. V \\<subseteq> U\n 3. 0 \\<notin> (\\<lambda>s. s - 0) ` S\n 4. s = 0 + t + monomial 1 ?x19\n 5. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 6. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. ?x19 \\<in> X\n 2. V \\<subseteq> U\n 3. 0 \\<notin> (\\<lambda>s. s - 0) ` S\n 4. s = 0 + t + monomial 1 ?x19\n 5. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 6. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "from step.hyps(8, 1)"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<subseteq> X", "show \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", ".."], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (5 subgoals):\n 1. V \\<subseteq> U\n 2. 0 \\<notin> (\\<lambda>s. s - 0) ` S\n 3. s = 0 + t + monomial 1 x\n 4. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 5. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. V \\<subseteq> U\n 2. 0 \\<notin> (\\<lambda>s. s - 0) ` S\n 3. s = 0 + t + monomial 1 x\n 4. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 5. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"V \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> U", "by (simp add: \\<open>V = U\\<close>)"], ["proof (state)\nthis:\n  V \\<subseteq> U\n\ngoal (4 subgoals):\n 1. 0 \\<notin> (\\<lambda>s. s - 0) ` S\n 2. s = 0 + t + monomial 1 x\n 3. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 4. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 \\<notin> (\\<lambda>s. s - 0) ` S\n 2. s = 0 + t + monomial 1 x\n 3. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 4. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "from step.hyps(3)"], ["proof (chain)\npicking this:\n  0 \\<notin> S", "show \"0 \\<notin> (\\<lambda>s. s - 0) ` S\""], ["proof (prove)\nusing this:\n  0 \\<notin> S\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>s. s - 0) ` S", "by simp"], ["proof (state)\nthis:\n  0 \\<notin> (\\<lambda>s. s - 0) ` S\n\ngoal (3 subgoals):\n 1. s = 0 + t + monomial 1 x\n 2. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 3. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. s = 0 + t + monomial 1 x\n 2. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 3. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"s = 0 + t + Poly_Mapping.single x 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = 0 + t + monomial 1 x", "by (simp add: s add.commute)"], ["proof (state)\nthis:\n  s = 0 + t + monomial 1 x\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 2. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n 2. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"(monomial (1::'a) s, V) \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))", "using \\<open>(monomial 1 s, V) \\<in> set ps1\\<close>"], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V) \\<in> set ps1\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))", "by (simp add: step.hyps(14) \\<open>V = U\\<close>)"], ["proof (state)\nthis:\n  (monomial (1::'a) s, V)\n  \\<in> set (fst (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n\ngoal (1 subgoal):\n 1. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S))) \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "by (simp add: step.hyps(14) \\<open>V = U\\<close>)"], ["proof (state)\nthis:\n  set (snd (split (0 + t) V ((\\<lambda>s. s - 0) ` S)))\n  \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "from \\<open>(monomial 1 s, V) \\<in> set ps1\\<close>"], ["proof (chain)\npicking this:\n  (monomial (1::'a) s, V) \\<in> set ps1", "have \"(monomial 1 s, V) \\<in> set (fst (ps1, qs1))\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V) \\<in> set ps1\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))", "by (simp only: fst_conv)"], ["proof (state)\nthis:\n  (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\n  (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))", "obtain t' x' where \"t' \\<in> .[X]\" and \"x' \\<in> X\" and \"V \\<subseteq> U\"\n        and 1: \"0 \\<notin> (\\<lambda>s. s - t') ` (\\<lambda>f. f - Poly_Mapping.single x 1) ` S\"\n        and s: \"s = t' + (Poly_Mapping.single x 1 + t) + Poly_Mapping.single x' 1\"\n        and 2: \"(monomial (1::'a) s, V) \\<in> set (fst (split (t' + (Poly_Mapping.single x 1 + t)) V\n                                            ((\\<lambda>s. s - t') ` (\\<lambda>f. f - Poly_Mapping.single x 1) ` S)))\"\n        and 3: \"set (snd (split (t' + (Poly_Mapping.single x 1 + t)) V ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S))) \\<subseteq>\n                  set (snd (ps1, qs1))\""], ["proof (prove)\nusing this:\n  0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\n  (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\n\ngoal (1 subgoal):\n 1. (\\<And>t' x'.\n        \\<lbrakk>t' \\<in> .[X]; x' \\<in> X; V \\<subseteq> U;\n         0 \\<notin> (\\<lambda>s. s - t') `\n                    (\\<lambda>f. f - monomial 1 x) ` S;\n         s = t' + (monomial 1 x + t) + monomial 1 x';\n         (monomial (1::'a) s, V)\n         \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n                          ((\\<lambda>s. s - t') `\n                           (\\<lambda>f. f - monomial 1 x) ` S)));\n         set (snd (split (t' + (monomial 1 x + t)) V\n                    ((\\<lambda>s. s - t') `\n                     (\\<lambda>f. f - monomial 1 x) ` S)))\n         \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step.hyps(16)"], ["proof (prove)\nusing this:\n  0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S\n  (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\n  \\<lbrakk>\\<And>t' xa.\n              \\<lbrakk>t' \\<in> .[X]; xa \\<in> X; V \\<subseteq> U;\n               0 \\<notin> (\\<lambda>s. s - t') `\n                          (\\<lambda>f. f - monomial 1 x) ` S;\n               s = t' + (monomial 1 x + t) + monomial 1 xa;\n               (monomial (1::'a) s, V)\n               \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n                                ((\\<lambda>s. s - t') `\n                                 (\\<lambda>f. f - monomial 1 x) ` S)));\n               set (snd (split (t' + (monomial 1 x + t)) V\n                          ((\\<lambda>s. s - t') `\n                           (\\<lambda>f. f - monomial 1 x) ` S)))\n               \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n              \\<Longrightarrow> ?thesis19;\n   0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S;\n   (monomial (1::'a) s, V) \\<in> set (fst (ps1, qs1))\\<rbrakk>\n  \\<Longrightarrow> ?thesis19\n\ngoal (1 subgoal):\n 1. (\\<And>t' x'.\n        \\<lbrakk>t' \\<in> .[X]; x' \\<in> X; V \\<subseteq> U;\n         0 \\<notin> (\\<lambda>s. s - t') `\n                    (\\<lambda>f. f - monomial 1 x) ` S;\n         s = t' + (monomial 1 x + t) + monomial 1 x';\n         (monomial (1::'a) s, V)\n         \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n                          ((\\<lambda>s. s - t') `\n                           (\\<lambda>f. f - monomial 1 x) ` S)));\n         set (snd (split (t' + (monomial 1 x + t)) V\n                    ((\\<lambda>s. s - t') `\n                     (\\<lambda>f. f - monomial 1 x) ` S)))\n         \\<subseteq> set (snd (ps1, qs1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in> .[X]\n  x' \\<in> X\n  V \\<subseteq> U\n  0 \\<notin> (\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S\n  s = t' + (monomial 1 x + t) + monomial 1 x'\n  (monomial (1::'a) s, V)\n  \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n                   ((\\<lambda>s. s - t') `\n                    (\\<lambda>f. f - monomial 1 x) ` S)))\n  set (snd (split (t' + (monomial 1 x + t)) V\n             ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)))\n  \\<subseteq> set (snd (ps1, qs1))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "have eq: \"(\\<lambda>s. s - t') ` (\\<lambda>f. f - Poly_Mapping.single x 1) ` S =\n                (\\<lambda>s. s - (t' + Poly_Mapping.single x 1)) ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S =\n    (\\<lambda>s. s - (t' + monomial 1 x)) ` S", "by (simp add: image_image add.commute diff_diff_eq)"], ["proof (state)\nthis:\n  (\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S =\n  (\\<lambda>s. s - (t' + monomial 1 x)) ` S\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>f. f - monomial 1 x) ` S \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (7 subgoals):\n 1. ?t'19 \\<in> .[X]\n 2. ?x19 \\<in> X\n 3. V \\<subseteq> U\n 4. 0 \\<notin> (\\<lambda>s. s - ?t'19) ` S\n 5. s = ?t'19 + t + monomial 1 ?x19\n 6. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n 7. set (snd (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "from step.hyps(8, 1)"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<subseteq> X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", ".."], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (7 subgoals):\n 1. ?t'19 \\<in> .[X]\n 2. ?x19 \\<in> X\n 3. V \\<subseteq> U\n 4. 0 \\<notin> (\\<lambda>s. s - ?t'19) ` S\n 5. s = ?t'19 + t + monomial 1 ?x19\n 6. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n 7. set (snd (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "hence \"Poly_Mapping.single x 1 \\<in> .[X]\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. monomial 1 x \\<in> .[X]", "by (rule PPs_closed_single)"], ["proof (state)\nthis:\n  monomial 1 x \\<in> .[X]\n\ngoal (7 subgoals):\n 1. ?t'19 \\<in> .[X]\n 2. ?x19 \\<in> X\n 3. V \\<subseteq> U\n 4. 0 \\<notin> (\\<lambda>s. s - ?t'19) ` S\n 5. s = ?t'19 + t + monomial 1 ?x19\n 6. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n 7. set (snd (split (?t'19 + t) V ((\\<lambda>s. s - ?t'19) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "with \\<open>t' \\<in> .[X]\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> .[X]\n  monomial 1 x \\<in> .[X]", "show \"t' + Poly_Mapping.single x 1 \\<in> .[X]\""], ["proof (prove)\nusing this:\n  t' \\<in> .[X]\n  monomial 1 x \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t' + monomial 1 x \\<in> .[X]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  t' + monomial 1 x \\<in> .[X]\n\ngoal (6 subgoals):\n 1. ?x19 \\<in> X\n 2. V \\<subseteq> U\n 3. 0 \\<notin> (\\<lambda>s. s - (t' + monomial 1 x)) ` S\n 4. s = t' + monomial 1 x + t + monomial 1 ?x19\n 5. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n 6. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. ?x19 \\<in> X\n 2. V \\<subseteq> U\n 3. 0 \\<notin> (\\<lambda>s. s - (t' + monomial 1 x)) ` S\n 4. s = t' + monomial 1 x + t + monomial 1 ?x19\n 5. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n 6. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "from 1"], ["proof (chain)\npicking this:\n  0 \\<notin> (\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S", "show \"0 \\<notin> (\\<lambda>s. s - (t' + Poly_Mapping.single x 1)) ` S\""], ["proof (prove)\nusing this:\n  0 \\<notin> (\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S\n\ngoal (1 subgoal):\n 1. 0 \\<notin> (\\<lambda>s. s - (t' + monomial 1 x)) ` S", "by (simp only: eq not_False_eq_True)"], ["proof (state)\nthis:\n  0 \\<notin> (\\<lambda>s. s - (t' + monomial 1 x)) ` S\n\ngoal (5 subgoals):\n 1. ?x19 \\<in> X\n 2. V \\<subseteq> U\n 3. s = t' + monomial 1 x + t + monomial 1 ?x19\n 4. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n 5. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. ?x19 \\<in> X\n 2. V \\<subseteq> U\n 3. s = t' + monomial 1 x + t + monomial 1 ?x19\n 4. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n 5. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"s = t' + Poly_Mapping.single x 1 + t + Poly_Mapping.single x' 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t' + monomial 1 x + t + monomial 1 x'", "by (simp only: s ac_simps)"], ["proof (state)\nthis:\n  s = t' + monomial 1 x + t + monomial 1 x'\n\ngoal (4 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U\n 3. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n 4. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U\n 3. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n 4. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"(monomial (1::'a) s, V) \\<in> set (fst (split (t' + Poly_Mapping.single x 1 + t) V\n                                                ((\\<lambda>s. s - (t' + Poly_Mapping.single x 1)) ` S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))", "using 2"], ["proof (prove)\nusing this:\n  (monomial (1::'a) s, V)\n  \\<in> set (fst (split (t' + (monomial 1 x + t)) V\n                   ((\\<lambda>s. s - t') `\n                    (\\<lambda>f. f - monomial 1 x) ` S)))\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) s, V)\n    \\<in> set (fst (split (t' + monomial 1 x + t) V\n                     ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))", "by (simp only: eq add.assoc)"], ["proof (state)\nthis:\n  (monomial (1::'a) s, V)\n  \\<in> set (fst (split (t' + monomial 1 x + t) V\n                   ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n\ngoal (3 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U\n 3. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U\n 3. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "have \"set (snd (split (t' + Poly_Mapping.single x 1 + t) V ((\\<lambda>s. s - (t' + Poly_Mapping.single x 1)) ` S))) \\<subseteq>\n              set (snd (ps1, qs1))\" (is \"?x \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps1, qs1))", "using 3"], ["proof (prove)\nusing this:\n  set (snd (split (t' + (monomial 1 x + t)) V\n             ((\\<lambda>s. s - t') ` (\\<lambda>f. f - monomial 1 x) ` S)))\n  \\<subseteq> set (snd (ps1, qs1))\n\ngoal (1 subgoal):\n 1. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps1, qs1))", "by (simp only: eq add.assoc)"], ["proof (state)\nthis:\n  set (snd (split (t' + monomial 1 x + t) V\n             ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n  \\<subseteq> set (snd (ps1, qs1))\n\ngoal (3 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U\n 3. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "also"], ["proof (state)\nthis:\n  set (snd (split (t' + monomial 1 x + t) V\n             ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n  \\<subseteq> set (snd (ps1, qs1))\n\ngoal (3 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U\n 3. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "have \"\\<dots> \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (ps1, qs1)) \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "by simp"], ["proof (state)\nthis:\n  set (snd (ps1, qs1)) \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal (3 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U\n 3. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "finally"], ["proof (chain)\npicking this:\n  set (snd (split (t' + monomial 1 x + t) V\n             ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n  \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "show \"?x \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\""], ["proof (prove)\nusing this:\n  set (snd (split (t' + monomial 1 x + t) V\n             ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n  \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal (1 subgoal):\n 1. set (snd (split (t' + monomial 1 x + t) V\n               ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n    \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))", "."], ["proof (state)\nthis:\n  set (snd (split (t' + monomial 1 x + t) V\n             ((\\<lambda>s. s - (t' + monomial 1 x)) ` S)))\n  \\<subseteq> set (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal (2 subgoals):\n 1. x' \\<in> X\n 2. V \\<subseteq> U", "qed fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lem_4_8:\n  assumes \"finite X\" and \"finite S\" and \"S \\<subseteq> .[X]\" and \"0 \\<notin> S\"\n    and \"g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\"\n  obtains t U where \"U \\<subseteq> X\" and \"(monomial (1::'a::field) t, U) \\<in> set (snd (split 0 X S))\"\n    and \"poly_deg g = Suc (deg_pm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?S = \"monomial (1::'a) ` S\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?G = \"punit.reduced_GB ?S\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have md1: \"monomial_decomp (fst ((split 0 X S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list))))\"\n    and md2: \"monomial_decomp (snd ((split 0 X S)::(_ \\<times> (((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (fst (split 0 X S)) &&&\n    monomial_decomp (snd (split 0 X S))", "using assms(1) subset_refl assms(2)"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst (split 0 X S)) &&&\n    monomial_decomp (snd (split 0 X S))", "by (rule monomial_decomp_split)+"], ["proof (state)\nthis:\n  monomial_decomp (fst (split 0 X S))\n  monomial_decomp (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(3)"], ["proof (chain)\npicking this:\n  S \\<subseteq> .[X]", "have 0: \"?S \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) ` S \\<subseteq> P[X]", "by (auto intro: Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1)"], ["proof (chain)\npicking this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]", "have \"punit.is_auto_reduced ?G\" and \"punit.is_monic_set ?G\"\n    and ideal_G: \"ideal ?G = ideal ?S\" and \"0 \\<notin> ?G\""], ["proof (prove)\nusing this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (punit.is_auto_reduced (punit.reduced_GB (monomial (1::'a) ` S)) &&&\n     punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))) &&&\n    ideal (punit.reduced_GB (monomial (1::'a) ` S)) =\n    ideal (monomial (1::'a) ` S) &&&\n    0 \\<notin> punit.reduced_GB (monomial (1::'a) ` S)", "by (rule reduced_GB_is_auto_reduced_Polys, rule reduced_GB_is_monic_set_Polys,\n        rule reduced_GB_ideal_Polys, rule reduced_GB_nonzero_Polys)"], ["proof (state)\nthis:\n  punit.is_auto_reduced (punit.reduced_GB (monomial (1::'a) ` S))\n  punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))\n  ideal (punit.reduced_GB (monomial (1::'a) ` S)) =\n  ideal (monomial (1::'a) ` S)\n  0 \\<notin> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2, 4) assms(5)"], ["proof (chain)\npicking this:\n  punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))\n  0 \\<notin> punit.reduced_GB (monomial (1::'a) ` S)\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)", "have \"punit.lc g = 1\""], ["proof (prove)\nusing this:\n  punit.is_monic_set (punit.reduced_GB (monomial (1::'a) ` S))\n  0 \\<notin> punit.reduced_GB (monomial (1::'a) ` S)\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. lcf g = (1::'a)", "by (auto simp: punit.is_monic_set_def)"], ["proof (state)\nthis:\n  lcf g = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"is_monomial_set ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monomial_set (monomial (1::'a) ` S)", "by (auto intro!: is_monomial_setI monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1) 0"], ["proof (chain)\npicking this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n  is_monomial_set (monomial (1::'a) ` S)", "have \"is_monomial_set ?G\""], ["proof (prove)\nusing this:\n  finite X\n  monomial (1::'a) ` S \\<subseteq> P[X]\n  is_monomial_set (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))", "by (rule reduced_GB_is_monomial_set_Polys)"], ["proof (state)\nthis:\n  is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"is_monomial g\""], ["proof (prove)\nusing this:\n  is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. is_monomial g", "using assms(5)"], ["proof (prove)\nusing this:\n  is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. is_monomial g", "by (rule is_monomial_setD)"], ["proof (state)\nthis:\n  is_monomial g\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  is_monomial g\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define s where \"s = lpp g\""], ["proof (state)\nthis:\n  s = lpp g\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  is_monomial g\n  s = lpp g", "have g: \"g = monomial 1 s\""], ["proof (prove)\nusing this:\n  is_monomial g\n  s = lpp g\n\ngoal (1 subgoal):\n 1. g = monomial (1::'a) s", "using \\<open>punit.lc g = 1\\<close>"], ["proof (prove)\nusing this:\n  is_monomial g\n  s = lpp g\n  lcf g = (1::'a)\n\ngoal (1 subgoal):\n 1. g = monomial (1::'a) s", "by (metis punit.monomial_eq_itself)"], ["proof (state)\nthis:\n  g = monomial (1::'a) s\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms(1) subset_refl assms(2) zero_in_PPs"], ["proof (state)\nthis:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"ideal ?G \\<div> monomial 1 0 = ideal ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (punit.reduced_GB (monomial (1::'a) ` S)) \\<div>\n    monomial (1::'a) 0 =\n    ideal (monomial (1::'a) ` S)", "by (simp add: ideal_G)"], ["proof (state)\nthis:\n  ideal (punit.reduced_GB (monomial (1::'a) ` S)) \\<div>\n  monomial (1::'a) 0 =\n  ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<in> .[?X]\n  ideal (punit.reduced_GB (monomial (1::'a) ` S)) \\<div>\n  monomial (1::'a) 0 =\n  ideal (monomial (1::'a) ` S)", "have \"splits_wrt (split 0 X S) (cone (monomial (1::'a) 0, X)) ?G\""], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<in> .[?X]\n  ideal (punit.reduced_GB (monomial (1::'a) ` S)) \\<div>\n  monomial (1::'a) 0 =\n  ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. splits_wrt (split 0 X S) (cone (monomial (1::'a) 0, X))\n     (punit.reduced_GB (monomial (1::'a) ` S))", "by (rule split_splits_wrt)"], ["proof (state)\nthis:\n  splits_wrt (split 0 X S) (cone (monomial (1::'a) 0, X))\n   (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"splits_wrt (fst (split 0 X S), snd (split 0 X S)) P[X] ?G\""], ["proof (prove)\nusing this:\n  splits_wrt (split 0 X S) (cone (monomial (1::'a) 0, X))\n   (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. splits_wrt (fst (split 0 X S), snd (split 0 X S)) P[X]\n     (punit.reduced_GB (monomial (1::'a) ` S))", "by simp"], ["proof (state)\nthis:\n  splits_wrt (fst (split 0 X S), snd (split 0 X S)) P[X]\n   (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"cone_decomp (P[X] \\<inter> ideal ?G) (fst (split 0 X S))\""], ["proof (prove)\nusing this:\n  splits_wrt (fst (split 0 X S), snd (split 0 X S)) P[X]\n   (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. cone_decomp\n     (P[X] \\<inter> ideal (punit.reduced_GB (monomial (1::'a) ` S)))\n     (fst (split 0 X S))", "using md2 \\<open>is_monomial_set ?G\\<close>"], ["proof (prove)\nusing this:\n  splits_wrt (fst (split 0 X S), snd (split 0 X S)) P[X]\n   (punit.reduced_GB (monomial (1::'a) ` S))\n  monomial_decomp (snd (split 0 X S))\n  is_monomial_set (punit.reduced_GB (monomial (1::'a) ` S))\n\ngoal (1 subgoal):\n 1. cone_decomp\n     (P[X] \\<inter> ideal (punit.reduced_GB (monomial (1::'a) ` S)))\n     (fst (split 0 X S))", "by (rule splits_wrt_cone_decomp_1)"], ["proof (state)\nthis:\n  cone_decomp\n   (P[X] \\<inter> ideal (punit.reduced_GB (monomial (1::'a) ` S)))\n   (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"cone_decomp (P[X] \\<inter> ideal ?S) (fst (split 0 X S))\""], ["proof (prove)\nusing this:\n  cone_decomp\n   (P[X] \\<inter> ideal (punit.reduced_GB (monomial (1::'a) ` S)))\n   (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S))\n     (fst (split 0 X S))", "by (simp only: ideal_G)"], ["proof (state)\nthis:\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S))\n   (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1, 3, 5)"], ["proof (chain)\npicking this:\n  finite X\n  S \\<subseteq> .[X]\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S))\n   (fst (split 0 X S))", "obtain U where \"(g, U) \\<in> set (fst (split 0 X S))\""], ["proof (prove)\nusing this:\n  finite X\n  S \\<subseteq> .[X]\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S))\n   (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set (fst (split 0 X S)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using md1"], ["proof (prove)\nusing this:\n  finite X\n  S \\<subseteq> .[X]\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  cone_decomp (P[X] \\<inter> ideal (monomial (1::'a) ` S))\n   (fst (split 0 X S))\n  monomial_decomp (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        (g, U) \\<in> set (fst (split 0 X S)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule lem_4_7)"], ["proof (state)\nthis:\n  (g, U) \\<in> set (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1) subset_refl assms(2, 4)"], ["proof (chain)\npicking this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<notin> S\n  (g, U) \\<in> set (fst (split 0 X S))", "obtain t' x where \"t' \\<in> .[X]\" and \"x \\<in> X\" and \"U \\<subseteq> X\"\n    and \"0 \\<notin> (\\<lambda>s. s - t') ` S\" and s: \"s = t' + 0 + Poly_Mapping.single x 1\"\n    and \"(g, U) \\<in> set (fst (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\"\n    and \"set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S))) \\<subseteq> (set (snd (split 0 X S)) :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) set)\""], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<notin> S\n  (g, U) \\<in> set (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>t' x.\n        \\<lbrakk>t' \\<in> .[X]; x \\<in> X; U \\<subseteq> X;\n         0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + 0 + monomial 1 x;\n         (g, U)\n         \\<in> set (fst (split (t' + 0) U ((\\<lambda>s. s - t') ` S)));\n         set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n         \\<subseteq> set (snd (split 0 X S))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding g"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<notin> S\n  (monomial (1::'a) s, U) \\<in> set (fst (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>t' x.\n        \\<lbrakk>t' \\<in> .[X]; x \\<in> X; U \\<subseteq> X;\n         0 \\<notin> (\\<lambda>s. s - t') ` S; s = t' + 0 + monomial 1 x;\n         (monomial (1::'a) s, U)\n         \\<in> set (fst (split (t' + 0) U ((\\<lambda>s. s - t') ` S)));\n         set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n         \\<subseteq> set (snd (split 0 X S))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule fst_splitE)"], ["proof (state)\nthis:\n  t' \\<in> .[X]\n  x \\<in> X\n  U \\<subseteq> X\n  0 \\<notin> (\\<lambda>s. s - t') ` S\n  s = t' + 0 + monomial 1 x\n  (g, U) \\<in> set (fst (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n  set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?S = \"(\\<lambda>s. s - t') ` S\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  finite S", "have \"finite ?S\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>s. s - t') ` S)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite ((\\<lambda>s. s - t') ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(1) \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite ((\\<lambda>s. s - t') ` S)", "obtain V where \"V \\<subseteq> U\"\n    and \"(monomial (1::'a) (t' + 0), V) \\<in> set (snd (split (t' + 0) U ?S))\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite ((\\<lambda>s. s - t') ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<subseteq> U;\n         (monomial (1::'a) (t' + 0), V)\n         \\<in> set (snd (split (t' + 0) U\n                          ((\\<lambda>s. s - t') ` S)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>0 \\<notin> ?S\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite ((\\<lambda>s. s - t') ` S)\n  0 \\<notin> (\\<lambda>s. s - t') ` S\n\ngoal (1 subgoal):\n 1. (\\<And>V.\n        \\<lbrakk>V \\<subseteq> U;\n         (monomial (1::'a) (t' + 0), V)\n         \\<in> set (snd (split (t' + 0) U\n                          ((\\<lambda>s. s - t') ` S)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule snd_splitI)"], ["proof (state)\nthis:\n  V \\<subseteq> U\n  (monomial (1::'a) (t' + 0), V)\n  \\<in> set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note this(2)"], ["proof (state)\nthis:\n  (monomial (1::'a) (t' + 0), V)\n  \\<in> set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (monomial (1::'a) (t' + 0), V)\n  \\<in> set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> \\<subseteq> set (snd (split 0 X S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n    \\<subseteq> set (snd (split 0 X S))", "by fact"], ["proof (state)\nthis:\n  set (snd (split (t' + 0) U ((\\<lambda>s. s - t') ` S)))\n  \\<subseteq> set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  (monomial (1::'a) (t' + 0), V) \\<in> set (snd (split 0 X S))", "have \"(monomial (1::'a) t', V) \\<in> set (snd (split 0 X S))\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) (t' + 0), V) \\<in> set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) t', V) \\<in> set (snd (split 0 X S))", "by simp"], ["proof (state)\nthis:\n  (monomial (1::'a) t', V) \\<in> set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly_deg g = Suc (deg_pm t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g = Suc (deg_pm t')", "by (simp add: g s deg_pm_plus deg_pm_single poly_deg_monomial)"], ["proof (state)\nthis:\n  poly_deg g = Suc (deg_pm t')\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>V \\<subseteq> U\\<close> \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  V \\<subseteq> U\n  U \\<subseteq> X", "have \"V \\<subseteq> X\""], ["proof (prove)\nusing this:\n  V \\<subseteq> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. V \\<subseteq> X", "by (rule subset_trans)"], ["proof (state)\nthis:\n  V \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<And>U t.\n        \\<lbrakk>U \\<subseteq> X;\n         (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by rule fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary cor_4_9:\n  assumes \"finite X\" and \"finite S\" and \"S \\<subseteq> .[X]\"\n    and \"g \\<in> punit.reduced_GB (monomial (1::'a::field) ` S)\"\n  shows \"poly_deg g \\<le> Suc (Max (poly_deg ` fst ` (set (snd (split 0 X S)) :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) set)))\"\n        (is \"_ \\<le> Suc (Max (poly_deg ` fst ` ?S))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "proof (cases \"0 \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "case True"], ["proof (state)\nthis:\n  0 \\<in> S\n\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "hence \"1 \\<in> monomial (1::'a) ` S\""], ["proof (prove)\nusing this:\n  0 \\<in> S\n\ngoal (1 subgoal):\n 1. 1 \\<in> monomial (1::'a) ` S", "by (rule rev_image_eqI) (simp only: single_one)"], ["proof (state)\nthis:\n  1 \\<in> monomial (1::'a) ` S\n\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "hence \"1 \\<in> ideal (monomial (1::'a) ` S)\""], ["proof (prove)\nusing this:\n  1 \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. 1 \\<in> ideal (monomial (1::'a) ` S)", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  1 \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "hence \"ideal (monomial (1::'a) ` S) = UNIV\""], ["proof (prove)\nusing this:\n  1 \\<in> ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. ideal (monomial (1::'a) ` S) = UNIV", "by (simp only: ideal_eq_UNIV_iff_contains_one)"], ["proof (state)\nthis:\n  ideal (monomial (1::'a) ` S) = UNIV\n\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "moreover"], ["proof (state)\nthis:\n  ideal (monomial (1::'a) ` S) = UNIV\n\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "from assms(3)"], ["proof (chain)\npicking this:\n  S \\<subseteq> .[X]", "have \"monomial (1::'a) ` S \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) ` S \\<subseteq> P[X]", "by (auto intro: Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "ultimately"], ["proof (chain)\npicking this:\n  ideal (monomial (1::'a) ` S) = UNIV\n  monomial (1::'a) ` S \\<subseteq> P[X]", "have \"punit.reduced_GB (monomial (1::'a) ` S) = {1}\""], ["proof (prove)\nusing this:\n  ideal (monomial (1::'a) ` S) = UNIV\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.reduced_GB (monomial (1::'a) ` S) = {1}", "using assms(1)"], ["proof (prove)\nusing this:\n  ideal (monomial (1::'a) ` S) = UNIV\n  monomial (1::'a) ` S \\<subseteq> P[X]\n  finite X\n\ngoal (1 subgoal):\n 1. punit.reduced_GB (monomial (1::'a) ` S) = {1}", "by (simp only: ideal_eq_UNIV_iff_reduced_GB_eq_one_Polys)"], ["proof (state)\nthis:\n  punit.reduced_GB (monomial (1::'a) ` S) = {1}\n\ngoal (2 subgoals):\n 1. 0 \\<in> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n 2. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "with assms(4)"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  punit.reduced_GB (monomial (1::'a) ` S) = {1}", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n  punit.reduced_GB (monomial (1::'a) ` S) = {1}\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "by simp"], ["proof (state)\nthis:\n  poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "case False"], ["proof (state)\nthis:\n  0 \\<notin> S\n\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "have fin: \"finite (poly_deg ` fst ` ?S)\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set (snd (split 0 X S)))", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set (snd (split 0 X S)))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "obtain t U where \"(monomial 1 t, U) \\<in> ?S\" and g: \"poly_deg g = Suc (deg_pm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t U.\n        \\<lbrakk>(monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1-3) False assms(4)"], ["proof (prove)\nusing this:\n  finite X\n  finite S\n  S \\<subseteq> .[X]\n  0 \\<notin> S\n  g \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>t U.\n        \\<lbrakk>(monomial (1::'a) t, U) \\<in> set (snd (split 0 X S));\n         poly_deg g = Suc (deg_pm t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lem_4_8)"], ["proof (state)\nthis:\n  (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S))\n  poly_deg g = Suc (deg_pm t)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "from this(1)"], ["proof (chain)\npicking this:\n  (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S))", "have \"poly_deg (fst (monomial (1::'a) t, U)) \\<in> poly_deg ` fst ` ?S\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) t, U) \\<in> set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. poly_deg (fst (monomial (1::'a) t, U))\n    \\<in> poly_deg ` fst ` set (snd (split 0 X S))", "by (intro imageI)"], ["proof (state)\nthis:\n  poly_deg (fst (monomial (1::'a) t, U))\n  \\<in> poly_deg ` fst ` set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "hence \"deg_pm t \\<in> poly_deg ` fst ` ?S\""], ["proof (prove)\nusing this:\n  poly_deg (fst (monomial (1::'a) t, U))\n  \\<in> poly_deg ` fst ` set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. deg_pm t \\<in> poly_deg ` fst ` set (snd (split 0 X S))", "by (simp add: poly_deg_monomial)"], ["proof (state)\nthis:\n  deg_pm t \\<in> poly_deg ` fst ` set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "with fin"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (snd (split 0 X S)))\n  deg_pm t \\<in> poly_deg ` fst ` set (snd (split 0 X S))", "have \"deg_pm t \\<le> Max (poly_deg ` fst ` ?S)\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (snd (split 0 X S)))\n  deg_pm t \\<in> poly_deg ` fst ` set (snd (split 0 X S))\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> Max (poly_deg ` fst ` set (snd (split 0 X S)))", "by (rule Max_ge)"], ["proof (state)\nthis:\n  deg_pm t \\<le> Max (poly_deg ` fst ` set (snd (split 0 X S)))\n\ngoal (1 subgoal):\n 1. 0 \\<notin> S \\<Longrightarrow>\n    poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "thus \"poly_deg g \\<le> Suc (Max (poly_deg ` fst ` ?S))\""], ["proof (prove)\nusing this:\n  deg_pm t \\<le> Max (poly_deg ` fst ` set (snd (split 0 X S)))\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "by (simp add: g)"], ["proof (state)\nthis:\n  poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_decomp_snd_split:\n  assumes \"finite X\" and \"U \\<subseteq> X\" and \"finite S\" and \"S \\<subseteq> .[X]\" and \"t \\<in> .[X]\"\n  shows \"standard_decomp (deg_pm t) (snd (split t U S) :: ((_ \\<Rightarrow>\\<^sub>0 'a::field) \\<times> _) list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm t) (snd (split t U S))", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  S \\<subseteq> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm t) (snd (split t U S))", "proof (induct t U S rule: split_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; S \\<subseteq> .[X];\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([(monomial (1::'a) t, U)], []))\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "case (base1 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<in> S\n  S \\<subseteq> .[X]\n  t \\<in> .[X]\n\ngoal (3 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<in> S; S \\<subseteq> .[X];\n        t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([(monomial (1::'a) t, U)], []))\n 2. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 3. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm t) (snd ([(monomial (1::'a) t, U)], []))", "by (simp add: standard_decomp_Nil)"], ["proof (state)\nthis:\n  standard_decomp (deg_pm t) (snd ([(monomial (1::'a) t, U)], []))\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "case (base2 t U S)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] = {}\n  S \\<subseteq> .[X]\n  t \\<in> .[X]\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "have \"deg_pm t = poly_deg (monomial (1::'a) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pm t = poly_deg (monomial (1::'a) t)", "by (simp add: poly_deg_monomial)"], ["proof (state)\nthis:\n  deg_pm t = poly_deg (monomial (1::'a) t)\n\ngoal (2 subgoals):\n 1. \\<And>t U S.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] = {}; S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd ([], [(monomial (1::'a) t, U)]))\n 2. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "thus ?case"], ["proof (prove)\nusing this:\n  deg_pm t = poly_deg (monomial (1::'a) t)\n\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm t) (snd ([], [(monomial (1::'a) t, U)]))", "by (simp add: standard_decomp_singleton)"], ["proof (state)\nthis:\n  standard_decomp (deg_pm t) (snd ([], [(monomial (1::'a) t, U)]))\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "case (step t U S V x ps0 ps1 qs0 qs1)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n  finite S\n  0 \\<notin> S\n  S \\<inter> .[U] \\<noteq> {}\n  V \\<subseteq> U\n  S \\<inter> .[V] = {}\n  \\<lbrakk>?V'19 \\<subseteq> U; S \\<inter> .[?V'19] = {}\\<rbrakk>\n  \\<Longrightarrow> card ?V'19 \\<le> card V\n  x \\<in> U\n  x \\<notin> V\n  V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {})\n  x = (SOME x'. x' \\<in> U - V)\n  (ps0, qs0) = split t (U - {x}) S\n  (ps1, qs1) =\n  split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S)\n  split t U S = (ps0 @ ps1, qs0 @ qs1)\n  \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n  \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0))\n  \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n   monomial 1 x + t \\<in> .[X]\\<rbrakk>\n  \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                     (snd (ps1, qs1))\n  S \\<subseteq> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "from step.hyps(15) step.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n  \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0))\n  S \\<subseteq> .[X]\n  t \\<in> .[X]", "have qs0: \"standard_decomp (deg_pm t) qs0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n  \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0))\n  S \\<subseteq> .[X]\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm t) qs0", "by (simp only: snd_conv)"], ["proof (state)\nthis:\n  standard_decomp (deg_pm t) qs0\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "have \"(\\<lambda>s. s - Poly_Mapping.single x 1) ` S \\<subseteq> .[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. s - monomial 1 x) ` S \\<subseteq> .[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> (\\<lambda>s. s - monomial 1 x) ` S \\<Longrightarrow>\n       xa \\<in> .[X]", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> (\\<lambda>s. s - monomial 1 x) ` S \\<Longrightarrow>\n       xa \\<in> .[X]", "assume \"u \\<in> (\\<lambda>s. s - Poly_Mapping.single x 1) ` S\""], ["proof (state)\nthis:\n  u \\<in> (\\<lambda>s. s - monomial 1 x) ` S\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> (\\<lambda>s. s - monomial 1 x) ` S \\<Longrightarrow>\n       xa \\<in> .[X]", "then"], ["proof (chain)\npicking this:\n  u \\<in> (\\<lambda>s. s - monomial 1 x) ` S", "obtain s where \"s \\<in> S\" and u: \"u = s - Poly_Mapping.single x 1\""], ["proof (prove)\nusing this:\n  u \\<in> (\\<lambda>s. s - monomial 1 x) ` S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> S; u = s - monomial 1 x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> S\n  u = s - monomial 1 x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> (\\<lambda>s. s - monomial 1 x) ` S \\<Longrightarrow>\n       xa \\<in> .[X]", "from this(1) step.prems(1)"], ["proof (chain)\npicking this:\n  s \\<in> S\n  S \\<subseteq> .[X]", "have \"s \\<in> .[X]\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. s \\<in> .[X]", ".."], ["proof (state)\nthis:\n  s \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> (\\<lambda>s. s - monomial 1 x) ` S \\<Longrightarrow>\n       xa \\<in> .[X]", "thus \"u \\<in> .[X]\""], ["proof (prove)\nusing this:\n  s \\<in> .[X]\n\ngoal (1 subgoal):\n 1. u \\<in> .[X]", "unfolding u"], ["proof (prove)\nusing this:\n  s \\<in> .[X]\n\ngoal (1 subgoal):\n 1. s - monomial 1 x \\<in> .[X]", "by (rule PPs_closed_minus)"], ["proof (state)\nthis:\n  u \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>s. s - monomial 1 x) ` S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>s. s - monomial 1 x) ` S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "from _ step.prems(2)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  t \\<in> .[X]", "have \"Poly_Mapping.single x 1 + t \\<in> .[X]\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial 1 x + t \\<in> .[X]", "proof (rule PPs_closed_plus)"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial 1 x \\<in> .[X]", "from step.hyps(8, 1)"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<subseteq> X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", ".."], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. monomial 1 x \\<in> .[X]", "thus \"Poly_Mapping.single x 1 \\<in> .[X]\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. monomial 1 x \\<in> .[X]", "by (rule PPs_closed_single)"], ["proof (state)\nthis:\n  monomial 1 x \\<in> .[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial 1 x + t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>s. s - monomial 1 x) ` S \\<subseteq> .[X]\n  monomial 1 x + t \\<in> .[X]", "have qs1: \"standard_decomp (Suc (deg_pm t)) qs1\""], ["proof (prove)\nusing this:\n  (\\<lambda>s. s - monomial 1 x) ` S \\<subseteq> .[X]\n  monomial 1 x + t \\<in> .[X]\n\ngoal (1 subgoal):\n 1. standard_decomp (Suc (deg_pm t)) qs1", "using step.hyps(16)"], ["proof (prove)\nusing this:\n  (\\<lambda>s. s - monomial 1 x) ` S \\<subseteq> .[X]\n  monomial 1 x + t \\<in> .[X]\n  \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n   monomial 1 x + t \\<in> .[X]\\<rbrakk>\n  \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                     (snd (ps1, qs1))\n\ngoal (1 subgoal):\n 1. standard_decomp (Suc (deg_pm t)) qs1", "by (simp add: deg_pm_plus deg_pm_single)"], ["proof (state)\nthis:\n  standard_decomp (Suc (deg_pm t)) qs1\n\ngoal (1 subgoal):\n 1. \\<And>t U S V x ps0 ps1 qs0 qs1.\n       \\<lbrakk>U \\<subseteq> X; finite S; 0 \\<notin> S;\n        S \\<inter> .[U] \\<noteq> {}; V \\<subseteq> U; S \\<inter> .[V] = {};\n        \\<And>V'.\n           \\<lbrakk>V' \\<subseteq> U; S \\<inter> .[V'] = {}\\<rbrakk>\n           \\<Longrightarrow> card V' \\<le> card V;\n        x \\<in> U; x \\<notin> V;\n        V = max_subset U (\\<lambda>V'. S \\<inter> .[V'] = {});\n        x = (SOME x'. x' \\<in> U - V); (ps0, qs0) = split t (U - {x}) S;\n        (ps1, qs1) =\n        split (monomial 1 x + t) U ((\\<lambda>f. f - monomial 1 x) ` S);\n        split t U S = (ps0 @ ps1, qs0 @ qs1);\n        \\<lbrakk>S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm t) (snd (ps0, qs0));\n        \\<lbrakk>(\\<lambda>f. f - monomial 1 x) ` S \\<subseteq> .[X];\n         monomial 1 x + t \\<in> .[X]\\<rbrakk>\n        \\<Longrightarrow> standard_decomp (deg_pm (monomial 1 x + t))\n                           (snd (ps1, qs1));\n        S \\<subseteq> .[X]; t \\<in> .[X]\\<rbrakk>\n       \\<Longrightarrow> standard_decomp (deg_pm t)\n                          (snd (ps0 @ ps1, qs0 @ qs1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm t) (snd (ps0 @ ps1, qs0 @ qs1))", "unfolding snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm t) (qs0 @ qs1)", "proof (rule standard_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+); deg_pm t \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (qs0 @ qs1) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix h U0"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+); deg_pm t \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (qs0 @ qs1) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"(h, U0) \\<in> set ((qs0 @ qs1)\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U0) \\<in> set ((qs0 @ qs1)\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+); deg_pm t \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (qs0 @ qs1) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "hence *: \"(h, U0) \\<in> set (qs0\\<^sub>+) \\<union> set (qs1\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h, U0) \\<in> set ((qs0 @ qs1)\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<union> set (qs1\\<^sub>+)", "by (simp add: pos_decomp_append)"], ["proof (state)\nthis:\n  (h, U0) \\<in> set (qs0\\<^sub>+) \\<union> set (qs1\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+) \\<Longrightarrow>\n       deg_pm t \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+); deg_pm t \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (qs0 @ qs1) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "thus \"deg_pm t \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  (h, U0) \\<in> set (qs0\\<^sub>+) \\<union> set (qs1\\<^sub>+)\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg h", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h\n 2. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h", "assume \"(h, U0) \\<in> set (qs0\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U0) \\<in> set (qs0\\<^sub>+)\n\ngoal (2 subgoals):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h\n 2. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h", "with qs0"], ["proof (chain)\npicking this:\n  standard_decomp (deg_pm t) qs0\n  (h, U0) \\<in> set (qs0\\<^sub>+)", "show ?thesis"], ["proof (prove)\nusing this:\n  standard_decomp (deg_pm t) qs0\n  (h, U0) \\<in> set (qs0\\<^sub>+)\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg h", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h", "assume \"(h, U0) \\<in> set (qs1\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U0) \\<in> set (qs1\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h", "with qs1"], ["proof (chain)\npicking this:\n  standard_decomp (Suc (deg_pm t)) qs1\n  (h, U0) \\<in> set (qs1\\<^sub>+)", "have \"Suc (deg_pm t) \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  standard_decomp (Suc (deg_pm t)) qs1\n  (h, U0) \\<in> set (qs1\\<^sub>+)\n\ngoal (1 subgoal):\n 1. Suc (deg_pm t) \\<le> poly_deg h", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  Suc (deg_pm t) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    deg_pm t \\<le> poly_deg h", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc (deg_pm t) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. deg_pm t \\<le> poly_deg h", "by simp"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pm t \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+); deg_pm t \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (qs0 @ qs1) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+); deg_pm t \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (qs0 @ qs1) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume d1: \"deg_pm t \\<le> d\" and d2: \"d \\<le> poly_deg h\""], ["proof (state)\nthis:\n  deg_pm t \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((qs0 @ qs1)\\<^sub>+); deg_pm t \\<le> d;\n        d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U') \\<in> set (qs0 @ qs1) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from *"], ["proof (chain)\npicking this:\n  (h, U0) \\<in> set (qs0\\<^sub>+) \\<union> set (qs1\\<^sub>+)", "show \"\\<exists>t' U'. (t', U') \\<in> set (qs0 @ qs1) \\<and> poly_deg t' = d \\<and> card U0 \\<le> card U'\""], ["proof (prove)\nusing this:\n  (h, U0) \\<in> set (qs0\\<^sub>+) \\<union> set (qs1\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "assume \"(h, U0) \\<in> set (qs0\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U0) \\<in> set (qs0\\<^sub>+)\n\ngoal (2 subgoals):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "with qs0"], ["proof (chain)\npicking this:\n  standard_decomp (deg_pm t) qs0\n  (h, U0) \\<in> set (qs0\\<^sub>+)", "obtain h' U' where \"(h', U') \\<in> set qs0\" and \"poly_deg h' = d\" and \"card U0 \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp (deg_pm t) qs0\n  (h, U0) \\<in> set (qs0\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set qs0; poly_deg h' = d;\n         card U0 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using d1 d2"], ["proof (prove)\nusing this:\n  standard_decomp (deg_pm t) qs0\n  (h, U0) \\<in> set (qs0\\<^sub>+)\n  deg_pm t \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set qs0; poly_deg h' = d;\n         card U0 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs0\n  poly_deg h' = d\n  card U0 \\<le> card U'\n\ngoal (2 subgoals):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs0\n  poly_deg h' = d\n  card U0 \\<le> card U'\n\ngoal (2 subgoals):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "from this(1)"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set qs0", "have \"(h', U') \\<in> set (qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set qs0\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (qs0 @ qs1)", "by simp"], ["proof (state)\nthis:\n  (h', U') \\<in> set (qs0 @ qs1)\n\ngoal (2 subgoals):\n 1. (h, U0) \\<in> set (qs0\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set qs0\n  poly_deg h' = d\n  card U0 \\<le> card U'\n  (h', U') \\<in> set (qs0 @ qs1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (h', U') \\<in> set qs0\n  poly_deg h' = d\n  card U0 \\<le> card U'\n  (h', U') \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "by blast"], ["proof (state)\nthis:\n  \\<exists>t' U'.\n     (t', U') \\<in> set (qs0 @ qs1) \\<and>\n     poly_deg t' = d \\<and> card U0 \\<le> card U'\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "assume \"(h, U0) \\<in> set (qs1\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U0) \\<in> set (qs1\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "hence \"(h, U0) \\<in> set qs1\""], ["proof (prove)\nusing this:\n  (h, U0) \\<in> set (qs1\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set qs1", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U0) \\<in> set qs1\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "from assms(1) step.hyps(1, 2)"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite S", "have \"monomial_decomp (snd (split t U S) :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list)\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n\ngoal (1 subgoal):\n 1. monomial_decomp (snd (split t U S))", "by (rule monomial_decomp_split)"], ["proof (state)\nthis:\n  monomial_decomp (snd (split t U S))\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "hence md: \"monomial_decomp (qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  monomial_decomp (snd (split t U S))\n\ngoal (1 subgoal):\n 1. monomial_decomp (qs0 @ qs1)", "by (simp add: step.hyps(14))"], ["proof (state)\nthis:\n  monomial_decomp (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  monomial_decomp (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "from \\<open>(h, U0) \\<in> set qs1\\<close>"], ["proof (chain)\npicking this:\n  (h, U0) \\<in> set qs1", "have \"(h, U0) \\<in> set (qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  (h, U0) \\<in> set qs1\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs0 @ qs1)", "by simp"], ["proof (state)\nthis:\n  (h, U0) \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  monomial_decomp (qs0 @ qs1)\n  (h, U0) \\<in> set (qs0 @ qs1)", "have \"is_monomial h\" and \"punit.lc h = 1\""], ["proof (prove)\nusing this:\n  monomial_decomp (qs0 @ qs1)\n  (h, U0) \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. is_monomial h &&& lcf h = (1::'a)", "by (rule monomial_decompD)+"], ["proof (state)\nthis:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "from this(1)"], ["proof (chain)\npicking this:\n  is_monomial h", "have \"monomial (punit.lc h) (lpp h) = h\""], ["proof (prove)\nusing this:\n  is_monomial h\n\ngoal (1 subgoal):\n 1. monomial (lcf h) (lpp h) = h", "by (rule punit.monomial_eq_itself)"], ["proof (state)\nthis:\n  monomial (lcf h) (lpp h) = h\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  monomial (lcf h) (lpp h) = h\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "define s where \"s = lpp h\""], ["proof (state)\nthis:\n  s = lpp h\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  is_monomial h\n  lcf h = (1::'a)\n  monomial (lcf h) (lpp h) = h\n  s = lpp h", "have h: \"h = monomial 1 s\""], ["proof (prove)\nusing this:\n  is_monomial h\n  lcf h = (1::'a)\n  monomial (lcf h) (lpp h) = h\n  s = lpp h\n\ngoal (1 subgoal):\n 1. h = monomial (1::'a) s", "by simp"], ["proof (state)\nthis:\n  h = monomial (1::'a) s\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "from d1"], ["proof (chain)\npicking this:\n  deg_pm t \\<le> d", "have \"deg_pm t = d \\<or> Suc (deg_pm t) \\<le> d\""], ["proof (prove)\nusing this:\n  deg_pm t \\<le> d\n\ngoal (1 subgoal):\n 1. deg_pm t = d \\<or> Suc (deg_pm t) \\<le> d", "by auto"], ["proof (state)\nthis:\n  deg_pm t = d \\<or> Suc (deg_pm t) \\<le> d\n\ngoal (1 subgoal):\n 1. (h, U0) \\<in> set (qs1\\<^sub>+) \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pm t = d \\<or> Suc (deg_pm t) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "assume \"deg_pm t = d\""], ["proof (state)\nthis:\n  deg_pm t = d\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "define F where \"F = (*) (monomial 1 t) ` monomial (1::'a) ` S\""], ["proof (state)\nthis:\n  F = (*) (monomial (1::'a) t) ` monomial (1::'a) ` S\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "have \"F \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> P[X]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> P[X]", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> P[X]", "assume \"f \\<in> F\""], ["proof (state)\nthis:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> P[X]", "then"], ["proof (chain)\npicking this:\n  f \\<in> F", "obtain u where \"u \\<in> S\" and f: \"f = monomial 1 (t + u)\""], ["proof (prove)\nusing this:\n  f \\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> S; f = monomial (1::'a) (t + u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: F_def times_monomial_monomial)"], ["proof (state)\nthis:\n  u \\<in> S\n  f = monomial (1::'a) (t + u)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> P[X]", "from this(1) step.prems(1)"], ["proof (chain)\npicking this:\n  u \\<in> S\n  S \\<subseteq> .[X]", "have \"u \\<in> .[X]\""], ["proof (prove)\nusing this:\n  u \\<in> S\n  S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. u \\<in> .[X]", ".."], ["proof (state)\nthis:\n  u \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> P[X]", "with step.prems(2)"], ["proof (chain)\npicking this:\n  t \\<in> .[X]\n  u \\<in> .[X]", "have \"t + u \\<in> .[X]\""], ["proof (prove)\nusing this:\n  t \\<in> .[X]\n  u \\<in> .[X]\n\ngoal (1 subgoal):\n 1. t + u \\<in> .[X]", "by (rule PPs_closed_plus)"], ["proof (state)\nthis:\n  t + u \\<in> .[X]\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> x \\<in> P[X]", "thus \"f \\<in> P[X]\""], ["proof (prove)\nusing this:\n  t + u \\<in> .[X]\n\ngoal (1 subgoal):\n 1. f \\<in> P[X]", "unfolding f"], ["proof (prove)\nusing this:\n  t + u \\<in> .[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (t + u) \\<in> P[X]", "by (rule Polys_closed_monomial)"], ["proof (state)\nthis:\n  f \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "have \"ideal F = (*) (monomial 1 t) ` ideal (monomial 1 ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F = (*) (monomial (1::'a) t) ` ideal (monomial (1::'a) ` S)", "by (simp only: ideal.span_image_scale_eq_image_scale F_def)"], ["proof (state)\nthis:\n  ideal F = (*) (monomial (1::'a) t) ` ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  ideal F = (*) (monomial (1::'a) t) ` ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "have \"inj ((*) (monomial (1::'a) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*) (monomial (1::'a) t))", "by (auto intro!: injI simp: times_monomial_left monomial_0_iff dest!: punit.monom_mult_inj_3)"], ["proof (state)\nthis:\n  inj ((*) (monomial (1::'a) t))\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  ideal F = (*) (monomial (1::'a) t) ` ideal (monomial (1::'a) ` S)\n  inj ((*) (monomial (1::'a) t))", "have eq: \"ideal F \\<div> monomial 1 t = ideal (monomial 1 ` S)\""], ["proof (prove)\nusing this:\n  ideal F = (*) (monomial (1::'a) t) ` ideal (monomial (1::'a) ` S)\n  inj ((*) (monomial (1::'a) t))\n\ngoal (1 subgoal):\n 1. ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)", "by (simp only: quot_set_image_times)"], ["proof (state)\nthis:\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "with assms(1) step.hyps(1, 2) step.prems(2)"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)", "have \"splits_wrt (split t U S) (cone (monomial (1::'a) t, U)) F\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  t \\<in> .[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. splits_wrt (split t U S) (cone (monomial (1::'a) t, U)) F", "by (rule split_splits_wrt)"], ["proof (state)\nthis:\n  splits_wrt (split t U S) (cone (monomial (1::'a) t, U)) F\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "hence \"splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial 1 t, U)) F\""], ["proof (prove)\nusing this:\n  splits_wrt (split t U S) (cone (monomial (1::'a) t, U)) F\n\ngoal (1 subgoal):\n 1. splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial (1::'a) t, U)) F", "by (simp only: step.hyps(14))"], ["proof (state)\nthis:\n  splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial (1::'a) t, U)) F\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "with assms(1)"], ["proof (chain)\npicking this:\n  finite X\n  splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial (1::'a) t, U)) F", "have \"cone_decomp (cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]) (qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  finite X\n  splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial (1::'a) t, U)) F\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X])\n     (qs0 @ qs1)", "using md _ \\<open>F \\<subseteq> P[X]\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  splits_wrt (ps0 @ ps1, qs0 @ qs1) (cone (monomial (1::'a) t, U)) F\n  monomial_decomp (qs0 @ qs1)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. cone_decomp (cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X])\n     (qs0 @ qs1)", "by (rule splits_wrt_cone_decomp_2)\n              (auto intro!: is_monomial_setI monomial_is_monomial simp: F_def times_monomial_monomial)"], ["proof (state)\nthis:\n  cone_decomp (cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X])\n   (qs0 @ qs1)\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "hence \"cone (monomial 1 s, U0) \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]\""], ["proof (prove)\nusing this:\n  cone_decomp (cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X])\n   (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) s, U0)\n    \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]", "using \\<open>(h, U0) \\<in> set (qs0 @ qs1)\\<close>"], ["proof (prove)\nusing this:\n  cone_decomp (cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X])\n   (qs0 @ qs1)\n  (h, U0) \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) s, U0)\n    \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]", "unfolding h"], ["proof (prove)\nusing this:\n  cone_decomp (cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X])\n   (qs0 @ qs1)\n  (monomial (1::'a) s, U0) \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. cone (monomial (1::'a) s, U0)\n    \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]", "by (rule cone_decomp_cone_subset)"], ["proof (state)\nthis:\n  cone (monomial (1::'a) s, U0)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "with assms(1) step.hyps(1, 2) step.prems(2) \\<open>F \\<subseteq> P[X]\\<close> eq"], ["proof (chain)\npicking this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  t \\<in> .[X]\n  F \\<subseteq> P[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n  cone (monomial (1::'a) s, U0)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]", "obtain U' where \"(monomial (1::'a) t, U') \\<in> set (snd (split t U S))\" and \"card U0 \\<le> card U'\""], ["proof (prove)\nusing this:\n  finite X\n  U \\<subseteq> X\n  finite S\n  t \\<in> .[X]\n  F \\<subseteq> P[X]\n  ideal F \\<div> monomial (1::'a) t = ideal (monomial (1::'a) ` S)\n  cone (monomial (1::'a) s, U0)\n  \\<subseteq> cone (monomial (1::'a) t, U) \\<inter> normal_form F ` P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>U'.\n        \\<lbrakk>(monomial (1::'a) t, U') \\<in> set (snd (split t U S));\n         card U0 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lem_4_6)"], ["proof (state)\nthis:\n  (monomial (1::'a) t, U') \\<in> set (snd (split t U S))\n  card U0 \\<le> card U'\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "from this(1)"], ["proof (chain)\npicking this:\n  (monomial (1::'a) t, U') \\<in> set (snd (split t U S))", "have \"(monomial 1 t, U') \\<in> set (qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  (monomial (1::'a) t, U') \\<in> set (snd (split t U S))\n\ngoal (1 subgoal):\n 1. (monomial (1::'a) t, U') \\<in> set (qs0 @ qs1)", "by (simp add: step.hyps(14))"], ["proof (state)\nthis:\n  (monomial (1::'a) t, U') \\<in> set (qs0 @ qs1)\n\ngoal (2 subgoals):\n 1. deg_pm t = d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'\n 2. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. (?t', ?U'1) \\<in> set (qs0 @ qs1)\n 2. poly_deg ?t' = d\n 3. card U0 \\<le> card ?U'1", "show \"poly_deg (monomial (1::'a) t) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (monomial (1::'a) t) = d", "by (simp add: poly_deg_monomial \\<open>deg_pm t = d\\<close>)"], ["proof (state)\nthis:\n  poly_deg (monomial (1::'a) t) = d\n\ngoal (2 subgoals):\n 1. (monomial (1::'a) t, ?U'1) \\<in> set (qs0 @ qs1)\n 2. card U0 \\<le> card ?U'1", "qed fact+"], ["proof (state)\nthis:\n  \\<exists>t' U'.\n     (t', U') \\<in> set (qs0 @ qs1) \\<and>\n     poly_deg t' = d \\<and> card U0 \\<le> card U'\n\ngoal (1 subgoal):\n 1. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "assume \"Suc (deg_pm t) \\<le> d\""], ["proof (state)\nthis:\n  Suc (deg_pm t) \\<le> d\n\ngoal (1 subgoal):\n 1. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "with qs1 \\<open>(h, U0) \\<in> set (qs1\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  standard_decomp (Suc (deg_pm t)) qs1\n  (h, U0) \\<in> set (qs1\\<^sub>+)\n  Suc (deg_pm t) \\<le> d", "obtain h' U' where \"(h', U') \\<in> set qs1\" and \"poly_deg h' = d\"\n          and \"card U0 \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp (Suc (deg_pm t)) qs1\n  (h, U0) \\<in> set (qs1\\<^sub>+)\n  Suc (deg_pm t) \\<le> d\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set qs1; poly_deg h' = d;\n         card U0 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using d2"], ["proof (prove)\nusing this:\n  standard_decomp (Suc (deg_pm t)) qs1\n  (h, U0) \\<in> set (qs1\\<^sub>+)\n  Suc (deg_pm t) \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set qs1; poly_deg h' = d;\n         card U0 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs1\n  poly_deg h' = d\n  card U0 \\<le> card U'\n\ngoal (1 subgoal):\n 1. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs1\n  poly_deg h' = d\n  card U0 \\<le> card U'\n\ngoal (1 subgoal):\n 1. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "from this(1)"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set qs1", "have \"(h', U') \\<in> set (qs0 @ qs1)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set qs1\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (qs0 @ qs1)", "by simp"], ["proof (state)\nthis:\n  (h', U') \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. Suc (deg_pm t) \\<le> d \\<Longrightarrow>\n    \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set qs1\n  poly_deg h' = d\n  card U0 \\<le> card U'\n  (h', U') \\<in> set (qs0 @ qs1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (h', U') \\<in> set qs1\n  poly_deg h' = d\n  card U0 \\<le> card U'\n  (h', U') \\<in> set (qs0 @ qs1)\n\ngoal (1 subgoal):\n 1. \\<exists>t' U'.\n       (t', U') \\<in> set (qs0 @ qs1) \\<and>\n       poly_deg t' = d \\<and> card U0 \\<le> card U'", "by blast"], ["proof (state)\nthis:\n  \\<exists>t' U'.\n     (t', U') \\<in> set (qs0 @ qs1) \\<and>\n     poly_deg t' = d \\<and> card U0 \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t' U'.\n     (t', U') \\<in> set (qs0 @ qs1) \\<and>\n     poly_deg t' = d \\<and> card U0 \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t' U'.\n     (t', U') \\<in> set (qs0 @ qs1) \\<and>\n     poly_deg t' = d \\<and> card U0 \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  standard_decomp (deg_pm t) (snd (ps0 @ ps1, qs0 @ qs1))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem standard_cone_decomp_snd_split:\n  fixes F\n  defines \"G \\<equiv> punit.reduced_GB F\"\n  defines \"ss \\<equiv> (split 0 X (lpp ` G)) :: ((_ \\<Rightarrow>\\<^sub>0 'a::field) \\<times> _) list \\<times> _\"\n  defines \"d \\<equiv> Suc (Max (poly_deg ` fst ` set (snd ss)))\"\n  assumes \"finite X\" and \"F \\<subseteq> P[X]\"\n  shows \"standard_decomp 0 (snd ss)\" (is ?thesis1)\n    and \"cone_decomp (normal_form F ` P[X]) (snd ss)\" (is ?thesis2)\n    and \"(\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> g \\<in> G \\<Longrightarrow> poly_deg g \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp 0 (snd ss) &&&\n    cone_decomp (normal_form F ` P[X]) (snd ss) &&&\n    (\\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n      g \\<in> G\\<rbrakk>\n     \\<Longrightarrow> poly_deg g \\<le> d)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "have \"ideal G = ideal F\" and \"punit.is_Groebner_basis G\" and \"finite G\" and \"0 \\<notin> G\"\n    and \"G \\<subseteq> P[X]\" and \"punit.is_reduced_GB G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ideal G = ideal F &&& punit.is_Groebner_basis G &&& finite G) &&&\n    0 \\<notin> G &&& G \\<subseteq> P[X] &&& punit.is_reduced_GB G", "using assms(4, 5)"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (ideal G = ideal F &&& punit.is_Groebner_basis G &&& finite G) &&&\n    0 \\<notin> G &&& G \\<subseteq> P[X] &&& punit.is_reduced_GB G", "unfolding G_def"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. (ideal (punit.reduced_GB F) = ideal F &&&\n     punit.is_Groebner_basis (punit.reduced_GB F) &&&\n     finite (punit.reduced_GB F)) &&&\n    0 \\<notin> punit.reduced_GB F &&&\n    punit.reduced_GB F \\<subseteq> P[X] &&&\n    punit.is_reduced_GB (punit.reduced_GB F)", "by (rule reduced_GB_ideal_Polys, rule reduced_GB_is_GB_Polys, rule finite_reduced_GB_Polys,\n        rule reduced_GB_nonzero_Polys, rule reduced_GB_Polys, rule reduced_GB_is_reduced_GB_Polys)"], ["proof (state)\nthis:\n  ideal G = ideal F\n  punit.is_Groebner_basis G\n  finite G\n  0 \\<notin> G\n  G \\<subseteq> P[X]\n  punit.is_reduced_GB G\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "define S where \"S = lpp ` G\""], ["proof (state)\nthis:\n  S = lpp ` G\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "note assms(4) subset_refl"], ["proof (state)\nthis:\n  finite X\n  ?A \\<subseteq> ?A\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "moreover"], ["proof (state)\nthis:\n  finite X\n  ?A \\<subseteq> ?A\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "from \\<open>finite G\\<close>"], ["proof (chain)\npicking this:\n  finite G", "have \"finite S\""], ["proof (prove)\nusing this:\n  finite G\n\ngoal (1 subgoal):\n 1. finite S", "unfolding S_def"], ["proof (prove)\nusing this:\n  finite G\n\ngoal (1 subgoal):\n 1. finite (lpp ` G)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite S\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "moreover"], ["proof (state)\nthis:\n  finite S\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "from \\<open>G \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  G \\<subseteq> P[X]", "have \"S \\<subseteq> .[X]\""], ["proof (prove)\nusing this:\n  G \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. S \\<subseteq> .[X]", "unfolding S_def"], ["proof (prove)\nusing this:\n  G \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. lpp ` G \\<subseteq> .[X]", "by (rule PPs_closed_image_lpp)"], ["proof (state)\nthis:\n  S \\<subseteq> .[X]\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "ultimately"], ["proof (chain)\npicking this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  S \\<subseteq> .[X]", "have \"standard_decomp (deg_pm (0::'x \\<Rightarrow>\\<^sub>0 nat)) (snd ss)\""], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm 0) (snd ss)", "using zero_in_PPs"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  S \\<subseteq> .[X]\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm 0) (snd ss)", "unfolding ss_def S_def"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` G)\n  lpp ` G \\<subseteq> .[X]\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. standard_decomp (deg_pm 0) (snd (split 0 X (lpp ` G)))", "by (rule standard_decomp_snd_split)"], ["proof (state)\nthis:\n  standard_decomp (deg_pm 0) (snd ss)\n\ngoal (3 subgoals):\n 1. standard_decomp 0 (snd ss)\n 2. cone_decomp (normal_form F ` P[X]) (snd ss)\n 3. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "thus ?thesis1"], ["proof (prove)\nusing this:\n  standard_decomp (deg_pm 0) (snd ss)\n\ngoal (1 subgoal):\n 1. standard_decomp 0 (snd ss)", "by simp"], ["proof (state)\nthis:\n  standard_decomp 0 (snd ss)\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "let ?S = \"monomial (1::'a) ` S\""], ["proof (state)\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "from \\<open>S \\<subseteq> .[X]\\<close>"], ["proof (chain)\npicking this:\n  S \\<subseteq> .[X]", "have \"?S \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  S \\<subseteq> .[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) ` S \\<subseteq> P[X]", "by (auto intro: Polys_closed_monomial)"], ["proof (state)\nthis:\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "have \"splits_wrt ss (cone (monomial 1 0, X)) ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splits_wrt ss (cone (monomial (1::'a) 0, X)) (monomial (1::'a) ` S)", "using assms(4) subset_refl \\<open>finite S\\<close> zero_in_PPs"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. splits_wrt ss (cone (monomial (1::'a) 0, X)) (monomial (1::'a) ` S)", "unfolding ss_def S_def"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` G)\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. splits_wrt (split 0 X (lpp ` G)) (cone (monomial (1::'a) 0, X))\n     (monomial (1::'a) ` lpp ` G)", "by (rule split_splits_wrt) simp"], ["proof (state)\nthis:\n  splits_wrt ss (cone (monomial (1::'a) 0, X)) (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "hence \"splits_wrt (fst ss, snd ss) P[X] ?S\""], ["proof (prove)\nusing this:\n  splits_wrt ss (cone (monomial (1::'a) 0, X)) (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. splits_wrt (fst ss, snd ss) P[X] (monomial (1::'a) ` S)", "by simp"], ["proof (state)\nthis:\n  splits_wrt (fst ss, snd ss) P[X] (monomial (1::'a) ` S)\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "with assms(4)"], ["proof (chain)\npicking this:\n  finite X\n  splits_wrt (fst ss, snd ss) P[X] (monomial (1::'a) ` S)", "have \"cone_decomp (P[X] \\<inter> normal_form ?S ` P[X]) (snd ss)\""], ["proof (prove)\nusing this:\n  finite X\n  splits_wrt (fst ss, snd ss) P[X] (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. cone_decomp (P[X] \\<inter> normal_form (monomial (1::'a) ` S) ` P[X])\n     (snd ss)", "using _ _ \\<open>?S \\<subseteq> P[X]\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  splits_wrt (fst ss, snd ss) P[X] (monomial (1::'a) ` S)\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  monomial (1::'a) ` S \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. cone_decomp (P[X] \\<inter> normal_form (monomial (1::'a) ` S) ` P[X])\n     (snd ss)", "proof (rule splits_wrt_cone_decomp_2)"], ["proof (state)\ngoal (2 subgoals):\n 1. monomial_decomp (snd ss)\n 2. is_monomial_set (monomial (1::'a) ` S)", "from assms(4) subset_refl \\<open>finite S\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S", "show \"monomial_decomp (snd ss)\""], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite S\n\ngoal (1 subgoal):\n 1. monomial_decomp (snd ss)", "unfolding ss_def S_def"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` G)\n\ngoal (1 subgoal):\n 1. monomial_decomp (snd (split 0 X (lpp ` G)))", "by (rule monomial_decomp_split)"], ["proof (state)\nthis:\n  monomial_decomp (snd ss)\n\ngoal (1 subgoal):\n 1. is_monomial_set (monomial (1::'a) ` S)", "qed (auto intro!: is_monomial_setI monomial_is_monomial)"], ["proof (state)\nthis:\n  cone_decomp (P[X] \\<inter> normal_form (monomial (1::'a) ` S) ` P[X])\n   (snd ss)\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "moreover"], ["proof (state)\nthis:\n  cone_decomp (P[X] \\<inter> normal_form (monomial (1::'a) ` S) ` P[X])\n   (snd ss)\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "have \"normal_form ?S ` P[X] = normal_form F ` P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form (monomial (1::'a) ` S) ` P[X] = normal_form F ` P[X]", "by (rule set_eqI)\n        (simp add: image_normal_form_iff[OF assms(4)] assms(5) \\<open>?S \\<subseteq> P[X]\\<close>,\n         simp add: S_def is_red_reduced_GB_monomial_lt_GB_Polys[OF assms(4)] \\<open>G \\<subseteq> P[X]\\<close> \\<open>0 \\<notin> G\\<close> flip: G_def)"], ["proof (state)\nthis:\n  normal_form (monomial (1::'a) ` S) ` P[X] = normal_form F ` P[X]\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "moreover"], ["proof (state)\nthis:\n  normal_form (monomial (1::'a) ` S) ` P[X] = normal_form F ` P[X]\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "from assms(4, 5)"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"normal_form F ` P[X] \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. normal_form F ` P[X] \\<subseteq> P[X]", "by (auto intro: Polys_closed_normal_form)"], ["proof (state)\nthis:\n  normal_form F ` P[X] \\<subseteq> P[X]\n\ngoal (2 subgoals):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)\n 2. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "ultimately"], ["proof (chain)\npicking this:\n  cone_decomp (P[X] \\<inter> normal_form (monomial (1::'a) ` S) ` P[X])\n   (snd ss)\n  normal_form (monomial (1::'a) ` S) ` P[X] = normal_form F ` P[X]\n  normal_form F ` P[X] \\<subseteq> P[X]", "show ?thesis2"], ["proof (prove)\nusing this:\n  cone_decomp (P[X] \\<inter> normal_form (monomial (1::'a) ` S) ` P[X])\n   (snd ss)\n  normal_form (monomial (1::'a) ` S) ` P[X] = normal_form F ` P[X]\n  normal_form F ` P[X] \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. cone_decomp (normal_form F ` P[X]) (snd ss)", "by (simp only: Int_absorb1)"], ["proof (state)\nthis:\n  cone_decomp (normal_form F ` P[X]) (snd ss)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "assume \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\""], ["proof (state)\nthis:\n  ?f19 \\<in> F \\<Longrightarrow> homogeneous ?f19\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "moreover"], ["proof (state)\nthis:\n  ?f19 \\<in> F \\<Longrightarrow> homogeneous ?f19\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "note \\<open>punit.is_reduced_GB G\\<close> \\<open>ideal G = ideal F\\<close>"], ["proof (state)\nthis:\n  punit.is_reduced_GB G\n  ideal G = ideal F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "moreover"], ["proof (state)\nthis:\n  punit.is_reduced_GB G\n  ideal G = ideal F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "assume \"g \\<in> G\""], ["proof (state)\nthis:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "ultimately"], ["proof (chain)\npicking this:\n  ?f19 \\<in> F \\<Longrightarrow> homogeneous ?f19\n  punit.is_reduced_GB G\n  ideal G = ideal F\n  g \\<in> G", "have \"homogeneous g\""], ["proof (prove)\nusing this:\n  ?f19 \\<in> F \\<Longrightarrow> homogeneous ?f19\n  punit.is_reduced_GB G\n  ideal G = ideal F\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. homogeneous g", "by (rule is_reduced_GB_homogeneous)"], ["proof (state)\nthis:\n  homogeneous g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "moreover"], ["proof (state)\nthis:\n  homogeneous g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "have \"lpp g \\<in> keys g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lpp g \\<in> keys g", "proof (rule punit.lt_in_keys)"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "from \\<open>g \\<in> G\\<close> \\<open>0 \\<notin> G\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> G\n  0 \\<notin> G", "show \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<in> G\n  0 \\<notin> G\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lpp g \\<in> keys g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "ultimately"], ["proof (chain)\npicking this:\n  homogeneous g\n  lpp g \\<in> keys g", "have deg_lt: \"deg_pm (lpp g) = poly_deg g\""], ["proof (prove)\nusing this:\n  homogeneous g\n  lpp g \\<in> keys g\n\ngoal (1 subgoal):\n 1. deg_pm (lpp g) = poly_deg g", "by (rule homogeneousD_poly_deg)"], ["proof (state)\nthis:\n  deg_pm (lpp g) = poly_deg g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "from \\<open>g \\<in> G\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> G", "have \"monomial 1 (lpp g) \\<in> ?S\""], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (lpp g) \\<in> monomial (1::'a) ` S", "unfolding S_def"], ["proof (prove)\nusing this:\n  g \\<in> G\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (lpp g) \\<in> monomial (1::'a) ` lpp ` G", "by (intro imageI)"], ["proof (state)\nthis:\n  monomial (1::'a) (lpp g) \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "also"], ["proof (state)\nthis:\n  monomial (1::'a) (lpp g) \\<in> monomial (1::'a) ` S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "have \"\\<dots> = punit.reduced_GB ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) ` S = punit.reduced_GB (monomial (1::'a) ` S)", "unfolding S_def G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'a) ` lpp ` punit.reduced_GB F =\n    punit.reduced_GB (monomial (1::'a) ` lpp ` punit.reduced_GB F)", "using assms(4, 5)"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. monomial (1::'a) ` lpp ` punit.reduced_GB F =\n    punit.reduced_GB (monomial (1::'a) ` lpp ` punit.reduced_GB F)", "by (rule reduced_GB_monomial_lt_reduced_GB_Polys[symmetric])"], ["proof (state)\nthis:\n  monomial (1::'a) ` S = punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "finally"], ["proof (chain)\npicking this:\n  monomial (1::'a) (lpp g) \\<in> punit.reduced_GB (monomial (1::'a) ` S)", "have \"monomial 1 (lpp g) \\<in> punit.reduced_GB ?S\""], ["proof (prove)\nusing this:\n  monomial (1::'a) (lpp g) \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. monomial (1::'a) (lpp g) \\<in> punit.reduced_GB (monomial (1::'a) ` S)", "."], ["proof (state)\nthis:\n  monomial (1::'a) (lpp g) \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "with assms(4) \\<open>finite S\\<close> \\<open>S \\<subseteq> .[X]\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  finite S\n  S \\<subseteq> .[X]\n  monomial (1::'a) (lpp g) \\<in> punit.reduced_GB (monomial (1::'a) ` S)", "have \"poly_deg (monomial (1::'a) (lpp g)) \\<le> d\""], ["proof (prove)\nusing this:\n  finite X\n  finite S\n  S \\<subseteq> .[X]\n  monomial (1::'a) (lpp g) \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. poly_deg (monomial (1::'a) (lpp g)) \\<le> d", "unfolding d_def ss_def S_def[symmetric]"], ["proof (prove)\nusing this:\n  finite X\n  finite S\n  S \\<subseteq> .[X]\n  monomial (1::'a) (lpp g) \\<in> punit.reduced_GB (monomial (1::'a) ` S)\n\ngoal (1 subgoal):\n 1. poly_deg (monomial (1::'a) (lpp g))\n    \\<le> Suc (Max (poly_deg ` fst ` set (snd (split 0 X S))))", "by (rule cor_4_9)"], ["proof (state)\nthis:\n  poly_deg (monomial (1::'a) (lpp g)) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n     g \\<in> G\\<rbrakk>\n    \\<Longrightarrow> poly_deg g \\<le> d", "thus \"poly_deg g \\<le> d\""], ["proof (prove)\nusing this:\n  poly_deg (monomial (1::'a) (lpp g)) \\<le> d\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> d", "by (simp add: poly_deg_monomial deg_lt)"], ["proof (state)\nthis:\n  poly_deg g \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Splitting Ideals\\<close>"], ["", "qualified"], ["", "definition ideal_decomp_aux :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) set \\<Rightarrow> (('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow>\n                                          ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::field) set \\<times> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list)\"\n  where \"ideal_decomp_aux F f =\n              (let J = ideal F; L = (J \\<div> f) \\<inter> P[X]; L' = lpp ` punit.reduced_GB L in\n                 ((*) f ` normal_form L ` P[X], map (apfst ((*) f)) (snd (split 0 X L'))))\""], ["", "context\n  assumes fin_X: \"finite X\"\nbegin"], ["", "lemma ideal_decomp_aux:\n  assumes \"finite F\" and \"F \\<subseteq> P[X]\" and \"f \\<in> P[X]\"\n  shows \"fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\" (is ?thesis1)\n    and \"ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\" (is ?thesis2)\n    and \"direct_decomp (ideal (insert f F) \\<inter> P[X]) [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\" (is ?thesis3)\n    and \"cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\" (is ?thesis4)\n    and \"f \\<noteq> 0 \\<Longrightarrow> valid_decomp X (snd (ideal_decomp_aux F f))\" (is \"_ \\<Longrightarrow> ?thesis5\")\n    and \"f \\<noteq> 0 \\<Longrightarrow> standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\" (is \"_ \\<Longrightarrow> ?thesis6\")\n    and \"homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))\" (is \"_ \\<Longrightarrow> ?thesis7\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (ideal_decomp_aux F f) \\<subseteq> ideal {f} &&&\n     ideal F \\<inter> fst (ideal_decomp_aux F f) = {0} &&&\n     direct_decomp (ideal (insert f F) \\<inter> P[X])\n      [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]) &&&\n    (cone_decomp (fst (ideal_decomp_aux F f))\n      (snd (ideal_decomp_aux F f)) &&&\n     (f \\<noteq> 0 \\<Longrightarrow>\n      valid_decomp X (snd (ideal_decomp_aux F f)))) &&&\n    (f \\<noteq> 0 \\<Longrightarrow>\n     standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))) &&&\n    (homogeneous f \\<Longrightarrow>\n     hom_decomp (snd (ideal_decomp_aux F f)))", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n 2. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 3. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 4. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 7. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "define J where \"J = ideal F\""], ["proof (state)\nthis:\n  J = ideal F\n\ngoal (7 subgoals):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n 2. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 3. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 4. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 7. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "define L where \"L = (J \\<div> f) \\<inter> P[X]\""], ["proof (state)\nthis:\n  L = (J \\<div> f) \\<inter> P[X]\n\ngoal (7 subgoals):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n 2. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 3. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 4. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 7. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "define S where \"S = (*) f ` normal_form L ` P[X]\""], ["proof (state)\nthis:\n  S = (*) f ` normal_form L ` P[X]\n\ngoal (7 subgoals):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n 2. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 3. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 4. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 7. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "define L' where \"L' = lpp ` punit.reduced_GB L\""], ["proof (state)\nthis:\n  L' = lpp ` punit.reduced_GB L\n\ngoal (7 subgoals):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n 2. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 3. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 4. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 7. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "have eq: \"ideal_decomp_aux F f = (S, map (apfst ((*) f)) (snd (split 0 X L')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_decomp_aux F f = (S, map (apfst ((*) f)) (snd (split 0 X L')))", "by (simp add: J_def ideal_decomp_aux_def Let_def L_def L'_def S_def)"], ["proof (state)\nthis:\n  ideal_decomp_aux F f = (S, map (apfst ((*) f)) (snd (split 0 X L')))\n\ngoal (7 subgoals):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n 2. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 3. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 4. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 7. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "have L_sub: \"L \\<subseteq> P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<subseteq> P[X]", "by (simp add: L_def)"], ["proof (state)\nthis:\n  L \\<subseteq> P[X]\n\ngoal (7 subgoals):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n 2. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 3. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 4. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 7. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}", "unfolding eq fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> ideal {f}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> ideal {f}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> ideal {f}", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> ideal {f}", "then"], ["proof (chain)\npicking this:\n  s \\<in> S", "obtain q where \"s = normal_form L q * f\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        s = normal_form L q * f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding S_def"], ["proof (prove)\nusing this:\n  s \\<in> (*) f ` normal_form L ` P[X]\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        s = normal_form L q * f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim imageE) auto"], ["proof (state)\nthis:\n  s = normal_form L q * f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> ideal {f}", "also"], ["proof (state)\nthis:\n  s = normal_form L q * f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> ideal {f}", "have \"\\<dots> \\<in> ideal {f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_form L q * f \\<in> ideal {f}", "by (intro ideal.span_scale ideal.span_base singletonI)"], ["proof (state)\nthis:\n  normal_form L q * f \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> ideal {f}", "finally"], ["proof (chain)\npicking this:\n  s \\<in> ideal {f}", "show \"s \\<in> ideal {f}\""], ["proof (prove)\nusing this:\n  s \\<in> ideal {f}\n\ngoal (1 subgoal):\n 1. s \\<in> ideal {f}", "."], ["proof (state)\nthis:\n  s \\<in> ideal {f}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (ideal_decomp_aux F f) \\<subseteq> ideal {f}\n\ngoal (6 subgoals):\n 1. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n 2. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 3. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 4. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 6. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)) = (x \\<in> {0})", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)) = (x \\<in> {0})", "show \"h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<longleftrightarrow> h \\<in> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)) = (h \\<in> {0})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "assume \"h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)\""], ["proof (state)\nthis:\n  h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "hence \"h \\<in> J\" and \"h \\<in> S\""], ["proof (prove)\nusing this:\n  h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)\n\ngoal (1 subgoal):\n 1. h \\<in> J &&& h \\<in> S", "by (simp_all add: J_def S_def eq)"], ["proof (state)\nthis:\n  h \\<in> J\n  h \\<in> S\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "from this(2)"], ["proof (chain)\npicking this:\n  h \\<in> S", "obtain q where \"q \\<in> P[X]\" and h: \"h = f * normal_form L q\""], ["proof (prove)\nusing this:\n  h \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P[X]; h = f * normal_form L q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: S_def)"], ["proof (state)\nthis:\n  q \\<in> P[X]\n  h = f * normal_form L q\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "from fin_X L_sub this(1)"], ["proof (chain)\npicking this:\n  finite X\n  L \\<subseteq> P[X]\n  q \\<in> P[X]", "have \"normal_form L q \\<in> P[X]\""], ["proof (prove)\nusing this:\n  finite X\n  L \\<subseteq> P[X]\n  q \\<in> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L q \\<in> P[X]", "by (rule Polys_closed_normal_form)"], ["proof (state)\nthis:\n  normal_form L q \\<in> P[X]\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "moreover"], ["proof (state)\nthis:\n  normal_form L q \\<in> P[X]\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "from \\<open>h \\<in> J\\<close>"], ["proof (chain)\npicking this:\n  h \\<in> J", "have \"f * normal_form L q \\<in> J\""], ["proof (prove)\nusing this:\n  h \\<in> J\n\ngoal (1 subgoal):\n 1. f * normal_form L q \\<in> J", "by (simp add: h)"], ["proof (state)\nthis:\n  f * normal_form L q \\<in> J\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "ultimately"], ["proof (chain)\npicking this:\n  normal_form L q \\<in> P[X]\n  f * normal_form L q \\<in> J", "have \"normal_form L q \\<in> L\""], ["proof (prove)\nusing this:\n  normal_form L q \\<in> P[X]\n  f * normal_form L q \\<in> J\n\ngoal (1 subgoal):\n 1. normal_form L q \\<in> L", "by (simp add: L_def quot_set_iff)"], ["proof (state)\nthis:\n  normal_form L q \\<in> L\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "hence \"normal_form L q \\<in> ideal L\""], ["proof (prove)\nusing this:\n  normal_form L q \\<in> L\n\ngoal (1 subgoal):\n 1. normal_form L q \\<in> ideal L", "by (rule ideal.span_base)"], ["proof (state)\nthis:\n  normal_form L q \\<in> ideal L\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "with normal_form_diff_in_ideal[OF fin_X L_sub]"], ["proof (chain)\npicking this:\n  ?p - normal_form L ?p \\<in> ideal L\n  normal_form L q \\<in> ideal L", "have \"(q - normal_form L q) + normal_form L q \\<in> ideal L\""], ["proof (prove)\nusing this:\n  ?p - normal_form L ?p \\<in> ideal L\n  normal_form L q \\<in> ideal L\n\ngoal (1 subgoal):\n 1. q - normal_form L q + normal_form L q \\<in> ideal L", "by (rule ideal.span_add)"], ["proof (state)\nthis:\n  q - normal_form L q + normal_form L q \\<in> ideal L\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "hence \"normal_form L q = 0\""], ["proof (prove)\nusing this:\n  q - normal_form L q + normal_form L q \\<in> ideal L\n\ngoal (1 subgoal):\n 1. normal_form L q = 0", "using fin_X L_sub"], ["proof (prove)\nusing this:\n  q - normal_form L q + normal_form L q \\<in> ideal L\n  finite X\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. normal_form L q = 0", "by (simp add: normal_form_zero_iff)"], ["proof (state)\nthis:\n  normal_form L q = 0\n\ngoal (2 subgoals):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f) \\<Longrightarrow>\n    h \\<in> {0}\n 2. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "thus \"h \\<in> {0}\""], ["proof (prove)\nusing this:\n  normal_form L q = 0\n\ngoal (1 subgoal):\n 1. h \\<in> {0}", "by (simp add: h)"], ["proof (state)\nthis:\n  h \\<in> {0}\n\ngoal (1 subgoal):\n 1. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "assume \"h \\<in> {0}\""], ["proof (state)\nthis:\n  h \\<in> {0}\n\ngoal (1 subgoal):\n 1. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "moreover"], ["proof (state)\nthis:\n  h \\<in> {0}\n\ngoal (1 subgoal):\n 1. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "have \"0 \\<in> (*) f ` normal_form L ` P[X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> (*) f ` normal_form L ` P[X]", "proof (intro image_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 = f * ?x\n 2. ?x = normal_form L ?x1\n 3. ?x1 \\<in> P[X]", "from fin_X L_sub"], ["proof (chain)\npicking this:\n  finite X\n  L \\<subseteq> P[X]", "show \"0 = normal_form L 0\""], ["proof (prove)\nusing this:\n  finite X\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. 0 = normal_form L 0", "by (simp only: normal_form_zero)"], ["proof (state)\nthis:\n  0 = normal_form L 0\n\ngoal (2 subgoals):\n 1. 0 = f * 0\n 2. 0 \\<in> P[X]", "qed (simp_all add: zero_in_Polys)"], ["proof (state)\nthis:\n  0 \\<in> (*) f ` normal_form L ` P[X]\n\ngoal (1 subgoal):\n 1. h \\<in> {0} \\<Longrightarrow>\n    h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "ultimately"], ["proof (chain)\npicking this:\n  h \\<in> {0}\n  0 \\<in> (*) f ` normal_form L ` P[X]", "show \"h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)\""], ["proof (prove)\nusing this:\n  h \\<in> {0}\n  0 \\<in> (*) f ` normal_form L ` P[X]\n\ngoal (1 subgoal):\n 1. h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)", "by (simp add: ideal.span_zero eq S_def)"], ["proof (state)\nthis:\n  h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (h \\<in> ideal F \\<inter> fst (ideal_decomp_aux F f)) = (h \\<in> {0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal F \\<inter> fst (ideal_decomp_aux F f) = {0}\n\ngoal (5 subgoals):\n 1. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 2. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 4. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 5. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "have \"direct_decomp (ideal (insert f F) \\<inter> P[X]) [ideal F \\<inter> P[X], fst (ideal_decomp_aux F f)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [ideal F \\<inter> P[X], fst (ideal_decomp_aux F f)]", "unfolding eq fst_conv S_def L_def J_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [ideal F \\<inter> P[X],\n      (*) f ` normal_form ((ideal F \\<div> f) \\<inter> P[X]) ` P[X]]", "using fin_X assms(2, 3)"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [ideal F \\<inter> P[X],\n      (*) f ` normal_form ((ideal F \\<div> f) \\<inter> P[X]) ` P[X]]", "by (rule direct_decomp_ideal_insert)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f F) \\<inter> P[X])\n   [ideal F \\<inter> P[X], fst (ideal_decomp_aux F f)]\n\ngoal (5 subgoals):\n 1. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n 2. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 4. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 5. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "thus ?thesis3"], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f F) \\<inter> P[X])\n   [ideal F \\<inter> P[X], fst (ideal_decomp_aux F f)]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]", "using perm.swap"], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f F) \\<inter> P[X])\n   [ideal F \\<inter> P[X], fst (ideal_decomp_aux F f)]\n  ?y # ?x # ?l <~~> ?x # ?y # ?l\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f F) \\<inter> P[X])\n     [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]", "by (rule direct_decomp_perm)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f F) \\<inter> P[X])\n   [fst (ideal_decomp_aux F f), ideal F \\<inter> P[X]]\n\ngoal (4 subgoals):\n 1. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 4. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "have std: \"standard_decomp 0 (snd (split 0 X L') :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list)\"\n    and \"cone_decomp (normal_form L ` P[X]) (snd (split 0 X L'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp 0 (snd (split 0 X L')) &&&\n    cone_decomp (normal_form L ` P[X]) (snd (split 0 X L'))", "unfolding L'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp 0 (snd (split 0 X (lpp ` punit.reduced_GB L))) &&&\n    cone_decomp (normal_form L ` P[X])\n     (snd (split 0 X (lpp ` punit.reduced_GB L)))", "using fin_X \\<open>L \\<subseteq> P[X]\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. standard_decomp 0 (snd (split 0 X (lpp ` punit.reduced_GB L))) &&&\n    cone_decomp (normal_form L ` P[X])\n     (snd (split 0 X (lpp ` punit.reduced_GB L)))", "by (rule standard_cone_decomp_snd_split)+"], ["proof (state)\nthis:\n  standard_decomp 0 (snd (split 0 X L'))\n  cone_decomp (normal_form L ` P[X]) (snd (split 0 X L'))\n\ngoal (4 subgoals):\n 1. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 4. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "from this(2)"], ["proof (chain)\npicking this:\n  cone_decomp (normal_form L ` P[X]) (snd (split 0 X L'))", "show ?thesis4"], ["proof (prove)\nusing this:\n  cone_decomp (normal_form L ` P[X]) (snd (split 0 X L'))\n\ngoal (1 subgoal):\n 1. cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))", "unfolding eq fst_conv snd_conv S_def"], ["proof (prove)\nusing this:\n  cone_decomp (normal_form L ` P[X]) (snd (split 0 X L'))\n\ngoal (1 subgoal):\n 1. cone_decomp ((*) f ` normal_form L ` P[X])\n     (map (apfst ((*) f)) (snd (split 0 X L')))", "by (rule cone_decomp_map_times)"], ["proof (state)\nthis:\n  cone_decomp (fst (ideal_decomp_aux F f)) (snd (ideal_decomp_aux F f))\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "from fin_X \\<open>L \\<subseteq> P[X]\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  L \\<subseteq> P[X]", "have \"finite (punit.reduced_GB L)\""], ["proof (prove)\nusing this:\n  finite X\n  L \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. finite (punit.reduced_GB L)", "by (rule finite_reduced_GB_Polys)"], ["proof (state)\nthis:\n  finite (punit.reduced_GB L)\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "hence \"finite L'\""], ["proof (prove)\nusing this:\n  finite (punit.reduced_GB L)\n\ngoal (1 subgoal):\n 1. finite L'", "unfolding L'_def"], ["proof (prove)\nusing this:\n  finite (punit.reduced_GB L)\n\ngoal (1 subgoal):\n 1. finite (lpp ` punit.reduced_GB L)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite L'\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "{"], ["proof (state)\nthis:\n  finite L'\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "have \"monomial_decomp (snd (split 0 X L') :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (snd (split 0 X L'))", "using fin_X subset_refl \\<open>finite L'\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite L'\n\ngoal (1 subgoal):\n 1. monomial_decomp (snd (split 0 X L'))", "by (rule monomial_decomp_split)"], ["proof (state)\nthis:\n  monomial_decomp (snd (split 0 X L'))\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "hence \"hom_decomp (snd (split 0 X L') :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list)\""], ["proof (prove)\nusing this:\n  monomial_decomp (snd (split 0 X L'))\n\ngoal (1 subgoal):\n 1. hom_decomp (snd (split 0 X L'))", "by (rule monomial_decomp_imp_hom_decomp)"], ["proof (state)\nthis:\n  hom_decomp (snd (split 0 X L'))\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "moreover"], ["proof (state)\nthis:\n  hom_decomp (snd (split 0 X L'))\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "assume \"homogeneous f\""], ["proof (state)\nthis:\n  homogeneous f\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n 3. homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))", "ultimately"], ["proof (chain)\npicking this:\n  hom_decomp (snd (split 0 X L'))\n  homogeneous f", "show ?thesis7"], ["proof (prove)\nusing this:\n  hom_decomp (snd (split 0 X L'))\n  homogeneous f\n\ngoal (1 subgoal):\n 1. hom_decomp (snd (ideal_decomp_aux F f))", "unfolding eq snd_conv"], ["proof (prove)\nusing this:\n  hom_decomp (snd (split 0 X L'))\n  homogeneous f\n\ngoal (1 subgoal):\n 1. hom_decomp (map (apfst ((*) f)) (snd (split 0 X L')))", "by (rule hom_decomp_map_times)"], ["proof (state)\nthis:\n  hom_decomp (snd (ideal_decomp_aux F f))\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "}"], ["proof (state)\nthis:\n  homogeneous f \\<Longrightarrow> hom_decomp (snd (ideal_decomp_aux F f))\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "have vd: \"valid_decomp X (snd (split 0 X L') :: ((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (snd (split 0 X L'))", "using fin_X subset_refl \\<open>finite L'\\<close> zero_in_PPs"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite L'\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (snd (split 0 X L'))", "by (rule valid_decomp_split)"], ["proof (state)\nthis:\n  valid_decomp X (snd (split 0 X L'))\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "moreover"], ["proof (state)\nthis:\n  valid_decomp X (snd (split 0 X L'))\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "note assms(3)"], ["proof (state)\nthis:\n  f \\<in> P[X]\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "moreover"], ["proof (state)\nthis:\n  f \\<in> P[X]\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "assume \"f \\<noteq> 0\""], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    valid_decomp X (snd (ideal_decomp_aux F f))\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "ultimately"], ["proof (chain)\npicking this:\n  valid_decomp X (snd (split 0 X L'))\n  f \\<in> P[X]\n  f \\<noteq> 0", "show ?thesis5"], ["proof (prove)\nusing this:\n  valid_decomp X (snd (split 0 X L'))\n  f \\<in> P[X]\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. valid_decomp X (snd (ideal_decomp_aux F f))", "unfolding eq snd_conv"], ["proof (prove)\nusing this:\n  valid_decomp X (snd (split 0 X L'))\n  f \\<in> P[X]\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. valid_decomp X (map (apfst ((*) f)) (snd (split 0 X L')))", "by (rule valid_decomp_map_times)"], ["proof (state)\nthis:\n  valid_decomp X (snd (ideal_decomp_aux F f))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "from std vd \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  standard_decomp 0 (snd (split 0 X L'))\n  valid_decomp X (snd (split 0 X L'))\n  f \\<noteq> 0", "have \"standard_decomp (0 + poly_deg f) (map (apfst ((*) f)) (snd (split 0 X L')))\""], ["proof (prove)\nusing this:\n  standard_decomp 0 (snd (split 0 X L'))\n  valid_decomp X (snd (split 0 X L'))\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. standard_decomp (0 + poly_deg f)\n     (map (apfst ((*) f)) (snd (split 0 X L')))", "by (rule standard_decomp_map_times)"], ["proof (state)\nthis:\n  standard_decomp (0 + poly_deg f)\n   (map (apfst ((*) f)) (snd (split 0 X L')))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "thus ?thesis6"], ["proof (prove)\nusing this:\n  standard_decomp (0 + poly_deg f)\n   (map (apfst ((*) f)) (snd (split 0 X L')))\n\ngoal (1 subgoal):\n 1. standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))", "by (simp add: eq)"], ["proof (state)\nthis:\n  standard_decomp (poly_deg f) (snd (ideal_decomp_aux F f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_decompE:\n  fixes f0 :: \"_ \\<Rightarrow>\\<^sub>0 'a::field\"\n  assumes \"finite F\" and \"F \\<subseteq> P[X]\" and \"f0 \\<in> P[X]\" and \"\\<And>f. f \\<in> F \\<Longrightarrow> poly_deg f \\<le> poly_deg f0\"\n  obtains T ps where \"valid_decomp X ps\" and \"standard_decomp (poly_deg f0) ps\" and \"cone_decomp T ps\"\n    and \"(\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> hom_decomp ps\"\n    and \"direct_decomp (ideal (insert f0 F) \\<inter> P[X]) [ideal {f0} \\<inter> P[X], T]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps T.\n        \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n         cone_decomp T ps;\n         (\\<And>f.\n             f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n         hom_decomp ps;\n         direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n          [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1, 2, 4)"], ["proof (prove)\nusing this:\n  finite F\n  F \\<subseteq> P[X]\n  ?f20 \\<in> F \\<Longrightarrow> poly_deg ?f20 \\<le> poly_deg f0\n\ngoal (1 subgoal):\n 1. (\\<And>ps T.\n        \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n         cone_decomp T ps;\n         (\\<And>f.\n             f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n         hom_decomp ps;\n         direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n          [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct F arbitrary: thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>ps T.\n                   \\<lbrakk>valid_decomp X ps;\n                    standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                    (\\<And>f.\n                        f \\<in> {} \\<Longrightarrow>\n                        homogeneous f) \\<Longrightarrow>\n                    hom_decomp ps;\n                    direct_decomp (ideal {f0} \\<inter> P[X])\n                     [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        {} \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> {} \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "case empty"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ?ps20; standard_decomp (poly_deg f0) ?ps20;\n   cone_decomp ?T20 ?ps20;\n   (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n   hom_decomp ?ps20;\n   direct_decomp (ideal {f0} \\<inter> P[X])\n    [ideal {f0} \\<inter> P[X], ?T20]\\<rbrakk>\n  \\<Longrightarrow> thesis\n  {} \\<subseteq> P[X]\n  ?f20 \\<in> {} \\<Longrightarrow> poly_deg ?f20 \\<le> poly_deg f0\n\ngoal (2 subgoals):\n 1. \\<And>thesis.\n       \\<lbrakk>\\<And>ps T.\n                   \\<lbrakk>valid_decomp X ps;\n                    standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                    (\\<And>f.\n                        f \\<in> {} \\<Longrightarrow>\n                        homogeneous f) \\<Longrightarrow>\n                    hom_decomp ps;\n                    direct_decomp (ideal {f0} \\<inter> P[X])\n                     [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        {} \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> {} \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule empty.prems)"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_decomp X ?ps20\n 2. standard_decomp (poly_deg f0) ?ps20\n 3. cone_decomp ?T20 ?ps20\n 4. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp ?ps20\n 5. direct_decomp (ideal {f0} \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "show \"valid_decomp X []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X []", "by (rule valid_decompI) simp_all"], ["proof (state)\nthis:\n  valid_decomp X []\n\ngoal (4 subgoals):\n 1. standard_decomp (poly_deg f0) []\n 2. cone_decomp ?T20 []\n 3. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 4. direct_decomp (ideal {f0} \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. standard_decomp (poly_deg f0) []\n 2. cone_decomp ?T20 []\n 3. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 4. direct_decomp (ideal {f0} \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "show \"standard_decomp (poly_deg f0) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp (poly_deg f0) []", "by (rule standard_decompI) simp_all"], ["proof (state)\nthis:\n  standard_decomp (poly_deg f0) []\n\ngoal (3 subgoals):\n 1. cone_decomp ?T20 []\n 2. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 3. direct_decomp (ideal {f0} \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. cone_decomp ?T20 []\n 2. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 3. direct_decomp (ideal {f0} \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "show \"cone_decomp {0} []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp {0} []", "by (rule cone_decompI) (simp add: direct_decomp_def bij_betw_def)"], ["proof (state)\nthis:\n  cone_decomp {0} []\n\ngoal (2 subgoals):\n 1. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 2. direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 2. direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]", "have \"direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X]]", "by (fact direct_decomp_singleton)"], ["proof (state)\nthis:\n  direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X]]\n\ngoal (2 subgoals):\n 1. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 2. direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]", "hence \"direct_decomp (ideal {f0} \\<inter> P[X]) [{0}, ideal {f0} \\<inter> P[X]]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X]]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal {f0} \\<inter> P[X]) [{0}, ideal {f0} \\<inter> P[X]]", "by (rule direct_decomp_Cons_zeroI)"], ["proof (state)\nthis:\n  direct_decomp (ideal {f0} \\<inter> P[X]) [{0}, ideal {f0} \\<inter> P[X]]\n\ngoal (2 subgoals):\n 1. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []\n 2. direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]", "thus \"direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal {f0} \\<inter> P[X]) [{0}, ideal {f0} \\<inter> P[X]]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]", "using perm.swap"], ["proof (prove)\nusing this:\n  direct_decomp (ideal {f0} \\<inter> P[X]) [{0}, ideal {f0} \\<inter> P[X]]\n  ?y # ?x # ?l <~~> ?x # ?y # ?l\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]", "by (rule direct_decomp_perm)"], ["proof (state)\nthis:\n  direct_decomp (ideal {f0} \\<inter> P[X]) [ideal {f0} \\<inter> P[X], {0}]\n\ngoal (1 subgoal):\n 1. (\\<And>f. f \\<in> {} \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n    hom_decomp []", "qed (simp add: hom_decomp_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (insert f F)"], ["proof (state)\nthis:\n  finite F\n  f \\<notin> F\n  \\<lbrakk>\\<And>ps T.\n              \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n               cone_decomp T ps;\n               (\\<And>f.\n                   f \\<in> F \\<Longrightarrow>\n                   homogeneous f) \\<Longrightarrow>\n               hom_decomp ps;\n               direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n              \\<Longrightarrow> ?thesis20;\n   F \\<subseteq> P[X];\n   \\<And>f.\n      f \\<in> F \\<Longrightarrow> poly_deg f \\<le> poly_deg f0\\<rbrakk>\n  \\<Longrightarrow> ?thesis20\n  \\<lbrakk>valid_decomp X ?ps20; standard_decomp (poly_deg f0) ?ps20;\n   cone_decomp ?T20 ?ps20;\n   (\\<And>fa.\n       fa \\<in> insert f F \\<Longrightarrow>\n       homogeneous fa) \\<Longrightarrow>\n   hom_decomp ?ps20;\n   direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n    [ideal {f0} \\<inter> P[X], ?T20]\\<rbrakk>\n  \\<Longrightarrow> thesis\n  insert f F \\<subseteq> P[X]\n  ?f20 \\<in> insert f F \\<Longrightarrow> poly_deg ?f20 \\<le> poly_deg f0\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "from insert.prems(2)"], ["proof (chain)\npicking this:\n  insert f F \\<subseteq> P[X]", "have \"F \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  insert f F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. F \\<subseteq> P[X]", "by simp"], ["proof (state)\nthis:\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"poly_deg f' \\<le> poly_deg f0\" if \"f' \\<in> F\" for f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f0", "from that"], ["proof (chain)\npicking this:\n  f' \\<in> F", "have \"f' \\<in> insert f F\""], ["proof (prove)\nusing this:\n  f' \\<in> F\n\ngoal (1 subgoal):\n 1. f' \\<in> insert f F", "by simp"], ["proof (state)\nthis:\n  f' \\<in> insert f F\n\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f0", "thus ?thesis"], ["proof (prove)\nusing this:\n  f' \\<in> insert f F\n\ngoal (1 subgoal):\n 1. poly_deg f' \\<le> poly_deg f0", "by (rule insert.prems)"], ["proof (state)\nthis:\n  poly_deg f' \\<le> poly_deg f0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f'20 \\<in> F \\<Longrightarrow> poly_deg ?f'20 \\<le> poly_deg f0\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  ?f'20 \\<in> F \\<Longrightarrow> poly_deg ?f'20 \\<le> poly_deg f0", "obtain T ps where valid_ps: \"valid_decomp X ps\" and std_ps: \"standard_decomp (poly_deg f0) ps\"\n    and cn_ps: \"cone_decomp T ps\" and dd: \"direct_decomp (ideal (insert f0 F) \\<inter> P[X]) [ideal {f0} \\<inter> P[X], T]\"\n    and hom_ps: \"(\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> hom_decomp ps\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  ?f'20 \\<in> F \\<Longrightarrow> poly_deg ?f'20 \\<le> poly_deg f0\n\ngoal (1 subgoal):\n 1. (\\<And>ps T.\n        \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n         cone_decomp T ps;\n         direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n          [ideal {f0} \\<inter> P[X], T];\n         (\\<And>f.\n             f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n         hom_decomp ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert.hyps(3)"], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  ?f'20 \\<in> F \\<Longrightarrow> poly_deg ?f'20 \\<le> poly_deg f0\n  \\<lbrakk>\\<And>ps T.\n              \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n               cone_decomp T ps;\n               (\\<And>f.\n                   f \\<in> F \\<Longrightarrow>\n                   homogeneous f) \\<Longrightarrow>\n               hom_decomp ps;\n               direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n              \\<Longrightarrow> ?thesis20;\n   F \\<subseteq> P[X];\n   \\<And>f.\n      f \\<in> F \\<Longrightarrow> poly_deg f \\<le> poly_deg f0\\<rbrakk>\n  \\<Longrightarrow> ?thesis20\n\ngoal (1 subgoal):\n 1. (\\<And>ps T.\n        \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n         cone_decomp T ps;\n         direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n          [ideal {f0} \\<inter> P[X], T];\n         (\\<And>f.\n             f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n         hom_decomp ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  valid_decomp X ps\n  standard_decomp (poly_deg f0) ps\n  cone_decomp T ps\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X], T]\n  (\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow>\n  hom_decomp ps\n\ngoal (1 subgoal):\n 1. \\<And>x F thesis.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>thesis.\n           \\<lbrakk>\\<And>ps T.\n                       \\<lbrakk>valid_decomp X ps;\n                        standard_decomp (poly_deg f0) ps; cone_decomp T ps;\n                        (\\<And>f.\n                            f \\<in> F \\<Longrightarrow>\n                            homogeneous f) \\<Longrightarrow>\n                        hom_decomp ps;\n                        direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n                         [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            F \\<subseteq> P[X];\n            \\<And>f.\n               f \\<in> F \\<Longrightarrow>\n               poly_deg f \\<le> poly_deg f0\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>ps T.\n           \\<lbrakk>valid_decomp X ps; standard_decomp (poly_deg f0) ps;\n            cone_decomp T ps;\n            (\\<And>f.\n                f \\<in> insert x F \\<Longrightarrow>\n                homogeneous f) \\<Longrightarrow>\n            hom_decomp ps;\n            direct_decomp (ideal (insert f0 (insert x F)) \\<inter> P[X])\n             [ideal {f0} \\<inter> P[X], T]\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        insert x F \\<subseteq> P[X];\n        \\<And>f.\n           f \\<in> insert x F \\<Longrightarrow>\n           poly_deg f \\<le> poly_deg f0\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> thesis\n 2. f \\<noteq> 0 \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> thesis\n 2. f \\<noteq> 0 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule insert.prems)"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_decomp X ?ps20\n 2. standard_decomp (poly_deg f0) ?ps20\n 3. cone_decomp ?T20 ?ps20\n 4. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp ?ps20\n 5. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "from dd"], ["proof (chain)\npicking this:\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X], T]", "show \"direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X]) [ideal {f0} \\<inter> P[X], T]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X], T]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], T]", "by (simp only: insert_commute[of f0] True ideal.span_insert_zero)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X], T]\n\ngoal (4 subgoals):\n 1. valid_decomp X ?ps20\n 2. standard_decomp (poly_deg f0) ?ps20\n 3. cone_decomp T ?ps20\n 4. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp ?ps20", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_decomp X ?ps20\n 2. standard_decomp (poly_deg f0) ?ps20\n 3. cone_decomp T ?ps20\n 4. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp ?ps20", "assume \"\\<And>f'. f' \\<in> insert f F \\<Longrightarrow> homogeneous f'\""], ["proof (state)\nthis:\n  ?f'20 \\<in> insert f F \\<Longrightarrow> homogeneous ?f'20\n\ngoal (4 subgoals):\n 1. valid_decomp X ?ps20\n 2. standard_decomp (poly_deg f0) ?ps20\n 3. cone_decomp T ?ps20\n 4. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp ?ps20", "hence \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\""], ["proof (prove)\nusing this:\n  ?f'20 \\<in> insert f F \\<Longrightarrow> homogeneous ?f'20\n\ngoal (1 subgoal):\n 1. \\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f", "by blast"], ["proof (state)\nthis:\n  ?f20 \\<in> F \\<Longrightarrow> homogeneous ?f20\n\ngoal (4 subgoals):\n 1. valid_decomp X ?ps20\n 2. standard_decomp (poly_deg f0) ?ps20\n 3. cone_decomp T ?ps20\n 4. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp ?ps20", "thus \"hom_decomp ps\""], ["proof (prove)\nusing this:\n  ?f20 \\<in> F \\<Longrightarrow> homogeneous ?f20\n\ngoal (1 subgoal):\n 1. hom_decomp ps", "by (rule hom_ps)"], ["proof (state)\nthis:\n  hom_decomp ps\n\ngoal (3 subgoals):\n 1. valid_decomp X ps\n 2. standard_decomp (poly_deg f0) ps\n 3. cone_decomp T ps", "qed fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "let ?D = \"ideal_decomp_aux (insert f0 F) f\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "from insert.hyps(1)"], ["proof (chain)\npicking this:\n  finite F", "have f0F_fin: \"finite (insert f0 F)\""], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. finite (insert f0 F)", "by simp"], ["proof (state)\nthis:\n  finite (insert f0 F)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  finite (insert f0 F)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "from \\<open>F \\<subseteq> P[X]\\<close> assms(3)"], ["proof (chain)\npicking this:\n  F \\<subseteq> P[X]\n  f0 \\<in> P[X]", "have f0F_sub: \"insert f0 F \\<subseteq> P[X]\""], ["proof (prove)\nusing this:\n  F \\<subseteq> P[X]\n  f0 \\<in> P[X]\n\ngoal (1 subgoal):\n 1. insert f0 F \\<subseteq> P[X]", "by simp"], ["proof (state)\nthis:\n  insert f0 F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  insert f0 F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "from insert.prems(2)"], ["proof (chain)\npicking this:\n  insert f F \\<subseteq> P[X]", "have \"f \\<in> P[X]\""], ["proof (prove)\nusing this:\n  insert f F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. f \\<in> P[X]", "by simp"], ["proof (state)\nthis:\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  finite (insert f0 F)\n  insert f0 F \\<subseteq> P[X]\n  f \\<in> P[X]", "have eq: \"ideal (insert f0 F) \\<inter> fst ?D = {0}\" and \"valid_decomp X (snd ?D)\"\n      and cn_D: \"cone_decomp (fst ?D) (snd ?D)\"\n      and \"standard_decomp (poly_deg f) (snd ?D)\"\n      and dd': \"direct_decomp (ideal (insert f (insert f0 F)) \\<inter> P[X])\n                  [fst ?D, ideal (insert f0 F) \\<inter> P[X]]\"\n      and hom_D: \"homogeneous f \\<Longrightarrow> hom_decomp (snd ?D)\""], ["proof (prove)\nusing this:\n  finite (insert f0 F)\n  insert f0 F \\<subseteq> P[X]\n  f \\<in> P[X]\n\ngoal (1 subgoal):\n 1. (ideal (insert f0 F) \\<inter> fst (ideal_decomp_aux (insert f0 F) f) =\n     {0} &&&\n     valid_decomp X (snd (ideal_decomp_aux (insert f0 F) f)) &&&\n     cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n      (snd (ideal_decomp_aux (insert f0 F) f))) &&&\n    standard_decomp (poly_deg f)\n     (snd (ideal_decomp_aux (insert f0 F) f)) &&&\n    direct_decomp (ideal (insert f (insert f0 F)) \\<inter> P[X])\n     [fst (ideal_decomp_aux (insert f0 F) f),\n      ideal (insert f0 F) \\<inter> P[X]] &&&\n    (homogeneous f \\<Longrightarrow>\n     hom_decomp (snd (ideal_decomp_aux (insert f0 F) f)))", "by (rule ideal_decomp_aux, auto intro: ideal_decomp_aux simp: False)"], ["proof (state)\nthis:\n  ideal (insert f0 F) \\<inter> fst (ideal_decomp_aux (insert f0 F) f) = {0}\n  valid_decomp X (snd (ideal_decomp_aux (insert f0 F) f))\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n   (snd (ideal_decomp_aux (insert f0 F) f))\n  standard_decomp (poly_deg f) (snd (ideal_decomp_aux (insert f0 F) f))\n  direct_decomp (ideal (insert f (insert f0 F)) \\<inter> P[X])\n   [fst (ideal_decomp_aux (insert f0 F) f),\n    ideal (insert f0 F) \\<inter> P[X]]\n  homogeneous f \\<Longrightarrow>\n  hom_decomp (snd (ideal_decomp_aux (insert f0 F) f))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "note fin_X this(2-4)"], ["proof (state)\nthis:\n  finite X\n  valid_decomp X (snd (ideal_decomp_aux (insert f0 F) f))\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n   (snd (ideal_decomp_aux (insert f0 F) f))\n  standard_decomp (poly_deg f) (snd (ideal_decomp_aux (insert f0 F) f))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  finite X\n  valid_decomp X (snd (ideal_decomp_aux (insert f0 F) f))\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n   (snd (ideal_decomp_aux (insert f0 F) f))\n  standard_decomp (poly_deg f) (snd (ideal_decomp_aux (insert f0 F) f))\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "have \"poly_deg f \\<le> poly_deg f0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg f \\<le> poly_deg f0", "by (rule insert.prems) simp"], ["proof (state)\nthis:\n  poly_deg f \\<le> poly_deg f0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X (snd (ideal_decomp_aux (insert f0 F) f))\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n   (snd (ideal_decomp_aux (insert f0 F) f))\n  standard_decomp (poly_deg f) (snd (ideal_decomp_aux (insert f0 F) f))\n  poly_deg f \\<le> poly_deg f0", "obtain qs where valid_qs: \"valid_decomp X qs\" and cn_qs: \"cone_decomp (fst ?D) qs\"\n      and std_qs: \"standard_decomp (poly_deg f0) qs\"\n      and hom_qs: \"hom_decomp (snd ?D) \\<Longrightarrow> hom_decomp qs\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X (snd (ideal_decomp_aux (insert f0 F) f))\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n   (snd (ideal_decomp_aux (insert f0 F) f))\n  standard_decomp (poly_deg f) (snd (ideal_decomp_aux (insert f0 F) f))\n  poly_deg f \\<le> poly_deg f0\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs;\n         cone_decomp (fst (ideal_decomp_aux (insert f0 F) f)) qs;\n         standard_decomp (poly_deg f0) qs;\n         hom_decomp\n          (snd (ideal_decomp_aux (insert f0 F) f)) \\<Longrightarrow>\n         hom_decomp qs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decomp_geE) blast"], ["proof (state)\nthis:\n  valid_decomp X qs\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f)) qs\n  standard_decomp (poly_deg f0) qs\n  hom_decomp (snd (ideal_decomp_aux (insert f0 F) f)) \\<Longrightarrow>\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "let ?T = \"sum_list ` listset [T, fst ?D]\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "let ?ps = \"ps @ qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule insert.prems)"], ["proof (state)\ngoal (5 subgoals):\n 1. valid_decomp X ?ps20\n 2. standard_decomp (poly_deg f0) ?ps20\n 3. cone_decomp ?T20 ?ps20\n 4. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp ?ps20\n 5. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "from valid_ps valid_qs"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  valid_decomp X qs", "show \"valid_decomp X ?ps\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (ps @ qs)", "by (rule valid_decomp_append)"], ["proof (state)\nthis:\n  valid_decomp X (ps @ qs)\n\ngoal (4 subgoals):\n 1. standard_decomp (poly_deg f0) (ps @ qs)\n 2. cone_decomp ?T20 (ps @ qs)\n 3. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 4. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. standard_decomp (poly_deg f0) (ps @ qs)\n 2. cone_decomp ?T20 (ps @ qs)\n 3. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 4. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "from std_ps std_qs"], ["proof (chain)\npicking this:\n  standard_decomp (poly_deg f0) ps\n  standard_decomp (poly_deg f0) qs", "show \"standard_decomp (poly_deg f0) ?ps\""], ["proof (prove)\nusing this:\n  standard_decomp (poly_deg f0) ps\n  standard_decomp (poly_deg f0) qs\n\ngoal (1 subgoal):\n 1. standard_decomp (poly_deg f0) (ps @ qs)", "by (rule standard_decomp_append)"], ["proof (state)\nthis:\n  standard_decomp (poly_deg f0) (ps @ qs)\n\ngoal (3 subgoals):\n 1. cone_decomp ?T20 (ps @ qs)\n 2. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 3. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. cone_decomp ?T20 (ps @ qs)\n 2. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 3. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "from dd perm.swap"], ["proof (chain)\npicking this:\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X], T]\n  ?y # ?x # ?l <~~> ?x # ?y # ?l", "have \"direct_decomp (ideal (insert f0 F) \\<inter> P[X]) [T, ideal {f0} \\<inter> P[X]]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X], T]\n  ?y # ?x # ?l <~~> ?x # ?y # ?l\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n     [T, ideal {f0} \\<inter> P[X]]", "by (rule direct_decomp_perm)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [T, ideal {f0} \\<inter> P[X]]\n\ngoal (3 subgoals):\n 1. cone_decomp ?T20 (ps @ qs)\n 2. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 3. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "hence \"T \\<subseteq> ideal (insert f0 F) \\<inter> P[X]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [T, ideal {f0} \\<inter> P[X]]\n\ngoal (1 subgoal):\n 1. T \\<subseteq> ideal (insert f0 F) \\<inter> P[X]", "by (rule direct_decomp_Cons_subsetI) (simp add: ideal.span_zero zero_in_Polys)"], ["proof (state)\nthis:\n  T \\<subseteq> ideal (insert f0 F) \\<inter> P[X]\n\ngoal (3 subgoals):\n 1. cone_decomp ?T20 (ps @ qs)\n 2. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 3. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "hence \"T \\<inter> fst ?D \\<subseteq> ideal (insert f0 F) \\<inter> fst ?D\""], ["proof (prove)\nusing this:\n  T \\<subseteq> ideal (insert f0 F) \\<inter> P[X]\n\ngoal (1 subgoal):\n 1. T \\<inter> fst (ideal_decomp_aux (insert f0 F) f)\n    \\<subseteq> ideal (insert f0 F) \\<inter>\n                fst (ideal_decomp_aux (insert f0 F) f)", "by blast"], ["proof (state)\nthis:\n  T \\<inter> fst (ideal_decomp_aux (insert f0 F) f)\n  \\<subseteq> ideal (insert f0 F) \\<inter>\n              fst (ideal_decomp_aux (insert f0 F) f)\n\ngoal (3 subgoals):\n 1. cone_decomp ?T20 (ps @ qs)\n 2. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 3. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "hence \"T \\<inter> fst ?D \\<subseteq> {0}\""], ["proof (prove)\nusing this:\n  T \\<inter> fst (ideal_decomp_aux (insert f0 F) f)\n  \\<subseteq> ideal (insert f0 F) \\<inter>\n              fst (ideal_decomp_aux (insert f0 F) f)\n\ngoal (1 subgoal):\n 1. T \\<inter> fst (ideal_decomp_aux (insert f0 F) f) \\<subseteq> {0}", "by (simp only: eq)"], ["proof (state)\nthis:\n  T \\<inter> fst (ideal_decomp_aux (insert f0 F) f) \\<subseteq> {0}\n\ngoal (3 subgoals):\n 1. cone_decomp ?T20 (ps @ qs)\n 2. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 3. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "from refl"], ["proof (chain)\npicking this:\n  ?t = ?t", "have \"direct_decomp ?T [T, fst ?D]\""], ["proof (prove)\nusing this:\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. direct_decomp\n     (sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)])\n     [T, fst (ideal_decomp_aux (insert f0 F) f)]", "proof (intro direct_decompI inj_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "fix xs ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "assume \"xs \\<in> listset [T, fst ?D]\""], ["proof (state)\nthis:\n  xs \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "then"], ["proof (chain)\npicking this:\n  xs \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "obtain x1 x2 where \"x1 \\<in> T\" and \"x2 \\<in> fst ?D\" and xs: \"xs = [x1, x2]\""], ["proof (prove)\nusing this:\n  xs \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 \\<in> T;\n         x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f);\n         xs = [x1, x2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  x1 \\<in> T\n  x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)\n  xs = [x1, x2]\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "assume \"ys \\<in> listset [T, fst ?D]\""], ["proof (state)\nthis:\n  ys \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "then"], ["proof (chain)\npicking this:\n  ys \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "obtain y1 y2 where \"y1 \\<in> T\" and \"y2 \\<in> fst ?D\" and ys: \"ys = [y1, y2]\""], ["proof (prove)\nusing this:\n  ys \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (1 subgoal):\n 1. (\\<And>y1 y2.\n        \\<lbrakk>y1 \\<in> T;\n         y2 \\<in> fst (ideal_decomp_aux (insert f0 F) f);\n         ys = [y1, y2]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule listset_doubletonE)"], ["proof (state)\nthis:\n  y1 \\<in> T\n  y2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)\n  ys = [y1, y2]\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "assume \"sum_list xs = sum_list ys\""], ["proof (state)\nthis:\n  sum_list xs = sum_list ys\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "hence \"x1 - y1 = y2 - x2\""], ["proof (prove)\nusing this:\n  sum_list xs = sum_list ys\n\ngoal (1 subgoal):\n 1. x1 - y1 = y2 - x2", "by (simp add: xs ys) (metis add_diff_cancel_left add_diff_cancel_right)"], ["proof (state)\nthis:\n  x1 - y1 = y2 - x2\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "moreover"], ["proof (state)\nthis:\n  x1 - y1 = y2 - x2\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "from cn_ps \\<open>x1 \\<in> T\\<close> \\<open>y1 \\<in> T\\<close>"], ["proof (chain)\npicking this:\n  cone_decomp T ps\n  x1 \\<in> T\n  y1 \\<in> T", "have \"x1 - y1 \\<in> T\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n  x1 \\<in> T\n  y1 \\<in> T\n\ngoal (1 subgoal):\n 1. x1 - y1 \\<in> T", "by (rule cone_decomp_closed_minus)"], ["proof (state)\nthis:\n  x1 - y1 \\<in> T\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "moreover"], ["proof (state)\nthis:\n  x1 - y1 \\<in> T\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "from cn_D \\<open>y2 \\<in> fst ?D\\<close> \\<open>x2 \\<in> fst ?D\\<close>"], ["proof (chain)\npicking this:\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n   (snd (ideal_decomp_aux (insert f0 F) f))\n  y2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)\n  x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)", "have \"y2 - x2 \\<in> fst ?D\""], ["proof (prove)\nusing this:\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f))\n   (snd (ideal_decomp_aux (insert f0 F) f))\n  y2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)\n  x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)\n\ngoal (1 subgoal):\n 1. y2 - x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)", "by (rule cone_decomp_closed_minus)"], ["proof (state)\nthis:\n  y2 - x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "ultimately"], ["proof (chain)\npicking this:\n  x1 - y1 = y2 - x2\n  x1 - y1 \\<in> T\n  y2 - x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)", "have \"y2 - x2 \\<in> T \\<inter> fst ?D\""], ["proof (prove)\nusing this:\n  x1 - y1 = y2 - x2\n  x1 - y1 \\<in> T\n  y2 - x2 \\<in> fst (ideal_decomp_aux (insert f0 F) f)\n\ngoal (1 subgoal):\n 1. y2 - x2 \\<in> T \\<inter> fst (ideal_decomp_aux (insert f0 F) f)", "by simp"], ["proof (state)\nthis:\n  y2 - x2 \\<in> T \\<inter> fst (ideal_decomp_aux (insert f0 F) f)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "also"], ["proof (state)\nthis:\n  y2 - x2 \\<in> T \\<inter> fst (ideal_decomp_aux (insert f0 F) f)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "have \"\\<dots> \\<subseteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<inter> fst (ideal_decomp_aux (insert f0 F) f) \\<subseteq> {0}", "by fact"], ["proof (state)\nthis:\n  T \\<inter> fst (ideal_decomp_aux (insert f0 F) f) \\<subseteq> {0}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "finally"], ["proof (chain)\npicking this:\n  y2 - x2 \\<in> {0}", "have \"x2 = y2\""], ["proof (prove)\nusing this:\n  y2 - x2 \\<in> {0}\n\ngoal (1 subgoal):\n 1. x2 = y2", "by simp"], ["proof (state)\nthis:\n  x2 = y2\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>t. t = t;\n        x \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        y \\<in> listset [T, fst (ideal_decomp_aux (insert f0 F) f)];\n        sum_list x = sum_list y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "with \\<open>x1 - y1 = y2 - x2\\<close>"], ["proof (chain)\npicking this:\n  x1 - y1 = y2 - x2\n  x2 = y2", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  x1 - y1 = y2 - x2\n  x2 = y2\n\ngoal (1 subgoal):\n 1. xs = ys", "by (simp add: xs ys)"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. (\\<And>t. t = t) \\<Longrightarrow>\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)] =\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]", "qed"], ["proof (state)\nthis:\n  direct_decomp\n   (sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)])\n   [T, fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (3 subgoals):\n 1. cone_decomp ?T20 (ps @ qs)\n 2. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 3. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X], ?T20]", "thus \"cone_decomp ?T ?ps\""], ["proof (prove)\nusing this:\n  direct_decomp\n   (sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)])\n   [T, fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (1 subgoal):\n 1. cone_decomp\n     (sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)])\n     (ps @ qs)", "using cn_ps cn_qs"], ["proof (prove)\nusing this:\n  direct_decomp\n   (sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)])\n   [T, fst (ideal_decomp_aux (insert f0 F) f)]\n  cone_decomp T ps\n  cone_decomp (fst (ideal_decomp_aux (insert f0 F) f)) qs\n\ngoal (1 subgoal):\n 1. cone_decomp\n     (sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)])\n     (ps @ qs)", "by (rule cone_decomp_append)"], ["proof (state)\nthis:\n  cone_decomp\n   (sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)])\n   (ps @ qs)\n\ngoal (2 subgoals):\n 1. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 2. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 2. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "assume \"\\<And>f'. f' \\<in> insert f F \\<Longrightarrow> homogeneous f'\""], ["proof (state)\nthis:\n  ?f'20 \\<in> insert f F \\<Longrightarrow> homogeneous ?f'20\n\ngoal (2 subgoals):\n 1. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 2. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "hence \"homogeneous f\" and \"\\<And>f'. f' \\<in> F \\<Longrightarrow> homogeneous f'\""], ["proof (prove)\nusing this:\n  ?f'20 \\<in> insert f F \\<Longrightarrow> homogeneous ?f'20\n\ngoal (1 subgoal):\n 1. homogeneous f &&&\n    (\\<And>f'. f' \\<in> F \\<Longrightarrow> homogeneous f')", "by blast+"], ["proof (state)\nthis:\n  homogeneous f\n  ?f'20 \\<in> F \\<Longrightarrow> homogeneous ?f'20\n\ngoal (2 subgoals):\n 1. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 2. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "from this(2)"], ["proof (chain)\npicking this:\n  ?f'20 \\<in> F \\<Longrightarrow> homogeneous ?f'20", "have \"hom_decomp ps\""], ["proof (prove)\nusing this:\n  ?f'20 \\<in> F \\<Longrightarrow> homogeneous ?f'20\n\ngoal (1 subgoal):\n 1. hom_decomp ps", "by (rule hom_ps)"], ["proof (state)\nthis:\n  hom_decomp ps\n\ngoal (2 subgoals):\n 1. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 2. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "moreover"], ["proof (state)\nthis:\n  hom_decomp ps\n\ngoal (2 subgoals):\n 1. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 2. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "from \\<open>homogeneous f\\<close>"], ["proof (chain)\npicking this:\n  homogeneous f", "have \"hom_decomp qs\""], ["proof (prove)\nusing this:\n  homogeneous f\n\ngoal (1 subgoal):\n 1. hom_decomp qs", "by (intro hom_qs hom_D)"], ["proof (state)\nthis:\n  hom_decomp qs\n\ngoal (2 subgoals):\n 1. (\\<And>fa.\n        fa \\<in> insert f F \\<Longrightarrow>\n        homogeneous fa) \\<Longrightarrow>\n    hom_decomp (ps @ qs)\n 2. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "ultimately"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  hom_decomp qs", "show \"hom_decomp (ps @ qs)\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp (ps @ qs)", "by (simp only: hom_decomp_append_iff)"], ["proof (state)\nthis:\n  hom_decomp (ps @ qs)\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "from dd'"], ["proof (chain)\npicking this:\n  direct_decomp (ideal (insert f (insert f0 F)) \\<inter> P[X])\n   [fst (ideal_decomp_aux (insert f0 F) f),\n    ideal (insert f0 F) \\<inter> P[X]]", "have \"direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n                      [ideal (insert f0 F) \\<inter> P[X], fst ?D]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f (insert f0 F)) \\<inter> P[X])\n   [fst (ideal_decomp_aux (insert f0 F) f),\n    ideal (insert f0 F) \\<inter> P[X]]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal (insert f0 F) \\<inter> P[X],\n      fst (ideal_decomp_aux (insert f0 F) f)]", "by (simp add: insert_commute direct_decomp_perm perm.swap)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   [ideal (insert f0 F) \\<inter> P[X],\n    fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "hence \"direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n                      ([fst ?D] @ [ideal {f0} \\<inter> P[X], T])\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   [ideal (insert f0 F) \\<inter> P[X],\n    fst (ideal_decomp_aux (insert f0 F) f)]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     ([fst (ideal_decomp_aux (insert f0 F) f)] @\n      [ideal {f0} \\<inter> P[X], T])", "using dd"], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   [ideal (insert f0 F) \\<inter> P[X],\n    fst (ideal_decomp_aux (insert f0 F) f)]\n  direct_decomp (ideal (insert f0 F) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X], T]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     ([fst (ideal_decomp_aux (insert f0 F) f)] @\n      [ideal {f0} \\<inter> P[X], T])", "by (rule direct_decomp_direct_decomp)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   ([fst (ideal_decomp_aux (insert f0 F) f)] @\n    [ideal {f0} \\<inter> P[X], T])\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "hence \"direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X]) ([ideal {f0} \\<inter> P[X]] @ [T, fst ?D])\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   ([fst (ideal_decomp_aux (insert f0 F) f)] @\n    [ideal {f0} \\<inter> P[X], T])\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     ([ideal {f0} \\<inter> P[X]] @\n      [T, fst (ideal_decomp_aux (insert f0 F) f)])", "by (rule direct_decomp_perm) auto"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   ([ideal {f0} \\<inter> P[X]] @\n    [T, fst (ideal_decomp_aux (insert f0 F) f)])\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "hence \"direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X]) [sum_list ` listset [ideal {f0} \\<inter> P[X]], ?T]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   ([ideal {f0} \\<inter> P[X]] @\n    [T, fst (ideal_decomp_aux (insert f0 F) f)])\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [sum_list ` listset [ideal {f0} \\<inter> P[X]],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "by (rule direct_decomp_appendD)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   [sum_list ` listset [ideal {f0} \\<inter> P[X]],\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "thus \"direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X]) [ideal {f0} \\<inter> P[X], ?T]\""], ["proof (prove)\nusing this:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   [sum_list ` listset [ideal {f0} \\<inter> P[X]],\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]\n\ngoal (1 subgoal):\n 1. direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n     [ideal {f0} \\<inter> P[X],\n      sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]", "by (simp add: image_image)"], ["proof (state)\nthis:\n  direct_decomp (ideal (insert f0 (insert f F)) \\<inter> P[X])\n   [ideal {f0} \\<inter> P[X],\n    sum_list ` listset [T, fst (ideal_decomp_aux (insert f0 F) f)]]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Exact Cone Decompositions\\<close>"], ["", "definition exact_decomp :: \"nat \\<Rightarrow> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<times> 'x set) list \\<Rightarrow> bool\"\n  where \"exact_decomp m ps \\<longleftrightarrow> (\\<forall>(h, U)\\<in>set ps. h \\<in> P[X] \\<and> U \\<subseteq> X) \\<and>\n                              (\\<forall>(h, U)\\<in>set ps. \\<forall>(h', U')\\<in>set ps. poly_deg h = poly_deg h' \\<longrightarrow>\n                                          m < card U \\<longrightarrow> m < card U' \\<longrightarrow> (h, U) = (h', U'))\""], ["", "lemma exact_decompI:\n  \"(\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]) \\<Longrightarrow> (\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X) \\<Longrightarrow>\n    (\\<And>h h' U U'. (h, U) \\<in> set ps \\<Longrightarrow> (h', U') \\<in> set ps \\<Longrightarrow> poly_deg h = poly_deg h' \\<Longrightarrow>\n            m < card U \\<Longrightarrow> m < card U' \\<Longrightarrow> (h, U) = (h', U')) \\<Longrightarrow>\n    exact_decomp m ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X];\n     \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X;\n     \\<And>h h' U U'.\n        \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n         poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n        \\<Longrightarrow> (h, U) = (h', U')\\<rbrakk>\n    \\<Longrightarrow> exact_decomp m ps", "unfolding exact_decomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X];\n     \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X;\n     \\<And>h h' U U'.\n        \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n         poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n        \\<Longrightarrow> (h, U) = (h', U')\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>(h, U)\\<in>set ps.\n                          h \\<in> P[X] \\<and> U \\<subseteq> X) \\<and>\n                      (\\<forall>(h, U)\\<in>set ps.\n                          \\<forall>(h', U')\\<in>set ps.\n                             poly_deg h = poly_deg h' \\<longrightarrow>\n                             m < card U \\<longrightarrow>\n                             m < card U' \\<longrightarrow>\n                             (h, U) = (h', U'))", "by fastforce"], ["", "lemma exact_decompD:\n  assumes \"exact_decomp m ps\" and \"(h, U) \\<in> set ps\"\n  shows \"h \\<in> P[X]\" and \"U \\<subseteq> X\"\n    and \"(h', U') \\<in> set ps \\<Longrightarrow> poly_deg h = poly_deg h' \\<Longrightarrow> m < card U \\<Longrightarrow> m < card U' \\<Longrightarrow>\n            (h, U) = (h', U')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&&\n    U \\<subseteq> X &&&\n    (\\<lbrakk>(h', U') \\<in> set ps; poly_deg h = poly_deg h'; m < card U;\n      m < card U'\\<rbrakk>\n     \\<Longrightarrow> (h, U) = (h', U'))", "using assms"], ["proof (prove)\nusing this:\n  exact_decomp m ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&&\n    U \\<subseteq> X &&&\n    (\\<lbrakk>(h', U') \\<in> set ps; poly_deg h = poly_deg h'; m < card U;\n      m < card U'\\<rbrakk>\n     \\<Longrightarrow> (h, U) = (h', U'))", "unfolding exact_decomp_def"], ["proof (prove)\nusing this:\n  (\\<forall>(h, U)\\<in>set ps. h \\<in> P[X] \\<and> U \\<subseteq> X) \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      \\<forall>(h', U')\\<in>set ps.\n         poly_deg h = poly_deg h' \\<longrightarrow>\n         m < card U \\<longrightarrow>\n         m < card U' \\<longrightarrow> (h, U) = (h', U'))\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&&\n    U \\<subseteq> X &&&\n    (\\<lbrakk>(h', U') \\<in> set ps; poly_deg h = poly_deg h'; m < card U;\n      m < card U'\\<rbrakk>\n     \\<Longrightarrow> (h, U) = (h', U'))", "by fastforce+"], ["", "lemma exact_decompI_zero:\n  assumes \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\" and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X\"\n    and \"\\<And>h h' U U'. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> (h', U') \\<in> set (ps\\<^sub>+) \\<Longrightarrow> poly_deg h = poly_deg h' \\<Longrightarrow>\n              (h, U) = (h', U')\"\n  shows \"exact_decomp 0 ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exact_decomp 0 ps", "using assms(1, 2)"], ["proof (prove)\nusing this:\n  (?h21, ?U21) \\<in> set ps \\<Longrightarrow> ?h21 \\<in> P[X]\n  (?h21, ?U21) \\<in> set ps \\<Longrightarrow> ?U21 \\<subseteq> X\n\ngoal (1 subgoal):\n 1. exact_decomp 0 ps", "proof (rule exact_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "fix h h' and U U' :: \"'x set\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"0 < card U\""], ["proof (state)\nthis:\n  0 < card U\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "hence \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < card U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "moreover"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "ultimately"], ["proof (chain)\npicking this:\n  U \\<noteq> {}\n  (h, U) \\<in> set ps", "have \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"0 < card U'\""], ["proof (state)\nthis:\n  0 < card U'\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "hence \"U' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < card U'\n\ngoal (1 subgoal):\n 1. U' \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U' \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "moreover"], ["proof (state)\nthis:\n  U' \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"(h', U') \\<in> set ps\""], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "ultimately"], ["proof (chain)\npicking this:\n  U' \\<noteq> {}\n  (h', U') \\<in> set ps", "have \"(h', U') \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  U' \\<noteq> {}\n  (h', U') \\<in> set ps\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h', U') \\<in> set (ps\\<^sub>+)\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"poly_deg h = poly_deg h'\""], ["proof (state)\nthis:\n  poly_deg h = poly_deg h'\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; 0 < card U; 0 < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "with \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close> \\<open>(h', U') \\<in> set (ps\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  (h', U') \\<in> set (ps\\<^sub>+)\n  poly_deg h = poly_deg h'", "show \"(h, U) = (h', U')\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  (h', U') \\<in> set (ps\\<^sub>+)\n  poly_deg h = poly_deg h'\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "by (rule assms(3))"], ["proof (state)\nthis:\n  (h, U) = (h', U')\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (h, ?U44 h U) \\<in> set ps\n 2. \\<And>h U.\n       (h, U) \\<in> set ps \\<Longrightarrow> (?h22 h U, U) \\<in> set ps", "qed"], ["", "lemma exact_decompD_zero:\n  assumes \"exact_decomp 0 ps\" and \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"(h', U') \\<in> set (ps\\<^sub>+)\"\n    and \"poly_deg h = poly_deg h'\"\n  shows \"(h, U) = (h', U')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "from assms(2)"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"(h, U) \\<in> set ps\" and \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps &&& U \\<noteq> {}", "by (simp_all add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "from assms(1) this(1)"], ["proof (chain)\npicking this:\n  exact_decomp 0 ps\n  (h, U) \\<in> set ps", "have \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp 0 ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "hence \"finite U\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. finite U", "using fin_X"], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "with \\<open>U \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  U \\<noteq> {}\n  finite U", "have \"0 < card U\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n  finite U\n\ngoal (1 subgoal):\n 1. 0 < card U", "by (simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < card U\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "from assms(3)"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set (ps\\<^sub>+)", "have \"(h', U') \\<in> set ps\" and \"U' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set ps &&& U' \\<noteq> {}", "by (simp_all add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  U' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "from assms(1) this(1)"], ["proof (chain)\npicking this:\n  exact_decomp 0 ps\n  (h', U') \\<in> set ps", "have \"U' \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp 0 ps\n  (h', U') \\<in> set ps\n\ngoal (1 subgoal):\n 1. U' \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "hence \"finite U'\""], ["proof (prove)\nusing this:\n  U' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. finite U'", "using fin_X"], ["proof (prove)\nusing this:\n  U' \\<subseteq> X\n  finite X\n\ngoal (1 subgoal):\n 1. finite U'", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite U'\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "with \\<open>U' \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  U' \\<noteq> {}\n  finite U'", "have \"0 < card U'\""], ["proof (prove)\nusing this:\n  U' \\<noteq> {}\n  finite U'\n\ngoal (1 subgoal):\n 1. 0 < card U'", "by (simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < card U'\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "by (rule exact_decompD) fact+"], ["proof (state)\nthis:\n  (h, U) = (h', U')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exact_decomp_imp_valid_decomp:\n  assumes \"exact_decomp m ps\" and \"\\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0\"\n  shows \"valid_decomp X ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X ps", "proof (rule valid_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X", "fix h U"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X", "assume *: \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0\n 3. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X", "with assms(1)"], ["proof (chain)\npicking this:\n  exact_decomp m ps\n  (h, U) \\<in> set ps", "show \"h \\<in> P[X]\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp m ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& U \\<subseteq> X", "by (rule exact_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<noteq> 0", "from *"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps", "show \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by (rule assms(2))"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exact_decomp_card_X:\n  assumes \"valid_decomp X ps\" and \"card X \\<le> m\"\n  shows \"exact_decomp m ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exact_decomp m ps", "proof (rule exact_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "fix h U"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (3 subgoals):\n 1. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U. (h, U) \\<in> set ps \\<Longrightarrow> U \\<subseteq> X\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "with assms(1)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "show \"h \\<in> P[X]\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "fix h1 h2 U1 U2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"(h1, U1) \\<in> set ps\""], ["proof (state)\nthis:\n  (h1, U1) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "with assms(1)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h1, U1) \\<in> set ps", "have \"U1 \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h1, U1) \\<in> set ps\n\ngoal (1 subgoal):\n 1. U1 \\<subseteq> X", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  U1 \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "with fin_X"], ["proof (chain)\npicking this:\n  finite X\n  U1 \\<subseteq> X", "have \"card U1 \\<le> card X\""], ["proof (prove)\nusing this:\n  finite X\n  U1 \\<subseteq> X\n\ngoal (1 subgoal):\n 1. card U1 \\<le> card X", "by (rule card_mono)"], ["proof (state)\nthis:\n  card U1 \\<le> card X\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "also"], ["proof (state)\nthis:\n  card U1 \\<le> card X\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "have \"\\<dots> \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card X \\<le> m", "by (fact assms(2))"], ["proof (state)\nthis:\n  card X \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "also"], ["proof (state)\nthis:\n  card X \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"m < card U1\""], ["proof (state)\nthis:\n  m < card U1\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set ps; (h', U') \\<in> set ps;\n        poly_deg h = poly_deg h'; m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "finally"], ["proof (chain)\npicking this:\n  card U1 < card U1", "show \"(h1, U1) = (h2, U2)\""], ["proof (prove)\nusing this:\n  card U1 < card U1\n\ngoal (1 subgoal):\n 1. (h1, U1) = (h2, U2)", "by simp"], ["proof (state)\nthis:\n  (h1, U1) = (h2, U2)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \\<a> :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<times> 'x set) list \\<Rightarrow> nat\"\n  where \"\\<a> ps = (LEAST k. standard_decomp k ps)\""], ["", "definition \\<b> :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<times> 'x set) list \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where \"\\<b> ps i = (LEAST d. \\<a> ps \\<le> d \\<and> (\\<forall>(h, U)\\<in>set ps. i \\<le> card U \\<longrightarrow> poly_deg h < d))\""], ["", "lemma \\<a>: \"standard_decomp k ps \\<Longrightarrow> standard_decomp (\\<a> ps) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp k ps \\<Longrightarrow> standard_decomp (\\<a> ps) ps", "unfolding \\<a>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp k ps \\<Longrightarrow>\n    standard_decomp (LEAST k. standard_decomp k ps) ps", "by (rule LeastI)"], ["", "lemma \\<a>_Nil:\n  assumes \"ps\\<^sub>+ = []\"\n  shows \"\\<a> ps = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a> ps = 0", "from assms"], ["proof (chain)\npicking this:\n  ps\\<^sub>+ = []", "have \"standard_decomp 0 ps\""], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n\ngoal (1 subgoal):\n 1. standard_decomp 0 ps", "by (rule standard_decomp_Nil)"], ["proof (state)\nthis:\n  standard_decomp 0 ps\n\ngoal (1 subgoal):\n 1. \\<a> ps = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  standard_decomp 0 ps\n\ngoal (1 subgoal):\n 1. \\<a> ps = 0", "unfolding \\<a>_def"], ["proof (prove)\nusing this:\n  standard_decomp 0 ps\n\ngoal (1 subgoal):\n 1. (LEAST k. standard_decomp k ps) = 0", "by (rule Least_eq_0)"], ["proof (state)\nthis:\n  \\<a> ps = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<a>_nonempty:\n  assumes \"valid_decomp X ps\" and \"standard_decomp k ps\" and \"ps\\<^sub>+ \\<noteq> []\"\n  shows \"\\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "using fin_X assms(1) _ assms(3)"], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "proof (rule standard_decomp_nonempty_unique)"], ["proof (state)\ngoal (1 subgoal):\n 1. standard_decomp (\\<a> ps) ps", "from assms(2)"], ["proof (chain)\npicking this:\n  standard_decomp k ps", "show \"standard_decomp (\\<a> ps) ps\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n\ngoal (1 subgoal):\n 1. standard_decomp (\\<a> ps) ps", "by (rule \\<a>)"], ["proof (state)\nthis:\n  standard_decomp (\\<a> ps) ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<a>_nonempty_unique:\n  assumes \"valid_decomp X ps\" and \"standard_decomp k ps\" and \"ps\\<^sub>+ \\<noteq> []\"\n  shows \"\\<a> ps = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a> ps = k", "from assms"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []", "have \"\\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "by (rule \\<a>_nonempty)"], ["proof (state)\nthis:\n  \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. \\<a> ps = k", "moreover"], ["proof (state)\nthis:\n  \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. \\<a> ps = k", "from fin_X assms"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []", "have \"k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "by (rule standard_decomp_nonempty_unique)"], ["proof (state)\nthis:\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. \\<a> ps = k", "ultimately"], ["proof (chain)\npicking this:\n  \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n  k = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. \\<a> ps = k", "by simp"], ["proof (state)\nthis:\n  \\<a> ps = k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<b>:\n  shows \"\\<a> ps \\<le> \\<b> ps i\" and \"(h, U) \\<in> set ps \\<Longrightarrow> i \\<le> card U \\<Longrightarrow> poly_deg h < \\<b> ps i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> \\<b> ps i &&&\n    (\\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n     \\<Longrightarrow> poly_deg h < \\<b> ps i)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> poly_deg h < \\<b> ps i", "let ?A = \"poly_deg ` fst ` set ps\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> poly_deg h < \\<b> ps i", "define A where \"A = insert (\\<a> ps) ?A\""], ["proof (state)\nthis:\n  A = insert (\\<a> ps) (poly_deg ` fst ` set ps)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> poly_deg h < \\<b> ps i", "define m where \"m = Suc (Max A)\""], ["proof (state)\nthis:\n  m = Suc (Max A)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> poly_deg h < \\<b> ps i", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "have \"finite ?A\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set ps)", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set ps)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> poly_deg h < \\<b> ps i", "hence \"finite A\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set ps)\n\ngoal (1 subgoal):\n 1. finite A", "by (simp add: A_def)"], ["proof (state)\nthis:\n  finite A\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> poly_deg h < \\<b> ps i", "have \"\\<a> ps \\<le> \\<b> ps i \\<and> (\\<forall>(h', U')\\<in>set ps. i \\<le> card U' \\<longrightarrow> poly_deg h' < \\<b> ps i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> \\<b> ps i \\<and>\n    (\\<forall>(h', U')\\<in>set ps.\n        i \\<le> card U' \\<longrightarrow> poly_deg h' < \\<b> ps i)", "unfolding \\<b>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps\n    \\<le> (LEAST d.\n              \\<a> ps \\<le> d \\<and>\n              (\\<forall>(h, U)\\<in>set ps.\n                  i \\<le> card U \\<longrightarrow> poly_deg h < d)) \\<and>\n    (\\<forall>(h', U')\\<in>set ps.\n        i \\<le> card U' \\<longrightarrow>\n        poly_deg h'\n        < (LEAST d.\n              \\<a> ps \\<le> d \\<and>\n              (\\<forall>(h, U)\\<in>set ps.\n                  i \\<le> card U \\<longrightarrow> poly_deg h < d)))", "proof (rule LeastI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "have \"\\<a> ps \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps \\<in> A", "by (simp add: A_def)"], ["proof (state)\nthis:\n  \\<a> ps \\<in> A\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "with \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A\n  \\<a> ps \\<in> A", "have \"\\<a> ps \\<le> Max A\""], ["proof (prove)\nusing this:\n  finite A\n  \\<a> ps \\<in> A\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> Max A", "by (rule Max_ge)"], ["proof (state)\nthis:\n  \\<a> ps \\<le> Max A\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "hence \"\\<a> ps \\<le> m\""], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> Max A\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> m", "by (simp add: m_def)"], ["proof (state)\nthis:\n  \\<a> ps \\<le> m\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "moreover"], ["proof (state)\nthis:\n  \\<a> ps \\<le> m\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "{"], ["proof (state)\nthis:\n  \\<a> ps \\<le> m\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "fix h U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "hence \"poly_deg (fst (h, U)) \\<in> ?A\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set ps", "by (intro imageI)"], ["proof (state)\nthis:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set ps\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "hence \"poly_deg h \\<in> A\""], ["proof (prove)\nusing this:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set ps\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> A", "by (simp add: A_def)"], ["proof (state)\nthis:\n  poly_deg h \\<in> A\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "with \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A\n  poly_deg h \\<in> A", "have \"poly_deg h \\<le> Max A\""], ["proof (prove)\nusing this:\n  finite A\n  poly_deg h \\<in> A\n\ngoal (1 subgoal):\n 1. poly_deg h \\<le> Max A", "by (rule Max_ge)"], ["proof (state)\nthis:\n  poly_deg h \\<le> Max A\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "hence \"poly_deg h < m\""], ["proof (prove)\nusing this:\n  poly_deg h \\<le> Max A\n\ngoal (1 subgoal):\n 1. poly_deg h < m", "by (simp add: m_def)"], ["proof (state)\nthis:\n  poly_deg h < m\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "}"], ["proof (state)\nthis:\n  (?ha25, ?Ua25) \\<in> set ps \\<Longrightarrow> poly_deg ?ha25 < m\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> ?k \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < ?k)", "ultimately"], ["proof (chain)\npicking this:\n  \\<a> ps \\<le> m\n  (?ha25, ?Ua25) \\<in> set ps \\<Longrightarrow> poly_deg ?ha25 < m", "show \"\\<a> ps \\<le> m \\<and> (\\<forall>(h, U)\\<in>set ps. i \\<le> card U \\<longrightarrow> poly_deg h < m)\""], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> m\n  (?ha25, ?Ua25) \\<in> set ps \\<Longrightarrow> poly_deg ?ha25 < m\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> m \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < m)", "by blast"], ["proof (state)\nthis:\n  \\<a> ps \\<le> m \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      i \\<le> card U \\<longrightarrow> poly_deg h < m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<a> ps \\<le> \\<b> ps i \\<and>\n  (\\<forall>(h', U')\\<in>set ps.\n      i \\<le> card U' \\<longrightarrow> poly_deg h' < \\<b> ps i)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n    \\<Longrightarrow> poly_deg h < \\<b> ps i", "thus \"\\<a> ps \\<le> \\<b> ps i\" and \"(h, U) \\<in> set ps \\<Longrightarrow> i \\<le> card U \\<Longrightarrow> poly_deg h < \\<b> ps i\""], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> \\<b> ps i \\<and>\n  (\\<forall>(h', U')\\<in>set ps.\n      i \\<le> card U' \\<longrightarrow> poly_deg h' < \\<b> ps i)\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> \\<b> ps i &&&\n    (\\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n     \\<Longrightarrow> poly_deg h < \\<b> ps i)", "by blast+"], ["proof (state)\nthis:\n  \\<a> ps \\<le> \\<b> ps i\n  \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U\\<rbrakk>\n  \\<Longrightarrow> poly_deg h < \\<b> ps i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<b>_le:\n  \"\\<a> ps \\<le> d \\<Longrightarrow> (\\<And>h' U'. (h', U') \\<in> set ps \\<Longrightarrow> i \\<le> card U' \\<Longrightarrow> poly_deg h' < d) \\<Longrightarrow> \\<b> ps i \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<a> ps \\<le> d;\n     \\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; i \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> poly_deg h' < d\\<rbrakk>\n    \\<Longrightarrow> \\<b> ps i \\<le> d", "unfolding \\<b>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<a> ps \\<le> d;\n     \\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; i \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> poly_deg h' < d\\<rbrakk>\n    \\<Longrightarrow> (LEAST d.\n                          \\<a> ps \\<le> d \\<and>\n                          (\\<forall>(h, U)\\<in>set ps.\n                              i \\<le> card U \\<longrightarrow>\n                              poly_deg h < d))\n                      \\<le> d", "by (intro Least_le) blast"], ["", "lemma \\<b>_decreasing:\n  assumes \"i \\<le> j\"\n  shows \"\\<b> ps j \\<le> \\<b> ps i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps j \\<le> \\<b> ps i", "proof (rule \\<b>_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; j \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; j \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; j \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i", "assume \"j \\<le> card U\""], ["proof (state)\nthis:\n  j \\<le> card U\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; j \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i", "with assms(1)"], ["proof (chain)\npicking this:\n  i \\<le> j\n  j \\<le> card U", "have \"i \\<le> card U\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  j \\<le> card U\n\ngoal (1 subgoal):\n 1. i \\<le> card U", "by (rule le_trans)"], ["proof (state)\nthis:\n  i \\<le> card U\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<b> ps i\n 2. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; j \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i", "with \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  i \\<le> card U", "show \"poly_deg h < \\<b> ps i\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  i \\<le> card U\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps i", "by (rule \\<b>)"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps i\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> \\<b> ps i", "qed (fact \\<b>)"], ["", "lemma \\<b>_Nil:\n  assumes \"ps\\<^sub>+ = []\" and \"Suc 0 \\<le> i\"\n  shows \"\\<b> ps i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps i = 0", "unfolding \\<b>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST d.\n        \\<a> ps \\<le> d \\<and>\n        (\\<forall>(h, U)\\<in>set ps.\n            i \\<le> card U \\<longrightarrow> poly_deg h < d)) =\n    0", "proof (rule Least_eq_0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "from assms(1)"], ["proof (chain)\npicking this:\n  ps\\<^sub>+ = []", "have \"\\<a> ps = 0\""], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n\ngoal (1 subgoal):\n 1. \\<a> ps = 0", "by (rule \\<a>_Nil)"], ["proof (state)\nthis:\n  \\<a> ps = 0\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "moreover"], ["proof (state)\nthis:\n  \\<a> ps = 0\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "{"], ["proof (state)\nthis:\n  \\<a> ps = 0\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "fix h and U::\"'x set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "note assms(2)"], ["proof (state)\nthis:\n  Suc 0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "also"], ["proof (state)\nthis:\n  Suc 0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "assume \"i \\<le> card U\""], ["proof (state)\nthis:\n  i \\<le> card U\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "finally"], ["proof (chain)\npicking this:\n  Suc 0 \\<le> card U", "have \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Suc 0 \\<le> card U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "moreover"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "ultimately"], ["proof (chain)\npicking this:\n  U \\<noteq> {}\n  (h, U) \\<in> set ps", "have \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "hence False"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: assms)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> card ?U25; (?h25, ?U25) \\<in> set ps\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<a> ps = 0\n  \\<lbrakk>i \\<le> card ?U25; (?h25, ?U25) \\<in> set ps\\<rbrakk>\n  \\<Longrightarrow> False", "show \"\\<a> ps \\<le> 0 \\<and> (\\<forall>(h, U)\\<in>set ps. i \\<le> card U \\<longrightarrow> poly_deg h < 0)\""], ["proof (prove)\nusing this:\n  \\<a> ps = 0\n  \\<lbrakk>i \\<le> card ?U25; (?h25, ?U25) \\<in> set ps\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> 0 \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < 0)", "by blast"], ["proof (state)\nthis:\n  \\<a> ps \\<le> 0 \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      i \\<le> card U \\<longrightarrow> poly_deg h < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<b>_zero:\n  assumes \"ps \\<noteq> []\"\n  shows \"Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "have \"finite (poly_deg ` fst ` set ps)\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set ps)", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set ps)\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "moreover"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set ps)\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "from assms"], ["proof (chain)\npicking this:\n  ps \\<noteq> []", "have \"poly_deg ` fst ` set ps \\<noteq> {}\""], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. poly_deg ` fst ` set ps \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  poly_deg ` fst ` set ps \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "moreover"], ["proof (state)\nthis:\n  poly_deg ` fst ` set ps \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "have \"\\<forall>a\\<in>poly_deg ` fst ` set ps. a < \\<b> ps 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>poly_deg ` fst ` set ps. a < \\<b> ps 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` fst ` set ps \\<Longrightarrow> a < \\<b> ps 0", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` fst ` set ps \\<Longrightarrow> a < \\<b> ps 0", "assume \"d \\<in> poly_deg ` fst ` set ps\""], ["proof (state)\nthis:\n  d \\<in> poly_deg ` fst ` set ps\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` fst ` set ps \\<Longrightarrow> a < \\<b> ps 0", "then"], ["proof (chain)\npicking this:\n  d \\<in> poly_deg ` fst ` set ps", "obtain p where \"p \\<in> set ps\" and \"d = poly_deg (fst p)\""], ["proof (prove)\nusing this:\n  d \\<in> poly_deg ` fst ` set ps\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> set ps; d = poly_deg (fst p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> set ps\n  d = poly_deg (fst p)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` fst ` set ps \\<Longrightarrow> a < \\<b> ps 0", "moreover"], ["proof (state)\nthis:\n  p \\<in> set ps\n  d = poly_deg (fst p)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` fst ` set ps \\<Longrightarrow> a < \\<b> ps 0", "obtain h U where \"p = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. p = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. p = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` fst ` set ps \\<Longrightarrow> a < \\<b> ps 0", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in> set ps\n  d = poly_deg (fst p)\n  p = (h, U)", "have \"(h, U) \\<in> set ps\" and d: \"d = poly_deg h\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n  d = poly_deg (fst p)\n  p = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps &&& d = poly_deg h", "by simp_all"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n  d = poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> poly_deg ` fst ` set ps \\<Longrightarrow> a < \\<b> ps 0", "from this(1) le0"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  0 \\<le> ?n", "show \"d < \\<b> ps 0\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  0 \\<le> ?n\n\ngoal (1 subgoal):\n 1. d < \\<b> ps 0", "unfolding d"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  0 \\<le> ?n\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "by (rule \\<b>)"], ["proof (state)\nthis:\n  d < \\<b> ps 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a\\<in>poly_deg ` fst ` set ps. a < \\<b> ps 0\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "ultimately"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set ps)\n  poly_deg ` fst ` set ps \\<noteq> {}\n  \\<forall>a\\<in>poly_deg ` fst ` set ps. a < \\<b> ps 0", "have \"Max (poly_deg ` fst ` set ps) < \\<b> ps 0\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set ps)\n  poly_deg ` fst ` set ps \\<noteq> {}\n  \\<forall>a\\<in>poly_deg ` fst ` set ps. a < \\<b> ps 0\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set ps) < \\<b> ps 0", "by simp"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set ps) < \\<b> ps 0\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Max (poly_deg ` fst ` set ps) < \\<b> ps 0\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "by simp"], ["proof (state)\nthis:\n  Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \\<b>_zero_gr:\n  assumes \"(h, U) \\<in> set ps\"\n  shows \"poly_deg h < \\<b> ps 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "have \"poly_deg h \\<le> Max (poly_deg ` fst ` set ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h \\<le> Max (poly_deg ` fst ` set ps)", "proof (rule Max_ge)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (poly_deg ` fst ` set ps)\n 2. poly_deg h \\<in> poly_deg ` fst ` set ps", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "show \"finite (poly_deg ` fst ` set ps)\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set ps)", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set ps)\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set ps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set ps", "from assms"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps", "have \"poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set ps\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set ps", "by (intro imageI)"], ["proof (state)\nthis:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set ps\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set ps", "thus \"poly_deg h \\<in> poly_deg ` fst ` set ps\""], ["proof (prove)\nusing this:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set ps\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set ps", "by simp"], ["proof (state)\nthis:\n  poly_deg h \\<in> poly_deg ` fst ` set ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg h \\<le> Max (poly_deg ` fst ` set ps)\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "also"], ["proof (state)\nthis:\n  poly_deg h \\<le> Max (poly_deg ` fst ` set ps)\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "have \"\\<dots> < Suc \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set ps) < Suc (Max (poly_deg ` fst ` set ps))", "by simp"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set ps) < Suc (Max (poly_deg ` fst ` set ps))\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "also"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set ps) < Suc (Max (poly_deg ` fst ` set ps))\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "have \"\\<dots> \\<le> \\<b> ps 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0", "proof (rule \\<b>_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. ps \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps", "show \"ps \\<noteq> []\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. ps \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ps \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (Max (poly_deg ` fst ` set ps)) \\<le> \\<b> ps 0\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "finally"], ["proof (chain)\npicking this:\n  poly_deg h < \\<b> ps 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg h < \\<b> ps 0\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps 0", "."], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<b>_one:\n  assumes \"valid_decomp X ps\" and \"standard_decomp k ps\"\n  shows \"\\<b> ps (Suc 0) = (if ps\\<^sub>+ = [] then 0 else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "proof (cases \"ps\\<^sub>+ = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "case True"], ["proof (state)\nthis:\n  ps\\<^sub>+ = []\n\ngoal (2 subgoals):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "hence \"\\<b> ps (Suc 0) = 0\""], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) = 0", "using le_refl"], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) = 0", "by (rule \\<b>_Nil)"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) = 0\n\ngoal (2 subgoals):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "with True"], ["proof (chain)\npicking this:\n  ps\\<^sub>+ = []\n  \\<b> ps (Suc 0) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n  \\<b> ps (Suc 0) = 0\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "by simp"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) =\n  (if ps\\<^sub>+ = [] then 0\n   else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "case False"], ["proof (state)\nthis:\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "with assms"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []", "have aP: \"\\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\" (is \"_ = Min ?A\")"], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))", "by (rule \\<a>_nonempty)"], ["proof (state)\nthis:\n  \\<a> ps = Min (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "from pos_decomp_subset finite_set"], ["proof (chain)\npicking this:\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps\n  finite (set ?xs)", "have \"finite (set (ps\\<^sub>+))\""], ["proof (prove)\nusing this:\n  set (?ps\\<^sub>+) \\<subseteq> set ?ps\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (set (ps\\<^sub>+))", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "hence \"finite ?A\""], ["proof (prove)\nusing this:\n  finite (set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set (ps\\<^sub>+))", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "from False"], ["proof (chain)\npicking this:\n  ps\\<^sub>+ \\<noteq> []", "have \"?A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "have \"\\<b> ps (Suc 0) = Suc (Max ?A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) = Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))", "unfolding \\<b>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST d.\n        \\<a> ps \\<le> d \\<and>\n        (\\<forall>(h, U)\\<in>set ps.\n            Suc 0 \\<le> card U \\<longrightarrow> poly_deg h < d)) =\n    Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "from \\<open>finite ?A\\<close> \\<open>?A \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}", "have \"\\<a> ps \\<in> ?A\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "unfolding aP"], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg ` fst ` set (ps\\<^sub>+) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min (poly_deg ` fst ` set (ps\\<^sub>+))\n    \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "by (rule Min_in)"], ["proof (state)\nthis:\n  \\<a> ps \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "with \\<open>finite ?A\\<close>"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  \\<a> ps \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "have \"\\<a> ps \\<le> Max ?A\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  \\<a> ps \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))", "by (rule Max_ge)"], ["proof (state)\nthis:\n  \\<a> ps \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "hence \"\\<a> ps \\<le> Suc (Max ?A)\""], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))", "by simp"], ["proof (state)\nthis:\n  \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "moreover"], ["proof (state)\nthis:\n  \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "{"], ["proof (state)\nthis:\n  \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "with fin_X assms(1)"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"finite U\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. finite U", "by (rule valid_decompD_finite)"], ["proof (state)\nthis:\n  finite U\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "moreover"], ["proof (state)\nthis:\n  finite U\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "assume \"Suc 0 \\<le> card U\""], ["proof (state)\nthis:\n  Suc 0 \\<le> card U\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  finite U\n  Suc 0 \\<le> card U", "have \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite U\n  Suc 0 \\<le> card U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "with \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}", "have \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "hence \"poly_deg (fst (h, U)) \\<in> ?A\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "by (intro imageI)"], ["proof (state)\nthis:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "hence \"poly_deg h \\<in> ?A\""], ["proof (prove)\nusing this:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "by (simp only: fst_conv)"], ["proof (state)\nthis:\n  poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "with \\<open>finite ?A\\<close>"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "have \"poly_deg h \\<le> Max ?A\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n  poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg h \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))", "by (rule Max_ge)"], ["proof (state)\nthis:\n  poly_deg h \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "hence \"poly_deg h < Suc (Max ?A)\""], ["proof (prove)\nusing this:\n  poly_deg h \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))", "by simp"], ["proof (state)\nthis:\n  poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?h25, ?U25) \\<in> set ps; Suc 0 \\<le> card ?U25\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?h25\n                    < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "ultimately"], ["proof (chain)\npicking this:\n  \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n  \\<lbrakk>(?h25, ?U25) \\<in> set ps; Suc 0 \\<le> card ?U25\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?h25\n                    < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))", "show \"\\<a> ps \\<le> Suc (Max ?A) \\<and> (\\<forall>(h, U)\\<in>set ps. Suc 0 \\<le> card U \\<longrightarrow> poly_deg h < Suc (Max ?A))\""], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n  \\<lbrakk>(?h25, ?U25) \\<in> set ps; Suc 0 \\<le> card ?U25\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?h25\n                    < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        Suc 0 \\<le> card U \\<longrightarrow>\n        poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "by blast"], ["proof (state)\nthis:\n  \\<a> ps \\<le> Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      Suc 0 \\<le> card U \\<longrightarrow>\n      poly_deg h < Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "assume \"\\<a> ps \\<le> d \\<and> (\\<forall>(h, U)\\<in>set ps. Suc 0 \\<le> card U \\<longrightarrow> poly_deg h < d)\""], ["proof (state)\nthis:\n  \\<a> ps \\<le> d \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      Suc 0 \\<le> card U \\<longrightarrow> poly_deg h < d)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "hence rl: \"poly_deg h < d\" if \"(h, U) \\<in> set ps\" and \"0 < card U\" for h U"], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> d \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      Suc 0 \\<le> card U \\<longrightarrow> poly_deg h < d)\n\ngoal (1 subgoal):\n 1. poly_deg h < d", "using that"], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> d \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      Suc 0 \\<le> card U \\<longrightarrow> poly_deg h < d)\n  (h, U) \\<in> set ps\n  0 < card U\n\ngoal (1 subgoal):\n 1. poly_deg h < d", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(?h23, ?U23) \\<in> set ps; 0 < card ?U23\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?h23 < d\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "have \"Max ?A < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set (ps\\<^sub>+)) < d", "unfolding Max_less_iff[OF \\<open>finite ?A\\<close> \\<open>?A \\<noteq> {}\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>poly_deg ` fst ` set (ps\\<^sub>+). a < d", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set (ps\\<^sub>+) \\<Longrightarrow> a < d", "fix d0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set (ps\\<^sub>+) \\<Longrightarrow> a < d", "assume \"d0 \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\""], ["proof (state)\nthis:\n  d0 \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set (ps\\<^sub>+) \\<Longrightarrow> a < d", "then"], ["proof (chain)\npicking this:\n  d0 \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "obtain h U where \"(h, U) \\<in> set (ps\\<^sub>+)\" and d0: \"d0 = poly_deg h\""], ["proof (prove)\nusing this:\n  d0 \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); d0 = poly_deg h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  d0 = poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set (ps\\<^sub>+) \\<Longrightarrow> a < d", "from this(1)"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"(h, U) \\<in> set ps\" and \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps &&& U \\<noteq> {}", "by (simp_all add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set (ps\\<^sub>+) \\<Longrightarrow> a < d", "from fin_X assms(1) this(1)"], ["proof (chain)\npicking this:\n  finite X\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"finite U\""], ["proof (prove)\nusing this:\n  finite X\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. finite U", "by (rule valid_decompD_finite)"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set (ps\\<^sub>+) \\<Longrightarrow> a < d", "with \\<open>U \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  U \\<noteq> {}\n  finite U", "have \"0 < card U\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n  finite U\n\ngoal (1 subgoal):\n 1. 0 < card U", "by (simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < card U\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set (ps\\<^sub>+) \\<Longrightarrow> a < d", "with \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  0 < card U", "show \"d0 < d\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  0 < card U\n\ngoal (1 subgoal):\n 1. d0 < d", "unfolding d0"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  0 < card U\n\ngoal (1 subgoal):\n 1. poly_deg h < d", "by (rule rl)"], ["proof (state)\nthis:\n  d0 < d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set (ps\\<^sub>+)) < d\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           Suc 0 \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> y", "thus \"Suc (Max ?A) \\<le> d\""], ["proof (prove)\nusing this:\n  Max (poly_deg ` fst ` set (ps\\<^sub>+)) < d\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> d", "by simp"], ["proof (state)\nthis:\n  Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) = Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> [] \\<Longrightarrow>\n    \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "with False"], ["proof (chain)\npicking this:\n  ps\\<^sub>+ \\<noteq> []\n  \\<b> ps (Suc 0) = Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ps\\<^sub>+ \\<noteq> []\n  \\<b> ps (Suc 0) = Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) =\n    (if ps\\<^sub>+ = [] then 0\n     else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))", "by simp"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) =\n  (if ps\\<^sub>+ = [] then 0\n   else Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+))))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \\<b>_one_gr:\n  assumes \"valid_decomp X ps\" and \"standard_decomp k ps\" and \"(h, U) \\<in> set (ps\\<^sub>+)\"\n  shows \"poly_deg h < \\<b> ps (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "from assms(3)"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"ps\\<^sub>+ \\<noteq> []\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []", "have eq: \"\\<b> ps (Suc 0) = Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  standard_decomp k ps\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc 0) = Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))", "by (simp add: \\<b>_one)"], ["proof (state)\nthis:\n  \\<b> ps (Suc 0) = Suc (Max (poly_deg ` fst ` set (ps\\<^sub>+)))\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "have \"poly_deg h \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))", "proof (rule Max_ge)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (poly_deg ` fst ` set (ps\\<^sub>+))\n 2. poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "show \"finite (poly_deg ` fst ` set (ps\\<^sub>+))\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set (ps\\<^sub>+))", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "from assms(3)"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "by (intro imageI)"], ["proof (state)\nthis:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "thus \"poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  poly_deg (fst (h, U)) \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)", "by simp"], ["proof (state)\nthis:\n  poly_deg h \\<in> poly_deg ` fst ` set (ps\\<^sub>+)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg h \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "also"], ["proof (state)\nthis:\n  poly_deg h \\<le> Max (poly_deg ` fst ` set (ps\\<^sub>+))\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "have \"\\<dots> < \\<b> ps (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set (ps\\<^sub>+)) < \\<b> ps (Suc 0)", "by (simp add: eq)"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set (ps\\<^sub>+)) < \\<b> ps (Suc 0)\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "finally"], ["proof (chain)\npicking this:\n  poly_deg h < \\<b> ps (Suc 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg h < \\<b> ps (Suc 0)\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc 0)", "."], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps (Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<b>_card_X:\n  assumes \"exact_decomp m ps\" and \"Suc (card X) \\<le> i\"\n  shows \"\\<b> ps i = \\<a> ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps i = \\<a> ps", "unfolding \\<b>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST d.\n        \\<a> ps \\<le> d \\<and>\n        (\\<forall>(h, U)\\<in>set ps.\n            i \\<le> card U \\<longrightarrow> poly_deg h < d)) =\n    \\<a> ps", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "assume \"(h, U) \\<in> set ps\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "with assms(1)"], ["proof (chain)\npicking this:\n  exact_decomp m ps\n  (h, U) \\<in> set ps", "have \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp m ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "note assms(2)"], ["proof (state)\nthis:\n  Suc (card X) \\<le> i\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "also"], ["proof (state)\nthis:\n  Suc (card X) \\<le> i\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "assume \"i \\<le> card U\""], ["proof (state)\nthis:\n  i \\<le> card U\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "finally"], ["proof (chain)\npicking this:\n  Suc (card X) \\<le> card U", "have \"card X < card U\""], ["proof (prove)\nusing this:\n  Suc (card X) \\<le> card U\n\ngoal (1 subgoal):\n 1. card X < card U", "by simp"], ["proof (state)\nthis:\n  card X < card U\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "with fin_X"], ["proof (chain)\npicking this:\n  finite X\n  card X < card U", "have \"\\<not> U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  finite X\n  card X < card U\n\ngoal (1 subgoal):\n 1. \\<not> U \\<subseteq> X", "by (auto dest: card_mono leD)"], ["proof (state)\nthis:\n  \\<not> U \\<subseteq> X\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "hence False"], ["proof (prove)\nusing this:\n  \\<not> U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. False", "using \\<open>U \\<subseteq> X\\<close>"], ["proof (prove)\nusing this:\n  \\<not> U \\<subseteq> X\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?h25, ?U25) \\<in> set ps; i \\<le> card ?U25\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n 2. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "thus \"\\<a> ps \\<le> \\<a> ps \\<and> (\\<forall>(h, U)\\<in>set ps. i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?h25, ?U25) \\<in> set ps; i \\<le> card ?U25\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> \\<a> ps \\<and>\n    (\\<forall>(h, U)\\<in>set ps.\n        i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)", "by blast"], ["proof (state)\nthis:\n  \\<a> ps \\<le> \\<a> ps \\<and>\n  (\\<forall>(h, U)\\<in>set ps.\n      i \\<le> card U \\<longrightarrow> poly_deg h < \\<a> ps)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<a> ps \\<le> y \\<and>\n       (\\<forall>(h, U)\\<in>set ps.\n           i \\<le> card U \\<longrightarrow>\n           poly_deg h < y) \\<Longrightarrow>\n       \\<a> ps \\<le> y", "qed simp"], ["", "lemma lem_6_1_1:\n  assumes \"standard_decomp k ps\" and \"exact_decomp m ps\" and \"Suc 0 \\<le> i\"\n    and \"i \\<le> card X\" and \"\\<b> ps (Suc i) \\<le> d\" and \"d < \\<b> ps i\"\n  obtains h U where \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"poly_deg h = d\" and \"card U = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"ps\\<^sub>+ \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps\\<^sub>+ \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "assume \"ps\\<^sub>+ = []\""], ["proof (state)\nthis:\n  ps\\<^sub>+ = []\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "hence \"\\<b> ps i = 0\""], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n\ngoal (1 subgoal):\n 1. \\<b> ps i = 0", "using assms(3)"], ["proof (prove)\nusing this:\n  ps\\<^sub>+ = []\n  Suc 0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<b> ps i = 0", "by (rule \\<b>_Nil)"], ["proof (state)\nthis:\n  \\<b> ps i = 0\n\ngoal (1 subgoal):\n 1. ps\\<^sub>+ = [] \\<Longrightarrow> False", "with assms(6)"], ["proof (chain)\npicking this:\n  d < \\<b> ps i\n  \\<b> ps i = 0", "show False"], ["proof (prove)\nusing this:\n  d < \\<b> ps i\n  \\<b> ps i = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps\\<^sub>+ \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have eq1: \"\\<b> ps (Suc (card X)) = \\<a> ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) = \\<a> ps", "using assms(2) le_refl"], ["proof (prove)\nusing this:\n  exact_decomp m ps\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) = \\<a> ps", "by (rule \\<b>_card_X)"], ["proof (state)\nthis:\n  \\<b> ps (Suc (card X)) = \\<a> ps\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(1)"], ["proof (chain)\npicking this:\n  standard_decomp k ps", "have std: \"standard_decomp (\\<b> ps (Suc (card X))) ps\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n\ngoal (1 subgoal):\n 1. standard_decomp (\\<b> ps (Suc (card X))) ps", "unfolding eq1"], ["proof (prove)\nusing this:\n  standard_decomp k ps\n\ngoal (1 subgoal):\n 1. standard_decomp (\\<a> ps) ps", "by (rule \\<a>)"], ["proof (state)\nthis:\n  standard_decomp (\\<b> ps (Suc (card X))) ps\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(4)"], ["proof (chain)\npicking this:\n  i \\<le> card X", "have \"Suc i \\<le> Suc (card X)\""], ["proof (prove)\nusing this:\n  i \\<le> card X\n\ngoal (1 subgoal):\n 1. Suc i \\<le> Suc (card X)", ".."], ["proof (state)\nthis:\n  Suc i \\<le> Suc (card X)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<b> ps (Suc (card X)) \\<le> \\<b> ps (Suc i)\""], ["proof (prove)\nusing this:\n  Suc i \\<le> Suc (card X)\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> \\<b> ps (Suc i)", "by (rule \\<b>_decreasing)"], ["proof (state)\nthis:\n  \\<b> ps (Suc (card X)) \\<le> \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<a> ps \\<le> \\<b> ps (Suc i)\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc (card X)) \\<le> \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> \\<b> ps (Suc i)", "by (simp only: eq1)"], ["proof (state)\nthis:\n  \\<a> ps \\<le> \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>h U. (h, U) \\<in> set ps \\<and> i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "assume *: \"\\<nexists>h U. (h, U) \\<in> set ps \\<and> i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)\""], ["proof (state)\nthis:\n  \\<nexists>h U.\n     (h, U) \\<in> set ps \\<and>\n     i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "note \\<open>\\<a> ps \\<le> \\<b> ps (Suc i)\\<close>"], ["proof (state)\nthis:\n  \\<a> ps \\<le> \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  \\<a> ps \\<le> \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "from assms(5, 6)"], ["proof (chain)\npicking this:\n  \\<b> ps (Suc i) \\<le> d\n  d < \\<b> ps i", "have \"\\<b> ps (Suc i) < \\<b> ps i\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc i) \\<le> d\n  d < \\<b> ps i\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc i) < \\<b> ps i", "by (rule le_less_trans)"], ["proof (state)\nthis:\n  \\<b> ps (Suc i) < \\<b> ps i\n\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  \\<a> ps < \\<b> ps i", "have \"\\<a> ps < \\<b> ps i\""], ["proof (prove)\nusing this:\n  \\<a> ps < \\<b> ps i\n\ngoal (1 subgoal):\n 1. \\<a> ps < \\<b> ps i", "."], ["proof (state)\nthis:\n  \\<a> ps < \\<b> ps i\n\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "hence \"\\<a> ps \\<le> \\<b> ps i - 1\""], ["proof (prove)\nusing this:\n  \\<a> ps < \\<b> ps i\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> \\<b> ps i - 1", "by simp"], ["proof (state)\nthis:\n  \\<a> ps \\<le> \\<b> ps i - 1\n\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "hence \"\\<b> ps i \\<le> \\<b> ps i - 1\""], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> \\<b> ps i - 1\n\ngoal (1 subgoal):\n 1. \\<b> ps i \\<le> \\<b> ps i - 1", "proof (rule \\<b>_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; i \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i - 1", "fix h U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; i \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i - 1", "assume \"(h, U) \\<in> set ps\" and \"i \\<le> card U\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n  i \\<le> card U\n\ngoal (1 subgoal):\n 1. \\<And>h' U'.\n       \\<lbrakk>(h', U') \\<in> set ps; i \\<le> card U'\\<rbrakk>\n       \\<Longrightarrow> poly_deg h' < \\<b> ps i - 1", "show \"poly_deg h < \\<b> ps i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps i - 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps i - 1 \\<Longrightarrow> False", "assume \"\\<not> poly_deg h < \\<b> ps i - 1\""], ["proof (state)\nthis:\n  \\<not> poly_deg h < \\<b> ps i - 1\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps i - 1 \\<Longrightarrow> False", "hence \"\\<b> ps i \\<le> Suc (poly_deg h)\""], ["proof (prove)\nusing this:\n  \\<not> poly_deg h < \\<b> ps i - 1\n\ngoal (1 subgoal):\n 1. \\<b> ps i \\<le> Suc (poly_deg h)", "by simp"], ["proof (state)\nthis:\n  \\<b> ps i \\<le> Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps i - 1 \\<Longrightarrow> False", "with * \\<open>(h, U) \\<in> set ps\\<close> \\<open>i \\<le> card U\\<close>"], ["proof (chain)\npicking this:\n  \\<nexists>h U.\n     (h, U) \\<in> set ps \\<and>\n     i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)\n  (h, U) \\<in> set ps\n  i \\<le> card U\n  \\<b> ps i \\<le> Suc (poly_deg h)", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>h U.\n     (h, U) \\<in> set ps \\<and>\n     i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)\n  (h, U) \\<in> set ps\n  i \\<le> card U\n  \\<b> ps i \\<le> Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps i - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<b> ps i \\<le> \\<b> ps i - 1\n\ngoal (1 subgoal):\n 1. \\<nexists>h U.\n       (h, U) \\<in> set ps \\<and>\n       i \\<le> card U \\<and>\n       \\<b> ps i \\<le> Suc (poly_deg h) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<b> ps i \\<le> \\<b> ps i - 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<a> ps < \\<b> ps i\\<close>"], ["proof (prove)\nusing this:\n  \\<b> ps i \\<le> \\<b> ps i - 1\n  \\<a> ps < \\<b> ps i\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>h U.\n     (h, U) \\<in> set ps \\<and>\n     i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>h U.\n     (h, U) \\<in> set ps \\<and>\n     i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)", "obtain h U where \"(h, U) \\<in> set ps\" and \"i \\<le> card U\" and \"\\<b> ps i \\<le> Suc (poly_deg h)\""], ["proof (prove)\nusing this:\n  \\<exists>h U.\n     (h, U) \\<in> set ps \\<and>\n     i \\<le> card U \\<and> \\<b> ps i \\<le> Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set ps; i \\<le> card U;\n         \\<b> ps i \\<le> Suc (poly_deg h)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n  i \\<le> card U\n  \\<b> ps i \\<le> Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms(3) this(2)"], ["proof (chain)\npicking this:\n  Suc 0 \\<le> i\n  i \\<le> card U", "have \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Suc 0 \\<le> i\n  i \\<le> card U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>(h, U) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}", "have \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note std this"], ["proof (state)\nthis:\n  standard_decomp (\\<b> ps (Suc (card X))) ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  standard_decomp (\\<b> ps (Suc (card X))) ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<b> ps (Suc (card X)) \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> d", "unfolding eq1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> d", "using \\<open>\\<a> ps \\<le> \\<b> ps (Suc i)\\<close> assms(5)"], ["proof (prove)\nusing this:\n  \\<a> ps \\<le> \\<b> ps (Suc i)\n  \\<b> ps (Suc i) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> d", "by (rule le_trans)"], ["proof (state)\nthis:\n  \\<b> ps (Suc (card X)) \\<le> d\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<b> ps (Suc (card X)) \\<le> d\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"d \\<le> poly_deg h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> poly_deg h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<le> poly_deg h", "from assms(6) \\<open>\\<b> ps i \\<le> Suc (poly_deg h)\\<close>"], ["proof (chain)\npicking this:\n  d < \\<b> ps i\n  \\<b> ps i \\<le> Suc (poly_deg h)", "have \"d < Suc (poly_deg h)\""], ["proof (prove)\nusing this:\n  d < \\<b> ps i\n  \\<b> ps i \\<le> Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. d < Suc (poly_deg h)", "by (rule less_le_trans)"], ["proof (state)\nthis:\n  d < Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg h", "thus ?thesis"], ["proof (prove)\nusing this:\n  d < Suc (poly_deg h)\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg h", "by simp"], ["proof (state)\nthis:\n  d \\<le> poly_deg h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  standard_decomp (\\<b> ps (Suc (card X))) ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  \\<b> ps (Suc (card X)) \\<le> d\n  d \\<le> poly_deg h", "obtain h' U' where \"(h', U') \\<in> set ps\" and d: \"poly_deg h' = d\" and \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp (\\<b> ps (Suc (card X))) ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  \\<b> ps (Suc (card X)) \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>i \\<le> card U\\<close> this(3)"], ["proof (chain)\npicking this:\n  i \\<le> card U\n  card U \\<le> card U'", "have \"i \\<le> card U'\""], ["proof (prove)\nusing this:\n  i \\<le> card U\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. i \\<le> card U'", "by (rule le_trans)"], ["proof (state)\nthis:\n  i \\<le> card U'\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms(3)"], ["proof (chain)\npicking this:\n  Suc 0 \\<le> i\n  i \\<le> card U'", "have \"U' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Suc 0 \\<le> i\n  i \\<le> card U'\n\ngoal (1 subgoal):\n 1. U' \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<open>(h', U') \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps\n  U' \\<noteq> {}", "have \"(h', U') \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n  U' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h', U') \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (h', U') \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note \\<open>poly_deg h' = d\\<close>"], ["proof (state)\nthis:\n  poly_deg h' = d\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  poly_deg h' = d\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"card U' = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card U' = i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. card U' \\<noteq> i \\<Longrightarrow> False", "assume \"card U' \\<noteq> i\""], ["proof (state)\nthis:\n  card U' \\<noteq> i\n\ngoal (1 subgoal):\n 1. card U' \\<noteq> i \\<Longrightarrow> False", "with \\<open>i \\<le> card U'\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> card U'\n  card U' \\<noteq> i", "have \"Suc i \\<le> card U'\""], ["proof (prove)\nusing this:\n  i \\<le> card U'\n  card U' \\<noteq> i\n\ngoal (1 subgoal):\n 1. Suc i \\<le> card U'", "by simp"], ["proof (state)\nthis:\n  Suc i \\<le> card U'\n\ngoal (1 subgoal):\n 1. card U' \\<noteq> i \\<Longrightarrow> False", "with \\<open>(h', U') \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps\n  Suc i \\<le> card U'", "have \"poly_deg h' < \\<b> ps (Suc i)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n  Suc i \\<le> card U'\n\ngoal (1 subgoal):\n 1. poly_deg h' < \\<b> ps (Suc i)", "by (rule \\<b>)"], ["proof (state)\nthis:\n  poly_deg h' < \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. card U' \\<noteq> i \\<Longrightarrow> False", "with assms(5)"], ["proof (chain)\npicking this:\n  \\<b> ps (Suc i) \\<le> d\n  poly_deg h' < \\<b> ps (Suc i)", "show False"], ["proof (prove)\nusing this:\n  \\<b> ps (Suc i) \\<le> d\n  poly_deg h' < \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. False", "by (simp add: d)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card U' = i\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set (ps\\<^sub>+)\n  poly_deg h' = d\n  card U' = i", "show ?thesis"], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (ps\\<^sub>+)\n  poly_deg h' = d\n  card U' = i\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lem_6_1_2:\n  assumes \"standard_decomp k ps\" and \"exact_decomp 0 ps\" and \"Suc 0 \\<le> i\"\n    and \"i \\<le> card X\" and \"\\<b> ps (Suc i) \\<le> d\" and \"d < \\<b> ps i\"\n  obtains h U where \"{(h', U') \\<in> set (ps\\<^sub>+). poly_deg h' = d} = {(h, U)}\" and \"card U = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  exact_decomp 0 ps\n  Suc 0 \\<le> i\n  i \\<le> card X\n  \\<b> ps (Suc i) \\<le> d\n  d < \\<b> ps i", "obtain h U where \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"poly_deg h = d\" and \"card U = i\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  exact_decomp 0 ps\n  Suc 0 \\<le> i\n  i \\<le> card X\n  \\<b> ps (Suc i) \\<le> d\n  d < \\<b> ps i\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>(h, U) \\<in> set (ps\\<^sub>+); poly_deg h = d;\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lem_6_1_1)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  poly_deg h = d\n  card U = i\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"{(h, U)} \\<subseteq> {(h', U') \\<in> set (ps\\<^sub>+). poly_deg h' = d}\" (is \"_ \\<subseteq> ?A\")"], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n  poly_deg h = d\n  card U = i\n\ngoal (1 subgoal):\n 1. {(h, U)}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}", "by simp"], ["proof (state)\nthis:\n  {(h, U)}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  {(h, U)}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"?A \\<subseteq> {(h, U)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n    \\<subseteq> {(h, U)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "assume \"x \\<in> ?A\""], ["proof (state)\nthis:\n  x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}", "obtain h' U' where \"(h', U') \\<in> set (ps\\<^sub>+)\" and \"poly_deg h' = d\" and x: \"x = (h', U')\""], ["proof (prove)\nusing this:\n  x \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set (ps\\<^sub>+); poly_deg h' = d;\n         x = (h', U')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (h', U') \\<in> set (ps\\<^sub>+)\n  poly_deg h' = d\n  x = (h', U')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "note assms(2) \\<open>(h, U) \\<in> set (ps\\<^sub>+)\\<close> this(1)"], ["proof (state)\nthis:\n  exact_decomp 0 ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  (h', U') \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "moreover"], ["proof (state)\nthis:\n  exact_decomp 0 ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  (h', U') \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "have \"poly_deg h = poly_deg h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h = poly_deg h'", "by (simp only: \\<open>poly_deg h = d\\<close> \\<open>poly_deg h' = d\\<close>)"], ["proof (state)\nthis:\n  poly_deg h = poly_deg h'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "ultimately"], ["proof (chain)\npicking this:\n  exact_decomp 0 ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  (h', U') \\<in> set (ps\\<^sub>+)\n  poly_deg h = poly_deg h'", "have \"(h, U) = (h', U')\""], ["proof (prove)\nusing this:\n  exact_decomp 0 ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  (h', U') \\<in> set (ps\\<^sub>+)\n  poly_deg h = poly_deg h'\n\ngoal (1 subgoal):\n 1. (h, U) = (h', U')", "by (rule exact_decompD_zero)"], ["proof (state)\nthis:\n  (h, U) = (h', U')\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y)\n       \\<in> {(h', U').\n              (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n              poly_deg h' = d} \\<Longrightarrow>\n       (x, y) \\<in> {(h, U)}", "thus \"x \\<in> {(h, U)}\""], ["proof (prove)\nusing this:\n  (h, U) = (h', U')\n\ngoal (1 subgoal):\n 1. x \\<in> {(h, U)}", "by (simp add: x)"], ["proof (state)\nthis:\n  x \\<in> {(h, U)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  \\<subseteq> {(h, U)}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  {(h, U)}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  \\<subseteq> {(h, U)}", "have \"{(h, U)} = ?A\""], ["proof (prove)\nusing this:\n  {(h, U)}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  \\<subseteq> {(h, U)}\n\ngoal (1 subgoal):\n 1. {(h, U)} =\n    {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}", ".."], ["proof (state)\nthis:\n  {(h, U)} =\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"?A = {(h, U)}\""], ["proof (prove)\nusing this:\n  {(h, U)} =\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n    {(h, U)}", "by (rule sym)"], ["proof (state)\nthis:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>card U = i\\<close>"], ["proof (prove)\nusing this:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}\n  card U = i\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lem_6_1_2':\n  assumes \"standard_decomp k ps\" and \"exact_decomp 0 ps\" and \"Suc 0 \\<le> i\"\n    and \"i \\<le> card X\" and \"\\<b> ps (Suc i) \\<le> d\" and \"d < \\<b> ps i\"\n  shows \"card {(h', U') \\<in> set (ps\\<^sub>+). poly_deg h' = d} = 1\" (is \"card ?A = _\")\n    and \"{(h', U') \\<in> set (ps\\<^sub>+). poly_deg h' = d \\<and> card U' = i} = {(h', U') \\<in> set (ps\\<^sub>+). poly_deg h' = d}\"\n            (is \"?B = _\")\n    and \"card {(h', U') \\<in> set (ps\\<^sub>+). poly_deg h' = d \\<and> card U' = i} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n    1 &&&\n    {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i} =\n    {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} &&&\n    card\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      poly_deg h' = d \\<and> card U' = i} =\n    1", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. card\n     {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n    1\n 2. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i} =\n    {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 3. card\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      poly_deg h' = d \\<and> card U' = i} =\n    1", "from assms"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  exact_decomp 0 ps\n  Suc 0 \\<le> i\n  i \\<le> card X\n  \\<b> ps (Suc i) \\<le> d\n  d < \\<b> ps i", "obtain h U where \"?A = {(h, U)}\" and \"card U = i\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  exact_decomp 0 ps\n  Suc 0 \\<le> i\n  i \\<le> card X\n  \\<b> ps (Suc i) \\<le> d\n  d < \\<b> ps i\n\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n                 {(h, U)};\n         card U = i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lem_6_1_2)"], ["proof (state)\nthis:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}\n  card U = i\n\ngoal (3 subgoals):\n 1. card\n     {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n    1\n 2. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i} =\n    {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 3. card\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      poly_deg h' = d \\<and> card U' = i} =\n    1", "from this(1)"], ["proof (chain)\npicking this:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}", "show \"card ?A = 1\""], ["proof (prove)\nusing this:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}\n\ngoal (1 subgoal):\n 1. card\n     {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n    1", "by simp"], ["proof (state)\nthis:\n  card {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  1\n\ngoal (2 subgoals):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i} =\n    {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 2. card\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      poly_deg h' = d \\<and> card U' = i} =\n    1", "moreover"], ["proof (state)\nthis:\n  card {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  1\n\ngoal (2 subgoals):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i} =\n    {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 2. card\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      poly_deg h' = d \\<and> card U' = i} =\n    1", "show \"?B = ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i} =\n    {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 2. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d \\<and> card U' = i}", "have \"(h, U) \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, U)\n    \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}", "by (simp add: \\<open>?A = {(h, U)}\\<close>)"], ["proof (state)\nthis:\n  (h, U)\n  \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (2 subgoals):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 2. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d \\<and> card U' = i}", "have \"?A = {(h, U)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n    {(h, U)}", "by fact"], ["proof (state)\nthis:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}\n\ngoal (2 subgoals):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 2. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d \\<and> card U' = i}", "also"], ["proof (state)\nthis:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  {(h, U)}\n\ngoal (2 subgoals):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 2. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d \\<and> card U' = i}", "from \\<open>(h, U) \\<in> ?A\\<close> \\<open>card U = i\\<close>"], ["proof (chain)\npicking this:\n  (h, U)\n  \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  card U = i", "have \"\\<dots> \\<subseteq> ?B\""], ["proof (prove)\nusing this:\n  (h, U)\n  \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  card U = i\n\ngoal (1 subgoal):\n 1. {(h, U)}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d \\<and> card U' = i}", "by simp"], ["proof (state)\nthis:\n  {(h, U)}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d \\<and> card U' = i}\n\ngoal (2 subgoals):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n 2. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d \\<and> card U' = i}", "finally"], ["proof (chain)\npicking this:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d \\<and> card U' = i}", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\nusing this:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d \\<and> card U' = i}\n\ngoal (1 subgoal):\n 1. {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                 poly_deg h' = d \\<and> card U' = i}", "."], ["proof (state)\nthis:\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n  \\<subseteq> {(h', U').\n               (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n               poly_deg h' = d \\<and> card U' = i}\n\ngoal (1 subgoal):\n 1. {(h', U').\n     (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n     poly_deg h' = d \\<and> card U' = i}\n    \\<subseteq> {(h', U').\n                 (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}", "qed blast"], ["proof (state)\nthis:\n  {(h', U').\n   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n   poly_deg h' = d \\<and> card U' = i} =\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. card\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      poly_deg h' = d \\<and> card U' = i} =\n    1", "ultimately"], ["proof (chain)\npicking this:\n  card {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  1\n  {(h', U').\n   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n   poly_deg h' = d \\<and> card U' = i} =\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}", "show \"card ?B = 1\""], ["proof (prove)\nusing this:\n  card {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d} =\n  1\n  {(h', U').\n   (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n   poly_deg h' = d \\<and> card U' = i} =\n  {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = d}\n\ngoal (1 subgoal):\n 1. card\n     {(h', U').\n      (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n      poly_deg h' = d \\<and> card U' = i} =\n    1", "by simp"], ["proof (state)\nthis:\n  card\n   {(h', U').\n    (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n    poly_deg h' = d \\<and> card U' = i} =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lem_6_1_3:\n  assumes \"standard_decomp k ps\" and \"exact_decomp 0 ps\" and \"Suc 0 \\<le> i\"\n    and \"i \\<le> card X\" and \"(h, U) \\<in> set (ps\\<^sub>+)\" and \"card U = i\"\n  shows \"\\<b> ps (Suc i) \\<le> poly_deg h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps (Suc i) \\<le> poly_deg h", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "define j where \"j = (LEAST j'. \\<b> ps j' \\<le> poly_deg h)\""], ["proof (state)\nthis:\n  j = (LEAST j'. \\<b> ps j' \\<le> poly_deg h)\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "assume \"\\<not> \\<b> ps (Suc i) \\<le> poly_deg h\""], ["proof (state)\nthis:\n  \\<not> \\<b> ps (Suc i) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence \"poly_deg h < \\<b> ps (Suc i)\""], ["proof (prove)\nusing this:\n  \\<not> \\<b> ps (Suc i) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (Suc i)", "by simp"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "from assms(2) le_refl"], ["proof (chain)\npicking this:\n  exact_decomp 0 ps\n  ?n \\<le> ?n", "have \"\\<b> ps (Suc (card X)) = \\<a> ps\""], ["proof (prove)\nusing this:\n  exact_decomp 0 ps\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) = \\<a> ps", "by (rule \\<b>_card_X)"], ["proof (state)\nthis:\n  \\<b> ps (Suc (card X)) = \\<a> ps\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<b> ps (Suc (card X)) = \\<a> ps\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "from _ assms(5)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"\\<dots> \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<a> ps \\<le> poly_deg h", "proof (rule standard_decompD)"], ["proof (state)\ngoal (1 subgoal):\n 1. standard_decomp (\\<a> ps) ps", "from assms(1)"], ["proof (chain)\npicking this:\n  standard_decomp k ps", "show \"standard_decomp (\\<a> ps) ps\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n\ngoal (1 subgoal):\n 1. standard_decomp (\\<a> ps) ps", "by (rule \\<a>)"], ["proof (state)\nthis:\n  standard_decomp (\\<a> ps) ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<a> ps \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<b> ps (Suc (card X)) \\<le> poly_deg h", "have \"\\<b> ps (Suc (card X)) \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc (card X)) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (card X)) \\<le> poly_deg h", "."], ["proof (state)\nthis:\n  \\<b> ps (Suc (card X)) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence 1: \"\\<b> ps j \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  \\<b> ps (Suc (card X)) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<b> ps j \\<le> poly_deg h", "unfolding j_def"], ["proof (prove)\nusing this:\n  \\<b> ps (Suc (card X)) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<b> ps (LEAST j'. \\<b> ps j' \\<le> poly_deg h) \\<le> poly_deg h", "by (rule LeastI)"], ["proof (state)\nthis:\n  \\<b> ps j \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "have \"Suc i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i < j", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc i < j \\<Longrightarrow> False", "assume \"\\<not> Suc i < j\""], ["proof (state)\nthis:\n  \\<not> Suc i < j\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < j \\<Longrightarrow> False", "hence \"j \\<le> Suc i\""], ["proof (prove)\nusing this:\n  \\<not> Suc i < j\n\ngoal (1 subgoal):\n 1. j \\<le> Suc i", "by simp"], ["proof (state)\nthis:\n  j \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < j \\<Longrightarrow> False", "hence \"\\<b> ps (Suc i) \\<le> \\<b> ps j\""], ["proof (prove)\nusing this:\n  j \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc i) \\<le> \\<b> ps j", "by (rule \\<b>_decreasing)"], ["proof (state)\nthis:\n  \\<b> ps (Suc i) \\<le> \\<b> ps j\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<b> ps (Suc i) \\<le> \\<b> ps j\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < j \\<Longrightarrow> False", "have \"\\<dots> \\<le> poly_deg h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<b> ps j \\<le> poly_deg h", "by fact"], ["proof (state)\nthis:\n  \\<b> ps j \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> Suc i < j \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<b> ps (Suc i) \\<le> poly_deg h", "show False"], ["proof (prove)\nusing this:\n  \\<b> ps (Suc i) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. False", "using \\<open>poly_deg h < \\<b> ps (Suc i)\\<close>"], ["proof (prove)\nusing this:\n  \\<b> ps (Suc i) \\<le> poly_deg h\n  poly_deg h < \\<b> ps (Suc i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence eq: \"Suc (j - 1) = j\""], ["proof (prove)\nusing this:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. Suc (j - 1) = j", "by simp"], ["proof (state)\nthis:\n  Suc (j - 1) = j\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "note assms(1, 2)"], ["proof (state)\nthis:\n  standard_decomp k ps\n  exact_decomp 0 ps\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  standard_decomp k ps\n  exact_decomp 0 ps\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "from assms(3)"], ["proof (chain)\npicking this:\n  Suc 0 \\<le> i", "have \"Suc 0 \\<le> j - 1\""], ["proof (prove)\nusing this:\n  Suc 0 \\<le> i\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> j - 1", "proof (rule le_trans)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> j - 1", "from \\<open>Suc i < j\\<close>"], ["proof (chain)\npicking this:\n  Suc i < j", "show \"i \\<le> j - 1\""], ["proof (prove)\nusing this:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. i \\<le> j - 1", "by simp"], ["proof (state)\nthis:\n  i \\<le> j - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc 0 \\<le> j - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Suc 0 \\<le> j - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "have \"j - 1 \\<le> card X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j - 1 \\<le> card X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j - 1 \\<le> card X", "have \"j \\<le> Suc (card X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> Suc (card X)", "unfolding j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST j'. \\<b> ps j' \\<le> poly_deg h) \\<le> Suc (card X)", "by (rule Least_le) fact"], ["proof (state)\nthis:\n  j \\<le> Suc (card X)\n\ngoal (1 subgoal):\n 1. j - 1 \\<le> card X", "thus ?thesis"], ["proof (prove)\nusing this:\n  j \\<le> Suc (card X)\n\ngoal (1 subgoal):\n 1. j - 1 \\<le> card X", "by simp"], ["proof (state)\nthis:\n  j - 1 \\<le> card X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j - 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j - 1 \\<le> card X\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "from 1"], ["proof (chain)\npicking this:\n  \\<b> ps j \\<le> poly_deg h", "have \"\\<b> ps (Suc (j - 1)) \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  \\<b> ps j \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<b> ps (Suc (j - 1)) \\<le> poly_deg h", "by (simp only: eq)"], ["proof (state)\nthis:\n  \\<b> ps (Suc (j - 1)) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<b> ps (Suc (j - 1)) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "have \"poly_deg h < \\<b> ps (j - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h < \\<b> ps (j - 1)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps (j - 1) \\<Longrightarrow> False", "assume \"\\<not> poly_deg h < \\<b> ps (j - 1)\""], ["proof (state)\nthis:\n  \\<not> poly_deg h < \\<b> ps (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps (j - 1) \\<Longrightarrow> False", "hence \"\\<b> ps (j - 1) \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  \\<not> poly_deg h < \\<b> ps (j - 1)\n\ngoal (1 subgoal):\n 1. \\<b> ps (j - 1) \\<le> poly_deg h", "by simp"], ["proof (state)\nthis:\n  \\<b> ps (j - 1) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps (j - 1) \\<Longrightarrow> False", "hence \"j \\<le> j - 1\""], ["proof (prove)\nusing this:\n  \\<b> ps (j - 1) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. j \\<le> j - 1", "unfolding j_def"], ["proof (prove)\nusing this:\n  \\<b> ps ((LEAST j'. \\<b> ps j' \\<le> poly_deg h) - 1) \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (LEAST j'. \\<b> ps j' \\<le> poly_deg h)\n    \\<le> (LEAST j'. \\<b> ps j' \\<le> poly_deg h) - 1", "by (rule Least_le)"], ["proof (state)\nthis:\n  j \\<le> j - 1\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps (j - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  j \\<le> j - 1\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps (j - 1) \\<Longrightarrow> False", "have \"\\<dots> < Suc (j - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j - 1 < Suc (j - 1)", "by simp"], ["proof (state)\nthis:\n  j - 1 < Suc (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> poly_deg h < \\<b> ps (j - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  j < Suc (j - 1)", "show False"], ["proof (prove)\nusing this:\n  j < Suc (j - 1)\n\ngoal (1 subgoal):\n 1. False", "by (simp only: eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg h < \\<b> ps (j - 1)\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  exact_decomp 0 ps\n  Suc 0 \\<le> j - 1\n  j - 1 \\<le> card X\n  \\<b> ps (Suc (j - 1)) \\<le> poly_deg h\n  poly_deg h < \\<b> ps (j - 1)", "obtain h0 U0\n    where eq1: \"{(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = poly_deg h} = {(h0, U0)}\"\n    and \"card U0 = j - 1\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  exact_decomp 0 ps\n  Suc 0 \\<le> j - 1\n  j - 1 \\<le> card X\n  \\<b> ps (Suc (j - 1)) \\<le> poly_deg h\n  poly_deg h < \\<b> ps (j - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>h0 U0.\n        \\<lbrakk>{(h', U').\n                  (h', U') \\<in> set (ps\\<^sub>+) \\<and>\n                  poly_deg h' = poly_deg h} =\n                 {(h0, U0)};\n         card U0 = j - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lem_6_1_2)"], ["proof (state)\nthis:\n  {(h', U').\n   (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = poly_deg h} =\n  {(h0, U0)}\n  card U0 = j - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "from assms(5)"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set (ps\\<^sub>+)", "have \"(h, U) \\<in> {(h', U'). (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = poly_deg h}\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U)\n    \\<in> {(h', U').\n           (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = poly_deg h}", "by simp"], ["proof (state)\nthis:\n  (h, U)\n  \\<in> {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = poly_deg h}\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence \"(h, U) \\<in> {(h0, U0)}\""], ["proof (prove)\nusing this:\n  (h, U)\n  \\<in> {(h', U').\n         (h', U') \\<in> set (ps\\<^sub>+) \\<and> poly_deg h' = poly_deg h}\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> {(h0, U0)}", "by (simp only: eq1)"], ["proof (state)\nthis:\n  (h, U) \\<in> {(h0, U0)}\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence \"U = U0\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> {(h0, U0)}\n\ngoal (1 subgoal):\n 1. U = U0", "by simp"], ["proof (state)\nthis:\n  U = U0\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence \"card U = j - 1\""], ["proof (prove)\nusing this:\n  U = U0\n\ngoal (1 subgoal):\n 1. card U = j - 1", "by (simp only: \\<open>card U0 = j - 1\\<close>)"], ["proof (state)\nthis:\n  card U = j - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence \"i = j - 1\""], ["proof (prove)\nusing this:\n  card U = j - 1\n\ngoal (1 subgoal):\n 1. i = j - 1", "by (simp only: assms(6))"], ["proof (state)\nthis:\n  i = j - 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "hence \"Suc i = j\""], ["proof (prove)\nusing this:\n  i = j - 1\n\ngoal (1 subgoal):\n 1. Suc i = j", "by (simp only: eq)"], ["proof (state)\nthis:\n  Suc i = j\n\ngoal (1 subgoal):\n 1. \\<not> \\<b> ps (Suc i) \\<le> poly_deg h \\<Longrightarrow> False", "with \\<open>Suc i < j\\<close>"], ["proof (chain)\npicking this:\n  Suc i < j\n  Suc i = j", "show False"], ["proof (prove)\nusing this:\n  Suc i < j\n  Suc i = j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "qualified"], ["", "fun shift_list :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) \\<times> 'x set) \\<Rightarrow>\n                              'x \\<Rightarrow> _ list \\<Rightarrow> _ list\" where\n  \"shift_list (h, U) x ps =\n        ((punit.monom_mult 1 (Poly_Mapping.single x 1) h, U) # (h, U - {x}) # removeAll (h, U) ps)\""], ["", "declare shift_list.simps[simp del]"], ["", "lemma monomial_decomp_shift_list:\n  assumes \"monomial_decomp ps\" and \"hU \\<in> set ps\"\n  shows \"monomial_decomp (shift_list hU x ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "let ?x = \"Poly_Mapping.single x (1::nat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "with assms(2)"], ["proof (chain)\npicking this:\n  hU \\<in> set ps\n  hU = (h, U)", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  hU \\<in> set ps\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "with assms(1)"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps", "have 1: \"is_monomial h\" and 2: \"lcf h = 1\""], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. is_monomial h &&& lcf h = (1::'a)", "by (rule monomial_decompD)+"], ["proof (state)\nthis:\n  is_monomial h\n  lcf h = (1::'a)\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "from this(1)"], ["proof (chain)\npicking this:\n  is_monomial h", "have \"monomial (lcf h) (lpp h) = h\""], ["proof (prove)\nusing this:\n  is_monomial h\n\ngoal (1 subgoal):\n 1. monomial (lcf h) (lpp h) = h", "by (rule punit.monomial_eq_itself)"], ["proof (state)\nthis:\n  monomial (lcf h) (lpp h) = h\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "moreover"], ["proof (state)\nthis:\n  monomial (lcf h) (lpp h) = h\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "define t where \"t = lpp h\""], ["proof (state)\nthis:\n  t = lpp h\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "ultimately"], ["proof (chain)\npicking this:\n  monomial (lcf h) (lpp h) = h\n  t = lpp h", "have \"h = monomial 1 t\""], ["proof (prove)\nusing this:\n  monomial (lcf h) (lpp h) = h\n  t = lpp h\n\ngoal (1 subgoal):\n 1. h = monomial (1::'a) t", "by (simp only: 2)"], ["proof (state)\nthis:\n  h = monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "hence \"is_monomial (punit.monom_mult 1 ?x h)\" and \"lcf (punit.monom_mult 1 ?x h) = 1\""], ["proof (prove)\nusing this:\n  h = monomial (1::'a) t\n\ngoal (1 subgoal):\n 1. is_monomial (local.punit.monom_mult (1::'a) (monomial 1 x) h) &&&\n    lcf (local.punit.monom_mult (1::'a) (monomial 1 x) h) = (1::'a)", "by (simp_all add: punit.monom_mult_monomial monomial_is_monomial)"], ["proof (state)\nthis:\n  is_monomial (local.punit.monom_mult (1::'a) (monomial 1 x) h)\n  lcf (local.punit.monom_mult (1::'a) (monomial 1 x) h) = (1::'a)\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "with assms(1) 1 2"], ["proof (chain)\npicking this:\n  monomial_decomp ps\n  is_monomial h\n  lcf h = (1::'a)\n  is_monomial (local.punit.monom_mult (1::'a) (monomial 1 x) h)\n  lcf (local.punit.monom_mult (1::'a) (monomial 1 x) h) = (1::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  monomial_decomp ps\n  is_monomial h\n  lcf h = (1::'a)\n  is_monomial (local.punit.monom_mult (1::'a) (monomial 1 x) h)\n  lcf (local.punit.monom_mult (1::'a) (monomial 1 x) h) = (1::'a)\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list hU x ps)", "by (simp add: shift_list.simps monomial_decomp_def hU)"], ["proof (state)\nthis:\n  monomial_decomp (shift_list hU x ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_decomp_shift_list:\n  assumes \"hom_decomp ps\" and \"hU \\<in> set ps\"\n  shows \"hom_decomp (shift_list hU x ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "let ?x = \"Poly_Mapping.single x (1::nat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "obtain h U where hU: \"hU = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. hU = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "with assms(2)"], ["proof (chain)\npicking this:\n  hU \\<in> set ps\n  hU = (h, U)", "have \"(h, U) \\<in> set ps\""], ["proof (prove)\nusing this:\n  hU \\<in> set ps\n  hU = (h, U)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "with assms(1)"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  (h, U) \\<in> set ps", "have 1: \"homogeneous h\""], ["proof (prove)\nusing this:\n  hom_decomp ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. homogeneous h", "by (rule hom_decompD)"], ["proof (state)\nthis:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "hence \"homogeneous (punit.monom_mult 1 ?x h)\""], ["proof (prove)\nusing this:\n  homogeneous h\n\ngoal (1 subgoal):\n 1. homogeneous (local.punit.monom_mult (1::'a) (monomial 1 x) h)", "by (simp only: homogeneous_monom_mult)"], ["proof (state)\nthis:\n  homogeneous (local.punit.monom_mult (1::'a) (monomial 1 x) h)\n\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "with assms(1) 1"], ["proof (chain)\npicking this:\n  hom_decomp ps\n  homogeneous h\n  homogeneous (local.punit.monom_mult (1::'a) (monomial 1 x) h)", "show ?thesis"], ["proof (prove)\nusing this:\n  hom_decomp ps\n  homogeneous h\n  homogeneous (local.punit.monom_mult (1::'a) (monomial 1 x) h)\n\ngoal (1 subgoal):\n 1. hom_decomp (shift_list hU x ps)", "by (simp add: shift_list.simps hom_decomp_def hU)"], ["proof (state)\nthis:\n  hom_decomp (shift_list hU x ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_decomp_shift_list:\n  assumes \"valid_decomp X ps\" and \"(h, U) \\<in> set ps\" and \"x \\<in> U\"\n  shows \"valid_decomp X (shift_list (h, U) x ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "let ?x = \"Poly_Mapping.single x (1::nat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "from assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"h \\<in> P[X]\" and \"h \\<noteq> 0\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& h \\<noteq> 0 &&& U \\<subseteq> X", "by (rule valid_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "moreover"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> P[X]", "have \"punit.monom_mult 1 ?x h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) h \\<in> P[X]", "proof (intro Polys_closed_monom_mult PPs_closed_single)"], ["proof (state)\ngoal (2 subgoals):\n 1. h \\<in> P[X] \\<Longrightarrow> x \\<in> X\n 2. h \\<in> P[X] \\<Longrightarrow> h \\<in> P[X]", "from \\<open>x \\<in> U\\<close> \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<subseteq> X", "show \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", ".."], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] \\<Longrightarrow> h \\<in> P[X]", "qed"], ["proof (state)\nthis:\n  local.punit.monom_mult (1::'a) (monomial 1 x) h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "moreover"], ["proof (state)\nthis:\n  local.punit.monom_mult (1::'a) (monomial 1 x) h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "from \\<open>U \\<subseteq> X\\<close>"], ["proof (chain)\npicking this:\n  U \\<subseteq> X", "have \"U - {x} \\<subseteq> X\""], ["proof (prove)\nusing this:\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U - {x} \\<subseteq> X", "by blast"], ["proof (state)\nthis:\n  U - {x} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "ultimately"], ["proof (chain)\npicking this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  local.punit.monom_mult (1::'a) (monomial 1 x) h \\<in> P[X]\n  U - {x} \\<subseteq> X", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  local.punit.monom_mult (1::'a) (monomial 1 x) h \\<in> P[X]\n  U - {x} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "using assms(1) \\<open>h \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  h \\<in> P[X]\n  h \\<noteq> 0\n  U \\<subseteq> X\n  local.punit.monom_mult (1::'a) (monomial 1 x) h \\<in> P[X]\n  U - {x} \\<subseteq> X\n  valid_decomp X ps\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x ps)", "by (simp add: valid_decomp_def punit.monom_mult_eq_zero_iff shift_list.simps)"], ["proof (state)\nthis:\n  valid_decomp X (shift_list (h, U) x ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma standard_decomp_shift_list:\n  assumes \"standard_decomp k ps\" and \"(h1, U1) \\<in> set ps\" and \"(h2, U2) \\<in> set ps\"\n    and \"poly_deg h1 = poly_deg h2\" and \"card U2 \\<le> card U1\" and \"(h1, U1) \\<noteq> (h2, U2)\" and \"x \\<in> U2\"\n  shows \"standard_decomp k (shift_list (h2, U2) x ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. standard_decomp k (shift_list (h2, U2) x ps)", "proof (rule standard_decompI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "let ?p1 = \"(punit.monom_mult 1 (Poly_Mapping.single x 1) h2, U2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "let ?p2 = \"(h2, U2 - {x})\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "let ?qs = \"removeAll (h2, U2) ps\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix h U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "hence disj: \"(h, U) = ?p1 \\<or> ((h, U) = ?p2 \\<and> U2 - {x} \\<noteq> {}) \\<or> (h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<or>\n    (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<or>\n    (h, U) \\<in> set (ps\\<^sub>+)", "by (auto simp: pos_decomp_def shift_list.simps split: if_split_asm)"], ["proof (state)\nthis:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<or>\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<or>\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from assms(7)"], ["proof (chain)\npicking this:\n  x \\<in> U2", "have \"U2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  x \\<in> U2\n\ngoal (1 subgoal):\n 1. U2 \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  U2 \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with assms(3)"], ["proof (chain)\npicking this:\n  (h2, U2) \\<in> set ps\n  U2 \\<noteq> {}", "have \"(h2, U2) \\<in> set (ps\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h2, U2) \\<in> set ps\n  U2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h2, U2) \\<in> set (ps\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h2, U2) \\<in> set (ps\\<^sub>+)\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "with assms(1)"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h2, U2) \\<in> set (ps\\<^sub>+)", "have k_le: \"k \\<le> poly_deg h2\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h2, U2) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h2", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  k \\<le> poly_deg h2\n\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "let ?x = \"Poly_Mapping.single x 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h U.\n       (h, U)\n       \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+) \\<Longrightarrow>\n       k \\<le> poly_deg h\n 2. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from disj"], ["proof (chain)\npicking this:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<or>\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<or>\n  (h, U) \\<in> set (ps\\<^sub>+)", "show \"k \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<or>\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<or>\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. (h, U) =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 3. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "assume \"(h, U) = ?p1\""], ["proof (state)\nthis:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\n\ngoal (3 subgoals):\n 1. (h, U) =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 3. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "hence h: \"h = punit.monom_mult (1::'a) ?x h2\""], ["proof (prove)\nusing this:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\n\ngoal (1 subgoal):\n 1. h = local.punit.monom_mult (1::'a) (monomial 1 x) h2", "by simp"], ["proof (state)\nthis:\n  h = local.punit.monom_mult (1::'a) (monomial 1 x) h2\n\ngoal (3 subgoals):\n 1. (h, U) =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 3. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "note k_le"], ["proof (state)\nthis:\n  k \\<le> poly_deg h2\n\ngoal (3 subgoals):\n 1. (h, U) =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 3. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "also"], ["proof (state)\nthis:\n  k \\<le> poly_deg h2\n\ngoal (3 subgoals):\n 1. (h, U) =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 3. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "have \"poly_deg h2 \\<le> poly_deg h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg h2 \\<le> poly_deg h", "by (cases \"h2 = 0\") (simp_all add: h poly_deg_monom_mult)"], ["proof (state)\nthis:\n  poly_deg h2 \\<le> poly_deg h\n\ngoal (3 subgoals):\n 1. (h, U) =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 3. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "finally"], ["proof (chain)\npicking this:\n  k \\<le> poly_deg h", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "."], ["proof (state)\nthis:\n  k \\<le> poly_deg h\n\ngoal (2 subgoals):\n 1. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "assume \"(h, U) = ?p2 \\<and> U2 - {x} \\<noteq> {}\""], ["proof (state)\nthis:\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<Longrightarrow>\n    k \\<le> poly_deg h\n 2. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "with k_le"], ["proof (chain)\npicking this:\n  k \\<le> poly_deg h2\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> poly_deg h2\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "by simp"], ["proof (state)\nthis:\n  k \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "assume \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (ps\\<^sub>+) \\<Longrightarrow> k \\<le> poly_deg h", "with assms(1)"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)", "show ?thesis"], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  k \\<le> poly_deg h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "assume \"k \\<le> d\" and \"d \\<le> poly_deg h\""], ["proof (state)\nthis:\n  k \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "from disj"], ["proof (chain)\npicking this:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<or>\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<or>\n  (h, U) \\<in> set (ps\\<^sub>+)", "obtain h' U' where 1: \"(h', U') \\<in> set (?p1 # ps)\" and \"poly_deg h' = d\"\n    and \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) \\<or>\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {} \\<or>\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U')\n                 \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x)\n                              h2,\n                             U2) #\n                            ps);\n         poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) =\n     (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"(h, U) = ?p1\""], ["proof (state)\nthis:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) =\n     (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence h: \"h = punit.monom_mult 1 ?x h2\" and \"U = U2\""], ["proof (prove)\nusing this:\n  (h, U) = (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\n\ngoal (1 subgoal):\n 1. h = local.punit.monom_mult (1::'a) (monomial 1 x) h2 &&& U = U2", "by simp_all"], ["proof (state)\nthis:\n  h = local.punit.monom_mult (1::'a) (monomial 1 x) h2\n  U = U2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) =\n     (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>d \\<le> poly_deg h\\<close>"], ["proof (chain)\npicking this:\n  d \\<le> poly_deg h", "have \"d \\<le> poly_deg h2 \\<or> poly_deg h = d\""], ["proof (prove)\nusing this:\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg h2 \\<or> poly_deg h = d", "by (cases \"h2 = 0\") (auto simp: h poly_deg_monom_mult deg_pm_single)"], ["proof (state)\nthis:\n  d \\<le> poly_deg h2 \\<or> poly_deg h = d\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) =\n     (local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  d \\<le> poly_deg h2 \\<or> poly_deg h = d\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "assume \"d \\<le> poly_deg h2\""], ["proof (state)\nthis:\n  d \\<le> poly_deg h2\n\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "with assms(1) \\<open>(h2, U2) \\<in> set (ps\\<^sub>+)\\<close> \\<open>k \\<le> d\\<close>"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h2, U2) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h2", "obtain h' U'\n        where \"(h', U') \\<in> set ps\" and \"poly_deg h' = d\" and \"card U2 \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h2, U2) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h2\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U2 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  poly_deg h' = d\n  card U2 \\<le> card U'\n\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "from this(1)"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps", "have \"(h', U') \\<in> set (?p1 # ps)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n\ngoal (1 subgoal):\n 1. (h', U')\n    \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)", "by simp"], ["proof (state)\nthis:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "note \\<open>poly_deg h' = d\\<close>"], ["proof (state)\nthis:\n  poly_deg h' = d\n\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  poly_deg h' = d\n\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "from \\<open>card U2 \\<le> card U'\\<close>"], ["proof (chain)\npicking this:\n  card U2 \\<le> card U'", "have \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  card U2 \\<le> card U'\n\ngoal (1 subgoal):\n 1. card U \\<le> card U'", "by (simp only: \\<open>U = U2\\<close>)"], ["proof (state)\nthis:\n  card U \\<le> card U'\n\ngoal (2 subgoals):\n 1. d \\<le> poly_deg h2 \\<Longrightarrow> thesis\n 2. poly_deg h = d \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h' = d\n  card U \\<le> card U'", "show ?thesis"], ["proof (prove)\nusing this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. poly_deg h = d \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg h = d \\<Longrightarrow> thesis", "have \"(h, U) \\<in> set (?p1 # ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, U)\n    \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)", "by (simp add: \\<open>(h, U) = ?p1\\<close>)"], ["proof (state)\nthis:\n  (h, U)\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (1 subgoal):\n 1. poly_deg h = d \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (h, U)\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (1 subgoal):\n 1. poly_deg h = d \\<Longrightarrow> thesis", "assume \"poly_deg h = d\""], ["proof (state)\nthis:\n  poly_deg h = d\n\ngoal (1 subgoal):\n 1. poly_deg h = d \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  (h, U)\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h = d", "show ?thesis"], ["proof (prove)\nusing this:\n  (h, U)\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h = d\n\ngoal (1 subgoal):\n 1. thesis", "using le_refl"], ["proof (prove)\nusing this:\n  (h, U)\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h = d\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"(h, U) = ?p2 \\<and> U2 - {x} \\<noteq> {}\""], ["proof (state)\nthis:\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"h = h2\" and U: \"U = U2 - {x}\""], ["proof (prove)\nusing this:\n  (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. h = h2 &&& U = U2 - {x}", "by simp_all"], ["proof (state)\nthis:\n  h = h2\n  U = U2 - {x}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>d \\<le> poly_deg h\\<close> this(1)"], ["proof (chain)\npicking this:\n  d \\<le> poly_deg h\n  h = h2", "have \"d \\<le> poly_deg h2\""], ["proof (prove)\nusing this:\n  d \\<le> poly_deg h\n  h = h2\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg h2", "by simp"], ["proof (state)\nthis:\n  d \\<le> poly_deg h2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms(1) \\<open>(h2, U2) \\<in> set (ps\\<^sub>+)\\<close> \\<open>k \\<le> d\\<close>"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h2, U2) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h2", "obtain h' U'\n      where \"(h', U') \\<in> set ps\" and \"poly_deg h' = d\" and \"card U2 \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h2, U2) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h2\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U2 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  poly_deg h' = d\n  card U2 \\<le> card U'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from this(1)"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps", "have \"(h', U') \\<in> set (?p1 # ps)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n\ngoal (1 subgoal):\n 1. (h', U')\n    \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)", "by simp"], ["proof (state)\nthis:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "note \\<open>poly_deg h' = d\\<close>"], ["proof (state)\nthis:\n  poly_deg h' = d\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  poly_deg h' = d\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from _ \\<open>card U2 \\<le> card U'\\<close>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  card U2 \\<le> card U'", "have \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  card U2 \\<le> card U'\n\ngoal (1 subgoal):\n 1. card U \\<le> card U'", "unfolding U"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  card U2 \\<le> card U'\n\ngoal (1 subgoal):\n 1. card (U2 - {x}) \\<le> card U'", "by (rule le_trans) (metis Diff_empty card_Diff1_le card.infinite finite_Diff_insert order_refl)"], ["proof (state)\nthis:\n  card U \\<le> card U'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) = (h2, U2 - {x}) \\<and> U2 - {x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h' = d\n  card U \\<le> card U'", "show ?thesis"], ["proof (prove)\nusing this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"(h, U) \\<in> set (ps\\<^sub>+)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (ps\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from assms(1) this \\<open>k \\<le> d\\<close> \\<open>d \\<le> poly_deg h\\<close>"], ["proof (chain)\npicking this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h", "obtain h' U'\n      where \"(h', U') \\<in> set ps\" and \"poly_deg h' = d\" and \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp k ps\n  (h, U) \\<in> set (ps\\<^sub>+)\n  k \\<le> d\n  d \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set ps; poly_deg h' = d;\n         card U \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set ps\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from this(1)"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set ps", "have \"(h', U') \\<in> set (?p1 # ps)\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set ps\n\ngoal (1 subgoal):\n 1. (h', U')\n    \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)", "by simp"], ["proof (state)\nthis:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h' U'.\n                \\<lbrakk>(h', U')\n                         \\<in> set ((local.punit.monom_mult (1::'a)\n(monomial 1 x) h2,\n                                     U2) #\n                                    ps);\n                 poly_deg h' = d; card U \\<le> card U'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (h, U) \\<in> set (ps\\<^sub>+)\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>poly_deg h' = d\\<close> \\<open>card U \\<le> card U'\\<close>"], ["proof (prove)\nusing this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>h U d.\n       \\<lbrakk>(h, U) \\<in> set ((shift_list (h2, U2) x ps)\\<^sub>+);\n        k \\<le> d; d \\<le> poly_deg h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>h' U'.\n                            (h', U')\n                            \\<in> set (shift_list (h2, U2) x ps) \\<and>\n                            poly_deg h' = d \\<and> card U \\<le> card U'", "show \"\\<exists>h' U'. (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and> poly_deg h' = d \\<and> card U \\<le> card U'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "proof (cases \"(h', U') = (h2, U2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "case True"], ["proof (state)\nthis:\n  (h', U') = (h2, U2)\n\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "hence \"h' = h2\" and \"U' = U2\""], ["proof (prove)\nusing this:\n  (h', U') = (h2, U2)\n\ngoal (1 subgoal):\n 1. h' = h2 &&& U' = U2", "by simp_all"], ["proof (state)\nthis:\n  h' = h2\n  U' = U2\n\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "from assms(2, 6)"], ["proof (chain)\npicking this:\n  (h1, U1) \\<in> set ps\n  (h1, U1) \\<noteq> (h2, U2)", "have \"(h1, U1) \\<in> set (shift_list (h2, U2) x ps)\""], ["proof (prove)\nusing this:\n  (h1, U1) \\<in> set ps\n  (h1, U1) \\<noteq> (h2, U2)\n\ngoal (1 subgoal):\n 1. (h1, U1) \\<in> set (shift_list (h2, U2) x ps)", "by (simp add: shift_list.simps)"], ["proof (state)\nthis:\n  (h1, U1) \\<in> set (shift_list (h2, U2) x ps)\n\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  (h1, U1) \\<in> set (shift_list (h2, U2) x ps)\n\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "from \\<open>poly_deg h' = d\\<close>"], ["proof (chain)\npicking this:\n  poly_deg h' = d", "have \"poly_deg h1 = d\""], ["proof (prove)\nusing this:\n  poly_deg h' = d\n\ngoal (1 subgoal):\n 1. poly_deg h1 = d", "by (simp only: \\<open>h' = h2\\<close> assms(4))"], ["proof (state)\nthis:\n  poly_deg h1 = d\n\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "moreover"], ["proof (state)\nthis:\n  poly_deg h1 = d\n\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "from \\<open>card U \\<le> card U'\\<close> assms(5)"], ["proof (chain)\npicking this:\n  card U \\<le> card U'\n  card U2 \\<le> card U1", "have \"card U \\<le> card U1\""], ["proof (prove)\nusing this:\n  card U \\<le> card U'\n  card U2 \\<le> card U1\n\ngoal (1 subgoal):\n 1. card U \\<le> card U1", "by (simp add: \\<open>U' = U2\\<close>)"], ["proof (state)\nthis:\n  card U \\<le> card U1\n\ngoal (2 subgoals):\n 1. (h', U') = (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'\n 2. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "ultimately"], ["proof (chain)\npicking this:\n  (h1, U1) \\<in> set (shift_list (h2, U2) x ps)\n  poly_deg h1 = d\n  card U \\<le> card U1", "show ?thesis"], ["proof (prove)\nusing this:\n  (h1, U1) \\<in> set (shift_list (h2, U2) x ps)\n  poly_deg h1 = d\n  card U \\<le> card U1\n\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "by blast"], ["proof (state)\nthis:\n  \\<exists>h' U'.\n     (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n     poly_deg h' = d \\<and> card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "case False"], ["proof (state)\nthis:\n  (h', U') \\<noteq> (h2, U2)\n\ngoal (1 subgoal):\n 1. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "with 1"], ["proof (chain)\npicking this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  (h', U') \\<noteq> (h2, U2)", "have \"(h', U') \\<in> set (shift_list (h2, U2) x ps)\""], ["proof (prove)\nusing this:\n  (h', U')\n  \\<in> set ((local.punit.monom_mult (1::'a) (monomial 1 x) h2, U2) # ps)\n  (h', U') \\<noteq> (h2, U2)\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (shift_list (h2, U2) x ps)", "by (auto simp: shift_list.simps)"], ["proof (state)\nthis:\n  (h', U') \\<in> set (shift_list (h2, U2) x ps)\n\ngoal (1 subgoal):\n 1. (h', U') \\<noteq> (h2, U2) \\<Longrightarrow>\n    \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "thus ?thesis"], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (shift_list (h2, U2) x ps)\n\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "using \\<open>poly_deg h' = d\\<close> \\<open>card U \\<le> card U'\\<close>"], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (shift_list (h2, U2) x ps)\n  poly_deg h' = d\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<exists>h' U'.\n       (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n       poly_deg h' = d \\<and> card U \\<le> card U'", "by blast"], ["proof (state)\nthis:\n  \\<exists>h' U'.\n     (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n     poly_deg h' = d \\<and> card U \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>h' U'.\n     (h', U') \\<in> set (shift_list (h2, U2) x ps) \\<and>\n     poly_deg h' = d \\<and> card U \\<le> card U'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_shift_list:\n  assumes \"valid_decomp X ps\" and \"cone_decomp T ps\" and \"(h, U) \\<in> set ps\" and \"x \\<in> U\"\n  shows \"cone_decomp T (shift_list (h, U) x ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "let ?p1 = \"(punit.monom_mult 1 (Poly_Mapping.single x 1) h, U)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "let ?p2 = \"(h, U - {x})\""], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "let ?qs = \"removeAll (h, U) ps\""], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "from assms(3)"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set ps", "obtain ps1 ps2 where ps: \"ps = ps1 @ (h, U) # ps2\" and *: \"(h, U) \\<notin> set ps1\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. (\\<And>ps1 ps2.\n        \\<lbrakk>ps = ps1 @ (h, U) # ps2; (h, U) \\<notin> set ps1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list_first)"], ["proof (state)\nthis:\n  ps = ps1 @ (h, U) # ps2\n  (h, U) \\<notin> set ps1\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "have \"count_list ps2 (h, U) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "from assms(1, 3)"], ["proof (chain)\npicking this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps", "have \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  valid_decomp X ps\n  (h, U) \\<in> set ps\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "assume \"count_list ps2 (h, U) \\<noteq> 0\""], ["proof (state)\nthis:\n  count_list ps2 (h, U) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "hence \"1 < count_list ps (h, U)\""], ["proof (prove)\nusing this:\n  count_list ps2 (h, U) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < count_list ps (h, U)", "by (simp add: ps count_list_append)"], ["proof (state)\nthis:\n  1 < count_list ps (h, U)\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  1 < count_list ps (h, U)\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<dots> \\<le> count_list (map cone ps) (cone (h, U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_list ps (h, U) \\<le> count_list (map cone ps) (cone (h, U))", "by (fact count_list_map_ge)"], ["proof (state)\nthis:\n  count_list ps (h, U) \\<le> count_list (map cone ps) (cone (h, U))\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  1 < count_list (map cone ps) (cone (h, U))", "have \"1 < count_list (map cone ps) (cone (h, U))\""], ["proof (prove)\nusing this:\n  1 < count_list (map cone ps) (cone (h, U))\n\ngoal (1 subgoal):\n 1. 1 < count_list (map cone ps) (cone (h, U))", "."], ["proof (state)\nthis:\n  1 < count_list (map cone ps) (cone (h, U))\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "with cone_decompD"], ["proof (chain)\npicking this:\n  cone_decomp ?T ?ps \\<Longrightarrow> direct_decomp ?T (map cone ?ps)\n  1 < count_list (map cone ps) (cone (h, U))", "have \"cone (h, U) = {0}\""], ["proof (prove)\nusing this:\n  cone_decomp ?T ?ps \\<Longrightarrow> direct_decomp ?T (map cone ?ps)\n  1 < count_list (map cone ps) (cone (h, U))\n\ngoal (1 subgoal):\n 1. cone (h, U) = {0}", "proof (rule direct_decomp_repeated_eq_zero)"], ["proof (state)\ngoal (2 subgoals):\n 1. cone_decomp ?A ps\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> 0 \\<in> s", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. cone_decomp ?A ps\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> 0 \\<in> s", "assume \"s \\<in> set (map cone ps)\""], ["proof (state)\nthis:\n  s \\<in> set (map cone ps)\n\ngoal (2 subgoals):\n 1. cone_decomp ?A ps\n 2. \\<And>s. s \\<in> set (map cone ps) \\<Longrightarrow> 0 \\<in> s", "thus \"0 \\<in> s\""], ["proof (prove)\nusing this:\n  s \\<in> set (map cone ps)\n\ngoal (1 subgoal):\n 1. 0 \\<in> s", "by (auto intro: zero_in_cone)"], ["proof (state)\nthis:\n  0 \\<in> s\n\ngoal (1 subgoal):\n 1. cone_decomp ?A ps", "qed (fact assms(2))"], ["proof (state)\nthis:\n  cone (h, U) = {0}\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "with tip_in_cone[of h U]"], ["proof (chain)\npicking this:\n  h \\<in> cone (h, U)\n  cone (h, U) = {0}", "have \"h = 0\""], ["proof (prove)\nusing this:\n  h \\<in> cone (h, U)\n  cone (h, U) = {0}\n\ngoal (1 subgoal):\n 1. h = 0", "by simp"], ["proof (state)\nthis:\n  h = 0\n\ngoal (1 subgoal):\n 1. count_list ps2 (h, U) \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>h \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\n  h = 0", "show False"], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  h = 0\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count_list ps2 (h, U) = 0\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "hence **: \"(h, U) \\<notin> set ps2\""], ["proof (prove)\nusing this:\n  count_list ps2 (h, U) = 0\n\ngoal (1 subgoal):\n 1. (h, U) \\<notin> set ps2", "by (simp add: count_list_eq_0_iff)"], ["proof (state)\nthis:\n  (h, U) \\<notin> set ps2\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "have \"perm ps ((h, U) # ps1 @ ps2)\" (is \"perm _ ?ps\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps <~~> (h, U) # ps1 @ ps2", "by (rule perm_sym) (simp only: perm_append_Cons ps)"], ["proof (state)\nthis:\n  ps <~~> (h, U) # ps1 @ ps2\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "with assms(2)"], ["proof (chain)\npicking this:\n  cone_decomp T ps\n  ps <~~> (h, U) # ps1 @ ps2", "have \"cone_decomp T ?ps\""], ["proof (prove)\nusing this:\n  cone_decomp T ps\n  ps <~~> (h, U) # ps1 @ ps2\n\ngoal (1 subgoal):\n 1. cone_decomp T ((h, U) # ps1 @ ps2)", "by (rule cone_decomp_perm)"], ["proof (state)\nthis:\n  cone_decomp T ((h, U) # ps1 @ ps2)\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "hence \"direct_decomp T (map cone ?ps)\""], ["proof (prove)\nusing this:\n  cone_decomp T ((h, U) # ps1 @ ps2)\n\ngoal (1 subgoal):\n 1. direct_decomp T (map cone ((h, U) # ps1 @ ps2))", "by (rule cone_decompD)"], ["proof (state)\nthis:\n  direct_decomp T (map cone ((h, U) # ps1 @ ps2))\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "hence \"direct_decomp T (cone (h, U) # map cone (ps1 @ ps2))\""], ["proof (prove)\nusing this:\n  direct_decomp T (map cone ((h, U) # ps1 @ ps2))\n\ngoal (1 subgoal):\n 1. direct_decomp T (cone (h, U) # map cone (ps1 @ ps2))", "by simp"], ["proof (state)\nthis:\n  direct_decomp T (cone (h, U) # map cone (ps1 @ ps2))\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "hence \"direct_decomp T ((map cone (ps1 @ ps2)) @ [cone ?p1, cone ?p2])\""], ["proof (prove)\nusing this:\n  direct_decomp T (cone (h, U) # map cone (ps1 @ ps2))\n\ngoal (1 subgoal):\n 1. direct_decomp T\n     (map cone (ps1 @ ps2) @\n      [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n       cone (h, U - {x})])", "proof (rule direct_decomp_direct_decomp)"], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, U))\n     [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n      cone (h, U - {x})]", "let ?x = \"Poly_Mapping.single x (Suc 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, U))\n     [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n      cone (h, U - {x})]", "have \"direct_decomp (cone (h, insert x (U - {x})))\n              [cone (h, U - {x}), cone (monomial (1::'a) ?x * h, insert x (U - {x}))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, insert x (U - {x})))\n     [cone (h, U - {x}),\n      cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x (U - {x}))]", "by (rule direct_decomp_cone_insert) simp"], ["proof (state)\nthis:\n  direct_decomp (cone (h, insert x (U - {x})))\n   [cone (h, U - {x}),\n    cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x (U - {x}))]\n\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, U))\n     [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n      cone (h, U - {x})]", "with assms(4)"], ["proof (chain)\npicking this:\n  x \\<in> U\n  direct_decomp (cone (h, insert x (U - {x})))\n   [cone (h, U - {x}),\n    cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x (U - {x}))]", "show \"direct_decomp (cone (h, U)) [cone ?p1, cone ?p2]\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  direct_decomp (cone (h, insert x (U - {x})))\n   [cone (h, U - {x}),\n    cone (monomial (1::'a) (monomial (Suc 0) x) * h, insert x (U - {x}))]\n\ngoal (1 subgoal):\n 1. direct_decomp (cone (h, U))\n     [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n      cone (h, U - {x})]", "by (simp add: insert_absorb times_monomial_left direct_decomp_perm perm.swap)"], ["proof (state)\nthis:\n  direct_decomp (cone (h, U))\n   [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n    cone (h, U - {x})]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  direct_decomp T\n   (map cone (ps1 @ ps2) @\n    [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     cone (h, U - {x})])\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "hence \"direct_decomp T (map cone (ps1 @ ps2 @ [?p1, ?p2]))\""], ["proof (prove)\nusing this:\n  direct_decomp T\n   (map cone (ps1 @ ps2) @\n    [cone (local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     cone (h, U - {x})])\n\ngoal (1 subgoal):\n 1. direct_decomp T\n     (map cone\n       (ps1 @\n        ps2 @\n        [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n         (h, U - {x})]))", "by simp"], ["proof (state)\nthis:\n  direct_decomp T\n   (map cone\n     (ps1 @\n      ps2 @\n      [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})]))\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "hence \"cone_decomp T (ps1 @ ps2 @ [?p1, ?p2])\""], ["proof (prove)\nusing this:\n  direct_decomp T\n   (map cone\n     (ps1 @\n      ps2 @\n      [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})]))\n\ngoal (1 subgoal):\n 1. cone_decomp T\n     (ps1 @\n      ps2 @\n      [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})])", "by (rule cone_decompI)"], ["proof (state)\nthis:\n  cone_decomp T\n   (ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})])\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "moreover"], ["proof (state)\nthis:\n  cone_decomp T\n   (ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})])\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "have \"perm (ps1 @ ps2 @ [?p1, ?p2]) (?p1 # ?p2 # (ps1 @ ps2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "have \"ps1 @ ps2 @ [?p1, ?p2] = (ps1 @ ps2) @ [?p1, ?p2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] =\n    (ps1 @ ps2) @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})]", "by simp"], ["proof (state)\nthis:\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] =\n  (ps1 @ ps2) @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})]\n\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "also"], ["proof (state)\nthis:\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] =\n  (ps1 @ ps2) @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})]\n\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "have \"perm \\<dots> ([?p1, ?p2] @ (ps1 @ ps2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ps1 @ ps2) @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] @\n    ps1 @ ps2", "by (rule perm_append_swap)"], ["proof (state)\nthis:\n  (ps1 @ ps2) @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] @\n  ps1 @ ps2\n\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "also"], ["proof (state)\nthis:\n  (ps1 @ ps2) @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] @\n  ps1 @ ps2\n\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "have \"\\<dots> = ?p1 # ?p2 # (ps1 @ ps2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] @\n    ps1 @ ps2 =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "by simp"], ["proof (state)\nthis:\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] @\n  ps1 @ ps2 =\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n  (h, U - {x}) # ps1 @ ps2\n\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "finally"], ["proof (chain)\npicking this:\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n  (h, U - {x}) # ps1 @ ps2", "show ?thesis"], ["proof (prove)\nusing this:\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n  (h, U - {x}) # ps1 @ ps2\n\ngoal (1 subgoal):\n 1. ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U),\n     (h, U - {x})] <~~>\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2", "."], ["proof (state)\nthis:\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n  (h, U - {x}) # ps1 @ ps2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n  (h, U - {x}) # ps1 @ ps2\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "ultimately"], ["proof (chain)\npicking this:\n  cone_decomp T\n   (ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})])\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n  (h, U - {x}) # ps1 @ ps2", "have \"cone_decomp T (?p1 # ?p2 # (ps1 @ ps2))\""], ["proof (prove)\nusing this:\n  cone_decomp T\n   (ps1 @\n    ps2 @\n    [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})])\n  ps1 @\n  ps2 @\n  [(local.punit.monom_mult (1::'a) (monomial 1 x) h, U), (h, U - {x})] <~~>\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n  (h, U - {x}) # ps1 @ ps2\n\ngoal (1 subgoal):\n 1. cone_decomp T\n     ((local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n      (h, U - {x}) # ps1 @ ps2)", "by (rule cone_decomp_perm)"], ["proof (state)\nthis:\n  cone_decomp T\n   ((local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2)\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "also"], ["proof (state)\nthis:\n  cone_decomp T\n   ((local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # ps1 @ ps2)\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "from * **"], ["proof (chain)\npicking this:\n  (h, U) \\<notin> set ps1\n  (h, U) \\<notin> set ps2", "have \"ps1 @ ps2 = removeAll (h, U) ps\""], ["proof (prove)\nusing this:\n  (h, U) \\<notin> set ps1\n  (h, U) \\<notin> set ps2\n\ngoal (1 subgoal):\n 1. ps1 @ ps2 = removeAll (h, U) ps", "by (simp add: remove1_append ps)"], ["proof (state)\nthis:\n  ps1 @ ps2 = removeAll (h, U) ps\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "finally"], ["proof (chain)\npicking this:\n  cone_decomp T\n   ((local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # removeAll (h, U) ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  cone_decomp T\n   ((local.punit.monom_mult (1::'a) (monomial 1 x) h, U) #\n    (h, U - {x}) # removeAll (h, U) ps)\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x ps)", "by (simp only: shift_list.simps)"], ["proof (state)\nthis:\n  cone_decomp T (shift_list (h, U) x ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Functions \\<open>shift\\<close> and \\<open>exact\\<close>\\<close>"], ["", "context\n  fixes k m :: nat\nbegin"], ["", "context\n  fixes d :: nat\nbegin"], ["", "definition shift2_inv :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<times> 'x set) list \\<Rightarrow> bool\" where\n  \"shift2_inv qs \\<longleftrightarrow> valid_decomp X qs \\<and> standard_decomp k qs \\<and> exact_decomp (Suc m) qs \\<and>\n                         (\\<forall>d0<d. card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1)\""], ["", "fun shift1_inv :: \"(((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<times> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::zero) \\<times> 'x set) set) \\<Rightarrow> bool\"\n  where \"shift1_inv (qs, B) \\<longleftrightarrow> B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} \\<and> shift2_inv qs\""], ["", "lemma shift2_invI:\n  \"valid_decomp X qs \\<Longrightarrow> standard_decomp k qs \\<Longrightarrow> exact_decomp (Suc m) qs \\<Longrightarrow>\n    (\\<And>d0. d0 < d \\<Longrightarrow> card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1) \\<Longrightarrow>\n    shift2_inv qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n     exact_decomp (Suc m) qs;\n     \\<And>d0.\n        d0 < d \\<Longrightarrow>\n        card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n        \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> shift2_inv qs", "by (simp add: shift2_inv_def)"], ["", "lemma shift2_invD:\n  assumes \"shift2_inv qs\"\n  shows \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"d0 < d \\<Longrightarrow> card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_decomp X qs &&& standard_decomp k qs) &&&\n    exact_decomp (Suc m) qs &&&\n    (d0 < d \\<Longrightarrow>\n     card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n     \\<le> 1)", "using assms"], ["proof (prove)\nusing this:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. (valid_decomp X qs &&& standard_decomp k qs) &&&\n    exact_decomp (Suc m) qs &&&\n    (d0 < d \\<Longrightarrow>\n     card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n     \\<le> 1)", "by (simp_all add: shift2_inv_def)"], ["", "lemma shift1_invI:\n  \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} \\<Longrightarrow> shift2_inv qs \\<Longrightarrow> shift1_inv (qs, B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B =\n             {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)};\n     shift2_inv qs\\<rbrakk>\n    \\<Longrightarrow> shift1_inv (qs, B)", "by simp"], ["", "lemma shift1_invD:\n  assumes \"shift1_inv (qs, B)\"\n  shows \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\" and \"shift2_inv qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} &&&\n    shift2_inv qs", "using assms"], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} &&&\n    shift2_inv qs", "by simp_all"], ["", "declare shift1_inv.simps[simp del]"], ["", "lemma shift1_inv_finite_snd:\n  assumes \"shift1_inv (qs, B)\"\n  shows \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. B \\<subseteq> ?B\n 2. finite ?B", "from assms"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}", "by (rule shift1_invD)"], ["proof (state)\nthis:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n\ngoal (2 subgoals):\n 1. B \\<subseteq> ?B\n 2. finite ?B", "also"], ["proof (state)\nthis:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n\ngoal (2 subgoals):\n 1. B \\<subseteq> ?B\n 2. finite ?B", "have \"\\<dots> \\<subseteq> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n    \\<subseteq> set qs", "by blast"], ["proof (state)\nthis:\n  {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n  \\<subseteq> set qs\n\ngoal (2 subgoals):\n 1. B \\<subseteq> ?B\n 2. finite ?B", "finally"], ["proof (chain)\npicking this:\n  B \\<subseteq> set qs", "show \"B \\<subseteq> set qs\""], ["proof (prove)\nusing this:\n  B \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. B \\<subseteq> set qs", "."], ["proof (state)\nthis:\n  B \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. finite (set qs)", "qed (fact finite_set)"], ["", "lemma shift1_inv_some_snd:\n  assumes \"shift1_inv (qs, B)\" and \"1 < card B\" and \"(h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\"\n  shows \"(h, U) \\<in> B\" and \"(h, U) \\<in> set qs\" and \"poly_deg h = d\" and \"card U = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((h, U) \\<in> B &&& (h, U) \\<in> set qs) &&&\n    poly_deg h = d &&& card U = Suc m", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "define A where \"A = {q \\<in> B. card (snd q) = Suc m}\""], ["proof (state)\nthis:\n  A = {q \\<in> B. card (snd q) = Suc m}\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "define Y where \"Y = {q \\<in> set qs. poly_deg (fst q) = d \\<and> Suc m < card (snd q)}\""], ["proof (state)\nthis:\n  Y = {q \\<in> set qs. poly_deg (fst q) = d \\<and> Suc m < card (snd q)}\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "from assms(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have B: \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\"\n    and inv2: \"shift2_inv qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} &&&\n    shift2_inv qs", "by (rule shift1_invD)+"], ["proof (state)\nthis:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n  shift2_inv qs\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "have B': \"B = A \\<union> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A \\<union> Y", "by (auto simp: B A_def Y_def)"], ["proof (state)\nthis:\n  B = A \\<union> Y\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "have \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> ?B\n 2. finite ?B", "show \"A \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> B", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<in> B. card (snd q) = Suc m} \\<subseteq> B", "by blast"], ["proof (state)\nthis:\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. finite B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite B", "from assms(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "show \"finite B\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. finite B", "by (rule shift1_inv_finite_snd)"], ["proof (state)\nthis:\n  finite B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite A\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "moreover"], ["proof (state)\nthis:\n  finite A\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "have \"finite Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Y", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. Y \\<subseteq> ?B\n 2. finite ?B", "show \"Y \\<subseteq> set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> set qs", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d \\<and> Suc m < card (snd q)}\n    \\<subseteq> set qs", "by blast"], ["proof (state)\nthis:\n  Y \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. finite (set qs)", "qed (fact finite_set)"], ["proof (state)\nthis:\n  finite Y\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "moreover"], ["proof (state)\nthis:\n  finite Y\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "have \"A \\<inter> Y = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> Y = {}", "by (auto simp: A_def Y_def)"], ["proof (state)\nthis:\n  A \\<inter> Y = {}\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "ultimately"], ["proof (chain)\npicking this:\n  finite A\n  finite Y\n  A \\<inter> Y = {}", "have \"card (A \\<union> Y) = card A + card Y\""], ["proof (prove)\nusing this:\n  finite A\n  finite Y\n  A \\<inter> Y = {}\n\ngoal (1 subgoal):\n 1. card (A \\<union> Y) = card A + card Y", "by (rule card_Un_disjoint)"], ["proof (state)\nthis:\n  card (A \\<union> Y) = card A + card Y\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "with assms(2)"], ["proof (chain)\npicking this:\n  1 < card B\n  card (A \\<union> Y) = card A + card Y", "have \"1 < card A + card Y\""], ["proof (prove)\nusing this:\n  1 < card B\n  card (A \\<union> Y) = card A + card Y\n\ngoal (1 subgoal):\n 1. 1 < card A + card Y", "by (simp only: B')"], ["proof (state)\nthis:\n  1 < card A + card Y\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "thm card_le_Suc0_iff_eq[OF \\<open>finite Y\\<close>]"], ["proof (state)\nthis:\n  1 < card A + card Y\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "moreover"], ["proof (state)\nthis:\n  1 < card A + card Y\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "have \"card Y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card Y \\<le> 1", "unfolding One_nat_def card_le_Suc0_iff_eq[OF \\<open>finite Y\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>Y. Ball Y ((=) a1)", "proof (intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "fix q1 q2 :: \"(('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "obtain h1 U1 where q1: \"q1 = (h1, U1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h1 U1. q1 = (h1, U1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h1 U1. q1 = (h1, U1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q1 = (h1, U1)\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "obtain h2 U2 where q2: \"q2 = (h2, U2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h2 U2. q2 = (h2, U2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h2 U2. q2 = (h2, U2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q2 = (h2, U2)\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "assume \"q1 \\<in> Y\""], ["proof (state)\nthis:\n  q1 \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "hence \"(h1, U1) \\<in> set qs\" and \"poly_deg h1 = d\" and \"Suc m < card U1\""], ["proof (prove)\nusing this:\n  q1 \\<in> Y\n\ngoal (1 subgoal):\n 1. (h1, U1) \\<in> set qs &&& poly_deg h1 = d &&& Suc m < card U1", "by (simp_all add: q1 Y_def)"], ["proof (state)\nthis:\n  (h1, U1) \\<in> set qs\n  poly_deg h1 = d\n  Suc m < card U1\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "assume \"q2 \\<in> Y\""], ["proof (state)\nthis:\n  q2 \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "hence \"(h2, U2) \\<in> set qs\" and \"poly_deg h2 = d\" and \"Suc m < card U2\""], ["proof (prove)\nusing this:\n  q2 \\<in> Y\n\ngoal (1 subgoal):\n 1. (h2, U2) \\<in> set qs &&& poly_deg h2 = d &&& Suc m < card U2", "by (simp_all add: q2 Y_def)"], ["proof (state)\nthis:\n  (h2, U2) \\<in> set qs\n  poly_deg h2 = d\n  Suc m < card U2\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "from this(2)"], ["proof (chain)\npicking this:\n  poly_deg h2 = d", "have \"poly_deg h1 = poly_deg h2\""], ["proof (prove)\nusing this:\n  poly_deg h2 = d\n\ngoal (1 subgoal):\n 1. poly_deg h1 = poly_deg h2", "by (simp only: \\<open>poly_deg h1 = d\\<close>)"], ["proof (state)\nthis:\n  poly_deg h1 = poly_deg h2\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "from inv2"], ["proof (chain)\npicking this:\n  shift2_inv qs", "have \"exact_decomp (Suc m) qs\""], ["proof (prove)\nusing this:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. exact_decomp (Suc m) qs", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. \\<And>a1 x.\n       \\<lbrakk>a1 \\<in> Y; x \\<in> Y\\<rbrakk> \\<Longrightarrow> a1 = x", "thus \"q1 = q2\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. q1 = q2", "unfolding q1 q2"], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. (h1, U1) = (h2, U2)", "by (rule exact_decompD) fact+"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card Y \\<le> 1\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "ultimately"], ["proof (chain)\npicking this:\n  1 < card A + card Y\n  card Y \\<le> 1", "have \"0 < card A\""], ["proof (prove)\nusing this:\n  1 < card A + card Y\n  card Y \\<le> 1\n\ngoal (1 subgoal):\n 1. 0 < card A", "by simp"], ["proof (state)\nthis:\n  0 < card A\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "hence \"A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < card A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "obtain a where \"a \\<in> A\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "have \"(h, U) \\<in> B \\<and> card (snd (h, U)) = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h, U) \\<in> B \\<and> card (snd (h, U)) = Suc m", "unfolding assms(3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME b. b \\<in> B \\<and> card (snd b) = Suc m) \\<in> B \\<and>\n    card (snd (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)) = Suc m", "proof (rule someI)"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> B \\<and> card (snd ?x) = Suc m", "from \\<open>a \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> A", "show \"a \\<in> B \\<and> card (snd a) = Suc m\""], ["proof (prove)\nusing this:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<in> B \\<and> card (snd a) = Suc m", "by (simp add: A_def)"], ["proof (state)\nthis:\n  a \\<in> B \\<and> card (snd a) = Suc m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (h, U) \\<in> B \\<and> card (snd (h, U)) = Suc m\n\ngoal (4 subgoals):\n 1. (h, U) \\<in> B\n 2. (h, U) \\<in> set qs\n 3. poly_deg h = d\n 4. card U = Suc m", "thus \"(h, U) \\<in> B\" and \"card U = Suc m\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> B \\<and> card (snd (h, U)) = Suc m\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> B &&& card U = Suc m", "by simp_all"], ["proof (state)\nthis:\n  (h, U) \\<in> B\n  card U = Suc m\n\ngoal (2 subgoals):\n 1. (h, U) \\<in> set qs\n 2. poly_deg h = d", "from this(1)"], ["proof (chain)\npicking this:\n  (h, U) \\<in> B", "show \"(h, U) \\<in> set qs\" and \"poly_deg h = d\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> B\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs &&& poly_deg h = d", "by (simp_all add: B)"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n  poly_deg h = d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_inv_preserved:\n  assumes \"shift1_inv (qs, B)\" and \"1 < card B\" and \"(h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\"\n    and \"x = (SOME y. y \\<in> U)\"\n  shows \"shift1_inv (shift_list (h, U) x qs, B - {(h, U)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "let ?p1 = \"(punit.monom_mult 1 (Poly_Mapping.single x 1) h, U)\""], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "let ?p2 = \"(h, U - {x})\""], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "let ?qs = \"removeAll (h, U) qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "let ?B = \"B - {(h, U)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from assms(1, 2, 3)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)", "have \"(h, U) \\<in> B\" and \"(h, U) \\<in> set qs\" and deg_h: \"poly_deg h = d\"\n    and card_U: \"card U = Suc m\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. ((h, U) \\<in> B &&& (h, U) \\<in> set qs) &&&\n    poly_deg h = d &&& card U = Suc m", "by (rule shift1_inv_some_snd)+"], ["proof (state)\nthis:\n  (h, U) \\<in> B\n  (h, U) \\<in> set qs\n  poly_deg h = d\n  card U = Suc m\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from card_U"], ["proof (chain)\npicking this:\n  card U = Suc m", "have \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  card U = Suc m\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "then"], ["proof (chain)\npicking this:\n  U \\<noteq> {}", "obtain y where \"y \\<in> U\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "hence \"x \\<in> U\""], ["proof (prove)\nusing this:\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. x \\<in> U", "unfolding assms(4)"], ["proof (prove)\nusing this:\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. (SOME y. y \\<in> U) \\<in> U", "by (rule someI)"], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "with card_U"], ["proof (chain)\npicking this:\n  card U = Suc m\n  x \\<in> U", "have card_Ux: \"card (U - {x}) = m\""], ["proof (prove)\nusing this:\n  card U = Suc m\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. card (U - {x}) = m", "by (metis card_Diff_singleton card.infinite diff_Suc_1 nat.simps(3))"], ["proof (state)\nthis:\n  card (U - {x}) = m\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from assms(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have B: \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\"\n    and inv2: \"shift2_inv qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} &&&\n    shift2_inv qs", "by (rule shift1_invD)+"], ["proof (state)\nthis:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from inv2"], ["proof (chain)\npicking this:\n  shift2_inv qs", "have valid_qs: \"valid_decomp X qs\""], ["proof (prove)\nusing this:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. valid_decomp X qs", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "hence \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "using \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "proof (intro shift1_invI shift2_invI)"], ["proof (state)\ngoal (5 subgoals):\n 1. B - {(h, U)} =\n    {q \\<in> set (shift_list (h, U) x qs).\n     poly_deg (fst q) = d \\<and> m < card (snd q)}\n 2. valid_decomp X (shift_list (h, U) x qs)\n 3. standard_decomp k (shift_list (h, U) x qs)\n 4. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 5. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "show \"?B = {q \\<in> set (shift_list (h, U) x qs). poly_deg (fst q) = d \\<and> m < card (snd q)}\" (is \"_ = ?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. B - {(h, U)} =\n    {q \\<in> set (shift_list (h, U) x qs).\n     poly_deg (fst q) = d \\<and> m < card (snd q)}", "proof (rule Set.set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> B - {(h, U)}) =\n       (xa \\<in> {q \\<in> set (shift_list (h, U) x qs).\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> B - {(h, U)}) =\n       (xa \\<in> {q \\<in> set (shift_list (h, U) x qs).\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})", "show \"b \\<in> ?B \\<longleftrightarrow> b \\<in> ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<in> B - {(h, U)}) =\n    (b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n              poly_deg (fst q) = d \\<and> m < card (snd q)})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> B - {(h, U)} \\<Longrightarrow>\n    b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n             poly_deg (fst q) = d \\<and> m < card (snd q)}\n 2. b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n             poly_deg (fst q) = d \\<and> m < card (snd q)} \\<Longrightarrow>\n    b \\<in> B - {(h, U)}", "assume \"b \\<in> ?C\""], ["proof (state)\nthis:\n  b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n           poly_deg (fst q) = d \\<and> m < card (snd q)}\n\ngoal (2 subgoals):\n 1. b \\<in> B - {(h, U)} \\<Longrightarrow>\n    b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n             poly_deg (fst q) = d \\<and> m < card (snd q)}\n 2. b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n             poly_deg (fst q) = d \\<and> m < card (snd q)} \\<Longrightarrow>\n    b \\<in> B - {(h, U)}", "hence \"b \\<in> insert ?p1 (insert ?p2 (set ?qs))\" and b1: \"poly_deg (fst b) = d\"\n          and b2: \"m < card (snd b)\""], ["proof (prove)\nusing this:\n  b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n           poly_deg (fst q) = d \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. b \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n             (insert (h, U - {x}) (set (removeAll (h, U) qs))) &&&\n    poly_deg (fst b) = d &&& m < card (snd b)", "by (simp_all add: shift_list.simps)"], ["proof (state)\nthis:\n  b \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n           (insert (h, U - {x}) (set (removeAll (h, U) qs)))\n  poly_deg (fst b) = d\n  m < card (snd b)\n\ngoal (2 subgoals):\n 1. b \\<in> B - {(h, U)} \\<Longrightarrow>\n    b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n             poly_deg (fst q) = d \\<and> m < card (snd q)}\n 2. b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n             poly_deg (fst q) = d \\<and> m < card (snd q)} \\<Longrightarrow>\n    b \\<in> B - {(h, U)}", "from this(1)"], ["proof (chain)\npicking this:\n  b \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n           (insert (h, U - {x}) (set (removeAll (h, U) qs)))", "show \"b \\<in> ?B\""], ["proof (prove)\nusing this:\n  b \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n           (insert (h, U - {x}) (set (removeAll (h, U) qs)))\n\ngoal (1 subgoal):\n 1. b \\<in> B - {(h, U)}", "proof (elim insertE)"], ["proof (state)\ngoal (3 subgoals):\n 1. b =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    b \\<in> B - {(h, U)}\n 2. b = (h, U - {x}) \\<Longrightarrow> b \\<in> B - {(h, U)}\n 3. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "assume \"b = ?p1\""], ["proof (state)\nthis:\n  b = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (3 subgoals):\n 1. b =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    b \\<in> B - {(h, U)}\n 2. b = (h, U - {x}) \\<Longrightarrow> b \\<in> B - {(h, U)}\n 3. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "with \\<open>h \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\n  b = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)", "have \"poly_deg (fst b) = Suc d\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  b = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (1 subgoal):\n 1. poly_deg (fst b) = Suc d", "by (simp add: poly_deg_monom_mult deg_pm_single deg_h)"], ["proof (state)\nthis:\n  poly_deg (fst b) = Suc d\n\ngoal (3 subgoals):\n 1. b =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    b \\<in> B - {(h, U)}\n 2. b = (h, U - {x}) \\<Longrightarrow> b \\<in> B - {(h, U)}\n 3. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (fst b) = Suc d\n\ngoal (1 subgoal):\n 1. b \\<in> B - {(h, U)}", "by (simp add: b1)"], ["proof (state)\nthis:\n  b \\<in> B - {(h, U)}\n\ngoal (2 subgoals):\n 1. b = (h, U - {x}) \\<Longrightarrow> b \\<in> B - {(h, U)}\n 2. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. b = (h, U - {x}) \\<Longrightarrow> b \\<in> B - {(h, U)}\n 2. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "assume \"b = ?p2\""], ["proof (state)\nthis:\n  b = (h, U - {x})\n\ngoal (2 subgoals):\n 1. b = (h, U - {x}) \\<Longrightarrow> b \\<in> B - {(h, U)}\n 2. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "hence \"card (snd b) = m\""], ["proof (prove)\nusing this:\n  b = (h, U - {x})\n\ngoal (1 subgoal):\n 1. card (snd b) = m", "by (simp add: card_Ux)"], ["proof (state)\nthis:\n  card (snd b) = m\n\ngoal (2 subgoals):\n 1. b = (h, U - {x}) \\<Longrightarrow> b \\<in> B - {(h, U)}\n 2. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "with b2"], ["proof (chain)\npicking this:\n  m < card (snd b)\n  card (snd b) = m", "show ?thesis"], ["proof (prove)\nusing this:\n  m < card (snd b)\n  card (snd b) = m\n\ngoal (1 subgoal):\n 1. b \\<in> B - {(h, U)}", "by simp"], ["proof (state)\nthis:\n  b \\<in> B - {(h, U)}\n\ngoal (1 subgoal):\n 1. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "assume \"b \\<in> set ?qs\""], ["proof (state)\nthis:\n  b \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. b \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> b \\<in> B - {(h, U)}", "with b1 b2"], ["proof (chain)\npicking this:\n  poly_deg (fst b) = d\n  m < card (snd b)\n  b \\<in> set (removeAll (h, U) qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (fst b) = d\n  m < card (snd b)\n  b \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. b \\<in> B - {(h, U)}", "by (auto simp: B)"], ["proof (state)\nthis:\n  b \\<in> B - {(h, U)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<in> B - {(h, U)}\n\ngoal (1 subgoal):\n 1. b \\<in> B - {(h, U)} \\<Longrightarrow>\n    b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n             poly_deg (fst q) = d \\<and> m < card (snd q)}", "qed (auto simp: B shift_list.simps)"], ["proof (state)\nthis:\n  (b \\<in> B - {(h, U)}) =\n  (b \\<in> {q \\<in> set (shift_list (h, U) x qs).\n            poly_deg (fst q) = d \\<and> m < card (snd q)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B - {(h, U)} =\n  {q \\<in> set (shift_list (h, U) x qs).\n   poly_deg (fst q) = d \\<and> m < card (snd q)}\n\ngoal (4 subgoals):\n 1. valid_decomp X (shift_list (h, U) x qs)\n 2. standard_decomp k (shift_list (h, U) x qs)\n 3. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 4. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_decomp X (shift_list (h, U) x qs)\n 2. standard_decomp k (shift_list (h, U) x qs)\n 3. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 4. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from valid_qs \\<open>(h, U) \\<in> set qs\\<close> \\<open>x \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n  x \\<in> U", "show \"valid_decomp X (shift_list (h, U) x qs)\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. valid_decomp X (shift_list (h, U) x qs)", "by (rule valid_decomp_shift_list)"], ["proof (state)\nthis:\n  valid_decomp X (shift_list (h, U) x qs)\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from inv2"], ["proof (chain)\npicking this:\n  shift2_inv qs", "have std: \"standard_decomp k qs\""], ["proof (prove)\nusing this:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. standard_decomp k qs", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  standard_decomp k qs\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "have \"?B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - {(h, U)} \\<noteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. B - {(h, U)} = {} \\<Longrightarrow> False", "assume \"?B = {}\""], ["proof (state)\nthis:\n  B - {(h, U)} = {}\n\ngoal (1 subgoal):\n 1. B - {(h, U)} = {} \\<Longrightarrow> False", "hence \"B \\<subseteq> {(h, U)}\""], ["proof (prove)\nusing this:\n  B - {(h, U)} = {}\n\ngoal (1 subgoal):\n 1. B \\<subseteq> {(h, U)}", "by simp"], ["proof (state)\nthis:\n  B \\<subseteq> {(h, U)}\n\ngoal (1 subgoal):\n 1. B - {(h, U)} = {} \\<Longrightarrow> False", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  B \\<subseteq> {(h, U)}", "have \"card B \\<le> card {(h, U)}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  B \\<subseteq> {(h, U)}\n\ngoal (1 subgoal):\n 1. card B \\<le> card {(h, U)}", "by (rule card_mono) simp"], ["proof (state)\nthis:\n  card B \\<le> card {(h, U)}\n\ngoal (1 subgoal):\n 1. B - {(h, U)} = {} \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  1 < card B\n  card B \\<le> card {(h, U)}", "show False"], ["proof (prove)\nusing this:\n  1 < card B\n  card B \\<le> card {(h, U)}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  B - {(h, U)} \\<noteq> {}\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "then"], ["proof (chain)\npicking this:\n  B - {(h, U)} \\<noteq> {}", "obtain h' U' where \"(h', U') \\<in> B\" and \"(h', U') \\<noteq> (h, U)\""], ["proof (prove)\nusing this:\n  B - {(h, U)} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> B; (h', U') \\<noteq> (h, U)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (h', U') \\<in> B\n  (h', U') \\<noteq> (h, U)\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from this(1)"], ["proof (chain)\npicking this:\n  (h', U') \\<in> B", "have \"(h', U') \\<in> set qs\" and \"poly_deg h' = d\" and \"Suc m \\<le> card U'\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> B\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set qs &&& poly_deg h' = d &&& Suc m \\<le> card U'", "by (simp_all add: B)"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs\n  poly_deg h' = d\n  Suc m \\<le> card U'\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "note std this(1) \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (state)\nthis:\n  standard_decomp k qs\n  (h', U') \\<in> set qs\n  (h, U) \\<in> set qs\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "moreover"], ["proof (state)\nthis:\n  standard_decomp k qs\n  (h', U') \\<in> set qs\n  (h, U) \\<in> set qs\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from \\<open>poly_deg h' = d\\<close>"], ["proof (chain)\npicking this:\n  poly_deg h' = d", "have \"poly_deg h' = poly_deg h\""], ["proof (prove)\nusing this:\n  poly_deg h' = d\n\ngoal (1 subgoal):\n 1. poly_deg h' = poly_deg h", "by (simp only: deg_h)"], ["proof (state)\nthis:\n  poly_deg h' = poly_deg h\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "moreover"], ["proof (state)\nthis:\n  poly_deg h' = poly_deg h\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from \\<open>Suc m \\<le> card U'\\<close>"], ["proof (chain)\npicking this:\n  Suc m \\<le> card U'", "have \"card U \\<le> card U'\""], ["proof (prove)\nusing this:\n  Suc m \\<le> card U'\n\ngoal (1 subgoal):\n 1. card U \\<le> card U'", "by (simp only: card_U)"], ["proof (state)\nthis:\n  card U \\<le> card U'\n\ngoal (3 subgoals):\n 1. standard_decomp k (shift_list (h, U) x qs)\n 2. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 3. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  standard_decomp k qs\n  (h', U') \\<in> set qs\n  (h, U) \\<in> set qs\n  poly_deg h' = poly_deg h\n  card U \\<le> card U'", "show \"standard_decomp k (shift_list (h, U) x qs)\""], ["proof (prove)\nusing this:\n  standard_decomp k qs\n  (h', U') \\<in> set qs\n  (h, U) \\<in> set qs\n  poly_deg h' = poly_deg h\n  card U \\<le> card U'\n\ngoal (1 subgoal):\n 1. standard_decomp k (shift_list (h, U) x qs)", "by (rule standard_decomp_shift_list) fact+"], ["proof (state)\nthis:\n  standard_decomp k (shift_list (h, U) x qs)\n\ngoal (2 subgoals):\n 1. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 2. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 2. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from inv2"], ["proof (chain)\npicking this:\n  shift2_inv qs", "have exct: \"exact_decomp (Suc m) qs\""], ["proof (prove)\nusing this:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. exact_decomp (Suc m) qs", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  exact_decomp (Suc m) qs\n\ngoal (2 subgoals):\n 1. exact_decomp (Suc m) (shift_list (h, U) x qs)\n 2. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "show \"exact_decomp (Suc m) (shift_list (h, U) x qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exact_decomp (Suc m) (shift_list (h, U) x qs)", "proof (rule exact_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       ha \\<in> P[X]\n 2. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       Ua \\<subseteq> X\n 3. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "fix h' U'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       ha \\<in> P[X]\n 2. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       Ua \\<subseteq> X\n 3. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "assume \"(h', U') \\<in> set (shift_list (h, U) x qs)\""], ["proof (state)\nthis:\n  (h', U') \\<in> set (shift_list (h, U) x qs)\n\ngoal (3 subgoals):\n 1. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       ha \\<in> P[X]\n 2. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       Ua \\<subseteq> X\n 3. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "hence *: \"(h', U') \\<in> insert ?p1 (insert ?p2 (set ?qs))\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. (h', U')\n    \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n           (insert (h, U - {x}) (set (removeAll (h, U) qs)))", "by (simp add: shift_list.simps)"], ["proof (state)\nthis:\n  (h', U')\n  \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n         (insert (h, U - {x}) (set (removeAll (h, U) qs)))\n\ngoal (3 subgoals):\n 1. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       ha \\<in> P[X]\n 2. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       Ua \\<subseteq> X\n 3. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "thus \"h' \\<in> P[X]\""], ["proof (prove)\nusing this:\n  (h', U')\n  \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n         (insert (h, U - {x}) (set (removeAll (h, U) qs)))\n\ngoal (1 subgoal):\n 1. h' \\<in> P[X]", "proof (elim insertE)"], ["proof (state)\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "assume \"(h', U') = ?p1\""], ["proof (state)\nthis:\n  (h', U') = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "hence h': \"h' = punit.monom_mult 1 (Poly_Mapping.single x 1) h\""], ["proof (prove)\nusing this:\n  (h', U') = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (1 subgoal):\n 1. h' = local.punit.monom_mult (1::'a) (monomial 1 x) h", "by simp"], ["proof (state)\nthis:\n  h' = local.punit.monom_mult (1::'a) (monomial 1 x) h\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "from exct \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs", "have \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "with \\<open>x \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<subseteq> X", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X", ".."], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "hence \"Poly_Mapping.single x 1 \\<in> .[X]\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. monomial 1 x \\<in> .[X]", "by (rule PPs_closed_single)"], ["proof (state)\nthis:\n  monomial 1 x \\<in> .[X]\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "moreover"], ["proof (state)\nthis:\n  monomial 1 x \\<in> .[X]\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "from exct \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs", "have \"h \\<in> P[X]\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. h \\<in> P[X]", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  h \\<in> P[X]\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    h' \\<in> P[X]\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "ultimately"], ["proof (chain)\npicking this:\n  monomial 1 x \\<in> .[X]\n  h \\<in> P[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  monomial 1 x \\<in> .[X]\n  h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. h' \\<in> P[X]", "unfolding h'"], ["proof (prove)\nusing this:\n  monomial 1 x \\<in> .[X]\n  h \\<in> P[X]\n\ngoal (1 subgoal):\n 1. local.punit.monom_mult (1::'a) (monomial 1 x) h \\<in> P[X]", "by (rule Polys_closed_monom_mult)"], ["proof (state)\nthis:\n  h' \\<in> P[X]\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "assume \"(h', U') = ?p2\""], ["proof (state)\nthis:\n  (h', U') = (h, U - {x})\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "hence \"h' = h\""], ["proof (prove)\nusing this:\n  (h', U') = (h, U - {x})\n\ngoal (1 subgoal):\n 1. h' = h", "by simp"], ["proof (state)\nthis:\n  h' = h\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "also"], ["proof (state)\nthis:\n  h' = h\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "from exct \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs", "have \"\\<dots> \\<in> P[X]\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. h \\<in> P[X]", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  h \\<in> P[X]\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> h' \\<in> P[X]\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "finally"], ["proof (chain)\npicking this:\n  h' \\<in> P[X]", "show ?thesis"], ["proof (prove)\nusing this:\n  h' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. h' \\<in> P[X]", "."], ["proof (state)\nthis:\n  h' \\<in> P[X]\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "assume \"(h', U') \\<in> set ?qs\""], ["proof (state)\nthis:\n  (h', U') \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "hence \"(h', U') \\<in> set qs\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set qs", "by simp"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow> h' \\<in> P[X]", "with exct"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs\n  (h', U') \\<in> set qs", "show ?thesis"], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n  (h', U') \\<in> set qs\n\ngoal (1 subgoal):\n 1. h' \\<in> P[X]", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  h' \\<in> P[X]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h' \\<in> P[X]\n\ngoal (2 subgoals):\n 1. \\<And>ha Ua.\n       (ha, Ua) \\<in> set (shift_list (h, U) x qs) \\<Longrightarrow>\n       Ua \\<subseteq> X\n 2. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "from *"], ["proof (chain)\npicking this:\n  (h', U')\n  \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n         (insert (h, U - {x}) (set (removeAll (h, U) qs)))", "show \"U' \\<subseteq> X\""], ["proof (prove)\nusing this:\n  (h', U')\n  \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n         (insert (h, U - {x}) (set (removeAll (h, U) qs)))\n\ngoal (1 subgoal):\n 1. U' \\<subseteq> X", "proof (elim insertE)"], ["proof (state)\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    U' \\<subseteq> X\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "assume \"(h', U') = ?p1\""], ["proof (state)\nthis:\n  (h', U') = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    U' \\<subseteq> X\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "hence \"U' = U\""], ["proof (prove)\nusing this:\n  (h', U') = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (1 subgoal):\n 1. U' = U", "by simp"], ["proof (state)\nthis:\n  U' = U\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    U' \\<subseteq> X\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "also"], ["proof (state)\nthis:\n  U' = U\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    U' \\<subseteq> X\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "from exct \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs", "have \"\\<dots> \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (3 subgoals):\n 1. (h', U') =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    U' \\<subseteq> X\n 2. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 3. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "finally"], ["proof (chain)\npicking this:\n  U' \\<subseteq> X", "show ?thesis"], ["proof (prove)\nusing this:\n  U' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U' \\<subseteq> X", "."], ["proof (state)\nthis:\n  U' \\<subseteq> X\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "assume \"(h', U') = ?p2\""], ["proof (state)\nthis:\n  (h', U') = (h, U - {x})\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "hence \"U' = U - {x}\""], ["proof (prove)\nusing this:\n  (h', U') = (h, U - {x})\n\ngoal (1 subgoal):\n 1. U' = U - {x}", "by simp"], ["proof (state)\nthis:\n  U' = U - {x}\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "also"], ["proof (state)\nthis:\n  U' = U - {x}\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "have \"\\<dots> \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U - {x} \\<subseteq> U", "by blast"], ["proof (state)\nthis:\n  U - {x} \\<subseteq> U\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "also"], ["proof (state)\nthis:\n  U - {x} \\<subseteq> U\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "from exct \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs", "have \"\\<dots> \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. U \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U \\<subseteq> X\n\ngoal (2 subgoals):\n 1. (h', U') = (h, U - {x}) \\<Longrightarrow> U' \\<subseteq> X\n 2. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "finally"], ["proof (chain)\npicking this:\n  U' \\<subseteq> X", "show ?thesis"], ["proof (prove)\nusing this:\n  U' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. U' \\<subseteq> X", "."], ["proof (state)\nthis:\n  U' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "assume \"(h', U') \\<in> set ?qs\""], ["proof (state)\nthis:\n  (h', U') \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "hence \"(h', U') \\<in> set qs\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set qs", "by simp"], ["proof (state)\nthis:\n  (h', U') \\<in> set qs\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    U' \\<subseteq> X", "with exct"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs\n  (h', U') \\<in> set qs", "show ?thesis"], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n  (h', U') \\<in> set qs\n\ngoal (1 subgoal):\n 1. U' \\<subseteq> X", "by (rule exact_decompD)"], ["proof (state)\nthis:\n  U' \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "fix h1 h2 U1 U2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "assume \"(h1, U1) \\<in> set (shift_list (h, U) x qs)\" and \"Suc m < card U1\""], ["proof (state)\nthis:\n  (h1, U1) \\<in> set (shift_list (h, U) x qs)\n  Suc m < card U1\n\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "hence \"(h1, U1) \\<in> set qs\""], ["proof (prove)\nusing this:\n  (h1, U1) \\<in> set (shift_list (h, U) x qs)\n  Suc m < card U1\n\ngoal (1 subgoal):\n 1. (h1, U1) \\<in> set qs", "using card_U card_Ux"], ["proof (prove)\nusing this:\n  (h1, U1) \\<in> set (shift_list (h, U) x qs)\n  Suc m < card U1\n  card U = Suc m\n  card (U - {x}) = m\n\ngoal (1 subgoal):\n 1. (h1, U1) \\<in> set qs", "by (auto simp: shift_list.simps)"], ["proof (state)\nthis:\n  (h1, U1) \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "assume \"(h2, U2) \\<in> set (shift_list (h, U) x qs)\" and \"Suc m < card U2\""], ["proof (state)\nthis:\n  (h2, U2) \\<in> set (shift_list (h, U) x qs)\n  Suc m < card U2\n\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "hence \"(h2, U2) \\<in> set qs\""], ["proof (prove)\nusing this:\n  (h2, U2) \\<in> set (shift_list (h, U) x qs)\n  Suc m < card U2\n\ngoal (1 subgoal):\n 1. (h2, U2) \\<in> set qs", "using card_U card_Ux"], ["proof (prove)\nusing this:\n  (h2, U2) \\<in> set (shift_list (h, U) x qs)\n  Suc m < card U2\n  card U = Suc m\n  card (U - {x}) = m\n\ngoal (1 subgoal):\n 1. (h2, U2) \\<in> set qs", "by (auto simp: shift_list.simps)"], ["proof (state)\nthis:\n  (h2, U2) \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "assume \"poly_deg h1 = poly_deg h2\""], ["proof (state)\nthis:\n  poly_deg h1 = poly_deg h2\n\ngoal (1 subgoal):\n 1. \\<And>ha h' Ua U'.\n       \\<lbrakk>(ha, Ua) \\<in> set (shift_list (h, U) x qs);\n        (h', U') \\<in> set (shift_list (h, U) x qs);\n        poly_deg ha = poly_deg h'; Suc m < card Ua; Suc m < card U'\\<rbrakk>\n       \\<Longrightarrow> (ha, Ua) = (h', U')", "from exct"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) qs", "show \"(h1, U1) = (h2, U2)\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. (h1, U1) = (h2, U2)", "by (rule exact_decompD) fact+"], ["proof (state)\nthis:\n  (h1, U1) = (h2, U2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exact_decomp (Suc m) (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "fix d0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "assume \"d0 < d\""], ["proof (state)\nthis:\n  d0 < d\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "have \"finite {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\" (is \"finite ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "by auto"], ["proof (state)\nthis:\n  finite {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "moreover"], ["proof (state)\nthis:\n  finite {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "have \"{q \\<in> set (shift_list (h, U) x qs). poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<subseteq> ?A\"\n      (is \"?C \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<in> set (shift_list (h, U) x qs).\n     poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<subseteq> {q \\<in> set qs.\n                 poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       (xa, y)\n       \\<in> {q \\<in> set (shift_list (h, U) x qs).\n              poly_deg (fst q) = d0 \\<and>\n              m < card (snd q)} \\<Longrightarrow>\n       (xa, y)\n       \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       (xa, y)\n       \\<in> {q \\<in> set (shift_list (h, U) x qs).\n              poly_deg (fst q) = d0 \\<and>\n              m < card (snd q)} \\<Longrightarrow>\n       (xa, y)\n       \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "assume \"q \\<in> ?C\""], ["proof (state)\nthis:\n  q \\<in> {q \\<in> set (shift_list (h, U) x qs).\n           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       (xa, y)\n       \\<in> {q \\<in> set (shift_list (h, U) x qs).\n              poly_deg (fst q) = d0 \\<and>\n              m < card (snd q)} \\<Longrightarrow>\n       (xa, y)\n       \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "hence \"q = ?p1 \\<or> q = ?p2 \\<or> q \\<in> set ?qs\" and 1: \"poly_deg (fst q) = d0\" and 2: \"m < card (snd q)\""], ["proof (prove)\nusing this:\n  q \\<in> {q \\<in> set (shift_list (h, U) x qs).\n           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. q = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<or>\n    q = (h, U - {x}) \\<or> q \\<in> set (removeAll (h, U) qs) &&&\n    poly_deg (fst q) = d0 &&& m < card (snd q)", "by (simp_all add: shift_list.simps)"], ["proof (state)\nthis:\n  q = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<or>\n  q = (h, U - {x}) \\<or> q \\<in> set (removeAll (h, U) qs)\n  poly_deg (fst q) = d0\n  m < card (snd q)\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       (xa, y)\n       \\<in> {q \\<in> set (shift_list (h, U) x qs).\n              poly_deg (fst q) = d0 \\<and>\n              m < card (snd q)} \\<Longrightarrow>\n       (xa, y)\n       \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "from this(1)"], ["proof (chain)\npicking this:\n  q = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<or>\n  q = (h, U - {x}) \\<or> q \\<in> set (removeAll (h, U) qs)", "show \"q \\<in> ?A\""], ["proof (prove)\nusing this:\n  q = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<or>\n  q = (h, U - {x}) \\<or> q \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. q =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 2. q = (h, U - {x}) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 3. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "assume \"q = ?p1\""], ["proof (state)\nthis:\n  q = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (3 subgoals):\n 1. q =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 2. q = (h, U - {x}) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 3. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "with \\<open>h \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\n  q = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)", "have \"d \\<le> poly_deg (fst q)\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  q = (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg (fst q)", "by (simp add: poly_deg_monom_mult deg_h)"], ["proof (state)\nthis:\n  d \\<le> poly_deg (fst q)\n\ngoal (3 subgoals):\n 1. q =\n    (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 2. q = (h, U - {x}) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 3. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "with \\<open>d0 < d\\<close>"], ["proof (chain)\npicking this:\n  d0 < d\n  d \\<le> poly_deg (fst q)", "show ?thesis"], ["proof (prove)\nusing this:\n  d0 < d\n  d \\<le> poly_deg (fst q)\n\ngoal (1 subgoal):\n 1. q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "by (simp only: 1)"], ["proof (state)\nthis:\n  q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (2 subgoals):\n 1. q = (h, U - {x}) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 2. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. q = (h, U - {x}) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 2. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "assume \"q = ?p2\""], ["proof (state)\nthis:\n  q = (h, U - {x})\n\ngoal (2 subgoals):\n 1. q = (h, U - {x}) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 2. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "hence \"d \\<le> poly_deg (fst q)\""], ["proof (prove)\nusing this:\n  q = (h, U - {x})\n\ngoal (1 subgoal):\n 1. d \\<le> poly_deg (fst q)", "by (simp add: deg_h)"], ["proof (state)\nthis:\n  d \\<le> poly_deg (fst q)\n\ngoal (2 subgoals):\n 1. q = (h, U - {x}) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n 2. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "with \\<open>d0 < d\\<close>"], ["proof (chain)\npicking this:\n  d0 < d\n  d \\<le> poly_deg (fst q)", "show ?thesis"], ["proof (prove)\nusing this:\n  d0 < d\n  d \\<le> poly_deg (fst q)\n\ngoal (1 subgoal):\n 1. q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "by (simp only: 1)"], ["proof (state)\nthis:\n  q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "assume \"q \\<in> set ?qs\""], ["proof (state)\nthis:\n  q \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. q \\<in> set (removeAll (h, U) qs) \\<Longrightarrow>\n    q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "with 1 2"], ["proof (chain)\npicking this:\n  poly_deg (fst q) = d0\n  m < card (snd q)\n  q \\<in> set (removeAll (h, U) qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg (fst q) = d0\n  m < card (snd q)\n  q \\<in> set (removeAll (h, U) qs)\n\ngoal (1 subgoal):\n 1. q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "by simp"], ["proof (state)\nthis:\n  q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {q \\<in> set (shift_list (h, U) x qs).\n   poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<subseteq> {q \\<in> set qs.\n               poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  finite {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  {q \\<in> set (shift_list (h, U) x qs).\n   poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<subseteq> {q \\<in> set qs.\n               poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "have \"card ?C \\<le> card ?A\""], ["proof (prove)\nusing this:\n  finite {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  {q \\<in> set (shift_list (h, U) x qs).\n   poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<subseteq> {q \\<in> set qs.\n               poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (shift_list (h, U) x qs).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> card\n           {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "by (rule card_mono)"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (shift_list (h, U) x qs).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "also"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (shift_list (h, U) x qs).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from inv2 \\<open>d0 < d\\<close>"], ["proof (chain)\npicking this:\n  shift2_inv qs\n  d0 < d", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\nusing this:\n  shift2_inv qs\n  d0 < d\n\ngoal (1 subgoal):\n 1. card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < d \\<Longrightarrow>\n       card\n        {q \\<in> set (shift_list (h, U) x qs).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  card\n   {q \\<in> set (shift_list (h, U) x qs).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1", "show \"card ?C \\<le> 1\""], ["proof (prove)\nusing this:\n  card\n   {q \\<in> set (shift_list (h, U) x qs).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (shift_list (h, U) x qs).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "."], ["proof (state)\nthis:\n  card\n   {q \\<in> set (shift_list (h, U) x qs).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift1_inv (shift_list (h, U) x qs, B - {(h, U)})\n\ngoal:\nNo subgoals!", "qed"], ["", "function (domintros) shift1 :: \"(((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<times> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) set) \\<Rightarrow>\n                                (((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<times>\n                                  ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) \\<times> 'x set) set)\"\n  where\n  \"shift1 (qs, B) =\n      (if 1 < card B then\n        let (h, U) = SOME b. b \\<in> B \\<and> card (snd b) = Suc m; x = SOME y. y \\<in> U in\n          shift1 (shift_list (h, U) x qs, B - {(h, U)})\n      else (qs, B))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>qs B. x = (qs, B) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>qs B qsa Ba.\n       (qs, B) = (qsa, Ba) \\<Longrightarrow>\n       (if 1 < card B\n        then let (h, U) = SOME b. b \\<in> B \\<and> card (snd b) = Suc m;\n                 x = SOME y. y \\<in> U\n             in shift1_sumC (shift_list (h, U) x qs, B - {(h, U)})\n        else (qs, B)) =\n       (if 1 < card Ba\n        then let (h, U) = SOME b. b \\<in> Ba \\<and> card (snd b) = Suc m;\n                 x = SOME y. y \\<in> U\n             in shift1_sumC (shift_list (h, U) x qsa, Ba - {(h, U)})\n        else (qsa, Ba))", "by auto"], ["", "lemma shift1_domI:\n  assumes \"shift1_inv args\"\n  shows \"shift1_dom args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_dom args", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_dom args", "from wf_measure[of \"card \\<circ> snd\"]"], ["proof (chain)\npicking this:\n  wf (measure (card \\<circ> snd))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf (measure (card \\<circ> snd))\n\ngoal (1 subgoal):\n 1. shift1_dom args", "using assms"], ["proof (prove)\nusing this:\n  wf (measure (card \\<circ> snd))\n  shift1_inv args\n\ngoal (1 subgoal):\n 1. shift1_dom args", "proof (induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> measure (card \\<circ> snd);\n                    shift1_inv y\\<rbrakk>\n                   \\<Longrightarrow> shift1_dom y;\n        shift1_inv x\\<rbrakk>\n       \\<Longrightarrow> shift1_dom x", "case (less args)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y39, args) \\<in> measure (card \\<circ> snd);\n   shift1_inv ?y39\\<rbrakk>\n  \\<Longrightarrow> shift1_dom ?y39\n  shift1_inv args\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> measure (card \\<circ> snd);\n                    shift1_inv y\\<rbrakk>\n                   \\<Longrightarrow> shift1_dom y;\n        shift1_inv x\\<rbrakk>\n       \\<Longrightarrow> shift1_dom x", "obtain qs B where args: \"args = (qs, B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs B. args = (qs, B) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>qs B. args = (qs, B) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  args = (qs, B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> measure (card \\<circ> snd);\n                    shift1_inv y\\<rbrakk>\n                   \\<Longrightarrow> shift1_dom y;\n        shift1_inv x\\<rbrakk>\n       \\<Longrightarrow> shift1_dom x", "have IH: \"shift1_dom (qs0, B0)\" if \"card B0 < card B\" and \"shift1_inv (qs0, B0)\"\n      for qs0 and B0::\"((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_dom (qs0, B0)", "using _ that(2)"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  shift1_inv (qs0, B0)\n\ngoal (1 subgoal):\n 1. shift1_dom (qs0, B0)", "proof (rule less)"], ["proof (state)\ngoal (1 subgoal):\n 1. ((qs0, B0), args) \\<in> measure (card \\<circ> snd)", "from that(1)"], ["proof (chain)\npicking this:\n  card B0 < card B", "show \"((qs0, B0), args) \\<in> measure (card \\<circ> snd)\""], ["proof (prove)\nusing this:\n  card B0 < card B\n\ngoal (1 subgoal):\n 1. ((qs0, B0), args) \\<in> measure (card \\<circ> snd)", "by (simp add: args)"], ["proof (state)\nthis:\n  ((qs0, B0), args) \\<in> measure (card \\<circ> snd)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>card ?B0.39 < card B; shift1_inv (?qs0.39, ?B0.39)\\<rbrakk>\n  \\<Longrightarrow> shift1_dom (?qs0.39, ?B0.39)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> measure (card \\<circ> snd);\n                    shift1_inv y\\<rbrakk>\n                   \\<Longrightarrow> shift1_dom y;\n        shift1_inv x\\<rbrakk>\n       \\<Longrightarrow> shift1_dom x", "from less(2)"], ["proof (chain)\npicking this:\n  shift1_inv args", "have inv: \"shift1_inv (qs, B)\""], ["proof (prove)\nusing this:\n  shift1_inv args\n\ngoal (1 subgoal):\n 1. shift1_inv (qs, B)", "by (simp only: args)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> measure (card \\<circ> snd);\n                    shift1_inv y\\<rbrakk>\n                   \\<Longrightarrow> shift1_dom y;\n        shift1_inv x\\<rbrakk>\n       \\<Longrightarrow> shift1_dom x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_dom args", "unfolding args"], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_dom (qs, B)", "proof (rule shift1.domintros)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba xa ya.\n       \\<lbrakk>Suc 0 < card B;\n        (aa, ba) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        (xa, ya) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\\<rbrakk>\n       \\<Longrightarrow> shift1_dom\n                          (shift_list\n                            (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n                            (SOME y. y \\<in> ya) qs,\n                           B -\n                           {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "fix h U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba xa ya.\n       \\<lbrakk>Suc 0 < card B;\n        (aa, ba) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        (xa, ya) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\\<rbrakk>\n       \\<Longrightarrow> shift1_dom\n                          (shift_list\n                            (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n                            (SOME y. y \\<in> ya) qs,\n                           B -\n                           {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "assume hU: \"(h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\""], ["proof (state)\nthis:\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>aa ba xa ya.\n       \\<lbrakk>Suc 0 < card B;\n        (aa, ba) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        (xa, ya) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\\<rbrakk>\n       \\<Longrightarrow> shift1_dom\n                          (shift_list\n                            (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n                            (SOME y. y \\<in> ya) qs,\n                           B -\n                           {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "define x where \"x = (SOME y. y \\<in> U)\""], ["proof (state)\nthis:\n  x = (SOME y. y \\<in> U)\n\ngoal (1 subgoal):\n 1. \\<And>aa ba xa ya.\n       \\<lbrakk>Suc 0 < card B;\n        (aa, ba) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        (xa, ya) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\\<rbrakk>\n       \\<Longrightarrow> shift1_dom\n                          (shift_list\n                            (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n                            (SOME y. y \\<in> ya) qs,\n                           B -\n                           {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "assume \"Suc 0 < card B\""], ["proof (state)\nthis:\n  Suc 0 < card B\n\ngoal (1 subgoal):\n 1. \\<And>aa ba xa ya.\n       \\<lbrakk>Suc 0 < card B;\n        (aa, ba) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        (xa, ya) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\\<rbrakk>\n       \\<Longrightarrow> shift1_dom\n                          (shift_list\n                            (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n                            (SOME y. y \\<in> ya) qs,\n                           B -\n                           {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "hence \"1 < card B\""], ["proof (prove)\nusing this:\n  Suc 0 < card B\n\ngoal (1 subgoal):\n 1. 1 < card B", "by simp"], ["proof (state)\nthis:\n  1 < card B\n\ngoal (1 subgoal):\n 1. \\<And>aa ba xa ya.\n       \\<lbrakk>Suc 0 < card B;\n        (aa, ba) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        (xa, ya) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\\<rbrakk>\n       \\<Longrightarrow> shift1_dom\n                          (shift_list\n                            (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n                            (SOME y. y \\<in> ya) qs,\n                           B -\n                           {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "have \"shift1_dom (shift_list (h, U) x qs, B - {(h, U)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_dom (shift_list (h, U) x qs, B - {(h, U)})", "proof (rule IH)"], ["proof (state)\ngoal (2 subgoals):\n 1. card (B - {(h, U)}) < card B\n 2. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from inv"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"finite B\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. finite B", "by (rule shift1_inv_finite_snd)"], ["proof (state)\nthis:\n  finite B\n\ngoal (2 subgoals):\n 1. card (B - {(h, U)}) < card B\n 2. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "moreover"], ["proof (state)\nthis:\n  finite B\n\ngoal (2 subgoals):\n 1. card (B - {(h, U)}) < card B\n 2. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from inv \\<open>1 < card B\\<close> hU"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)", "have \"(h, U) \\<in> B\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> B", "by (rule shift1_inv_some_snd)"], ["proof (state)\nthis:\n  (h, U) \\<in> B\n\ngoal (2 subgoals):\n 1. card (B - {(h, U)}) < card B\n 2. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "ultimately"], ["proof (chain)\npicking this:\n  finite B\n  (h, U) \\<in> B", "show \"card (B - {(h, U)}) < card B\""], ["proof (prove)\nusing this:\n  finite B\n  (h, U) \\<in> B\n\ngoal (1 subgoal):\n 1. card (B - {(h, U)}) < card B", "by (rule card_Diff1_less)"], ["proof (state)\nthis:\n  card (B - {(h, U)}) < card B\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from inv \\<open>1 < card B\\<close> hU x_def"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)", "show \"shift1_inv (shift_list (h, U) x qs, (B - {(h, U)}))\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "by (rule shift1_inv_preserved)"], ["proof (state)\nthis:\n  shift1_inv (shift_list (h, U) x qs, B - {(h, U)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift1_dom (shift_list (h, U) x qs, B - {(h, U)})\n\ngoal (1 subgoal):\n 1. \\<And>aa ba xa ya.\n       \\<lbrakk>Suc 0 < card B;\n        (aa, ba) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        (xa, ya) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\\<rbrakk>\n       \\<Longrightarrow> shift1_dom\n                          (shift_list\n                            (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n                            (SOME y. y \\<in> ya) qs,\n                           B -\n                           {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "thus \"shift1_dom (shift_list (SOME b. b \\<in> B \\<and> card (snd b) = Suc m) (SOME y. y \\<in> U) qs,\n                    B - {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})\""], ["proof (prove)\nusing this:\n  shift1_dom (shift_list (h, U) x qs, B - {(h, U)})\n\ngoal (1 subgoal):\n 1. shift1_dom\n     (shift_list (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n       (SOME y. y \\<in> U) qs,\n      B - {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})", "by (simp add: hU x_def)"], ["proof (state)\nthis:\n  shift1_dom\n   (shift_list (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n     (SOME y. y \\<in> U) qs,\n    B - {SOME b. b \\<in> B \\<and> card (snd b) = Suc m})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift1_dom args\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift1_dom args\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_induct [consumes 1, case_names base step]:\n  assumes \"shift1_inv args\"\n  assumes \"\\<And>qs B. shift1_inv (qs, B) \\<Longrightarrow> card B \\<le> 1 \\<Longrightarrow> P (qs, B) (qs, B)\"\n  assumes \"\\<And>qs B h U x. shift1_inv (qs, B) \\<Longrightarrow> 1 < card B \\<Longrightarrow>\n            (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m) \\<Longrightarrow> x = (SOME y. y \\<in> U) \\<Longrightarrow>\n            finite U \\<Longrightarrow> x \\<in> U \\<Longrightarrow> card (U - {x}) = m \\<Longrightarrow>\n            P (shift_list (h, U) x qs, B - {(h, U)}) (shift1 (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n            P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\"\n  shows \"P args (shift1 args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P args (shift1 args)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P args (shift1 args)", "from assms(1)"], ["proof (chain)\npicking this:\n  shift1_inv args", "have \"shift1_dom args\""], ["proof (prove)\nusing this:\n  shift1_inv args\n\ngoal (1 subgoal):\n 1. shift1_dom args", "by (rule shift1_domI)"], ["proof (state)\nthis:\n  shift1_dom args\n\ngoal (1 subgoal):\n 1. P args (shift1 args)", "thus ?thesis"], ["proof (prove)\nusing this:\n  shift1_dom args\n\ngoal (1 subgoal):\n 1. P args (shift1 args)", "using assms(1)"], ["proof (prove)\nusing this:\n  shift1_dom args\n  shift1_inv args\n\ngoal (1 subgoal):\n 1. P args (shift1 args)", "proof (induct args rule: shift1.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_dom (qs, B);\n        \\<And>x xa y xb.\n           \\<lbrakk>1 < card B;\n            x = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n            (xa, y) = x; xb = (SOME ya. ya \\<in> y);\n            shift1_inv (shift_list (xa, y) xb qs, B - {(xa, y)})\\<rbrakk>\n           \\<Longrightarrow> P (shift_list (xa, y) xb qs, B - {(xa, y)})\n                              (shift1\n                                (shift_list (xa, y) xb qs, B - {(xa, y)}));\n        shift1_inv (qs, B)\\<rbrakk>\n       \\<Longrightarrow> P (qs, B) (shift1 (qs, B))", "case step: (1 qs B)"], ["proof (state)\nthis:\n  shift1_dom (qs, B)\n  \\<lbrakk>1 < card B;\n   ?x39 = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n   (?xa39, ?y39) = ?x39; ?xb39 = (SOME y. y \\<in> ?y39);\n   shift1_inv\n    (shift_list (?xa39, ?y39) ?xb39 qs, B - {(?xa39, ?y39)})\\<rbrakk>\n  \\<Longrightarrow> P (shift_list (?xa39, ?y39) ?xb39 qs,\n                       B - {(?xa39, ?y39)})\n                     (shift1\n                       (shift_list (?xa39, ?y39) ?xb39 qs,\n                        B - {(?xa39, ?y39)}))\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_dom (qs, B);\n        \\<And>x xa y xb.\n           \\<lbrakk>1 < card B;\n            x = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n            (xa, y) = x; xb = (SOME ya. ya \\<in> y);\n            shift1_inv (shift_list (xa, y) xb qs, B - {(xa, y)})\\<rbrakk>\n           \\<Longrightarrow> P (shift_list (xa, y) xb qs, B - {(xa, y)})\n                              (shift1\n                                (shift_list (xa, y) xb qs, B - {(xa, y)}));\n        shift1_inv (qs, B)\\<rbrakk>\n       \\<Longrightarrow> P (qs, B) (shift1 (qs, B))", "obtain h U where hU: \"(h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U.\n        (h, U) =\n        (SOME b. b \\<in> B \\<and> card (snd b) = Suc m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (smt prod.exhaust)"], ["proof (state)\nthis:\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_dom (qs, B);\n        \\<And>x xa y xb.\n           \\<lbrakk>1 < card B;\n            x = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n            (xa, y) = x; xb = (SOME ya. ya \\<in> y);\n            shift1_inv (shift_list (xa, y) xb qs, B - {(xa, y)})\\<rbrakk>\n           \\<Longrightarrow> P (shift_list (xa, y) xb qs, B - {(xa, y)})\n                              (shift1\n                                (shift_list (xa, y) xb qs, B - {(xa, y)}));\n        shift1_inv (qs, B)\\<rbrakk>\n       \\<Longrightarrow> P (qs, B) (shift1 (qs, B))", "define x where \"x = (SOME y. y \\<in> U)\""], ["proof (state)\nthis:\n  x = (SOME y. y \\<in> U)\n\ngoal (1 subgoal):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_dom (qs, B);\n        \\<And>x xa y xb.\n           \\<lbrakk>1 < card B;\n            x = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n            (xa, y) = x; xb = (SOME ya. ya \\<in> y);\n            shift1_inv (shift_list (xa, y) xb qs, B - {(xa, y)})\\<rbrakk>\n           \\<Longrightarrow> P (shift_list (xa, y) xb qs, B - {(xa, y)})\n                              (shift1\n                                (shift_list (xa, y) xb qs, B - {(xa, y)}));\n        shift1_inv (qs, B)\\<rbrakk>\n       \\<Longrightarrow> P (qs, B) (shift1 (qs, B))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (qs, B) (shift1 (qs, B))", "proof (simp add: shift1.psimps[OF step.hyps(1)] flip: hU x_def del: One_nat_def,\n          intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "let ?args = \"(shift_list (h, U) x qs, B - {(h, U)})\""], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "assume \"1 < card B\""], ["proof (state)\nthis:\n  1 < card B\n\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "with step.prems"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B", "have card_U: \"card U = Suc m\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n\ngoal (1 subgoal):\n 1. card U = Suc m", "using hU"], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. card U = Suc m", "by (rule shift1_inv_some_snd)"], ["proof (state)\nthis:\n  card U = Suc m\n\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "from card_U"], ["proof (chain)\npicking this:\n  card U = Suc m", "have \"finite U\""], ["proof (prove)\nusing this:\n  card U = Suc m\n\ngoal (1 subgoal):\n 1. finite U", "using card.infinite"], ["proof (prove)\nusing this:\n  card U = Suc m\n  infinite ?A \\<Longrightarrow> card ?A = 0\n\ngoal (1 subgoal):\n 1. finite U", "by fastforce"], ["proof (state)\nthis:\n  finite U\n\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "from card_U"], ["proof (chain)\npicking this:\n  card U = Suc m", "have \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  card U = Suc m\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "then"], ["proof (chain)\npicking this:\n  U \\<noteq> {}", "obtain y where \"y \\<in> U\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> U\n\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "hence \"x \\<in> U\""], ["proof (prove)\nusing this:\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. x \\<in> U", "unfolding x_def"], ["proof (prove)\nusing this:\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. (SOME y. y \\<in> U) \\<in> U", "by (rule someI)"], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (2 subgoals):\n 1. 1 < card B \\<Longrightarrow>\n    P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n 2. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "with step.prems \\<open>1 < card B\\<close> hU x_def \\<open>finite U\\<close>"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U", "show \"P (qs, B) (shift1 ?args)\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))", "proof (rule assms(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. card (U - {x}) = m\n 2. P (shift_list (h, U) x qs, B - {(h, U)})\n     (shift1 (shift_list (h, U) x qs, B - {(h, U)}))", "from \\<open>finite U\\<close> \\<open>x \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  finite U\n  x \\<in> U", "show \"card (U - {x}) = m\""], ["proof (prove)\nusing this:\n  finite U\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. card (U - {x}) = m", "by (simp add: card_U)"], ["proof (state)\nthis:\n  card (U - {x}) = m\n\ngoal (1 subgoal):\n 1. P (shift_list (h, U) x qs, B - {(h, U)})\n     (shift1 (shift_list (h, U) x qs, B - {(h, U)}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P (shift_list (h, U) x qs, B - {(h, U)})\n     (shift1 (shift_list (h, U) x qs, B - {(h, U)}))", "from \\<open>1 < card B\\<close> refl hU x_def"], ["proof (chain)\npicking this:\n  1 < card B\n  ?t = ?t\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)", "show \"P ?args (shift1 ?args)\""], ["proof (prove)\nusing this:\n  1 < card B\n  ?t = ?t\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n\ngoal (1 subgoal):\n 1. P (shift_list (h, U) x qs, B - {(h, U)})\n     (shift1 (shift_list (h, U) x qs, B - {(h, U)}))", "proof (rule step.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "from step.prems \\<open>1 < card B\\<close> hU x_def"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)", "show \"shift1_inv ?args\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n\ngoal (1 subgoal):\n 1. shift1_inv (shift_list (h, U) x qs, B - {(h, U)})", "by (rule shift1_inv_preserved)"], ["proof (state)\nthis:\n  shift1_inv (shift_list (h, U) x qs, B - {(h, U)})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (shift_list (h, U) x qs, B - {(h, U)})\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (qs, B) (shift1 (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal (1 subgoal):\n 1. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "assume \"\\<not> 1 < card B\""], ["proof (state)\nthis:\n  \\<not> 1 < card B\n\ngoal (1 subgoal):\n 1. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "hence \"card B \\<le> 1\""], ["proof (prove)\nusing this:\n  \\<not> 1 < card B\n\ngoal (1 subgoal):\n 1. card B \\<le> 1", "by simp"], ["proof (state)\nthis:\n  card B \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> 1 < card B \\<Longrightarrow> P (qs, B) (qs, B)", "with step.prems"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  card B \\<le> 1", "show \"P (qs, B) (qs, B)\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n\ngoal (1 subgoal):\n 1. P (qs, B) (qs, B)", "by (rule assms(2))"], ["proof (state)\nthis:\n  P (qs, B) (qs, B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (qs, B) (shift1 (qs, B))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P args (shift1 args)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_1:\n  assumes \"shift1_inv args\" and \"d0 \\<le> d\"\n  shows \"card {q \\<in> set (fst (shift1 args)). poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (shift1 args)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "using assms(1)"], ["proof (prove)\nusing this:\n  shift1_inv args\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (shift1 args)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "proof (induct args rule: shift1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst (qs, B)).\n                           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n                         \\<le> 1\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n        \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n                         \\<le> 1", "case (base qs B)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst (qs, B)).\n                           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n                         \\<le> 1\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n        \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n                         \\<le> 1", "from assms(2)"], ["proof (chain)\npicking this:\n  d0 \\<le> d", "have \"d0 < d \\<or> d0 = d\""], ["proof (prove)\nusing this:\n  d0 \\<le> d\n\ngoal (1 subgoal):\n 1. d0 < d \\<or> d0 = d", "by auto"], ["proof (state)\nthis:\n  d0 < d \\<or> d0 = d\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst (qs, B)).\n                           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n                         \\<le> 1\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n        \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n                         \\<le> 1", "thus ?case"], ["proof (prove)\nusing this:\n  d0 < d \\<or> d0 = d\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d0 < d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1\n 2. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "from base(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"shift2_inv qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. shift2_inv qs", "by (rule shift1_invD)"], ["proof (state)\nthis:\n  shift2_inv qs\n\ngoal (2 subgoals):\n 1. d0 < d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1\n 2. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "moreover"], ["proof (state)\nthis:\n  shift2_inv qs\n\ngoal (2 subgoals):\n 1. d0 < d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1\n 2. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "assume \"d0 < d\""], ["proof (state)\nthis:\n  d0 < d\n\ngoal (2 subgoals):\n 1. d0 < d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1\n 2. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  shift2_inv qs\n  d0 < d", "show ?thesis"], ["proof (prove)\nusing this:\n  shift2_inv qs\n  d0 < d\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "unfolding fst_conv"], ["proof (prove)\nusing this:\n  shift2_inv qs\n  d0 < d\n\ngoal (1 subgoal):\n 1. card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (fst (qs, B)).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "assume \"d0 = d\""], ["proof (state)\nthis:\n  d0 = d\n\ngoal (1 subgoal):\n 1. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "from base(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"B = {q \\<in> set (fst (qs, B)). poly_deg (fst q) = d0 \\<and> m < card (snd q)}\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B =\n    {q \\<in> set (fst (qs, B)).\n     poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "unfolding fst_conv \\<open>d0 = d\\<close>"], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}", "by (rule shift1_invD)"], ["proof (state)\nthis:\n  B =\n  {q \\<in> set (fst (qs, B)). poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. d0 = d \\<Longrightarrow>\n    card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "with base(2)"], ["proof (chain)\npicking this:\n  card B \\<le> 1\n  B =\n  {q \\<in> set (fst (qs, B)). poly_deg (fst q) = d0 \\<and> m < card (snd q)}", "show ?thesis"], ["proof (prove)\nusing this:\n  card B \\<le> 1\n  B =\n  {q \\<in> set (fst (qs, B)). poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (qs, B)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "by simp"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (fst (qs, B)).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (fst (qs, B)).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n        \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n                         \\<le> 1", "qed"], ["", "lemma shift1_2:\n  \"shift1_inv args \\<Longrightarrow>\n    card {q \\<in> set (fst (shift1 args)). m < card (snd q)} \\<le> card {q \\<in> set (fst args). m < card (snd q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_inv args \\<Longrightarrow>\n    card {q \\<in> set (fst (shift1 args)). m < card (snd q)}\n    \\<le> card {q \\<in> set (fst args). m < card (snd q)}", "proof (induct args rule: shift1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "case (base qs B)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n    \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}", ".."], ["proof (state)\nthis:\n  card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n  \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "case (step qs B h U x)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U\n  card (U - {x}) = m\n  card\n   {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n          m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "let ?x = \"Poly_Mapping.single x (1::nat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "let ?p1 = \"(punit.monom_mult 1 ?x h, U)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "let ?A = \"{q \\<in> set qs. m < card (snd q)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "from step(1-3)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)", "have card_U: \"card U = Suc m\" and \"(h, U) \\<in> set qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. card U = Suc m &&& (h, U) \\<in> set qs", "by (rule shift1_inv_some_snd)+"], ["proof (state)\nthis:\n  card U = Suc m\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "from step(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"shift2_inv qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. shift2_inv qs", "by (rule shift1_invD)"], ["proof (state)\nthis:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "hence \"valid_decomp X qs\""], ["proof (prove)\nusing this:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. valid_decomp X qs", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "hence \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "using \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by (rule valid_decompD)"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "have fin1: \"finite ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {q \\<in> set qs. m < card (snd q)}", "by auto"], ["proof (state)\nthis:\n  finite {q \\<in> set qs. m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "hence fin2: \"finite (insert ?p1 ?A)\""], ["proof (prove)\nusing this:\n  finite {q \\<in> set qs. m < card (snd q)}\n\ngoal (1 subgoal):\n 1. finite\n     (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n       {q \\<in> set qs. m < card (snd q)})", "by simp"], ["proof (state)\nthis:\n  finite\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)})\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "from \\<open>(h, U) \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  (h, U) \\<in> set qs", "have hU_in: \"(h, U) \\<in> insert ?p1 ?A\""], ["proof (prove)\nusing this:\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. (h, U)\n    \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n           {q \\<in> set qs. m < card (snd q)}", "by (simp add: card_U)"], ["proof (state)\nthis:\n  (h, U)\n  \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n         {q \\<in> set qs. m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "have \"?p1 \\<noteq> (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<noteq> (h, U)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) =\n    (h, U) \\<Longrightarrow>\n    False", "assume \"?p1 = (h, U)\""], ["proof (state)\nthis:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) = (h, U)\n\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) =\n    (h, U) \\<Longrightarrow>\n    False", "hence \"lpp (punit.monom_mult 1 ?x h) = lpp h\""], ["proof (prove)\nusing this:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) = (h, U)\n\ngoal (1 subgoal):\n 1. lpp (local.punit.monom_mult (1::'a) (monomial 1 x) h) = lpp h", "by simp"], ["proof (state)\nthis:\n  lpp (local.punit.monom_mult (1::'a) (monomial 1 x) h) = lpp h\n\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) =\n    (h, U) \\<Longrightarrow>\n    False", "with \\<open>h \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  h \\<noteq> 0\n  lpp (local.punit.monom_mult (1::'a) (monomial 1 x) h) = lpp h", "show False"], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n  lpp (local.punit.monom_mult (1::'a) (monomial 1 x) h) = lpp h\n\ngoal (1 subgoal):\n 1. False", "by (simp add: punit.lt_monom_mult monomial_0_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<noteq> (h, U)\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "let ?qs = \"shift_list (h, U) x qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "have \"{q \\<in> set (fst (?qs, B - {(h, U)})). m < card (snd q)} = (insert ?p1 ?A) - {(h, U)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n     m < card (snd q)} =\n    insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)} -\n    {(h, U)}", "using step(7) card_U \\<open>?p1 \\<noteq> (h, U)\\<close>"], ["proof (prove)\nusing this:\n  card (U - {x}) = m\n  card U = Suc m\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U) \\<noteq> (h, U)\n\ngoal (1 subgoal):\n 1. {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n     m < card (snd q)} =\n    insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)} -\n    {(h, U)}", "by (fastforce simp: shift_list.simps)"], ["proof (state)\nthis:\n  {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n   m < card (snd q)} =\n  insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n   {q \\<in> set qs. m < card (snd q)} -\n  {(h, U)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "also"], ["proof (state)\nthis:\n  {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n   m < card (snd q)} =\n  insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n   {q \\<in> set qs. m < card (snd q)} -\n  {(h, U)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "from fin2 hU_in"], ["proof (chain)\npicking this:\n  finite\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)})\n  (h, U)\n  \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n         {q \\<in> set qs. m < card (snd q)}", "have \"card \\<dots> = card (insert ?p1 ?A) - 1\""], ["proof (prove)\nusing this:\n  finite\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)})\n  (h, U)\n  \\<in> insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n         {q \\<in> set qs. m < card (snd q)}\n\ngoal (1 subgoal):\n 1. card\n     (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n       {q \\<in> set qs. m < card (snd q)} -\n      {(h, U)}) =\n    card\n     (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n       {q \\<in> set qs. m < card (snd q)}) -\n    1", "by (simp add: card_Diff_singleton_if)"], ["proof (state)\nthis:\n  card\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)} -\n    {(h, U)}) =\n  card\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)}) -\n  1\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "also"], ["proof (state)\nthis:\n  card\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)} -\n    {(h, U)}) =\n  card\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)}) -\n  1\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "from fin1"], ["proof (chain)\npicking this:\n  finite {q \\<in> set qs. m < card (snd q)}", "have \"\\<dots> \\<le> Suc (card ?A) - 1\""], ["proof (prove)\nusing this:\n  finite {q \\<in> set qs. m < card (snd q)}\n\ngoal (1 subgoal):\n 1. card\n     (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n       {q \\<in> set qs. m < card (snd q)}) -\n    1\n    \\<le> Suc (card {q \\<in> set qs. m < card (snd q)}) - 1", "by (simp add: card_insert_if)"], ["proof (state)\nthis:\n  card\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)}) -\n  1\n  \\<le> Suc (card {q \\<in> set qs. m < card (snd q)}) - 1\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "also"], ["proof (state)\nthis:\n  card\n   (insert (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n     {q \\<in> set qs. m < card (snd q)}) -\n  1\n  \\<le> Suc (card {q \\<in> set qs. m < card (snd q)}) - 1\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "have \"\\<dots> = card {q \\<in> set (fst (qs, B)). m < card (snd q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card {q \\<in> set qs. m < card (snd q)}) - 1 =\n    card {q \\<in> set (fst (qs, B)). m < card (snd q)}", "by simp"], ["proof (state)\nthis:\n  Suc (card {q \\<in> set qs. m < card (snd q)}) - 1 =\n  card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "finally"], ["proof (chain)\npicking this:\n  card\n   {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n    m < card (snd q)}\n  \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}", "have \"card {q \\<in> set (fst (?qs, B - {(h, U)})). m < card (snd q)} \\<le>\n                  card {q \\<in> set (fst (qs, B)). m < card (snd q)}\""], ["proof (prove)\nusing this:\n  card\n   {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n    m < card (snd q)}\n  \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}", "."], ["proof (state)\nthis:\n  card\n   {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n    m < card (snd q)}\n  \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        card\n         {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n          m < card (snd q)}\n        \\<le> card\n               {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n                m < card (snd q)}\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (fst\n   (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n                           m < card (snd q)}\n                         \\<le> card\n                                {q \\<in> set (fst (qs, B)).\n                                 m < card (snd q)}", "with step(8)"], ["proof (chain)\npicking this:\n  card\n   {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n          m < card (snd q)}\n  card\n   {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n    m < card (snd q)}\n  \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}", "show ?case"], ["proof (prove)\nusing this:\n  card\n   {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n          m < card (snd q)}\n  card\n   {q \\<in> set (fst (shift_list (h, U) x qs, B - {(h, U)})).\n    m < card (snd q)}\n  \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}", "by (rule le_trans)"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))).\n    m < card (snd q)}\n  \\<le> card {q \\<in> set (fst (qs, B)). m < card (snd q)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_3: \"shift1_inv args \\<Longrightarrow> cone_decomp T (fst args) \\<Longrightarrow> cone_decomp T (fst (shift1 args))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shift1_inv args; cone_decomp T (fst args)\\<rbrakk>\n    \\<Longrightarrow> cone_decomp T (fst (shift1 args))", "proof (induct args rule: shift1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1;\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (fst (qs, B))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "case (base qs B)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n  cone_decomp T (fst (qs, B))\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1;\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (fst (qs, B))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from base(3)"], ["proof (chain)\npicking this:\n  cone_decomp T (fst (qs, B))", "show ?case"], ["proof (prove)\nusing this:\n  cone_decomp T (fst (qs, B))\n\ngoal (1 subgoal):\n 1. cone_decomp T (fst (qs, B))", "."], ["proof (state)\nthis:\n  cone_decomp T (fst (qs, B))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "case (step qs B h U x)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U\n  card (U - {x}) = m\n  cone_decomp T\n   (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n  cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))\n  cone_decomp T (fst (qs, B))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from step.hyps(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"shift2_inv qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. shift2_inv qs", "by (rule shift1_invD)"], ["proof (state)\nthis:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "hence \"valid_decomp X qs\""], ["proof (prove)\nusing this:\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. valid_decomp X qs", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "moreover"], ["proof (state)\nthis:\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from step.prems"], ["proof (chain)\npicking this:\n  cone_decomp T (fst (qs, B))", "have \"cone_decomp T qs\""], ["proof (prove)\nusing this:\n  cone_decomp T (fst (qs, B))\n\ngoal (1 subgoal):\n 1. cone_decomp T qs", "by (simp only: fst_conv)"], ["proof (state)\nthis:\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "moreover"], ["proof (state)\nthis:\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from step.hyps(1-3)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)", "have \"(h, U) \\<in> set qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", "by (rule shift1_inv_some_snd)"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "ultimately"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  cone_decomp T qs\n  (h, U) \\<in> set qs", "have \"cone_decomp T (fst (shift_list (h, U) x qs, B - {(h, U)}))\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  cone_decomp T qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (fst (shift_list (h, U) x qs, B - {(h, U)}))", "unfolding fst_conv"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  cone_decomp T qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x qs)", "using step.hyps(6)"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  cone_decomp T qs\n  (h, U) \\<in> set qs\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. cone_decomp T (shift_list (h, U) x qs)", "by (rule cone_decomp_shift_list)"], ["proof (state)\nthis:\n  cone_decomp T (fst (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        cone_decomp T\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        cone_decomp T (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "thus ?case"], ["proof (prove)\nusing this:\n  cone_decomp T (fst (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal (1 subgoal):\n 1. cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))", "by (rule step.hyps(8))"], ["proof (state)\nthis:\n  cone_decomp T (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_4:\n  \"shift1_inv args \\<Longrightarrow>\n    Max (poly_deg ` fst ` set (fst args)) \\<le> Max (poly_deg ` fst ` set (fst (shift1 args)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_inv args \\<Longrightarrow>\n    Max (poly_deg ` fst ` set (fst args))\n    \\<le> Max (poly_deg ` fst ` set (fst (shift1 args)))", "proof (induct args rule: shift1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg ` fst ` set (fst (qs, B)))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "case (base qs B)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg ` fst ` set (fst (qs, B)))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set (fst (qs, B)))\n    \\<le> Max (poly_deg ` fst ` set (fst (qs, B)))", ".."], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set (fst (qs, B)))\n  \\<le> Max (poly_deg ` fst ` set (fst (qs, B)))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "case (step qs B h U x)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U\n  card (U - {x}) = m\n  Max (poly_deg ` fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n  \\<le> Max (poly_deg `\n             fst `\n             set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "let ?x = \"Poly_Mapping.single x 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "let ?p1 = \"(punit.monom_mult 1 ?x h, U)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "let ?qs = \"shift_list (h, U) x qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "from step(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\"\n    and inv2: \"shift2_inv qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} &&&\n    shift2_inv qs", "by (rule shift1_invD)+"], ["proof (state)\nthis:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "from this(1)"], ["proof (chain)\npicking this:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}", "have \"B \\<subseteq> set qs\""], ["proof (prove)\nusing this:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. B \\<subseteq> set qs", "by auto"], ["proof (state)\nthis:\n  B \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "with step(2)"], ["proof (chain)\npicking this:\n  1 < card B\n  B \\<subseteq> set qs", "have \"set qs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  1 < card B\n  B \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. set qs \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  set qs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "have fin: \"finite (poly_deg ` fst ` set ?qs)\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set (shift_list (h, U) x qs))", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set (shift_list (h, U) x qs))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "have \"Max (poly_deg ` fst ` set (fst (qs, B))) \\<le> Max (poly_deg ` fst ` set (fst (?qs, B - {(h, U)})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set (fst (qs, B)))\n    \\<le> Max (poly_deg `\n               fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))", "unfolding fst_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "proof (rule Max.boundedI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (poly_deg ` fst ` set qs)\n 2. poly_deg ` fst ` set qs \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "show \"finite (poly_deg ` fst ` set qs)\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. finite (poly_deg ` fst ` set qs)", "by (intro finite_imageI)"], ["proof (state)\nthis:\n  finite (poly_deg ` fst ` set qs)\n\ngoal (2 subgoals):\n 1. poly_deg ` fst ` set qs \\<noteq> {}\n 2. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_deg ` fst ` set qs \\<noteq> {}\n 2. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "from \\<open>set qs \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  set qs \\<noteq> {}", "show \"poly_deg ` fst ` set qs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  set qs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. poly_deg ` fst ` set qs \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  poly_deg ` fst ` set qs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "assume \"a \\<in> poly_deg ` fst ` set qs\""], ["proof (state)\nthis:\n  a \\<in> poly_deg ` fst ` set qs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "then"], ["proof (chain)\npicking this:\n  a \\<in> poly_deg ` fst ` set qs", "obtain q where \"q \\<in> set qs\" and a: \"a = poly_deg (fst q)\""], ["proof (prove)\nusing this:\n  a \\<in> poly_deg ` fst ` set qs\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set qs; a = poly_deg (fst q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> set qs\n  a = poly_deg (fst q)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> poly_deg ` fst ` set qs \\<Longrightarrow>\n       a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "show \"a \\<le> Max (poly_deg ` fst ` set ?qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "proof (cases \"q = (h, U)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n 2. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "case True"], ["proof (state)\nthis:\n  q = (h, U)\n\ngoal (2 subgoals):\n 1. q = (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n 2. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "hence \"a \\<le> poly_deg (fst ?p1)\""], ["proof (prove)\nusing this:\n  q = (h, U)\n\ngoal (1 subgoal):\n 1. a \\<le> poly_deg\n             (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))", "by (cases \"h = 0\") (simp_all add: a poly_deg_monom_mult)"], ["proof (state)\nthis:\n  a \\<le> poly_deg\n           (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n\ngoal (2 subgoals):\n 1. q = (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n 2. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "also"], ["proof (state)\nthis:\n  a \\<le> poly_deg\n           (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n\ngoal (2 subgoals):\n 1. q = (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n 2. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "from fin"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (shift_list (h, U) x qs))", "have \"\\<dots> \\<le> Max (poly_deg ` fst ` set ?qs)\""], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (shift_list (h, U) x qs))\n\ngoal (1 subgoal):\n 1. poly_deg (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n    \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "proof (rule Max_ge)"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n    \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)", "have \"?p1 \\<in> set ?qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n    \\<in> set (shift_list (h, U) x qs)", "by (simp add: shift_list.simps)"], ["proof (state)\nthis:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n  \\<in> set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. poly_deg (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n    \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)", "thus \"poly_deg (fst ?p1) \\<in> poly_deg ` fst ` set ?qs\""], ["proof (prove)\nusing this:\n  (local.punit.monom_mult (1::'a) (monomial 1 x) h, U)\n  \\<in> set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. poly_deg (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n    \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)", "by (intro imageI)"], ["proof (state)\nthis:\n  poly_deg (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n  \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_deg (fst (local.punit.monom_mult (1::'a) (monomial 1 x) h, U))\n  \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n\ngoal (2 subgoals):\n 1. q = (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n 2. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "finally"], ["proof (chain)\npicking this:\n  a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n\ngoal (1 subgoal):\n 1. a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "."], ["proof (state)\nthis:\n  a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n\ngoal (1 subgoal):\n 1. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "case False"], ["proof (state)\nthis:\n  q \\<noteq> (h, U)\n\ngoal (1 subgoal):\n 1. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "with \\<open>q \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> set qs\n  q \\<noteq> (h, U)", "have \"q \\<in> set ?qs\""], ["proof (prove)\nusing this:\n  q \\<in> set qs\n  q \\<noteq> (h, U)\n\ngoal (1 subgoal):\n 1. q \\<in> set (shift_list (h, U) x qs)", "by (simp add: shift_list.simps)"], ["proof (state)\nthis:\n  q \\<in> set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "hence \"a \\<in> poly_deg ` fst ` set ?qs\""], ["proof (prove)\nusing this:\n  q \\<in> set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. a \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)", "unfolding a"], ["proof (prove)\nusing this:\n  q \\<in> set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. poly_deg (fst q) \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)", "by (intro imageI)"], ["proof (state)\nthis:\n  a \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. q \\<noteq> (h, U) \\<Longrightarrow>\n    a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "with fin"], ["proof (chain)\npicking this:\n  finite (poly_deg ` fst ` set (shift_list (h, U) x qs))\n  a \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (poly_deg ` fst ` set (shift_list (h, U) x qs))\n  a \\<in> poly_deg ` fst ` set (shift_list (h, U) x qs)\n\ngoal (1 subgoal):\n 1. a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))", "by (rule Max_ge)"], ["proof (state)\nthis:\n  a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<le> Max (poly_deg ` fst ` set (shift_list (h, U) x qs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set (fst (qs, B)))\n  \\<le> Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n        \\<le> Max (poly_deg `\n                   fst `\n                   set (fst (shift1\n                              (shift_list (h, U) x qs,\n                               B - {(h, U)}))))\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set (fst (qs, B)))\n                         \\<le> Max (poly_deg `\n                                    fst `\n                                    set (fst\n    (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "thus ?case"], ["proof (prove)\nusing this:\n  Max (poly_deg ` fst ` set (fst (qs, B)))\n  \\<le> Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set (fst (qs, B)))\n    \\<le> Max (poly_deg `\n               fst `\n               set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "using step(8)"], ["proof (prove)\nusing this:\n  Max (poly_deg ` fst ` set (fst (qs, B)))\n  \\<le> Max (poly_deg `\n             fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n  Max (poly_deg ` fst ` set (fst (shift_list (h, U) x qs, B - {(h, U)})))\n  \\<le> Max (poly_deg `\n             fst `\n             set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set (fst (qs, B)))\n    \\<le> Max (poly_deg `\n               fst `\n               set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))", "by (rule le_trans)"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set (fst (qs, B)))\n  \\<le> Max (poly_deg `\n             fst `\n             set (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)}))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_5: \"shift1_inv args \\<Longrightarrow> fst (shift1 args) = [] \\<longleftrightarrow> fst args = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift1_inv args \\<Longrightarrow>\n    (fst (shift1 args) = []) = (fst args = [])", "proof (induct args rule: shift1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> (fst (qs, B) = []) = (fst (qs, B) = [])\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "case (base qs B)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> (fst (qs, B) = []) = (fst (qs, B) = [])\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (qs, B) = []) = (fst (qs, B) = [])", ".."], ["proof (state)\nthis:\n  (fst (qs, B) = []) = (fst (qs, B) = [])\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "case (step qs B h U x)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U\n  card (U - {x}) = m\n  (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n  (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "let ?p1 = \"(punit.monom_mult 1 (Poly_Mapping.single x 1) h, U)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "let ?qs = \"shift_list (h, U) x qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "from step(1)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)", "have \"B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\"\n    and inv2: \"shift2_inv qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n\ngoal (1 subgoal):\n 1. B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)} &&&\n    shift2_inv qs", "by (rule shift1_invD)+"], ["proof (state)\nthis:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n  shift2_inv qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "from this(1)"], ["proof (chain)\npicking this:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}", "have \"B \\<subseteq> set qs\""], ["proof (prove)\nusing this:\n  B = {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. B \\<subseteq> set qs", "by auto"], ["proof (state)\nthis:\n  B \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "with step(2)"], ["proof (chain)\npicking this:\n  1 < card B\n  B \\<subseteq> set qs", "have \"qs \\<noteq> []\""], ["proof (prove)\nusing this:\n  1 < card B\n  B \\<subseteq> set qs\n\ngoal (1 subgoal):\n 1. qs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "moreover"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "have \"fst (shift1 (?qs, B - {(h, U)})) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) \\<noteq> []", "by (simp add: step.hyps(8) del: One_nat_def) (simp add: shift_list.simps)"], ["proof (state)\nthis:\n  fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n        (fst (shift_list (h, U) x qs, B - {(h, U)}) = [])\\<rbrakk>\n       \\<Longrightarrow> (fst (shift1\n                                (shift_list (h, U) x qs, B - {(h, U)})) =\n                          []) =\n                         (fst (qs, B) = [])", "ultimately"], ["proof (chain)\npicking this:\n  qs \\<noteq> []\n  fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  qs \\<noteq> []\n  fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n    (fst (qs, B) = [])", "by simp"], ["proof (state)\nthis:\n  (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})) = []) =\n  (fst (qs, B) = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_6: \"shift1_inv args \\<Longrightarrow> monomial_decomp (fst args) \\<Longrightarrow> monomial_decomp (fst (shift1 args))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shift1_inv args; monomial_decomp (fst args)\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (fst (shift1 args))", "proof (induct args rule: shift1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1;\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (qs, B))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        monomial_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        monomial_decomp\n         (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "case (base qs B)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n  monomial_decomp (fst (qs, B))\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1;\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (fst (qs, B))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        monomial_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        monomial_decomp\n         (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from base(3)"], ["proof (chain)\npicking this:\n  monomial_decomp (fst (qs, B))", "show ?case"], ["proof (prove)\nusing this:\n  monomial_decomp (fst (qs, B))\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst (qs, B))", "."], ["proof (state)\nthis:\n  monomial_decomp (fst (qs, B))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        monomial_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        monomial_decomp\n         (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        monomial_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        monomial_decomp\n         (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "case (step qs B h U x)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U\n  card (U - {x}) = m\n  monomial_decomp\n   (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n  monomial_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))\n  monomial_decomp (fst (qs, B))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        monomial_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        monomial_decomp\n         (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from step(1-3)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)", "have \"(h, U) \\<in> set qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", "by (rule shift1_inv_some_snd)"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        monomial_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        monomial_decomp\n         (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "with step.prems"], ["proof (chain)\npicking this:\n  monomial_decomp (fst (qs, B))\n  (h, U) \\<in> set qs", "have \"monomial_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))\""], ["proof (prove)\nusing this:\n  monomial_decomp (fst (qs, B))\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))", "unfolding fst_conv"], ["proof (prove)\nusing this:\n  monomial_decomp qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (shift_list (h, U) x qs)", "by (rule monomial_decomp_shift_list)"], ["proof (state)\nthis:\n  monomial_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        monomial_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        monomial_decomp\n         (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        monomial_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "thus ?case"], ["proof (prove)\nusing this:\n  monomial_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal (1 subgoal):\n 1. monomial_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))", "by (rule step.hyps)"], ["proof (state)\nthis:\n  monomial_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift1_7: \"shift1_inv args \\<Longrightarrow> hom_decomp (fst args) \\<Longrightarrow> hom_decomp (fst (shift1 args))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shift1_inv args; hom_decomp (fst args)\\<rbrakk>\n    \\<Longrightarrow> hom_decomp (fst (shift1 args))", "proof (induct args rule: shift1_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1;\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (fst (qs, B))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        hom_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "case (base qs B)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  card B \\<le> 1\n  hom_decomp (fst (qs, B))\n\ngoal (2 subgoals):\n 1. \\<And>qs B.\n       \\<lbrakk>shift1_inv (qs, B); card B \\<le> 1;\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (fst (qs, B))\n 2. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        hom_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from base(3)"], ["proof (chain)\npicking this:\n  hom_decomp (fst (qs, B))", "show ?case"], ["proof (prove)\nusing this:\n  hom_decomp (fst (qs, B))\n\ngoal (1 subgoal):\n 1. hom_decomp (fst (qs, B))", "."], ["proof (state)\nthis:\n  hom_decomp (fst (qs, B))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        hom_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        hom_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "case (step qs B h U x)"], ["proof (state)\nthis:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n  x = (SOME y. y \\<in> U)\n  finite U\n  x \\<in> U\n  card (U - {x}) = m\n  hom_decomp (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n  hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))\n  hom_decomp (fst (qs, B))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        hom_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "from step(1-3)"], ["proof (chain)\npicking this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)", "have \"(h, U) \\<in> set qs\""], ["proof (prove)\nusing this:\n  shift1_inv (qs, B)\n  1 < card B\n  (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m)\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set qs", "by (rule shift1_inv_some_snd)"], ["proof (state)\nthis:\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        hom_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "with step.prems"], ["proof (chain)\npicking this:\n  hom_decomp (fst (qs, B))\n  (h, U) \\<in> set qs", "have \"hom_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))\""], ["proof (prove)\nusing this:\n  hom_decomp (fst (qs, B))\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. hom_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))", "unfolding fst_conv"], ["proof (prove)\nusing this:\n  hom_decomp qs\n  (h, U) \\<in> set qs\n\ngoal (1 subgoal):\n 1. hom_decomp (shift_list (h, U) x qs)", "by (rule hom_decomp_shift_list)"], ["proof (state)\nthis:\n  hom_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal (1 subgoal):\n 1. \\<And>qs B h U x.\n       \\<lbrakk>shift1_inv (qs, B); 1 < card B;\n        (h, U) = (SOME b. b \\<in> B \\<and> card (snd b) = Suc m);\n        x = (SOME y. y \\<in> U); finite U; x \\<in> U; card (U - {x}) = m;\n        hom_decomp\n         (fst (shift_list (h, U) x qs, B - {(h, U)})) \\<Longrightarrow>\n        hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})));\n        hom_decomp (fst (qs, B))\\<rbrakk>\n       \\<Longrightarrow> hom_decomp\n                          (fst (shift1\n                                 (shift_list (h, U) x qs, B - {(h, U)})))", "thus ?case"], ["proof (prove)\nusing this:\n  hom_decomp (fst (shift_list (h, U) x qs, B - {(h, U)}))\n\ngoal (1 subgoal):\n 1. hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))", "by (rule step.hyps)"], ["proof (state)\nthis:\n  hom_decomp (fst (shift1 (shift_list (h, U) x qs, B - {(h, U)})))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma shift2_inv_preserved:\n  assumes \"shift2_inv d qs\"\n  shows \"shift2_inv (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "define args where \"args = (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\""], ["proof (state)\nthis:\n  args =\n  (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from refl assms"], ["proof (chain)\npicking this:\n  ?t = ?t\n  shift2_inv d qs", "have inv1: \"shift1_inv d args\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift1_inv d args", "unfolding args_def"], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift1_inv d\n     (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})", "by (rule shift1_invI)"], ["proof (state)\nthis:\n  shift1_inv d args\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "hence \"shift1_inv d (shift1 args)\""], ["proof (prove)\nusing this:\n  shift1_inv d args\n\ngoal (1 subgoal):\n 1. shift1_inv d (shift1 args)", "by (induct args rule: shift1_induct)"], ["proof (state)\nthis:\n  shift1_inv d (shift1 args)\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "hence \"shift1_inv d (fst (shift1 args), snd (shift1 args))\""], ["proof (prove)\nusing this:\n  shift1_inv d (shift1 args)\n\ngoal (1 subgoal):\n 1. shift1_inv d (fst (shift1 args), snd (shift1 args))", "by simp"], ["proof (state)\nthis:\n  shift1_inv d (fst (shift1 args), snd (shift1 args))\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "hence \"shift2_inv d (fst (shift1 args))\""], ["proof (prove)\nusing this:\n  shift1_inv d (fst (shift1 args), snd (shift1 args))\n\ngoal (1 subgoal):\n 1. shift2_inv d (fst (shift1 args))", "by (rule shift1_invD)"], ["proof (state)\nthis:\n  shift2_inv d (fst (shift1 args))\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "hence \"valid_decomp X (fst (shift1 args))\" and \"standard_decomp k (fst (shift1 args))\"\n    and \"exact_decomp (Suc m) (fst (shift1 args))\""], ["proof (prove)\nusing this:\n  shift2_inv d (fst (shift1 args))\n\ngoal (1 subgoal):\n 1. valid_decomp X (fst (shift1 args)) &&&\n    standard_decomp k (fst (shift1 args)) &&&\n    exact_decomp (Suc m) (fst (shift1 args))", "by (rule shift2_invD)+"], ["proof (state)\nthis:\n  valid_decomp X (fst (shift1 args))\n  standard_decomp k (fst (shift1 args))\n  exact_decomp (Suc m) (fst (shift1 args))\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "thus \"shift2_inv (Suc d) (fst (shift1 args))\""], ["proof (prove)\nusing this:\n  valid_decomp X (fst (shift1 args))\n  standard_decomp k (fst (shift1 args))\n  exact_decomp (Suc m) (fst (shift1 args))\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d) (fst (shift1 args))", "proof (rule shift2_invI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < Suc d \\<Longrightarrow>\n       card\n        {q \\<in> set (fst (shift1 args)).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "fix d0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < Suc d \\<Longrightarrow>\n       card\n        {q \\<in> set (fst (shift1 args)).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "assume \"d0 < Suc d\""], ["proof (state)\nthis:\n  d0 < Suc d\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < Suc d \\<Longrightarrow>\n       card\n        {q \\<in> set (fst (shift1 args)).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "hence \"d0 \\<le> d\""], ["proof (prove)\nusing this:\n  d0 < Suc d\n\ngoal (1 subgoal):\n 1. d0 \\<le> d", "by simp"], ["proof (state)\nthis:\n  d0 \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < Suc d \\<Longrightarrow>\n       card\n        {q \\<in> set (fst (shift1 args)).\n         poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "with inv1"], ["proof (chain)\npicking this:\n  shift1_inv d args\n  d0 \\<le> d", "show \"card {q \\<in> set (fst (shift1 args)). poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1\""], ["proof (prove)\nusing this:\n  shift1_inv d args\n  d0 \\<le> d\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (shift1 args)).\n      poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "by (rule shift1_1)"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (fst (shift1 args)).\n    poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift2_inv (Suc d) (fst (shift1 args))\n\ngoal:\nNo subgoals!", "qed"], ["", "function shift2 :: \"nat \\<Rightarrow> nat \\<Rightarrow> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<Rightarrow>\n                      ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) \\<times> 'x set) list\" where\n  \"shift2 c d qs =\n      (if c \\<le> d then qs\n      else shift2 c (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>c d qs. x = (c, d, qs) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>c d qs ca da qsa.\n       (c, d, qs) = (ca, da, qsa) \\<Longrightarrow>\n       (if c \\<le> d then qs\n        else shift2_sumC\n              (c, Suc d,\n               fst (shift1\n                     (qs,\n                      {q \\<in> set qs.\n                       poly_deg (fst q) = d \\<and> m < card (snd q)})))) =\n       (if ca \\<le> da then qsa\n        else shift2_sumC\n              (ca, Suc da,\n               fst (shift1\n                     (qsa,\n                      {q \\<in> set qsa.\n                       poly_deg (fst q) = da \\<and> m < card (snd q)}))))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All shift2_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>c d qs.\n       \\<not> c \\<le> d \\<Longrightarrow>\n       ((c, Suc d,\n         fst (shift1\n               (qs,\n                {q \\<in> set qs.\n                 poly_deg (fst q) = d \\<and> m < card (snd q)}))),\n        c, d, qs)\n       \\<in> ?R", "show \"wf (measure (\\<lambda>(c, d, _). c - d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(c, d, uu_). c - d))", "by (fact wf_measure)"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>(c, d, uu_). c - d))\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<not> c \\<le> d \\<Longrightarrow>\n       ((c, Suc d,\n         fst (shift1\n               (qs,\n                {q \\<in> set qs.\n                 poly_deg (fst q) = d \\<and> m < card (snd q)}))),\n        c, d, qs)\n       \\<in> measure (\\<lambda>(c, d, uu_). c - d)", "qed simp"], ["", "lemma shift2_1: \"shift2_inv d qs \\<Longrightarrow> shift2_inv c (shift2 c d qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv d qs \\<Longrightarrow> shift2_inv c (shift2 c d qs)", "proof (induct c d qs rule: shift2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> shift2_inv c\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> shift2_inv c (shift2 c d qs)", "case IH: (1 c d qs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> c \\<le> d;\n   shift2_inv (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})))\\<rbrakk>\n  \\<Longrightarrow> shift2_inv c\n                     (shift2 c (Suc d)\n                       (fst (shift1\n                              (qs,\n                               {q \\<in> set qs.\n                                poly_deg (fst q) = d \\<and>\n                                m < card (snd q)}))))\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> shift2_inv c\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> shift2_inv c (shift2 c d qs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv c (shift2 c d qs)", "proof (subst shift2.simps, simp del: shift2.simps, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<le> d \\<Longrightarrow> shift2_inv c qs\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    shift2_inv c\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "assume \"c \\<le> d\""], ["proof (state)\nthis:\n  c \\<le> d\n\ngoal (2 subgoals):\n 1. c \\<le> d \\<Longrightarrow> shift2_inv c qs\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    shift2_inv c\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "show \"shift2_inv c qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv c qs", "proof (rule shift2_invI)"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_decomp X qs\n 2. standard_decomp k qs\n 3. exact_decomp (Suc m) qs\n 4. \\<And>d0.\n       d0 < c \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "from IH(2)"], ["proof (chain)\npicking this:\n  shift2_inv d qs", "show \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\""], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. valid_decomp X qs &&& standard_decomp k qs &&& exact_decomp (Suc m) qs", "by (rule shift2_invD)+"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < c \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < c \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "fix d0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < c \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "assume \"d0 < c\""], ["proof (state)\nthis:\n  d0 < c\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < c \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "hence \"d0 < d\""], ["proof (prove)\nusing this:\n  d0 < c\n\ngoal (1 subgoal):\n 1. d0 < d", "using \\<open>c \\<le> d\\<close>"], ["proof (prove)\nusing this:\n  d0 < c\n  c \\<le> d\n\ngoal (1 subgoal):\n 1. d0 < d", "by (rule less_le_trans)"], ["proof (state)\nthis:\n  d0 < d\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < c \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "with IH(2)"], ["proof (chain)\npicking this:\n  shift2_inv d qs\n  d0 < d", "show \"card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1\""], ["proof (prove)\nusing this:\n  shift2_inv d qs\n  d0 < d\n\ngoal (1 subgoal):\n 1. card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift2_inv c qs\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    shift2_inv c\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    shift2_inv c\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "assume \"\\<not> c \\<le> d\""], ["proof (state)\nthis:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    shift2_inv c\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "thus \"shift2_inv c (shift2 c (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))))\""], ["proof (prove)\nusing this:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. shift2_inv c\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "proof (rule IH)"], ["proof (state)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from IH(2)"], ["proof (chain)\npicking this:\n  shift2_inv d qs", "show \"shift2_inv (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\""], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift2_inv_preserved)"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift2_inv c\n   (shift2 c (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  shift2_inv c (shift2 c d qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift2_2:\n  \"shift2_inv d qs \\<Longrightarrow>\n    card {q \\<in> set (shift2 c d qs). m < card (snd q)} \\<le> card {q \\<in> set qs. m < card (snd q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv d qs \\<Longrightarrow>\n    card {q \\<in> set (shift2 c d qs). m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "proof (induct c d qs rule: shift2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> card\n                                   {q \\<in> set\n       (shift2 c (Suc d)\n         (fst (shift1\n                (qs,\n                 {q \\<in> set qs.\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})))).\n                                    m < card (snd q)}\n                                  \\<le> card\n   {q \\<in> set (fst (shift1\n                       (qs,\n                        {q \\<in> set qs.\n                         poly_deg (fst q) = d \\<and> m < card (snd q)}))).\n    m < card (snd q)};\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (shift2 c d qs). m < card (snd q)}\n                         \\<le> card {q \\<in> set qs. m < card (snd q)}", "case IH: (1 c d qs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> c \\<le> d;\n   shift2_inv (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})))\\<rbrakk>\n  \\<Longrightarrow> card\n                     {q \\<in> set (shift2 c (Suc d)\n                                    (fst\n(shift1\n  (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))).\n                      m < card (snd q)}\n                    \\<le> card\n                           {q \\<in> set (fst\n    (shift1\n      (qs,\n       {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))).\n                            m < card (snd q)}\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> card\n                                   {q \\<in> set\n       (shift2 c (Suc d)\n         (fst (shift1\n                (qs,\n                 {q \\<in> set qs.\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})))).\n                                    m < card (snd q)}\n                                  \\<le> card\n   {q \\<in> set (fst (shift1\n                       (qs,\n                        {q \\<in> set qs.\n                         poly_deg (fst q) = d \\<and> m < card (snd q)}))).\n    m < card (snd q)};\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (shift2 c d qs). m < card (snd q)}\n                         \\<le> card {q \\<in> set qs. m < card (snd q)}", "let ?A = \"{q \\<in> set (shift2 c (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))). m < card (snd q)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> card\n                                   {q \\<in> set\n       (shift2 c (Suc d)\n         (fst (shift1\n                (qs,\n                 {q \\<in> set qs.\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})))).\n                                    m < card (snd q)}\n                                  \\<le> card\n   {q \\<in> set (fst (shift1\n                       (qs,\n                        {q \\<in> set qs.\n                         poly_deg (fst q) = d \\<and> m < card (snd q)}))).\n    m < card (snd q)};\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> card\n                          {q \\<in> set (shift2 c d qs). m < card (snd q)}\n                         \\<le> card {q \\<in> set qs. m < card (snd q)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {q \\<in> set (shift2 c d qs). m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "proof (subst shift2.simps, simp del: shift2.simps, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    card\n     {q \\<in> set (shift2 c (Suc d)\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})))).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "assume \"\\<not> c \\<le> d\""], ["proof (state)\nthis:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    card\n     {q \\<in> set (shift2 c (Suc d)\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})))).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "hence \"card ?A \\<le> card {q \\<in> set (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))). m < card (snd q)}\""], ["proof (prove)\nusing this:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (shift2 c (Suc d)\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})))).\n      m < card (snd q)}\n    \\<le> card\n           {q \\<in> set (fst (shift1\n                               (qs,\n                                {q \\<in> set qs.\n                                 poly_deg (fst q) = d \\<and>\n                                 m < card (snd q)}))).\n            m < card (snd q)}", "proof (rule IH)"], ["proof (state)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "show \"shift2_inv (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "using IH(2)"], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift2_inv_preserved)"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (shift2 c (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (shift1\n                             (qs,\n                              {q \\<in> set qs.\n                               poly_deg (fst q) = d \\<and>\n                               m < card (snd q)}))).\n          m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    card\n     {q \\<in> set (shift2 c (Suc d)\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})))).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "also"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (shift2 c (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (shift1\n                             (qs,\n                              {q \\<in> set qs.\n                               poly_deg (fst q) = d \\<and>\n                               m < card (snd q)}))).\n          m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    card\n     {q \\<in> set (shift2 c (Suc d)\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})))).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "have \"\\<dots> \\<le> card {q \\<in> set (fst (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})). m < card (snd q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)}))).\n      m < card (snd q)}\n    \\<le> card\n           {q \\<in> set (fst (qs,\n                              {q \\<in> set qs.\n                               poly_deg (fst q) = d \\<and>\n                               m < card (snd q)})).\n            m < card (snd q)}", "using refl IH(2)"], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)}))).\n      m < card (snd q)}\n    \\<le> card\n           {q \\<in> set (fst (qs,\n                              {q \\<in> set qs.\n                               poly_deg (fst q) = d \\<and>\n                               m < card (snd q)})).\n            m < card (snd q)}", "by (intro shift1_2 shift1_invI)"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (fst (shift1\n                       (qs,\n                        {q \\<in> set qs.\n                         poly_deg (fst q) = d \\<and> m < card (snd q)}))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})).\n          m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    card\n     {q \\<in> set (shift2 c (Suc d)\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})))).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "finally"], ["proof (chain)\npicking this:\n  card\n   {q \\<in> set (shift2 c (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})).\n          m < card (snd q)}", "show \"card ?A \\<le> card {q \\<in> set qs. m < card (snd q)}\""], ["proof (prove)\nusing this:\n  card\n   {q \\<in> set (shift2 c (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))).\n    m < card (snd q)}\n  \\<le> card\n         {q \\<in> set (fst (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})).\n          m < card (snd q)}\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (shift2 c (Suc d)\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})))).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "by (simp only: fst_conv)"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (shift2 c (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))).\n    m < card (snd q)}\n  \\<le> card {q \\<in> set qs. m < card (snd q)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {q \\<in> set (shift2 c d qs). m < card (snd q)}\n  \\<le> card {q \\<in> set qs. m < card (snd q)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift2_3: \"shift2_inv d qs \\<Longrightarrow> cone_decomp T qs \\<Longrightarrow> cone_decomp T (shift2 c d qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shift2_inv d qs; cone_decomp T qs\\<rbrakk>\n    \\<Longrightarrow> cone_decomp T (shift2 c d qs)", "proof (induct c d qs rule: shift2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 cone_decomp T\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> cone_decomp T\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (shift2 c d qs)", "case IH: (1 c d qs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> c \\<le> d;\n   shift2_inv (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})));\n   cone_decomp T\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})))\\<rbrakk>\n  \\<Longrightarrow> cone_decomp T\n                     (shift2 c (Suc d)\n                       (fst (shift1\n                              (qs,\n                               {q \\<in> set qs.\n                                poly_deg (fst q) = d \\<and>\n                                m < card (snd q)}))))\n  shift2_inv d qs\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 cone_decomp T\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> cone_decomp T\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (shift2 c d qs)", "have inv2: \"shift2_inv (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "using IH(2)"], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift2_inv_preserved)"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 cone_decomp T\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> cone_decomp T\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (shift2 c d qs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (shift2 c d qs)", "proof (subst shift2.simps, simp add: IH.prems del: shift2.simps, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    cone_decomp T\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "assume \"\\<not> c \\<le> d\""], ["proof (state)\nthis:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    cone_decomp T\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "moreover"], ["proof (state)\nthis:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    cone_decomp T\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "note inv2"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    cone_decomp T\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "moreover"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    cone_decomp T\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "have \"cone_decomp T (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "proof (rule shift1_3)"], ["proof (state)\ngoal (2 subgoals):\n 1. shift1_inv ?d\n     (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n 2. cone_decomp T\n     (fst (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))", "from refl IH(2)"], ["proof (chain)\npicking this:\n  ?t = ?t\n  shift2_inv d qs", "show \"shift1_inv d (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift1_inv d\n     (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})", "by (rule shift1_invI)"], ["proof (state)\nthis:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n\ngoal (1 subgoal):\n 1. cone_decomp T\n     (fst (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))", "qed (simp add: IH.prems)"], ["proof (state)\nthis:\n  cone_decomp T\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    cone_decomp T\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> c \\<le> d\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n  cone_decomp T\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))", "show \"cone_decomp T (shift2 c (Suc d) (fst (shift1 (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))))\""], ["proof (prove)\nusing this:\n  \\<not> c \\<le> d\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n  cone_decomp T\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (1 subgoal):\n 1. cone_decomp T\n     (shift2 c (Suc d)\n       (fst (shift1\n              (qs,\n               {q \\<in> set qs.\n                poly_deg (fst q) = d \\<and> m < card (snd q)}))))", "by (rule IH)"], ["proof (state)\nthis:\n  cone_decomp T\n   (shift2 c (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone_decomp T (shift2 c d qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift2_4:\n  \"shift2_inv d qs \\<Longrightarrow> Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv d qs \\<Longrightarrow>\n    Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))", "proof (induct c d qs rule: shift2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> Max (poly_deg `\n fst `\n set (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n                                  \\<le> Max\n   (poly_deg `\n    fst `\n    set (shift2 c (Suc d)\n          (fst (shift1\n                 (qs,\n                  {q \\<in> set qs.\n                   poly_deg (fst q) = d \\<and> m < card (snd q)})))));\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))", "case IH: (1 c d qs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> c \\<le> d;\n   shift2_inv (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})))\\<rbrakk>\n  \\<Longrightarrow> Max (poly_deg `\n                         fst `\n                         set (fst (shift1\n                                    (qs,\n                                     {q \\<in> set qs.\npoly_deg (fst q) = d \\<and> m < card (snd q)}))))\n                    \\<le> Max (poly_deg `\n                               fst `\n                               set (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))))\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> Max (poly_deg `\n fst `\n set (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n                                  \\<le> Max\n   (poly_deg `\n    fst `\n    set (shift2 c (Suc d)\n          (fst (shift1\n                 (qs,\n                  {q \\<in> set qs.\n                   poly_deg (fst q) = d \\<and> m < card (snd q)})))));\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))", "let ?args = \"(qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> Max (poly_deg `\n fst `\n set (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n                                  \\<le> Max\n   (poly_deg `\n    fst `\n    set (shift2 c (Suc d)\n          (fst (shift1\n                 (qs,\n                  {q \\<in> set qs.\n                   poly_deg (fst q) = d \\<and> m < card (snd q)})))));\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))", "proof (subst shift2.simps, simp del: shift2.simps, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 c (Suc d)\n                     (fst (shift1\n                            (qs,\n                             {q \\<in> set qs.\n                              poly_deg (fst q) = d \\<and>\n                              m < card (snd q)})))))", "assume \"\\<not> c \\<le> d\""], ["proof (state)\nthis:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 c (Suc d)\n                     (fst (shift1\n                            (qs,\n                             {q \\<in> set qs.\n                              poly_deg (fst q) = d \\<and>\n                              m < card (snd q)})))))", "have \"Max (poly_deg ` fst ` set (fst ?args)) \\<le> Max (poly_deg ` fst ` set (fst (shift1 ?args)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg `\n         fst `\n         set (fst (qs,\n                   {q \\<in> set qs.\n                    poly_deg (fst q) = d \\<and> m < card (snd q)})))\n    \\<le> Max (poly_deg `\n               fst `\n               set (fst (shift1\n                          (qs,\n                           {q \\<in> set qs.\n                            poly_deg (fst q) = d \\<and>\n                            m < card (snd q)}))))", "using refl IH(2)"], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg `\n         fst `\n         set (fst (qs,\n                   {q \\<in> set qs.\n                    poly_deg (fst q) = d \\<and> m < card (snd q)})))\n    \\<le> Max (poly_deg `\n               fst `\n               set (fst (shift1\n                          (qs,\n                           {q \\<in> set qs.\n                            poly_deg (fst q) = d \\<and>\n                            m < card (snd q)}))))", "by (intro shift1_4 shift1_invI)"], ["proof (state)\nthis:\n  Max (poly_deg `\n       fst `\n       set (fst (qs,\n                 {q \\<in> set qs.\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})))\n  \\<le> Max (poly_deg `\n             fst `\n             set (fst (shift1\n                        (qs,\n                         {q \\<in> set qs.\n                          poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 c (Suc d)\n                     (fst (shift1\n                            (qs,\n                             {q \\<in> set qs.\n                              poly_deg (fst q) = d \\<and>\n                              m < card (snd q)})))))", "also"], ["proof (state)\nthis:\n  Max (poly_deg `\n       fst `\n       set (fst (qs,\n                 {q \\<in> set qs.\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})))\n  \\<le> Max (poly_deg `\n             fst `\n             set (fst (shift1\n                        (qs,\n                         {q \\<in> set qs.\n                          poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 c (Suc d)\n                     (fst (shift1\n                            (qs,\n                             {q \\<in> set qs.\n                              poly_deg (fst q) = d \\<and>\n                              m < card (snd q)})))))", "from \\<open>\\<not> c \\<le> d\\<close>"], ["proof (chain)\npicking this:\n  \\<not> c \\<le> d", "have \"\\<dots> \\<le> Max (poly_deg ` fst ` set (shift2 c (Suc d) (fst (shift1 ?args))))\""], ["proof (prove)\nusing this:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. Max (poly_deg `\n         fst `\n         set (fst (shift1\n                    (qs,\n                     {q \\<in> set qs.\n                      poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 c (Suc d)\n                     (fst (shift1\n                            (qs,\n                             {q \\<in> set qs.\n                              poly_deg (fst q) = d \\<and>\n                              m < card (snd q)})))))", "proof (rule IH)"], ["proof (state)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from IH(2)"], ["proof (chain)\npicking this:\n  shift2_inv d qs", "show \"shift2_inv (Suc d) (fst (shift1 ?args))\""], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift2_inv_preserved)"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (poly_deg `\n       fst `\n       set (fst (shift1\n                  (qs,\n                   {q \\<in> set qs.\n                    poly_deg (fst q) = d \\<and> m < card (snd q)}))))\n  \\<le> Max (poly_deg `\n             fst `\n             set (shift2 c (Suc d)\n                   (fst (shift1\n                          (qs,\n                           {q \\<in> set qs.\n                            poly_deg (fst q) = d \\<and>\n                            m < card (snd q)})))))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 c (Suc d)\n                     (fst (shift1\n                            (qs,\n                             {q \\<in> set qs.\n                              poly_deg (fst q) = d \\<and>\n                              m < card (snd q)})))))", "finally"], ["proof (chain)\npicking this:\n  Max (poly_deg `\n       fst `\n       set (fst (qs,\n                 {q \\<in> set qs.\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})))\n  \\<le> Max (poly_deg `\n             fst `\n             set (shift2 c (Suc d)\n                   (fst (shift1\n                          (qs,\n                           {q \\<in> set qs.\n                            poly_deg (fst q) = d \\<and>\n                            m < card (snd q)})))))", "show \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (shift2 c (Suc d) (fst (shift1 ?args))))\""], ["proof (prove)\nusing this:\n  Max (poly_deg `\n       fst `\n       set (fst (qs,\n                 {q \\<in> set qs.\n                  poly_deg (fst q) = d \\<and> m < card (snd q)})))\n  \\<le> Max (poly_deg `\n             fst `\n             set (shift2 c (Suc d)\n                   (fst (shift1\n                          (qs,\n                           {q \\<in> set qs.\n                            poly_deg (fst q) = d \\<and>\n                            m < card (snd q)})))))\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 c (Suc d)\n                     (fst (shift1\n                            (qs,\n                             {q \\<in> set qs.\n                              poly_deg (fst q) = d \\<and>\n                              m < card (snd q)})))))", "by (simp only: fst_conv)"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg `\n             fst `\n             set (shift2 c (Suc d)\n                   (fst (shift1\n                          (qs,\n                           {q \\<in> set qs.\n                            poly_deg (fst q) = d \\<and>\n                            m < card (snd q)})))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (shift2 c d qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift2_5:\n  \"shift2_inv d qs \\<Longrightarrow> shift2 c d qs = [] \\<longleftrightarrow> qs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv d qs \\<Longrightarrow> (shift2 c d qs = []) = (qs = [])", "proof (induct c d qs rule: shift2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> (shift2 c (Suc d)\n                                    (fst\n(shift1\n  (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n                                   []) =\n                                  (fst (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n                                   []);\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> (shift2 c d qs = []) = (qs = [])", "case IH: (1 c d qs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> c \\<le> d;\n   shift2_inv (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})))\\<rbrakk>\n  \\<Longrightarrow> (shift2 c (Suc d)\n                      (fst (shift1\n                             (qs,\n                              {q \\<in> set qs.\n                               poly_deg (fst q) = d \\<and>\n                               m < card (snd q)}))) =\n                     []) =\n                    (fst (shift1\n                           (qs,\n                            {q \\<in> set qs.\n                             poly_deg (fst q) = d \\<and>\n                             m < card (snd q)})) =\n                     [])\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> (shift2 c (Suc d)\n                                    (fst\n(shift1\n  (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n                                   []) =\n                                  (fst (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n                                   []);\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> (shift2 c d qs = []) = (qs = [])", "let ?args = \"(qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> (shift2 c (Suc d)\n                                    (fst\n(shift1\n  (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n                                   []) =\n                                  (fst (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n                                   []);\n        shift2_inv d qs\\<rbrakk>\n       \\<Longrightarrow> (shift2 c d qs = []) = (qs = [])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (shift2 c d qs = []) = (qs = [])", "proof (subst shift2.simps, simp del: shift2.simps, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    (shift2 c (Suc d)\n      (fst (shift1\n             (qs,\n              {q \\<in> set qs.\n               poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n     []) =\n    (qs = [])", "assume \"\\<not> c \\<le> d\""], ["proof (state)\nthis:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    (shift2 c (Suc d)\n      (fst (shift1\n             (qs,\n              {q \\<in> set qs.\n               poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n     []) =\n    (qs = [])", "hence \"shift2 c (Suc d) (fst (shift1 ?args)) = [] \\<longleftrightarrow> fst (shift1 ?args) = []\""], ["proof (prove)\nusing this:\n  \\<not> c \\<le> d\n\ngoal (1 subgoal):\n 1. (shift2 c (Suc d)\n      (fst (shift1\n             (qs,\n              {q \\<in> set qs.\n               poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n     []) =\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n     [])", "proof (rule IH)"], ["proof (state)\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from IH(2)"], ["proof (chain)\npicking this:\n  shift2_inv d qs", "show \"shift2_inv (Suc d) (fst (shift1 ?args))\""], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift2_inv_preserved)"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (shift2 c (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n   []) =\n  (fst (shift1\n         (qs,\n          {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n   [])\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    (shift2 c (Suc d)\n      (fst (shift1\n             (qs,\n              {q \\<in> set qs.\n               poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n     []) =\n    (qs = [])", "also"], ["proof (state)\nthis:\n  (shift2 c (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n   []) =\n  (fst (shift1\n         (qs,\n          {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n   [])\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    (shift2 c (Suc d)\n      (fst (shift1\n             (qs,\n              {q \\<in> set qs.\n               poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n     []) =\n    (qs = [])", "from refl IH(2)"], ["proof (chain)\npicking this:\n  ?t = ?t\n  shift2_inv d qs", "have \"\\<dots> \\<longleftrightarrow> fst ?args = []\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n     []) =\n    (fst (qs,\n          {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}) =\n     [])", "by (intro shift1_5 shift1_invI)"], ["proof (state)\nthis:\n  (fst (shift1\n         (qs,\n          {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})) =\n   []) =\n  (fst (qs,\n        {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}) =\n   [])\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow>\n    (shift2 c (Suc d)\n      (fst (shift1\n             (qs,\n              {q \\<in> set qs.\n               poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n     []) =\n    (qs = [])", "finally"], ["proof (chain)\npicking this:\n  (shift2 c (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n   []) =\n  (fst (qs,\n        {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}) =\n   [])", "show \"shift2 c (Suc d) (fst (shift1 ?args)) = [] \\<longleftrightarrow> qs = []\""], ["proof (prove)\nusing this:\n  (shift2 c (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n   []) =\n  (fst (qs,\n        {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}) =\n   [])\n\ngoal (1 subgoal):\n 1. (shift2 c (Suc d)\n      (fst (shift1\n             (qs,\n              {q \\<in> set qs.\n               poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n     []) =\n    (qs = [])", "by (simp only: fst_conv)"], ["proof (state)\nthis:\n  (shift2 c (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)}))) =\n   []) =\n  (qs = [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (shift2 c d qs = []) = (qs = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift2_6:\n  \"shift2_inv d qs \\<Longrightarrow> monomial_decomp qs \\<Longrightarrow> monomial_decomp (shift2 c d qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shift2_inv d qs; monomial_decomp qs\\<rbrakk>\n    \\<Longrightarrow> monomial_decomp (shift2 c d qs)", "proof (induct c d qs rule: shift2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 monomial_decomp\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (shift2 c d qs)", "case IH: (1 c d qs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> c \\<le> d;\n   shift2_inv (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})));\n   monomial_decomp\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})))\\<rbrakk>\n  \\<Longrightarrow> monomial_decomp\n                     (shift2 c (Suc d)\n                       (fst (shift1\n                              (qs,\n                               {q \\<in> set qs.\n                                poly_deg (fst q) = d \\<and>\n                                m < card (snd q)}))))\n  shift2_inv d qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 monomial_decomp\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (shift2 c d qs)", "let ?args = \"(qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 monomial_decomp\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> monomial_decomp\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (shift2 c d qs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (shift2 c d qs)", "proof (subst shift2.simps, simp del: shift2.simps, intro conjI impI IH)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))\n 3. \\<not> c \\<le> d \\<Longrightarrow>\n    monomial_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from IH(2)"], ["proof (chain)\npicking this:\n  shift2_inv d qs", "show \"shift2_inv (Suc d) (fst (shift1 ?args))\""], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift2_inv_preserved)"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    monomial_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    monomial_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from refl IH(2)"], ["proof (chain)\npicking this:\n  ?t = ?t\n  shift2_inv d qs", "have \"shift1_inv d ?args\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift1_inv d\n     (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})", "by (rule shift1_invI)"], ["proof (state)\nthis:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    monomial_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "moreover"], ["proof (state)\nthis:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    monomial_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from IH(3)"], ["proof (chain)\npicking this:\n  monomial_decomp qs", "have \"monomial_decomp (fst ?args)\""], ["proof (prove)\nusing this:\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp\n     (fst (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))", "by simp"], ["proof (state)\nthis:\n  monomial_decomp\n   (fst (qs,\n         {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    monomial_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "ultimately"], ["proof (chain)\npicking this:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n  monomial_decomp\n   (fst (qs,\n         {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))", "show \"monomial_decomp (fst (shift1 ?args))\""], ["proof (prove)\nusing this:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n  monomial_decomp\n   (fst (qs,\n         {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))\n\ngoal (1 subgoal):\n 1. monomial_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift1_6)"], ["proof (state)\nthis:\n  monomial_decomp\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d", "qed"], ["proof (state)\nthis:\n  monomial_decomp (shift2 c d qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift2_7:\n  \"shift2_inv d qs \\<Longrightarrow> hom_decomp qs \\<Longrightarrow> hom_decomp (shift2 c d qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>shift2_inv d qs; hom_decomp qs\\<rbrakk>\n    \\<Longrightarrow> hom_decomp (shift2 c d qs)", "proof (induct c d qs rule: shift2.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 hom_decomp\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> hom_decomp\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (shift2 c d qs)", "case IH: (1 c d qs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> c \\<le> d;\n   shift2_inv (Suc d)\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})));\n   hom_decomp\n    (fst (shift1\n           (qs,\n            {q \\<in> set qs.\n             poly_deg (fst q) = d \\<and> m < card (snd q)})))\\<rbrakk>\n  \\<Longrightarrow> hom_decomp\n                     (shift2 c (Suc d)\n                       (fst (shift1\n                              (qs,\n                               {q \\<in> set qs.\n                                poly_deg (fst q) = d \\<and>\n                                m < card (snd q)}))))\n  shift2_inv d qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 hom_decomp\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> hom_decomp\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (shift2 c d qs)", "let ?args = \"(qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c d qs.\n       \\<lbrakk>\\<lbrakk>\\<not> c \\<le> d;\n                 shift2_inv (Suc d)\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and> m < card (snd q)})));\n                 hom_decomp\n                  (fst (shift1\n                         (qs,\n                          {q \\<in> set qs.\n                           poly_deg (fst q) = d \\<and>\n                           m < card (snd q)})))\\<rbrakk>\n                \\<Longrightarrow> hom_decomp\n                                   (shift2 c (Suc d)\n                                     (fst\n (shift1\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))));\n        shift2_inv d qs; hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (shift2 c d qs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (shift2 c d qs)", "proof (subst shift2.simps, simp del: shift2.simps, intro conjI impI IH)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))\n 3. \\<not> c \\<le> d \\<Longrightarrow>\n    hom_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from IH(2)"], ["proof (chain)\npicking this:\n  shift2_inv d qs", "show \"shift2_inv (Suc d) (fst (shift1 ?args))\""], ["proof (prove)\nusing this:\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift2_inv (Suc d)\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift2_inv_preserved)"], ["proof (state)\nthis:\n  shift2_inv (Suc d)\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    hom_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    hom_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from refl IH(2)"], ["proof (chain)\npicking this:\n  ?t = ?t\n  shift2_inv d qs", "have \"shift1_inv d ?args\""], ["proof (prove)\nusing this:\n  ?t = ?t\n  shift2_inv d qs\n\ngoal (1 subgoal):\n 1. shift1_inv d\n     (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})", "by (rule shift1_invI)"], ["proof (state)\nthis:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    hom_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "moreover"], ["proof (state)\nthis:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    hom_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "from IH(3)"], ["proof (chain)\npicking this:\n  hom_decomp qs", "have \"hom_decomp (fst ?args)\""], ["proof (prove)\nusing this:\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp\n     (fst (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))", "by simp"], ["proof (state)\nthis:\n  hom_decomp\n   (fst (qs,\n         {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))\n\ngoal (2 subgoals):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d\n 2. \\<not> c \\<le> d \\<Longrightarrow>\n    hom_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "ultimately"], ["proof (chain)\npicking this:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n  hom_decomp\n   (fst (qs,\n         {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))", "show \"hom_decomp (fst (shift1 ?args))\""], ["proof (prove)\nusing this:\n  shift1_inv d\n   (qs, {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})\n  hom_decomp\n   (fst (qs,\n         {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)}))\n\ngoal (1 subgoal):\n 1. hom_decomp\n     (fst (shift1\n            (qs,\n             {q \\<in> set qs.\n              poly_deg (fst q) = d \\<and> m < card (snd q)})))", "by (rule shift1_7)"], ["proof (state)\nthis:\n  hom_decomp\n   (fst (shift1\n          (qs,\n           {q \\<in> set qs. poly_deg (fst q) = d \\<and> m < card (snd q)})))\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> d \\<Longrightarrow> \\<not> c \\<le> d", "qed"], ["proof (state)\nthis:\n  hom_decomp (shift2 c d qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition shift :: \"((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<Rightarrow>\n                        ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) \\<times> 'x set) list\"\n  where \"shift qs = shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs\""], ["", "lemma shift2_inv_init:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"shift2_inv k qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shift2_inv k qs", "using assms"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. shift2_inv k qs", "proof (rule shift2_invI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < k \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "fix d0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < k \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "assume \"d0 < k\""], ["proof (state)\nthis:\n  d0 < k\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < k \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "have \"{q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "assume \"q \\<in> set qs\""], ["proof (state)\nthis:\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "obtain h U where q: \"q = (h, U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h U. q = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = (x1, x2) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>h U. q = (h, U) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q = (h, U)\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "assume \"poly_deg (fst q) = d0\" and \"m < card (snd q)\""], ["proof (state)\nthis:\n  poly_deg (fst q) = d0\n  m < card (snd q)\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "hence \"poly_deg h < k\" and \"m < card U\""], ["proof (prove)\nusing this:\n  poly_deg (fst q) = d0\n  m < card (snd q)\n\ngoal (1 subgoal):\n 1. poly_deg h < k &&& m < card U", "using \\<open>d0 < k\\<close>"], ["proof (prove)\nusing this:\n  poly_deg (fst q) = d0\n  m < card (snd q)\n  d0 < k\n\ngoal (1 subgoal):\n 1. poly_deg h < k &&& m < card U", "by (simp_all add: q)"], ["proof (state)\nthis:\n  poly_deg h < k\n  m < card U\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "from this(2)"], ["proof (chain)\npicking this:\n  m < card U", "have \"U \\<noteq> {}\""], ["proof (prove)\nusing this:\n  m < card U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "with \\<open>q \\<in> set qs\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> set qs\n  U \\<noteq> {}", "have \"(h, U) \\<in> set (qs\\<^sub>+)\""], ["proof (prove)\nusing this:\n  q \\<in> set qs\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h, U) \\<in> set (qs\\<^sub>+)", "by (simp add: q pos_decomp_def)"], ["proof (state)\nthis:\n  (h, U) \\<in> set (qs\\<^sub>+)\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "with assms(2)"], ["proof (chain)\npicking this:\n  standard_decomp k qs\n  (h, U) \\<in> set (qs\\<^sub>+)", "have \"k \\<le> poly_deg h\""], ["proof (prove)\nusing this:\n  standard_decomp k qs\n  (h, U) \\<in> set (qs\\<^sub>+)\n\ngoal (1 subgoal):\n 1. k \\<le> poly_deg h", "by (rule standard_decompD)"], ["proof (state)\nthis:\n  k \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "with \\<open>poly_deg h < k\\<close>"], ["proof (chain)\npicking this:\n  poly_deg h < k\n  k \\<le> poly_deg h", "have False"], ["proof (prove)\nusing this:\n  poly_deg h < k\n  k \\<le> poly_deg h\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?q47 \\<in> set qs; poly_deg (fst ?q47) = d0;\n   m < card (snd ?q47)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q47 \\<in> set qs; poly_deg (fst ?q47) = d0;\n   m < card (snd ?q47)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}", "by blast"], ["proof (state)\nthis:\n  {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 < k \\<Longrightarrow>\n       card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n       \\<le> 1", "thus \"card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} \\<le> 1\""], ["proof (prove)\nusing this:\n  {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)} = {}\n\ngoal (1 subgoal):\n 1. card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n    \\<le> 1", "by (simp only: card.empty)"], ["proof (state)\nthis:\n  card {q \\<in> set qs. poly_deg (fst q) = d0 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"valid_decomp X (shift qs)\" and \"standard_decomp k (shift qs)\" and \"exact_decomp m (shift qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift qs) &&&\n    standard_decomp k (local.shift qs) &&& exact_decomp m (local.shift qs)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift qs)\n 2. standard_decomp k (local.shift qs)\n 3. exact_decomp m (local.shift qs)", "define c where \"c = card {q \\<in> set qs. m < card (snd q)}\""], ["proof (state)\nthis:\n  c = card {q \\<in> set qs. m < card (snd q)}\n\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift qs)\n 2. standard_decomp k (local.shift qs)\n 3. exact_decomp m (local.shift qs)", "define A where \"A = {q \\<in> set (shift qs). m < card (snd q)}\""], ["proof (state)\nthis:\n  A = {q \\<in> set (local.shift qs). m < card (snd q)}\n\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift qs)\n 2. standard_decomp k (local.shift qs)\n 3. exact_decomp m (local.shift qs)", "from assms"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"shift2_inv k qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. shift2_inv k qs", "by (rule shift2_inv_init)"], ["proof (state)\nthis:\n  shift2_inv k qs\n\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift qs)\n 2. standard_decomp k (local.shift qs)\n 3. exact_decomp m (local.shift qs)", "hence inv2: \"shift2_inv (k + c) (shift qs)\" and \"card A \\<le> c\""], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. shift2_inv (k + c) (local.shift qs) &&& card A \\<le> c", "unfolding shift_def c_def A_def"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. shift2_inv (k + card {q \\<in> set qs. m < card (snd q)})\n     (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs) &&&\n    card\n     {q \\<in> set (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k\n                    qs).\n      m < card (snd q)}\n    \\<le> card {q \\<in> set qs. m < card (snd q)}", "by (rule shift2_1, rule shift2_2)"], ["proof (state)\nthis:\n  shift2_inv (k + c) (local.shift qs)\n  card A \\<le> c\n\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift qs)\n 2. standard_decomp k (local.shift qs)\n 3. exact_decomp m (local.shift qs)", "from inv2"], ["proof (chain)\npicking this:\n  shift2_inv (k + c) (local.shift qs)", "have fin: \"valid_decomp X (shift qs)\" and std: \"standard_decomp k (shift qs)\"\n    and exct: \"exact_decomp (Suc m) (shift qs)\""], ["proof (prove)\nusing this:\n  shift2_inv (k + c) (local.shift qs)\n\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift qs) &&&\n    standard_decomp k (local.shift qs) &&&\n    exact_decomp (Suc m) (local.shift qs)", "by (rule shift2_invD)+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift qs)\n  standard_decomp k (local.shift qs)\n  exact_decomp (Suc m) (local.shift qs)\n\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift qs)\n 2. standard_decomp k (local.shift qs)\n 3. exact_decomp m (local.shift qs)", "show \"valid_decomp X (shift qs)\" and \"standard_decomp k (shift qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift qs) &&& standard_decomp k (local.shift qs)", "by fact+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift qs)\n  standard_decomp k (local.shift qs)\n\ngoal (1 subgoal):\n 1. exact_decomp m (local.shift qs)", "have \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "by (auto simp: A_def)"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. exact_decomp m (local.shift qs)", "show \"exact_decomp m (shift qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exact_decomp m (local.shift qs)", "proof (rule exact_decompI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (local.shift qs) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (local.shift qs) \\<Longrightarrow> U \\<subseteq> X\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "fix h U"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (local.shift qs) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (local.shift qs) \\<Longrightarrow> U \\<subseteq> X\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume \"(h, U) \\<in> set (shift qs)\""], ["proof (state)\nthis:\n  (h, U) \\<in> set (local.shift qs)\n\ngoal (3 subgoals):\n 1. \\<And>h U.\n       (h, U) \\<in> set (local.shift qs) \\<Longrightarrow> h \\<in> P[X]\n 2. \\<And>h U.\n       (h, U) \\<in> set (local.shift qs) \\<Longrightarrow> U \\<subseteq> X\n 3. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "with exct"], ["proof (chain)\npicking this:\n  exact_decomp (Suc m) (local.shift qs)\n  (h, U) \\<in> set (local.shift qs)", "show \"h \\<in> P[X]\" and \"U \\<subseteq> X\""], ["proof (prove)\nusing this:\n  exact_decomp (Suc m) (local.shift qs)\n  (h, U) \\<in> set (local.shift qs)\n\ngoal (1 subgoal):\n 1. h \\<in> P[X] &&& U \\<subseteq> X", "by (rule exact_decompD)+"], ["proof (state)\nthis:\n  h \\<in> P[X]\n  U \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "fix h1 h2 U1 U2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume 1: \"(h1, U1) \\<in> set (shift qs)\" and 2: \"(h2, U2) \\<in> set (shift qs)\""], ["proof (state)\nthis:\n  (h1, U1) \\<in> set (local.shift qs)\n  (h2, U2) \\<in> set (local.shift qs)\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "assume 3: \"poly_deg h1 = poly_deg h2\" and 4: \"m < card U1\" and 5: \"m < card U2\""], ["proof (state)\nthis:\n  poly_deg h1 = poly_deg h2\n  m < card U1\n  m < card U2\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "from 5"], ["proof (chain)\npicking this:\n  m < card U2", "have \"U2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  m < card U2\n\ngoal (1 subgoal):\n 1. U2 \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  U2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "with 2"], ["proof (chain)\npicking this:\n  (h2, U2) \\<in> set (local.shift qs)\n  U2 \\<noteq> {}", "have \"(h2, U2) \\<in> set ((shift qs)\\<^sub>+)\""], ["proof (prove)\nusing this:\n  (h2, U2) \\<in> set (local.shift qs)\n  U2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (h2, U2) \\<in> set ((local.shift qs)\\<^sub>+)", "by (simp add: pos_decomp_def)"], ["proof (state)\nthis:\n  (h2, U2) \\<in> set ((local.shift qs)\\<^sub>+)\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "let ?C = \"{q \\<in> set (shift qs). poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "define B where \"B = {q \\<in> A. k \\<le> poly_deg (fst q) \\<and> poly_deg (fst q) \\<le> poly_deg h2}\""], ["proof (state)\nthis:\n  B =\n  {q \\<in> A.\n   k \\<le> poly_deg (fst q) \\<and> poly_deg (fst q) \\<le> poly_deg h2}\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "have \"Suc (poly_deg h2) - k \\<le> card B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "have \"B = (\\<Union>d0\\<in>{k..poly_deg h2}. {q \\<in> A. poly_deg (fst q) = d0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    (\\<Union>d0\\<in>{k..poly_deg h2}. {q \\<in> A. poly_deg (fst q) = d0})", "by (auto simp: B_def)"], ["proof (state)\nthis:\n  B = (\\<Union>d0\\<in>{k..poly_deg h2}. {q \\<in> A. poly_deg (fst q) = d0})\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "also"], ["proof (state)\nthis:\n  B = (\\<Union>d0\\<in>{k..poly_deg h2}. {q \\<in> A. poly_deg (fst q) = d0})\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "have \"card \\<dots> = (\\<Sum>d0=k..poly_deg h2. card {q \\<in> A. poly_deg (fst q) = d0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (\\<Union>d0\\<in>{k..poly_deg h2}. {q \\<in> A. poly_deg (fst q) = d0}) =\n    (\\<Sum>d0 = k..poly_deg h2. card {q \\<in> A. poly_deg (fst q) = d0})", "proof (intro card_UN_disjoint ballI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {k..poly_deg h2}\n 2. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       finite {q \\<in> A. poly_deg (fst q) = d0}\n 3. \\<And>d0 j.\n       \\<lbrakk>d0 \\<in> {k..poly_deg h2}; j \\<in> {k..poly_deg h2};\n        d0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n                         {q \\<in> A. poly_deg (fst q) = j} =\n                         {}", "fix d0"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {k..poly_deg h2}\n 2. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       finite {q \\<in> A. poly_deg (fst q) = d0}\n 3. \\<And>d0 j.\n       \\<lbrakk>d0 \\<in> {k..poly_deg h2}; j \\<in> {k..poly_deg h2};\n        d0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n                         {q \\<in> A. poly_deg (fst q) = j} =\n                         {}", "from _ \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite A", "show \"finite {q \\<in> A. poly_deg (fst q) = d0}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite A\n\ngoal (1 subgoal):\n 1. finite {q \\<in> A. poly_deg (fst q) = d0}", "by (rule finite_subset) blast"], ["proof (state)\nthis:\n  finite {q \\<in> A. poly_deg (fst q) = d0}\n\ngoal (2 subgoals):\n 1. finite {k..poly_deg h2}\n 2. \\<And>d0 j.\n       \\<lbrakk>d0 \\<in> {k..poly_deg h2}; j \\<in> {k..poly_deg h2};\n        d0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n                         {q \\<in> A. poly_deg (fst q) = j} =\n                         {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {k..poly_deg h2}\n 2. \\<And>d0 j.\n       \\<lbrakk>d0 \\<in> {k..poly_deg h2}; j \\<in> {k..poly_deg h2};\n        d0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n                         {q \\<in> A. poly_deg (fst q) = j} =\n                         {}", "fix d0 d1 :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {k..poly_deg h2}\n 2. \\<And>d0 j.\n       \\<lbrakk>d0 \\<in> {k..poly_deg h2}; j \\<in> {k..poly_deg h2};\n        d0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n                         {q \\<in> A. poly_deg (fst q) = j} =\n                         {}", "assume \"d0 \\<noteq> d1\""], ["proof (state)\nthis:\n  d0 \\<noteq> d1\n\ngoal (2 subgoals):\n 1. finite {k..poly_deg h2}\n 2. \\<And>d0 j.\n       \\<lbrakk>d0 \\<in> {k..poly_deg h2}; j \\<in> {k..poly_deg h2};\n        d0 \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n                         {q \\<in> A. poly_deg (fst q) = j} =\n                         {}", "thus \"{q \\<in> A. poly_deg (fst q) = d0} \\<inter> {q \\<in> A. poly_deg (fst q) = d1} = {}\""], ["proof (prove)\nusing this:\n  d0 \\<noteq> d1\n\ngoal (1 subgoal):\n 1. {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n    {q \\<in> A. poly_deg (fst q) = d1} =\n    {}", "by blast"], ["proof (state)\nthis:\n  {q \\<in> A. poly_deg (fst q) = d0} \\<inter>\n  {q \\<in> A. poly_deg (fst q) = d1} =\n  {}\n\ngoal (1 subgoal):\n 1. finite {k..poly_deg h2}", "qed (fact finite_atLeastAtMost)"], ["proof (state)\nthis:\n  card\n   (\\<Union>d0\\<in>{k..poly_deg h2}. {q \\<in> A. poly_deg (fst q) = d0}) =\n  (\\<Sum>d0 = k..poly_deg h2. card {q \\<in> A. poly_deg (fst q) = d0})\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "also"], ["proof (state)\nthis:\n  card\n   (\\<Union>d0\\<in>{k..poly_deg h2}. {q \\<in> A. poly_deg (fst q) = d0}) =\n  (\\<Sum>d0 = k..poly_deg h2. card {q \\<in> A. poly_deg (fst q) = d0})\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "have \"\\<dots> \\<ge> (\\<Sum>d0=k..poly_deg h2. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = k..poly_deg h2. 1)\n    \\<le> (\\<Sum>d0 = k..poly_deg h2.\n              card {q \\<in> A. poly_deg (fst q) = d0})", "proof (rule sum_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "fix d0"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "assume \"d0 \\<in> {k..poly_deg h2}\""], ["proof (state)\nthis:\n  d0 \\<in> {k..poly_deg h2}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "hence \"k \\<le> d0\" and \"d0 \\<le> poly_deg h2\""], ["proof (prove)\nusing this:\n  d0 \\<in> {k..poly_deg h2}\n\ngoal (1 subgoal):\n 1. k \\<le> d0 &&& d0 \\<le> poly_deg h2", "by simp_all"], ["proof (state)\nthis:\n  k \\<le> d0\n  d0 \\<le> poly_deg h2\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "with std \\<open>(h2, U2) \\<in> set ((shift qs)\\<^sub>+)\\<close>"], ["proof (chain)\npicking this:\n  standard_decomp k (local.shift qs)\n  (h2, U2) \\<in> set ((local.shift qs)\\<^sub>+)\n  k \\<le> d0\n  d0 \\<le> poly_deg h2", "obtain h' U' where \"(h', U') \\<in> set (shift qs)\"\n          and \"poly_deg h' = d0\" and \"card U2 \\<le> card U'\""], ["proof (prove)\nusing this:\n  standard_decomp k (local.shift qs)\n  (h2, U2) \\<in> set ((local.shift qs)\\<^sub>+)\n  k \\<le> d0\n  d0 \\<le> poly_deg h2\n\ngoal (1 subgoal):\n 1. (\\<And>h' U'.\n        \\<lbrakk>(h', U') \\<in> set (local.shift qs); poly_deg h' = d0;\n         card U2 \\<le> card U'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule standard_decompE)"], ["proof (state)\nthis:\n  (h', U') \\<in> set (local.shift qs)\n  poly_deg h' = d0\n  card U2 \\<le> card U'\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "from 5 this(3)"], ["proof (chain)\npicking this:\n  m < card U2\n  card U2 \\<le> card U'", "have \"m < card U'\""], ["proof (prove)\nusing this:\n  m < card U2\n  card U2 \\<le> card U'\n\ngoal (1 subgoal):\n 1. m < card U'", "by (rule less_le_trans)"], ["proof (state)\nthis:\n  m < card U'\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "with \\<open>(h', U') \\<in> set (shift qs)\\<close>"], ["proof (chain)\npicking this:\n  (h', U') \\<in> set (local.shift qs)\n  m < card U'", "have \"(h', U') \\<in> {q \\<in> A. poly_deg (fst q) = d0}\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> set (local.shift qs)\n  m < card U'\n\ngoal (1 subgoal):\n 1. (h', U') \\<in> {q \\<in> A. poly_deg (fst q) = d0}", "by (simp add: A_def \\<open>poly_deg h' = d0\\<close>)"], ["proof (state)\nthis:\n  (h', U') \\<in> {q \\<in> A. poly_deg (fst q) = d0}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "hence \"{q \\<in> A. poly_deg (fst q) = d0} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (h', U') \\<in> {q \\<in> A. poly_deg (fst q) = d0}\n\ngoal (1 subgoal):\n 1. {q \\<in> A. poly_deg (fst q) = d0} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {q \\<in> A. poly_deg (fst q) = d0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "moreover"], ["proof (state)\nthis:\n  {q \\<in> A. poly_deg (fst q) = d0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "from _ \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite A", "have \"finite {q \\<in> A. poly_deg (fst q) = d0}\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  finite A\n\ngoal (1 subgoal):\n 1. finite {q \\<in> A. poly_deg (fst q) = d0}", "by (rule finite_subset) blast"], ["proof (state)\nthis:\n  finite {q \\<in> A. poly_deg (fst q) = d0}\n\ngoal (1 subgoal):\n 1. \\<And>d0.\n       d0 \\<in> {k..poly_deg h2} \\<Longrightarrow>\n       1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "ultimately"], ["proof (chain)\npicking this:\n  {q \\<in> A. poly_deg (fst q) = d0} \\<noteq> {}\n  finite {q \\<in> A. poly_deg (fst q) = d0}", "show \"1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}\""], ["proof (prove)\nusing this:\n  {q \\<in> A. poly_deg (fst q) = d0} \\<noteq> {}\n  finite {q \\<in> A. poly_deg (fst q) = d0}\n\ngoal (1 subgoal):\n 1. 1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}", "by (simp add: card_gt_0_iff Suc_le_eq)"], ["proof (state)\nthis:\n  1 \\<le> card {q \\<in> A. poly_deg (fst q) = d0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>d0 = k..poly_deg h2. 1)\n  \\<le> (\\<Sum>d0 = k..poly_deg h2. card {q \\<in> A. poly_deg (fst q) = d0})\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "also"], ["proof (state)\nthis:\n  (\\<Sum>d0 = k..poly_deg h2. 1)\n  \\<le> (\\<Sum>d0 = k..poly_deg h2. card {q \\<in> A. poly_deg (fst q) = d0})\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "have \"(\\<Sum>d0=k..poly_deg h2. 1) = Suc (poly_deg h2) - k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d0 = k..poly_deg h2. 1) = Suc (poly_deg h2) - k", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>d0 = k..poly_deg h2. 1) = Suc (poly_deg h2) - k\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "finally"], ["proof (chain)\npicking this:\n  Suc (poly_deg h2) - k \\<le> card B", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc (poly_deg h2) - k \\<le> card B\n\ngoal (1 subgoal):\n 1. Suc (poly_deg h2) - k \\<le> card B", "."], ["proof (state)\nthis:\n  Suc (poly_deg h2) - k \\<le> card B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (poly_deg h2) - k \\<le> card B\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "also"], ["proof (state)\nthis:\n  Suc (poly_deg h2) - k \\<le> card B\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "from \\<open>finite A\\<close> _"], ["proof (chain)\npicking this:\n  finite A\n  PROP ?psi \\<Longrightarrow> PROP ?psi", "have \"\\<dots> \\<le> card A\""], ["proof (prove)\nusing this:\n  finite A\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n\ngoal (1 subgoal):\n 1. card B \\<le> card A", "by (rule card_mono) (auto simp: B_def)"], ["proof (state)\nthis:\n  card B \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "also"], ["proof (state)\nthis:\n  card B \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "have \"\\<dots> \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A \\<le> c", "by fact"], ["proof (state)\nthis:\n  card A \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "finally"], ["proof (chain)\npicking this:\n  Suc (poly_deg h2) - k \\<le> c", "have \"poly_deg h2 < k + c\""], ["proof (prove)\nusing this:\n  Suc (poly_deg h2) - k \\<le> c\n\ngoal (1 subgoal):\n 1. poly_deg h2 < k + c", "by simp"], ["proof (state)\nthis:\n  poly_deg h2 < k + c\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "with inv2"], ["proof (chain)\npicking this:\n  shift2_inv (k + c) (local.shift qs)\n  poly_deg h2 < k + c", "have \"card ?C \\<le> 1\""], ["proof (prove)\nusing this:\n  shift2_inv (k + c) (local.shift qs)\n  poly_deg h2 < k + c\n\ngoal (1 subgoal):\n 1. card\n     {q \\<in> set (local.shift qs).\n      poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n    \\<le> 1", "by (rule shift2_invD)"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "have \"finite ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {q \\<in> set (local.shift qs).\n      poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}", "by auto"], ["proof (state)\nthis:\n  finite\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "moreover"], ["proof (state)\nthis:\n  finite\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "note \\<open>card ?C \\<le> 1\\<close>"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "moreover"], ["proof (state)\nthis:\n  card\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "from 1 3 4"], ["proof (chain)\npicking this:\n  (h1, U1) \\<in> set (local.shift qs)\n  poly_deg h1 = poly_deg h2\n  m < card U1", "have \"(h1, U1) \\<in> ?C\""], ["proof (prove)\nusing this:\n  (h1, U1) \\<in> set (local.shift qs)\n  poly_deg h1 = poly_deg h2\n  m < card U1\n\ngoal (1 subgoal):\n 1. (h1, U1)\n    \\<in> {q \\<in> set (local.shift qs).\n           poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}", "by simp"], ["proof (state)\nthis:\n  (h1, U1)\n  \\<in> {q \\<in> set (local.shift qs).\n         poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "moreover"], ["proof (state)\nthis:\n  (h1, U1)\n  \\<in> {q \\<in> set (local.shift qs).\n         poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "from 2 5"], ["proof (chain)\npicking this:\n  (h2, U2) \\<in> set (local.shift qs)\n  m < card U2", "have \"(h2, U2) \\<in> ?C\""], ["proof (prove)\nusing this:\n  (h2, U2) \\<in> set (local.shift qs)\n  m < card U2\n\ngoal (1 subgoal):\n 1. (h2, U2)\n    \\<in> {q \\<in> set (local.shift qs).\n           poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}", "by simp"], ["proof (state)\nthis:\n  (h2, U2)\n  \\<in> {q \\<in> set (local.shift qs).\n         poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. \\<And>h h' U U'.\n       \\<lbrakk>(h, U) \\<in> set (local.shift qs);\n        (h', U') \\<in> set (local.shift qs); poly_deg h = poly_deg h';\n        m < card U; m < card U'\\<rbrakk>\n       \\<Longrightarrow> (h, U) = (h', U')", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  card\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  \\<le> 1\n  (h1, U1)\n  \\<in> {q \\<in> set (local.shift qs).\n         poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  (h2, U2)\n  \\<in> {q \\<in> set (local.shift qs).\n         poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}", "show \"(h1, U1) = (h2, U2)\""], ["proof (prove)\nusing this:\n  finite\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  card\n   {q \\<in> set (local.shift qs).\n    poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  \\<le> 1\n  (h1, U1)\n  \\<in> {q \\<in> set (local.shift qs).\n         poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n  (h2, U2)\n  \\<in> {q \\<in> set (local.shift qs).\n         poly_deg (fst q) = poly_deg h2 \\<and> m < card (snd q)}\n\ngoal (1 subgoal):\n 1. (h1, U1) = (h2, U2)", "by (auto simp: card_le_Suc0_iff_eq)"], ["proof (state)\nthis:\n  (h1, U1) = (h2, U2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  exact_decomp m (local.shift qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decomp_shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"monomial_decomp qs\"\n  shows \"monomial_decomp (shift qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (local.shift qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial_decomp (local.shift qs)", "from assms(1, 2, 3)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"shift2_inv k qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. shift2_inv k qs", "by (rule shift2_inv_init)"], ["proof (state)\nthis:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (local.shift qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (local.shift qs)", "unfolding shift_def"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. monomial_decomp\n     (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs)", "using assms(4)"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp\n     (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs)", "by (rule shift2_6)"], ["proof (state)\nthis:\n  monomial_decomp (local.shift qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_decomp_shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"hom_decomp qs\"\n  shows \"hom_decomp (shift qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (local.shift qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_decomp (local.shift qs)", "from assms(1, 2, 3)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"shift2_inv k qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. shift2_inv k qs", "by (rule shift2_inv_init)"], ["proof (state)\nthis:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. hom_decomp (local.shift qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. hom_decomp (local.shift qs)", "unfolding shift_def"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. hom_decomp (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs)", "using assms(4)"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs)", "by (rule shift2_7)"], ["proof (state)\nthis:\n  hom_decomp (local.shift qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_shift:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n    and \"cone_decomp T qs\"\n  shows \"cone_decomp T (shift qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (local.shift qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp T (local.shift qs)", "from assms(1, 2, 3)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"shift2_inv k qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. shift2_inv k qs", "by (rule shift2_inv_init)"], ["proof (state)\nthis:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (local.shift qs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (local.shift qs)", "unfolding shift_def"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. cone_decomp T\n     (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs)", "using assms(4)"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. cone_decomp T\n     (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs)", "by (rule shift2_3)"], ["proof (state)\nthis:\n  cone_decomp T (local.shift qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Max_shift_ge:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (shift qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (local.shift qs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (local.shift qs))", "from assms(1-3)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"shift2_inv k qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. shift2_inv k qs", "by (rule shift2_inv_init)"], ["proof (state)\nthis:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (local.shift qs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (local.shift qs))", "unfolding shift_def"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg `\n               fst `\n               set (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k\n                     qs))", "by (rule shift2_4)"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (local.shift qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shift_Nil_iff:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp (Suc m) qs\"\n  shows \"shift qs = [] \\<longleftrightarrow> qs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.shift qs = []) = (qs = [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (local.shift qs = []) = (qs = [])", "from assms(1-3)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"shift2_inv k qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. shift2_inv k qs", "by (rule shift2_inv_init)"], ["proof (state)\nthis:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. (local.shift qs = []) = (qs = [])", "thus ?thesis"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. (local.shift qs = []) = (qs = [])", "unfolding shift_def"], ["proof (prove)\nusing this:\n  shift2_inv k qs\n\ngoal (1 subgoal):\n 1. (shift2 (k + card {q \\<in> set qs. m < card (snd q)}) k qs = []) =\n    (qs = [])", "by (rule shift2_5)"], ["proof (state)\nthis:\n  (local.shift qs = []) = (qs = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "primrec exact_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<Rightarrow>\n                      ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) \\<times> 'x set) list\" where\n  \"exact_aux k 0 qs = qs\" |\n  \"exact_aux k (Suc m) qs = exact_aux k m (shift k m qs)\""], ["", "lemma exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\"\n  shows \"valid_decomp X (exact_aux k m qs)\" (is ?thesis1)\n    and \"standard_decomp k (exact_aux k m qs)\" (is ?thesis2)\n    and \"exact_decomp 0 (exact_aux k m qs)\" (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (exact_aux k m qs) &&&\n    standard_decomp k (exact_aux k m qs) &&&\n    exact_decomp 0 (exact_aux k m qs)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_decomp X (exact_aux k m qs)\n 2. standard_decomp k (exact_aux k m qs)\n 3. exact_decomp 0 (exact_aux k m qs)", "from assms"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp m qs", "have \"?thesis1 \\<and> ?thesis2 \\<and> ?thesis3\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp m qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact_aux k m qs) \\<and>\n    standard_decomp k (exact_aux k m qs) \\<and>\n    exact_decomp 0 (exact_aux k m qs)", "proof (induct m arbitrary: qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n        exact_decomp 0 qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k 0 qs) \\<and>\n                         standard_decomp k (exact_aux k 0 qs) \\<and>\n                         exact_decomp 0 (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> valid_decomp X\n(exact_aux k m qs) \\<and>\n                                     standard_decomp k\n(exact_aux k m qs) \\<and>\n                                     exact_decomp 0 (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n                         standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n                         exact_decomp 0 (exact_aux k (Suc m) qs)", "case 0"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n        exact_decomp 0 qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k 0 qs) \\<and>\n                         standard_decomp k (exact_aux k 0 qs) \\<and>\n                         exact_decomp 0 (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> valid_decomp X\n(exact_aux k m qs) \\<and>\n                                     standard_decomp k\n(exact_aux k m qs) \\<and>\n                                     exact_decomp 0 (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n                         standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n                         exact_decomp 0 (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact_aux k 0 qs) \\<and>\n    standard_decomp k (exact_aux k 0 qs) \\<and>\n    exact_decomp 0 (exact_aux k 0 qs)", "by simp"], ["proof (state)\nthis:\n  valid_decomp X (exact_aux k 0 qs) \\<and>\n  standard_decomp k (exact_aux k 0 qs) \\<and>\n  exact_decomp 0 (exact_aux k 0 qs)\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> valid_decomp X\n(exact_aux k m qs) \\<and>\n                                     standard_decomp k\n(exact_aux k m qs) \\<and>\n                                     exact_decomp 0 (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n                         standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n                         exact_decomp 0 (exact_aux k (Suc m) qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> valid_decomp X\n(exact_aux k m qs) \\<and>\n                                     standard_decomp k\n(exact_aux k m qs) \\<and>\n                                     exact_decomp 0 (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n                         standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n                         exact_decomp 0 (exact_aux k (Suc m) qs)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ?qs46; standard_decomp k ?qs46;\n   exact_decomp m ?qs46\\<rbrakk>\n  \\<Longrightarrow> valid_decomp X (exact_aux k m ?qs46) \\<and>\n                    standard_decomp k (exact_aux k m ?qs46) \\<and>\n                    exact_decomp 0 (exact_aux k m ?qs46)\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> valid_decomp X\n(exact_aux k m qs) \\<and>\n                                     standard_decomp k\n(exact_aux k m qs) \\<and>\n                                     exact_decomp 0 (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n                         standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n                         exact_decomp 0 (exact_aux k (Suc m) qs)", "let ?qs = \"shift k m qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> valid_decomp X\n(exact_aux k m qs) \\<and>\n                                     standard_decomp k\n(exact_aux k m qs) \\<and>\n                                     exact_decomp 0 (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n                         standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n                         exact_decomp 0 (exact_aux k (Suc m) qs)", "have \"valid_decomp X (exact_aux k m ?qs) \\<and> standard_decomp k (exact_aux k m ?qs) \\<and>\n          exact_decomp 0 (exact_aux k m ?qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (exact_aux k m (local.shift k m qs)) \\<and>\n    standard_decomp k (exact_aux k m (local.shift k m qs)) \\<and>\n    exact_decomp 0 (exact_aux k m (local.shift k m qs))", "proof (rule Suc)"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift k m qs)\n 2. standard_decomp k (local.shift k m qs)\n 3. exact_decomp m (local.shift k m qs)", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "show \"valid_decomp X ?qs\" and \"standard_decomp k ?qs\" and \"exact_decomp m ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "by (rule shift)+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift k m qs)\n  standard_decomp k (local.shift k m qs)\n  exact_decomp m (local.shift k m qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_decomp X (exact_aux k m (local.shift k m qs)) \\<and>\n  standard_decomp k (exact_aux k m (local.shift k m qs)) \\<and>\n  exact_decomp 0 (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> valid_decomp X\n(exact_aux k m qs) \\<and>\n                                     standard_decomp k\n(exact_aux k m qs) \\<and>\n                                     exact_decomp 0 (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n                         standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n                         exact_decomp 0 (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_decomp X (exact_aux k m (local.shift k m qs)) \\<and>\n  standard_decomp k (exact_aux k m (local.shift k m qs)) \\<and>\n  exact_decomp 0 (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n    standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n    exact_decomp 0 (exact_aux k (Suc m) qs)", "by simp"], ["proof (state)\nthis:\n  valid_decomp X (exact_aux k (Suc m) qs) \\<and>\n  standard_decomp k (exact_aux k (Suc m) qs) \\<and>\n  exact_decomp 0 (exact_aux k (Suc m) qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_decomp X (exact_aux k m qs) \\<and>\n  standard_decomp k (exact_aux k m qs) \\<and>\n  exact_decomp 0 (exact_aux k m qs)\n\ngoal (3 subgoals):\n 1. valid_decomp X (exact_aux k m qs)\n 2. standard_decomp k (exact_aux k m qs)\n 3. exact_decomp 0 (exact_aux k m qs)", "thus ?thesis1 and ?thesis2 and ?thesis3"], ["proof (prove)\nusing this:\n  valid_decomp X (exact_aux k m qs) \\<and>\n  standard_decomp k (exact_aux k m qs) \\<and>\n  exact_decomp 0 (exact_aux k m qs)\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact_aux k m qs) &&&\n    standard_decomp k (exact_aux k m qs) &&&\n    exact_decomp 0 (exact_aux k m qs)", "by simp_all"], ["proof (state)\nthis:\n  valid_decomp X (exact_aux k m qs)\n  standard_decomp k (exact_aux k m qs)\n  exact_decomp 0 (exact_aux k m qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decomp_exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\" and \"monomial_decomp qs\"\n  shows \"monomial_decomp (exact_aux k m qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (exact_aux k m qs)", "using assms"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp m qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact_aux k m qs)", "proof (induct m arbitrary: qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs; exact_decomp 0 qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; monomial_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> monomial_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k (Suc m) qs)", "case 0"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n  monomial_decomp qs\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs; exact_decomp 0 qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; monomial_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> monomial_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact_aux k 0 qs)", "by simp"], ["proof (state)\nthis:\n  monomial_decomp (exact_aux k 0 qs)\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; monomial_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> monomial_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k (Suc m) qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; monomial_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> monomial_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k (Suc m) qs)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ?qs46; standard_decomp k ?qs46;\n   exact_decomp m ?qs46; monomial_decomp ?qs46\\<rbrakk>\n  \\<Longrightarrow> monomial_decomp (exact_aux k m ?qs46)\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; monomial_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> monomial_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k (Suc m) qs)", "let ?qs = \"shift k m qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; monomial_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> monomial_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k (Suc m) qs)", "have \"monomial_decomp (exact_aux k m ?qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (exact_aux k m (local.shift k m qs))", "proof (rule Suc)"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_decomp X (local.shift k m qs)\n 2. standard_decomp k (local.shift k m qs)\n 3. exact_decomp m (local.shift k m qs)\n 4. monomial_decomp (local.shift k m qs)", "show \"valid_decomp X ?qs\" and \"standard_decomp k ?qs\" and \"exact_decomp m ?qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "using Suc.prems(1, 2, 3)"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "by (rule shift)+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift k m qs)\n  standard_decomp k (local.shift k m qs)\n  exact_decomp m (local.shift k m qs)\n\ngoal (1 subgoal):\n 1. monomial_decomp (local.shift k m qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial_decomp (local.shift k m qs)", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  monomial_decomp qs", "show \"monomial_decomp ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (local.shift k m qs)", "by (rule monomial_decomp_shift)"], ["proof (state)\nthis:\n  monomial_decomp (local.shift k m qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monomial_decomp (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; monomial_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> monomial_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        monomial_decomp qs\\<rbrakk>\n       \\<Longrightarrow> monomial_decomp (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  monomial_decomp (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact_aux k (Suc m) qs)", "by simp"], ["proof (state)\nthis:\n  monomial_decomp (exact_aux k (Suc m) qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_decomp_exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\" and \"hom_decomp qs\"\n  shows \"hom_decomp (exact_aux k m qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (exact_aux k m qs)", "using assms"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp m qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp (exact_aux k m qs)", "proof (induct m arbitrary: qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs; exact_decomp 0 qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; hom_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> hom_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k (Suc m) qs)", "case 0"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n  hom_decomp qs\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs; exact_decomp 0 qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; hom_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> hom_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp (exact_aux k 0 qs)", "by simp"], ["proof (state)\nthis:\n  hom_decomp (exact_aux k 0 qs)\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; hom_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> hom_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k (Suc m) qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; hom_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> hom_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k (Suc m) qs)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ?qs46; standard_decomp k ?qs46;\n   exact_decomp m ?qs46; hom_decomp ?qs46\\<rbrakk>\n  \\<Longrightarrow> hom_decomp (exact_aux k m ?qs46)\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; hom_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> hom_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k (Suc m) qs)", "let ?qs = \"shift k m qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; hom_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> hom_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k (Suc m) qs)", "have \"hom_decomp (exact_aux k m ?qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (exact_aux k m (local.shift k m qs))", "proof (rule Suc)"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_decomp X (local.shift k m qs)\n 2. standard_decomp k (local.shift k m qs)\n 3. exact_decomp m (local.shift k m qs)\n 4. hom_decomp (local.shift k m qs)", "show \"valid_decomp X ?qs\" and \"standard_decomp k ?qs\" and \"exact_decomp m ?qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "using Suc.prems(1, 2, 3)"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "by (rule shift)+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift k m qs)\n  standard_decomp k (local.shift k m qs)\n  exact_decomp m (local.shift k m qs)\n\ngoal (1 subgoal):\n 1. hom_decomp (local.shift k m qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_decomp (local.shift k m qs)", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  hom_decomp qs", "show \"hom_decomp ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp (local.shift k m qs)", "by (rule hom_decomp_shift)"], ["proof (state)\nthis:\n  hom_decomp (local.shift k m qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hom_decomp (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; hom_decomp qs\\<rbrakk>\n                   \\<Longrightarrow> hom_decomp (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        hom_decomp qs\\<rbrakk>\n       \\<Longrightarrow> hom_decomp (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  hom_decomp (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. hom_decomp (exact_aux k (Suc m) qs)", "by simp"], ["proof (state)\nthis:\n  hom_decomp (exact_aux k (Suc m) qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_exact_aux:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\" and \"cone_decomp T qs\"\n  shows \"cone_decomp T (exact_aux k m qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (exact_aux k m qs)", "using assms"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp m qs\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (exact_aux k m qs)", "proof (induct m arbitrary: qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs; exact_decomp 0 qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; cone_decomp T qs\\<rbrakk>\n                   \\<Longrightarrow> cone_decomp T (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k (Suc m) qs)", "case 0"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n  cone_decomp T qs\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs; exact_decomp 0 qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k 0 qs)\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; cone_decomp T qs\\<rbrakk>\n                   \\<Longrightarrow> cone_decomp T (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (exact_aux k 0 qs)", "by simp"], ["proof (state)\nthis:\n  cone_decomp T (exact_aux k 0 qs)\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; cone_decomp T qs\\<rbrakk>\n                   \\<Longrightarrow> cone_decomp T (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k (Suc m) qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; cone_decomp T qs\\<rbrakk>\n                   \\<Longrightarrow> cone_decomp T (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k (Suc m) qs)", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ?qs46; standard_decomp k ?qs46;\n   exact_decomp m ?qs46; cone_decomp T ?qs46\\<rbrakk>\n  \\<Longrightarrow> cone_decomp T (exact_aux k m ?qs46)\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; cone_decomp T qs\\<rbrakk>\n                   \\<Longrightarrow> cone_decomp T (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k (Suc m) qs)", "let ?qs = \"shift k m qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; cone_decomp T qs\\<rbrakk>\n                   \\<Longrightarrow> cone_decomp T (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k (Suc m) qs)", "have \"cone_decomp T (exact_aux k m ?qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (exact_aux k m (local.shift k m qs))", "proof (rule Suc)"], ["proof (state)\ngoal (4 subgoals):\n 1. valid_decomp X (local.shift k m qs)\n 2. standard_decomp k (local.shift k m qs)\n 3. exact_decomp m (local.shift k m qs)\n 4. cone_decomp T (local.shift k m qs)", "show \"valid_decomp X ?qs\" and \"standard_decomp k ?qs\" and \"exact_decomp m ?qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "using Suc.prems(1, 2, 3)"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "by (rule shift)+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift k m qs)\n  standard_decomp k (local.shift k m qs)\n  exact_decomp m (local.shift k m qs)\n\ngoal (1 subgoal):\n 1. cone_decomp T (local.shift k m qs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp T (local.shift k m qs)", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  cone_decomp T qs", "show \"cone_decomp T ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (local.shift k m qs)", "by (rule cone_decomp_shift)"], ["proof (state)\nthis:\n  cone_decomp T (local.shift k m qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cone_decomp T (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs; cone_decomp T qs\\<rbrakk>\n                   \\<Longrightarrow> cone_decomp T (exact_aux k m qs);\n        valid_decomp X qs; standard_decomp k qs; exact_decomp (Suc m) qs;\n        cone_decomp T qs\\<rbrakk>\n       \\<Longrightarrow> cone_decomp T (exact_aux k (Suc m) qs)", "thus ?case"], ["proof (prove)\nusing this:\n  cone_decomp T (exact_aux k m (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. cone_decomp T (exact_aux k (Suc m) qs)", "by simp"], ["proof (state)\nthis:\n  cone_decomp T (exact_aux k (Suc m) qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Max_exact_aux_ge:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\"\n  shows \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (exact_aux k m qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact_aux k m qs))", "using assms"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp m qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact_aux k m qs))", "proof (induct m arbitrary: qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n        exact_decomp 0 qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg ` fst ` set (exact_aux k 0 qs))\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "case 0"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n        exact_decomp 0 qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg ` fst ` set (exact_aux k 0 qs))\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact_aux k 0 qs))", "by simp"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (exact_aux k 0 qs))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ?qs46; standard_decomp k ?qs46;\n   exact_decomp m ?qs46\\<rbrakk>\n  \\<Longrightarrow> Max (poly_deg ` fst ` set ?qs46)\n                    \\<le> Max (poly_deg ` fst ` set (exact_aux k m ?qs46))\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "let ?qs = \"shift k m qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set ?qs)\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (local.shift k m qs))", "by (rule Max_shift_ge)"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "also"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (local.shift k m qs))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "have \"\\<dots> \\<le> Max (poly_deg ` fst ` set (exact_aux k m ?qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set (local.shift k m qs))\n    \\<le> Max (poly_deg ` fst ` set (exact_aux k m (local.shift k m qs)))", "proof (rule Suc)"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift k m qs)\n 2. standard_decomp k (local.shift k m qs)\n 3. exact_decomp m (local.shift k m qs)", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "show \"valid_decomp X ?qs\" and \"standard_decomp k ?qs\" and \"exact_decomp m ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "by (rule shift)+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift k m qs)\n  standard_decomp k (local.shift k m qs)\n  exact_decomp m (local.shift k m qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set (local.shift k m qs))\n  \\<le> Max (poly_deg ` fst ` set (exact_aux k m (local.shift k m qs)))\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                                     \\<le> Max\n      (poly_deg ` fst ` set (exact_aux k m qs));\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> Max (poly_deg ` fst ` set qs)\n                         \\<le> Max (poly_deg `\n                                    fst ` set (exact_aux k (Suc m) qs))", "finally"], ["proof (chain)\npicking this:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (exact_aux k m (local.shift k m qs)))", "show ?case"], ["proof (prove)\nusing this:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (exact_aux k m (local.shift k m qs)))\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact_aux k (Suc m) qs))", "by simp"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (exact_aux k (Suc m) qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exact_aux_Nil_iff:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"exact_decomp m qs\"\n  shows \"exact_aux k m qs = [] \\<longleftrightarrow> qs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exact_aux k m qs = []) = (qs = [])", "using assms"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp m qs\n\ngoal (1 subgoal):\n 1. (exact_aux k m qs = []) = (qs = [])", "proof (induct m arbitrary: qs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n        exact_decomp 0 qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k 0 qs = []) = (qs = [])\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "case 0"], ["proof (state)\nthis:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n\ngoal (2 subgoals):\n 1. \\<And>qs.\n       \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n        exact_decomp 0 qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k 0 qs = []) = (qs = [])\n 2. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "thus ?case"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp 0 qs\n\ngoal (1 subgoal):\n 1. (exact_aux k 0 qs = []) = (qs = [])", "by simp"], ["proof (state)\nthis:\n  (exact_aux k 0 qs = []) = (qs = [])\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_decomp X ?qs46; standard_decomp k ?qs46;\n   exact_decomp m ?qs46\\<rbrakk>\n  \\<Longrightarrow> (exact_aux k m ?qs46 = []) = (?qs46 = [])\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "let ?qs = \"shift k m qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "have \"exact_aux k m ?qs = [] \\<longleftrightarrow> ?qs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exact_aux k m (local.shift k m qs) = []) = (local.shift k m qs = [])", "proof (rule Suc)"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_decomp X (local.shift k m qs)\n 2. standard_decomp k (local.shift k m qs)\n 3. exact_decomp m (local.shift k m qs)", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "show \"valid_decomp X ?qs\" and \"standard_decomp k ?qs\" and \"exact_decomp m ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (local.shift k m qs) &&&\n    standard_decomp k (local.shift k m qs) &&&\n    exact_decomp m (local.shift k m qs)", "by (rule shift)+"], ["proof (state)\nthis:\n  valid_decomp X (local.shift k m qs)\n  standard_decomp k (local.shift k m qs)\n  exact_decomp m (local.shift k m qs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (exact_aux k m (local.shift k m qs) = []) = (local.shift k m qs = [])\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "also"], ["proof (state)\nthis:\n  (exact_aux k m (local.shift k m qs) = []) = (local.shift k m qs = [])\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "from Suc.prems"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs", "have \"\\<dots> \\<longleftrightarrow> qs = []\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (Suc m) qs\n\ngoal (1 subgoal):\n 1. (local.shift k m qs = []) = (qs = [])", "by (rule shift_Nil_iff)"], ["proof (state)\nthis:\n  (local.shift k m qs = []) = (qs = [])\n\ngoal (1 subgoal):\n 1. \\<And>m qs.\n       \\<lbrakk>\\<And>qs.\n                   \\<lbrakk>valid_decomp X qs; standard_decomp k qs;\n                    exact_decomp m qs\\<rbrakk>\n                   \\<Longrightarrow> (exact_aux k m qs = []) = (qs = []);\n        valid_decomp X qs; standard_decomp k qs;\n        exact_decomp (Suc m) qs\\<rbrakk>\n       \\<Longrightarrow> (exact_aux k (Suc m) qs = []) = (qs = [])", "finally"], ["proof (chain)\npicking this:\n  (exact_aux k m (local.shift k m qs) = []) = (qs = [])", "show ?case"], ["proof (prove)\nusing this:\n  (exact_aux k m (local.shift k m qs) = []) = (qs = [])\n\ngoal (1 subgoal):\n 1. (exact_aux k (Suc m) qs = []) = (qs = [])", "by simp"], ["proof (state)\nthis:\n  (exact_aux k (Suc m) qs = []) = (qs = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "definition exact :: \"nat \\<Rightarrow> ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a) \\<times> 'x set) list \\<Rightarrow>\n                        ((('x \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a::{comm_ring_1,ring_no_zero_divisors}) \\<times> 'x set) list\"\n  where \"exact k qs = exact_aux k (card X) qs\""], ["", "lemma exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\"\n  shows \"valid_decomp X (exact k qs)\" (is ?thesis1)\n    and \"standard_decomp k (exact k qs)\" (is ?thesis2)\n    and \"exact_decomp 0 (exact k qs)\" (is ?thesis3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_decomp X (exact k qs) &&&\n    standard_decomp k (exact k qs) &&& exact_decomp 0 (exact k qs)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. valid_decomp X (exact k qs)\n 2. standard_decomp k (exact k qs)\n 3. exact_decomp 0 (exact k qs)", "from assms(1) le_refl"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  ?n \\<le> ?n", "have \"exact_decomp (card X) qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. exact_decomp (card X) qs", "by (rule exact_decomp_card_X)"], ["proof (state)\nthis:\n  exact_decomp (card X) qs\n\ngoal (3 subgoals):\n 1. valid_decomp X (exact k qs)\n 2. standard_decomp k (exact k qs)\n 3. exact_decomp 0 (exact k qs)", "with assms"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs", "show ?thesis1 and ?thesis2 and ?thesis3"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact k qs) &&&\n    standard_decomp k (exact k qs) &&& exact_decomp 0 (exact k qs)", "unfolding exact_def"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact_aux k (card X) qs) &&&\n    standard_decomp k (exact_aux k (card X) qs) &&&\n    exact_decomp 0 (exact_aux k (card X) qs)", "by (rule exact_aux)+"], ["proof (state)\nthis:\n  valid_decomp X (exact k qs)\n  standard_decomp k (exact k qs)\n  exact_decomp 0 (exact k qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monomial_decomp_exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"monomial_decomp qs\"\n  shows \"monomial_decomp (exact k qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial_decomp (exact k qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial_decomp (exact k qs)", "from assms(1) le_refl"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  ?n \\<le> ?n", "have \"exact_decomp (card X) qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. exact_decomp (card X) qs", "by (rule exact_decomp_card_X)"], ["proof (state)\nthis:\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact k qs)", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact k qs)", "unfolding exact_def"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact_aux k (card X) qs)", "using assms(3)"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact_aux k (card X) qs)", "by (rule monomial_decomp_exact_aux)"], ["proof (state)\nthis:\n  monomial_decomp (exact k qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hom_decomp_exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"hom_decomp qs\"\n  shows \"hom_decomp (exact k qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_decomp (exact k qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom_decomp (exact k qs)", "from assms(1) le_refl"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  ?n \\<le> ?n", "have \"exact_decomp (card X) qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. exact_decomp (card X) qs", "by (rule exact_decomp_card_X)"], ["proof (state)\nthis:\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. hom_decomp (exact k qs)", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. hom_decomp (exact k qs)", "unfolding exact_def"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. hom_decomp (exact_aux k (card X) qs)", "using assms(3)"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n  hom_decomp qs\n\ngoal (1 subgoal):\n 1. hom_decomp (exact_aux k (card X) qs)", "by (rule hom_decomp_exact_aux)"], ["proof (state)\nthis:\n  hom_decomp (exact k qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cone_decomp_exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"cone_decomp T qs\"\n  shows \"cone_decomp T (exact k qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cone_decomp T (exact k qs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cone_decomp T (exact k qs)", "from assms(1) le_refl"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  ?n \\<le> ?n", "have \"exact_decomp (card X) qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. exact_decomp (card X) qs", "by (rule exact_decomp_card_X)"], ["proof (state)\nthis:\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (exact k qs)", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (exact k qs)", "unfolding exact_def"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (exact_aux k (card X) qs)", "using assms(3)"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n  cone_decomp T qs\n\ngoal (1 subgoal):\n 1. cone_decomp T (exact_aux k (card X) qs)", "by (rule cone_decomp_exact_aux)"], ["proof (state)\nthis:\n  cone_decomp T (exact k qs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Max_exact_ge:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\"\n  shows \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (exact k qs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact k qs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact k qs))", "from assms(1) le_refl"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  ?n \\<le> ?n", "have \"exact_decomp (card X) qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. exact_decomp (card X) qs", "by (rule exact_decomp_card_X)"], ["proof (state)\nthis:\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact k qs))", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact k qs))", "unfolding exact_def"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact_aux k (card X) qs))", "by (rule Max_exact_aux_ge)"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (exact k qs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exact_Nil_iff:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\"\n  shows \"exact k qs = [] \\<longleftrightarrow> qs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exact k qs = []) = (qs = [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (exact k qs = []) = (qs = [])", "from assms(1) le_refl"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  ?n \\<le> ?n", "have \"exact_decomp (card X) qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  ?n \\<le> ?n\n\ngoal (1 subgoal):\n 1. exact_decomp (card X) qs", "by (rule exact_decomp_card_X)"], ["proof (state)\nthis:\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. (exact k qs = []) = (qs = [])", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. (exact k qs = []) = (qs = [])", "unfolding exact_def"], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  exact_decomp (card X) qs\n\ngoal (1 subgoal):\n 1. (exact_aux k (card X) qs = []) = (qs = [])", "by (rule exact_aux_Nil_iff)"], ["proof (state)\nthis:\n  (exact k qs = []) = (qs = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \\<b>_zero_exact:\n  assumes \"valid_decomp X qs\" and \"standard_decomp k qs\" and \"qs \\<noteq> []\"\n  shows \"Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0", "from assms(1, 2)"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs", "have \"Max (poly_deg ` fst ` set qs) \\<le> Max (poly_deg ` fst ` set (exact k qs))\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n\ngoal (1 subgoal):\n 1. Max (poly_deg ` fst ` set qs)\n    \\<le> Max (poly_deg ` fst ` set (exact k qs))", "by (rule Max_exact_ge)"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (exact k qs))\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0", "also"], ["proof (state)\nthis:\n  Max (poly_deg ` fst ` set qs)\n  \\<le> Max (poly_deg ` fst ` set (exact k qs))\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0", "have \"Suc \\<dots> \\<le> \\<b> (exact k qs) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set (exact k qs))) \\<le> \\<b> (exact k qs) 0", "proof (rule \\<b>_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. exact k qs \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp k qs\n  qs \\<noteq> []", "show \"exact k qs \\<noteq> []\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp k qs\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. exact k qs \\<noteq> []", "by (simp add: exact_Nil_iff)"], ["proof (state)\nthis:\n  exact k qs \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (Max (poly_deg ` fst ` set (exact k qs))) \\<le> \\<b> (exact k qs) 0\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0", "by simp"], ["proof (state)\nthis:\n  Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact k qs) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normal_form_exact_decompE:\n  assumes \"F \\<subseteq> P[X]\"\n  obtains qs where \"valid_decomp X qs\" and \"standard_decomp 0 qs\" and \"monomial_decomp qs\"\n    and \"cone_decomp (normal_form F ` P[X]) qs\" and \"exact_decomp 0 qs\"\n    and \"\\<And>g. (\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f) \\<Longrightarrow> g \\<in> punit.reduced_GB F \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?G = \"punit.reduced_GB F\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?S = \"lpp ` ?G\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?N = \"normal_form F ` P[X]\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define qs::\"((_ \\<Rightarrow>\\<^sub>0 'a) \\<times> _) list\" where \"qs = snd (split 0 X ?S)\""], ["proof (state)\nthis:\n  qs = snd (split 0 X (lpp ` punit.reduced_GB F))\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from fin_X assms"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have std: \"standard_decomp 0 qs\" and cn: \"cone_decomp ?N qs\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. standard_decomp 0 qs &&& cone_decomp (normal_form F ` P[X]) qs", "unfolding qs_def"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. standard_decomp 0 (snd (split 0 X (lpp ` punit.reduced_GB F))) &&&\n    cone_decomp (normal_form F ` P[X])\n     (snd (split 0 X (lpp ` punit.reduced_GB F)))", "by (rule standard_cone_decomp_snd_split)+"], ["proof (state)\nthis:\n  standard_decomp 0 qs\n  cone_decomp (normal_form F ` P[X]) qs\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from fin_X assms"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]", "have \"finite ?G\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. finite (punit.reduced_GB F)", "by (rule finite_reduced_GB_Polys)"], ["proof (state)\nthis:\n  finite (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"finite ?S\""], ["proof (prove)\nusing this:\n  finite (punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. finite (lpp ` punit.reduced_GB F)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (lpp ` punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with fin_X subset_refl"], ["proof (chain)\npicking this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` punit.reduced_GB F)", "have valid: \"valid_decomp X qs\""], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. valid_decomp X qs", "unfolding qs_def"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. valid_decomp X (snd (split 0 X (lpp ` punit.reduced_GB F)))", "using zero_in_PPs"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` punit.reduced_GB F)\n  0 \\<in> .[?X]\n\ngoal (1 subgoal):\n 1. valid_decomp X (snd (split 0 X (lpp ` punit.reduced_GB F)))", "by (rule valid_decomp_split)"], ["proof (state)\nthis:\n  valid_decomp X qs\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from fin_X subset_refl \\<open>finite ?S\\<close>"], ["proof (chain)\npicking this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` punit.reduced_GB F)", "have md: \"monomial_decomp qs\""], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. monomial_decomp qs", "unfolding qs_def"], ["proof (prove)\nusing this:\n  finite X\n  ?A \\<subseteq> ?A\n  finite (lpp ` punit.reduced_GB F)\n\ngoal (1 subgoal):\n 1. monomial_decomp (snd (split 0 X (lpp ` punit.reduced_GB F)))", "by (rule monomial_decomp_split)"], ["proof (state)\nthis:\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?qs = \"exact 0 qs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from valid std"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp 0 qs", "have \"valid_decomp X ?qs\" and \"standard_decomp 0 ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n\ngoal (1 subgoal):\n 1. valid_decomp X (exact 0 qs) &&& standard_decomp 0 (exact 0 qs)", "by (rule exact)+"], ["proof (state)\nthis:\n  valid_decomp X (exact 0 qs)\n  standard_decomp 0 (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  valid_decomp X (exact 0 qs)\n  standard_decomp 0 (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from valid std md"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n  monomial_decomp qs", "have \"monomial_decomp ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n  monomial_decomp qs\n\ngoal (1 subgoal):\n 1. monomial_decomp (exact 0 qs)", "by (rule monomial_decomp_exact)"], ["proof (state)\nthis:\n  monomial_decomp (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  monomial_decomp (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from valid std cn"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n  cone_decomp (normal_form F ` P[X]) qs", "have \"cone_decomp ?N ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n  cone_decomp (normal_form F ` P[X]) qs\n\ngoal (1 subgoal):\n 1. cone_decomp (normal_form F ` P[X]) (exact 0 qs)", "by (rule cone_decomp_exact)"], ["proof (state)\nthis:\n  cone_decomp (normal_form F ` P[X]) (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  cone_decomp (normal_form F ` P[X]) (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from valid std"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp 0 qs", "have \"exact_decomp 0 ?qs\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n\ngoal (1 subgoal):\n 1. exact_decomp 0 (exact 0 qs)", "by (rule exact)"], ["proof (state)\nthis:\n  exact_decomp 0 (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  exact_decomp 0 (exact 0 qs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly_deg g \\<le> \\<b> ?qs 0\" if \"\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f\" and \"g \\<in> ?G\" for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg g \\<le> \\<b> (exact 0 qs) 0", "proof (cases \"qs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0\n 2. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "case True"], ["proof (state)\nthis:\n  qs = []\n\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0\n 2. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "from one_in_Polys"], ["proof (chain)\npicking this:\n  1 \\<in> P[?X]", "have \"normal_form F 1 \\<in> ?N\""], ["proof (prove)\nusing this:\n  1 \\<in> P[?X]\n\ngoal (1 subgoal):\n 1. normal_form F 1 \\<in> normal_form F ` P[X]", "by (rule imageI)"], ["proof (state)\nthis:\n  normal_form F 1 \\<in> normal_form F ` P[X]\n\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0\n 2. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "also"], ["proof (state)\nthis:\n  normal_form F 1 \\<in> normal_form F ` P[X]\n\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0\n 2. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "from True cn"], ["proof (chain)\npicking this:\n  qs = []\n  cone_decomp (normal_form F ` P[X]) qs", "have \"\\<dots> = {0}\""], ["proof (prove)\nusing this:\n  qs = []\n  cone_decomp (normal_form F ` P[X]) qs\n\ngoal (1 subgoal):\n 1. normal_form F ` P[X] = {0}", "by (simp add: cone_decomp_def direct_decomp_def bij_betw_def)"], ["proof (state)\nthis:\n  normal_form F ` P[X] = {0}\n\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0\n 2. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "finally"], ["proof (chain)\npicking this:\n  normal_form F 1 \\<in> {0}", "have \"?G = {1}\""], ["proof (prove)\nusing this:\n  normal_form F 1 \\<in> {0}\n\ngoal (1 subgoal):\n 1. punit.reduced_GB F = {1}", "using fin_X assms"], ["proof (prove)\nusing this:\n  normal_form F 1 \\<in> {0}\n  finite X\n  F \\<subseteq> P[X]\n\ngoal (1 subgoal):\n 1. punit.reduced_GB F = {1}", "by (simp add: normal_form_zero_iff ideal_eq_UNIV_iff_reduced_GB_eq_one_Polys\n                flip: ideal_eq_UNIV_iff_contains_one)"], ["proof (state)\nthis:\n  punit.reduced_GB F = {1}\n\ngoal (2 subgoals):\n 1. qs = [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0\n 2. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "with that(2)"], ["proof (chain)\npicking this:\n  g \\<in> punit.reduced_GB F\n  punit.reduced_GB F = {1}", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<in> punit.reduced_GB F\n  punit.reduced_GB F = {1}\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> \\<b> (exact 0 qs) 0", "by simp"], ["proof (state)\nthis:\n  poly_deg g \\<le> \\<b> (exact 0 qs) 0\n\ngoal (1 subgoal):\n 1. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "case False"], ["proof (state)\nthis:\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "from fin_X assms that"], ["proof (chain)\npicking this:\n  finite X\n  F \\<subseteq> P[X]\n  ?f47 \\<in> F \\<Longrightarrow> homogeneous ?f47\n  g \\<in> punit.reduced_GB F", "have \"poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set qs))\""], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n  ?f47 \\<in> F \\<Longrightarrow> homogeneous ?f47\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set qs))", "unfolding qs_def"], ["proof (prove)\nusing this:\n  finite X\n  F \\<subseteq> P[X]\n  ?f47 \\<in> F \\<Longrightarrow> homogeneous ?f47\n  g \\<in> punit.reduced_GB F\n\ngoal (1 subgoal):\n 1. poly_deg g\n    \\<le> Suc (Max (poly_deg `\n                    fst ` set (snd (split 0 X (lpp ` punit.reduced_GB F)))))", "by (rule standard_cone_decomp_snd_split)"], ["proof (state)\nthis:\n  poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set qs))\n\ngoal (1 subgoal):\n 1. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "also"], ["proof (state)\nthis:\n  poly_deg g \\<le> Suc (Max (poly_deg ` fst ` set qs))\n\ngoal (1 subgoal):\n 1. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "from valid std False"], ["proof (chain)\npicking this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n  qs \\<noteq> []", "have \"\\<dots> \\<le> \\<b> ?qs 0\""], ["proof (prove)\nusing this:\n  valid_decomp X qs\n  standard_decomp 0 qs\n  qs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact 0 qs) 0", "by (rule \\<b>_zero_exact)"], ["proof (state)\nthis:\n  Suc (Max (poly_deg ` fst ` set qs)) \\<le> \\<b> (exact 0 qs) 0\n\ngoal (1 subgoal):\n 1. qs \\<noteq> [] \\<Longrightarrow> poly_deg g \\<le> \\<b> (exact 0 qs) 0", "finally"], ["proof (chain)\npicking this:\n  poly_deg g \\<le> \\<b> (exact 0 qs) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_deg g \\<le> \\<b> (exact 0 qs) 0\n\ngoal (1 subgoal):\n 1. poly_deg g \\<le> \\<b> (exact 0 qs) 0", "."], ["proof (state)\nthis:\n  poly_deg g \\<le> \\<b> (exact 0 qs) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n   ?g47 \\<in> punit.reduced_GB F\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?g47 \\<le> \\<b> (exact 0 qs) 0\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>valid_decomp X qs; standard_decomp 0 qs;\n         monomial_decomp qs; cone_decomp (normal_form F ` P[X]) qs;\n         exact_decomp 0 qs;\n         \\<And>g.\n            \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n             g \\<in> punit.reduced_GB F\\<rbrakk>\n            \\<Longrightarrow> poly_deg g \\<le> \\<b> qs 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  valid_decomp X (exact 0 qs)\n  standard_decomp 0 (exact 0 qs)\n  monomial_decomp (exact 0 qs)\n  cone_decomp (normal_form F ` P[X]) (exact 0 qs)\n  exact_decomp 0 (exact 0 qs)\n  \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n   ?g47 \\<in> punit.reduced_GB F\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?g47 \\<le> \\<b> (exact 0 qs) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_decomp X (exact 0 qs)\n  standard_decomp 0 (exact 0 qs)\n  monomial_decomp (exact 0 qs)\n  cone_decomp (normal_form F ` P[X]) (exact 0 qs)\n  exact_decomp 0 (exact 0 qs)\n  \\<lbrakk>\\<And>f. f \\<in> F \\<Longrightarrow> homogeneous f;\n   ?g47 \\<in> punit.reduced_GB F\\<rbrakk>\n  \\<Longrightarrow> poly_deg ?g47 \\<le> \\<b> (exact 0 qs) 0\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "(* pm_powerprod *)"], ["", "end"], ["", "(* theory *)"]]}