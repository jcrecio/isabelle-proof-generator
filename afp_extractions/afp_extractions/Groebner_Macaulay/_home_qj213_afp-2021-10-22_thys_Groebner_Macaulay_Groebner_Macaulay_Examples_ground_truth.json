{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay/Groebner_Macaulay_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Macaulay", "problem_names": ["theorem thm_2_3_6_Dube:\n  assumes \"finite X\" and \"set fs \\<subseteq> P[X]\"\n  shows \"punit.is_Groebner_basis (set (punit.Macaulay_list\n                                        (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs)))\"", "theorem thm_2_3_7_Dube:\n  assumes \"finite X\" and \"set fs \\<subseteq> P[X]\"\n  shows \"1 \\<in> ideal (set fs) \\<longleftrightarrow>\n          1 \\<in> set (punit.Macaulay_list (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs))\"", "theorem thm_2_3_6_indets_Dube:\n  fixes fs\n  defines \"X \\<equiv> \\<Union>(indets ` set fs)\"\n  shows \"punit.is_Groebner_basis (set (punit.Macaulay_list\n                                        (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs)))\"", "theorem thm_2_3_7_indets_Dube:\n  fixes fs\n  defines \"X \\<equiv> \\<Union>(indets ` set fs)\"\n  shows \"1 \\<in> ideal (set fs) \\<longleftrightarrow>\n          1 \\<in> set (punit.Macaulay_list (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs))\"", "lemma remdups_wrt_rev_notin: \"v \\<in> set vs \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f xs vs)\"", "lemma distinct_remdups_wrt_rev: \"distinct (map f (remdups_wrt_rev f xs vs))\"", "lemma map_of_remdups_wrt_rev':\n  \"map_of (remdups_wrt_rev fst xs vs) k = map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs) k\"", "lemma (in term_powerprod) compute_list_to_poly [code]:\n  \"list_to_poly ts cs = distr\\<^sub>0 DRLEX (remdups_wrt_rev fst (zip ts cs) [])\"", "lemma (in ordered_term) compute_Macaulay_list [code]:\n  \"Macaulay_list ps =\n     (let ts = Keys_to_list ps in\n      filter (\\<lambda>p. p \\<noteq> 0) (mat_to_polys ts (row_echelon (polys_to_mat ts ps)))\n     )\"", "lemma inj_PP: \"inj PP\"", "lemma inj_mapping_of: \"inj mapping_of\"", "lemma mapping_of_comp_PP [simp]:\n  \"mapping_of \\<circ> PP = (\\<lambda>x. x)\"\n  \"PP \\<circ> mapping_of = (\\<lambda>x. x)\"", "lemma map_key_PP_mapping_of [simp]: \"Poly_Mapping.map_key PP (Poly_Mapping.map_key mapping_of p) = p\"", "lemma map_key_mapping_of_PP [simp]: \"Poly_Mapping.map_key mapping_of (Poly_Mapping.map_key PP p) = p\"", "lemmas map_key_PP_plus = map_key_plus[OF inj_PP]", "lemmas map_key_PP_zero [simp] = map_key_zero[OF inj_PP]", "lemma lookup_map_key_PP: \"lookup (Poly_Mapping.map_key PP p) t = lookup p (PP t)\"", "lemma keys_map_key_PP: \"keys (Poly_Mapping.map_key PP p) = mapping_of ` keys p\"", "lemma map_key_PP_zero_iff [iff]: \"Poly_Mapping.map_key PP p = 0 \\<longleftrightarrow> p = 0\"", "lemma map_key_PP_uminus [simp]: \"Poly_Mapping.map_key PP (- p) = - Poly_Mapping.map_key PP p\"", "lemma map_key_PP_minus:\n  \"Poly_Mapping.map_key PP (p - q) = Poly_Mapping.map_key PP p - Poly_Mapping.map_key PP q\"", "lemma map_key_PP_monomial [simp]: \"Poly_Mapping.map_key PP (monomial c t) = monomial c (mapping_of t)\"", "lemma map_key_PP_one [simp]: \"Poly_Mapping.map_key PP 1 = 1\"", "lemma map_key_PP_monom_mult_punit:\n  \"Poly_Mapping.map_key PP (monom_mult_punit c t p) =\n    monom_mult_punit c (mapping_of t) (Poly_Mapping.map_key PP p)\"", "lemma map_key_PP_times:\n  \"Poly_Mapping.map_key PP (p * q) =\n    Poly_Mapping.map_key PP p * Poly_Mapping.map_key PP (q::(_, _::add_linorder) pp \\<Rightarrow>\\<^sub>0 _)\"", "lemma map_key_PP_sum: \"Poly_Mapping.map_key PP (sum f A) = (\\<Sum>a\\<in>A. Poly_Mapping.map_key PP (f a))\"", "lemma map_key_PP_ideal:\n  \"Poly_Mapping.map_key PP ` ideal F = ideal (Poly_Mapping.map_key PP ` (F::((_, _::add_linorder) pp \\<Rightarrow>\\<^sub>0 _) set))\"", "lemma map_PP_insort:\n  \"map PP (pp_pm.ordered_powerprod_lin.insort x xs) = ordered_powerprod_lin.insort (PP x) (map PP xs)\"", "lemma map_PP_sorted_list_of_set:\n  \"map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` T)\"", "lemma map_PP_pps_to_list: \"map PP (pp_pm.punit.pps_to_list T) = punit.pps_to_list (PP ` T)\"", "lemma map_mapping_of_pps_to_list:\n  \"map mapping_of (punit.pps_to_list T) = pp_pm.punit.pps_to_list (mapping_of ` T)\"", "lemma keys_to_list_map_key_PP:\n  \"pp_pm.punit.keys_to_list (Poly_Mapping.map_key PP p) = map mapping_of (punit.keys_to_list p)\"", "lemma Keys_to_list_map_key_PP:\n  \"pp_pm.punit.Keys_to_list (map (Poly_Mapping.map_key PP) fs) = map mapping_of (punit.Keys_to_list fs)\"", "lemma poly_deg_map_key_PP: \"poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p\"", "lemma deg_le_sect_pp_aux_1:\n  assumes \"t \\<in> keys (deg_le_sect_pp_aux xs n)\"\n  shows \"deg_pp t \\<le> n\" and \"keys_pp t \\<subseteq> set xs\"", "lemma deg_le_sect_pp_aux_2:\n  assumes \"deg_pp t \\<le> n\" and \"keys_pp t \\<subseteq> set xs\"\n  shows \"t \\<in> keys (deg_le_sect_pp_aux xs n)\"", "lemma keys_deg_le_sect_pp_aux:\n  \"keys (deg_le_sect_pp_aux xs n) = {t. deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs}\"", "lemma deg_le_sect_deg_le_sect_pp:\n  \"map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) = deg_le_sect_pp xs d\"", "lemma deg_shifts_deg_shifts_pp:\n  \"pp_pm.deg_shifts (set xs) d (map (Poly_Mapping.map_key PP) fs) =\n        map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs)\"", "lemma ideal_deg_shifts_pp: \"ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)\"", "lemma set_indets_pp: \"set (indets_pp p) = indets (Poly_Mapping.map_key PP p)\"", "lemma poly_to_row_map_key_PP:\n  \"poly_to_row (map pp.mapping_of xs) (Poly_Mapping.map_key PP p) = poly_to_row xs p\"", "lemma Macaulay_mat_map_key_PP:\n  \"pp_pm.punit.Macaulay_mat (map (Poly_Mapping.map_key PP) fs) = punit.Macaulay_mat fs\"", "lemma row_to_poly_mapping_of:\n  assumes \"distinct ts\" and \"dim_vec r = length ts\"\n  shows \"row_to_poly (map pp.mapping_of ts) r = Poly_Mapping.map_key PP (row_to_poly ts r)\"", "lemma mat_to_polys_mapping_of:\n  assumes \"distinct ts\" and \"dim_col m = length ts\"\n  shows \"mat_to_polys (map pp.mapping_of ts) m = map (Poly_Mapping.map_key PP) (mat_to_polys ts m)\"", "lemma map_key_PP_Macaulay_list:\n  \"map (Poly_Mapping.map_key PP) (punit.Macaulay_list fs) =\n      pp_pm.punit.Macaulay_list (map (Poly_Mapping.map_key PP) fs)\"", "lemma lpp_map_key_PP: \"pp_pm.lpp (Poly_Mapping.map_key PP p) = mapping_of (lpp p)\"", "lemma is_GB_map_key_PP:\n  \"finite G \\<Longrightarrow> pp_pm.punit.is_Groebner_basis (Poly_Mapping.map_key PP ` G) \\<longleftrightarrow> punit.is_Groebner_basis G\"", "lemma thm_2_3_6_pp:\n  assumes \"pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs) b\"\n  shows \"punit.is_Groebner_basis (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))\"", "lemma Dube_is_GB_cofactor_bound_pp:\n  \"pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n            (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))\"", "lemma GB_Macaulay_Dube_is_GB: \"punit.is_Groebner_basis (set (GB_Macaulay_Dube fs))\"", "lemma ideal_GB_Macaulay_Dube: \"ideal (set (GB_Macaulay_Dube fs)) = ideal (set fs)\"", "lemma\n  \"comp_red_basis_punit DRLEX (GB_Macaulay_Dube_punit DRLEX [X * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y, Y ^ 3 - X ^ 3]) =\n    [X ^ 5, X ^ 3 * Y - C\\<^sub>0 (1 / 9) * X ^ 4, Y ^ 3 - X ^ 3, X * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y]\""], "translations": [["", "theorem thm_2_3_6_Dube:\n  assumes \"finite X\" and \"set fs \\<subseteq> P[X]\"\n  shows \"punit.is_Groebner_basis (set (punit.Macaulay_list\n                                        (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list\n            (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs)))", "using assms Dube_is_GB_cofactor_bound"], ["proof (prove)\nusing this:\n  finite X\n  set fs \\<subseteq> P[X]\n  \\<lbrakk>finite ?X; finite ?F; ?F \\<subseteq> P[?X]\\<rbrakk>\n  \\<Longrightarrow> is_GB_cofactor_bound ?F\n                     (Dube (Suc (card ?X)) (maxdeg ?F))\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list\n            (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs)))", "by (rule thm_2_3_6) (simp_all add: assms)"], ["", "theorem thm_2_3_7_Dube:\n  assumes \"finite X\" and \"set fs \\<subseteq> P[X]\"\n  shows \"1 \\<in> ideal (set fs) \\<longleftrightarrow>\n          1 \\<in> set (punit.Macaulay_list (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<in> ideal (set fs)) =\n    (1 \\<in> set (punit.Macaulay_list\n                   (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs)))\n                     fs)))", "using assms Dube_is_GB_cofactor_bound"], ["proof (prove)\nusing this:\n  finite X\n  set fs \\<subseteq> P[X]\n  \\<lbrakk>finite ?X; finite ?F; ?F \\<subseteq> P[?X]\\<rbrakk>\n  \\<Longrightarrow> is_GB_cofactor_bound ?F\n                     (Dube (Suc (card ?X)) (maxdeg ?F))\n\ngoal (1 subgoal):\n 1. (1 \\<in> ideal (set fs)) =\n    (1 \\<in> set (punit.Macaulay_list\n                   (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs)))\n                     fs)))", "by (rule thm_2_3_7) (simp_all add: assms)"], ["", "theorem thm_2_3_6_indets_Dube:\n  fixes fs\n  defines \"X \\<equiv> \\<Union>(indets ` set fs)\"\n  shows \"punit.is_Groebner_basis (set (punit.Macaulay_list\n                                        (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list\n            (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs)))", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list\n            (deg_shifts (\\<Union> (indets ` set fs))\n              (Dube (Suc (card (\\<Union> (indets ` set fs))))\n                (maxdeg (set fs)))\n              fs)))", "using Dube_is_GB_cofactor_bound_indets"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  is_GB_cofactor_bound ?F\n   (Dube (Suc (card (\\<Union> (indets ` ?F)))) (maxdeg ?F))\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list\n            (deg_shifts (\\<Union> (indets ` set fs))\n              (Dube (Suc (card (\\<Union> (indets ` set fs))))\n                (maxdeg (set fs)))\n              fs)))", "by (rule thm_2_3_6_indets) (fact finite_set)"], ["", "theorem thm_2_3_7_indets_Dube:\n  fixes fs\n  defines \"X \\<equiv> \\<Union>(indets ` set fs)\"\n  shows \"1 \\<in> ideal (set fs) \\<longleftrightarrow>\n          1 \\<in> set (punit.Macaulay_list (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs))) fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<in> ideal (set fs)) =\n    (1 \\<in> set (punit.Macaulay_list\n                   (deg_shifts X (Dube (Suc (card X)) (maxdeg (set fs)))\n                     fs)))", "unfolding X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<in> ideal (set fs)) =\n    (1 \\<in> set (punit.Macaulay_list\n                   (deg_shifts (\\<Union> (indets ` set fs))\n                     (Dube (Suc (card (\\<Union> (indets ` set fs))))\n                       (maxdeg (set fs)))\n                     fs)))", "using Dube_is_GB_cofactor_bound_indets"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  is_GB_cofactor_bound ?F\n   (Dube (Suc (card (\\<Union> (indets ` ?F)))) (maxdeg ?F))\n\ngoal (1 subgoal):\n 1. (1 \\<in> ideal (set fs)) =\n    (1 \\<in> set (punit.Macaulay_list\n                   (deg_shifts (\\<Union> (indets ` set fs))\n                     (Dube (Suc (card (\\<Union> (indets ` set fs))))\n                       (maxdeg (set fs)))\n                     fs)))", "by (rule thm_2_3_7_indets) (fact finite_set)"], ["", "end"], ["", "(* extended_ord_pm_powerprod *)"], ["", "subsection \\<open>Preparations\\<close>"], ["", "(* This is exactly the same as in \"Groebner_Bases.F4_Examples\". Pull out into common ancestor? *)"], ["", "primrec remdups_wrt_rev :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> 'a list\" where\n  \"remdups_wrt_rev f [] vs = []\" |\n  \"remdups_wrt_rev f (x # xs) vs =\n    (let fx = f x in if List.member vs fx then remdups_wrt_rev f xs vs else x # (remdups_wrt_rev f xs (fx # vs)))\""], ["", "lemma remdups_wrt_rev_notin: \"v \\<in> set vs \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f xs vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set vs \\<Longrightarrow>\n    v \\<notin> f ` set (remdups_wrt_rev f xs vs)", "proof (induct xs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       v \\<in> set vs \\<Longrightarrow>\n       v \\<notin> f ` set (remdups_wrt_rev f [] vs)\n 2. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "case Nil"], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       v \\<in> set vs \\<Longrightarrow>\n       v \\<notin> f ` set (remdups_wrt_rev f [] vs)\n 2. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f [] vs)", "by simp"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f [] vs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  v \\<in> set ?vs \\<Longrightarrow>\n  v \\<notin> f ` set (remdups_wrt_rev f xs ?vs)\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  v \\<in> set vs", "have 1: \"v \\<notin> f ` set (remdups_wrt_rev f xs vs)\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f xs vs)", "by (rule Cons(1))"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f xs vs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  v \\<in> set vs", "have \"v \\<in> set (f x # vs)\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> set (f x # vs)", "by simp"], ["proof (state)\nthis:\n  v \\<in> set (f x # vs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "hence 2: \"v \\<notin> f ` set (remdups_wrt_rev f xs (f x # vs))\""], ["proof (prove)\nusing this:\n  v \\<in> set (f x # vs)\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f xs (f x # vs))", "by (rule Cons(1))"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f xs (f x # vs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  v \\<in> set vs", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f (x # xs) vs)", "by (auto simp: Let_def 1 2 List.member_def)"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f (x # xs) vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_remdups_wrt_rev: \"distinct (map f (remdups_wrt_rev f xs vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (remdups_wrt_rev f xs vs))", "proof (induct xs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs. distinct (map f (remdups_wrt_rev f [] vs))\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vs. distinct (map f (remdups_wrt_rev f [] vs))\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (remdups_wrt_rev f [] vs))", "by simp"], ["proof (state)\nthis:\n  distinct (map f (remdups_wrt_rev f [] vs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (map f (remdups_wrt_rev f xs ?vs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (remdups_wrt_rev f (x # xs) vs))", "by (simp add: Let_def Cons(1) remdups_wrt_rev_notin)"], ["proof (state)\nthis:\n  distinct (map f (remdups_wrt_rev f (x # xs) vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_remdups_wrt_rev':\n  \"map_of (remdups_wrt_rev fst xs vs) k = map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst xs vs) k =\n    map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs) k", "proof (induct xs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       map_of (remdups_wrt_rev fst [] vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       map_of (remdups_wrt_rev fst [] vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst [] vs) k =\n    map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k", "by simp"], ["proof (state)\nthis:\n  map_of (remdups_wrt_rev fst [] vs) k =\n  map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_of (remdups_wrt_rev fst xs ?vs) k =\n  map_of (filter (\\<lambda>x. fst x \\<notin> set ?vs) xs) k\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst (x # xs) vs) k =\n    map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (x # xs)) k", "proof (simp add: Let_def List.member_def Cons, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "assume \"k \\<noteq> fst x\""], ["proof (state)\nthis:\n  k \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "have \"map_of (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs) xs) =\n          map_of (filter (\\<lambda>y. fst y \\<noteq> fst x) (filter (\\<lambda>y. fst y \\<notin> set vs) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n       xs) =\n    map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x)\n       (filter (\\<lambda>y. fst y \\<notin> set vs) xs))", "by (simp only: filter_filter conj_commute)"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x)\n     (filter (\\<lambda>y. fst y \\<notin> set vs) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "also"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x)\n     (filter (\\<lambda>y. fst y \\<notin> set vs) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "have \"... = map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |` {y. y \\<noteq> fst x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x)\n       (filter (\\<lambda>y. fst y \\<notin> set vs) xs)) =\n    map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n    {y. y \\<noteq> fst x}", "by (rule map_of_filter)"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x)\n     (filter (\\<lambda>y. fst y \\<notin> set vs) xs)) =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n  {y. y \\<noteq> fst x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "finally"], ["proof (chain)\npicking this:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n  {y. y \\<noteq> fst x}", "show \"map_of (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs) xs) k =\n                  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) k\""], ["proof (prove)\nusing this:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n  {y. y \\<noteq> fst x}\n\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n       xs)\n     k =\n    map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) k", "by (simp add: restrict_map_def \\<open>k \\<noteq> fst x\\<close>)"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs)\n   k =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of (remdups_wrt_rev fst (x # xs) vs) k =\n  map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (x # xs)) k\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary map_of_remdups_wrt_rev: \"map_of (remdups_wrt_rev fst xs []) = map_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst xs []) = map_of xs", "by (rule ext, simp add: map_of_remdups_wrt_rev')"], ["", "lemma (in term_powerprod) compute_list_to_poly [code]:\n  \"list_to_poly ts cs = distr\\<^sub>0 DRLEX (remdups_wrt_rev fst (zip ts cs) [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_to_poly ts cs =\n    distr\\<^sub>0 DRLEX (remdups_wrt_rev fst (zip ts cs) [])", "by (rule poly_mapping_eqI,\n      simp add: lookup_list_to_poly list_to_fun_def distr\\<^sub>0_def oalist_of_list_ntm_def\n        oa_ntm.lookup_oalist_of_list distinct_remdups_wrt_rev lookup_dflt_def map_of_remdups_wrt_rev)"], ["", "lemma (in ordered_term) compute_Macaulay_list [code]:\n  \"Macaulay_list ps =\n     (let ts = Keys_to_list ps in\n      filter (\\<lambda>p. p \\<noteq> 0) (mat_to_polys ts (row_echelon (polys_to_mat ts ps)))\n     )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Macaulay_list ps =\n    (let ts = Keys_to_list ps\n     in filter (\\<lambda>p. p \\<noteq> 0)\n         (mat_to_polys ts (row_echelon (polys_to_mat ts ps))))", "by (simp add: Macaulay_list_def Macaulay_mat_def Let_def)"], ["", "declare conversep_iff [code]"], ["", "derive (eq) ceq poly_mapping"], ["", "derive (no) ccompare poly_mapping"], ["", "derive (dlist) set_impl poly_mapping"], ["", "derive (no) cenum poly_mapping"], ["", "derive (eq) ceq rat"], ["", "derive (no) ccompare rat"], ["", "derive (dlist) set_impl rat"], ["", "derive (no) cenum rat"], ["", "subsubsection \\<open>Connection between @{typ \"('x \\<Rightarrow>\\<^sub>0 'a) \\<Rightarrow>\\<^sub>0 'b\"} and @{typ \"('x, 'a) pp \\<Rightarrow>\\<^sub>0 'b\"}\\<close>"], ["", "(* Move into \"Polynomials.PP_Type\"? *)"], ["", "definition keys_pp_to_list :: \"('x::linorder, 'a::zero) pp \\<Rightarrow> 'x list\"\n  where \"keys_pp_to_list t = sorted_list_of_set (keys_pp t)\""], ["", "lemma inj_PP: \"inj PP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj PP", "by (simp add: PP_inject inj_def)"], ["", "lemma inj_mapping_of: \"inj mapping_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj pp.mapping_of", "by (simp add: mapping_of_inject inj_def)"], ["", "lemma mapping_of_comp_PP [simp]:\n  \"mapping_of \\<circ> PP = (\\<lambda>x. x)\"\n  \"PP \\<circ> mapping_of = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp.mapping_of \\<circ> PP = (\\<lambda>x. x) &&&\n    PP \\<circ> pp.mapping_of = (\\<lambda>x. x)", "by (simp_all add: comp_def PP_inverse mapping_of_inverse)"], ["", "lemma map_key_PP_mapping_of [simp]: \"Poly_Mapping.map_key PP (Poly_Mapping.map_key mapping_of p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (Poly_Mapping.map_key pp.mapping_of p) = p", "by (simp add: map_key_compose[OF inj_PP inj_mapping_of] comp_def PP_inverse map_key_id)"], ["", "lemma map_key_mapping_of_PP [simp]: \"Poly_Mapping.map_key mapping_of (Poly_Mapping.map_key PP p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key pp.mapping_of (Poly_Mapping.map_key PP p) = p", "by (simp add: map_key_compose[OF inj_mapping_of inj_PP] comp_def mapping_of_inverse map_key_id)"], ["", "lemmas map_key_PP_plus = map_key_plus[OF inj_PP]"], ["", "lemmas map_key_PP_zero [simp] = map_key_zero[OF inj_PP]"], ["", "lemma lookup_map_key_PP: \"lookup (Poly_Mapping.map_key PP p) t = lookup p (PP t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map_key PP p) t = lookup p (PP t)", "by (simp add: map_key.rep_eq inj_PP)"], ["", "lemma keys_map_key_PP: \"keys (Poly_Mapping.map_key PP p) = mapping_of ` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Poly_Mapping.map_key PP p) = pp.mapping_of ` keys p", "by (simp add: keys_map_key inj_PP)\n     (smt Collect_cong PP_inverse UNIV_I image_def pp.mapping_of_inverse vimage_def)"], ["", "lemma map_key_PP_zero_iff [iff]: \"Poly_Mapping.map_key PP p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Poly_Mapping.map_key PP p = 0) = (p = 0)", "by (metis map_key_PP_zero map_key_mapping_of_PP)"], ["", "lemma map_key_PP_uminus [simp]: \"Poly_Mapping.map_key PP (- p) = - Poly_Mapping.map_key PP p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (- p) = - Poly_Mapping.map_key PP p", "by (rule poly_mapping_eqI) (simp add: lookup_map_key_PP)"], ["", "lemma map_key_PP_minus:\n  \"Poly_Mapping.map_key PP (p - q) = Poly_Mapping.map_key PP p - Poly_Mapping.map_key PP q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (p - q) =\n    Poly_Mapping.map_key PP p - Poly_Mapping.map_key PP q", "by (rule poly_mapping_eqI) (simp add: lookup_map_key_PP lookup_minus)"], ["", "lemma map_key_PP_monomial [simp]: \"Poly_Mapping.map_key PP (monomial c t) = monomial c (mapping_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)", "have \"Poly_Mapping.map_key PP (monomial c t) = Poly_Mapping.map_key PP (monomial c (PP (mapping_of t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c t) =\n    Poly_Mapping.map_key PP (monomial c (PP (pp.mapping_of t)))", "by (simp only: mapping_of_inverse)"], ["proof (state)\nthis:\n  Poly_Mapping.map_key PP (monomial c t) =\n  Poly_Mapping.map_key PP (monomial c (PP (pp.mapping_of t)))\n\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)", "also"], ["proof (state)\nthis:\n  Poly_Mapping.map_key PP (monomial c t) =\n  Poly_Mapping.map_key PP (monomial c (PP (pp.mapping_of t)))\n\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)", "from inj_PP"], ["proof (chain)\npicking this:\n  inj PP", "have \"\\<dots> = monomial c (mapping_of t)\""], ["proof (prove)\nusing this:\n  inj PP\n\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c (PP (pp.mapping_of t))) =\n    monomial c (pp.mapping_of t)", "by (fact map_key_single)"], ["proof (state)\nthis:\n  Poly_Mapping.map_key PP (monomial c (PP (pp.mapping_of t))) =\n  monomial c (pp.mapping_of t)\n\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)", "finally"], ["proof (chain)\npicking this:\n  Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)", "show ?thesis"], ["proof (prove)\nusing this:\n  Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)\n\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)", "."], ["proof (state)\nthis:\n  Poly_Mapping.map_key PP (monomial c t) = monomial c (pp.mapping_of t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_key_PP_one [simp]: \"Poly_Mapping.map_key PP 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP 1 = 1", "by (simp add: zero_pp.rep_eq flip: single_one)"], ["", "lemma map_key_PP_monom_mult_punit:\n  \"Poly_Mapping.map_key PP (monom_mult_punit c t p) =\n    monom_mult_punit c (mapping_of t) (Poly_Mapping.map_key PP p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (monom_mult_punit c t p) =\n    monom_mult_punit c (pp.mapping_of t) (Poly_Mapping.map_key PP p)", "by (rule poly_mapping_eqI)\n     (simp add: punit.lookup_monom_mult monom_mult_punit_def adds_pp_iff PP_inverse lookup_map_key_PP\n          mapping_of_inverse flip: minus_pp.abs_eq)"], ["", "lemma map_key_PP_times:\n  \"Poly_Mapping.map_key PP (p * q) =\n    Poly_Mapping.map_key PP p * Poly_Mapping.map_key PP (q::(_, _::add_linorder) pp \\<Rightarrow>\\<^sub>0 _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (p * q) =\n    Poly_Mapping.map_key PP p * Poly_Mapping.map_key PP q", "by (induct p rule: poly_mapping_plus_induct)\n     (simp_all add: distrib_right map_key_PP_plus times_monomial_left map_key_PP_monom_mult_punit\n        flip: monom_mult_punit_def)"], ["", "lemma map_key_PP_sum: \"Poly_Mapping.map_key PP (sum f A) = (\\<Sum>a\\<in>A. Poly_Mapping.map_key PP (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP (sum f A) =\n    (\\<Sum>a\\<in>A. Poly_Mapping.map_key PP (f a))", "by (induct A rule: infinite_finite_induct) (simp_all add: map_key_PP_plus)"], ["", "lemma map_key_PP_ideal:\n  \"Poly_Mapping.map_key PP ` ideal F = ideal (Poly_Mapping.map_key PP ` (F::((_, _::add_linorder) pp \\<Rightarrow>\\<^sub>0 _) set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP ` ideal F = ideal (Poly_Mapping.map_key PP ` F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP ` ideal F = ideal (Poly_Mapping.map_key PP ` F)", "from map_key_PP_mapping_of"], ["proof (chain)\npicking this:\n  Poly_Mapping.map_key PP (Poly_Mapping.map_key pp.mapping_of ?p) = ?p", "have \"surj (Poly_Mapping.map_key PP)\""], ["proof (prove)\nusing this:\n  Poly_Mapping.map_key PP (Poly_Mapping.map_key pp.mapping_of ?p) = ?p\n\ngoal (1 subgoal):\n 1. surj (Poly_Mapping.map_key PP)", "by (rule surjI)"], ["proof (state)\nthis:\n  surj (Poly_Mapping.map_key PP)\n\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP ` ideal F = ideal (Poly_Mapping.map_key PP ` F)", "with map_key_PP_plus map_key_PP_times"], ["proof (chain)\npicking this:\n  Poly_Mapping.map_key PP (?p + ?q) =\n  Poly_Mapping.map_key PP ?p + Poly_Mapping.map_key PP ?q\n  Poly_Mapping.map_key PP (?p * ?q) =\n  Poly_Mapping.map_key PP ?p * Poly_Mapping.map_key PP ?q\n  surj (Poly_Mapping.map_key PP)", "show ?thesis"], ["proof (prove)\nusing this:\n  Poly_Mapping.map_key PP (?p + ?q) =\n  Poly_Mapping.map_key PP ?p + Poly_Mapping.map_key PP ?q\n  Poly_Mapping.map_key PP (?p * ?q) =\n  Poly_Mapping.map_key PP ?p * Poly_Mapping.map_key PP ?q\n  surj (Poly_Mapping.map_key PP)\n\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key PP ` ideal F = ideal (Poly_Mapping.map_key PP ` F)", "by (rule image_ideal_eq_surj)"], ["proof (state)\nthis:\n  Poly_Mapping.map_key PP ` ideal F = ideal (Poly_Mapping.map_key PP ` F)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Locale \\<open>pp_powerprod\\<close>\\<close>"], ["", "text \\<open>We have to introduce a new locale analogous to @{locale pm_powerprod}, but this time for\n  power-products represented by @{type pp} rather than @{type poly_mapping}. This apparently leads\n  to some (more-or-less) duplicate definitions and lemmas, but seems to be the only feasible way to\n  get both\n  \\<^item> the convenient representation by @{type poly_mapping} for theory development, and\n  \\<^item> the executable representation by @{type pp} for code generation.\\<close>"], ["", "locale pp_powerprod =\n  ordered_powerprod ord ord_strict\n  for ord::\"('x::{countable,linorder}, nat) pp \\<Rightarrow> ('x, nat) pp \\<Rightarrow> bool\"\n  and ord_strict\nbegin"], ["", "sublocale gd_powerprod"], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_powerprod ord ord_strict", ".."], ["", "sublocale pp_pm: extended_ord_pm_powerprod \"\\<lambda>s t. ord (PP s) (PP t)\" \"\\<lambda>s t. ord_strict (PP s) (PP t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_ord_pm_powerprod (\\<lambda>s t. ord (PP s) (PP t))\n     (\\<lambda>s t. ord_strict (PP s) (PP t))", "by standard (auto simp: zero_min plus_monotone simp flip: zero_pp_def plus_pp.abs_eq PP_inject)"], ["", "definition poly_deg_pp :: \"(('x, nat) pp \\<Rightarrow>\\<^sub>0 'a::zero) \\<Rightarrow> nat\"\n  where \"poly_deg_pp p = (if p = 0 then 0 else max_list (map deg_pp (punit.keys_to_list p)))\""], ["", "primrec deg_le_sect_pp_aux :: \"'x list \\<Rightarrow> nat \\<Rightarrow> ('x, nat) pp \\<Rightarrow>\\<^sub>0 nat\" where\n  \"deg_le_sect_pp_aux xs 0 = 1\" |\n  \"deg_le_sect_pp_aux xs (Suc n) =\n    (let p = deg_le_sect_pp_aux xs n in p + foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) p)) xs 0)\""], ["", "definition deg_le_sect_pp  :: \"'x list \\<Rightarrow> nat \\<Rightarrow> ('x, nat) pp list\"\n  where \"deg_le_sect_pp xs d = punit.keys_to_list (deg_le_sect_pp_aux xs d)\""], ["", "definition deg_shifts_pp :: \"'x list \\<Rightarrow> nat \\<Rightarrow>\n                                (('x, nat) pp \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> (('x, nat) pp \\<Rightarrow>\\<^sub>0 'b::semiring_1) list\"\n  where \"deg_shifts_pp xs d fs = concat (map (\\<lambda>f. (map (\\<lambda>t. monom_mult_punit 1 t f)\n                                          (deg_le_sect_pp xs (d - poly_deg_pp f)))) fs)\""], ["", "definition indets_pp :: \"(('x, nat) pp \\<Rightarrow>\\<^sub>0 'b::zero) \\<Rightarrow> 'x list\"\n  where \"indets_pp p = remdups (concat (map keys_pp_to_list (punit.keys_to_list p)))\""], ["", "definition Indets_pp :: \"(('x, nat) pp \\<Rightarrow>\\<^sub>0 'b::zero) list \\<Rightarrow> 'x list\"\n  where \"Indets_pp ps = remdups (concat (map indets_pp ps))\""], ["", "lemma map_PP_insort:\n  \"map PP (pp_pm.ordered_powerprod_lin.insort x xs) = ordered_powerprod_lin.insort (PP x) (map PP xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map PP (pp_pm.ordered_powerprod_lin.insort x xs) =\n    ordered_powerprod_lin.insort (PP x) (map PP xs)", "by (induct xs) simp_all"], ["", "lemma map_PP_sorted_list_of_set:\n  \"map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` T)", "proof (induct T rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set A) =\n       ordered_powerprod_lin.sorted_list_of_set (PP ` A)\n 2. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "case (infinite T)"], ["proof (state)\nthis:\n  infinite T\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set A) =\n       ordered_powerprod_lin.sorted_list_of_set (PP ` A)\n 2. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "moreover"], ["proof (state)\nthis:\n  infinite T\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set A) =\n       ordered_powerprod_lin.sorted_list_of_set (PP ` A)\n 2. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "from inj_PP subset_UNIV"], ["proof (chain)\npicking this:\n  inj PP\n  ?A \\<subseteq> UNIV", "have \"inj_on PP T\""], ["proof (prove)\nusing this:\n  inj PP\n  ?A \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. inj_on PP T", "by (rule inj_on_subset)"], ["proof (state)\nthis:\n  inj_on PP T\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set A) =\n       ordered_powerprod_lin.sorted_list_of_set (PP ` A)\n 2. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "ultimately"], ["proof (chain)\npicking this:\n  infinite T\n  inj_on PP T", "show ?case"], ["proof (prove)\nusing this:\n  infinite T\n  inj_on PP T\n\ngoal (1 subgoal):\n 1. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` T)", "by (simp add: inj_PP finite_image_iff)"], ["proof (state)\nthis:\n  map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n  ordered_powerprod_lin.sorted_list_of_set (PP ` T)\n\ngoal (2 subgoals):\n 1. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` {})", "by simp"], ["proof (state)\nthis:\n  map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set {}) =\n  ordered_powerprod_lin.sorted_list_of_set (PP ` {})\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "case (insert t T)"], ["proof (state)\nthis:\n  finite T\n  t \\<notin> T\n  map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n  ordered_powerprod_lin.sorted_list_of_set (PP ` T)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "moreover"], ["proof (state)\nthis:\n  finite T\n  t \\<notin> T\n  map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n  ordered_powerprod_lin.sorted_list_of_set (PP ` T)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "from insert(2)"], ["proof (chain)\npicking this:\n  t \\<notin> T", "have \"PP t \\<notin> PP ` T\""], ["proof (prove)\nusing this:\n  t \\<notin> T\n\ngoal (1 subgoal):\n 1. PP t \\<notin> PP ` T", "by (simp add: PP_inject image_iff)"], ["proof (state)\nthis:\n  PP t \\<notin> PP ` T\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set F) =\n        ordered_powerprod_lin.sorted_list_of_set (PP ` F)\\<rbrakk>\n       \\<Longrightarrow> map PP\n                          (pp_pm.ordered_powerprod_lin.sorted_list_of_set\n                            (insert x F)) =\n                         ordered_powerprod_lin.sorted_list_of_set\n                          (PP ` insert x F)", "ultimately"], ["proof (chain)\npicking this:\n  finite T\n  t \\<notin> T\n  map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n  ordered_powerprod_lin.sorted_list_of_set (PP ` T)\n  PP t \\<notin> PP ` T", "show ?case"], ["proof (prove)\nusing this:\n  finite T\n  t \\<notin> T\n  map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set T) =\n  ordered_powerprod_lin.sorted_list_of_set (PP ` T)\n  PP t \\<notin> PP ` T\n\ngoal (1 subgoal):\n 1. map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set (insert t T)) =\n    ordered_powerprod_lin.sorted_list_of_set (PP ` insert t T)", "by (simp add: map_PP_insort)"], ["proof (state)\nthis:\n  map PP (pp_pm.ordered_powerprod_lin.sorted_list_of_set (insert t T)) =\n  ordered_powerprod_lin.sorted_list_of_set (PP ` insert t T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_PP_pps_to_list: \"map PP (pp_pm.punit.pps_to_list T) = punit.pps_to_list (PP ` T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map PP (pp_pm.punit.pps_to_list T) = punit.pps_to_list (PP ` T)", "by (simp add: pp_pm.punit.pps_to_list_def punit.pps_to_list_def map_PP_sorted_list_of_set flip: rev_map)"], ["", "lemma map_mapping_of_pps_to_list:\n  \"map mapping_of (punit.pps_to_list T) = pp_pm.punit.pps_to_list (mapping_of ` T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "have \"map mapping_of (punit.pps_to_list T) = map mapping_of (punit.pps_to_list (PP ` mapping_of ` T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    map pp.mapping_of (punit.pps_to_list (PP ` pp.mapping_of ` T))", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  map pp.mapping_of (punit.pps_to_list T) =\n  map pp.mapping_of (punit.pps_to_list (PP ` pp.mapping_of ` T))\n\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "also"], ["proof (state)\nthis:\n  map pp.mapping_of (punit.pps_to_list T) =\n  map pp.mapping_of (punit.pps_to_list (PP ` pp.mapping_of ` T))\n\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "have \"\\<dots> = map mapping_of (map PP (pp_pm.punit.pps_to_list (mapping_of ` T)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list (PP ` pp.mapping_of ` T)) =\n    map pp.mapping_of (map PP (pp_pm.punit.pps_to_list (pp.mapping_of ` T)))", "by (simp only: map_PP_pps_to_list)"], ["proof (state)\nthis:\n  map pp.mapping_of (punit.pps_to_list (PP ` pp.mapping_of ` T)) =\n  map pp.mapping_of (map PP (pp_pm.punit.pps_to_list (pp.mapping_of ` T)))\n\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "also"], ["proof (state)\nthis:\n  map pp.mapping_of (punit.pps_to_list (PP ` pp.mapping_of ` T)) =\n  map pp.mapping_of (map PP (pp_pm.punit.pps_to_list (pp.mapping_of ` T)))\n\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "have \"\\<dots> = pp_pm.punit.pps_to_list (mapping_of ` T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map pp.mapping_of\n     (map PP (pp_pm.punit.pps_to_list (pp.mapping_of ` T))) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "by simp"], ["proof (state)\nthis:\n  map pp.mapping_of (map PP (pp_pm.punit.pps_to_list (pp.mapping_of ` T))) =\n  pp_pm.punit.pps_to_list (pp.mapping_of ` T)\n\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "finally"], ["proof (chain)\npicking this:\n  map pp.mapping_of (punit.pps_to_list T) =\n  pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "show ?thesis"], ["proof (prove)\nusing this:\n  map pp.mapping_of (punit.pps_to_list T) =\n  pp_pm.punit.pps_to_list (pp.mapping_of ` T)\n\ngoal (1 subgoal):\n 1. map pp.mapping_of (punit.pps_to_list T) =\n    pp_pm.punit.pps_to_list (pp.mapping_of ` T)", "."], ["proof (state)\nthis:\n  map pp.mapping_of (punit.pps_to_list T) =\n  pp_pm.punit.pps_to_list (pp.mapping_of ` T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_to_list_map_key_PP:\n  \"pp_pm.punit.keys_to_list (Poly_Mapping.map_key PP p) = map mapping_of (punit.keys_to_list p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.punit.keys_to_list (Poly_Mapping.map_key PP p) =\n    map pp.mapping_of (punit.keys_to_list p)", "by (simp add: pp_pm.punit.keys_to_list_def punit.keys_to_list_def keys_map_key_PP map_mapping_of_pps_to_list)"], ["", "lemma Keys_to_list_map_key_PP:\n  \"pp_pm.punit.Keys_to_list (map (Poly_Mapping.map_key PP) fs) = map mapping_of (punit.Keys_to_list fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.punit.Keys_to_list (map (Poly_Mapping.map_key PP) fs) =\n    map pp.mapping_of (punit.Keys_to_list fs)", "by (simp add: punit.Keys_to_list_eq_pps_to_list pp_pm.punit.Keys_to_list_eq_pps_to_list\n          map_mapping_of_pps_to_list Keys_def image_UN keys_map_key_PP)"], ["", "lemma poly_deg_map_key_PP: \"poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "assume \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "hence \"map deg_pp (punit.keys_to_list p) \\<noteq> []\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map deg_pp (punit.keys_to_list p) \\<noteq> []", "by (simp add: punit.keys_to_list_def punit.pps_to_list_def)"], ["proof (state)\nthis:\n  map deg_pp (punit.keys_to_list p) \\<noteq> []\n\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "hence \"Max (deg_pp ` keys p) = max_list (map deg_pp (punit.keys_to_list p))\""], ["proof (prove)\nusing this:\n  map deg_pp (punit.keys_to_list p) \\<noteq> []\n\ngoal (1 subgoal):\n 1. Max (deg_pp ` keys p) = max_list (map deg_pp (punit.keys_to_list p))", "by (simp add: max_list_Max punit.set_keys_to_list)"], ["proof (state)\nthis:\n  Max (deg_pp ` keys p) = max_list (map deg_pp (punit.keys_to_list p))\n\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "}"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  Max (deg_pp ` keys p) = max_list (map deg_pp (punit.keys_to_list p))\n\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  Max (deg_pp ` keys p) = max_list (map deg_pp (punit.keys_to_list p))\n\ngoal (1 subgoal):\n 1. poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p", "by (simp add: poly_deg_def poly_deg_pp_def keys_map_key_PP image_image flip: deg_pp.rep_eq)"], ["proof (state)\nthis:\n  poly_deg (Poly_Mapping.map_key PP p) = poly_deg_pp p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_le_sect_pp_aux_1:\n  assumes \"t \\<in> keys (deg_le_sect_pp_aux xs n)\"\n  shows \"deg_pp t \\<le> n\" and \"keys_pp t \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deg_pp t \\<le> n &&& keys_pp t \\<subseteq> set xs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n\n 2. keys_pp t \\<subseteq> set xs", "from assms"], ["proof (chain)\npicking this:\n  t \\<in> keys (deg_le_sect_pp_aux xs n)", "have \"deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs\""], ["proof (prove)\nusing this:\n  t \\<in> keys (deg_le_sect_pp_aux xs n)\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs", "proof (induct n arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       t \\<in> keys (deg_le_sect_pp_aux xs 0) \\<Longrightarrow>\n       deg_pp t \\<le> 0 \\<and> keys_pp t \\<subseteq> set xs\n 2. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "case 0"], ["proof (state)\nthis:\n  t \\<in> keys (deg_le_sect_pp_aux xs 0)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       t \\<in> keys (deg_le_sect_pp_aux xs 0) \\<Longrightarrow>\n       deg_pp t \\<le> 0 \\<and> keys_pp t \\<subseteq> set xs\n 2. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "thus ?case"], ["proof (prove)\nusing this:\n  t \\<in> keys (deg_le_sect_pp_aux xs 0)\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> 0 \\<and> keys_pp t \\<subseteq> set xs", "by (simp_all add: keys_pp.rep_eq zero_pp.rep_eq)"], ["proof (state)\nthis:\n  deg_pp t \\<le> 0 \\<and> keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "case (Suc n)"], ["proof (state)\nthis:\n  ?t9 \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n  deg_pp ?t9 \\<le> n \\<and> keys_pp ?t9 \\<subseteq> set xs\n  t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "define X where \"X = set xs\""], ["proof (state)\nthis:\n  X = set xs\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "define q where \"q = deg_le_sect_pp_aux xs n\""], ["proof (state)\nthis:\n  q = deg_le_sect_pp_aux xs n\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "have 1: \"s \\<in> keys q \\<Longrightarrow> deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> X\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> keys q \\<Longrightarrow>\n    deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> X", "unfolding q_def X_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n    deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> set xs", "by (fact Suc.hyps)"], ["proof (state)\nthis:\n  ?s9 \\<in> keys q \\<Longrightarrow>\n  deg_pp ?s9 \\<le> n \\<and> keys_pp ?s9 \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "note Suc.prems"], ["proof (state)\nthis:\n  t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "also"], ["proof (state)\nthis:\n  t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "have \"keys (deg_le_sect_pp_aux xs (Suc n)) \\<subseteq> keys q \\<union>\n                    keys (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0)\"\n      (is \"_ \\<subseteq> _ \\<union> keys (foldr ?r xs 0)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (deg_le_sect_pp_aux xs (Suc n))\n    \\<subseteq> keys q \\<union>\n                keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   xs 0)", "by (simp add: Let_def Poly_Mapping.keys_add flip: q_def)"], ["proof (state)\nthis:\n  keys (deg_le_sect_pp_aux xs (Suc n))\n  \\<subseteq> keys q \\<union>\n              keys\n               (foldr\n                 (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs\n                 0)\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   t \\<in> keys (deg_le_sect_pp_aux xs n) \\<Longrightarrow>\n                   deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs;\n        t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                         keys_pp t \\<subseteq> set xs", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys q \\<union>\n          keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)", "show ?case"], ["proof (prove)\nusing this:\n  t \\<in> keys q \\<union>\n          keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "assume \"t \\<in> keys q\""], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (2 subgoals):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "hence \"deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs", "unfolding q_def"], ["proof (prove)\nusing this:\n  t \\<in> keys (deg_le_sect_pp_aux xs n)\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs\n\ngoal (2 subgoals):\n 1. t \\<in> keys q \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "by simp"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "assume \"t \\<in> keys (foldr ?r xs 0)\""], ["proof (state)\nthis:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "moreover"], ["proof (state)\nthis:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "have \"set xs \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> X", "by (simp add: X_def)"], ["proof (state)\nthis:\n  set xs \\<subseteq> X\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n  set xs \\<subseteq> X", "have \"deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n  set xs \\<subseteq> X\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "proof (induct xs arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys\n                         (foldr\n                           (\\<lambda>x.\n                               (+) (monom_mult_punit 1 (single_pp x 1) q))\n                           [] 0);\n        set [] \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "case Nil"], ["proof (state)\nthis:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             [] 0)\n  set [] \\<subseteq> X\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> keys\n                         (foldr\n                           (\\<lambda>x.\n                               (+) (monom_mult_punit 1 (single_pp x 1) q))\n                           [] 0);\n        set [] \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "thus ?case"], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             [] 0)\n  set [] \\<subseteq> X\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "by simp"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?t9\n           \\<in> keys\n                  (foldr\n                    (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                    xs 0);\n   set xs \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> deg_pp ?t9 \\<le> Suc n \\<and> keys_pp ?t9 \\<subseteq> X\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             (x # xs) 0)\n  set (x # xs) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  set (x # xs) \\<subseteq> X", "have \"x \\<in> X\" and \"set xs \\<subseteq> X\""], ["proof (prove)\nusing this:\n  set (x # xs) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. x \\<in> X &&& set xs \\<subseteq> X", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> X\n  set xs \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "note Cons.prems(1)"], ["proof (state)\nthis:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             (x # xs) 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "also"], ["proof (state)\nthis:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             (x # xs) 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "have \"keys (foldr ?r (x # xs) 0) \\<subseteq> keys (?r x 0) \\<union> keys (foldr ?r xs 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n       (x # xs) 0)\n    \\<subseteq> keys (monom_mult_punit 1 (single_pp x 1) q + 0) \\<union>\n                keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   xs 0)", "by (simp add: Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  keys\n   (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) (x # xs)\n     0)\n  \\<subseteq> keys (monom_mult_punit 1 (single_pp x 1) q + 0) \\<union>\n              keys\n               (foldr\n                 (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs\n                 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>t \\<in> keys\n                                     (foldr\n (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs 0);\n                    set xs \\<subseteq> X\\<rbrakk>\n                   \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and>\n                                     keys_pp t \\<subseteq> X;\n        t \\<in> keys\n                 (foldr\n                   (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n                   (a # xs) 0);\n        set (a # xs) \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "finally"], ["proof (chain)\npicking this:\n  t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q + 0) \\<union>\n          keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)", "show ?case"], ["proof (prove)\nusing this:\n  t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q + 0) \\<union>\n          keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (monom_mult_punit 1 (single_pp x 1) q + 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "assume \"t \\<in> keys (?r x 0)\""], ["proof (state)\nthis:\n  t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q + 0)\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (monom_mult_punit 1 (single_pp x 1) q + 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "also"], ["proof (state)\nthis:\n  t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q + 0)\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (monom_mult_punit 1 (single_pp x 1) q + 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "have \"\\<dots> = (+) (single_pp x 1) ` keys q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monom_mult_punit 1 (single_pp x 1) q + 0) =\n    (+) (single_pp x 1) ` keys q", "by (simp add: monom_mult_punit_def punit.keys_monom_mult)"], ["proof (state)\nthis:\n  keys (monom_mult_punit 1 (single_pp x 1) q + 0) =\n  (+) (single_pp x 1) ` keys q\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (monom_mult_punit 1 (single_pp x 1) q + 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "finally"], ["proof (chain)\npicking this:\n  t \\<in> (+) (single_pp x 1) ` keys q", "obtain s where \"s \\<in> keys q\" and t: \"t = single_pp x 1 + s\""], ["proof (prove)\nusing this:\n  t \\<in> (+) (single_pp x 1) ` keys q\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> keys q; t = single_pp x 1 + s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s \\<in> keys q\n  t = single_pp x 1 + s\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (monom_mult_punit 1 (single_pp x 1) q + 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> keys q", "have \"deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> X\""], ["proof (prove)\nusing this:\n  s \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> X", "by (rule 1)"], ["proof (state)\nthis:\n  deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> X\n\ngoal (2 subgoals):\n 1. t \\<in> keys\n             (monom_mult_punit 1 (single_pp x 1) q + 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n 2. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "with \\<open>x \\<in> X\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> X\n  deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> X", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> X\n  deg_pp s \\<le> n \\<and> keys_pp s \\<subseteq> X\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "by (simp add: t deg_pp_plus deg_pp_single keys_pp.rep_eq plus_pp.rep_eq\n                keys_plus_ninv_comm_monoid_add single_pp.rep_eq)"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "assume \"t \\<in> keys (foldr ?r xs 0)\""], ["proof (state)\nthis:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "thus \"deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\""], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "using \\<open>set xs \\<subseteq> X\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> keys\n           (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs 0)\n  set xs \\<subseteq> X\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. t \\<in> keys\n             (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs 0) \\<Longrightarrow>\n    deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> X\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs", "by (simp only: X_def)"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pp t \\<le> Suc n \\<and> keys_pp t \\<subseteq> set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs\n\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n\n 2. keys_pp t \\<subseteq> set xs", "thus \"deg_pp t \\<le> n\" and \"keys_pp t \\<subseteq> set xs\""], ["proof (prove)\nusing this:\n  deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> n &&& keys_pp t \\<subseteq> set xs", "by simp_all"], ["proof (state)\nthis:\n  deg_pp t \\<le> n\n  keys_pp t \\<subseteq> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_le_sect_pp_aux_2:\n  assumes \"deg_pp t \\<le> n\" and \"keys_pp t \\<subseteq> set xs\"\n  shows \"t \\<in> keys (deg_le_sect_pp_aux xs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs n)", "using assms"], ["proof (prove)\nusing this:\n  deg_pp t \\<le> n\n  keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs n)", "proof (induct n arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>deg_pp t \\<le> 0; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs 0)\n 2. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "case 0"], ["proof (state)\nthis:\n  deg_pp t \\<le> 0\n  keys_pp t \\<subseteq> set xs\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>deg_pp t \\<le> 0; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs 0)\n 2. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  deg_pp t \\<le> 0\n  keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs 0)", "by simp"], ["proof (state)\nthis:\n  t \\<in> keys (deg_le_sect_pp_aux xs 0)\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>deg_pp ?t9 \\<le> n; keys_pp ?t9 \\<subseteq> set xs\\<rbrakk>\n  \\<Longrightarrow> ?t9 \\<in> keys (deg_le_sect_pp_aux xs n)\n  deg_pp t \\<le> Suc n\n  keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "have foldr: \"foldr (\\<lambda>x. (+) (f x)) ys 0 + y = foldr (\\<lambda>x. (+) (f x)) ys y\"\n    for f ys and y::\"'z::monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (+) (f x)) ys (0::'z) + y =\n    foldr (\\<lambda>x. (+) (f x)) ys y", "by (induct ys) (simp_all add: ac_simps)"], ["proof (state)\nthis:\n  foldr (\\<lambda>x. (+) (?f10 x)) ?ys10 (0::?'z11) + ?y10 =\n  foldr (\\<lambda>x. (+) (?f10 x)) ?ys10 ?y10\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "define q where \"q = deg_le_sect_pp_aux xs n\""], ["proof (state)\nthis:\n  q = deg_le_sect_pp_aux xs n\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "from Suc.prems(1)"], ["proof (chain)\npicking this:\n  deg_pp t \\<le> Suc n", "have \"deg_pp t \\<le> n \\<or> deg_pp t = Suc n\""], ["proof (prove)\nusing this:\n  deg_pp t \\<le> Suc n\n\ngoal (1 subgoal):\n 1. deg_pp t \\<le> n \\<or> deg_pp t = Suc n", "by auto"], ["proof (state)\nthis:\n  deg_pp t \\<le> n \\<or> deg_pp t = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>deg_pp t \\<le> n;\n                    keys_pp t \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs n);\n        deg_pp t \\<le> Suc n; keys_pp t \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  deg_pp t \\<le> n \\<or> deg_pp t = Suc n\n\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n 2. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "assume \"deg_pp t \\<le> n\""], ["proof (state)\nthis:\n  deg_pp t \\<le> n\n\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n 2. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "hence \"t \\<in> keys q\""], ["proof (prove)\nusing this:\n  deg_pp t \\<le> n\n\ngoal (1 subgoal):\n 1. t \\<in> keys q", "unfolding q_def"], ["proof (prove)\nusing this:\n  deg_pp t \\<le> n\n\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs n)", "using Suc.prems(2)"], ["proof (prove)\nusing this:\n  deg_pp t \\<le> n\n  keys_pp t \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs n)", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  t \\<in> keys q\n\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n 2. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "hence \"0 < lookup q t\""], ["proof (prove)\nusing this:\n  t \\<in> keys q\n\ngoal (1 subgoal):\n 1. 0 < lookup q t", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  0 < lookup q t\n\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n 2. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "also"], ["proof (state)\nthis:\n  0 < lookup q t\n\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n 2. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "have \"\\<dots> \\<le> lookup (deg_le_sect_pp_aux xs (Suc n)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup q t \\<le> lookup (deg_le_sect_pp_aux xs (Suc n)) t", "by (simp add: Let_def lookup_add flip: q_def)"], ["proof (state)\nthis:\n  lookup q t \\<le> lookup (deg_le_sect_pp_aux xs (Suc n)) t\n\ngoal (2 subgoals):\n 1. deg_pp t \\<le> n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n 2. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "finally"], ["proof (chain)\npicking this:\n  0 < lookup (deg_le_sect_pp_aux xs (Suc n)) t", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < lookup (deg_le_sect_pp_aux xs (Suc n)) t\n\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "assume eq: \"deg_pp t = Suc n\""], ["proof (state)\nthis:\n  deg_pp t = Suc n\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "hence \"keys_pp t \\<noteq> {}\""], ["proof (prove)\nusing this:\n  deg_pp t = Suc n\n\ngoal (1 subgoal):\n 1. keys_pp t \\<noteq> {}", "by (auto simp: keys_pp.rep_eq deg_pp.rep_eq)"], ["proof (state)\nthis:\n  keys_pp t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "then"], ["proof (chain)\npicking this:\n  keys_pp t \\<noteq> {}", "obtain x where \"x \\<in> keys_pp t\""], ["proof (prove)\nusing this:\n  keys_pp t \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> keys_pp t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> keys_pp t\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "with Suc.prems(2)"], ["proof (chain)\npicking this:\n  keys_pp t \\<subseteq> set xs\n  x \\<in> keys_pp t", "have \"x \\<in> set xs\""], ["proof (prove)\nusing this:\n  keys_pp t \\<subseteq> set xs\n  x \\<in> keys_pp t\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", ".."], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "then"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain xs1 xs2 where xs: \"xs = xs1 @ x # xs2\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs1 xs2.\n        xs = xs1 @ x # xs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = xs1 @ x # xs2\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "define s where \"s = t - single_pp x 1\""], ["proof (state)\nthis:\n  s = t - single_pp x 1\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "from \\<open>x \\<in> keys_pp t\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> keys_pp t", "have \"single_pp x 1 adds t\""], ["proof (prove)\nusing this:\n  x \\<in> keys_pp t\n\ngoal (1 subgoal):\n 1. single_pp x 1 adds t", "by (simp add: adds_pp_iff single_pp.rep_eq keys_pp.rep_eq adds_poly_mapping le_fun_def\n          lookup_single when_def in_keys_iff)"], ["proof (state)\nthis:\n  single_pp x 1 adds t\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "hence \"s + single_pp x 1 = (t + single_pp x 1) - single_pp x 1\""], ["proof (prove)\nusing this:\n  single_pp x 1 adds t\n\ngoal (1 subgoal):\n 1. s + single_pp x 1 = t + single_pp x 1 - single_pp x 1", "unfolding s_def"], ["proof (prove)\nusing this:\n  single_pp x 1 adds t\n\ngoal (1 subgoal):\n 1. t - single_pp x 1 + single_pp x 1 = t + single_pp x 1 - single_pp x 1", "by (rule minus_plus)"], ["proof (state)\nthis:\n  s + single_pp x 1 = t + single_pp x 1 - single_pp x 1\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "hence t: \"t = single_pp x 1 + s\""], ["proof (prove)\nusing this:\n  s + single_pp x 1 = t + single_pp x 1 - single_pp x 1\n\ngoal (1 subgoal):\n 1. t = single_pp x 1 + s", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  t = single_pp x 1 + s\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "with eq"], ["proof (chain)\npicking this:\n  deg_pp t = Suc n\n  t = single_pp x 1 + s", "have \"deg_pp s \\<le> n\""], ["proof (prove)\nusing this:\n  deg_pp t = Suc n\n  t = single_pp x 1 + s\n\ngoal (1 subgoal):\n 1. deg_pp s \\<le> n", "by (simp add: deg_pp_plus deg_pp_single)"], ["proof (state)\nthis:\n  deg_pp s \\<le> n\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "moreover"], ["proof (state)\nthis:\n  deg_pp s \\<le> n\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "have \"keys_pp s \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_pp s \\<subseteq> set xs", "proof (rule subset_trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys_pp s \\<subseteq> ?B\n 2. ?B \\<subseteq> set xs", "from Suc.prems(2) \\<open>x \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  keys_pp t \\<subseteq> set xs\n  x \\<in> set xs", "show \"keys_pp t \\<union> keys_pp (single_pp x (Suc 0)) \\<subseteq> set xs\""], ["proof (prove)\nusing this:\n  keys_pp t \\<subseteq> set xs\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. keys_pp t \\<union> keys_pp (single_pp x (Suc 0)) \\<subseteq> set xs", "by (simp add: keys_pp.rep_eq single_pp.rep_eq)"], ["proof (state)\nthis:\n  keys_pp t \\<union> keys_pp (single_pp x (Suc 0)) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. keys_pp s \\<subseteq> keys_pp t \\<union> keys_pp (single_pp x (Suc 0))", "qed (simp add: s_def keys_pp.rep_eq minus_pp.rep_eq keys_diff)"], ["proof (state)\nthis:\n  keys_pp s \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  deg_pp s \\<le> n\n  keys_pp s \\<subseteq> set xs", "have \"s \\<in> keys q\""], ["proof (prove)\nusing this:\n  deg_pp s \\<le> n\n  keys_pp s \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. s \\<in> keys q", "unfolding q_def"], ["proof (prove)\nusing this:\n  deg_pp s \\<le> n\n  keys_pp s \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. s \\<in> keys (deg_le_sect_pp_aux xs n)", "by (rule Suc.hyps)"], ["proof (state)\nthis:\n  s \\<in> keys q\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "hence \"t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q)\""], ["proof (prove)\nusing this:\n  s \\<in> keys q\n\ngoal (1 subgoal):\n 1. t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q)", "by (simp add: monom_mult_punit_def punit.keys_monom_mult t)"], ["proof (state)\nthis:\n  t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q)\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "hence \"0 < lookup (monom_mult_punit 1 (single_pp x 1) q) t\""], ["proof (prove)\nusing this:\n  t \\<in> keys (monom_mult_punit 1 (single_pp x 1) q)\n\ngoal (1 subgoal):\n 1. 0 < lookup (monom_mult_punit 1 (single_pp x 1) q) t", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  0 < lookup (monom_mult_punit 1 (single_pp x 1) q) t\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "also"], ["proof (state)\nthis:\n  0 < lookup (monom_mult_punit 1 (single_pp x 1) q) t\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "have \"\\<dots> \\<le> lookup (q + (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs1 0 +\n                      (monom_mult_punit 1 (single_pp x 1) q +\n                        foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs2 0))) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult_punit 1 (single_pp x 1) q) t\n    \\<le> lookup\n           (q +\n            (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n              xs1 0 +\n             (monom_mult_punit 1 (single_pp x 1) q +\n              foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n               xs2 0)))\n           t", "by (simp add: lookup_add)"], ["proof (state)\nthis:\n  lookup (monom_mult_punit 1 (single_pp x 1) q) t\n  \\<le> lookup\n         (q +\n          (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n            xs1 0 +\n           (monom_mult_punit 1 (single_pp x 1) q +\n            foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs2 0)))\n         t\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "also"], ["proof (state)\nthis:\n  lookup (monom_mult_punit 1 (single_pp x 1) q) t\n  \\<le> lookup\n         (q +\n          (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n            xs1 0 +\n           (monom_mult_punit 1 (single_pp x 1) q +\n            foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q))\n             xs2 0)))\n         t\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "have \"\\<dots> = lookup (deg_le_sect_pp_aux xs (Suc n)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (q +\n      (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs1\n        0 +\n       (monom_mult_punit 1 (single_pp x 1) q +\n        foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs2\n         0)))\n     t =\n    lookup (deg_le_sect_pp_aux xs (Suc n)) t", "by (simp add: Let_def foldr flip: q_def, simp add: xs)"], ["proof (state)\nthis:\n  lookup\n   (q +\n    (foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs1 0 +\n     (monom_mult_punit 1 (single_pp x 1) q +\n      foldr (\\<lambda>x. (+) (monom_mult_punit 1 (single_pp x 1) q)) xs2\n       0)))\n   t =\n  lookup (deg_le_sect_pp_aux xs (Suc n)) t\n\ngoal (1 subgoal):\n 1. deg_pp t = Suc n \\<Longrightarrow>\n    t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "finally"], ["proof (chain)\npicking this:\n  0 < lookup (deg_le_sect_pp_aux xs (Suc n)) t", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < lookup (deg_le_sect_pp_aux xs (Suc n)) t\n\ngoal (1 subgoal):\n 1. t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> keys (deg_le_sect_pp_aux xs (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_deg_le_sect_pp_aux:\n  \"keys (deg_le_sect_pp_aux xs n) = {t. deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (deg_le_sect_pp_aux xs n) =\n    {t. deg_pp t \\<le> n \\<and> keys_pp t \\<subseteq> set xs}", "by (auto dest: deg_le_sect_pp_aux_1 deg_le_sect_pp_aux_2)"], ["", "lemma deg_le_sect_deg_le_sect_pp:\n  \"map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) = deg_le_sect_pp xs d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) =\n    deg_le_sect_pp xs d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) =\n    deg_le_sect_pp xs d", "have \"PP ` {t. deg_pm t \\<le> d \\<and> keys t \\<subseteq> set xs} = PP ` {t. deg_pp (PP t) \\<le> d \\<and> keys_pp (PP t) \\<subseteq> set xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP ` {t. deg_pm t \\<le> d \\<and> keys t \\<subseteq> set xs} =\n    PP ` {t. deg_pp (PP t) \\<le> d \\<and> keys_pp (PP t) \\<subseteq> set xs}", "by (simp only: keys_pp.abs_eq deg_pp.abs_eq)"], ["proof (state)\nthis:\n  PP ` {t. deg_pm t \\<le> d \\<and> keys t \\<subseteq> set xs} =\n  PP ` {t. deg_pp (PP t) \\<le> d \\<and> keys_pp (PP t) \\<subseteq> set xs}\n\ngoal (1 subgoal):\n 1. map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) =\n    deg_le_sect_pp xs d", "also"], ["proof (state)\nthis:\n  PP ` {t. deg_pm t \\<le> d \\<and> keys t \\<subseteq> set xs} =\n  PP ` {t. deg_pp (PP t) \\<le> d \\<and> keys_pp (PP t) \\<subseteq> set xs}\n\ngoal (1 subgoal):\n 1. map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) =\n    deg_le_sect_pp xs d", "have \"\\<dots> = {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP `\n    {t. deg_pp (PP t) \\<le> d \\<and> keys_pp (PP t) \\<subseteq> set xs} =\n    {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}", "proof (intro subset_antisym subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n 2. \\<And>x.\n       x \\<in> {t. deg_pp t \\<le> d \\<and>\n                   keys_pp t \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs}", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n 2. \\<And>x.\n       x \\<in> {t. deg_pp t \\<le> d \\<and>\n                   keys_pp t \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs}", "assume \"t \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\""], ["proof (state)\nthis:\n  t \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n 2. \\<And>x.\n       x \\<in> {t. deg_pp t \\<le> d \\<and>\n                   keys_pp t \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs}", "moreover"], ["proof (state)\nthis:\n  t \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n 2. \\<And>x.\n       x \\<in> {t. deg_pp t \\<le> d \\<and>\n                   keys_pp t \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs}", "have \"t = PP (mapping_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = PP (pp.mapping_of t)", "by (simp only: mapping_of_inverse)"], ["proof (state)\nthis:\n  t = PP (pp.mapping_of t)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n 2. \\<And>x.\n       x \\<in> {t. deg_pp t \\<le> d \\<and>\n                   keys_pp t \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs}", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n  t = PP (pp.mapping_of t)", "show \"t \\<in> PP ` {t. deg_pp (PP t) \\<le> d \\<and> keys_pp (PP t) \\<subseteq> set xs}\""], ["proof (prove)\nusing this:\n  t \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n  t = PP (pp.mapping_of t)\n\ngoal (1 subgoal):\n 1. t \\<in> PP `\n            {t. deg_pp (PP t) \\<le> d \\<and>\n                keys_pp (PP t) \\<subseteq> set xs}", "by auto"], ["proof (state)\nthis:\n  t \\<in> PP `\n          {t. deg_pp (PP t) \\<le> d \\<and>\n              keys_pp (PP t) \\<subseteq> set xs}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> PP `\n               {t. deg_pp (PP t) \\<le> d \\<and>\n                   keys_pp (PP t) \\<subseteq> set xs} \\<Longrightarrow>\n       x \\<in> {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}", "qed auto"], ["proof (state)\nthis:\n  PP ` {t. deg_pp (PP t) \\<le> d \\<and> keys_pp (PP t) \\<subseteq> set xs} =\n  {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n\ngoal (1 subgoal):\n 1. map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) =\n    deg_le_sect_pp xs d", "finally"], ["proof (chain)\npicking this:\n  PP ` {t. deg_pm t \\<le> d \\<and> keys t \\<subseteq> set xs} =\n  {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}", "show ?thesis"], ["proof (prove)\nusing this:\n  PP ` {t. deg_pm t \\<le> d \\<and> keys t \\<subseteq> set xs} =\n  {t. deg_pp t \\<le> d \\<and> keys_pp t \\<subseteq> set xs}\n\ngoal (1 subgoal):\n 1. map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) =\n    deg_le_sect_pp xs d", "by (simp add: deg_le_sect_pp_def punit.keys_to_list_def keys_deg_le_sect_pp_aux deg_le_sect_alt\n      PPs_def conj_commute map_PP_pps_to_list flip: Collect_conj_eq)"], ["proof (state)\nthis:\n  map PP (pp_pm.punit.pps_to_list (deg_le_sect (set xs) d)) =\n  deg_le_sect_pp xs d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deg_shifts_deg_shifts_pp:\n  \"pp_pm.deg_shifts (set xs) d (map (Poly_Mapping.map_key PP) fs) =\n        map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.deg_shifts (set xs) d (map (Poly_Mapping.map_key PP) fs) =\n    map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs)", "by (simp add: pp_pm.deg_shifts_def deg_shifts_pp_def map_concat comp_def poly_deg_map_key_PP\n         map_key_PP_monom_mult_punit PP_inverse flip: deg_le_sect_deg_le_sect_pp monom_mult_punit_def)"], ["", "lemma ideal_deg_shifts_pp: \"ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "have \"ideal (set (deg_shifts_pp xs d fs)) =\n        Poly_Mapping.map_key mapping_of ` Poly_Mapping.map_key PP ` ideal (set (deg_shifts_pp xs d fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) =\n    Poly_Mapping.map_key pp.mapping_of `\n    Poly_Mapping.map_key PP ` ideal (set (deg_shifts_pp xs d fs))", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  ideal (set (deg_shifts_pp xs d fs)) =\n  Poly_Mapping.map_key pp.mapping_of `\n  Poly_Mapping.map_key PP ` ideal (set (deg_shifts_pp xs d fs))\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "also"], ["proof (state)\nthis:\n  ideal (set (deg_shifts_pp xs d fs)) =\n  Poly_Mapping.map_key pp.mapping_of `\n  Poly_Mapping.map_key PP ` ideal (set (deg_shifts_pp xs d fs))\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "have \"\\<dots> = Poly_Mapping.map_key mapping_of ` ideal\n                    (set (map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key pp.mapping_of `\n    Poly_Mapping.map_key PP ` ideal (set (deg_shifts_pp xs d fs)) =\n    Poly_Mapping.map_key pp.mapping_of `\n    ideal (set (map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs)))", "by (simp add: map_key_PP_ideal)"], ["proof (state)\nthis:\n  Poly_Mapping.map_key pp.mapping_of `\n  Poly_Mapping.map_key PP ` ideal (set (deg_shifts_pp xs d fs)) =\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (set (map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs)))\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "also"], ["proof (state)\nthis:\n  Poly_Mapping.map_key pp.mapping_of `\n  Poly_Mapping.map_key PP ` ideal (set (deg_shifts_pp xs d fs)) =\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (set (map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs)))\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "have \"\\<dots> = Poly_Mapping.map_key mapping_of ` ideal (Poly_Mapping.map_key PP ` set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key pp.mapping_of `\n    ideal (set (map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs))) =\n    Poly_Mapping.map_key pp.mapping_of `\n    ideal (Poly_Mapping.map_key PP ` set fs)", "by (simp flip: deg_shifts_deg_shifts_pp)"], ["proof (state)\nthis:\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (set (map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs))) =\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (Poly_Mapping.map_key PP ` set fs)\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "also"], ["proof (state)\nthis:\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (set (map (Poly_Mapping.map_key PP) (deg_shifts_pp xs d fs))) =\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (Poly_Mapping.map_key PP ` set fs)\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "have \"\\<dots> = Poly_Mapping.map_key mapping_of ` Poly_Mapping.map_key PP ` ideal (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key pp.mapping_of `\n    ideal (Poly_Mapping.map_key PP ` set fs) =\n    Poly_Mapping.map_key pp.mapping_of `\n    Poly_Mapping.map_key PP ` ideal (set fs)", "by (simp only: map_key_PP_ideal)"], ["proof (state)\nthis:\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (Poly_Mapping.map_key PP ` set fs) =\n  Poly_Mapping.map_key pp.mapping_of `\n  Poly_Mapping.map_key PP ` ideal (set fs)\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "also"], ["proof (state)\nthis:\n  Poly_Mapping.map_key pp.mapping_of `\n  ideal (Poly_Mapping.map_key PP ` set fs) =\n  Poly_Mapping.map_key pp.mapping_of `\n  Poly_Mapping.map_key PP ` ideal (set fs)\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "have \"\\<dots> = ideal (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map_key pp.mapping_of `\n    Poly_Mapping.map_key PP ` ideal (set fs) =\n    ideal (set fs)", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  Poly_Mapping.map_key pp.mapping_of `\n  Poly_Mapping.map_key PP ` ideal (set fs) =\n  ideal (set fs)\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "finally"], ["proof (chain)\npicking this:\n  ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)\n\ngoal (1 subgoal):\n 1. ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)", "."], ["proof (state)\nthis:\n  ideal (set (deg_shifts_pp xs d fs)) = ideal (set fs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_indets_pp: \"set (indets_pp p) = indets (Poly_Mapping.map_key PP p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (indets_pp p) = indets (Poly_Mapping.map_key PP p)", "by (simp add: indets_pp_def indets_def keys_pp_to_list_def keys_pp.rep_eq punit.set_keys_to_list\n        keys_map_key_PP)"], ["", "lemma poly_to_row_map_key_PP:\n  \"poly_to_row (map pp.mapping_of xs) (Poly_Mapping.map_key PP p) = poly_to_row xs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_to_row (map pp.mapping_of xs) (Poly_Mapping.map_key PP p) =\n    poly_to_row xs p", "by (simp add: poly_to_row_def comp_def lookup_map_key_PP mapping_of_inverse)"], ["", "lemma Macaulay_mat_map_key_PP:\n  \"pp_pm.punit.Macaulay_mat (map (Poly_Mapping.map_key PP) fs) = punit.Macaulay_mat fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.punit.Macaulay_mat (map (Poly_Mapping.map_key PP) fs) =\n    punit.Macaulay_mat fs", "by (simp add: punit.Macaulay_mat_def pp_pm.punit.Macaulay_mat_def Keys_to_list_map_key_PP\n          polys_to_mat_def comp_def poly_to_row_map_key_PP)"], ["", "lemma row_to_poly_mapping_of:\n  assumes \"distinct ts\" and \"dim_vec r = length ts\"\n  shows \"row_to_poly (map pp.mapping_of ts) r = Poly_Mapping.map_key PP (row_to_poly ts r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_to_poly (map pp.mapping_of ts) r =\n    Poly_Mapping.map_key PP (row_to_poly ts r)", "proof (rule poly_mapping_eqI, simp only: lookup_map_key_PP)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (row_to_poly (map pp.mapping_of ts) r) k =\n       lookup (row_to_poly ts r) (PP k)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (row_to_poly (map pp.mapping_of ts) r) k =\n       lookup (row_to_poly ts r) (PP k)", "let ?ts = \"map mapping_of ts\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (row_to_poly (map pp.mapping_of ts) r) k =\n       lookup (row_to_poly ts r) (PP k)", "from inj_mapping_of subset_UNIV"], ["proof (chain)\npicking this:\n  inj pp.mapping_of\n  ?A \\<subseteq> UNIV", "have \"inj_on mapping_of (set ts)\""], ["proof (prove)\nusing this:\n  inj pp.mapping_of\n  ?A \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. inj_on pp.mapping_of (set ts)", "by (rule inj_on_subset)"], ["proof (state)\nthis:\n  inj_on pp.mapping_of (set ts)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (row_to_poly (map pp.mapping_of ts) r) k =\n       lookup (row_to_poly ts r) (PP k)", "with assms(1)"], ["proof (chain)\npicking this:\n  distinct ts\n  inj_on pp.mapping_of (set ts)", "have 1: \"distinct ?ts\""], ["proof (prove)\nusing this:\n  distinct ts\n  inj_on pp.mapping_of (set ts)\n\ngoal (1 subgoal):\n 1. distinct (map pp.mapping_of ts)", "by (simp add: distinct_map)"], ["proof (state)\nthis:\n  distinct (map pp.mapping_of ts)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (row_to_poly (map pp.mapping_of ts) r) k =\n       lookup (row_to_poly ts r) (PP k)", "from assms(2)"], ["proof (chain)\npicking this:\n  dim_vec r = length ts", "have 2: \"dim_vec r = length ?ts\""], ["proof (prove)\nusing this:\n  dim_vec r = length ts\n\ngoal (1 subgoal):\n 1. dim_vec r = length (map pp.mapping_of ts)", "by simp"], ["proof (state)\nthis:\n  dim_vec r = length (map pp.mapping_of ts)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (row_to_poly (map pp.mapping_of ts) r) k =\n       lookup (row_to_poly ts r) (PP k)", "show \"lookup (row_to_poly ?ts r) t = lookup (row_to_poly ts r) (PP t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "proof (cases \"t \\<in> set ?ts\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)\n 2. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "case True"], ["proof (state)\nthis:\n  t \\<in> set (map pp.mapping_of ts)\n\ngoal (2 subgoals):\n 1. t \\<in> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)\n 2. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "then"], ["proof (chain)\npicking this:\n  t \\<in> set (map pp.mapping_of ts)", "obtain i where i1: \"i < length ?ts\" and t1: \"t = ?ts ! i\""], ["proof (prove)\nusing this:\n  t \\<in> set (map pp.mapping_of ts)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (map pp.mapping_of ts);\n         t = map pp.mapping_of ts ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length (map pp.mapping_of ts)\n  t = map pp.mapping_of ts ! i\n\ngoal (2 subgoals):\n 1. t \\<in> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)\n 2. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "hence i2: \"i < length ts\" and t2: \"PP t = ts ! i\""], ["proof (prove)\nusing this:\n  i < length (map pp.mapping_of ts)\n  t = map pp.mapping_of ts ! i\n\ngoal (1 subgoal):\n 1. i < length ts &&& PP t = ts ! i", "by (simp_all add: mapping_of_inverse)"], ["proof (state)\nthis:\n  i < length ts\n  PP t = ts ! i\n\ngoal (2 subgoals):\n 1. t \\<in> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)\n 2. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "have \"lookup (row_to_poly ?ts r) t = r $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (row_to_poly (map pp.mapping_of ts) r) t = r $ i", "unfolding t1"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (row_to_poly (map pp.mapping_of ts) r)\n     (map pp.mapping_of ts ! i) =\n    r $ i", "using 1 2 i1"], ["proof (prove)\nusing this:\n  distinct (map pp.mapping_of ts)\n  dim_vec r = length (map pp.mapping_of ts)\n  i < length (map pp.mapping_of ts)\n\ngoal (1 subgoal):\n 1. lookup (row_to_poly (map pp.mapping_of ts) r)\n     (map pp.mapping_of ts ! i) =\n    r $ i", "by (rule punit.lookup_row_to_poly)"], ["proof (state)\nthis:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t = r $ i\n\ngoal (2 subgoals):\n 1. t \\<in> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)\n 2. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "moreover"], ["proof (state)\nthis:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t = r $ i\n\ngoal (2 subgoals):\n 1. t \\<in> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)\n 2. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "have \"lookup (row_to_poly ts r) (PP t) = r $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (row_to_poly ts r) (PP t) = r $ i", "unfolding t2"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (row_to_poly ts r) (ts ! i) = r $ i", "using assms i2"], ["proof (prove)\nusing this:\n  distinct ts\n  dim_vec r = length ts\n  i < length ts\n\ngoal (1 subgoal):\n 1. lookup (row_to_poly ts r) (ts ! i) = r $ i", "by (rule punit.lookup_row_to_poly)"], ["proof (state)\nthis:\n  lookup (row_to_poly ts r) (PP t) = r $ i\n\ngoal (2 subgoals):\n 1. t \\<in> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)\n 2. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "ultimately"], ["proof (chain)\npicking this:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t = r $ i\n  lookup (row_to_poly ts r) (PP t) = r $ i", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t = r $ i\n  lookup (row_to_poly ts r) (PP t) = r $ i\n\ngoal (1 subgoal):\n 1. lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "by simp"], ["proof (state)\nthis:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t =\n  lookup (row_to_poly ts r) (PP t)\n\ngoal (1 subgoal):\n 1. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "case False"], ["proof (state)\nthis:\n  t \\<notin> set (map pp.mapping_of ts)\n\ngoal (1 subgoal):\n 1. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "have \"PP t \\<notin> set ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP t \\<notin> set ts", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. PP t \\<in> set ts \\<Longrightarrow> False", "assume \"PP t \\<in> set ts\""], ["proof (state)\nthis:\n  PP t \\<in> set ts\n\ngoal (1 subgoal):\n 1. PP t \\<in> set ts \\<Longrightarrow> False", "hence \"mapping_of (PP t) \\<in> mapping_of ` set ts\""], ["proof (prove)\nusing this:\n  PP t \\<in> set ts\n\ngoal (1 subgoal):\n 1. pp.mapping_of (PP t) \\<in> pp.mapping_of ` set ts", "by (rule imageI)"], ["proof (state)\nthis:\n  pp.mapping_of (PP t) \\<in> pp.mapping_of ` set ts\n\ngoal (1 subgoal):\n 1. PP t \\<in> set ts \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  t \\<notin> set (map pp.mapping_of ts)\n  pp.mapping_of (PP t) \\<in> pp.mapping_of ` set ts", "show False"], ["proof (prove)\nusing this:\n  t \\<notin> set (map pp.mapping_of ts)\n  pp.mapping_of (PP t) \\<in> pp.mapping_of ` set ts\n\ngoal (1 subgoal):\n 1. False", "by (simp add: PP_inverse)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  PP t \\<notin> set ts\n\ngoal (1 subgoal):\n 1. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "with punit.keys_row_to_poly"], ["proof (chain)\npicking this:\n  keys (row_to_poly ?ts ?r) \\<subseteq> set ?ts\n  PP t \\<notin> set ts", "have \"lookup (row_to_poly ts r) (PP t) = 0\""], ["proof (prove)\nusing this:\n  keys (row_to_poly ?ts ?r) \\<subseteq> set ?ts\n  PP t \\<notin> set ts\n\ngoal (1 subgoal):\n 1. lookup (row_to_poly ts r) (PP t) = (0::'c)", "by (metis in_keys_iff in_mono)"], ["proof (state)\nthis:\n  lookup (row_to_poly ts r) (PP t) = (0::'c)\n\ngoal (1 subgoal):\n 1. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "moreover"], ["proof (state)\nthis:\n  lookup (row_to_poly ts r) (PP t) = (0::'c)\n\ngoal (1 subgoal):\n 1. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "from False punit.keys_row_to_poly"], ["proof (chain)\npicking this:\n  t \\<notin> set (map pp.mapping_of ts)\n  keys (row_to_poly ?ts ?r) \\<subseteq> set ?ts", "have \"lookup (row_to_poly ?ts r) t = 0\""], ["proof (prove)\nusing this:\n  t \\<notin> set (map pp.mapping_of ts)\n  keys (row_to_poly ?ts ?r) \\<subseteq> set ?ts\n\ngoal (1 subgoal):\n 1. lookup (row_to_poly (map pp.mapping_of ts) r) t = (0::'c)", "by (metis in_keys_iff in_mono)"], ["proof (state)\nthis:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t = (0::'c)\n\ngoal (1 subgoal):\n 1. t \\<notin> set (map pp.mapping_of ts) \\<Longrightarrow>\n    lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "ultimately"], ["proof (chain)\npicking this:\n  lookup (row_to_poly ts r) (PP t) = (0::'c)\n  lookup (row_to_poly (map pp.mapping_of ts) r) t = (0::'c)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (row_to_poly ts r) (PP t) = (0::'c)\n  lookup (row_to_poly (map pp.mapping_of ts) r) t = (0::'c)\n\ngoal (1 subgoal):\n 1. lookup (row_to_poly (map pp.mapping_of ts) r) t =\n    lookup (row_to_poly ts r) (PP t)", "by simp"], ["proof (state)\nthis:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t =\n  lookup (row_to_poly ts r) (PP t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (row_to_poly (map pp.mapping_of ts) r) t =\n  lookup (row_to_poly ts r) (PP t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_to_polys_mapping_of:\n  assumes \"distinct ts\" and \"dim_col m = length ts\"\n  shows \"mat_to_polys (map pp.mapping_of ts) m = map (Poly_Mapping.map_key PP) (mat_to_polys ts m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "assume \"r \\<in> set (rows m)\""], ["proof (state)\nthis:\n  r \\<in> set (rows m)\n\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "then"], ["proof (chain)\npicking this:\n  r \\<in> set (rows m)", "obtain i where \"r = row m i\""], ["proof (prove)\nusing this:\n  r \\<in> set (rows m)\n\ngoal (1 subgoal):\n 1. (\\<And>i. r = row m i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: rows_def)"], ["proof (state)\nthis:\n  r = row m i\n\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "hence \"dim_vec r = length ts\""], ["proof (prove)\nusing this:\n  r = row m i\n\ngoal (1 subgoal):\n 1. dim_vec r = length ts", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  dim_vec r = length ts\n\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "with assms(1)"], ["proof (chain)\npicking this:\n  distinct ts\n  dim_vec r = length ts", "have \"row_to_poly (map pp.mapping_of ts) r = Poly_Mapping.map_key PP (row_to_poly ts r)\""], ["proof (prove)\nusing this:\n  distinct ts\n  dim_vec r = length ts\n\ngoal (1 subgoal):\n 1. row_to_poly (map pp.mapping_of ts) r =\n    Poly_Mapping.map_key PP (row_to_poly ts r)", "by (rule row_to_poly_mapping_of)"], ["proof (state)\nthis:\n  row_to_poly (map pp.mapping_of ts) r =\n  Poly_Mapping.map_key PP (row_to_poly ts r)\n\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "}"], ["proof (state)\nthis:\n  ?r11 \\<in> set (rows m) \\<Longrightarrow>\n  row_to_poly (map pp.mapping_of ts) ?r11 =\n  Poly_Mapping.map_key PP (row_to_poly ts ?r11)\n\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?r11 \\<in> set (rows m) \\<Longrightarrow>\n  row_to_poly (map pp.mapping_of ts) ?r11 =\n  Poly_Mapping.map_key PP (row_to_poly ts ?r11)\n\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "using assms"], ["proof (prove)\nusing this:\n  ?r11 \\<in> set (rows m) \\<Longrightarrow>\n  row_to_poly (map pp.mapping_of ts) ?r11 =\n  Poly_Mapping.map_key PP (row_to_poly ts ?r11)\n  distinct ts\n  dim_col m = length ts\n\ngoal (1 subgoal):\n 1. mat_to_polys (map pp.mapping_of ts) m =\n    map (Poly_Mapping.map_key PP) (mat_to_polys ts m)", "by (simp add: mat_to_polys_def)"], ["proof (state)\nthis:\n  mat_to_polys (map pp.mapping_of ts) m =\n  map (Poly_Mapping.map_key PP) (mat_to_polys ts m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_key_PP_Macaulay_list:\n  \"map (Poly_Mapping.map_key PP) (punit.Macaulay_list fs) =\n      pp_pm.punit.Macaulay_list (map (Poly_Mapping.map_key PP) fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (Poly_Mapping.map_key PP) (punit.Macaulay_list fs) =\n    pp_pm.punit.Macaulay_list (map (Poly_Mapping.map_key PP) fs)", "by (simp add: punit.Macaulay_list_def pp_pm.punit.Macaulay_list_def Macaulay_mat_map_key_PP\n          Keys_to_list_map_key_PP mat_to_polys_mapping_of filter_map comp_def\n          punit.distinct_Keys_to_list punit.length_Keys_to_list)"], ["", "lemma lpp_map_key_PP: \"pp_pm.lpp (Poly_Mapping.map_key PP p) = mapping_of (lpp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "by (simp add: zero_pp.rep_eq)"], ["proof (state)\nthis:\n  pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)", "proof (rule pp_pm.punit.lt_eqI_keys)"], ["proof (state)\ngoal (2 subgoals):\n 1. pp.mapping_of (lpp p) \\<in> keys (Poly_Mapping.map_key PP p)\n 2. \\<And>u.\n       u \\<in> keys (Poly_Mapping.map_key PP p) \\<Longrightarrow>\n       ord (PP u) (PP (pp.mapping_of (lpp p)))", "show \"pp.mapping_of (lpp p) \\<in> keys (Poly_Mapping.map_key PP p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp.mapping_of (lpp p) \\<in> keys (Poly_Mapping.map_key PP p)", "unfolding keys_map_key_PP"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp.mapping_of (lpp p) \\<in> pp.mapping_of ` keys p", "by (intro imageI punit.lt_in_keys False)"], ["proof (state)\nthis:\n  pp.mapping_of (lpp p) \\<in> keys (Poly_Mapping.map_key PP p)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (Poly_Mapping.map_key PP p) \\<Longrightarrow>\n       ord (PP u) (PP (pp.mapping_of (lpp p)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (Poly_Mapping.map_key PP p) \\<Longrightarrow>\n       ord (PP u) (PP (pp.mapping_of (lpp p)))", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (Poly_Mapping.map_key PP p) \\<Longrightarrow>\n       ord (PP u) (PP (pp.mapping_of (lpp p)))", "assume \"s \\<in> keys (Poly_Mapping.map_key PP p)\""], ["proof (state)\nthis:\n  s \\<in> keys (Poly_Mapping.map_key PP p)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (Poly_Mapping.map_key PP p) \\<Longrightarrow>\n       ord (PP u) (PP (pp.mapping_of (lpp p)))", "then"], ["proof (chain)\npicking this:\n  s \\<in> keys (Poly_Mapping.map_key PP p)", "obtain t where \"t \\<in> keys p\" and s: \"s = mapping_of t\""], ["proof (prove)\nusing this:\n  s \\<in> keys (Poly_Mapping.map_key PP p)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; s = pp.mapping_of t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding keys_map_key_PP"], ["proof (prove)\nusing this:\n  s \\<in> pp.mapping_of ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys p; s = pp.mapping_of t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t \\<in> keys p\n  s = pp.mapping_of t\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> keys (Poly_Mapping.map_key PP p) \\<Longrightarrow>\n       ord (PP u) (PP (pp.mapping_of (lpp p)))", "thus \"ord (PP s) (PP (pp.mapping_of (lpp p)))\""], ["proof (prove)\nusing this:\n  t \\<in> keys p\n  s = pp.mapping_of t\n\ngoal (1 subgoal):\n 1. ord (PP s) (PP (pp.mapping_of (lpp p)))", "by (simp add: mapping_of_inverse punit.lt_max_keys)"], ["proof (state)\nthis:\n  ord (PP s) (PP (pp.mapping_of (lpp p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pp_pm.lpp (Poly_Mapping.map_key PP p) = pp.mapping_of (lpp p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_GB_map_key_PP:\n  \"finite G \\<Longrightarrow> pp_pm.punit.is_Groebner_basis (Poly_Mapping.map_key PP ` G) \\<longleftrightarrow> punit.is_Groebner_basis G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite G \\<Longrightarrow>\n    pp_pm.punit.is_Groebner_basis (Poly_Mapping.map_key PP ` G) =\n    punit.is_Groebner_basis G", "by (simp add: punit.GB_alt_3_finite pp_pm.punit.GB_alt_3_finite lpp_map_key_PP adds_pp_iff\n        flip: map_key_PP_ideal)"], ["", "lemma thm_2_3_6_pp:\n  assumes \"pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs) b\"\n  shows \"punit.is_Groebner_basis (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "let ?fs = \"map (Poly_Mapping.map_key PP) fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "from assms"], ["proof (chain)\npicking this:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs) b", "have \"pp_pm.is_GB_cofactor_bound (set ?fs) b\""], ["proof (prove)\nusing this:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs) b\n\ngoal (1 subgoal):\n 1. pp_pm.is_GB_cofactor_bound (set (map (Poly_Mapping.map_key PP) fs)) b", "by simp"], ["proof (state)\nthis:\n  pp_pm.is_GB_cofactor_bound (set (map (Poly_Mapping.map_key PP) fs)) b\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "hence \"pp_pm.punit.is_Groebner_basis\n                (set (pp_pm.punit.Macaulay_list (pp_pm.deg_shifts (\\<Union> (indets ` set ?fs)) b ?fs)))\""], ["proof (prove)\nusing this:\n  pp_pm.is_GB_cofactor_bound (set (map (Poly_Mapping.map_key PP) fs)) b\n\ngoal (1 subgoal):\n 1. pp_pm.punit.is_Groebner_basis\n     (set (pp_pm.punit.Macaulay_list\n            (pp_pm.deg_shifts\n              (\\<Union> (indets ` set (map (Poly_Mapping.map_key PP) fs))) b\n              (map (Poly_Mapping.map_key PP) fs))))", "by (rule pp_pm.thm_2_3_6_indets)"], ["proof (state)\nthis:\n  pp_pm.punit.is_Groebner_basis\n   (set (pp_pm.punit.Macaulay_list\n          (pp_pm.deg_shifts\n            (\\<Union> (indets ` set (map (Poly_Mapping.map_key PP) fs))) b\n            (map (Poly_Mapping.map_key PP) fs))))\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "also"], ["proof (state)\nthis:\n  pp_pm.punit.is_Groebner_basis\n   (set (pp_pm.punit.Macaulay_list\n          (pp_pm.deg_shifts\n            (\\<Union> (indets ` set (map (Poly_Mapping.map_key PP) fs))) b\n            (map (Poly_Mapping.map_key PP) fs))))\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "have \"(\\<Union> (indets ` set ?fs)) = set (Indets_pp fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (indets ` set (map (Poly_Mapping.map_key PP) fs)) =\n    set (Indets_pp fs)", "by (simp add: Indets_pp_def set_indets_pp)"], ["proof (state)\nthis:\n  \\<Union> (indets ` set (map (Poly_Mapping.map_key PP) fs)) =\n  set (Indets_pp fs)\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "finally"], ["proof (chain)\npicking this:\n  pp_pm.punit.is_Groebner_basis\n   (set (pp_pm.punit.Macaulay_list\n          (pp_pm.deg_shifts (set (Indets_pp fs)) b\n            (map (Poly_Mapping.map_key PP) fs))))", "show ?thesis"], ["proof (prove)\nusing this:\n  pp_pm.punit.is_Groebner_basis\n   (set (pp_pm.punit.Macaulay_list\n          (pp_pm.deg_shifts (set (Indets_pp fs)) b\n            (map (Poly_Mapping.map_key PP) fs))))\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))", "by (simp add: deg_shifts_deg_shifts_pp map_key_PP_Macaulay_list flip: set_map is_GB_map_key_PP)"], ["proof (state)\nthis:\n  punit.is_Groebner_basis\n   (set (punit.Macaulay_list (deg_shifts_pp (Indets_pp fs) b fs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Dube_is_GB_cofactor_bound_pp:\n  \"pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n            (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "proof (cases \"fs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fs = [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))\n 2. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "case True"], ["proof (state)\nthis:\n  fs = []\n\ngoal (2 subgoals):\n 1. fs = [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))\n 2. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "by (rule pp_pm.is_GB_cofactor_boundI_subset_zero) (simp add: True)"], ["proof (state)\nthis:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n   (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "case False"], ["proof (state)\nthis:\n  fs \\<noteq> []\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "let ?F = \"Poly_Mapping.map_key PP ` set fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "have \"pp_pm.is_GB_cofactor_bound ?F (Dube (Suc (card (\\<Union> (indets ` ?F)))) (maxdeg ?F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube\n       (Suc (card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs))))\n       (maxdeg (Poly_Mapping.map_key PP ` set fs)))", "by (intro pp_pm.Dube_is_GB_cofactor_bound_indets finite_imageI finite_set)"], ["proof (state)\nthis:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n   (Dube (Suc (card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs))))\n     (maxdeg (Poly_Mapping.map_key PP ` set fs)))\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "moreover"], ["proof (state)\nthis:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n   (Dube (Suc (card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs))))\n     (maxdeg (Poly_Mapping.map_key PP ` set fs)))\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "have \"card (\\<Union> (indets ` ?F)) = length (Indets_pp fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs)) =\n    length (Indets_pp fs)", "by (simp add: Indets_pp_def length_remdups_card_conv set_indets_pp)"], ["proof (state)\nthis:\n  card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs)) =\n  length (Indets_pp fs)\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "moreover"], ["proof (state)\nthis:\n  card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs)) =\n  length (Indets_pp fs)\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "from False"], ["proof (chain)\npicking this:\n  fs \\<noteq> []", "have \"maxdeg ?F = max_list (map poly_deg_pp fs)\""], ["proof (prove)\nusing this:\n  fs \\<noteq> []\n\ngoal (1 subgoal):\n 1. maxdeg (Poly_Mapping.map_key PP ` set fs) =\n    max_list (map poly_deg_pp fs)", "by (simp add: max_list_Max maxdeg_def image_image poly_deg_map_key_PP)"], ["proof (state)\nthis:\n  maxdeg (Poly_Mapping.map_key PP ` set fs) = max_list (map poly_deg_pp fs)\n\ngoal (1 subgoal):\n 1. fs \\<noteq> [] \\<Longrightarrow>\n    pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "ultimately"], ["proof (chain)\npicking this:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n   (Dube (Suc (card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs))))\n     (maxdeg (Poly_Mapping.map_key PP ` set fs)))\n  card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs)) =\n  length (Indets_pp fs)\n  maxdeg (Poly_Mapping.map_key PP ` set fs) = max_list (map poly_deg_pp fs)", "show ?thesis"], ["proof (prove)\nusing this:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n   (Dube (Suc (card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs))))\n     (maxdeg (Poly_Mapping.map_key PP ` set fs)))\n  card (\\<Union> (indets ` Poly_Mapping.map_key PP ` set fs)) =\n  length (Indets_pp fs)\n  maxdeg (Poly_Mapping.map_key PP ` set fs) = max_list (map poly_deg_pp fs)\n\ngoal (1 subgoal):\n 1. pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n     (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))", "by simp"], ["proof (state)\nthis:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set fs)\n   (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition GB_Macaulay_Dube :: \"(('x, nat) pp \\<Rightarrow>\\<^sub>0 'a) list \\<Rightarrow> (('x, nat) pp \\<Rightarrow>\\<^sub>0 'a::field) list\"\n  where \"GB_Macaulay_Dube fs = punit.Macaulay_list (deg_shifts_pp (Indets_pp fs)\n                            (Dube (Suc (length (Indets_pp fs))) (max_list (map poly_deg_pp fs))) fs)\""], ["", "lemma GB_Macaulay_Dube_is_GB: \"punit.is_Groebner_basis (set (GB_Macaulay_Dube fs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis (set (GB_Macaulay_Dube fs))", "unfolding GB_Macaulay_Dube_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list\n            (deg_shifts_pp (Indets_pp fs)\n              (Dube (Suc (length (Indets_pp fs)))\n                (max_list (map poly_deg_pp fs)))\n              fs)))", "using Dube_is_GB_cofactor_bound_pp"], ["proof (prove)\nusing this:\n  pp_pm.is_GB_cofactor_bound (Poly_Mapping.map_key PP ` set ?fs)\n   (Dube (Suc (length (Indets_pp ?fs))) (max_list (map poly_deg_pp ?fs)))\n\ngoal (1 subgoal):\n 1. punit.is_Groebner_basis\n     (set (punit.Macaulay_list\n            (deg_shifts_pp (Indets_pp fs)\n              (Dube (Suc (length (Indets_pp fs)))\n                (max_list (map poly_deg_pp fs)))\n              fs)))", "by (rule thm_2_3_6_pp)"], ["", "lemma ideal_GB_Macaulay_Dube: \"ideal (set (GB_Macaulay_Dube fs)) = ideal (set fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal (set (GB_Macaulay_Dube fs)) = ideal (set fs)", "by (simp add: GB_Macaulay_Dube_def punit.pmdl_Macaulay_list[simplified] ideal_deg_shifts_pp)"], ["", "end"], ["", "global_interpretation punit': pp_powerprod \"ord_pp_punit cmp_term\" \"ord_pp_strict_punit cmp_term\"\n  rewrites \"punit.adds_term = (adds)\"\n  and \"punit.pp_of_term = (\\<lambda>x. x)\"\n  and \"punit.component_of_term = (\\<lambda>_. ())\"\n  and \"punit.monom_mult = monom_mult_punit\"\n  and \"punit.mult_scalar = mult_scalar_punit\"\n  and \"punit'.punit.min_term = min_term_punit\"\n  and \"punit'.punit.lt = lt_punit cmp_term\"\n  and \"punit'.punit.lc = lc_punit cmp_term\"\n  and \"punit'.punit.tail = tail_punit cmp_term\"\n  and \"punit'.punit.ord_p = ord_p_punit cmp_term\"\n  and \"punit'.punit.keys_to_list = keys_to_list_punit cmp_term\"\n  for cmp_term :: \"('a::nat, nat) pp nat_term_order\"\n\n  defines max_punit = punit'.ordered_powerprod_lin.max\n  and max_list_punit = punit'.ordered_powerprod_lin.max_list\n  and Keys_to_list_punit = punit'.punit.Keys_to_list\n  and Macaulay_mat_punit = punit'.punit.Macaulay_mat\n  and Macaulay_list_punit = punit'.punit.Macaulay_list\n  and poly_deg_pp_punit = punit'.poly_deg_pp\n  and deg_le_sect_pp_aux_punit = punit'.deg_le_sect_pp_aux\n  and deg_le_sect_pp_punit = punit'.deg_le_sect_pp\n  and deg_shifts_pp_punit = punit'.deg_shifts_pp\n  and indets_pp_punit = punit'.indets_pp\n  and Indets_pp_punit = punit'.Indets_pp\n  and GB_Macaulay_Dube_punit = punit'.GB_Macaulay_Dube\n\n  (* Only needed for auto-reduction: *)\n  and find_adds_punit = punit'.punit.find_adds\n  and trd_aux_punit = punit'.punit.trd_aux\n  and trd_punit = punit'.punit.trd\n  and comp_min_basis_punit = punit'.punit.comp_min_basis\n  and comp_red_basis_aux_punit = punit'.punit.comp_red_basis_aux\n  and comp_red_basis_punit = punit'.punit.comp_red_basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((pp_powerprod (ord_pp_punit cmp_term)\n       (ord_pp_strict_punit cmp_term) &&&\n      punit.adds_term = (adds) &&& punit.pp_of_term = (\\<lambda>x. x)) &&&\n     punit.component_of_term = (\\<lambda>_. ()) &&&\n     punit.monom_mult = monom_mult_punit &&&\n     punit.mult_scalar = mult_scalar_punit) &&&\n    (ordered_term.min_term fst = min_term_punit &&&\n     ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term &&&\n     ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term) &&&\n    ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term &&&\n    ordered_term.ord_p (ord_pp_strict_punit cmp_term) =\n    ord_p_punit cmp_term &&&\n    ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_powerprod (ord_pp_punit cmp_term) (ord_pp_strict_punit cmp_term)", "unfolding punit0.ord_pp_def punit0.ord_pp_strict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_powerprod\n     (\\<lambda>s t.\n         le_of_nat_term_order cmp_term (fst (s, the_min))\n          (fst (t, the_min)))\n     (\\<lambda>s t.\n         lt_of_nat_term_order cmp_term (fst (s, the_min))\n          (fst (t, the_min)))", ".."], ["proof (prove)\ngoal (11 subgoals):\n 1. punit.adds_term = (adds)\n 2. punit.pp_of_term = (\\<lambda>x. x)\n 3. punit.component_of_term = (\\<lambda>_. ())\n 4. punit.monom_mult = monom_mult_punit\n 5. punit.mult_scalar = mult_scalar_punit\n 6. ordered_term.min_term fst = min_term_punit\n 7. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 8. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 9. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 10. ordered_term.ord_p (ord_pp_strict_punit cmp_term) =\n     ord_p_punit cmp_term\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.adds_term = (adds)", "by (fact punit_adds_term)"], ["proof (prove)\ngoal (10 subgoals):\n 1. punit.pp_of_term = (\\<lambda>x. x)\n 2. punit.component_of_term = (\\<lambda>_. ())\n 3. punit.monom_mult = monom_mult_punit\n 4. punit.mult_scalar = mult_scalar_punit\n 5. ordered_term.min_term fst = min_term_punit\n 6. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 7. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 8. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 9. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 10. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n     keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.pp_of_term = (\\<lambda>x. x)", "by (simp add: id_def)"], ["proof (prove)\ngoal (9 subgoals):\n 1. punit.component_of_term = (\\<lambda>_. ())\n 2. punit.monom_mult = monom_mult_punit\n 3. punit.mult_scalar = mult_scalar_punit\n 4. ordered_term.min_term fst = min_term_punit\n 5. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 6. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 7. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 8. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 9. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.component_of_term = (\\<lambda>_. ())", "by (fact punit_component_of_term)"], ["proof (prove)\ngoal (8 subgoals):\n 1. punit.monom_mult = monom_mult_punit\n 2. punit.mult_scalar = mult_scalar_punit\n 3. ordered_term.min_term fst = min_term_punit\n 4. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 5. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 6. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 7. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 8. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult = monom_mult_punit", "by (simp only: monom_mult_punit_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. punit.mult_scalar = mult_scalar_punit\n 2. ordered_term.min_term fst = min_term_punit\n 3. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 4. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 5. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 6. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 7. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.mult_scalar = mult_scalar_punit", "by (simp only: mult_scalar_punit_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ordered_term.min_term fst = min_term_punit\n 2. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 3. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 4. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 5. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 6. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.min_term fst = min_term_punit", "using min_term_punit_def"], ["proof (prove)\nusing this:\n  min_term_punit \\<equiv> ordered_term.min_term fst\n\ngoal (1 subgoal):\n 1. ordered_term.min_term fst = min_term_punit", "by fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 2. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 3. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 4. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 5. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term", "by (simp only: lt_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 2. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 3. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 4. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term", "by (simp only: lc_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 2. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 3. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term", "by (simp only: tail_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 2. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term", "by (simp only: ord_p_punit_def ord_pp_strict_punit_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "by (simp only: keys_to_list_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Computations\\<close>"], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"comp_red_basis_punit DRLEX (GB_Macaulay_Dube_punit DRLEX [X * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y, Y ^ 3 - X ^ 3]) =\n    [X ^ 5, X ^ 3 * Y - C\\<^sub>0 (1 / 9) * X ^ 4, Y ^ 3 - X ^ 3, X * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_red_basis_punit DRLEX\n     (GB_Macaulay_Dube_punit DRLEX\n       [V\\<^sub>0 0 * (V\\<^sub>0 1)\\<^sup>2 +\n        3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1,\n        V\\<^sub>0 1 ^ 3 - V\\<^sub>0 0 ^ 3]) =\n    [V\\<^sub>0 0 ^ 5,\n     V\\<^sub>0 0 ^ 3 * V\\<^sub>0 1 - C\\<^sub>0 (1 / 9) * V\\<^sub>0 0 ^ 4,\n     V\\<^sub>0 1 ^ 3 - V\\<^sub>0 0 ^ 3,\n     V\\<^sub>0 0 * (V\\<^sub>0 1)\\<^sup>2 +\n     3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1]", "by eval"], ["", "end"], ["", "end"], ["", "(* theory *)"]]}