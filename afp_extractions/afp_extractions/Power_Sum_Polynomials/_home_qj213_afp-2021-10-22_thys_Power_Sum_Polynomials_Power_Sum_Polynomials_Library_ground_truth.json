{"file_name": "/home/qj213/afp-2021-10-22/thys/Power_Sum_Polynomials/Power_Sum_Polynomials_Library.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Power_Sum_Polynomials", "problem_names": ["lemma atLeastAtMost_nat_numeral:\n  \"atLeastAtMost m (numeral k :: nat) =\n     (if m \\<le> numeral k then insert (numeral k) (atLeastAtMost m (pred_numeral k))\n                 else {})\"", "lemma sum_in_Rats [intro]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow> sum f A \\<in> \\<rat>\"", "lemma (in monoid_mult) prod_list_distinct_conv_prod_set:\n  \"distinct xs \\<Longrightarrow> prod_list (map f xs) = prod f (set xs)\"", "lemma (in monoid_mult) interv_prod_list_conv_prod_set_nat:\n  \"prod_list (map f [m..<n]) = prod f (set [m..<n])\"", "lemma (in monoid_mult) prod_list_prod_nth:\n  \"prod_list xs = (\\<Prod>i = 0..< length xs. xs ! i)\"", "lemma gcd_poly_code_aux_reduce:\n  \"gcd_poly_code_aux p 0 = normalize p\"\n  \"q \\<noteq> 0 \\<Longrightarrow> gcd_poly_code_aux p q = gcd_poly_code_aux q (primitive_part (pseudo_mod p q))\"", "lemma coprimeI_primes:\n  fixes a b :: \"'a :: factorial_semiring\"\n  assumes \"a \\<noteq> 0 \\<or> b \\<noteq> 0\"\n  assumes \"\\<And>p. prime p \\<Longrightarrow> p dvd a \\<Longrightarrow> p dvd b \\<Longrightarrow> False\"\n  shows   \"coprime a b\"", "lemma coprime_pderiv_imp_squarefree:\n  assumes \"coprime p (pderiv p)\"\n  shows   \"squarefree p\"", "lemma squarefree_field_poly_iff:\n  fixes p :: \"'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes [simp]: \"p \\<noteq> 0\"\n  shows \"squarefree p \\<longleftrightarrow> coprime p (pderiv p)\"", "lemma coprime_pderiv_imp_rsquarefree:\n  assumes \"coprime (p :: 'a :: field_char_0 poly) (pderiv p)\"\n  shows   \"rsquarefree p\"", "lemma poly_of_nat [simp]: \"poly (of_nat n) x = of_nat n\"", "lemma poly_of_int [simp]: \"poly (of_int n) x = of_int n\"", "lemma order_eq_0_iff: \"p \\<noteq> 0 \\<Longrightarrow> order x p = 0 \\<longleftrightarrow> poly p x \\<noteq> 0\"", "lemma order_pos_iff: \"p \\<noteq> 0 \\<Longrightarrow> order x p > 0 \\<longleftrightarrow> poly p x = 0\"", "lemma order_prod:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\"\n  shows   \"order x (\\<Prod>y\\<in>A. f y) = (\\<Sum>y\\<in>A. order x (f y))\"", "lemma order_prod_mset:\n  assumes \"0 \\<notin># A\"\n  shows   \"order x (prod_mset A) = sum_mset (image_mset (order x) A)\"", "lemma order_prod_list:\n  assumes \"0 \\<notin> set xs\"\n  shows   \"order x (prod_list xs) = sum_list (map (order x) xs)\"", "lemma order_power: \"p \\<noteq> 0 \\<Longrightarrow> order x (p ^ n) = n * order x p\"", "lemma smult_0_right [simp]: \"MPoly_Type.smult p 0 = 0\"", "lemma mult_smult_right [simp]: \n  fixes c :: \"'a :: comm_semiring_0\"\n  shows \"p * MPoly_Type.smult c q = MPoly_Type.smult c (p * q)\"", "lemma mapping_single_eq_iff [simp]:\n  \"Poly_Mapping.single a b = Poly_Mapping.single c d \\<longleftrightarrow> b = 0 \\<and> d = 0 \\<or> a = c \\<and> b = d\"", "lemma monom_of_set_plus_monom_of_set:\n  assumes \"A \\<inter> B = {}\" \"finite A\" \"finite B\"\n  shows   \"monom_of_set A + monom_of_set B = monom_of_set (A \\<union> B)\"", "lemma mpoly_monom_0_eq_Const: \"monom 0 c = Const c\"", "lemma mpoly_Const_0 [simp]: \"Const 0 = 0\"", "lemma mpoly_Const_1 [simp]: \"Const 1 = 1\"", "lemma mpoly_Const_uminus: \"Const (-a) = -Const a\"", "lemma mpoly_Const_add: \"Const (a + b) = Const a + Const b\"", "lemma mpoly_Const_mult: \"Const (a * b) = Const a * Const b\"", "lemma mpoly_Const_power: \"Const (a ^ n) = Const a ^ n\"", "lemma of_nat_mpoly_eq: \"of_nat n = Const (of_nat n)\"", "lemma insertion_of_nat [simp]: \"insertion f (of_nat n) = of_nat n\"", "lemma insertion_monom_of_set [simp]:\n  \"insertion f (monom (monom_of_set X) c) = c * (\\<Prod>i\\<in>X. f i)\"", "lemma symmetric_mpoly_symmetric_sum:\n  assumes \"\\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> g \\<pi> permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g \\<pi> x)\"\n  shows \"symmetric_mpoly A (\\<Sum>x\\<in>X. f x)\"", "lemma sym_mpoly_0 [simp]:\n  assumes \"finite A\"\n  shows   \"sym_mpoly A 0 = 1\"", "lemma sym_mpoly_eq_0 [simp]:\n  assumes \"k > card A\"\n  shows   \"sym_mpoly A k = 0\"", "lemma coeff_sym_mpoly_monom_of_set_eq_0:\n  assumes \"finite X\" \"Y \\<subseteq> X\" \"card Y \\<noteq> k\"\n  shows   \"MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = 0\"", "lemma coeff_sym_mpoly_monom_of_set_eq_0':\n  assumes \"finite X\" \"\\<not>Y \\<subseteq> X\" \"finite Y\"\n  shows   \"MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = 0\"", "lemma poly_roots_0 [simp]: \"poly_roots 0 = {#}\"", "lemma poly_roots_1 [simp]: \"poly_roots 1 = {#}\"", "lemma count_poly_roots [simp]:\n  assumes \"p \\<noteq> 0\"\n  shows   \"count (poly_roots p) x = order x p\"", "lemma in_poly_roots_iff [simp]: \"p \\<noteq> 0 \\<Longrightarrow> x \\<in># poly_roots p \\<longleftrightarrow> poly p x = 0\"", "lemma set_mset_poly_roots: \"p \\<noteq> 0 \\<Longrightarrow> set_mset (poly_roots p) = {x. poly p x = 0}\"", "lemma count_poly_roots': \"count (poly_roots p) x = (if p = 0 then 0 else order x p)\"", "lemma poly_roots_const [simp]: \"poly_roots [:c:] = {#}\"", "lemma poly_roots_linear [simp]: \"poly_roots [:-x, 1:] = {#x#}\"", "lemma poly_roots_monom [simp]: \"c \\<noteq> 0 \\<Longrightarrow> poly_roots (Polynomial.monom c n) = replicate_mset n 0\"", "lemma poly_roots_smult [simp]: \"c \\<noteq> 0 \\<Longrightarrow> poly_roots (Polynomial.smult c p) = poly_roots p\"", "lemma poly_roots_mult: \"p \\<noteq> 0 \\<Longrightarrow> q \\<noteq> 0 \\<Longrightarrow> poly_roots (p * q) = poly_roots p + poly_roots q\"", "lemma poly_roots_prod:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\"\n  shows   \"poly_roots (prod f A) = (\\<Sum>x\\<in>A. poly_roots (f x))\"", "lemma poly_roots_prod_mset:\n  assumes \"0 \\<notin># A\"\n  shows   \"poly_roots (prod_mset A) = sum_mset (image_mset poly_roots A)\"", "lemma poly_roots_prod_list:\n  assumes \"0 \\<notin> set xs\"\n  shows   \"poly_roots (prod_list xs) = sum_list (map poly_roots xs)\"", "lemma poly_roots_power: \"p \\<noteq> 0 \\<Longrightarrow> poly_roots (p ^ n) = repeat_mset n (poly_roots p)\"", "lemma rsquarefree_poly_roots_eq:\n  assumes \"rsquarefree p\"\n  shows   \"poly_roots p = mset_set {x. poly p x = 0}\"", "lemma rsquarefree_imp_distinct_roots:\n  assumes \"rsquarefree p\" and \"mset xs = poly_roots p\"\n  shows   \"distinct xs\"", "lemma poly_roots_factorization:\n  fixes p c A\n  assumes [simp]: \"c \\<noteq> 0\"\n  defines \"p \\<equiv> Polynomial.smult c (prod_mset (image_mset (\\<lambda>x. [:-x, 1:]) A))\"\n  shows   \"poly_roots p = A\"", "lemma fundamental_theorem_algebra_factorized':\n  fixes p :: \"complex poly\"\n  shows \"p = Polynomial.smult (Polynomial.lead_coeff p) \n               (prod_mset (image_mset (\\<lambda>x. [:-x, 1:]) (poly_roots p)))\"", "lemma poly_roots_eq_imp_eq:\n  fixes p q :: \"complex poly\"\n  assumes \"Polynomial.lead_coeff p = Polynomial.lead_coeff q\"\n  assumes \"poly_roots p = poly_roots q\"\n  shows   \"p = q\"", "lemma Sum_any_zeroI': \"(\\<And>x. P x \\<Longrightarrow> f x = 0) \\<Longrightarrow> Sum_any (\\<lambda>x. f x when P x) = 0\"", "lemma sym_mpoly_insert:\n  assumes \"finite X\" \"x \\<notin> X\"\n  shows   \"(sym_mpoly (insert x X) (Suc k) :: 'a :: semiring_1 mpoly) =\n             monom (monom_of_set {x}) 1 * sym_mpoly X k + sym_mpoly X (Suc k)\" (is \"?lhs = ?A + ?B\")"], "translations": [["", "lemma atLeastAtMost_nat_numeral:\n  \"atLeastAtMost m (numeral k :: nat) =\n     (if m \\<le> numeral k then insert (numeral k) (atLeastAtMost m (pred_numeral k))\n                 else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m..numeral k} =\n    (if m \\<le> numeral k then insert (numeral k) {m..pred_numeral k}\n     else {})", "by (simp add: numeral_eq_Suc atLeastAtMostSuc_conv)"], ["", "lemma sum_in_Rats [intro]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow> sum f A \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow>\n    sum f A \\<in> \\<rat>", "by (induction A rule: infinite_finite_induct) auto"], ["", "(* TODO Move *)"], ["", "lemma (in monoid_mult) prod_list_distinct_conv_prod_set:\n  \"distinct xs \\<Longrightarrow> prod_list (map f xs) = prod f (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> prod_list (map f xs) = prod f (set xs)", "by (induct xs) simp_all"], ["", "lemma (in monoid_mult) interv_prod_list_conv_prod_set_nat:\n  \"prod_list (map f [m..<n]) = prod f (set [m..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map f [m..<n]) = prod f (set [m..<n])", "by (simp add: prod_list_distinct_conv_prod_set)"], ["", "lemma (in monoid_mult) prod_list_prod_nth:\n  \"prod_list xs = (\\<Prod>i = 0..< length xs. xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "using interv_prod_list_conv_prod_set_nat [of \"(!) xs\" 0 \"length xs\"]"], ["proof (prove)\nusing this:\n  prod_list (map ((!) xs) [0..<length xs]) =\n  prod ((!) xs) (set [0..<length xs])\n\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "by (simp add: map_nth)"], ["", "lemma gcd_poly_code_aux_reduce:\n  \"gcd_poly_code_aux p 0 = normalize p\"\n  \"q \\<noteq> 0 \\<Longrightarrow> gcd_poly_code_aux p q = gcd_poly_code_aux q (primitive_part (pseudo_mod p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_poly_code_aux p 0 = normalize p &&&\n    (q \\<noteq> 0 \\<Longrightarrow>\n     gcd_poly_code_aux p q =\n     gcd_poly_code_aux q (primitive_part (pseudo_mod p q)))", "by (subst gcd_poly_code_aux.simps; simp)+"], ["", "lemma coprimeI_primes:\n  fixes a b :: \"'a :: factorial_semiring\"\n  assumes \"a \\<noteq> 0 \\<or> b \\<noteq> 0\"\n  assumes \"\\<And>p. prime p \\<Longrightarrow> p dvd a \\<Longrightarrow> p dvd b \\<Longrightarrow> False\"\n  shows   \"coprime a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime a b", "proof (rule coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "assume d: \"d dvd a\" \"d dvd b\""], ["proof (state)\nthis:\n  d dvd a\n  d dvd b\n\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "with assms(1)"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a) \\<or> b \\<noteq> (0::'a)\n  d dvd a\n  d dvd b", "have [simp]: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> b \\<noteq> (0::'a)\n  d dvd a\n  d dvd b\n\ngoal (1 subgoal):\n 1. d \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd a; c dvd b\\<rbrakk> \\<Longrightarrow> is_unit c", "show \"is_unit d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "assume \"\\<not>is_unit d\""], ["proof (state)\nthis:\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> is_unit d", "obtain p where p: \"prime p\" \"p dvd d\""], ["proof (prove)\nusing this:\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_divisor_exists[of d]"], ["proof (prove)\nusing this:\n  \\<not> is_unit d\n  \\<lbrakk>d \\<noteq> (0::'a); \\<not> is_unit d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. b dvd d \\<and> prime b\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prime p\n  p dvd d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "from assms(2)[of p] and p and d"], ["proof (chain)\npicking this:\n  \\<lbrakk>prime p; p dvd a; p dvd b\\<rbrakk> \\<Longrightarrow> False\n  prime p\n  p dvd d\n  d dvd a\n  d dvd b", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; p dvd a; p dvd b\\<rbrakk> \\<Longrightarrow> False\n  prime p\n  p dvd d\n  d dvd a\n  d dvd b\n\ngoal (1 subgoal):\n 1. False", "using dvd_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; p dvd a; p dvd b\\<rbrakk> \\<Longrightarrow> False\n  prime p\n  p dvd d\n  d dvd a\n  d dvd b\n  \\<lbrakk>?a dvd ?b; ?b dvd ?c\\<rbrakk> \\<Longrightarrow> ?a dvd ?c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_pderiv_imp_squarefree:\n  assumes \"coprime p (pderiv p)\"\n  shows   \"squarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree p", "proof (rule squarefreeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "assume d: \"d ^ 2 dvd p\""], ["proof (state)\nthis:\n  d\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "then"], ["proof (chain)\npicking this:\n  d\\<^sup>2 dvd p", "obtain q where q: \"p = d ^ 2 * q\""], ["proof (prove)\nusing this:\n  d\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = d\\<^sup>2 * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = d\\<^sup>2 * q\n\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "hence \"d dvd p\" \"d dvd pderiv p\""], ["proof (prove)\nusing this:\n  p = d\\<^sup>2 * q\n\ngoal (1 subgoal):\n 1. d dvd p &&& d dvd pderiv p", "by (auto simp: pderiv_mult pderiv_power_Suc numeral_2_eq_2)"], ["proof (state)\nthis:\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> is_unit x", "with assms"], ["proof (chain)\npicking this:\n  coprime p (pderiv p)\n  d dvd p\n  d dvd pderiv p", "show \"is_unit d\""], ["proof (prove)\nusing this:\n  coprime p (pderiv p)\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. is_unit d", "using not_coprimeI"], ["proof (prove)\nusing this:\n  coprime p (pderiv p)\n  d dvd p\n  d dvd pderiv p\n  \\<lbrakk>?c dvd ?a; ?c dvd ?b; \\<not> is_unit ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> coprime ?a ?b\n\ngoal (1 subgoal):\n 1. is_unit d", "by blast"], ["proof (state)\nthis:\n  is_unit d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squarefree_field_poly_iff:\n  fixes p :: \"'a :: {field_char_0,euclidean_ring_gcd,semiring_gcd_mult_normalize} poly\"\n  assumes [simp]: \"p \\<noteq> 0\"\n  shows \"squarefree p \\<longleftrightarrow> coprime p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree p = coprime p (pderiv p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. squarefree p \\<Longrightarrow> coprime p (pderiv p)\n 2. coprime p (pderiv p) \\<Longrightarrow> squarefree p", "assume \"squarefree p\""], ["proof (state)\nthis:\n  squarefree p\n\ngoal (2 subgoals):\n 1. squarefree p \\<Longrightarrow> coprime p (pderiv p)\n 2. coprime p (pderiv p) \\<Longrightarrow> squarefree p", "show \"coprime p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime p (pderiv p)", "proof (rule coprimeI_primes)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "assume d: \"d dvd p\" \"d dvd pderiv p\" \"prime d\""], ["proof (state)\nthis:\n  d dvd p\n  d dvd pderiv p\n  prime d\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "from d(1)"], ["proof (chain)\npicking this:\n  d dvd p", "obtain q where q: \"p = d * q\""], ["proof (prove)\nusing this:\n  d dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = d * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = d * q\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "from d(2) and q"], ["proof (chain)\npicking this:\n  d dvd pderiv p\n  p = d * q", "have \"d dvd q * pderiv d\""], ["proof (prove)\nusing this:\n  d dvd pderiv p\n  p = d * q\n\ngoal (1 subgoal):\n 1. d dvd q * pderiv d", "by (simp add: pderiv_mult dvd_add_right_iff)"], ["proof (state)\nthis:\n  d dvd q * pderiv d\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>prime d\\<close>"], ["proof (chain)\npicking this:\n  prime d\n  d dvd q * pderiv d", "have \"d dvd q \\<or> d dvd pderiv d\""], ["proof (prove)\nusing this:\n  prime d\n  d dvd q * pderiv d\n\ngoal (1 subgoal):\n 1. d dvd q \\<or> d dvd pderiv d", "using prime_dvd_mult_iff"], ["proof (prove)\nusing this:\n  prime d\n  d dvd q * pderiv d\n  prime ?p \\<Longrightarrow> (?p dvd ?a * ?b) = (?p dvd ?a \\<or> ?p dvd ?b)\n\ngoal (1 subgoal):\n 1. d dvd q \\<or> d dvd pderiv d", "by blast"], ["proof (state)\nthis:\n  d dvd q \\<or> d dvd pderiv d\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  d dvd q \\<or> d dvd pderiv d\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. d dvd q \\<Longrightarrow> False\n 2. d dvd pderiv d \\<Longrightarrow> False", "assume \"d dvd q\""], ["proof (state)\nthis:\n  d dvd q\n\ngoal (2 subgoals):\n 1. d dvd q \\<Longrightarrow> False\n 2. d dvd pderiv d \\<Longrightarrow> False", "hence \"d ^ 2 dvd p\""], ["proof (prove)\nusing this:\n  d dvd q\n\ngoal (1 subgoal):\n 1. d\\<^sup>2 dvd p", "by (auto simp: q power2_eq_square)"], ["proof (state)\nthis:\n  d\\<^sup>2 dvd p\n\ngoal (2 subgoals):\n 1. d dvd q \\<Longrightarrow> False\n 2. d dvd pderiv d \\<Longrightarrow> False", "with \\<open>squarefree p\\<close>"], ["proof (chain)\npicking this:\n  squarefree p\n  d\\<^sup>2 dvd p", "show False"], ["proof (prove)\nusing this:\n  squarefree p\n  d\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. False", "using d(3) not_prime_unit squarefreeD"], ["proof (prove)\nusing this:\n  squarefree p\n  d\\<^sup>2 dvd p\n  prime d\n  is_unit ?x \\<Longrightarrow> \\<not> prime ?x\n  \\<lbrakk>squarefree ?n; ?x\\<^sup>2 dvd ?n\\<rbrakk>\n  \\<Longrightarrow> ?x dvd (1::?'a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "assume \"d dvd pderiv d\""], ["proof (state)\nthis:\n  d dvd pderiv d\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "hence \"Polynomial.degree d = 0\""], ["proof (prove)\nusing this:\n  d dvd pderiv d\n\ngoal (1 subgoal):\n 1. Polynomial.degree d = 0", "by simp"], ["proof (state)\nthis:\n  Polynomial.degree d = 0\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Polynomial.degree d = 0\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "have \"d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "using d"], ["proof (prove)\nusing this:\n  d dvd p\n  d dvd pderiv p\n  prime d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Polynomial.degree d = 0\n  d \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  Polynomial.degree d = 0\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using d(3) is_unit_iff_degree not_prime_unit"], ["proof (prove)\nusing this:\n  Polynomial.degree d = 0\n  d \\<noteq> 0\n  prime d\n  ?p \\<noteq> 0 \\<Longrightarrow> is_unit ?p = (Polynomial.degree ?p = 0)\n  is_unit ?x \\<Longrightarrow> \\<not> prime ?x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0", "qed auto"], ["proof (state)\nthis:\n  coprime p (pderiv p)\n\ngoal (1 subgoal):\n 1. coprime p (pderiv p) \\<Longrightarrow> squarefree p", "qed (use coprime_pderiv_imp_squarefree[of p] in auto)"], ["", "lemma coprime_pderiv_imp_rsquarefree:\n  assumes \"coprime (p :: 'a :: field_char_0 poly) (pderiv p)\"\n  shows   \"rsquarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree p", "unfolding rsquarefree_roots"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       \\<not> (poly p a = (0::'a) \\<and> poly (pderiv p) a = (0::'a))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p a = (0::'a); poly (pderiv p) a = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p a = (0::'a); poly (pderiv p) a = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"poly p x = 0\" \"poly (pderiv p) x = 0\""], ["proof (state)\nthis:\n  poly p x = (0::'a)\n  poly (pderiv p) x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p a = (0::'a); poly (pderiv p) a = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"[:-x, 1:] dvd p\" \"[:-x, 1:] dvd pderiv p\""], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n  poly (pderiv p) x = (0::'a)\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd p &&& [:- x, 1::'a:] dvd pderiv p", "by (auto simp: poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd p\n  [:- x, 1::'a:] dvd pderiv p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p a = (0::'a); poly (pderiv p) a = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  coprime p (pderiv p)\n  [:- x, 1::'a:] dvd p\n  [:- x, 1::'a:] dvd pderiv p", "have \"is_unit [:-x, 1:]\""], ["proof (prove)\nusing this:\n  coprime p (pderiv p)\n  [:- x, 1::'a:] dvd p\n  [:- x, 1::'a:] dvd pderiv p\n\ngoal (1 subgoal):\n 1. is_unit [:- x, 1::'a:]", "using not_coprimeI"], ["proof (prove)\nusing this:\n  coprime p (pderiv p)\n  [:- x, 1::'a:] dvd p\n  [:- x, 1::'a:] dvd pderiv p\n  \\<lbrakk>?c dvd ?a; ?c dvd ?b; \\<not> is_unit ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> coprime ?a ?b\n\ngoal (1 subgoal):\n 1. is_unit [:- x, 1::'a:]", "by blast"], ["proof (state)\nthis:\n  is_unit [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>poly p a = (0::'a); poly (pderiv p) a = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  is_unit [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_of_nat [simp]: \"poly (of_nat n) x = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_nat n) x = of_nat n", "by (induction n) auto"], ["", "lemma poly_of_int [simp]: \"poly (of_int n) x = of_int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int n) x = of_int n", "by (cases n) auto"], ["", "lemma order_eq_0_iff: \"p \\<noteq> 0 \\<Longrightarrow> order x p = 0 \\<longleftrightarrow> poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (order x p = 0) = (poly p x \\<noteq> (0::'a))", "by (auto simp: order_root)"], ["", "lemma order_pos_iff: \"p \\<noteq> 0 \\<Longrightarrow> order x p > 0 \\<longleftrightarrow> poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> (0 < order x p) = (poly p x = (0::'a))", "by (auto simp: order_root)"], ["", "lemma order_prod:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\"\n  shows   \"order x (\\<Prod>y\\<in>A. f y) = (\\<Sum>y\\<in>A. order x (f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (prod f A) = (\\<Sum>y\\<in>A. order x (f y))", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order x (prod f A) = (\\<Sum>y\\<in>A. order x (f y))", "by (induction A rule: infinite_finite_induct) (auto simp: order_mult)"], ["", "lemma order_prod_mset:\n  assumes \"0 \\<notin># A\"\n  shows   \"order x (prod_mset A) = sum_mset (image_mset (order x) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (\\<Prod>\\<^sub># A) = \\<Sum>\\<^sub># (image_mset (order x) A)", "using assms"], ["proof (prove)\nusing this:\n  0 \\<notin># A\n\ngoal (1 subgoal):\n 1. order x (\\<Prod>\\<^sub># A) = \\<Sum>\\<^sub># (image_mset (order x) A)", "by (induction A) (auto simp: order_mult)"], ["", "lemma order_prod_list:\n  assumes \"0 \\<notin> set xs\"\n  shows   \"order x (prod_list xs) = sum_list (map (order x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x (prod_list xs) = sum_list (map (order x) xs)", "using assms"], ["proof (prove)\nusing this:\n  0 \\<notin> set xs\n\ngoal (1 subgoal):\n 1. order x (prod_list xs) = sum_list (map (order x) xs)", "by (induction xs) (auto simp: order_mult)"], ["", "lemma order_power: \"p \\<noteq> 0 \\<Longrightarrow> order x (p ^ n) = n * order x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> order x (p ^ n) = n * order x p", "by (induction n) (auto simp: order_mult)"], ["", "lemma smult_0_right [simp]: \"MPoly_Type.smult p 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.smult p 0 = 0", "by (transfer, transfer) auto"], ["", "lemma mult_smult_right [simp]: \n  fixes c :: \"'a :: comm_semiring_0\"\n  shows \"p * MPoly_Type.smult c q = MPoly_Type.smult c (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * MPoly_Type.smult c q = MPoly_Type.smult c (p * q)", "by (simp add: smult_conv_mult mult_ac)"], ["", "lemma mapping_single_eq_iff [simp]:\n  \"Poly_Mapping.single a b = Poly_Mapping.single c d \\<longleftrightarrow> b = 0 \\<and> d = 0 \\<or> a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Poly_Mapping.single a b = Poly_Mapping.single c d) =\n    (b = (0::'b) \\<and> d = (0::'b) \\<or> a = c \\<and> b = d)", "by transfer (unfold fun_eq_iff when_def, metis)"], ["", "lemma monom_of_set_plus_monom_of_set:\n  assumes \"A \\<inter> B = {}\" \"finite A\" \"finite B\"\n  shows   \"monom_of_set A + monom_of_set B = monom_of_set (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_of_set A + monom_of_set B = monom_of_set (A \\<union> B)", "using assms"], ["proof (prove)\nusing this:\n  A \\<inter> B = {}\n  finite A\n  finite B\n\ngoal (1 subgoal):\n 1. monom_of_set A + monom_of_set B = monom_of_set (A \\<union> B)", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma mpoly_monom_0_eq_Const: \"monom 0 c = Const c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom 0 c = Const c", "by (intro mpoly_eqI) (auto simp: coeff_monom when_def mpoly_coeff_Const)"], ["", "lemma mpoly_Const_0 [simp]: \"Const 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (0::'a) = 0", "by (intro mpoly_eqI) (auto simp: mpoly_coeff_Const mpoly_coeff_0)"], ["", "lemma mpoly_Const_1 [simp]: \"Const 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (1::'a) = 1", "by (intro mpoly_eqI) (auto simp: mpoly_coeff_Const mpoly_coeff_1)"], ["", "lemma mpoly_Const_uminus: \"Const (-a) = -Const a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (- a) = - Const a", "by (intro mpoly_eqI) (auto simp: mpoly_coeff_Const)"], ["", "lemma mpoly_Const_add: \"Const (a + b) = Const a + Const b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (a + b) = Const a + Const b", "by (intro mpoly_eqI) (auto simp: mpoly_coeff_Const)"], ["", "lemma mpoly_Const_mult: \"Const (a * b) = Const a * Const b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (a * b) = Const a * Const b", "unfolding mpoly_monom_0_eq_Const [symmetric] mult_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom 0 (a * b) = MPoly_Type.monom (0 + 0) (a * b)", "by simp"], ["", "lemma mpoly_Const_power: \"Const (a ^ n) = Const a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (a ^ n) = Const a ^ n", "by (induction n) (auto simp: mpoly_Const_mult)"], ["", "lemma of_nat_mpoly_eq: \"of_nat n = Const (of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n = Const (of_nat n)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. of_nat 0 = Const (of_nat 0)\n 2. \\<And>n.\n       of_nat n = Const (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = Const (of_nat (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. of_nat 0 = Const (of_nat 0)\n 2. \\<And>n.\n       of_nat n = Const (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = Const (of_nat (Suc n))", "have \"0 = (Const 0 :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Const (0::'a)", "by (intro mpoly_eqI) (auto simp: mpoly_coeff_Const)"], ["proof (state)\nthis:\n  0 = Const (0::'a)\n\ngoal (2 subgoals):\n 1. of_nat 0 = Const (of_nat 0)\n 2. \\<And>n.\n       of_nat n = Const (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = Const (of_nat (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  0 = Const (0::'a)\n\ngoal (1 subgoal):\n 1. of_nat 0 = Const (of_nat 0)", "by simp"], ["proof (state)\nthis:\n  of_nat 0 = Const (of_nat 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = Const (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = Const (of_nat (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = Const (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = Const (of_nat (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  of_nat n = Const (of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = Const (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = Const (of_nat (Suc n))", "have \"1 + Const (of_nat n) = Const (1 + of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + Const (of_nat n) = Const ((1::'b) + of_nat n)", "by (intro mpoly_eqI) (auto simp: mpoly_coeff_Const mpoly_coeff_1)"], ["proof (state)\nthis:\n  1 + Const (of_nat n) = Const ((1::?'b1) + of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       of_nat n = Const (of_nat n) \\<Longrightarrow>\n       of_nat (Suc n) = Const (of_nat (Suc n))", "thus ?case"], ["proof (prove)\nusing this:\n  1 + Const (of_nat n) = Const ((1::?'b1) + of_nat n)\n\ngoal (1 subgoal):\n 1. of_nat (Suc n) = Const (of_nat (Suc n))", "using Suc"], ["proof (prove)\nusing this:\n  1 + Const (of_nat n) = Const ((1::?'b1) + of_nat n)\n  of_nat n = Const (of_nat n)\n\ngoal (1 subgoal):\n 1. of_nat (Suc n) = Const (of_nat (Suc n))", "by auto"], ["proof (state)\nthis:\n  of_nat (Suc n) = Const (of_nat (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_of_nat [simp]: \"insertion f (of_nat n) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (of_nat n) = of_nat n", "by (simp add: of_nat_mpoly_eq)"], ["", "lemma insertion_monom_of_set [simp]:\n  \"insertion f (monom (monom_of_set X) c) = c * (\\<Prod>i\\<in>X. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "proof (cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n 2. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "case [simp]: True"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n 2. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "have \"insertion f (monom (monom_of_set X) c) = c * (\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom (monom_of_set X) c) =\n    c * (\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0))", "by (auto simp: lookup_monom_of_set)"], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom (monom_of_set X) c) =\n  c * (\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0))\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n 2. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "also"], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom (monom_of_set X) c) =\n  c * (\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0))\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n 2. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "have \"(\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0)) = (\\<Prod>i\\<in>X. f i ^ (if i \\<in> X then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0)) =\n    (\\<Prod>i\\<in>X. f i ^ (if i \\<in> X then 1 else 0))", "by (intro Prod_any.expand_superset) auto"], ["proof (state)\nthis:\n  (\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0)) =\n  (\\<Prod>i\\<in>X. f i ^ (if i \\<in> X then 1 else 0))\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n 2. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "also"], ["proof (state)\nthis:\n  (\\<Prod>a. f a ^ (if a \\<in> X then 1 else 0)) =\n  (\\<Prod>i\\<in>X. f i ^ (if i \\<in> X then 1 else 0))\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n 2. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "have \"\\<dots> = (\\<Prod>i\\<in>X. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>X. f i ^ (if i \\<in> X then 1 else 0)) = prod f X", "by (intro prod.cong) auto"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>X. f i ^ (if i \\<in> X then 1 else 0)) = prod f X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n 2. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "finally"], ["proof (chain)\npicking this:\n  insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "."], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow>\n    insertion f (MPoly_Type.monom (monom_of_set X) c) = c * prod f X", "qed (auto simp: lookup_monom_of_set)"], ["", "(* TODO: Move! Version in AFP is too weak! *)"], ["", "lemma symmetric_mpoly_symmetric_sum:\n  assumes \"\\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> g \\<pi> permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g \\<pi> x)\"\n  shows \"symmetric_mpoly A (\\<Sum>x\\<in>X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (sum f X)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"mpoly_map_vars \\<pi> (sum f X) = (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (sum f X) =\n    (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) =\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) =\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"\\<dots> = (\\<Sum>x\\<in>X. f (g \\<pi> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n    (\\<Sum>x\\<in>X. f (g \\<pi> x))", "by (intro sum.cong assms \\<pi> refl)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n  (\\<Sum>x\\<in>X. f (g \\<pi> x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n  (\\<Sum>x\\<in>X. f (g \\<pi> x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"\\<dots> = (\\<Sum>x\\<in>g \\<pi>`X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)", "using assms(1)[OF \\<pi>]"], ["proof (prove)\nusing this:\n  g \\<pi> permutes X\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)", "by (subst sum.reindex) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"g \\<pi> ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<pi> ` X = X", "using assms(1)[OF \\<pi>]"], ["proof (prove)\nusing this:\n  g \\<pi> permutes X\n\ngoal (1 subgoal):\n 1. g \\<pi> ` X = X", "by (simp add: permutes_image)"], ["proof (state)\nthis:\n  g \\<pi> ` X = X\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X", "show \"mpoly_map_vars \\<pi> (sum f X) = sum f X\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (sum f X) = sum f X", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_mpoly_0 [simp]:\n  assumes \"finite A\"\n  shows   \"sym_mpoly A 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym_mpoly A 0 = 1", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. sym_mpoly A 0 = 1", "by (transfer, transfer) (auto simp: fun_eq_iff when_def)"], ["", "lemma sym_mpoly_eq_0 [simp]:\n  assumes \"k > card A\"\n  shows   \"sym_mpoly A k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym_mpoly A k = 0", "proof (transfer fixing: A k, transfer fixing: A k, intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       (if finite A \\<and>\n           (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y)\n        then 1::'a else (0::'a)) =\n       (0::'a)", "fix mon"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       (if finite A \\<and>\n           (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y)\n        then 1::'a else (0::'a)) =\n       (0::'a)", "have \"\\<not>(finite A \\<and> (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (finite A \\<and>\n            (\\<exists>Y\\<subseteq>A.\n                card Y = k \\<and> mon = monom_of_set Y))", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>finite A; Y \\<subseteq> A; mon = monom_of_set Y;\n        k = card Y\\<rbrakk>\n       \\<Longrightarrow> False", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>finite A; Y \\<subseteq> A; mon = monom_of_set Y;\n        k = card Y\\<rbrakk>\n       \\<Longrightarrow> False", "assume Y: \"finite A\" \"Y \\<subseteq> A\" \"k = card Y\" \"mon = monom_of_set Y\""], ["proof (state)\nthis:\n  finite A\n  Y \\<subseteq> A\n  k = card Y\n  mon = monom_of_set Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>finite A; Y \\<subseteq> A; mon = monom_of_set Y;\n        k = card Y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"card Y \\<le> card A\""], ["proof (prove)\nusing this:\n  finite A\n  Y \\<subseteq> A\n  k = card Y\n  mon = monom_of_set Y\n\ngoal (1 subgoal):\n 1. card Y \\<le> card A", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card Y \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>finite A; Y \\<subseteq> A; mon = monom_of_set Y;\n        k = card Y\\<rbrakk>\n       \\<Longrightarrow> False", "with Y and assms"], ["proof (chain)\npicking this:\n  finite A\n  Y \\<subseteq> A\n  k = card Y\n  mon = monom_of_set Y\n  card A < k\n  card Y \\<le> card A", "show False"], ["proof (prove)\nusing this:\n  finite A\n  Y \\<subseteq> A\n  k = card Y\n  mon = monom_of_set Y\n  card A < k\n  card Y \\<le> card A\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (finite A \\<and>\n          (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y))\n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       (if finite A \\<and>\n           (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y)\n        then 1::'a else (0::'a)) =\n       (0::'a)", "thus \"(if finite A \\<and> (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y) then 1 else 0) = 0\""], ["proof (prove)\nusing this:\n  \\<not> (finite A \\<and>\n          (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y))\n\ngoal (1 subgoal):\n 1. (if finite A \\<and>\n        (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y)\n     then 1::'b else (0::'b)) =\n    (0::'b)", "by auto"], ["proof (state)\nthis:\n  (if finite A \\<and>\n      (\\<exists>Y\\<subseteq>A. card Y = k \\<and> mon = monom_of_set Y)\n   then 1::?'b1 else (0::?'b1)) =\n  (0::?'b1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_sym_mpoly_monom_of_set_eq_0:\n  assumes \"finite X\" \"Y \\<subseteq> X\" \"card Y \\<noteq> k\"\n  shows   \"MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = (0::'a)", "using assms finite_subset[of _ X]"], ["proof (prove)\nusing this:\n  finite X\n  Y \\<subseteq> X\n  card Y \\<noteq> k\n  \\<lbrakk>?A \\<subseteq> X; finite X\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = (0::'a)", "by (auto simp: coeff_sym_mpoly)"], ["", "lemma coeff_sym_mpoly_monom_of_set_eq_0':\n  assumes \"finite X\" \"\\<not>Y \\<subseteq> X\" \"finite Y\"\n  shows   \"MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = (0::'a)", "using assms finite_subset[of _ X]"], ["proof (prove)\nusing this:\n  finite X\n  \\<not> Y \\<subseteq> X\n  finite Y\n  \\<lbrakk>?A \\<subseteq> X; finite X\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = (0::'a)", "by (auto simp: coeff_sym_mpoly)"], ["", "subsection \\<open>The set of roots of a univariate polynomial\\<close>"], ["", "lift_definition poly_roots :: \"'a :: idom poly \\<Rightarrow> 'a multiset\" is\n  \"\\<lambda>p x. if p = 0 then 0 else order x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>poly.\n       (\\<lambda>x. if poly = 0 then 0 else order x poly) \\<in> multiset", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>poly.\n       (\\<lambda>x. if poly = 0 then 0 else order x poly) \\<in> multiset", "fix p :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>poly.\n       (\\<lambda>x. if poly = 0 then 0 else order x poly) \\<in> multiset", "show \"(\\<lambda>x. if p = 0 then 0 else order x p) \\<in> multiset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if p = 0 then 0 else order x p) \\<in> multiset", "by (cases \"p = 0\") (auto simp: multiset_def order_pos_iff poly_roots_finite)"], ["proof (state)\nthis:\n  (\\<lambda>x. if p = 0 then 0 else order x p) \\<in> multiset\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_roots_0 [simp]: \"poly_roots 0 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots 0 = {#}", "by transfer auto"], ["", "lemma poly_roots_1 [simp]: \"poly_roots 1 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots 1 = {#}", "by transfer auto"], ["", "lemma count_poly_roots [simp]:\n  assumes \"p \\<noteq> 0\"\n  shows   \"count (poly_roots p) x = order x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (poly_roots p) x = order x p", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count (poly_roots p) x = order x p", "by transfer auto"], ["", "lemma in_poly_roots_iff [simp]: \"p \\<noteq> 0 \\<Longrightarrow> x \\<in># poly_roots p \\<longleftrightarrow> poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (x \\<in># poly_roots p) = (poly p x = (0::'a))", "by (subst count_greater_zero_iff [symmetric], subst count_poly_roots) (auto simp: order_pos_iff)"], ["", "lemma set_mset_poly_roots: \"p \\<noteq> 0 \\<Longrightarrow> set_mset (poly_roots p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set_mset (poly_roots p) = {x. poly p x = (0::'a)}", "using in_poly_roots_iff[of p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  (?x \\<in># poly_roots p) = (poly p ?x = (0::'a))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set_mset (poly_roots p) = {x. poly p x = (0::'a)}", "by blast"], ["", "lemma count_poly_roots': \"count (poly_roots p) x = (if p = 0 then 0 else order x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (poly_roots p) x = (if p = 0 then 0 else order x p)", "by transfer' auto"], ["", "lemma poly_roots_const [simp]: \"poly_roots [:c:] = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots [:c:] = {#}", "by (intro multiset_eqI) (auto simp: count_poly_roots' order_eq_0_iff)"], ["", "lemma poly_roots_linear [simp]: \"poly_roots [:-x, 1:] = {#x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots [:- x, 1::'a:] = {#x#}", "by (intro multiset_eqI) (auto simp: count_poly_roots' order_eq_0_iff)"], ["", "lemma poly_roots_monom [simp]: \"c \\<noteq> 0 \\<Longrightarrow> poly_roots (Polynomial.monom c n) = replicate_mset n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    poly_roots (Polynomial.monom c n) = replicate_mset n (0::'a)", "by (intro multiset_eqI) (auto simp: count_poly_roots' order_eq_0_iff poly_monom)"], ["", "lemma poly_roots_smult [simp]: \"c \\<noteq> 0 \\<Longrightarrow> poly_roots (Polynomial.smult c p) = poly_roots p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    poly_roots (Polynomial.smult c p) = poly_roots p", "by (intro multiset_eqI) (auto simp: count_poly_roots' order_smult)"], ["", "lemma poly_roots_mult: \"p \\<noteq> 0 \\<Longrightarrow> q \\<noteq> 0 \\<Longrightarrow> poly_roots (p * q) = poly_roots p + poly_roots q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> poly_roots (p * q) = poly_roots p + poly_roots q", "by (intro multiset_eqI) (auto simp: count_poly_roots' order_mult)"], ["", "lemma poly_roots_prod:\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0\"\n  shows   \"poly_roots (prod f A) = (\\<Sum>x\\<in>A. poly_roots (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (prod f A) = (\\<Sum>x\\<in>A. poly_roots (f x))", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_roots (prod f A) = (\\<Sum>x\\<in>A. poly_roots (f x))", "by (induction A rule: infinite_finite_induct) (auto simp: poly_roots_mult)"], ["", "lemma poly_roots_prod_mset:\n  assumes \"0 \\<notin># A\"\n  shows   \"poly_roots (prod_mset A) = sum_mset (image_mset poly_roots A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (\\<Prod>\\<^sub># A) =\n    \\<Sum>\\<^sub># (image_mset poly_roots A)", "using assms"], ["proof (prove)\nusing this:\n  0 \\<notin># A\n\ngoal (1 subgoal):\n 1. poly_roots (\\<Prod>\\<^sub># A) =\n    \\<Sum>\\<^sub># (image_mset poly_roots A)", "by (induction A) (auto simp: poly_roots_mult)"], ["", "lemma poly_roots_prod_list:\n  assumes \"0 \\<notin> set xs\"\n  shows   \"poly_roots (prod_list xs) = sum_list (map poly_roots xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (prod_list xs) = sum_list (map poly_roots xs)", "using assms"], ["proof (prove)\nusing this:\n  0 \\<notin> set xs\n\ngoal (1 subgoal):\n 1. poly_roots (prod_list xs) = sum_list (map poly_roots xs)", "by (induction xs) (auto simp: poly_roots_mult)"], ["", "lemma poly_roots_power: \"p \\<noteq> 0 \\<Longrightarrow> poly_roots (p ^ n) = repeat_mset n (poly_roots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "by (induction n) (auto simp: poly_roots_mult)"], ["", "lemma rsquarefree_poly_roots_eq:\n  assumes \"rsquarefree p\"\n  shows   \"poly_roots p = mset_set {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots p = mset_set {x. poly p x = (0::'a)}", "proof (rule multiset_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       count (poly_roots p) x = count (mset_set {x. poly p x = (0::'a)}) x", "fix x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       count (poly_roots p) x = count (mset_set {x. poly p x = (0::'a)}) x", "from assms"], ["proof (chain)\npicking this:\n  rsquarefree p", "show \"count (poly_roots p) x = count (mset_set {x. poly p x = 0}) x\""], ["proof (prove)\nusing this:\n  rsquarefree p\n\ngoal (1 subgoal):\n 1. count (poly_roots p) x = count (mset_set {x. poly p x = (0::'a)}) x", "by (cases \"poly p x = 0\") (auto simp: poly_roots_finite order_eq_0_iff rsquarefree_def)"], ["proof (state)\nthis:\n  count (poly_roots p) x = count (mset_set {x. poly p x = (0::'a)}) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsquarefree_imp_distinct_roots:\n  assumes \"rsquarefree p\" and \"mset xs = poly_roots p\"\n  shows   \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> distinct xs\n 2. p \\<noteq> 0 \\<Longrightarrow> distinct xs", "case [simp]: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> distinct xs\n 2. p \\<noteq> 0 \\<Longrightarrow> distinct xs", "have *: \"mset xs = mset_set {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset_set {x. poly p x = (0::'a)}", "using assms"], ["proof (prove)\nusing this:\n  rsquarefree p\n  mset xs = poly_roots p\n\ngoal (1 subgoal):\n 1. mset xs = mset_set {x. poly p x = (0::'a)}", "by (simp add: rsquarefree_poly_roots_eq)"], ["proof (state)\nthis:\n  mset xs = mset_set {x. poly p x = (0::'a)}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> distinct xs\n 2. p \\<noteq> 0 \\<Longrightarrow> distinct xs", "hence \"set_mset (mset xs) = set_mset (mset_set {x. poly p x = 0})\""], ["proof (prove)\nusing this:\n  mset xs = mset_set {x. poly p x = (0::'a)}\n\ngoal (1 subgoal):\n 1. set_mset (mset xs) = set_mset (mset_set {x. poly p x = (0::'a)})", "by (simp only: )"], ["proof (state)\nthis:\n  set_mset (mset xs) = set_mset (mset_set {x. poly p x = (0::'a)})\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> distinct xs\n 2. p \\<noteq> 0 \\<Longrightarrow> distinct xs", "hence [simp]: \"set xs = {x. poly p x = 0}\""], ["proof (prove)\nusing this:\n  set_mset (mset xs) = set_mset (mset_set {x. poly p x = (0::'a)})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = (0::'a)}", "by (simp add: poly_roots_finite)"], ["proof (state)\nthis:\n  set xs = {x. poly p x = (0::'a)}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> distinct xs\n 2. p \\<noteq> 0 \\<Longrightarrow> distinct xs", "from *"], ["proof (chain)\npicking this:\n  mset xs = mset_set {x. poly p x = (0::'a)}", "show ?thesis"], ["proof (prove)\nusing this:\n  mset xs = mset_set {x. poly p x = (0::'a)}\n\ngoal (1 subgoal):\n 1. distinct xs", "by (subst distinct_count_atmost_1) (auto simp: poly_roots_finite)"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> distinct xs", "qed (use assms in auto)"], ["", "lemma poly_roots_factorization:\n  fixes p c A\n  assumes [simp]: \"c \\<noteq> 0\"\n  defines \"p \\<equiv> Polynomial.smult c (prod_mset (image_mset (\\<lambda>x. [:-x, 1:]) A))\"\n  shows   \"poly_roots p = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots p = A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_roots p = A", "have \"poly_roots p = poly_roots (\\<Prod>x\\<in>#A. [:-x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots p = poly_roots (\\<Prod>x\\<in>#A. [:- x, 1::'a:])", "by (auto simp: p_def)"], ["proof (state)\nthis:\n  poly_roots p = poly_roots (\\<Prod>x\\<in>#A. [:- x, 1::'a:])\n\ngoal (1 subgoal):\n 1. poly_roots p = A", "also"], ["proof (state)\nthis:\n  poly_roots p = poly_roots (\\<Prod>x\\<in>#A. [:- x, 1::'a:])\n\ngoal (1 subgoal):\n 1. poly_roots p = A", "have \"\\<dots> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (\\<Prod>x\\<in>#A. [:- x, 1::'a:]) = A", "by (subst poly_roots_prod_mset) (auto simp: image_mset.compositionality o_def)"], ["proof (state)\nthis:\n  poly_roots (\\<Prod>x\\<in>#A. [:- x, 1::'a:]) = A\n\ngoal (1 subgoal):\n 1. poly_roots p = A", "finally"], ["proof (chain)\npicking this:\n  poly_roots p = A", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_roots p = A\n\ngoal (1 subgoal):\n 1. poly_roots p = A", "."], ["proof (state)\nthis:\n  poly_roots p = A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fundamental_theorem_algebra_factorized':\n  fixes p :: \"complex poly\"\n  shows \"p = Polynomial.smult (Polynomial.lead_coeff p) \n               (prod_mset (image_mset (\\<lambda>x. [:-x, 1:]) (poly_roots p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "case [simp]: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "obtain xs where\n    xs: \"Polynomial.smult (Polynomial.lead_coeff p) (\\<Prod>x\\<leftarrow>xs. [:-x, 1:]) = p\"\n        \"length xs = Polynomial.degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>Polynomial.smult (Polynomial.lead_coeff p)\n                  (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) =\n                 p;\n         length xs = Polynomial.degree p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fundamental_theorem_algebra_factorized[of p]"], ["proof (prove)\nusing this:\n  \\<exists>as.\n     Polynomial.smult (Polynomial.lead_coeff p)\n      (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n     p \\<and>\n     length as = Polynomial.degree p\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>Polynomial.smult (Polynomial.lead_coeff p)\n                  (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) =\n                 p;\n         length xs = Polynomial.degree p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) =\n  p\n  length xs = Polynomial.degree p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "define A where \"A = mset xs\""], ["proof (state)\nthis:\n  A = mset xs\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "note xs(1)"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) =\n  p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "also"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) =\n  p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "have \"(\\<Prod>x\\<leftarrow>xs. [:-x, 1:]) = prod_mset (image_mset (\\<lambda>x. [:-x, 1:]) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) = (\\<Prod>x\\<in>#A. [:- x, 1:])", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) =\n    (\\<Prod>x\\<in>#mset xs. [:- x, 1:])", "by (induction xs) auto"], ["proof (state)\nthis:\n  (\\<Prod>x\\<leftarrow>xs. [:- x, 1:]) = (\\<Prod>x\\<in>#A. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult (Polynomial.lead_coeff p) (\\<Prod>x\\<in>#A. [:- x, 1:]) =\n  p", "have *: \"Polynomial.smult (Polynomial.lead_coeff p) (\\<Prod>x\\<in>#A. [:- x, 1:]) = p\""], ["proof (prove)\nusing this:\n  Polynomial.smult (Polynomial.lead_coeff p) (\\<Prod>x\\<in>#A. [:- x, 1:]) =\n  p\n\ngoal (1 subgoal):\n 1. Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#A. [:- x, 1:]) =\n    p", "."], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff p) (\\<Prod>x\\<in>#A. [:- x, 1:]) =\n  p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "also"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff p) (\\<Prod>x\\<in>#A. [:- x, 1:]) =\n  p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "have \"A = poly_roots p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = poly_roots p", "using poly_roots_factorization[of \"Polynomial.lead_coeff p\" A]"], ["proof (prove)\nusing this:\n  Polynomial.lead_coeff p \\<noteq> 0 \\<Longrightarrow>\n  poly_roots\n   (Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#A. [:- x, 1:])) =\n  A\n\ngoal (1 subgoal):\n 1. A = poly_roots p", "by (subst * [symmetric]) auto"], ["proof (state)\nthis:\n  A = poly_roots p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:]) =\n  p", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:]) =\n  p\n\ngoal (1 subgoal):\n 1. p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", ".."], ["proof (state)\nthis:\n  p =\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "qed auto"], ["", "lemma poly_roots_eq_imp_eq:\n  fixes p q :: \"complex poly\"\n  assumes \"Polynomial.lead_coeff p = Polynomial.lead_coeff q\"\n  assumes \"poly_roots p = poly_roots q\"\n  shows   \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (cases \"p = 0 \\<or> q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "hence [simp]: \"p \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "have \"p = Polynomial.smult (Polynomial.lead_coeff p) \n               (prod_mset (image_mset (\\<lambda>x. [:-x, 1:]) (poly_roots p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])", "by (rule fundamental_theorem_algebra_factorized')"], ["proof (state)\nthis:\n  p =\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "also"], ["proof (state)\nthis:\n  p =\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "have \"\\<dots> = Polynomial.smult (Polynomial.lead_coeff q) \n                   (prod_mset (image_mset (\\<lambda>x. [:-x, 1:]) (poly_roots q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (Polynomial.lead_coeff p)\n     (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:]) =\n    Polynomial.smult (Polynomial.lead_coeff q)\n     (\\<Prod>x\\<in>#poly_roots q. [:- x, 1:])", "by (simp add: assms)"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:]) =\n  Polynomial.smult (Polynomial.lead_coeff q)\n   (\\<Prod>x\\<in>#poly_roots q. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "also"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff p)\n   (\\<Prod>x\\<in>#poly_roots p. [:- x, 1:]) =\n  Polynomial.smult (Polynomial.lead_coeff q)\n   (\\<Prod>x\\<in>#poly_roots q. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "have \"\\<dots> = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (Polynomial.lead_coeff q)\n     (\\<Prod>x\\<in>#poly_roots q. [:- x, 1:]) =\n    q", "by (rule fundamental_theorem_algebra_factorized' [symmetric])"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff q)\n   (\\<Prod>x\\<in>#poly_roots q. [:- x, 1:]) =\n  q\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow> p = q", "finally"], ["proof (chain)\npicking this:\n  p = q", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q\n\ngoal (1 subgoal):\n 1. p = q", "."], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow> p = q", "qed (use assms in auto)"], ["", "lemma Sum_any_zeroI': \"(\\<And>x. P x \\<Longrightarrow> f x = 0) \\<Longrightarrow> Sum_any (\\<lambda>x. f x when P x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P x \\<Longrightarrow> f x = (0::'b)) \\<Longrightarrow>\n    (\\<Sum>x. f x when P x) = (0::'b)", "by (auto simp: Sum_any.expand_set)"], ["", "(* TODO: This was not really needed here, but it is important nonetheless.\n   It should go in the Symmetric_Polynomials entry. *)"], ["", "lemma sym_mpoly_insert:\n  assumes \"finite X\" \"x \\<notin> X\"\n  shows   \"(sym_mpoly (insert x X) (Suc k) :: 'a :: semiring_1 mpoly) =\n             monom (monom_of_set {x}) 1 * sym_mpoly X k + sym_mpoly X (Suc k)\" (is \"?lhs = ?A + ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym_mpoly (insert x X) (Suc k) =\n    MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n    sym_mpoly X (Suc k)", "proof (rule mpoly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n       MPoly_Type.coeff\n        (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n         sym_mpoly X (Suc k))\n        mon", "fix mon"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n       MPoly_Type.coeff\n        (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n         sym_mpoly X (Suc k))\n        mon", "show \"coeff ?lhs mon = coeff (?A + ?B) mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "proof (cases \"\\<forall>i. lookup mon i \\<le> 1 \\<and> (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i.\n             lookup mon i \\<le> 1 \\<and>\n             (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0))\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i.\n             lookup mon i \\<le> 1 \\<and>\n             (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0))", "obtain i where i: \"lookup mon i > 1 \\<or> i \\<notin> insert x X \\<and> lookup mon i > 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i.\n             lookup mon i \\<le> 1 \\<and>\n             (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        1 < lookup mon i \\<or>\n        i \\<notin> insert x X \\<and> 0 < lookup mon i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: not_le)"], ["proof (state)\nthis:\n  1 < lookup mon i \\<or> i \\<notin> insert x X \\<and> 0 < lookup mon i\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"coeff ?A mon = prod_fun (coeff (monom (monom_of_set {x}) 1))\n                                  (coeff (sym_mpoly X k)) mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n    prod_fun\n     (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n     (MPoly_Type.coeff (sym_mpoly X k)) mon", "by (simp add: coeff_mpoly_times)"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) mon\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) mon\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"\\<dots> = (\\<Sum>l. \\<Sum>q. coeff (monom (monom_of_set {x}) 1) l * coeff (sym_mpoly X k) q\n                         when mon = l + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun\n     (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n     (MPoly_Type.coeff (sym_mpoly X k)) mon =\n    (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                        (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                       MPoly_Type.coeff (sym_mpoly X k) q when\n                       mon = l + q)", "unfolding prod_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a))\n               l *\n              (\\<Sum>q. MPoly_Type.coeff (sym_mpoly X k) q when\n                        mon = l + q)) =\n    (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                        (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                       MPoly_Type.coeff (sym_mpoly X k) q when\n                       mon = l + q)", "by (intro Sum_any.cong, subst Sum_any_right_distrib, force)\n           (auto simp: Sum_any_right_distrib when_def intro!: Sum_any.cong)"], ["proof (state)\nthis:\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) mon =\n  (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                      (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                     MPoly_Type.coeff (sym_mpoly X k) q when\n                     mon = l + q)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "also"], ["proof (state)\nthis:\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) mon =\n  (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                      (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                     MPoly_Type.coeff (sym_mpoly X k) q when\n                     mon = l + q)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                        (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                       MPoly_Type.coeff (sym_mpoly X k) q when\n                       mon = l + q) =\n    (0::'a)", "proof (rule Sum_any_zeroI, rule Sum_any_zeroI')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa q.\n       mon = xa + q \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) xa *\n       MPoly_Type.coeff (sym_mpoly X k) q =\n       (0::'a)", "fix ma mb"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa q.\n       mon = xa + q \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) xa *\n       MPoly_Type.coeff (sym_mpoly X k) q =\n       (0::'a)", "assume *: \"mon = ma + mb\""], ["proof (state)\nthis:\n  mon = ma + mb\n\ngoal (1 subgoal):\n 1. \\<And>xa q.\n       mon = xa + q \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) xa *\n       MPoly_Type.coeff (sym_mpoly X k) q =\n       (0::'a)", "show \"coeff (monom (monom_of_set {x}) (1::'a)) ma * coeff (sym_mpoly X k) mb = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "proof (cases \"i = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. i \\<noteq> x \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "case [simp]: True"], ["proof (state)\nthis:\n  i = x\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. i \\<noteq> x \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "proof (cases \"lookup mb i > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. \\<not> 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  0 < lookup mb i\n\ngoal (2 subgoals):\n 1. 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. \\<not> 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "hence \"coeff (sym_mpoly X k) mb = 0\""], ["proof (prove)\nusing this:\n  0 < lookup mb i\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) mb = (0::'b)", "using \\<open>x \\<notin> X\\<close>"], ["proof (prove)\nusing this:\n  0 < lookup mb i\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) mb = (0::'b)", "by (auto simp: coeff_sym_mpoly lookup_monom_of_set split: if_splits)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) mb = (0::?'b1)\n\ngoal (2 subgoals):\n 1. 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. \\<not> 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly X k) mb = (0::?'b1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "using mult_not_zero"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly X k) mb = (0::?'b1)\n  ?a * ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  ?a \\<noteq> (0::?'a) \\<and> ?b \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < lookup mb i\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "hence \"coeff (monom (monom_of_set {x}) 1) ma = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < lookup mb i\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'b)) ma =\n    (0::'b)", "using i"], ["proof (prove)\nusing this:\n  \\<not> 0 < lookup mb i\n  1 < lookup mon i \\<or> i \\<notin> insert x X \\<and> 0 < lookup mon i\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'b)) ma =\n    (0::'b)", "by (auto simp: coeff_monom when_def * lookup_add)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::?'b1)) ma =\n  (0::?'b1)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < lookup mb i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::?'b1)) ma =\n  (0::?'b1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "using mult_not_zero"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::?'b1)) ma =\n  (0::?'b1)\n  ?a * ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  ?a \\<noteq> (0::?'a) \\<and> ?b \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<noteq> x \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> x \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "case [simp]: False"], ["proof (state)\nthis:\n  i \\<noteq> x\n\ngoal (1 subgoal):\n 1. i \\<noteq> x \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "proof (cases \"lookup ma i > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. \\<not> 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < lookup ma i\n\ngoal (2 subgoals):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. \\<not> 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "hence \"lookup mb i = lookup mon i\""], ["proof (prove)\nusing this:\n  \\<not> 0 < lookup ma i\n\ngoal (1 subgoal):\n 1. lookup mb i = lookup mon i", "using *"], ["proof (prove)\nusing this:\n  \\<not> 0 < lookup ma i\n  mon = ma + mb\n\ngoal (1 subgoal):\n 1. lookup mb i = lookup mon i", "by (auto simp: lookup_add)"], ["proof (state)\nthis:\n  lookup mb i = lookup mon i\n\ngoal (2 subgoals):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. \\<not> 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "hence \"coeff (sym_mpoly X k) mb = 0\""], ["proof (prove)\nusing this:\n  lookup mb i = lookup mon i\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) mb = (0::'b)", "using i"], ["proof (prove)\nusing this:\n  lookup mb i = lookup mon i\n  1 < lookup mon i \\<or> i \\<notin> insert x X \\<and> 0 < lookup mon i\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) mb = (0::'b)", "by (auto simp: coeff_sym_mpoly lookup_monom_of_set split: if_splits)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) mb = (0::?'b1)\n\ngoal (2 subgoals):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)\n 2. \\<not> 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly X k) mb = (0::?'b1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "using mult_not_zero"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly X k) mb = (0::?'b1)\n  ?a * ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  ?a \\<noteq> (0::?'a) \\<and> ?b \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "case True"], ["proof (state)\nthis:\n  0 < lookup ma i\n\ngoal (1 subgoal):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "hence \"coeff (monom (monom_of_set {x}) 1) ma = 0\""], ["proof (prove)\nusing this:\n  0 < lookup ma i\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'b)) ma =\n    (0::'b)", "using i"], ["proof (prove)\nusing this:\n  0 < lookup ma i\n  1 < lookup mon i \\<or> i \\<notin> insert x X \\<and> 0 < lookup mon i\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'b)) ma =\n    (0::'b)", "by (auto simp: coeff_monom when_def * lookup_add)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::?'b1)) ma =\n  (0::?'b1)\n\ngoal (1 subgoal):\n 1. 0 < lookup ma i \\<Longrightarrow>\n    MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::?'b1)) ma =\n  (0::?'b1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "using mult_not_zero"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::?'b1)) ma =\n  (0::?'b1)\n  ?a * ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  ?a \\<noteq> (0::?'a) \\<and> ?b \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                      (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                     MPoly_Type.coeff (sym_mpoly X k) q when\n                     mon = l + q) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "finally"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)", "have \"coeff ?A mon = 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n    (0::'a)", "."], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "moreover"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "from False"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i.\n             lookup mon i \\<le> 1 \\<and>\n             (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0))", "have \"coeff ?lhs mon = 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i.\n             lookup mon i \\<le> 1 \\<and>\n             (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0))\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon = (0::'a)", "by (subst coeff_sym_mpoly) (auto simp: lookup_monom_of_set split: if_splits)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "moreover"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "from False"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i.\n             lookup mon i \\<le> 1 \\<and>\n             (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0))", "have \"coeff (sym_mpoly X (Suc k)) mon = 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i.\n             lookup mon i \\<le> 1 \\<and>\n             (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0))\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X (Suc k)) mon = (0::'b)", "by (subst coeff_sym_mpoly) (auto simp: lookup_monom_of_set split: if_splits)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X (Suc k)) mon = (0::?'b1)\n\ngoal (2 subgoals):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. \\<not> (\\<forall>i.\n               lookup mon i \\<le> 1 \\<and>\n               (i \\<notin> insert x X \\<longrightarrow>\n                lookup mon i = 0)) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "ultimately"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon = (0::'a)\n  MPoly_Type.coeff (sym_mpoly X (Suc k)) mon = (0::?'b1)", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon = (0::'a)\n  MPoly_Type.coeff (sym_mpoly X (Suc k)) mon = (0::?'b1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n    sym_mpoly X (Suc k))\n   mon\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "case True"], ["proof (state)\nthis:\n  \\<forall>i.\n     lookup mon i \\<le> 1 \\<and>\n     (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "define A where \"A = keys mon\""], ["proof (state)\nthis:\n  A = keys mon\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have A: \"A \\<subseteq> insert x X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> insert x X", "using True"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     lookup mon i \\<le> 1 \\<and>\n     (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> insert x X", "by (auto simp: A_def)"], ["proof (state)\nthis:\n  A \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have [simp]: \"mon = monom_of_set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon = monom_of_set A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mon = monom_of_set (keys mon)", "using True"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     lookup mon i \\<le> 1 \\<and>\n     (i \\<notin> insert x X \\<longrightarrow> lookup mon i = 0)\n\ngoal (1 subgoal):\n 1. mon = monom_of_set (keys mon)", "by transfer (force simp: fun_eq_iff le_Suc_eq)"], ["proof (state)\nthis:\n  mon = monom_of_set A\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using finite_subset A assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  A \\<subseteq> insert x X\n  finite X\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. finite A", "by blast"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       lookup mon i \\<le> 1 \\<and>\n       (i \\<notin> insert x X \\<longrightarrow>\n        lookup mon i = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "proof (cases \"x \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. x \\<notin> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "case False"], ["proof (state)\nthis:\n  x \\<notin> A\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. x \\<notin> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"coeff ?A mon = prod_fun (coeff (monom (monom_of_set {x}) 1))\n                                    (coeff (sym_mpoly X k)) (monom_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n    prod_fun\n     (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n     (MPoly_Type.coeff (sym_mpoly X k)) (monom_of_set A)", "by (simp add: coeff_mpoly_times)"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) (monom_of_set A)\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. x \\<notin> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) (monom_of_set A)\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. x \\<notin> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"\\<dots> = (\\<Sum>l. \\<Sum>q. coeff (monom (monom_of_set {x}) 1) l * coeff (sym_mpoly X k) q\n                         when monom_of_set A = l + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun\n     (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n     (MPoly_Type.coeff (sym_mpoly X k)) (monom_of_set A) =\n    (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                        (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                       MPoly_Type.coeff (sym_mpoly X k) q when\n                       monom_of_set A = l + q)", "unfolding prod_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a))\n               l *\n              (\\<Sum>q. MPoly_Type.coeff (sym_mpoly X k) q when\n                        monom_of_set A = l + q)) =\n    (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                        (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                       MPoly_Type.coeff (sym_mpoly X k) q when\n                       monom_of_set A = l + q)", "by (intro Sum_any.cong, subst Sum_any_right_distrib, force)\n           (auto simp: Sum_any_right_distrib when_def intro!: Sum_any.cong)"], ["proof (state)\nthis:\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) (monom_of_set A) =\n  (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                      (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                     MPoly_Type.coeff (sym_mpoly X k) q when\n                     monom_of_set A = l + q)\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. x \\<notin> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "also"], ["proof (state)\nthis:\n  prod_fun (MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)))\n   (MPoly_Type.coeff (sym_mpoly X k)) (monom_of_set A) =\n  (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                      (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                     MPoly_Type.coeff (sym_mpoly X k) q when\n                     monom_of_set A = l + q)\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. x \\<notin> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                        (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                       MPoly_Type.coeff (sym_mpoly X k) q when\n                       monom_of_set A = l + q) =\n    (0::'a)", "proof (rule Sum_any_zeroI, rule Sum_any_zeroI')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa q.\n       monom_of_set A = xa + q \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) xa *\n       MPoly_Type.coeff (sym_mpoly X k) q =\n       (0::'a)", "fix ma mb"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa q.\n       monom_of_set A = xa + q \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) xa *\n       MPoly_Type.coeff (sym_mpoly X k) q =\n       (0::'a)", "assume *: \"monom_of_set A = ma + mb\""], ["proof (state)\nthis:\n  monom_of_set A = ma + mb\n\ngoal (1 subgoal):\n 1. \\<And>xa q.\n       monom_of_set A = xa + q \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) xa *\n       MPoly_Type.coeff (sym_mpoly X k) q =\n       (0::'a)", "hence \"keys ma \\<subseteq> A\""], ["proof (prove)\nusing this:\n  monom_of_set A = ma + mb\n\ngoal (1 subgoal):\n 1. keys ma \\<subseteq> A", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  monom_of_set A = ma + mb\n  finite A\n\ngoal (1 subgoal):\n 1. keys ma \\<subseteq> A", "by transfer (auto simp: fun_eq_iff split: if_splits)"], ["proof (state)\nthis:\n  keys ma \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>xa q.\n       monom_of_set A = xa + q \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) xa *\n       MPoly_Type.coeff (sym_mpoly X k) q =\n       (0::'a)", "thus \"coeff (monom (monom_of_set {x}) (1::'a)) ma * coeff (sym_mpoly X k) mb = 0\""], ["proof (prove)\nusing this:\n  keys ma \\<subseteq> A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "using \\<open>x \\<notin> A\\<close>"], ["proof (prove)\nusing this:\n  keys ma \\<subseteq> A\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n    MPoly_Type.coeff (sym_mpoly X k) mb =\n    (0::'a)", "by (auto simp: coeff_monom when_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set {x}) (1::'a)) ma *\n  MPoly_Type.coeff (sym_mpoly X k) mb =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. MPoly_Type.coeff\n                      (MPoly_Type.monom (monom_of_set {x}) (1::'a)) l *\n                     MPoly_Type.coeff (sym_mpoly X k) q when\n                     monom_of_set A = l + q) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon\n 2. x \\<notin> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "finally"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "using False A assms finite_subset[of _ \"insert x X\"] finite_subset[of _ X]"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  (0::'a)\n  x \\<notin> A\n  A \\<subseteq> insert x X\n  finite X\n  x \\<notin> X\n  \\<lbrakk>?A \\<subseteq> insert x X; finite (insert x X)\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n  \\<lbrakk>?A \\<subseteq> X; finite X\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "by (auto simp: coeff_sym_mpoly)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n    sym_mpoly X (Suc k))\n   mon\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "case True"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"mon = monom_of_set {x} + monom_of_set (A - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon = monom_of_set {x} + monom_of_set (A - {x})", "using \\<open>x \\<in> A\\<close> \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. mon = monom_of_set {x} + monom_of_set (A - {x})", "by (auto simp: monom_of_set_plus_monom_of_set)"], ["proof (state)\nthis:\n  mon = monom_of_set {x} + monom_of_set (A - {x})\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "also"], ["proof (state)\nthis:\n  mon = monom_of_set {x} + monom_of_set (A - {x})\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"coeff ?A \\<dots> = coeff (sym_mpoly X k) (monom_of_set (A - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k)\n     (monom_of_set {x} + monom_of_set (A - {x})) =\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x}))", "by (subst coeff_monom_mult) auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k)\n   (monom_of_set {x} + monom_of_set (A - {x})) =\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x}))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k)\n   (monom_of_set {x} + monom_of_set (A - {x})) =\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x}))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"\\<dots> = (if card A = Suc k then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "proof (cases \"card A = Suc k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card A = Suc k \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))\n 2. card A \\<noteq> Suc k \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "case True"], ["proof (state)\nthis:\n  card A = Suc k\n\ngoal (2 subgoals):\n 1. card A = Suc k \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))\n 2. card A \\<noteq> Suc k \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  card A = Suc k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "using assms \\<open>finite A\\<close> \\<open>x \\<in> A\\<close> A"], ["proof (prove)\nusing this:\n  card A = Suc k\n  finite X\n  x \\<notin> X\n  finite A\n  x \\<in> A\n  A \\<subseteq> insert x X\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "by (subst coeff_sym_mpoly_monom_of_set) auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n  (if card A = Suc k then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. card A \\<noteq> Suc k \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card A \\<noteq> Suc k \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "case False"], ["proof (state)\nthis:\n  card A \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. card A \\<noteq> Suc k \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  card A \\<noteq> Suc k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "using assms \\<open>x \\<in> A\\<close> A \\<open>finite A\\<close> card_Suc_Diff1[of A x]"], ["proof (prove)\nusing this:\n  card A \\<noteq> Suc k\n  finite X\n  x \\<notin> X\n  x \\<in> A\n  A \\<subseteq> insert x X\n  finite A\n  \\<lbrakk>finite A; x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> Suc (card (A - {x})) = card A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n    (if card A = Suc k then 1::'a else (0::'a))", "by (subst coeff_sym_mpoly_monom_of_set_eq_0) auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n  (if card A = Suc k then 1::'a else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n  (if card A = Suc k then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "moreover"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n  (if card A = Suc k then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"coeff ?B (monom_of_set A) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X (Suc k)) (monom_of_set A) = (0::'a)", "using assms \\<open>x \\<in> A\\<close> \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  x \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X (Suc k)) (monom_of_set A) = (0::'a)", "by (subst coeff_sym_mpoly_monom_of_set_eq_0') auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X (Suc k)) (monom_of_set A) = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "moreover"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X (Suc k)) (monom_of_set A) = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "have \"coeff ?lhs (monom_of_set A) = (if card A = Suc k then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) (monom_of_set A) =\n    (if card A = Suc k then 1::'a else (0::'a))", "using assms A \\<open>finite A\\<close> finite_subset[of _ \"insert x X\"]"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  A \\<subseteq> insert x X\n  finite A\n  \\<lbrakk>?A \\<subseteq> insert x X; finite (insert x X)\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) (monom_of_set A) =\n    (if card A = Suc k then 1::'a else (0::'a))", "by (auto simp: coeff_sym_mpoly)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) (monom_of_set A) =\n  (if card A = Suc k then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "ultimately"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x}))\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n  (if card A = Suc k then 1::'a else (0::'a))\n  MPoly_Type.coeff (sym_mpoly X (Suc k)) (monom_of_set A) = (0::'a)\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) (monom_of_set A) =\n  (if card A = Suc k then 1::'a else (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k) mon =\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x}))\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set (A - {x})) =\n  (if card A = Suc k then 1::'a else (0::'a))\n  MPoly_Type.coeff (sym_mpoly X (Suc k)) (monom_of_set A) = (0::'a)\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) (monom_of_set A) =\n  (if card A = Suc k then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n    MPoly_Type.coeff\n     (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n      sym_mpoly X (Suc k))\n     mon", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n    sym_mpoly X (Suc k))\n   mon\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n    sym_mpoly X (Suc k))\n   mon\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly (insert x X) (Suc k)) mon =\n  MPoly_Type.coeff\n   (MPoly_Type.monom (monom_of_set {x}) (1::'a) * sym_mpoly X k +\n    sym_mpoly X (Suc k))\n   mon\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}