{"file_name": "/home/qj213/afp-2021-10-22/thys/Power_Sum_Polynomials/Power_Sum_Polynomials.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Power_Sum_Polynomials", "problem_names": ["lemma lookup_powsum_mpoly_aux:\n  \"Poly_Mapping.lookup (powsum_mpoly_aux X k) mon =\n     (if infinite X \\<or> k = 0 \\<and> mon \\<noteq> 0 then 0\n             else if k = 0 \\<and> mon = 0 then of_nat (card X)\n             else if finite X \\<and> (\\<exists>x\\<in>X. mon = Poly_Mapping.single x k) then 1 else 0)\"", "lemma lookup_sym_mpoly_aux_monom_singleton [simp]:\n  assumes \"finite X\" \"x \\<in> X\" \"k > 0\"\n  shows   \"Poly_Mapping.lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) = 1\"", "lemma lookup_sym_mpoly_aux_monom_singleton':\n  assumes \"finite X\" \"k > 0\"\n  shows   \"Poly_Mapping.lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) = (if x \\<in> X then 1 else 0)\"", "lemma keys_powsum_mpoly_aux: \"m \\<in> keys (powsum_mpoly_aux A k) \\<Longrightarrow> keys m \\<subseteq> A\"", "lemma vars_powsum_mpoly_subset: \"vars (powsum_mpoly A k) \\<subseteq> A\"", "lemma powsum_mpoly_infinite: \"\\<not>finite A \\<Longrightarrow> powsum_mpoly A k = 0\"", "lemma coeff_powsum_mpoly:\n  \"MPoly_Type.coeff (powsum_mpoly X k) mon =\n     (if infinite X \\<or> k = 0 \\<and> mon \\<noteq> 0 then 0\n             else if k = 0 \\<and> mon = 0 then of_nat (card X)\n             else if finite X \\<and> (\\<exists>x\\<in>X. mon = Poly_Mapping.single x k) then 1 else 0)\"", "lemma coeff_powsum_mpoly_0_right:\n  \"MPoly_Type.coeff (powsum_mpoly X 0) mon = (if mon = 0 then of_nat (card X) else 0)\"", "lemma coeff_powsum_mpoly_singleton:\n  assumes \"finite X\" \"k > 0\"\n  shows   \"MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (if x \\<in> X then 1 else 0)\"", "lemma coeff_powsum_mpoly_singleton_eq_1 [simp]:\n  assumes \"finite X\" \"x \\<in> X\" \"k > 0\"\n  shows   \"MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = 1\"", "lemma coeff_powsum_mpoly_singleton_eq_0 [simp]:\n  assumes \"finite X\" \"x \\<notin> X\" \"k > 0\"\n  shows   \"MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = 0\"", "lemma powsum_mpoly_0 [simp]: \"powsum_mpoly X 0 = of_nat (card X)\"", "lemma powsum_mpoly_empty [simp]: \"powsum_mpoly {} k = 0\"", "lemma powsum_mpoly_altdef: \"powsum_mpoly X k = (\\<Sum>x\\<in>X. monom (Poly_Mapping.single x k) 1)\"", "lemma symmetric_powsum_mpoly [intro]:\n  assumes \"A \\<subseteq> B\"\n  shows   \"symmetric_mpoly A (powsum_mpoly B k)\"", "lemma insertion_powsum_mpoly [simp]: \"insertion f (powsum_mpoly X k) = (\\<Sum>i\\<in>X. f i ^ k)\"", "lemma powsum_mpoly_nz:\n  assumes \"finite X\" \"X \\<noteq> {}\" \"k > 0\"\n  shows   \"(powsum_mpoly X k :: 'a :: {semiring_1, zero_neq_one} mpoly) \\<noteq> 0\"", "lemma powsum_mpoly_eq_0_iff:\n  assumes \"k > 0\"\n  shows   \"powsum_mpoly X k = 0 \\<longleftrightarrow> infinite X \\<or> X = {}\"", "theorem Girard_Newton:\n  assumes \"finite X\"\n  shows   \"(-1) ^ k * of_nat k * sym_mpoly X k +\n           (\\<Sum>i<k. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n             (0 :: 'a :: comm_ring_1 mpoly)\"\n  (is \"?lhs = 0\")", "lemma powsum_mpoly_recurrence':\n  assumes k: \"k > card X\" and X: \"finite X\"\n  shows   \"(powsum_mpoly X k :: 'a :: comm_ring_1 mpoly) =\n             -(\\<Sum>i=1..card X. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\""], "translations": [["", "lemma lookup_powsum_mpoly_aux:\n  \"Poly_Mapping.lookup (powsum_mpoly_aux X k) mon =\n     (if infinite X \\<or> k = 0 \\<and> mon \\<noteq> 0 then 0\n             else if k = 0 \\<and> mon = 0 then of_nat (card X)\n             else if finite X \\<and> (\\<exists>x\\<in>X. mon = Poly_Mapping.single x k) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (powsum_mpoly_aux X k) mon =\n    (if infinite X \\<or> k = 0 \\<and> mon \\<noteq> 0 then 0::'a\n     else if k = 0 \\<and> mon = 0 then of_nat (card X)\n          else if finite X \\<and>\n                  (\\<exists>x\\<in>X. mon = Poly_Mapping.single x k)\n               then 1::'a else (0::'a))", "by transfer' simp"], ["", "lemma lookup_sym_mpoly_aux_monom_singleton [simp]:\n  assumes \"finite X\" \"x \\<in> X\" \"k > 0\"\n  shows   \"Poly_Mapping.lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  x \\<in> X\n  0 < k\n\ngoal (1 subgoal):\n 1. lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) = (1::'a)", "by (auto simp: lookup_powsum_mpoly_aux)"], ["", "lemma lookup_sym_mpoly_aux_monom_singleton':\n  assumes \"finite X\" \"k > 0\"\n  shows   \"Poly_Mapping.lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) = (if x \\<in> X then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) =\n    (if x \\<in> X then 1::'a else (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  0 < k\n\ngoal (1 subgoal):\n 1. lookup (powsum_mpoly_aux X k) (Poly_Mapping.single x k) =\n    (if x \\<in> X then 1::'a else (0::'a))", "by (auto simp: lookup_powsum_mpoly_aux)"], ["", "lemma keys_powsum_mpoly_aux: \"m \\<in> keys (powsum_mpoly_aux A k) \\<Longrightarrow> keys m \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> keys (powsum_mpoly_aux A k) \\<Longrightarrow>\n    keys m \\<subseteq> A", "by transfer' (auto split: if_splits simp: keys_monom_of_set)"], ["", "lift_definition powsum_mpoly :: \"nat set \\<Rightarrow> nat \\<Rightarrow> 'a :: {semiring_1,zero_neq_one} mpoly\" is\n  \"powsum_mpoly_aux\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma vars_powsum_mpoly_subset: \"vars (powsum_mpoly A k) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (powsum_mpoly A k) \\<subseteq> A", "using keys_powsum_mpoly_aux"], ["proof (prove)\nusing this:\n  ?m \\<in> keys (powsum_mpoly_aux ?A ?k) \\<Longrightarrow>\n  keys ?m \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. vars (powsum_mpoly A k) \\<subseteq> A", "by (auto simp: vars_def powsum_mpoly.rep_eq)"], ["", "lemma powsum_mpoly_infinite: \"\\<not>finite A \\<Longrightarrow> powsum_mpoly A k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> powsum_mpoly A k = 0", "by (transfer, transfer) auto"], ["", "lemma coeff_powsum_mpoly:\n  \"MPoly_Type.coeff (powsum_mpoly X k) mon =\n     (if infinite X \\<or> k = 0 \\<and> mon \\<noteq> 0 then 0\n             else if k = 0 \\<and> mon = 0 then of_nat (card X)\n             else if finite X \\<and> (\\<exists>x\\<in>X. mon = Poly_Mapping.single x k) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) mon =\n    (if infinite X \\<or> k = 0 \\<and> mon \\<noteq> 0 then 0::'a\n     else if k = 0 \\<and> mon = 0 then of_nat (card X)\n          else if finite X \\<and>\n                  (\\<exists>x\\<in>X. mon = Poly_Mapping.single x k)\n               then 1::'a else (0::'a))", "by transfer' (simp add: lookup_powsum_mpoly_aux)"], ["", "lemma coeff_powsum_mpoly_0_right:\n  \"MPoly_Type.coeff (powsum_mpoly X 0) mon = (if mon = 0 then of_nat (card X) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X 0) mon =\n    (if mon = 0 then of_nat (card X) else (0::'a))", "by transfer' (auto simp add: lookup_powsum_mpoly_aux)"], ["", "lemma coeff_powsum_mpoly_singleton:\n  assumes \"finite X\" \"k > 0\"\n  shows   \"MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (if x \\<in> X then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) =\n    (if x \\<in> X then 1::'a else (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  0 < k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) =\n    (if x \\<in> X then 1::'a else (0::'a))", "by transfer' (simp add: lookup_powsum_mpoly_aux)"], ["", "lemma coeff_powsum_mpoly_singleton_eq_1 [simp]:\n  assumes \"finite X\" \"x \\<in> X\" \"k > 0\"\n  shows   \"MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  x \\<in> X\n  0 < k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (1::'a)", "by (simp add: coeff_powsum_mpoly_singleton)"], ["", "lemma coeff_powsum_mpoly_singleton_eq_0 [simp]:\n  assumes \"finite X\" \"x \\<notin> X\" \"k > 0\"\n  shows   \"MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  0 < k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (0::'a)", "by (simp add: coeff_powsum_mpoly_singleton)"], ["", "lemma powsum_mpoly_0 [simp]: \"powsum_mpoly X 0 = of_nat (card X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X 0 = of_nat (card X)", "by (intro mpoly_eqI ext) (auto simp: coeff_powsum_mpoly_0_right of_nat_mpoly_eq mpoly_coeff_Const)"], ["", "lemma powsum_mpoly_empty [simp]: \"powsum_mpoly {} k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly {} k = 0", "by (intro mpoly_eqI) (auto simp: coeff_powsum_mpoly)"], ["", "lemma powsum_mpoly_altdef: \"powsum_mpoly X k = (\\<Sum>x\\<in>X. monom (Poly_Mapping.single x k) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "proof (cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n 2. infinite X \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "case [simp]: True"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n 2. infinite X \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "by auto"], ["proof (state)\nthis:\n  powsum_mpoly X k =\n  (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "proof (intro mpoly_eqI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (powsum_mpoly X k) mon =\n       MPoly_Type.coeff\n        (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n        mon", "case (1 mon)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (powsum_mpoly X k) mon =\n       MPoly_Type.coeff\n        (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n        mon", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) mon =\n    MPoly_Type.coeff\n     (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a)) mon", "using False"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) mon =\n    MPoly_Type.coeff\n     (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a)) mon", "by (cases \"\\<exists>x\\<in>X. mon = Poly_Mapping.single x k\")\n           (auto simp: coeff_powsum_mpoly coeff_monom when_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (powsum_mpoly X k) mon =\n  MPoly_Type.coeff\n   (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a)) mon\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  powsum_mpoly X k =\n  (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  powsum_mpoly X k =\n  (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow>\n    powsum_mpoly X k =\n    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "qed (auto simp: powsum_mpoly_infinite)"], ["", "text \\<open>\n  Power sum polynomials are symmetric:\n\\<close>"], ["", "lemma symmetric_powsum_mpoly [intro]:\n  assumes \"A \\<subseteq> B\"\n  shows   \"symmetric_mpoly A (powsum_mpoly B k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (powsum_mpoly B k)", "unfolding powsum_mpoly_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A\n     (\\<Sum>x\\<in>B. MPoly_Type.monom (Poly_Mapping.single x k) (1::'a))", "proof (rule symmetric_mpoly_symmetric_sum)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> ?g \\<pi> permutes B\n 2. \\<And>x \\<pi>.\n       \\<lbrakk>x \\<in> B; \\<pi> permutes A\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (MPoly_Type.monom (Poly_Mapping.single x k)\n                            (1::'a)) =\n                         MPoly_Type.monom\n                          (Poly_Mapping.single (?g \\<pi> x) k) (1::'a)", "fix x \\<pi>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> ?g \\<pi> permutes B\n 2. \\<And>x \\<pi>.\n       \\<lbrakk>x \\<in> B; \\<pi> permutes A\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (MPoly_Type.monom (Poly_Mapping.single x k)\n                            (1::'a)) =\n                         MPoly_Type.monom\n                          (Poly_Mapping.single (?g \\<pi> x) k) (1::'a)", "assume \"x \\<in> B\" \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  x \\<in> B\n  \\<pi> permutes A\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> ?g \\<pi> permutes B\n 2. \\<And>x \\<pi>.\n       \\<lbrakk>x \\<in> B; \\<pi> permutes A\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (MPoly_Type.monom (Poly_Mapping.single x k)\n                            (1::'a)) =\n                         MPoly_Type.monom\n                          (Poly_Mapping.single (?g \\<pi> x) k) (1::'a)", "thus \"mpoly_map_vars \\<pi> (MPoly_Type.monom (Poly_Mapping.single x k) 1) =\n        MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) k) 1\""], ["proof (prove)\nusing this:\n  x \\<in> B\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi>\n     (MPoly_Type.monom (Poly_Mapping.single x k) (1::'b)) =\n    MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) k) (1::'b)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> B\n  \\<pi> permutes A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi>\n     (MPoly_Type.monom (Poly_Mapping.single x k) (1::'b)) =\n    MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) k) (1::'b)", "by (auto simp: mpoly_map_vars_monom permutes_bij permutep_single\n                               bij_imp_bij_inv permutes_inv_inv)"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi>\n   (MPoly_Type.monom (Poly_Mapping.single x k) (1::?'b1)) =\n  MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) k) (1::?'b1)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> \\<pi> permutes B", "qed (use assms in \\<open>auto simp: permutes_subset\\<close>)"], ["", "lemma insertion_powsum_mpoly [simp]: \"insertion f (powsum_mpoly X k) = (\\<Sum>i\\<in>X. f i ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (powsum_mpoly X k) = (\\<Sum>i\\<in>X. f i ^ k)", "unfolding powsum_mpoly_altdef insertion_sum insertion_single"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. (1::'a) * f x ^ k) = (\\<Sum>i\\<in>X. f i ^ k)", "by simp"], ["", "lemma powsum_mpoly_nz:\n  assumes \"finite X\" \"X \\<noteq> {}\" \"k > 0\"\n  shows   \"(powsum_mpoly X k :: 'a :: {semiring_1, zero_neq_one} mpoly) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X k \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. powsum_mpoly X k \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  finite X\n  X \\<noteq> {}\n  0 < k", "obtain x where \"x \\<in> X\""], ["proof (prove)\nusing this:\n  finite X\n  X \\<noteq> {}\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k \\<noteq> 0", "hence \"coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (1 :: 'a)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> X\n  finite X\n  X \\<noteq> {}\n  0 < k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (1::'a)", "by (auto simp: coeff_powsum_mpoly)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (1::'a)\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (powsum_mpoly X k) (Poly_Mapping.single x k) = (1::'a)\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  powsum_mpoly X k \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma powsum_mpoly_eq_0_iff:\n  assumes \"k > 0\"\n  shows   \"powsum_mpoly X k = 0 \\<longleftrightarrow> infinite X \\<or> X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (powsum_mpoly X k = 0) = (infinite X \\<or> X = {})", "using assms powsum_mpoly_nz[of X k]"], ["proof (prove)\nusing this:\n  0 < k\n  \\<lbrakk>finite X; X \\<noteq> {}; 0 < k\\<rbrakk>\n  \\<Longrightarrow> powsum_mpoly X k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (powsum_mpoly X k = 0) = (infinite X \\<or> X = {})", "by (auto simp: powsum_mpoly_infinite)"], ["", "subsection \\<open>The Girard--Newton Theorem\\<close>"], ["", "text \\<open>\n  The following is a nice combinatorial proof of the Girard--Newton Theorem due to\n  Doron Zeilberger~\\cite{zeilberger}.\n\n  The precise statement is this:\n\n  Let $e_k$ denote the $k$-th elementary symmetric polynomial in $X_1,\\ldots,X_n$.\n  This is the sum of all monomials that can be formed by taking the product of $k$ \n  distinct variables.\n\n  Next, let $p_k = X_1^k + \\ldots + X_n^k$ denote that $k$-th symmetric power sum polynomial\n  in $X_1,\\ldots,X_n$.\n\n  Then the following equality holds:\n  \\[(-1)^k k e_k + \\sum_{i=0}^{k-1} (-1)^i e_i p_{k-i}\\]\n\\<close>"], ["", "theorem Girard_Newton:\n  assumes \"finite X\"\n  shows   \"(-1) ^ k * of_nat k * sym_mpoly X k +\n           (\\<Sum>i<k. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n             (0 :: 'a :: comm_ring_1 mpoly)\"\n  (is \"?lhs = 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "write Poly_Mapping.single (\"sng\")"], ["proof (state)\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "define n where \"n = card X\""], ["proof (state)\nthis:\n  n = card X\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "define \\<A> :: \"(nat set \\<times> nat) set\"\n    where \"\\<A> = {(A, j). A \\<subseteq> X \\<and> card A \\<le> k \\<and> j \\<in> X \\<and> (card A = k \\<longrightarrow> j \\<in> A)}\""], ["proof (state)\nthis:\n  \\<A> =\n  {(A, j).\n   A \\<subseteq> X \\<and>\n   card A \\<le> k \\<and>\n   j \\<in> X \\<and> (card A = k \\<longrightarrow> j \\<in> A)}\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "define \\<A>1 :: \"(nat set \\<times> nat) set\"\n    where \"\\<A>1 = {A\\<in>Pow X. card A < k} \\<times> X\""], ["proof (state)\nthis:\n  \\<A>1 = {A \\<in> Pow X. card A < k} \\<times> X\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "define \\<A>2 :: \"(nat set \\<times> nat) set\"\n    where \"\\<A>2 = (SIGMA A:{A\\<in>Pow X. card A = k}. A)\""], ["proof (state)\nthis:\n  \\<A>2 = (SIGMA A:{A \\<in> Pow X. card A = k}. A)\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "have \\<A>_split: \"\\<A> = \\<A>1 \\<union> \\<A>2\" \"\\<A>1 \\<inter> \\<A>2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> = \\<A>1 \\<union> \\<A>2 &&& \\<A>1 \\<inter> \\<A>2 = {}", "by (auto simp: \\<A>_def \\<A>1_def \\<A>2_def)"], ["proof (state)\nthis:\n  \\<A> = \\<A>1 \\<union> \\<A>2\n  \\<A>1 \\<inter> \\<A>2 = {}\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "have [intro]: \"finite \\<A>1\" \"finite \\<A>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<A>1 &&& finite \\<A>2", "using assms finite_subset[of _ X]"], ["proof (prove)\nusing this:\n  finite X\n  \\<lbrakk>?A \\<subseteq> X; finite X\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite \\<A>1 &&& finite \\<A>2", "by (auto simp: \\<A>1_def \\<A>2_def intro!: finite_SigmaI)"], ["proof (state)\nthis:\n  finite \\<A>1\n  finite \\<A>2\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "have [intro]: \"finite \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<A>", "by (subst \\<A>_split) auto\n\n  \\<comment> \\<open>\n    We define a `weight' function \\<open>w\\<close> from \\<open>\\<A>\\<close> to the ring of polynomials as\n    \\[w(A,j) = (-1)^{|A|} x_j^{k-|A|} \\prod_{i\\in A} x_i\\ .\\]\n  \\<close>"], ["proof (state)\nthis:\n  finite \\<A>\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "define w :: \"nat set \\<times> nat \\<Rightarrow> 'a mpoly\"\n    where \"w = (\\<lambda>(A, j). monom (monom_of_set A + sng j (k - card A)) ((-1) ^ card A))\"\n\n  \\<comment> \\<open>The sum of these weights over all of \\<open>\\<A>\\<close> is precisely the sum that we want to show equals 0:\\<close>"], ["proof (state)\nthis:\n  w =\n  (\\<lambda>(A, j).\n      MPoly_Type.monom (monom_of_set A + sng j (k - card A))\n       ((- (1::'a)) ^ card A))\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "have \"?lhs = (\\<Sum>x\\<in>\\<A>. w x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "have \"(\\<Sum>x\\<in>\\<A>. w x) = (\\<Sum>x\\<in>\\<A>1. w x) + (\\<Sum>x\\<in>\\<A>2. w x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w \\<A> = sum w \\<A>1 + sum w \\<A>2", "by (subst \\<A>_split, subst sum.union_disjoint, use \\<A>_split(2) in auto)"], ["proof (state)\nthis:\n  sum w \\<A> = sum w \\<A>1 + sum w \\<A>2\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "also"], ["proof (state)\nthis:\n  sum w \\<A> = sum w \\<A>1 + sum w \\<A>2\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "have \"(\\<Sum>x\\<in>\\<A>1. w x) = (\\<Sum>i<k. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"(\\<Sum>x\\<in>\\<A>1. w x) = (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j))", "using assms"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j))", "by (subst sum.Sigma) (auto simp: \\<A>1_def)"], ["proof (state)\nthis:\n  sum w \\<A>1 =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  sum w \\<A>1 =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"\\<dots> = (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X.\n                        monom (monom_of_set A) ((-1) ^ card A) * monom (sng j (k - card A)) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j)) =\n    (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n       \\<Sum>j\\<in>X.\n         MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n         MPoly_Type.monom (sng j (k - card A)) (1::'a))", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n       \\<Sum>j\\<in>X.\n         case (A, j) of\n         (A, j) \\<Rightarrow>\n           MPoly_Type.monom (monom_of_set A + sng j (k - card A))\n            ((- (1::'a)) ^ card A)) =\n    (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n       \\<Sum>j\\<in>X.\n         MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n         MPoly_Type.monom (sng j (k - card A)) (1::'a))", "by (intro sum.cong) (auto simp: mult_monom)"], ["proof (state)\nthis:\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j)) =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     \\<Sum>j\\<in>X.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n       MPoly_Type.monom (sng j (k - card A)) (1::'a))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. \\<Sum>j\\<in>X. w (A, j)) =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     \\<Sum>j\\<in>X.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n       MPoly_Type.monom (sng j (k - card A)) (1::'a))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"\\<dots> = (\\<Sum>A | A \\<subseteq> X \\<and> card A < k. monom (monom_of_set A) ((-1) ^ card A) *\n                        powsum_mpoly X (k - card A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n       \\<Sum>j\\<in>X.\n         MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n         MPoly_Type.monom (sng j (k - card A)) (1::'a)) =\n    (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n       powsum_mpoly X (k - card A))", "by (simp add: sum_distrib_left powsum_mpoly_altdef)"], ["proof (state)\nthis:\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     \\<Sum>j\\<in>X.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n       MPoly_Type.monom (sng j (k - card A)) (1::'a)) =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n     powsum_mpoly X (k - card A))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     \\<Sum>j\\<in>X.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n       MPoly_Type.monom (sng j (k - card A)) (1::'a)) =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n     powsum_mpoly X (k - card A))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"\\<dots> = (\\<Sum>(i,A) \\<in> (SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n                        monom (monom_of_set A) ((-1) ^ i) * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n       powsum_mpoly X (k - card A)) =\n    (\\<Sum>(i, A)\n           \\<in>(SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ i) *\n       powsum_mpoly X (k - i))", "by (rule sum.reindex_bij_witness[of _ snd \"\\<lambda>A. (card A, A)\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n     powsum_mpoly X (k - card A)) =\n  (\\<Sum>(i, A)\n         \\<in>(SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ i) *\n     powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A < k.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ card A) *\n     powsum_mpoly X (k - card A)) =\n  (\\<Sum>(i, A)\n         \\<in>(SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ i) *\n     powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"\\<dots> = (\\<Sum>i<k. \\<Sum>A | A \\<subseteq> X \\<and> card A = i.\n                        monom (monom_of_set A) 1 * monom 0 ((-1) ^ i) * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, A)\n           \\<in>(SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ i) *\n       powsum_mpoly X (k - i)) =\n    (\\<Sum>i<k.\n        \\<Sum>A | A \\<subseteq> X \\<and> card A = i.\n          MPoly_Type.monom (monom_of_set A) (1::'a) *\n          MPoly_Type.monom 0 ((- (1::'a)) ^ i) *\n          powsum_mpoly X (k - i))", "using assms"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<Sum>(i, A)\n           \\<in>(SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ i) *\n       powsum_mpoly X (k - i)) =\n    (\\<Sum>i<k.\n        \\<Sum>A | A \\<subseteq> X \\<and> card A = i.\n          MPoly_Type.monom (monom_of_set A) (1::'a) *\n          MPoly_Type.monom 0 ((- (1::'a)) ^ i) *\n          powsum_mpoly X (k - i))", "by (subst sum.Sigma) (auto simp: mult_monom)"], ["proof (state)\nthis:\n  (\\<Sum>(i, A)\n         \\<in>(SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ i) *\n     powsum_mpoly X (k - i)) =\n  (\\<Sum>i<k.\n      \\<Sum>A | A \\<subseteq> X \\<and> card A = i.\n        MPoly_Type.monom (monom_of_set A) (1::'a) *\n        MPoly_Type.monom 0 ((- (1::'a)) ^ i) *\n        powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  (\\<Sum>(i, A)\n         \\<in>(SIGMA i:{..<k}. {A. A \\<subseteq> X \\<and> card A = i}).\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ i) *\n     powsum_mpoly X (k - i)) =\n  (\\<Sum>i<k.\n      \\<Sum>A | A \\<subseteq> X \\<and> card A = i.\n        MPoly_Type.monom (monom_of_set A) (1::'a) *\n        MPoly_Type.monom 0 ((- (1::'a)) ^ i) *\n        powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"\\<dots> = (\\<Sum>i<k. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        \\<Sum>A | A \\<subseteq> X \\<and> card A = i.\n          MPoly_Type.monom (monom_of_set A) (1::'a) *\n          MPoly_Type.monom 0 ((- (1::'a)) ^ i) *\n          powsum_mpoly X (k - i)) =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "by (simp add: sum_distrib_left sum_distrib_right mpoly_monom_0_eq_Const \n                      mpoly_Const_power mpoly_Const_uminus algebra_simps sym_mpoly_altdef)"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      \\<Sum>A | A \\<subseteq> X \\<and> card A = i.\n        MPoly_Type.monom (monom_of_set A) (1::'a) *\n        MPoly_Type.monom 0 ((- (1::'a)) ^ i) *\n        powsum_mpoly X (k - i)) =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "finally"], ["proof (chain)\npicking this:\n  sum w \\<A>1 =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum w \\<A>1 =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. sum w \\<A>1 =\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "."], ["proof (state)\nthis:\n  sum w \\<A>1 =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum w \\<A>1 =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "also"], ["proof (state)\nthis:\n  sum w \\<A>1 =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "have \"(\\<Sum>x\\<in>\\<A>2. w x) = (-1) ^ k * of_nat k * sym_mpoly X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "have \"(\\<Sum>x\\<in>\\<A>2. w x) = (\\<Sum>(A,j)\\<in>\\<A>2. monom (monom_of_set A) ((- 1) ^ k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w \\<A>2 =\n    (\\<Sum>(A, j)\\<in>\\<A>2.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k))", "by (intro sum.cong) (auto simp: \\<A>2_def w_def mpoly_monom_0_eq_Const intro!: sum.cong)"], ["proof (state)\nthis:\n  sum w \\<A>2 =\n  (\\<Sum>(A, j)\\<in>\\<A>2.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k))\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "also"], ["proof (state)\nthis:\n  sum w \\<A>2 =\n  (\\<Sum>(A, j)\\<in>\\<A>2.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k))\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "have \"\\<dots> = (\\<Sum>A | A \\<subseteq> X \\<and> card A = k. \\<Sum>j\\<in>A. monom (monom_of_set A) ((- 1) ^ k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(A, j)\\<in>\\<A>2.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k)) =\n    (\\<Sum>A | A \\<subseteq> X \\<and> card A = k.\n       \\<Sum>j\\<in>A. MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k))", "using assms finite_subset[of _ X]"], ["proof (prove)\nusing this:\n  finite X\n  \\<lbrakk>?A \\<subseteq> X; finite X\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>(A, j)\\<in>\\<A>2.\n       MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k)) =\n    (\\<Sum>A | A \\<subseteq> X \\<and> card A = k.\n       \\<Sum>j\\<in>A. MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k))", "by (subst sum.Sigma) (auto simp: \\<A>2_def)"], ["proof (state)\nthis:\n  (\\<Sum>(A, j)\\<in>\\<A>2.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k)) =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A = k.\n     \\<Sum>j\\<in>A. MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k))\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "also"], ["proof (state)\nthis:\n  (\\<Sum>(A, j)\\<in>\\<A>2.\n     MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k)) =\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A = k.\n     \\<Sum>j\\<in>A. MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k))\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "have \"(\\<lambda>A. monom (monom_of_set A) ((- 1) ^ k) :: 'a mpoly) =\n                   (\\<lambda>A. monom 0 ((-1) ^ k) * monom (monom_of_set A) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k)) =\n    (\\<lambda>A.\n        MPoly_Type.monom 0 ((- (1::'a)) ^ k) *\n        MPoly_Type.monom (monom_of_set A) (1::'a))", "by (auto simp: fun_eq_iff mult_monom)"], ["proof (state)\nthis:\n  (\\<lambda>A. MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k)) =\n  (\\<lambda>A.\n      MPoly_Type.monom 0 ((- (1::'a)) ^ k) *\n      MPoly_Type.monom (monom_of_set A) (1::'a))\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "also"], ["proof (state)\nthis:\n  (\\<lambda>A. MPoly_Type.monom (monom_of_set A) ((- (1::'a)) ^ k)) =\n  (\\<lambda>A.\n      MPoly_Type.monom 0 ((- (1::'a)) ^ k) *\n      MPoly_Type.monom (monom_of_set A) (1::'a))\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "have \"monom 0 ((-1) ^ k) = (-1) ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom 0 ((- (1::'b)) ^ k) = (- 1) ^ k", "by (auto simp: mpoly_monom_0_eq_Const mpoly_Const_power mpoly_Const_uminus)"], ["proof (state)\nthis:\n  MPoly_Type.monom 0 ((- (1::?'b1)) ^ k) = (- 1) ^ k\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "also"], ["proof (state)\nthis:\n  MPoly_Type.monom 0 ((- (1::?'b1)) ^ k) = (- 1) ^ k\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "have \"(\\<Sum>A | A \\<subseteq> X \\<and> card A = k. \\<Sum>j\\<in>A. (- 1) ^ k * monom (monom_of_set A) 1) =\n                   ((-1) ^ k * of_nat k * sym_mpoly X k :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A | A \\<subseteq> X \\<and> card A = k.\n       \\<Sum>j\\<in>A.\n         (- 1) ^ k * MPoly_Type.monom (monom_of_set A) (1::'a)) =\n    (- 1) ^ k * of_nat k * sym_mpoly X k", "by (auto simp: sum_distrib_left sum_distrib_right mult_ac sym_mpoly_altdef)"], ["proof (state)\nthis:\n  (\\<Sum>A | A \\<subseteq> X \\<and> card A = k.\n     \\<Sum>j\\<in>A. (- 1) ^ k * MPoly_Type.monom (monom_of_set A) (1::'a)) =\n  (- 1) ^ k * of_nat k * sym_mpoly X k\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "finally"], ["proof (chain)\npicking this:\n  sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "show ?thesis"], ["proof (prove)\nusing this:\n  sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k\n\ngoal (1 subgoal):\n 1. sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k", "."], ["proof (state)\nthis:\n  sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum w \\<A>2 = (- 1) ^ k * of_nat k * sym_mpoly X k\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "finally"], ["proof (chain)\npicking this:\n  sum w \\<A> =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) +\n  (- 1) ^ k * of_nat k * sym_mpoly X k", "show ?thesis"], ["proof (prove)\nusing this:\n  sum w \\<A> =\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) +\n  (- 1) ^ k * of_nat k * sym_mpoly X k\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    sum w \\<A>", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  sum w \\<A>\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Next, we show that the weights sum to 0:\\<close>"], ["proof (state)\nthis:\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  sum w \\<A>\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "also"], ["proof (state)\nthis:\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  sum w \\<A>\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "have \"(\\<Sum>x\\<in>\\<A>. w x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "proof -\n    \\<comment> \\<open>We define a function \\<open>T\\<close> that is a involutory permutation of \\<open>\\<A>\\<close>.\n        To be more precise, it bijectively maps those elements \\<open>(A,j)\\<close> of \\<open>\\<A>\\<close> with \\<open>j \\<in> A\\<close>\n        to those where \\<open>j \\<notin> A\\<close> and the other way round. `Involutory' means that \\<open>T\\<close> is its\n        own inverse function, i.\\,e.\\ $T(T(x)) = x$.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "define T :: \"nat set \\<times> nat \\<Rightarrow> nat set \\<times> nat\"\n      where \"T = (\\<lambda>(A, j). if j \\<in> A then (A - {j}, j) else (insert j A, j))\""], ["proof (state)\nthis:\n  T = (\\<lambda>(A, j). if j \\<in> A then (A - {j}, j) else (insert j A, j))\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have [simp]: \"T (T x) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. T (T x) = x", "by (auto simp: T_def split: prod.splits)"], ["proof (state)\nthis:\n  T (T ?x) = ?x\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have [simp]: \"T x \\<in> \\<A>\" if \"x \\<in> \\<A>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. T x \\<in> \\<A>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T x \\<in> \\<A>", "have [simp]: \"n \\<le> n - Suc 0 \\<longleftrightarrow> n = 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<le> n - Suc 0) = (n = 0)", "by auto"], ["proof (state)\nthis:\n  (?n \\<le> ?n - Suc 0) = (?n = 0)\n\ngoal (1 subgoal):\n 1. T x \\<in> \\<A>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. T x \\<in> \\<A>", "using that assms finite_subset[of _ X]"], ["proof (prove)\nusing this:\n  x \\<in> \\<A>\n  finite X\n  \\<lbrakk>?A \\<subseteq> X; finite X\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. T x \\<in> \\<A>", "by (auto simp: T_def \\<A>_def split: prod.splits)"], ["proof (state)\nthis:\n  T x \\<in> \\<A>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> \\<A> \\<Longrightarrow> T ?x \\<in> \\<A>\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have \"snd (T x) \\<in> fst (T x) \\<longleftrightarrow> snd x \\<notin> fst x\" if \"x \\<in> \\<A>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd (T x) \\<in> fst (T x)) = (snd x \\<notin> fst x)", "by (auto simp: T_def split: prod.splits)"], ["proof (state)\nthis:\n  ?x \\<in> \\<A> \\<Longrightarrow>\n  (snd (T ?x) \\<in> fst (T ?x)) = (snd ?x \\<notin> fst ?x)\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "hence bij: \"bij_betw T {x\\<in>\\<A>. snd x \\<in> fst x} {x\\<in>\\<A>. snd x \\<notin> fst x}\""], ["proof (prove)\nusing this:\n  ?x \\<in> \\<A> \\<Longrightarrow>\n  (snd (T ?x) \\<in> fst (T ?x)) = (snd ?x \\<notin> fst ?x)\n\ngoal (1 subgoal):\n 1. bij_betw T {x \\<in> \\<A>. snd x \\<in> fst x}\n     {x \\<in> \\<A>. snd x \\<notin> fst x}", "by (intro bij_betwI[of _ _ _ T]) auto\n\n    \\<comment>\\<open>Crucially, we show that \\<^term>\\<open>T\\<close> flips the weight of each element:\\<close>"], ["proof (state)\nthis:\n  bij_betw T {x \\<in> \\<A>. snd x \\<in> fst x}\n   {x \\<in> \\<A>. snd x \\<notin> fst x}\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have [simp]: \"w (T x) = -w x\" if \"x \\<in> \\<A>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. w (T x) = - w x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w (T x) = - w x", "obtain A j where [simp]: \"x = (A, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A j. x = (A, j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force\n      \n      \\<comment> \\<open>Since \\<^term>\\<open>T\\<close> is an involution, we can assume w.\\,l.\\,o.\\,g.\\ that \\<open>j \\<in> A\\<close>:\\<close>"], ["proof (state)\nthis:\n  x = (A, j)\n\ngoal (1 subgoal):\n 1. w (T x) = - w x", "have aux: \"w (T (A, j)) = - w (A, j)\" if \"(A, j) \\<in> \\<A>\" \"j \\<in> A\" for j A"], ["proof (prove)\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "from that"], ["proof (chain)\npicking this:\n  (A, j) \\<in> \\<A>\n  j \\<in> A", "have [simp]: \"j \\<in> A\" \"A \\<subseteq> X\" and \"k > 0\""], ["proof (prove)\nusing this:\n  (A, j) \\<in> \\<A>\n  j \\<in> A\n\ngoal (1 subgoal):\n 1. (j \\<in> A &&& A \\<subseteq> X) &&& 0 < k", "using finite_subset[OF _ assms, of A]"], ["proof (prove)\nusing this:\n  (A, j) \\<in> \\<A>\n  j \\<in> A\n  A \\<subseteq> X \\<Longrightarrow> finite A\n\ngoal (1 subgoal):\n 1. (j \\<in> A &&& A \\<subseteq> X) &&& 0 < k", "by (auto simp: \\<A>_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  j \\<in> A\n  A \\<subseteq> X\n  0 < k\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have [simp]: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using finite_subset[OF _ assms, of A]"], ["proof (prove)\nusing this:\n  A \\<subseteq> X \\<Longrightarrow> finite A\n\ngoal (1 subgoal):\n 1. finite A", "by auto"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "from that"], ["proof (chain)\npicking this:\n  (A, j) \\<in> \\<A>\n  j \\<in> A", "have \"card A \\<le> k\""], ["proof (prove)\nusing this:\n  (A, j) \\<in> \\<A>\n  j \\<in> A\n\ngoal (1 subgoal):\n 1. card A \\<le> k", "by (auto simp: \\<A>_def)"], ["proof (state)\nthis:\n  card A \\<le> k\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have card: \"card A = Suc (card (A - {j}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A = Suc (card (A - {j}))", "using card.remove[of A j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite A; j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> card A = Suc (card (A - {j}))\n\ngoal (1 subgoal):\n 1. card A = Suc (card (A - {j}))", "by auto"], ["proof (state)\nthis:\n  card A = Suc (card (A - {j}))\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "hence card_less: \"card (A - {j}) < card A\""], ["proof (prove)\nusing this:\n  card A = Suc (card (A - {j}))\n\ngoal (1 subgoal):\n 1. card (A - {j}) < card A", "by linarith"], ["proof (state)\nthis:\n  card (A - {j}) < card A\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have \"w (T (A, j)) = monom (monom_of_set (A - {j}) + sng j (k - card (A - {j})))\n                         ((- 1) ^ card (A - {j}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w (T (A, j)) =\n    MPoly_Type.monom (monom_of_set (A - {j}) + sng j (k - card (A - {j})))\n     ((- (1::'a)) ^ card (A - {j}))", "by (simp add: w_def T_def)"], ["proof (state)\nthis:\n  w (T (A, j)) =\n  MPoly_Type.monom (monom_of_set (A - {j}) + sng j (k - card (A - {j})))\n   ((- (1::'a)) ^ card (A - {j}))\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "also"], ["proof (state)\nthis:\n  w (T (A, j)) =\n  MPoly_Type.monom (monom_of_set (A - {j}) + sng j (k - card (A - {j})))\n   ((- (1::'a)) ^ card (A - {j}))\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have \"(- 1) ^ card (A - {j}) = ((- 1) ^ Suc (Suc (card (A - {j}))) :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (1::'a)) ^ card (A - {j}) = (- (1::'a)) ^ Suc (Suc (card (A - {j})))", "by simp"], ["proof (state)\nthis:\n  (- (1::'a)) ^ card (A - {j}) = (- (1::'a)) ^ Suc (Suc (card (A - {j})))\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "also"], ["proof (state)\nthis:\n  (- (1::'a)) ^ card (A - {j}) = (- (1::'a)) ^ Suc (Suc (card (A - {j})))\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have \"Suc (card (A - {j})) = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (A - {j})) = card A", "using card"], ["proof (prove)\nusing this:\n  card A = Suc (card (A - {j}))\n\ngoal (1 subgoal):\n 1. Suc (card (A - {j})) = card A", "by simp"], ["proof (state)\nthis:\n  Suc (card (A - {j})) = card A\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "also"], ["proof (state)\nthis:\n  Suc (card (A - {j})) = card A\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have \"k - card (A - {j}) = Suc (k - card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k - card (A - {j}) = Suc (k - card A)", "using \\<open>k > 0\\<close> \\<open>card A \\<le> k\\<close> card_less"], ["proof (prove)\nusing this:\n  0 < k\n  card A \\<le> k\n  card (A - {j}) < card A\n\ngoal (1 subgoal):\n 1. k - card (A - {j}) = Suc (k - card A)", "by (subst card) auto"], ["proof (state)\nthis:\n  k - card (A - {j}) = Suc (k - card A)\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "also"], ["proof (state)\nthis:\n  k - card (A - {j}) = Suc (k - card A)\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have \"monom_of_set (A - {j}) + sng j (Suc (k - card A)) =\n                   monom_of_set A + sng j (k - card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_of_set (A - {j}) + sng j (Suc (k - card A)) =\n    monom_of_set A + sng j (k - card A)", "by (transfer fixing: A j k) (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  monom_of_set (A - {j}) + sng j (Suc (k - card A)) =\n  monom_of_set A + sng j (k - card A)\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "also"], ["proof (state)\nthis:\n  monom_of_set (A - {j}) + sng j (Suc (k - card A)) =\n  monom_of_set A + sng j (k - card A)\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "have \"monom \\<dots> ((-1)^ Suc (card A)) = -w (A, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.monom (monom_of_set A + sng j (k - card A))\n     ((- (1::'a)) ^ Suc (card A)) =\n    - w (A, j)", "by (simp add: w_def monom_uminus)"], ["proof (state)\nthis:\n  MPoly_Type.monom (monom_of_set A + sng j (k - card A))\n   ((- (1::'a)) ^ Suc (card A)) =\n  - w (A, j)\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "finally"], ["proof (chain)\npicking this:\n  w (T (A, j)) = - w (A, j)", "show ?thesis"], ["proof (prove)\nusing this:\n  w (T (A, j)) = - w (A, j)\n\ngoal (1 subgoal):\n 1. w (T (A, j)) = - w (A, j)", "."], ["proof (state)\nthis:\n  w (T (A, j)) = - w (A, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?A, ?j) \\<in> \\<A>; ?j \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> w (T (?A, ?j)) = - w (?A, ?j)\n\ngoal (1 subgoal):\n 1. w (T x) = - w x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w (T x) = - w x", "proof (cases \"j \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j \\<in> A \\<Longrightarrow> w (T x) = - w x\n 2. j \\<notin> A \\<Longrightarrow> w (T x) = - w x", "case True"], ["proof (state)\nthis:\n  j \\<in> A\n\ngoal (2 subgoals):\n 1. j \\<in> A \\<Longrightarrow> w (T x) = - w x\n 2. j \\<notin> A \\<Longrightarrow> w (T x) = - w x", "with aux[of A j] that"], ["proof (chain)\npicking this:\n  \\<lbrakk>(A, j) \\<in> \\<A>; j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> w (T (A, j)) = - w (A, j)\n  x \\<in> \\<A>\n  j \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(A, j) \\<in> \\<A>; j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> w (T (A, j)) = - w (A, j)\n  x \\<in> \\<A>\n  j \\<in> A\n\ngoal (1 subgoal):\n 1. w (T x) = - w x", "by auto"], ["proof (state)\nthis:\n  w (T x) = - w x\n\ngoal (1 subgoal):\n 1. j \\<notin> A \\<Longrightarrow> w (T x) = - w x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<notin> A \\<Longrightarrow> w (T x) = - w x", "case False"], ["proof (state)\nthis:\n  j \\<notin> A\n\ngoal (1 subgoal):\n 1. j \\<notin> A \\<Longrightarrow> w (T x) = - w x", "hence \"snd (T x) \\<in> fst (T x)\""], ["proof (prove)\nusing this:\n  j \\<notin> A\n\ngoal (1 subgoal):\n 1. snd (T x) \\<in> fst (T x)", "by (auto simp: T_def split: prod.splits)"], ["proof (state)\nthis:\n  snd (T x) \\<in> fst (T x)\n\ngoal (1 subgoal):\n 1. j \\<notin> A \\<Longrightarrow> w (T x) = - w x", "with aux[of \"fst (T x)\" \"snd (T x)\"] that"], ["proof (chain)\npicking this:\n  \\<lbrakk>(fst (T x), snd (T x)) \\<in> \\<A>;\n   snd (T x) \\<in> fst (T x)\\<rbrakk>\n  \\<Longrightarrow> w (T (fst (T x), snd (T x))) =\n                    - w (fst (T x), snd (T x))\n  x \\<in> \\<A>\n  snd (T x) \\<in> fst (T x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(fst (T x), snd (T x)) \\<in> \\<A>;\n   snd (T x) \\<in> fst (T x)\\<rbrakk>\n  \\<Longrightarrow> w (T (fst (T x), snd (T x))) =\n                    - w (fst (T x), snd (T x))\n  x \\<in> \\<A>\n  snd (T x) \\<in> fst (T x)\n\ngoal (1 subgoal):\n 1. w (T x) = - w x", "by auto"], ["proof (state)\nthis:\n  w (T x) = - w x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w (T x) = - w x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> \\<A> \\<Longrightarrow> w (T ?x) = - w ?x\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "text \\<open>\n      We can now show fairly easily that the sum is equal to zero.\n    \\<close>"], ["proof (state)\nthis:\n  ?x \\<in> \\<A> \\<Longrightarrow> w (T ?x) = - w ?x\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have *: \"\\<A> = {x\\<in>\\<A>. snd x \\<in> fst x} \\<union> {x\\<in>\\<A>. snd x \\<notin> fst x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> =\n    {x \\<in> \\<A>. snd x \\<in> fst x} \\<union>\n    {x \\<in> \\<A>. snd x \\<notin> fst x}", "by auto"], ["proof (state)\nthis:\n  \\<A> =\n  {x \\<in> \\<A>. snd x \\<in> fst x} \\<union>\n  {x \\<in> \\<A>. snd x \\<notin> fst x}\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have \"(\\<Sum>x\\<in>\\<A>. w x) = (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x) + (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum w \\<A> =\n    (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x) +\n    (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x)", "using \\<open>finite \\<A>\\<close>"], ["proof (prove)\nusing this:\n  finite \\<A>\n\ngoal (1 subgoal):\n 1. sum w \\<A> =\n    (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x) +\n    (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x)", "by (subst *, subst sum.union_disjoint) auto"], ["proof (state)\nthis:\n  sum w \\<A> =\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x) +\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x)\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "also"], ["proof (state)\nthis:\n  sum w \\<A> =\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x) +\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x)\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have \"(\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x) = (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x) =\n    (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x))", "using sum.reindex_bij_betw[OF bij, of w]"], ["proof (prove)\nusing this:\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x)) =\n  sum w {x \\<in> \\<A>. snd x \\<notin> fst x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x) =\n    (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x) =\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x))\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<notin> fst x. w x) =\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x))\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "have \"\\<dots> = -(\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x)) =\n    - (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x)", "by (simp add: sum_negf)"], ["proof (state)\nthis:\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w (T x)) =\n  - (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x)\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "finally"], ["proof (chain)\npicking this:\n  sum w \\<A> =\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x) +\n  - (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x)", "show \"(\\<Sum>x\\<in>\\<A>. w x) = 0\""], ["proof (prove)\nusing this:\n  sum w \\<A> =\n  (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x) +\n  - (\\<Sum>x | x \\<in> \\<A> \\<and> snd x \\<in> fst x. w x)\n\ngoal (1 subgoal):\n 1. sum w \\<A> = 0", "by simp"], ["proof (state)\nthis:\n  sum w \\<A> = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum w \\<A> = 0\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "finally"], ["proof (chain)\npicking this:\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  0\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * sym_mpoly X k +\n    (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "."], ["proof (state)\nthis:\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following variant of the theorem holds for \\<open>k > n\\<close>. Note that this is now a\n  linear recurrence relation with constant coefficients for $p_k$ in terms of\n  $e_0, \\ldots, e_n$.\n\\<close>"], ["", "corollary Girard_Newton':\n  assumes \"finite X\" and \"k > card X\"\n  shows   \"(\\<Sum>i\\<le>card X. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n             (0 :: 'a :: comm_ring_1 mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>card X.\n        (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>card X.\n        (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "have \"(0 :: 'a mpoly) = (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "using Girard_Newton[of X k] assms"], ["proof (prove)\nusing this:\n  finite X \\<Longrightarrow>\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  0\n  finite X\n  card X < k\n\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "by simp"], ["proof (state)\nthis:\n  0 = (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>card X.\n        (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "also"], ["proof (state)\nthis:\n  0 = (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>card X.\n        (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "have \"\\<dots> = (\\<Sum>i\\<le>card X. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    (\\<Sum>i\\<le>card X. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  card X < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    (\\<Sum>i\\<le>card X. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  (\\<Sum>i\\<le>card X. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>card X.\n        (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", "finally"], ["proof (chain)\npicking this:\n  0 =\n  (\\<Sum>i\\<le>card X. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 =\n  (\\<Sum>i\\<le>card X. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>card X.\n        (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n    0", ".."], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>card X. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following variant is the Newton--Girard Theorem solved for $e_k$, giving us\n  an explicit way to determine $e_k$ from $e_0, \\ldots, e_{k-1}$ and $p_1, \\ldots, p_k$:\n\\<close>"], ["", "corollary sym_mpoly_recurrence:\n  assumes k: \"k > 0\" and \"finite X\"\n  shows   \"(sym_mpoly X k :: 'a :: field_char_0 mpoly) =\n             -smult (1 / of_nat k) (\\<Sum>i=1..k. (-1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "define e p :: \"nat \\<Rightarrow> 'a mpoly\" where [simp]: \"e = sym_mpoly X\" \"p = powsum_mpoly X\""], ["proof (state)\nthis:\n  e = sym_mpoly X\n  p = powsum_mpoly X\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "have *: \"0 = (-1) ^ k * of_nat k * e k +\n              (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i) :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    (- 1) ^ k * of_nat k * e k + (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i))", "using Girard_Newton[of X k] assms"], ["proof (prove)\nusing this:\n  finite X \\<Longrightarrow>\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  0\n  0 < k\n  finite X\n\ngoal (1 subgoal):\n 1. 0 =\n    (- 1) ^ k * of_nat k * e k + (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i))", "by simp"], ["proof (state)\nthis:\n  0 = (- 1) ^ k * of_nat k * e k + (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "have \"0 = (-1) ^ k * smult (1 / of_nat k) (0 :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (- 1) ^ k * MPoly_Type.smult ((1::'a) / of_nat k) 0", "by simp"], ["proof (state)\nthis:\n  0 = (- 1) ^ k * MPoly_Type.smult ((1::'a) / of_nat k) 0\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "also"], ["proof (state)\nthis:\n  0 = (- 1) ^ k * MPoly_Type.smult ((1::'a) / of_nat k) 0\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "have \"\\<dots> = smult (1 / of_nat k) (of_nat k) * e k +\n                  smult (1 / of_nat k) (\\<Sum>i<k. (-1)^(k+i) * e i * p (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * MPoly_Type.smult ((1::'a) / of_nat k) 0 =\n    MPoly_Type.smult ((1::'a) / of_nat k) (of_nat k) * e k +\n    MPoly_Type.smult ((1::'a) / of_nat k)\n     (\\<Sum>i<k. (- 1) ^ (k + i) * e i * p (k - i))", "unfolding smult_conv_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ k * (MPoly_Type.monom 0 ((1::'a) / of_nat k) * 0) =\n    MPoly_Type.monom 0 ((1::'a) / of_nat k) * of_nat k * e k +\n    MPoly_Type.monom 0 ((1::'a) / of_nat k) *\n    (\\<Sum>i<k. (- 1) ^ (k + i) * e i * p (k - i))", "using k"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * (MPoly_Type.monom 0 ((1::'a) / of_nat k) * 0) =\n    MPoly_Type.monom 0 ((1::'a) / of_nat k) * of_nat k * e k +\n    MPoly_Type.monom 0 ((1::'a) / of_nat k) *\n    (\\<Sum>i<k. (- 1) ^ (k + i) * e i * p (k - i))", "by (subst *) (simp add: power_add sum_distrib_left sum_distrib_right field_simps \n                               del: div_mult_self3 div_mult_self4 div_mult_self2 div_mult_self1)"], ["proof (state)\nthis:\n  (- 1) ^ k * MPoly_Type.smult ((1::'a) / of_nat k) 0 =\n  MPoly_Type.smult ((1::'a) / of_nat k) (of_nat k) * e k +\n  MPoly_Type.smult ((1::'a) / of_nat k)\n   (\\<Sum>i<k. (- 1) ^ (k + i) * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "also"], ["proof (state)\nthis:\n  (- 1) ^ k * MPoly_Type.smult ((1::'a) / of_nat k) 0 =\n  MPoly_Type.smult ((1::'a) / of_nat k) (of_nat k) * e k +\n  MPoly_Type.smult ((1::'a) / of_nat k)\n   (\\<Sum>i<k. (- 1) ^ (k + i) * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "have \"smult (1 / of_nat k :: 'a) (of_nat k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.smult ((1::'a) / of_nat k) (of_nat k) = 1", "using k"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. MPoly_Type.smult ((1::'a) / of_nat k) (of_nat k) = 1", "by (simp add: of_nat_monom smult_conv_mult mult_monom del: monom_of_nat)"], ["proof (state)\nthis:\n  MPoly_Type.smult ((1::'a) / of_nat k) (of_nat k) = 1\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "also"], ["proof (state)\nthis:\n  MPoly_Type.smult ((1::'a) / of_nat k) (of_nat k) = 1\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "have \"(\\<Sum>i<k. (-1) ^ (k+i) * e i * p (k - i)) = (\\<Sum>i=1..k. (-1) ^ i * e (k-i) * p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k. (- 1) ^ (k + i) * e i * p (k - i)) =\n    (\\<Sum>i = 1..k. (- 1) ^ i * e (k - i) * p i)", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>i. k - i\" \"\\<lambda>i. k - i\"])\n       (auto simp: minus_one_power_iff)"], ["proof (state)\nthis:\n  (\\<Sum>i<k. (- 1) ^ (k + i) * e i * p (k - i)) =\n  (\\<Sum>i = 1..k. (- 1) ^ i * e (k - i) * p i)\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "finally"], ["proof (chain)\npicking this:\n  0 =\n  1 * e k +\n  MPoly_Type.smult ((1::'a) / of_nat k)\n   (\\<Sum>i = 1..k. (- 1) ^ i * e (k - i) * p i)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 =\n  1 * e k +\n  MPoly_Type.smult ((1::'a) / of_nat k)\n   (\\<Sum>i = 1..k. (- 1) ^ i * e (k - i) * p i)\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "unfolding e_p_def"], ["proof (prove)\nusing this:\n  0 =\n  1 * sym_mpoly X k +\n  MPoly_Type.smult ((1::'a) / of_nat k)\n   (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)\n\ngoal (1 subgoal):\n 1. sym_mpoly X k =\n    - MPoly_Type.smult ((1::'a) / of_nat k)\n       (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)", "by algebra"], ["proof (state)\nthis:\n  sym_mpoly X k =\n  - MPoly_Type.smult ((1::'a) / of_nat k)\n     (\\<Sum>i = 1..k. (- 1) ^ i * sym_mpoly X (k - i) * powsum_mpoly X i)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Analogously, the following is the theorem solved for $p_k$, giving us a\n  way to determine $p_k$ from $e_0, \\ldots, e_k$ and $p_1, \\ldots, p_{k-1}$:\n\\<close>"], ["", "corollary powsum_mpoly_recurrence:\n  assumes k: \"k > 0\" and X: \"finite X\"\n  shows   \"(powsum_mpoly X k :: 'a :: comm_ring_1 mpoly) =\n             (-1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n             (\\<Sum>i=1..<k. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "define e p :: \"nat \\<Rightarrow> 'a mpoly\" where [simp]: \"e = sym_mpoly X\" \"p = powsum_mpoly X\""], ["proof (state)\nthis:\n  e = sym_mpoly X\n  p = powsum_mpoly X\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have *: \"0 = (-1) ^ k * of_nat k * e k +\n                 (\\<Sum>i<k. (-1) ^ i * e i * p (k - i) :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    (- 1) ^ k * of_nat k * e k + (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i))", "using Girard_Newton[of X k] assms"], ["proof (prove)\nusing this:\n  finite X \\<Longrightarrow>\n  (- 1) ^ k * of_nat k * sym_mpoly X k +\n  (\\<Sum>i<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i)) =\n  0\n  0 < k\n  finite X\n\ngoal (1 subgoal):\n 1. 0 =\n    (- 1) ^ k * of_nat k * e k + (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i))", "by simp"], ["proof (state)\nthis:\n  0 = (- 1) ^ k * of_nat k * e k + (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  0 = (- 1) ^ k * of_nat k * e k + (\\<Sum>i<k. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"{..<k} = insert 0 {1..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<k} = insert 0 {1..<k}", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  finite X\n\ngoal (1 subgoal):\n 1. {..<k} = insert 0 {1..<k}", "by auto"], ["proof (state)\nthis:\n  {..<k} = insert 0 {1..<k}\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "finally"], ["proof (chain)\npicking this:\n  0 =\n  (- 1) ^ k * of_nat k * e k +\n  (\\<Sum>i\\<in>insert 0 {1..<k}. (- 1) ^ i * e i * p (k - i))", "have \"(-1) ^ k * of_nat k * e k + (\\<Sum>i=1..<k. (-1) ^ i * e i * p (k - i)) + p k = 0\""], ["proof (prove)\nusing this:\n  0 =\n  (- 1) ^ k * of_nat k * e k +\n  (\\<Sum>i\\<in>insert 0 {1..<k}. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * e k +\n    (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) +\n    p k =\n    0", "using assms"], ["proof (prove)\nusing this:\n  0 =\n  (- 1) ^ k * of_nat k * e k +\n  (\\<Sum>i\\<in>insert 0 {1..<k}. (- 1) ^ i * e i * p (k - i))\n  0 < k\n  finite X\n\ngoal (1 subgoal):\n 1. (- 1) ^ k * of_nat k * e k +\n    (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) +\n    p k =\n    0", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (- 1) ^ k * of_nat k * e k +\n  (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) +\n  p k =\n  0\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "from add.inverse_unique[OF this]"], ["proof (chain)\npicking this:\n  - ((- 1) ^ k * of_nat k * e k +\n     (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))) =\n  p k", "show ?thesis"], ["proof (prove)\nusing this:\n  - ((- 1) ^ k * of_nat k * e k +\n     (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))) =\n  p k\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "by simp"], ["proof (state)\nthis:\n  powsum_mpoly X k =\n  (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n  (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Again, if we assume $k > n$, the above takes a much simpler form and is, in fact,\n  a linear recurrence with constant coefficients:\n\\<close>"], ["", "lemma powsum_mpoly_recurrence':\n  assumes k: \"k > card X\" and X: \"finite X\"\n  shows   \"(powsum_mpoly X k :: 'a :: comm_ring_1 mpoly) =\n             -(\\<Sum>i=1..card X. (-1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "define e p :: \"nat \\<Rightarrow> 'a mpoly\" where [simp]: \"e = sym_mpoly X\" \"p = powsum_mpoly X\""], ["proof (state)\nthis:\n  e = sym_mpoly X\n  p = powsum_mpoly X\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"p k = (-1) ^ (k + 1) * of_nat k * e k - (\\<Sum>i=1..<k. (-1) ^ i * e i * p (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p k =\n    (- 1) ^ (k + 1) * of_nat k * e k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))", "unfolding e_p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "using assms"], ["proof (prove)\nusing this:\n  card X < k\n  finite X\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    (- 1) ^ (k + 1) * of_nat k * sym_mpoly X k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "by (intro powsum_mpoly_recurrence) auto"], ["proof (state)\nthis:\n  p k =\n  (- 1) ^ (k + 1) * of_nat k * e k -\n  (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  p k =\n  (- 1) ^ (k + 1) * of_nat k * e k -\n  (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"\\<dots> = -(\\<Sum>i=1..<k. (-1) ^ i * e i * p (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (k + 1) * of_nat k * e k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) =\n    - (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))", "using assms"], ["proof (prove)\nusing this:\n  card X < k\n  finite X\n\ngoal (1 subgoal):\n 1. (- 1) ^ (k + 1) * of_nat k * e k -\n    (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) =\n    - (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ (k + 1) * of_nat k * e k -\n  (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) =\n  - (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "also"], ["proof (state)\nthis:\n  (- 1) ^ (k + 1) * of_nat k * e k -\n  (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) =\n  - (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "have \"(\\<Sum>i=1..<k. (-1) ^ i * e i * p (k - i)) = (\\<Sum>i=1..card X. (-1) ^ i * e i * p (k - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) =\n    (\\<Sum>i = 1..card X. (- 1) ^ i * e i * p (k - i))", "using assms"], ["proof (prove)\nusing this:\n  card X < k\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) =\n    (\\<Sum>i = 1..card X. (- 1) ^ i * e i * p (k - i))", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 1..<k. (- 1) ^ i * e i * p (k - i)) =\n  (\\<Sum>i = 1..card X. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "finally"], ["proof (chain)\npicking this:\n  p k = - (\\<Sum>i = 1..card X. (- 1) ^ i * e i * p (k - i))", "show ?thesis"], ["proof (prove)\nusing this:\n  p k = - (\\<Sum>i = 1..card X. (- 1) ^ i * e i * p (k - i))\n\ngoal (1 subgoal):\n 1. powsum_mpoly X k =\n    - (\\<Sum>i = 1..card X.\n          (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))", "by simp"], ["proof (state)\nthis:\n  powsum_mpoly X k =\n  - (\\<Sum>i = 1..card X.\n        (- 1) ^ i * sym_mpoly X i * powsum_mpoly X (k - i))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}