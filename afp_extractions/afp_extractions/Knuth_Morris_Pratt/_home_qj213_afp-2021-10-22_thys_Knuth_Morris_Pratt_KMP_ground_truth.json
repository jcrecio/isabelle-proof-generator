{"file_name": "/home/qj213/afp-2021-10-22/thys/Knuth_Morris_Pratt/KMP.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Knuth_Morris_Pratt", "problem_names": ["lemma \"i \\<le> length ys \\<Longrightarrow> sublist_at xs ys i \\<longleftrightarrow> sublist_at' xs ys i\"", "lemma sublist_lengths: \"sublist_at xs ys i \\<Longrightarrow> i + length xs \\<le> length ys\"", "lemma Nil_is_sublist: \"sublist_at ([] :: 'x list) ys i \\<longleftrightarrow> i \\<le> length ys\"", "lemma sublist_step[intro]:\n  \"\\<lbrakk>i + length xs < length ys; sublist_at xs ys i; ys!(i + length xs) = x\\<rbrakk> \\<Longrightarrow> sublist_at (xs@[x]) ys i\"", "lemma all_positions_sublist:\n\"\\<lbrakk>i + length xs \\<le> length ys; \\<forall>jj<length xs. ys!(i+jj) = xs!jj\\<rbrakk> \\<Longrightarrow> sublist_at xs ys i\"", "lemma sublist_all_positions: \"sublist_at xs ys i \\<Longrightarrow> \\<forall>jj<length xs. ys!(i+jj) = xs!jj\"", "lemma sublist_at_altdef:\n  \"sublist_at xs ys i \\<longleftrightarrow> (\\<exists>ps ss. ys = ps@xs@ss \\<and> i = length ps)\"", "lemma is_arg_min_id: \"is_arg_min id P i \\<longleftrightarrow> P i \\<and> (\\<forall>ii<i. \\<not>P ii)\"", "lemma kmp_result: \"kmp_SPEC s t =\n  RETURN (if sublist s t then Some (LEAST i. sublist_at s t i) else None)\"", "lemmas kmp_SPEC_altdefs =\n  kmp_SPEC_def[folded is_arg_min_id]\n  kmp_SPEC_def[folded sublist_iff_sublist_at]\n  kmp_result", "lemma \"s \\<noteq> [] \\<Longrightarrow> naive_algorithm s t \\<le> kmp_SPEC s t\"", "lemma borderE[elim]:\n  fixes xs ys :: \"'a list\"\n  assumes \"border xs ys\"\n  obtains \"prefix xs ys\" and \"suffix xs ys\"", "lemma strict_borderE[elim]:\n  fixes xs ys :: \"'a list\"\n  assumes \"strict_border xs ys\"\n  obtains \"border xs ys\" and \"length xs < length ys\"", "lemma strict_border_simps[simp]:\n  \"strict_border xs [] \\<longleftrightarrow> False\"\n  \"strict_border [] (x # xs) \\<longleftrightarrow> True\"", "lemma strict_border_prefix: \"strict_border xs ys \\<Longrightarrow> strict_prefix xs ys\"\n  and strict_border_suffix: \"strict_border xs ys \\<Longrightarrow> strict_suffix xs ys\"\n  and strict_border_imp_nonempty: \"strict_border xs ys \\<Longrightarrow> ys \\<noteq> []\"\n  and strict_border_prefix_suffix: \"strict_border xs ys \\<longleftrightarrow> strict_prefix xs ys \\<and> strict_suffix xs ys\"", "lemma border_length_le: \"border xs ys \\<Longrightarrow> length xs \\<le> length ys\"", "lemma border_length_r_less (*rm*): \"\\<forall>xs. strict_border xs ys \\<longrightarrow> length xs < length ys\"", "lemma border_positions: \"border xs ys \\<Longrightarrow> \\<forall>i<length xs. ys!i = ys!(length ys - length xs + i)\"", "lemma all_positions_drop_length_take: \"\\<lbrakk>i \\<le> length w; i \\<le> length x;\n  \\<forall>j<i. x ! j = w ! (length w + j - i)\\<rbrakk>\n    \\<Longrightarrow> drop (length w - i) w = take i x\"", "lemma all_positions_suffix_take: \"\\<lbrakk>i \\<le> length w; i \\<le> length x;\n  \\<forall>j<i. x ! j = w ! (length w + j - i)\\<rbrakk>\n    \\<Longrightarrow> suffix (take i x) w\"", "lemma suffix_butlast: \"suffix xs ys \\<Longrightarrow> suffix (butlast xs) (butlast ys)\"", "lemma positions_border: \"\\<forall>j<l. w!j = w!(length w - l + j) \\<Longrightarrow> border (take l w) w\"", "lemma positions_strict_border: \"l < length w \\<Longrightarrow> \\<forall>j<l. w!j = w!(length w - l + j) \\<Longrightarrow> strict_border (take l w) w\"", "lemmas intrinsic_borderI = arg_max_natI[OF _ border_length_r_less, folded intrinsic_border_def]", "lemmas intrinsic_borderI' = border_bot.bot.not_eq_extremum[THEN iffD1, THEN intrinsic_borderI]", "lemmas intrinsic_border_max = arg_max_nat_le[OF _ border_length_r_less, folded intrinsic_border_def]", "lemma nonempty_is_arg_max_ib: \"ys \\<noteq> [] \\<Longrightarrow> is_arg_max length (\\<lambda>xs. strict_border xs ys) (intrinsic_border ys)\"", "lemma intrinsic_border_less: \"w \\<noteq> [] \\<Longrightarrow> length (intrinsic_border w) < length w\"", "lemma intrinsic_border_take_less: \"j > 0 \\<Longrightarrow> w \\<noteq> [] \\<Longrightarrow> length (intrinsic_border (take j w)) < length w\"", "lemma border_example: \"{b. border b ''aabaabaa''} = {'''', ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\"\n  (is \"{b. border b ?l} = {?take0, ?take1, ?take2, ?take5, ?l}\")", "lemma \\<ff>_eq_0_iff_j_eq_0[simp]: \"\\<ff> s j = 0 \\<longleftrightarrow> j = 0\"", "lemma j_le_\\<ff>_le: \"j \\<le> length s \\<Longrightarrow> \\<ff> s j \\<le> j\"", "lemma j_le_\\<ff>_le': \"0 < j \\<Longrightarrow> j \\<le> length s \\<Longrightarrow> \\<ff> s j - 1 < j\"", "lemma \\<ff>_le: \"s \\<noteq> [] \\<Longrightarrow> \\<ff> s j - 1 < length s\"", "lemma reuse_matches: \n  assumes j_le: \"j \\<le> length s\"\n  and old_matches: \"\\<forall>jj<j. t ! (i + jj) = s ! jj\"\n  shows \"\\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\"\n    (is \"\\<forall>jj<?j'. t ! (?i' + jj) = s ! jj\")", "theorem shift_safe:\n  assumes\n    \"\\<forall>ii<i. \\<not>sublist_at s t ii\"\n    \"t!(i+j) \\<noteq> s!j\" and\n    [simp]: \"j < length s\" and\n    matches: \"\\<forall>jj<j. t!(i+jj) = s!jj\"\n  defines\n    assignment: \"i' \\<equiv> i + (j - \\<ff> s j + 1)\"\n  shows\n    \"\\<forall>ii<i'. \\<not>sublist_at s t ii\"", "lemma kmp_correct: \"s \\<noteq> []\n  \\<Longrightarrow> kmp s t \\<le> kmp_SPEC s t\"", "lemma \\<ff>_butlast[simp]: \"j < length s \\<Longrightarrow> \\<ff> (butlast s) j = \\<ff> s j\"", "lemma kmp1_refine: \"kmp1 s t \\<le> kmp s t\"", "lemma take_length_ib[simp]:\n  assumes \"0 < j\" \"j \\<le> length s\"\n    shows \"take (length (intrinsic_border (take j s))) s = intrinsic_border (take j s)\"", "lemma ib_singleton[simp]: \"intrinsic_border [z] = []\"", "lemma border_butlast: \"border xs ys \\<Longrightarrow> border (butlast xs) (butlast ys)\"", "lemma border_take_lengths: \"i \\<le> length s \\<Longrightarrow> border (take i s) (take j s) \\<Longrightarrow> i \\<le> j\"", "lemma border_step: \"border xs ys \\<longleftrightarrow> border (xs@[ys!length xs]) (ys@[ys!length xs])\"", "lemma ib_butlast: \"length w \\<ge> 2 \\<Longrightarrow> length (intrinsic_border w) \\<le> length (intrinsic_border (butlast w)) + 1\"", "lemma \\<ff>_step_bound(*rm*):\n  assumes \"j \\<le> length w\"\n  shows \"\\<ff> w j \\<le> \\<ff> w (j-1) + 1\"", "lemma border_take_\\<ff>: \"border (take (\\<ff> s i - 1) s ) (take i s)\"", "lemma \\<ff>_is_max: \"j \\<le> length s \\<Longrightarrow> strict_border b (take j s) \\<Longrightarrow> \\<ff> s j \\<ge> length b + 1\"", "theorem skipping_ok:\n  assumes j_bounds[simp]: \"1 < j\" \"j \\<le> length s\"\n    and mismatch: \"s!(i-1) \\<noteq> s!(j-1)\"\n    and greater_checked: \"\\<ff> s j \\<le> i + 1\"\n    and \"strict_border (take (i-1) s) (take (j-1) s)\"\n  shows \"\\<ff> s j \\<le> \\<ff> s (i-1) + 1\"", "lemma extend_border:\n  assumes \"j \\<le> length s\"\n  assumes \"s!(i-1) = s!(j-1)\"\n  assumes \"strict_border (take (i-1) s) (take (j-1) s)\"\n  assumes \"\\<ff> s j \\<le> i + 1\"\n  shows \"\\<ff> s j = i + 1\"", "lemma compute_\\<ff>s_correct: \"compute_\\<ff>s s \\<le> compute_\\<ff>s_SPEC s\"", "lemma compute_\\<ff>s_inner_bounds: \n  assumes \"I_out_cb s (\\<ff>s,ix,j)\"\n  assumes \"j < length \\<ff>s\"\n  assumes \"I_in_cb s j i\"\n  shows \"i-1 < length s\" \"j-1 < length s\"", "lemma compute_butlast_\\<ff>s_refine[refine]:\n  assumes \"(s,s') \\<in> br butlast ((\\<noteq>) [])\"\n  shows \"compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')\"", "lemma kmp2_refine: \"kmp2 s t \\<le> kmp1 s t\"", "lemma kmp2_correct: \"s \\<noteq> []\n  \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t\"", "lemma kmp3_correct: \"kmp3 s t \\<le> kmp_SPEC s t\"", "lemma eq_id_param: \"((=), (=)) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\"", "lemmas in_bounds_aux = compute_\\<ff>s_inner_bounds[of \"butlast s\" for s, simplified]", "lemma kmp_inner_in_bound:\n  assumes \"i + length s \\<le> length t\"\n  assumes \"I_in_na s t i (j,None)\"\n  shows \"i + j < length t\" \"j < length s\"", "lemma kmp3_correct':\n  \"(uncurry kmp3, uncurry kmp_SPEC) \\<in> Id \\<times>\\<^sub>r Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\"", "lemmas kmp_impl_correct' = kmp_impl.refine[FCOMP kmp3_correct']", "theorem kmp_impl_correct:\n  \"< arl_assn id_assn s si * arl_assn id_assn t ti > \n       kmp_impl si ti \n   <\\<lambda>r. arl_assn id_assn s si * arl_assn id_assn t ti * \\<up>(\n      case r of None \\<Rightarrow>  \\<nexists>i. sublist_at s t i\n              | Some i \\<Rightarrow> sublist_at s t i \\<and> (\\<forall>ii<i. \\<not> sublist_at s t ii)\n    )>\\<^sub>t\""], "translations": [["", "lemma \"i \\<le> length ys \\<Longrightarrow> sublist_at xs ys i \\<longleftrightarrow> sublist_at' xs ys i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length ys \\<Longrightarrow>\n    sublist_at xs ys i = sublist_at' xs ys i", "unfolding sublist_at'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length ys \\<Longrightarrow>\n    sublist_at xs ys i = (take (length xs) (drop i ys) = xs)", "by (induction xs ys i rule: sublist_at.induct) auto"], ["", "text\\<open>However, the new definition has some reasonable properties:\\<close>"], ["", "subsubsection\\<open>Properties\\<close>"], ["", "lemma sublist_lengths: \"sublist_at xs ys i \\<Longrightarrow> i + length xs \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist_at xs ys i \\<Longrightarrow> i + length xs \\<le> length ys", "by (induction xs ys i rule: sublist_at.induct) auto"], ["", "lemma Nil_is_sublist: \"sublist_at ([] :: 'x list) ys i \\<longleftrightarrow> i \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist_at [] ys i = (i \\<le> length ys)", "by (induction \"[] :: 'x list\" ys i rule: sublist_at.induct) auto"], ["", "text\\<open>Furthermore, we need:\\<close>"], ["", "lemma sublist_step[intro]:\n  \"\\<lbrakk>i + length xs < length ys; sublist_at xs ys i; ys!(i + length xs) = x\\<rbrakk> \\<Longrightarrow> sublist_at (xs@[x]) ys i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i + length xs < length ys; sublist_at xs ys i;\n     ys ! (i + length xs) = x\\<rbrakk>\n    \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "apply (induction xs ys i rule: sublist_at.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa xs y ys.\n       \\<lbrakk>\\<lbrakk>0 + length xs < length ys; sublist_at xs ys 0;\n                 ys ! (0 + length xs) = x\\<rbrakk>\n                \\<Longrightarrow> sublist_at (xs @ [x]) ys 0;\n        0 + length (xa # xs) < length (y # ys);\n        sublist_at (xa # xs) (y # ys) 0;\n        (y # ys) ! (0 + length (xa # xs)) = x\\<rbrakk>\n       \\<Longrightarrow> sublist_at ((xa # xs) @ [x]) (y # ys) 0\n 2. \\<And>xs y ys i.\n       \\<lbrakk>\\<lbrakk>i + length xs < length ys; sublist_at xs ys i;\n                 ys ! (i + length xs) = x\\<rbrakk>\n                \\<Longrightarrow> sublist_at (xs @ [x]) ys i;\n        Suc i + length xs < length (y # ys); sublist_at xs (y # ys) (Suc i);\n        (y # ys) ! (Suc i + length xs) = x\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) (y # ys) (Suc i)\n 3. \\<And>ys.\n       \\<lbrakk>0 + length [] < length ys; sublist_at [] ys 0;\n        ys ! (0 + length []) = x\\<rbrakk>\n       \\<Longrightarrow> sublist_at ([] @ [x]) ys 0\n 4. \\<And>v va uv_.\n       \\<lbrakk>uv_ + length (v # va) < length [];\n        sublist_at (v # va) [] uv_;\n        [] ! (uv_ + length (v # va)) = x\\<rbrakk>\n       \\<Longrightarrow> sublist_at ((v # va) @ [x]) [] uv_\n 5. \\<And>uu_ v.\n       \\<lbrakk>Suc v + length uu_ < length []; sublist_at uu_ [] (Suc v);\n        [] ! (Suc v + length uu_) = x\\<rbrakk>\n       \\<Longrightarrow> sublist_at (uu_ @ [x]) [] (Suc v)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>ys \\<noteq> []; x = ys ! 0\\<rbrakk>\n       \\<Longrightarrow> sublist_at [ys ! 0] ys 0", "using sublist_at.elims(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> sublist_at ?x ?xa ?xb;\n   \\<And>x xs y ys.\n      \\<lbrakk>?x = x # xs; ?xa = y # ys; ?xb = 0;\n       \\<not> (x = y \\<and> sublist_at xs ys 0)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>xs y ys i.\n      \\<lbrakk>?x = xs; ?xa = y # ys; ?xb = Suc i;\n       \\<not> sublist_at xs ys i\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va uv_.\n      \\<lbrakk>?x = v # va; ?xa = []; ?xb = uv_\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uu_ v.\n      \\<lbrakk>?x = uu_; ?xa = []; ?xb = Suc v\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>ys \\<noteq> []; x = ys ! 0\\<rbrakk>\n       \\<Longrightarrow> sublist_at [ys ! 0] ys 0", "by fastforce"], ["", "lemma all_positions_sublist:\n\"\\<lbrakk>i + length xs \\<le> length ys; \\<forall>jj<length xs. ys!(i+jj) = xs!jj\\<rbrakk> \\<Longrightarrow> sublist_at xs ys i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i + length xs \\<le> length ys;\n     \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n    \\<Longrightarrow> sublist_at xs ys i", "proof (induction xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i + length [] \\<le> length ys;\n     \\<forall>jj<length []. ys ! (i + jj) = [] ! jj\\<rbrakk>\n    \\<Longrightarrow> sublist_at [] ys i\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "case Nil"], ["proof (state)\nthis:\n  i + length [] \\<le> length ys\n  \\<forall>jj<length []. ys ! (i + jj) = [] ! jj\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i + length [] \\<le> length ys;\n     \\<forall>jj<length []. ys ! (i + jj) = [] ! jj\\<rbrakk>\n    \\<Longrightarrow> sublist_at [] ys i\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "then"], ["proof (chain)\npicking this:\n  i + length [] \\<le> length ys\n  \\<forall>jj<length []. ys ! (i + jj) = [] ! jj", "show ?case"], ["proof (prove)\nusing this:\n  i + length [] \\<le> length ys\n  \\<forall>jj<length []. ys ! (i + jj) = [] ! jj\n\ngoal (1 subgoal):\n 1. sublist_at [] ys i", "by (simp add: Nil_is_sublist)"], ["proof (state)\nthis:\n  sublist_at [] ys i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>i + length xs \\<le> length ys;\n   \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n  \\<Longrightarrow> sublist_at xs ys i\n  i + length (xs @ [x]) \\<le> length ys\n  \\<forall>jj<length (xs @ [x]). ys ! (i + jj) = (xs @ [x]) ! jj\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "from \\<open>i + length (xs @ [x]) \\<le> length ys\\<close>"], ["proof (chain)\npicking this:\n  i + length (xs @ [x]) \\<le> length ys", "have \"i + length xs \\<le> length ys\""], ["proof (prove)\nusing this:\n  i + length (xs @ [x]) \\<le> length ys\n\ngoal (1 subgoal):\n 1. i + length xs \\<le> length ys", "by simp"], ["proof (state)\nthis:\n  i + length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "moreover"], ["proof (state)\nthis:\n  i + length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "have \"\\<forall>jj<length xs. ys!(i + jj) = xs!jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj", "by (simp add: nth_append snoc.prems(2))"], ["proof (state)\nthis:\n  \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "ultimately"], ["proof (chain)\npicking this:\n  i + length xs \\<le> length ys\n  \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj", "have \"sublist_at xs ys i\""], ["proof (prove)\nusing this:\n  i + length xs \\<le> length ys\n  \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\n\ngoal (1 subgoal):\n 1. sublist_at xs ys i", "using snoc.IH"], ["proof (prove)\nusing this:\n  i + length xs \\<le> length ys\n  \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\n  \\<lbrakk>i + length xs \\<le> length ys;\n   \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n  \\<Longrightarrow> sublist_at xs ys i\n\ngoal (1 subgoal):\n 1. sublist_at xs ys i", "by simp"], ["proof (state)\nthis:\n  sublist_at xs ys i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>i + length xs \\<le> length ys;\n                 \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj\\<rbrakk>\n                \\<Longrightarrow> sublist_at xs ys i;\n        i + length (xs @ [x]) \\<le> length ys;\n        \\<forall>jj<length (xs @ [x]).\n           ys ! (i + jj) = (xs @ [x]) ! jj\\<rbrakk>\n       \\<Longrightarrow> sublist_at (xs @ [x]) ys i", "then"], ["proof (chain)\npicking this:\n  sublist_at xs ys i", "show ?case"], ["proof (prove)\nusing this:\n  sublist_at xs ys i\n\ngoal (1 subgoal):\n 1. sublist_at (xs @ [x]) ys i", "using snoc.prems"], ["proof (prove)\nusing this:\n  sublist_at xs ys i\n  i + length (xs @ [x]) \\<le> length ys\n  \\<forall>jj<length (xs @ [x]). ys ! (i + jj) = (xs @ [x]) ! jj\n\ngoal (1 subgoal):\n 1. sublist_at (xs @ [x]) ys i", "by auto"], ["proof (state)\nthis:\n  sublist_at (xs @ [x]) ys i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sublist_all_positions: \"sublist_at xs ys i \\<Longrightarrow> \\<forall>jj<length xs. ys!(i+jj) = xs!jj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist_at xs ys i \\<Longrightarrow>\n    \\<forall>jj<length xs. ys ! (i + jj) = xs ! jj", "by (induction xs ys i rule: sublist_at.induct) (auto simp: nth_Cons')"], ["", "text\\<open>It also connects well to theory @{theory \"HOL-Library.Sublist\"} (compare @{thm[source] sublist_def}):\\<close>"], ["", "lemma sublist_at_altdef:\n  \"sublist_at xs ys i \\<longleftrightarrow> (\\<exists>ps ss. ys = ps@xs@ss \\<and> i = length ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist_at xs ys i =\n    (\\<exists>ps ss. ys = ps @ xs @ ss \\<and> i = length ps)", "proof (induction xs ys i rule: sublist_at.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xs y ys.\n       sublist_at xs ys 0 =\n       (\\<exists>ps ss.\n           ys = ps @ xs @ ss \\<and> 0 = length ps) \\<Longrightarrow>\n       sublist_at (x # xs) (y # ys) 0 =\n       (\\<exists>ps ss. y # ys = ps @ (x # xs) @ ss \\<and> 0 = length ps)\n 2. \\<And>xs y ys i.\n       sublist_at xs ys i =\n       (\\<exists>ps ss.\n           ys = ps @ xs @ ss \\<and> i = length ps) \\<Longrightarrow>\n       sublist_at xs (y # ys) (Suc i) =\n       (\\<exists>ps ss. y # ys = ps @ xs @ ss \\<and> Suc i = length ps)\n 3. \\<And>ys.\n       sublist_at [] ys 0 =\n       (\\<exists>ps ss. ys = ps @ [] @ ss \\<and> 0 = length ps)\n 4. \\<And>v va uv_.\n       sublist_at (v # va) [] uv_ =\n       (\\<exists>ps ss. [] = ps @ (v # va) @ ss \\<and> uv_ = length ps)\n 5. \\<And>uu_ v.\n       sublist_at uu_ [] (Suc v) =\n       (\\<exists>ps ss. [] = ps @ uu_ @ ss \\<and> Suc v = length ps)", "case (2 ss t ts i)"], ["proof (state)\nthis:\n  sublist_at ss ts i =\n  (\\<exists>ps ssa. ts = ps @ ss @ ssa \\<and> i = length ps)\n\ngoal (5 subgoals):\n 1. \\<And>x xs y ys.\n       sublist_at xs ys 0 =\n       (\\<exists>ps ss.\n           ys = ps @ xs @ ss \\<and> 0 = length ps) \\<Longrightarrow>\n       sublist_at (x # xs) (y # ys) 0 =\n       (\\<exists>ps ss. y # ys = ps @ (x # xs) @ ss \\<and> 0 = length ps)\n 2. \\<And>xs y ys i.\n       sublist_at xs ys i =\n       (\\<exists>ps ss.\n           ys = ps @ xs @ ss \\<and> i = length ps) \\<Longrightarrow>\n       sublist_at xs (y # ys) (Suc i) =\n       (\\<exists>ps ss. y # ys = ps @ xs @ ss \\<and> Suc i = length ps)\n 3. \\<And>ys.\n       sublist_at [] ys 0 =\n       (\\<exists>ps ss. ys = ps @ [] @ ss \\<and> 0 = length ps)\n 4. \\<And>v va uv_.\n       sublist_at (v # va) [] uv_ =\n       (\\<exists>ps ss. [] = ps @ (v # va) @ ss \\<and> uv_ = length ps)\n 5. \\<And>uu_ v.\n       sublist_at uu_ [] (Suc v) =\n       (\\<exists>ps ss. [] = ps @ uu_ @ ss \\<and> Suc v = length ps)", "show \"sublist_at ss (t#ts) (Suc i) \\<longleftrightarrow> (\\<exists>xs ys. t#ts = xs@ss@ys \\<and> Suc i = length xs)\"\n    (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist_at ss (t # ts) (Suc i) =\n    (\\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sublist_at ss (t # ts) (Suc i) \\<Longrightarrow>\n    \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n 2. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "assume ?lhs"], ["proof (state)\nthis:\n  sublist_at ss (t # ts) (Suc i)\n\ngoal (2 subgoals):\n 1. sublist_at ss (t # ts) (Suc i) \\<Longrightarrow>\n    \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n 2. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "then"], ["proof (chain)\npicking this:\n  sublist_at ss (t # ts) (Suc i)", "have \"sublist_at ss ts i\""], ["proof (prove)\nusing this:\n  sublist_at ss (t # ts) (Suc i)\n\ngoal (1 subgoal):\n 1. sublist_at ss ts i", "by simp"], ["proof (state)\nthis:\n  sublist_at ss ts i\n\ngoal (2 subgoals):\n 1. sublist_at ss (t # ts) (Suc i) \\<Longrightarrow>\n    \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n 2. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "with \"2.IH\""], ["proof (chain)\npicking this:\n  sublist_at ss ts i =\n  (\\<exists>ps ssa. ts = ps @ ss @ ssa \\<and> i = length ps)\n  sublist_at ss ts i", "obtain xs where \"\\<exists>ys. ts = xs@ss@ys \\<and> i = length xs\""], ["proof (prove)\nusing this:\n  sublist_at ss ts i =\n  (\\<exists>ps ssa. ts = ps @ ss @ ssa \\<and> i = length ps)\n  sublist_at ss ts i\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<exists>ys.\n           ts = xs @ ss @ ys \\<and> i = length xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<exists>ys. ts = xs @ ss @ ys \\<and> i = length xs\n\ngoal (2 subgoals):\n 1. sublist_at ss (t # ts) (Suc i) \\<Longrightarrow>\n    \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n 2. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys. ts = xs @ ss @ ys \\<and> i = length xs", "have \"\\<exists>ys. t#ts = (t#xs)@ss@ys \\<and> Suc i = length (t#xs)\""], ["proof (prove)\nusing this:\n  \\<exists>ys. ts = xs @ ss @ ys \\<and> i = length xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys. t # ts = (t # xs) @ ss @ ys \\<and> Suc i = length (t # xs)", "by simp"], ["proof (state)\nthis:\n  \\<exists>ys. t # ts = (t # xs) @ ss @ ys \\<and> Suc i = length (t # xs)\n\ngoal (2 subgoals):\n 1. sublist_at ss (t # ts) (Suc i) \\<Longrightarrow>\n    \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n 2. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys. t # ts = (t # xs) @ ss @ ys \\<and> Suc i = length (t # xs)", "show ?rhs"], ["proof (prove)\nusing this:\n  \\<exists>ys. t # ts = (t # xs) @ ss @ ys \\<and> Suc i = length (t # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs", "obtain xs where \"\\<exists>ys. t#ts = xs@ss@ys \\<and> length xs = Suc i\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<exists>ys.\n           t # ts = xs @ ss @ ys \\<and> length xs = Suc i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: sym)"], ["proof (state)\nthis:\n  \\<exists>ys. t # ts = xs @ ss @ ys \\<and> length xs = Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys. t # ts = xs @ ss @ ys \\<and> length xs = Suc i", "have \"\\<exists>ys. ts = (tl xs)@ss@ys \\<and> i = length (tl xs)\""], ["proof (prove)\nusing this:\n  \\<exists>ys. t # ts = xs @ ss @ ys \\<and> length xs = Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>ys. ts = tl xs @ ss @ ys \\<and> i = length (tl xs)", "by (auto simp add: length_Suc_conv)"], ["proof (state)\nthis:\n  \\<exists>ys. ts = tl xs @ ss @ ys \\<and> i = length (tl xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys. ts = tl xs @ ss @ ys \\<and> i = length (tl xs)", "have \"\\<exists>xs ys. ts = xs@ss@ys \\<and> i = length xs\""], ["proof (prove)\nusing this:\n  \\<exists>ys. ts = tl xs @ ss @ ys \\<and> i = length (tl xs)\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys. ts = xs @ ss @ ys \\<and> i = length xs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs ys. ts = xs @ ss @ ys \\<and> i = length xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       t # ts = xs @ ss @ ys \\<and> Suc i = length xs \\<Longrightarrow>\n    sublist_at ss (t # ts) (Suc i)", "with \"2.IH\""], ["proof (chain)\npicking this:\n  sublist_at ss ts i =\n  (\\<exists>ps ssa. ts = ps @ ss @ ssa \\<and> i = length ps)\n  \\<exists>xs ys. ts = xs @ ss @ ys \\<and> i = length xs", "show ?lhs"], ["proof (prove)\nusing this:\n  sublist_at ss ts i =\n  (\\<exists>ps ssa. ts = ps @ ss @ ssa \\<and> i = length ps)\n  \\<exists>xs ys. ts = xs @ ss @ ys \\<and> i = length xs\n\ngoal (1 subgoal):\n 1. sublist_at ss (t # ts) (Suc i)", "by simp"], ["proof (state)\nthis:\n  sublist_at ss (t # ts) (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sublist_at ss (t # ts) (Suc i) =\n  (\\<exists>xs ys. t # ts = xs @ ss @ ys \\<and> Suc i = length xs)\n\ngoal (4 subgoals):\n 1. \\<And>x xs y ys.\n       sublist_at xs ys 0 =\n       (\\<exists>ps ss.\n           ys = ps @ xs @ ss \\<and> 0 = length ps) \\<Longrightarrow>\n       sublist_at (x # xs) (y # ys) 0 =\n       (\\<exists>ps ss. y # ys = ps @ (x # xs) @ ss \\<and> 0 = length ps)\n 2. \\<And>ys.\n       sublist_at [] ys 0 =\n       (\\<exists>ps ss. ys = ps @ [] @ ss \\<and> 0 = length ps)\n 3. \\<And>v va uv_.\n       sublist_at (v # va) [] uv_ =\n       (\\<exists>ps ss. [] = ps @ (v # va) @ ss \\<and> uv_ = length ps)\n 4. \\<And>uu_ v.\n       sublist_at uu_ [] (Suc v) =\n       (\\<exists>ps ss. [] = ps @ uu_ @ ss \\<and> Suc v = length ps)", "qed auto"], ["", "corollary sublist_iff_sublist_at: \"Sublist.sublist xs ys \\<longleftrightarrow> (\\<exists>i. sublist_at xs ys i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sublist xs ys = (\\<exists>i. sublist_at xs ys i)", "by (simp add: sublist_at_altdef Sublist.sublist_def)"], ["", "subsection\\<open>Sublist-check algorithms\\<close>"], ["", "text\\<open>\n  We use the Isabelle Refinement Framework (Theory @{theory Refine_Monadic.Refine_Monadic}) to\n  phrase the specification and the algorithm. \n\\<close>"], ["", "text\\<open>@{term s} for \"searchword\" / \"searchlist\", @{term t} for \"text\"\\<close>"], ["", "definition \"kmp_SPEC s t = SPEC (\\<lambda>\n  None \\<Rightarrow> \\<nexists>i. sublist_at s t i |\n  Some i \\<Rightarrow> sublist_at s t i \\<and> (\\<forall>ii<i. \\<not>sublist_at s t ii))\""], ["", "lemma is_arg_min_id: \"is_arg_min id P i \\<longleftrightarrow> P i \\<and> (\\<forall>ii<i. \\<not>P ii)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min id P i = (P i \\<and> (\\<forall>ii<i. \\<not> P ii))", "unfolding is_arg_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P i \\<and> (\\<nexists>y. P y \\<and> id y < id i)) =\n    (P i \\<and> (\\<forall>ii<i. \\<not> P ii))", "by auto"], ["", "lemma kmp_result: \"kmp_SPEC s t =\n  RETURN (if sublist s t then Some (LEAST i. sublist_at s t i) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp_SPEC s t =\n    RETURN (if sublist s t then Some (LEAST i. sublist_at s t i) else None)", "unfolding kmp_SPEC_def sublist_iff_sublist_at"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (case_option (\\<not> Ex (sublist_at s t))\n       (\\<lambda>i.\n           sublist_at s t i \\<and>\n           (\\<forall>ii<i. \\<not> sublist_at s t ii))) =\n    RETURN\n     (if Ex (sublist_at s t) then Some (LEAST i. sublist_at s t i)\n      else None)", "apply (auto intro: LeastI dest: not_less_Least split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x2.\n       \\<lbrakk>sublist_at s t x; sublist_at s t x2;\n        \\<forall>ii<x2. \\<not> sublist_at s t ii\\<rbrakk>\n       \\<Longrightarrow> x2 = Least (sublist_at s t)", "by (meson LeastI nat_neq_iff not_less_Least)"], ["", "corollary weak_kmp_SPEC: \"kmp_SPEC s t \\<le> SPEC (\\<lambda>pos. pos\\<noteq>None \\<longleftrightarrow> Sublist.sublist s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp_SPEC s t\n    \\<le> SPEC (\\<lambda>pos. (pos \\<noteq> None) = sublist s t)", "by (simp add: kmp_result)"], ["", "lemmas kmp_SPEC_altdefs =\n  kmp_SPEC_def[folded is_arg_min_id]\n  kmp_SPEC_def[folded sublist_iff_sublist_at]\n  kmp_result"], ["", "section\\<open>Naive algorithm\\<close>"], ["", "text\\<open>Since KMP is a direct advancement of the naive \"test-all-starting-positions\" approach, we provide it here for comparison:\\<close>"], ["", "subsection\\<open>Invariants\\<close>"], ["", "definition \"I_out_na s t \\<equiv> \\<lambda>(i,j,pos).\n  (\\<forall>ii<i. \\<not>sublist_at s t ii) \\<and>\n  (case pos of None \\<Rightarrow> j = 0\n    | Some p \\<Rightarrow> p=i \\<and> sublist_at s t i)\""], ["", "definition \"I_in_na s t i \\<equiv> \\<lambda>(j,pos).\n  case pos of None \\<Rightarrow> j < length s \\<and> (\\<forall>jj<j. t!(i+jj) = s!(jj))\n    | Some p \\<Rightarrow> sublist_at s t i\""], ["", "subsection\\<open>Algorithm\\<close>"], ["", "(*Algorithm is common knowledge \\<longrightarrow> remove citation here, move explanations to KMP below?*)"], ["", "text\\<open>The following definition is taken from Helmut Seidl's lecture on algorithms and data structures@{cite GAD} except that we\n\\<^item> output the identified position @{term \\<open>pos :: nat option\\<close>} instead of just @{const True}\n\\<^item> use @{term \\<open>pos :: nat option\\<close>} as break-flag to support the abort within the loops\n\\<^item> rewrite @{prop \\<open>i \\<le> length t - length s\\<close>} in the first while-condition to @{prop \\<open>i + length s \\<le> length t\\<close>} to avoid having to use @{typ int} for list indexes (or the additional precondition @{prop \\<open>length s \\<le> length t\\<close>})\n\\<close>"], ["", "definition \"naive_algorithm s t \\<equiv> do {\n  let i=0;\n  let j=0;\n  let pos=None;\n  (_,_,pos) \\<leftarrow> WHILEIT (I_out_na s t) (\\<lambda>(i,_,pos). i + length s \\<le> length t \\<and> pos=None) (\\<lambda>(i,j,pos). do {\n    (_,pos) \\<leftarrow> WHILEIT (I_in_na s t i) (\\<lambda>(j,pos). t!(i+j) = s!j \\<and> pos=None) (\\<lambda>(j,_). do {\n      let j=j+1;\n      if j=length s then RETURN (j,Some i) else RETURN (j,None)\n    }) (j,pos);\n    if pos=None then do {\n      let i = i + 1;\n      let j = 0;\n      RETURN (i,j,None)\n    } else RETURN (i,j,Some i)\n  }) (i,j,pos);\n\n  RETURN pos\n}\""], ["", "subsection\\<open>Correctness\\<close>"], ["", "text\\<open>The basic lemmas on @{const sublist_at} from the previous chapter together with @{theory Refine_Monadic.Refine_Monadic}'s verification condition generator / solver suffice:\\<close>"], ["", "lemma \"s \\<noteq> [] \\<Longrightarrow> naive_algorithm s t \\<le> kmp_SPEC s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> naive_algorithm s t \\<le> kmp_SPEC s t", "unfolding naive_algorithm_def kmp_SPEC_def I_out_na_def I_in_na_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    (let i = 0; j = 0; pos = None\n     in WHILE\\<^sub>T\\<^bsup>\\<lambda>(i, j, pos).\n                                (\\<forall>ii<i.\n                                    \\<not> sublist_at s t ii) \\<and>\n                                (case pos of None \\<Rightarrow> j = 0\n                                 | Some p \\<Rightarrow>\n                                     p = i \\<and> sublist_at s t i)\\<^esup>\n         (\\<lambda>(i, uu_, pos).\n             i + length s \\<le> length t \\<and> pos = None)\n         (\\<lambda>(i, j, pos).\n             WHILE\\<^sub>T\\<^bsup>\\<lambda>(j, pos).\n                                     case pos of\n                                     None \\<Rightarrow>\n j < length s \\<and> (\\<forall>jj<j. t ! (i + jj) = s ! jj)\n                                     | Some p \\<Rightarrow>\n   sublist_at s t i\\<^esup>\n              (\\<lambda>(j, pos). t ! (i + j) = s ! j \\<and> pos = None)\n              (\\<lambda>(j, uu_).\n                  let j = j + 1\n                  in if j = length s then RETURN (j, Some i)\n                     else RETURN (j, None))\n              (j, pos) \\<bind>\n             (\\<lambda>(uu_, pos).\n                 if pos = None\n                 then let i = i + 1; j = 0 in RETURN (i, j, None)\n                 else RETURN (i, j, Some i)))\n         (i, j, pos) \\<bind>\n        (\\<lambda>(uu_, uu_, pos). RETURN pos))\n    \\<le> SPEC\n           (case_option (\\<not> Ex (sublist_at s t))\n             (\\<lambda>i.\n                 sublist_at s t i \\<and>\n                 (\\<forall>ii<i. \\<not> sublist_at s t ii)))", "apply (refine_vcg\n    WHILEIT_rule[where R=\"measure (\\<lambda>(i,_,pos). length t - i + (if pos = None then 1 else 0))\"]\n    WHILEIT_rule[where R=\"measure (\\<lambda>(j,_::nat option). length s - j)\"]\n    )"], ["proof (prove)\ngoal (16 subgoals):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    wf (measure\n         (\\<lambda>(i, uu_, pos).\n             length t - i + (if pos = None then 1 else 0)))\n 2. \\<And>x1 x2 x1a x2a ii.\n       \\<lbrakk>s \\<noteq> []; x2 = (x1a, x2a); (0, 0, None) = (x1, x2);\n        ii < x1\\<rbrakk>\n       \\<Longrightarrow> \\<not> sublist_at s t ii\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>s \\<noteq> []; x2 = (x1a, x2a);\n        (0, 0, None) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2a of None \\<Rightarrow> x1a = 0\n                         | Some p \\<Rightarrow>\n                             p = x1 \\<and> sublist_at s t x1\n 4. \\<And>sa a b aa ba.\n       \\<lbrakk>s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of None \\<Rightarrow> j = 0\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, uu_, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> wf (measure (\\<lambda>(j, uu_). length s - j))\n 5. \\<And>sa a b aa ba x1 x2.\n       \\<lbrakk>s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of None \\<Rightarrow> j = 0\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, uu_, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba); (aa, ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2 of\n                         None \\<Rightarrow>\n                           x1 < length s \\<and>\n                           (\\<forall>jj<x1. t ! (a + jj) = s ! jj)\n                         | Some p \\<Rightarrow> sublist_at s t a\n 6. \\<And>sa a b aa ba saa ab bb x1 x2.\n       \\<lbrakk>s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of None \\<Rightarrow> j = 0\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, uu_, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba);\n        case saa of\n        (j, None) \\<Rightarrow>\n          j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n        | (j, Some p) \\<Rightarrow> sublist_at s t a;\n        case saa of\n        (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n        saa = (ab, bb); ab + 1 = length s;\n        (ab + 1, Some a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2 of\n                         None \\<Rightarrow>\n                           x1 < length s \\<and>\n                           (\\<forall>jj<x1. t ! (a + jj) = s ! jj)\n                         | Some p \\<Rightarrow> sublist_at s t a\n 7. \\<And>sa a b aa ba saa ab bb.\n       \\<lbrakk>s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of None \\<Rightarrow> j = 0\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, uu_, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba);\n        case saa of\n        (j, None) \\<Rightarrow>\n          j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n        | (j, Some p) \\<Rightarrow> sublist_at s t a;\n        case saa of\n        (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n        saa = (ab, bb); ab + 1 = length s\\<rbrakk>\n       \\<Longrightarrow> ((ab + 1, Some a), saa)\n                         \\<in> measure (\\<lambda>(j, uu_). length s - j)\n 8. \\<And>sa a b aa ba saa ab bb x1 x2.\n       \\<lbrakk>s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of None \\<Rightarrow> j = 0\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, uu_, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba);\n        case saa of\n        (j, None) \\<Rightarrow>\n          j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n        | (j, Some p) \\<Rightarrow> sublist_at s t a;\n        case saa of\n        (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n        saa = (ab, bb); ab + 1 \\<noteq> length s;\n        (ab + 1, None) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2 of\n                         None \\<Rightarrow>\n                           x1 < length s \\<and>\n                           (\\<forall>jj<x1. t ! (a + jj) = s ! jj)\n                         | Some p \\<Rightarrow> sublist_at s t a\n 9. \\<And>sa a b aa ba saa ab bb.\n       \\<lbrakk>s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of None \\<Rightarrow> j = 0\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, uu_, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba);\n        case saa of\n        (j, None) \\<Rightarrow>\n          j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n        | (j, Some p) \\<Rightarrow> sublist_at s t a;\n        case saa of\n        (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n        saa = (ab, bb); ab + 1 \\<noteq> length s\\<rbrakk>\n       \\<Longrightarrow> ((ab + 1, None), saa)\n                         \\<in> measure (\\<lambda>(j, uu_). length s - j)\n 10. \\<And>sa a b aa ba saa ab bb x1 x2 x1a x2a ii.\n        \\<lbrakk>s \\<noteq> [];\n         case sa of\n         (i, j, pos) \\<Rightarrow>\n           (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n           (case pos of None \\<Rightarrow> j = 0\n            | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n         case sa of\n         (i, uu_, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         sa = (a, b); b = (aa, ba);\n         case saa of\n         (j, None) \\<Rightarrow>\n           j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n         | (j, Some p) \\<Rightarrow> sublist_at s t a;\n         \\<not> (case saa of\n                 (j, pos) \\<Rightarrow>\n                   t ! (a + j) = s ! j \\<and> pos = None);\n         saa = (ab, bb); bb = None; x2 = (x1a, x2a);\n         (a + 1, 0, None) = (x1, x2); ii < x1\\<rbrakk>\n        \\<Longrightarrow> \\<not> sublist_at s t ii\nA total of 16 subgoals...", "apply (vc_solve solve: asm_rl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab aba.\n       \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        Suc (ab + aba) \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj; t ! (ab + aba) = s ! aba;\n        length s = Suc aba\\<rbrakk>\n       \\<Longrightarrow> sublist_at s t ab\n 2. \\<And>ab aba jj.\n       \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        ab + length s \\<le> length t; t ! (ab + aba) = s ! aba;\n        Suc aba \\<noteq> length s; aba < length s;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj; jj < Suc aba\\<rbrakk>\n       \\<Longrightarrow> t ! (ab + jj) = s ! jj\n 3. \\<And>ab aba ii.\n       \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        ab + length s \\<le> length t; t ! (ab + aba) \\<noteq> s ! aba;\n        ii < Suc ab; aba < length s;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj; sublist_at s t ii\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of None \\<Rightarrow> aaa = 0\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab_. \\<not> sublist_at s t ii;\n     Suc (ab_ + aba_) \\<le> length t;\n     \\<forall>jj<aba_. t ! (ab_ + jj) = s ! jj; t ! (ab_ + aba_) = s ! aba_;\n     length s = Suc aba_\\<rbrakk>\n    \\<Longrightarrow> sublist_at s t ab_", "by (metis add_Suc_right all_positions_sublist less_antisym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab aba jj.\n       \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        ab + length s \\<le> length t; t ! (ab + aba) = s ! aba;\n        Suc aba \\<noteq> length s; aba < length s;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj; jj < Suc aba\\<rbrakk>\n       \\<Longrightarrow> t ! (ab + jj) = s ! jj\n 2. \\<And>ab aba ii.\n       \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        ab + length s \\<le> length t; t ! (ab + aba) \\<noteq> s ! aba;\n        ii < Suc ab; aba < length s;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj; sublist_at s t ii\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of None \\<Rightarrow> aaa = 0\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab_. \\<not> sublist_at s t ii;\n     ab_ + length s \\<le> length t; t ! (ab_ + aba_) = s ! aba_;\n     Suc aba_ \\<noteq> length s; aba_ < length s;\n     \\<forall>jj<aba_. t ! (ab_ + jj) = s ! jj; jj_ < Suc aba_\\<rbrakk>\n    \\<Longrightarrow> t ! (ab_ + jj_) = s ! jj_", "using less_Suc_eq"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab_. \\<not> sublist_at s t ii;\n     ab_ + length s \\<le> length t; t ! (ab_ + aba_) = s ! aba_;\n     Suc aba_ \\<noteq> length s; aba_ < length s;\n     \\<forall>jj<aba_. t ! (ab_ + jj) = s ! jj; jj_ < Suc aba_\\<rbrakk>\n    \\<Longrightarrow> t ! (ab_ + jj_) = s ! jj_", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab aba ii.\n       \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        ab + length s \\<le> length t; t ! (ab + aba) \\<noteq> s ! aba;\n        ii < Suc ab; aba < length s;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj; sublist_at s t ii\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of None \\<Rightarrow> aaa = 0\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; \\<forall>ii<ab_. \\<not> sublist_at s t ii;\n     ab_ + length s \\<le> length t; t ! (ab_ + aba_) \\<noteq> s ! aba_;\n     ii_ < Suc ab_; aba_ < length s;\n     \\<forall>jj<aba_. t ! (ab_ + jj) = s ! jj; sublist_at s t ii_\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis less_SucE sublist_all_positions)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of None \\<Rightarrow> aaa = 0\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> [];\n     ab_ + length s \\<le> length t \\<longrightarrow>\n     (\\<exists>y. baa_ = Some y);\n     \\<forall>ii<ab_. \\<not> sublist_at s t ii;\n     case baa_ of None \\<Rightarrow> aaa_ = 0\n     | Some p \\<Rightarrow> p = ab_ \\<and> sublist_at s t ab_\\<rbrakk>\n    \\<Longrightarrow> case baa_ of\n                      None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                      | Some i \\<Rightarrow>\n                          sublist_at s t i \\<and>\n                          (\\<forall>ii<i. \\<not> sublist_at s t ii)", "by (auto split: option.splits) (metis sublist_lengths add_less_cancel_right leI le_less_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Note that the precondition cannot be removed without an extra branch: If @{prop \\<open>s = []\\<close>}, the inner while-condition accesses out-of-bound memory. This will apply to KMP, too.\\<close>"], ["", "section\\<open>Knuth--Morris--Pratt algorithm\\<close>"], ["", "text\\<open>Just like our templates@{cite KMP77}@{cite GAD}, we first verify the main routine and discuss the computation of the auxiliary values @{term \\<open>\\<ff> s\\<close>} only in a later section.\\<close>"], ["", "subsection\\<open>Preliminaries: Borders of lists\\<close>"], ["", "definition \"border xs ys \\<longleftrightarrow> prefix xs ys \\<and> suffix xs ys\""], ["", "definition \"strict_border xs ys \\<longleftrightarrow> border xs ys \\<and> length xs < length ys\""], ["", "definition \"intrinsic_border ls \\<equiv> ARG_MAX length b. strict_border b ls\""], ["", "subsubsection\\<open>Properties\\<close>"], ["", "interpretation border_order: order border strict_border"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order border strict_border", "by standard (auto simp: border_def suffix_def strict_border_def)"], ["", "interpretation border_bot: order_bot Nil border strict_border"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order_bot [] border strict_border", "by standard (simp add: border_def)"], ["", "lemma borderE[elim]:\n  fixes xs ys :: \"'a list\"\n  assumes \"border xs ys\"\n  obtains \"prefix xs ys\" and \"suffix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>prefix xs ys; suffix xs ys\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  border xs ys\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>prefix xs ys; suffix xs ys\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding border_def"], ["proof (prove)\nusing this:\n  prefix xs ys \\<and> suffix xs ys\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>prefix xs ys; suffix xs ys\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma strict_borderE[elim]:\n  fixes xs ys :: \"'a list\"\n  assumes \"strict_border xs ys\"\n  obtains \"border xs ys\" and \"length xs < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>border xs ys; length xs < length ys\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  strict_border xs ys\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>border xs ys; length xs < length ys\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding strict_border_def"], ["proof (prove)\nusing this:\n  border xs ys \\<and> length xs < length ys\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>border xs ys; length xs < length ys\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma strict_border_simps[simp]:\n  \"strict_border xs [] \\<longleftrightarrow> False\"\n  \"strict_border [] (x # xs) \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_border xs [] = False &&& strict_border [] (x # xs) = True", "by (simp_all add: strict_border_def)"], ["", "lemma strict_border_prefix: \"strict_border xs ys \\<Longrightarrow> strict_prefix xs ys\"\n  and strict_border_suffix: \"strict_border xs ys \\<Longrightarrow> strict_suffix xs ys\"\n  and strict_border_imp_nonempty: \"strict_border xs ys \\<Longrightarrow> ys \\<noteq> []\"\n  and strict_border_prefix_suffix: \"strict_border xs ys \\<longleftrightarrow> strict_prefix xs ys \\<and> strict_suffix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((strict_border xs ys \\<Longrightarrow> strict_prefix xs ys) &&&\n     (strict_border xs ys \\<Longrightarrow> strict_suffix xs ys)) &&&\n    (strict_border xs ys \\<Longrightarrow> ys \\<noteq> []) &&&\n    strict_border xs ys = (strict_prefix xs ys \\<and> strict_suffix xs ys)", "by (auto simp: border_order.order.strict_iff_order border_def)"], ["", "lemma border_length_le: \"border xs ys \\<Longrightarrow> length xs \\<le> length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. border xs ys \\<Longrightarrow> length xs \\<le> length ys", "unfolding border_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<and> suffix xs ys \\<Longrightarrow>\n    length xs \\<le> length ys", "by (simp add: prefix_length_le)"], ["", "lemma border_length_r_less (*rm*): \"\\<forall>xs. strict_border xs ys \\<longrightarrow> length xs < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. strict_border xs ys \\<longrightarrow> length xs < length ys", "using strict_borderE"], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_border ?xs ?ys;\n   \\<lbrakk>border ?xs ?ys; length ?xs < length ?ys\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>xs. strict_border xs ys \\<longrightarrow> length xs < length ys", "by auto"], ["", "lemma border_positions: \"border xs ys \\<Longrightarrow> \\<forall>i<length xs. ys!i = ys!(length ys - length xs + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. border xs ys \\<Longrightarrow>\n    \\<forall>i<length xs. ys ! i = ys ! (length ys - length xs + i)", "unfolding border_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<and> suffix xs ys \\<Longrightarrow>\n    \\<forall>i<length xs. ys ! i = ys ! (length ys - length xs + i)", "by (metis diff_add_inverse diff_add_inverse2 length_append not_add_less1 nth_append prefixE suffixE)"], ["", "lemma all_positions_drop_length_take: \"\\<lbrakk>i \\<le> length w; i \\<le> length x;\n  \\<forall>j<i. x ! j = w ! (length w + j - i)\\<rbrakk>\n    \\<Longrightarrow> drop (length w - i) w = take i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length w; i \\<le> length x;\n     \\<forall>j<i. x ! j = w ! (length w + j - i)\\<rbrakk>\n    \\<Longrightarrow> drop (length w - i) w = take i x", "by (cases \"i = length x\") (auto intro: nth_equalityI)"], ["", "lemma all_positions_suffix_take: \"\\<lbrakk>i \\<le> length w; i \\<le> length x;\n  \\<forall>j<i. x ! j = w ! (length w + j - i)\\<rbrakk>\n    \\<Longrightarrow> suffix (take i x) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length w; i \\<le> length x;\n     \\<forall>j<i. x ! j = w ! (length w + j - i)\\<rbrakk>\n    \\<Longrightarrow> suffix (take i x) w", "by (metis all_positions_drop_length_take suffix_drop)"], ["", "lemma suffix_butlast: \"suffix xs ys \\<Longrightarrow> suffix (butlast xs) (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suffix xs ys \\<Longrightarrow> suffix (butlast xs) (butlast ys)", "unfolding suffix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs. ys = zs @ xs \\<Longrightarrow>\n    \\<exists>zs. butlast ys = zs @ butlast xs", "by (metis append_Nil2 butlast.simps(1) butlast_append)"], ["", "lemma positions_border: \"\\<forall>j<l. w!j = w!(length w - l + j) \\<Longrightarrow> border (take l w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<l. w ! j = w ! (length w - l + j) \\<Longrightarrow>\n    border (take l w) w", "by (cases \"l < length w\") (simp_all add: border_def all_positions_suffix_take take_is_prefix)"], ["", "lemma positions_strict_border: \"l < length w \\<Longrightarrow> \\<forall>j<l. w!j = w!(length w - l + j) \\<Longrightarrow> strict_border (take l w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < length w;\n     \\<forall>j<l. w ! j = w ! (length w - l + j)\\<rbrakk>\n    \\<Longrightarrow> strict_border (take l w) w", "by (simp add: positions_border strict_border_def)"], ["", "lemmas intrinsic_borderI = arg_max_natI[OF _ border_length_r_less, folded intrinsic_border_def]"], ["", "lemmas intrinsic_borderI' = border_bot.bot.not_eq_extremum[THEN iffD1, THEN intrinsic_borderI]"], ["", "lemmas intrinsic_border_max = arg_max_nat_le[OF _ border_length_r_less, folded intrinsic_border_def]"], ["", "lemma nonempty_is_arg_max_ib: \"ys \\<noteq> [] \\<Longrightarrow> is_arg_max length (\\<lambda>xs. strict_border xs ys) (intrinsic_border ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow>\n    is_arg_max length (\\<lambda>xs. strict_border xs ys)\n     (intrinsic_border ys)", "by (simp add: intrinsic_borderI' intrinsic_border_max is_arg_max_linorder)"], ["", "lemma intrinsic_border_less: \"w \\<noteq> [] \\<Longrightarrow> length (intrinsic_border w) < length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> [] \\<Longrightarrow> length (intrinsic_border w) < length w", "using intrinsic_borderI[of w] border_length_r_less intrinsic_borderI'"], ["proof (prove)\nusing this:\n  strict_border w ?ys \\<Longrightarrow>\n  strict_border (intrinsic_border ?ys) ?ys\n  \\<forall>xs. strict_border xs ?ys \\<longrightarrow> length xs < length ?ys\n  ?ys \\<noteq> [] \\<Longrightarrow> strict_border (intrinsic_border ?ys) ?ys\n\ngoal (1 subgoal):\n 1. w \\<noteq> [] \\<Longrightarrow> length (intrinsic_border w) < length w", "by blast"], ["", "lemma intrinsic_border_take_less: \"j > 0 \\<Longrightarrow> w \\<noteq> [] \\<Longrightarrow> length (intrinsic_border (take j w)) < length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < j; w \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length (intrinsic_border (take j w)) < length w", "by (metis intrinsic_border_less length_take less_not_refl2 min_less_iff_conj take_eq_Nil)"], ["", "subsubsection\\<open>Examples\\<close>"], ["", "lemma border_example: \"{b. border b ''aabaabaa''} = {'''', ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\"\n  (is \"{b. border b ?l} = {?take0, ?take1, ?take2, ?take5, ?l}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''} =\n    {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {b. border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\n 2. {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\n    \\<subseteq> {b. border b ''aabaabaa''}", "show \"{?take0, ?take1, ?take2, ?take5, ?l} \\<subseteq> {b. border b ?l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\n    \\<subseteq> {b. border b ''aabaabaa''}", "by simp eval"], ["proof (state)\nthis:\n  {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\n  \\<subseteq> {b. border b ''aabaabaa''}\n\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "have \"\\<not>border ''aab'' ?l\" \"\\<not>border ''aaba'' ?l\" \"\\<not>border ''aabaab'' ?l\" \"\\<not>border ''aabaaba'' ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> border ''aab'' ''aabaabaa'' &&&\n     \\<not> border ''aaba'' ''aabaabaa'') &&&\n    \\<not> border ''aabaab'' ''aabaabaa'' &&&\n    \\<not> border ''aabaaba'' ''aabaabaa''", "by eval+"], ["proof (state)\nthis:\n  \\<not> border ''aab'' ''aabaabaa''\n  \\<not> border ''aaba'' ''aabaabaa''\n  \\<not> border ''aabaab'' ''aabaabaa''\n  \\<not> border ''aabaaba'' ''aabaabaa''\n\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "moreover"], ["proof (state)\nthis:\n  \\<not> border ''aab'' ''aabaabaa''\n  \\<not> border ''aaba'' ''aabaabaa''\n  \\<not> border ''aabaab'' ''aabaabaa''\n  \\<not> border ''aabaaba'' ''aabaabaa''\n\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "have \"{b. border b ?l} \\<subseteq> set (prefixes ?l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''} \\<subseteq> set (prefixes ''aabaabaa'')", "using border_def in_set_prefixes"], ["proof (prove)\nusing this:\n  border ?xs ?ys = (prefix ?xs ?ys \\<and> suffix ?xs ?ys)\n  (?xs \\<in> set (prefixes ?ys)) = prefix ?xs ?ys\n\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''} \\<subseteq> set (prefixes ''aabaabaa'')", "by blast"], ["proof (state)\nthis:\n  {b. border b ''aabaabaa''} \\<subseteq> set (prefixes ''aabaabaa'')\n\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> border ''aab'' ''aabaabaa''\n  \\<not> border ''aaba'' ''aabaabaa''\n  \\<not> border ''aabaab'' ''aabaabaa''\n  \\<not> border ''aabaaba'' ''aabaabaa''\n  {b. border b ''aabaabaa''} \\<subseteq> set (prefixes ''aabaabaa'')", "show \"{b. border b ?l} \\<subseteq> {?take0, ?take1, ?take2, ?take5, ?l}\""], ["proof (prove)\nusing this:\n  \\<not> border ''aab'' ''aabaabaa''\n  \\<not> border ''aaba'' ''aabaabaa''\n  \\<not> border ''aabaab'' ''aabaabaa''\n  \\<not> border ''aabaaba'' ''aabaabaa''\n  {b. border b ''aabaabaa''} \\<subseteq> set (prefixes ''aabaabaa'')\n\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "by auto"], ["proof (state)\nthis:\n  {b. border b ''aabaabaa''}\n  \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary strict_border_example: \"{b. strict_border b ''aabaabaa''} = {'''', ''a'', ''aa'', ''aabaa''}\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. strict_border b ''aabaabaa''} = {[], ''a'', ''aa'', ''aabaa''}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {b. strict_border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa''}\n 2. {[], ''a'', ''aa'', ''aabaa''}\n    \\<subseteq> {b. strict_border b ''aabaabaa''}", "have \"?l \\<subseteq> {b. border b ''aabaabaa''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. strict_border b ''aabaabaa''} \\<subseteq> {b. border b ''aabaabaa''}", "by auto"], ["proof (state)\nthis:\n  {b. strict_border b ''aabaabaa''} \\<subseteq> {b. border b ''aabaabaa''}\n\ngoal (2 subgoals):\n 1. {b. strict_border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa''}\n 2. {[], ''a'', ''aa'', ''aabaa''}\n    \\<subseteq> {b. strict_border b ''aabaabaa''}", "also"], ["proof (state)\nthis:\n  {b. strict_border b ''aabaabaa''} \\<subseteq> {b. border b ''aabaabaa''}\n\ngoal (2 subgoals):\n 1. {b. strict_border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa''}\n 2. {[], ''a'', ''aa'', ''aabaa''}\n    \\<subseteq> {b. strict_border b ''aabaabaa''}", "have \"\\<dots> = {'''', ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. border b ''aabaabaa''} =\n    {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "by (fact border_example)"], ["proof (state)\nthis:\n  {b. border b ''aabaabaa''} = {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\n\ngoal (2 subgoals):\n 1. {b. strict_border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa''}\n 2. {[], ''a'', ''aa'', ''aabaa''}\n    \\<subseteq> {b. strict_border b ''aabaabaa''}", "finally"], ["proof (chain)\npicking this:\n  {b. strict_border b ''aabaabaa''}\n  \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}", "show \"?l \\<subseteq> ?r\""], ["proof (prove)\nusing this:\n  {b. strict_border b ''aabaabaa''}\n  \\<subseteq> {[], ''a'', ''aa'', ''aabaa'', ''aabaabaa''}\n\ngoal (1 subgoal):\n 1. {b. strict_border b ''aabaabaa''}\n    \\<subseteq> {[], ''a'', ''aa'', ''aabaa''}", "by auto"], ["proof (state)\nthis:\n  {b. strict_border b ''aabaabaa''}\n  \\<subseteq> {[], ''a'', ''aa'', ''aabaa''}\n\ngoal (1 subgoal):\n 1. {[], ''a'', ''aa'', ''aabaa''}\n    \\<subseteq> {b. strict_border b ''aabaabaa''}", "show \"?r \\<subseteq> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {[], ''a'', ''aa'', ''aabaa''}\n    \\<subseteq> {b. strict_border b ''aabaabaa''}", "by simp eval"], ["proof (state)\nthis:\n  {[], ''a'', ''aa'', ''aabaa''}\n  \\<subseteq> {b. strict_border b ''aabaabaa''}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \"intrinsic_border ''aabaabaa'' = ''aabaa''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "proof - \\<comment> \\<open>We later obtain a fast algorithm for that.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "have exhaust: \"strict_border b ''aabaabaa'' \\<longleftrightarrow> b \\<in> {'''', ''a'', ''aa'', ''aabaa''}\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_border b ''aabaabaa'' = (b \\<in> {[], ''a'', ''aa'', ''aabaa''})", "using strict_border_example"], ["proof (prove)\nusing this:\n  {b. strict_border b ''aabaabaa''} = {[], ''a'', ''aa'', ''aabaa''}\n\ngoal (1 subgoal):\n 1. strict_border b ''aabaabaa'' = (b \\<in> {[], ''a'', ''aa'', ''aabaa''})", "by auto"], ["proof (state)\nthis:\n  strict_border ?b ''aabaabaa'' = (?b \\<in> {[], ''a'', ''aa'', ''aabaa''})\n\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "then"], ["proof (chain)\npicking this:\n  strict_border ?b ''aabaabaa'' = (?b \\<in> {[], ''a'', ''aa'', ''aabaa''})", "have\n    \"\\<not>is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''''\"\n    \"\\<not>is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''a''\"\n    \"\\<not>is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aa''\"\n    \"is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aabaa''\""], ["proof (prove)\nusing this:\n  strict_border ?b ''aabaabaa'' = (?b \\<in> {[], ''a'', ''aa'', ''aabaa''})\n\ngoal (1 subgoal):\n 1. (\\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'')\n             [] &&&\n     \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'')\n             ''a'') &&&\n    \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'')\n            ''aa'' &&&\n    is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aabaa''", "unfolding is_arg_max_linorder"], ["proof (prove)\nusing this:\n  strict_border ?b ''aabaabaa'' = (?b \\<in> {[], ''a'', ''aa'', ''aabaa''})\n\ngoal (1 subgoal):\n 1. (\\<not> (strict_border [] ''aabaabaa'' \\<and>\n             (\\<forall>y.\n                 strict_border y ''aabaabaa'' \\<longrightarrow>\n                 length y \\<le> length [])) &&&\n     \\<not> (strict_border ''a'' ''aabaabaa'' \\<and>\n             (\\<forall>y.\n                 strict_border y ''aabaabaa'' \\<longrightarrow>\n                 length y \\<le> length ''a''))) &&&\n    \\<not> (strict_border ''aa'' ''aabaabaa'' \\<and>\n            (\\<forall>y.\n                strict_border y ''aabaabaa'' \\<longrightarrow>\n                length y \\<le> length ''aa'')) &&&\n    strict_border ''aabaa'' ''aabaabaa'' \\<and>\n    (\\<forall>y.\n        strict_border y ''aabaabaa'' \\<longrightarrow>\n        length y \\<le> length ''aabaa'')", "by auto"], ["proof (state)\nthis:\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') []\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''a''\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aa''\n  is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aabaa''\n\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "moreover"], ["proof (state)\nthis:\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') []\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''a''\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aa''\n  is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aabaa''\n\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "have \"strict_border (intrinsic_border ''aabaabaa'') ''aabaabaa''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_border (intrinsic_border ''aabaabaa'') ''aabaabaa''", "using intrinsic_borderI'"], ["proof (prove)\nusing this:\n  ?ys \\<noteq> [] \\<Longrightarrow> strict_border (intrinsic_border ?ys) ?ys\n\ngoal (1 subgoal):\n 1. strict_border (intrinsic_border ''aabaabaa'') ''aabaabaa''", "by blast"], ["proof (state)\nthis:\n  strict_border (intrinsic_border ''aabaabaa'') ''aabaabaa''\n\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "note this[unfolded exhaust]"], ["proof (state)\nthis:\n  intrinsic_border ''aabaabaa'' \\<in> {[], ''a'', ''aa'', ''aabaa''}\n\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') []\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''a''\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aa''\n  is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aabaa''\n  intrinsic_border ''aabaabaa'' \\<in> {[], ''a'', ''aa'', ''aabaa''}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') []\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''a''\n  \\<not> is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aa''\n  is_arg_max length (\\<lambda>b. strict_border b ''aabaabaa'') ''aabaa''\n  intrinsic_border ''aabaabaa'' \\<in> {[], ''a'', ''aa'', ''aabaa''}\n\ngoal (1 subgoal):\n 1. intrinsic_border ''aabaabaa'' = ''aabaa''", "by simp (metis list.discI nonempty_is_arg_max_ib)"], ["proof (state)\nthis:\n  intrinsic_border ''aabaabaa'' = ''aabaa''\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Main routine\\<close>"], ["", "text\\<open>The following is Seidl's \"border\"-table@{cite GAD} (values shifted by 1 so we don't need @{typ int}),\nor equivalently, \"f\" from Knuth's, Morris' and Pratt's paper@{cite KMP77} (with indexes starting at 0).\\<close>"], ["", "fun \\<ff> :: \"'a list \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"\\<ff> s 0 = 0\" \\<comment> \\<open>This increments the compare position while @{prop \\<open>j=(0::nat)\\<close>}\\<close> |\n  \"\\<ff> s j = length (intrinsic_border (take j s)) + 1\""], ["", "text\\<open>Note that we use their \"next\" only implicitly.\\<close>"], ["", "subsubsection\\<open>Invariants\\<close>"], ["", "definition \"I_outer s t \\<equiv> \\<lambda>(i,j,pos).\n  (\\<forall>ii<i. \\<not>sublist_at s t ii) \\<and>\n  (case pos of None \\<Rightarrow> (\\<forall>jj<j. t!(i+jj) = s!(jj)) \\<and> j < length s\n    | Some p \\<Rightarrow> p=i \\<and> sublist_at s t i)\""], ["", "text\\<open>For the inner loop, we can reuse @{const I_in_na}.\\<close>"], ["", "subsubsection\\<open>Algorithm\\<close>"], ["", "text\\<open>First, we use the non-evaluable function @{const \\<ff>} directly:\\<close>"], ["", "definition \"kmp s t \\<equiv> do {\n  ASSERT (s \\<noteq> []);\n  let i=0;\n  let j=0;\n  let pos=None;\n  (_,_,pos) \\<leftarrow> WHILEIT (I_outer s t) (\\<lambda>(i,j,pos). i + length s \\<le> length t \\<and> pos=None) (\\<lambda>(i,j,pos). do {\n    ASSERT (i + length s \\<le> length t);\n    (j,pos) \\<leftarrow> WHILEIT (I_in_na s t i) (\\<lambda>(j,pos). t!(i+j) = s!j \\<and> pos=None) (\\<lambda>(j,pos). do {\n      let j=j+1;\n      if j=length s then RETURN (j,Some i) else RETURN (j,None)\n    }) (j,pos);\n    if pos=None then do {\n      ASSERT (j < length s);\n      let i = i + (j - \\<ff> s j + 1);\n      let j = max 0 (\\<ff> s j - 1); \\<comment> \\<open>\\<open>max\\<close> not necessary\\<close>\n      RETURN (i,j,None)\n    } else RETURN (i,j,Some i)\n  }) (i,j,pos);\n\n  RETURN pos\n}\""], ["", "subsubsection\\<open>Correctness\\<close>"], ["", "lemma \\<ff>_eq_0_iff_j_eq_0[simp]: \"\\<ff> s j = 0 \\<longleftrightarrow> j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<ff> s j = 0) = (j = 0)", "by (cases j) simp_all"], ["", "lemma j_le_\\<ff>_le: \"j \\<le> length s \\<Longrightarrow> \\<ff> s j \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> length s \\<Longrightarrow> \\<ff> s j \\<le> j", "apply (cases j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<le> length s; j = 0\\<rbrakk>\n    \\<Longrightarrow> \\<ff> s j \\<le> j\n 2. \\<And>nat.\n       \\<lbrakk>j \\<le> length s; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s j \\<le> j", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length s; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length (intrinsic_border (take (Suc nat) s))\n                         \\<le> nat", "by (metis Suc_leI intrinsic_border_less length_take list.size(3) min.absorb2 nat.simps(3) not_less)"], ["", "lemma j_le_\\<ff>_le': \"0 < j \\<Longrightarrow> j \\<le> length s \\<Longrightarrow> \\<ff> s j - 1 < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < j; j \\<le> length s\\<rbrakk>\n    \\<Longrightarrow> \\<ff> s j - 1 < j", "by (metis diff_less j_le_\\<ff>_le le_eq_less_or_eq less_imp_diff_less less_one)"], ["", "lemma \\<ff>_le: \"s \\<noteq> [] \\<Longrightarrow> \\<ff> s j - 1 < length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> \\<ff> s j - 1 < length s", "by (cases j) (simp_all add: intrinsic_border_take_less)"], ["", "(*\n  Only needed for run-time analysis\nlemma \"p576 et seq\":\n  assumes\n    \"j \\<le> length s\" and\n    assignments:\n    \"i' = i + (j + 1 - \\<ff> s j)\"\n    \"j' = max 0 (\\<ff> s j - 1)\"\n  shows\n    sum_no_decrease: \"i' + j' \\<ge> i + j\" and\n    i_increase: \"i' > i\"\n  using assignments by (simp_all add: j_le_\\<ff>_le[OF assms(1), THEN le_imp_less_Suc])\n*)"], ["", "lemma reuse_matches: \n  assumes j_le: \"j \\<le> length s\"\n  and old_matches: \"\\<forall>jj<j. t ! (i + jj) = s ! jj\"\n  shows \"\\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\"\n    (is \"\\<forall>jj<?j'. t ! (?i' + jj) = s ! jj\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "proof (cases \"j>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "assume \"j>0\""], ["proof (state)\nthis:\n  0 < j\n\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "have \\<ff>_le: \"\\<ff> s j \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ff> s j \\<le> j", "by (simp add: j_le j_le_\\<ff>_le)"], ["proof (state)\nthis:\n  \\<ff> s j \\<le> j\n\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "with old_matches"], ["proof (chain)\npicking this:\n  \\<forall>jj<j. t ! (i + jj) = s ! jj\n  \\<ff> s j \\<le> j", "have 1: \"\\<forall>jj<?j'. t ! (?i' + jj) = s ! (j - \\<ff> s j + 1 + jj)\""], ["proof (prove)\nusing this:\n  \\<forall>jj<j. t ! (i + jj) = s ! jj\n  \\<ff> s j \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>jj<\\<ff> s j - 1.\n       t ! (i + (j - \\<ff> s j + 1) + jj) = s ! (j - \\<ff> s j + 1 + jj)", "by (metis ab_semigroup_add_class.add.commute add.assoc diff_diff_cancel less_diff_conv)"], ["proof (state)\nthis:\n  \\<forall>jj<\\<ff> s j - 1.\n     t ! (i + (j - \\<ff> s j + 1) + jj) = s ! (j - \\<ff> s j + 1 + jj)\n\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "have [simp]: \"length (take j s) = j\" \"length (intrinsic_border (take j s)) = ?j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take j s) = j &&&\n    length (intrinsic_border (take j s)) = \\<ff> s j - 1", "by (simp add: j_le) (metis \\<open>0 < j\\<close> diff_add_inverse2 \\<ff>.elims nat_neq_iff)"], ["proof (state)\nthis:\n  length (take j s) = j\n  length (intrinsic_border (take j s)) = \\<ff> s j - 1\n\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "then"], ["proof (chain)\npicking this:\n  length (take j s) = j\n  length (intrinsic_border (take j s)) = \\<ff> s j - 1", "have \"\\<forall>jj<?j'. take j s ! jj = take j s ! (j - (\\<ff> s j - 1) + jj)\""], ["proof (prove)\nusing this:\n  length (take j s) = j\n  length (intrinsic_border (take j s)) = \\<ff> s j - 1\n\ngoal (1 subgoal):\n 1. \\<forall>jj<\\<ff> s j - 1.\n       take j s ! jj = take j s ! (j - (\\<ff> s j - 1) + jj)", "by (metis intrinsic_borderI' \\<open>0 < j\\<close> border_positions length_greater_0_conv strict_border_def)"], ["proof (state)\nthis:\n  \\<forall>jj<\\<ff> s j - 1.\n     take j s ! jj = take j s ! (j - (\\<ff> s j - 1) + jj)\n\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "then"], ["proof (chain)\npicking this:\n  \\<forall>jj<\\<ff> s j - 1.\n     take j s ! jj = take j s ! (j - (\\<ff> s j - 1) + jj)", "have \"\\<forall>jj<?j'. take j s ! jj = take j s ! (j - \\<ff> s j + 1 + jj)\""], ["proof (prove)\nusing this:\n  \\<forall>jj<\\<ff> s j - 1.\n     take j s ! jj = take j s ! (j - (\\<ff> s j - 1) + jj)\n\ngoal (1 subgoal):\n 1. \\<forall>jj<\\<ff> s j - 1.\n       take j s ! jj = take j s ! (j - \\<ff> s j + 1 + jj)", "by (simp add: \\<ff>_le)"], ["proof (state)\nthis:\n  \\<forall>jj<\\<ff> s j - 1.\n     take j s ! jj = take j s ! (j - \\<ff> s j + 1 + jj)\n\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "then"], ["proof (chain)\npicking this:\n  \\<forall>jj<\\<ff> s j - 1.\n     take j s ! jj = take j s ! (j - \\<ff> s j + 1 + jj)", "have 2: \"\\<forall>jj<?j'. s ! (j - \\<ff> s j + 1 + jj) = s ! jj\""], ["proof (prove)\nusing this:\n  \\<forall>jj<\\<ff> s j - 1.\n     take j s ! jj = take j s ! (j - \\<ff> s j + 1 + jj)\n\ngoal (1 subgoal):\n 1. \\<forall>jj<\\<ff> s j - 1. s ! (j - \\<ff> s j + 1 + jj) = s ! jj", "using \\<ff>_le"], ["proof (prove)\nusing this:\n  \\<forall>jj<\\<ff> s j - 1.\n     take j s ! jj = take j s ! (j - \\<ff> s j + 1 + jj)\n  \\<ff> s j \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>jj<\\<ff> s j - 1. s ! (j - \\<ff> s j + 1 + jj) = s ! jj", "by simp"], ["proof (state)\nthis:\n  \\<forall>jj<\\<ff> s j - 1. s ! (j - \\<ff> s j + 1 + jj) = s ! jj\n\ngoal (2 subgoals):\n 1. 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n 2. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "from 1 2"], ["proof (chain)\npicking this:\n  \\<forall>jj<\\<ff> s j - 1.\n     t ! (i + (j - \\<ff> s j + 1) + jj) = s ! (j - \\<ff> s j + 1 + jj)\n  \\<forall>jj<\\<ff> s j - 1. s ! (j - \\<ff> s j + 1 + jj) = s ! jj", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>jj<\\<ff> s j - 1.\n     t ! (i + (j - \\<ff> s j + 1) + jj) = s ! (j - \\<ff> s j + 1 + jj)\n  \\<forall>jj<\\<ff> s j - 1. s ! (j - \\<ff> s j + 1 + jj) = s ! jj\n\ngoal (1 subgoal):\n 1. \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "by simp"], ["proof (state)\nthis:\n  \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n\ngoal (1 subgoal):\n 1. \\<not> 0 < j \\<Longrightarrow>\n    \\<forall>jj<\\<ff> s j - 1. t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj", "qed simp"], ["", "theorem shift_safe:\n  assumes\n    \"\\<forall>ii<i. \\<not>sublist_at s t ii\"\n    \"t!(i+j) \\<noteq> s!j\" and\n    [simp]: \"j < length s\" and\n    matches: \"\\<forall>jj<j. t!(i+jj) = s!jj\"\n  defines\n    assignment: \"i' \\<equiv> i + (j - \\<ff> s j + 1)\"\n  shows\n    \"\\<forall>ii<i'. \\<not>sublist_at s t ii\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ii<i'. \\<not> sublist_at s t ii", "proof (standard, standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ii. ii < i' \\<Longrightarrow> \\<not> sublist_at s t ii", "fix ii"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ii. ii < i' \\<Longrightarrow> \\<not> sublist_at s t ii", "assume \"ii < i'\""], ["proof (state)\nthis:\n  ii < i'\n\ngoal (1 subgoal):\n 1. \\<And>ii. ii < i' \\<Longrightarrow> \\<not> sublist_at s t ii", "then"], ["proof (chain)\npicking this:\n  ii < i'", "consider \\<comment> \\<open>The position falls into one of three categories:\\<close>\n    (old) \"ii < i\" |\n    (current) \"ii = i\" |\n    (skipped) \"ii > i\""], ["proof (prove)\nusing this:\n  ii < i'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ii < i \\<Longrightarrow> thesis;\n     ii = i \\<Longrightarrow> thesis;\n     i < ii \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>ii < i \\<Longrightarrow> ?thesis;\n   ii = i \\<Longrightarrow> ?thesis;\n   i < ii \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>ii. ii < i' \\<Longrightarrow> \\<not> sublist_at s t ii", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ii < i \\<Longrightarrow> ?thesis;\n   ii = i \\<Longrightarrow> ?thesis;\n   i < ii \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"\\<not>sublist_at s t ii\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ii < i \\<Longrightarrow> ?thesis;\n   ii = i \\<Longrightarrow> ?thesis;\n   i < ii \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> sublist_at s t ii", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. ii < i \\<Longrightarrow> \\<not> sublist_at s t ii\n 2. ii = i \\<Longrightarrow> \\<not> sublist_at s t ii\n 3. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "case old \\<comment> \\<open>Old position, use invariant.\\<close>"], ["proof (state)\nthis:\n  ii < i\n\ngoal (3 subgoals):\n 1. ii < i \\<Longrightarrow> \\<not> sublist_at s t ii\n 2. ii = i \\<Longrightarrow> \\<not> sublist_at s t ii\n 3. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "with \\<open>\\<forall>ii<i. \\<not>sublist_at s t ii\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ii<i. \\<not> sublist_at s t ii\n  ii < i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>ii<i. \\<not> sublist_at s t ii\n  ii < i\n\ngoal (1 subgoal):\n 1. \\<not> sublist_at s t ii", "by simp"], ["proof (state)\nthis:\n  \\<not> sublist_at s t ii\n\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow> \\<not> sublist_at s t ii\n 2. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow> \\<not> sublist_at s t ii\n 2. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "case current \\<comment> \\<open>The mismatch occurred while testing this alignment.\\<close>"], ["proof (state)\nthis:\n  ii = i\n\ngoal (2 subgoals):\n 1. ii = i \\<Longrightarrow> \\<not> sublist_at s t ii\n 2. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "with \\<open>t!(i+j) \\<noteq> s!j\\<close>"], ["proof (chain)\npicking this:\n  t ! (i + j) \\<noteq> s ! j\n  ii = i", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! (i + j) \\<noteq> s ! j\n  ii = i\n\ngoal (1 subgoal):\n 1. \\<not> sublist_at s t ii", "using sublist_all_positions[of s t i]"], ["proof (prove)\nusing this:\n  t ! (i + j) \\<noteq> s ! j\n  ii = i\n  sublist_at s t i \\<Longrightarrow>\n  \\<forall>jj<length s. t ! (i + jj) = s ! jj\n\ngoal (1 subgoal):\n 1. \\<not> sublist_at s t ii", "by auto"], ["proof (state)\nthis:\n  \\<not> sublist_at s t ii\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "case skipped \\<comment> \\<open>The skipped positions.\\<close>"], ["proof (state)\nthis:\n  i < ii\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "then"], ["proof (chain)\npicking this:\n  i < ii", "have \"0<j\""], ["proof (prove)\nusing this:\n  i < ii\n\ngoal (1 subgoal):\n 1. 0 < j", "using \\<open>ii < i'\\<close> assignment"], ["proof (prove)\nusing this:\n  i < ii\n  ii < i'\n  i' \\<equiv> i + (j - \\<ff> s j + 1)\n\ngoal (1 subgoal):\n 1. 0 < j", "by linarith"], ["proof (state)\nthis:\n  0 < j\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "then"], ["proof (chain)\npicking this:\n  0 < j", "have less_j[simp]: \"j + i - ii < j\" and le_s: \"j + i - ii \\<le> length s\""], ["proof (prove)\nusing this:\n  0 < j\n\ngoal (1 subgoal):\n 1. j + i - ii < j &&& j + i - ii \\<le> length s", "using \\<open>ii < i'\\<close> assms(3) skipped"], ["proof (prove)\nusing this:\n  0 < j\n  ii < i'\n  j < length s\n  i < ii\n\ngoal (1 subgoal):\n 1. j + i - ii < j &&& j + i - ii \\<le> length s", "by linarith+"], ["proof (state)\nthis:\n  j + i - ii < j\n  j + i - ii \\<le> length s\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "note \\<ff>_le[simp] = j_le_\\<ff>_le[OF assms(3)[THEN less_imp_le]]"], ["proof (state)\nthis:\n  \\<ff> s j \\<le> j\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "have \"0 < \\<ff> s j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<ff> s j", "using \\<open>0 < j\\<close> \\<ff>_eq_0_iff_j_eq_0 neq0_conv"], ["proof (prove)\nusing this:\n  0 < j\n  (\\<ff> ?s ?j = 0) = (?j = 0)\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. 0 < \\<ff> s j", "by blast"], ["proof (state)\nthis:\n  0 < \\<ff> s j\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "then"], ["proof (chain)\npicking this:\n  0 < \\<ff> s j", "have \"j + i - ii > \\<ff> s j - 1\""], ["proof (prove)\nusing this:\n  0 < \\<ff> s j\n\ngoal (1 subgoal):\n 1. \\<ff> s j - 1 < j + i - ii", "using \\<open>ii < i'\\<close> assignment \\<ff>_le"], ["proof (prove)\nusing this:\n  0 < \\<ff> s j\n  ii < i'\n  i' \\<equiv> i + (j - \\<ff> s j + 1)\n  \\<ff> s j \\<le> j\n\ngoal (1 subgoal):\n 1. \\<ff> s j - 1 < j + i - ii", "by linarith"], ["proof (state)\nthis:\n  \\<ff> s j - 1 < j + i - ii\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "then"], ["proof (chain)\npicking this:\n  \\<ff> s j - 1 < j + i - ii", "have contradiction_goal: \"j + i - ii > length (intrinsic_border (take j s))\""], ["proof (prove)\nusing this:\n  \\<ff> s j - 1 < j + i - ii\n\ngoal (1 subgoal):\n 1. length (intrinsic_border (take j s)) < j + i - ii", "by (metis \\<ff>.elims \\<open>0 < j\\<close> add_diff_cancel_right' not_gr_zero)"], ["proof (state)\nthis:\n  length (intrinsic_border (take j s)) < j + i - ii\n\ngoal (1 subgoal):\n 1. i < ii \\<Longrightarrow> \\<not> sublist_at s t ii", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sublist_at s t ii", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "assume \"sublist_at s t ii\""], ["proof (state)\nthis:\n  sublist_at s t ii\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "note sublist_all_positions[OF this]"], ["proof (state)\nthis:\n  \\<forall>jj<length s. t ! (ii + jj) = s ! jj\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "with le_s"], ["proof (chain)\npicking this:\n  j + i - ii \\<le> length s\n  \\<forall>jj<length s. t ! (ii + jj) = s ! jj", "have a: \"\\<forall>jj < j+i-ii. t!(ii+jj) = s!jj\""], ["proof (prove)\nusing this:\n  j + i - ii \\<le> length s\n  \\<forall>jj<length s. t ! (ii + jj) = s ! jj\n\ngoal (1 subgoal):\n 1. \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! jj", "by simp"], ["proof (state)\nthis:\n  \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! jj\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "have ff1: \"\\<not> ii < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ii < i", "by (metis not_less_iff_gr_or_eq skipped)"], ["proof (state)\nthis:\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> ii < i", "have \"i + (ii - i + jj) = ii + jj\" for jj"], ["proof (prove)\nusing this:\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. i + (ii - i + jj) = ii + jj", "by (metis add.assoc add_diff_inverse_nat)"], ["proof (state)\nthis:\n  i + (ii - i + ?jj) = ii + ?jj\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i + (ii - i + ?jj) = ii + ?jj", "have \"\\<not> jj < j + i - ii \\<or> t ! (ii + jj) = s ! (ii - i + jj)\" if \"ii - i + jj < j\" for jj"], ["proof (prove)\nusing this:\n  i + (ii - i + ?jj) = ii + ?jj\n\ngoal (1 subgoal):\n 1. \\<not> jj < j + i - ii \\<or> t ! (ii + jj) = s ! (ii - i + jj)", "using that ff1"], ["proof (prove)\nusing this:\n  i + (ii - i + ?jj) = ii + ?jj\n  ii - i + jj < j\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. \\<not> jj < j + i - ii \\<or> t ! (ii + jj) = s ! (ii - i + jj)", "by (metis matches)"], ["proof (state)\nthis:\n  ii - i + ?jj < j \\<Longrightarrow>\n  \\<not> ?jj < j + i - ii \\<or> t ! (ii + ?jj) = s ! (ii - i + ?jj)\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ii - i + ?jj < j \\<Longrightarrow>\n  \\<not> ?jj < j + i - ii \\<or> t ! (ii + ?jj) = s ! (ii - i + ?jj)", "have \"\\<not> jj < j + i - ii \\<or> t ! (ii + jj) = s ! (ii - i + jj)\" for jj"], ["proof (prove)\nusing this:\n  ii - i + ?jj < j \\<Longrightarrow>\n  \\<not> ?jj < j + i - ii \\<or> t ! (ii + ?jj) = s ! (ii - i + ?jj)\n\ngoal (1 subgoal):\n 1. \\<not> jj < j + i - ii \\<or> t ! (ii + jj) = s ! (ii - i + jj)", "using ff1"], ["proof (prove)\nusing this:\n  ii - i + ?jj < j \\<Longrightarrow>\n  \\<not> ?jj < j + i - ii \\<or> t ! (ii + ?jj) = s ! (ii - i + ?jj)\n  \\<not> ii < i\n\ngoal (1 subgoal):\n 1. \\<not> jj < j + i - ii \\<or> t ! (ii + jj) = s ! (ii - i + jj)", "by auto"], ["proof (state)\nthis:\n  \\<not> ?jj < j + i - ii \\<or> t ! (ii + ?jj) = s ! (ii - i + ?jj)\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "with matches"], ["proof (chain)\npicking this:\n  \\<forall>jj<j. t ! (i + jj) = s ! jj\n  \\<not> ?jj < j + i - ii \\<or> t ! (ii + ?jj) = s ! (ii - i + ?jj)", "have \"\\<forall>jj < j+i-ii. t!(ii+jj) = s!(ii-i+jj)\""], ["proof (prove)\nusing this:\n  \\<forall>jj<j. t ! (i + jj) = s ! jj\n  \\<not> ?jj < j + i - ii \\<or> t ! (ii + ?jj) = s ! (ii - i + ?jj)\n\ngoal (1 subgoal):\n 1. \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! (ii - i + jj)", "by metis"], ["proof (state)\nthis:\n  \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! (ii - i + jj)\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! (ii - i + jj)", "have \"\\<forall>jj < j+i-ii. s!jj = s!(ii-i+jj)\""], ["proof (prove)\nusing this:\n  \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! (ii - i + jj)\n\ngoal (1 subgoal):\n 1. \\<forall>jj<j + i - ii. s ! jj = s ! (ii - i + jj)", "using a"], ["proof (prove)\nusing this:\n  \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! (ii - i + jj)\n  \\<forall>jj<j + i - ii. t ! (ii + jj) = s ! jj\n\ngoal (1 subgoal):\n 1. \\<forall>jj<j + i - ii. s ! jj = s ! (ii - i + jj)", "by auto"], ["proof (state)\nthis:\n  \\<forall>jj<j + i - ii. s ! jj = s ! (ii - i + jj)\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>jj<j + i - ii. s ! jj = s ! (ii - i + jj)", "have \"\\<forall>jj < j+i-ii. (take j s)!jj = (take j s)!(ii-i+jj)\""], ["proof (prove)\nusing this:\n  \\<forall>jj<j + i - ii. s ! jj = s ! (ii - i + jj)\n\ngoal (1 subgoal):\n 1. \\<forall>jj<j + i - ii. take j s ! jj = take j s ! (ii - i + jj)", "using \\<open>i<ii\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>jj<j + i - ii. s ! jj = s ! (ii - i + jj)\n  i < ii\n\ngoal (1 subgoal):\n 1. \\<forall>jj<j + i - ii. take j s ! jj = take j s ! (ii - i + jj)", "by auto"], ["proof (state)\nthis:\n  \\<forall>jj<j + i - ii. take j s ! jj = take j s ! (ii - i + jj)\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "with positions_strict_border[of \"j+i-ii\" \"take j s\", simplified]"], ["proof (chain)\npicking this:\n  \\<forall>ja<j + i - ii.\n     take j s ! ja = take j s ! (ii - i + ja) \\<Longrightarrow>\n  strict_border (take (j + i - ii) s) (take j s)\n  \\<forall>jj<j + i - ii. take j s ! jj = take j s ! (ii - i + jj)", "have \"strict_border (take (j+i-ii) s) (take j s)\""], ["proof (prove)\nusing this:\n  \\<forall>ja<j + i - ii.\n     take j s ! ja = take j s ! (ii - i + ja) \\<Longrightarrow>\n  strict_border (take (j + i - ii) s) (take j s)\n  \\<forall>jj<j + i - ii. take j s ! jj = take j s ! (ii - i + jj)\n\ngoal (1 subgoal):\n 1. strict_border (take (j + i - ii) s) (take j s)", "."], ["proof (state)\nthis:\n  strict_border (take (j + i - ii) s) (take j s)\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "note intrinsic_border_max[OF this]"], ["proof (state)\nthis:\n  length (take (j + i - ii) s) \\<le> length (intrinsic_border (take j s))\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  length (take (j + i - ii) s) \\<le> length (intrinsic_border (take j s))\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "note contradiction_goal"], ["proof (state)\nthis:\n  length (intrinsic_border (take j s)) < j + i - ii\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  length (intrinsic_border (take j s)) < j + i - ii\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "have \"j+i-ii \\<le> length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j + i - ii \\<le> length s", "by (fact le_s)"], ["proof (state)\nthis:\n  j + i - ii \\<le> length s\n\ngoal (1 subgoal):\n 1. sublist_at s t ii \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  length (take (j + i - ii) s) < j + i - ii\n  j + i - ii \\<le> length s", "show False"], ["proof (prove)\nusing this:\n  length (take (j + i - ii) s) < j + i - ii\n  j + i - ii \\<le> length s\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> sublist_at s t ii\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> sublist_at s t ii\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kmp_correct: \"s \\<noteq> []\n  \\<Longrightarrow> kmp s t \\<le> kmp_SPEC s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp s t \\<le> kmp_SPEC s t", "unfolding kmp_def kmp_SPEC_def I_outer_def I_in_na_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow>\n    ASSERT (s \\<noteq> []) \\<bind>\n    (\\<lambda>_.\n        let i = 0; j = 0; pos = None\n        in WHILE\\<^sub>T\\<^bsup>\\<lambda>(i, j, pos).\n                                   (\\<forall>ii<i.\n \\<not> sublist_at s t ii) \\<and>\n                                   (case pos of\n                                    None \\<Rightarrow>\n(\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n                                    | Some p \\<Rightarrow>\n  p = i \\<and> sublist_at s t i)\\<^esup>\n            (\\<lambda>(i, j, pos).\n                i + length s \\<le> length t \\<and> pos = None)\n            (\\<lambda>(i, j, pos).\n                ASSERT (i + length s \\<le> length t) \\<bind>\n                (\\<lambda>_.\n                    WHILE\\<^sub>T\\<^bsup>\\<lambda>(j, pos).\n      case pos of\n      None \\<Rightarrow>\n        j < length s \\<and> (\\<forall>jj<j. t ! (i + jj) = s ! jj)\n      | Some p \\<Rightarrow> sublist_at s t i\\<^esup>\n                     (\\<lambda>(j, pos).\n                         t ! (i + j) = s ! j \\<and> pos = None)\n                     (\\<lambda>(j, pos).\n                         let j = j + 1\n                         in if j = length s then RETURN (j, Some i)\n                            else RETURN (j, None))\n                     (j, pos) \\<bind>\n                    (\\<lambda>(j, pos).\n                        if pos = None\n                        then ASSERT (j < length s) \\<bind>\n                             (\\<lambda>_.\n                                 let i = i + (j - \\<ff> s j + 1);\n                                     j = max 0 (\\<ff> s j - 1)\n                                 in RETURN (i, j, None))\n                        else RETURN (i, j, Some i))))\n            (i, j, pos) \\<bind>\n           (\\<lambda>(uu_, uu_, pos). RETURN pos))\n    \\<le> SPEC\n           (case_option (\\<not> Ex (sublist_at s t))\n             (\\<lambda>i.\n                 sublist_at s t i \\<and>\n                 (\\<forall>ii<i. \\<not> sublist_at s t ii)))", "apply (refine_vcg\n    WHILEIT_rule[where R=\"measure (\\<lambda>(i,_,pos). length t - i + (if pos = None then 1 else 0))\"]\n    WHILEIT_rule[where R=\"measure (\\<lambda>(j,_::nat option). length s - j)\"]\n    )"], ["proof (prove)\ngoal (18 subgoals):\n 1. \\<lbrakk>s \\<noteq> []; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wf (measure\n                           (\\<lambda>(i, uu_, pos).\n                               length t - i +\n                               (if pos = None then 1 else 0)))\n 2. \\<And>x1 x2 x1a x2a ii.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; x2 = (x1a, x2a);\n        (0, 0, None) = (x1, x2); ii < x1\\<rbrakk>\n       \\<Longrightarrow> \\<not> sublist_at s t ii\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; x2 = (x1a, x2a);\n        (0, 0, None) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2a of\n                         None \\<Rightarrow>\n                           (\\<forall>jj<x1a. t ! (x1 + jj) = s ! jj) \\<and>\n                           x1a < length s\n                         | Some p \\<Rightarrow>\n                             p = x1 \\<and> sublist_at s t x1\n 4. \\<And>sa a b aa ba.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of\n           None \\<Rightarrow>\n             (\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> a + length s \\<le> length t\n 5. \\<And>sa a b aa ba.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of\n           None \\<Rightarrow>\n             (\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba); a + length s \\<le> length t\\<rbrakk>\n       \\<Longrightarrow> wf (measure (\\<lambda>(j, uu_). length s - j))\n 6. \\<And>sa a b aa ba x1 x2.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of\n           None \\<Rightarrow>\n             (\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba); a + length s \\<le> length t;\n        (aa, ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2 of\n                         None \\<Rightarrow>\n                           x1 < length s \\<and>\n                           (\\<forall>jj<x1. t ! (a + jj) = s ! jj)\n                         | Some p \\<Rightarrow> sublist_at s t a\n 7. \\<And>sa a b aa ba saa ab bb x1 x2.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of\n           None \\<Rightarrow>\n             (\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba); a + length s \\<le> length t;\n        case saa of\n        (j, None) \\<Rightarrow>\n          j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n        | (j, Some p) \\<Rightarrow> sublist_at s t a;\n        case saa of\n        (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n        saa = (ab, bb); ab + 1 = length s;\n        (ab + 1, Some a) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2 of\n                         None \\<Rightarrow>\n                           x1 < length s \\<and>\n                           (\\<forall>jj<x1. t ! (a + jj) = s ! jj)\n                         | Some p \\<Rightarrow> sublist_at s t a\n 8. \\<And>sa a b aa ba saa ab bb.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of\n           None \\<Rightarrow>\n             (\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba); a + length s \\<le> length t;\n        case saa of\n        (j, None) \\<Rightarrow>\n          j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n        | (j, Some p) \\<Rightarrow> sublist_at s t a;\n        case saa of\n        (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n        saa = (ab, bb); ab + 1 = length s\\<rbrakk>\n       \\<Longrightarrow> ((ab + 1, Some a), saa)\n                         \\<in> measure (\\<lambda>(j, uu_). length s - j)\n 9. \\<And>sa a b aa ba saa ab bb x1 x2.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n          (case pos of\n           None \\<Rightarrow>\n             (\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n           | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n        case sa of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        sa = (a, b); b = (aa, ba); a + length s \\<le> length t;\n        case saa of\n        (j, None) \\<Rightarrow>\n          j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n        | (j, Some p) \\<Rightarrow> sublist_at s t a;\n        case saa of\n        (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n        saa = (ab, bb); ab + 1 \\<noteq> length s;\n        (ab + 1, None) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x2 of\n                         None \\<Rightarrow>\n                           x1 < length s \\<and>\n                           (\\<forall>jj<x1. t ! (a + jj) = s ! jj)\n                         | Some p \\<Rightarrow> sublist_at s t a\n 10. \\<And>sa a b aa ba saa ab bb.\n        \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n         case sa of\n         (i, j, pos) \\<Rightarrow>\n           (\\<forall>ii<i. \\<not> sublist_at s t ii) \\<and>\n           (case pos of\n            None \\<Rightarrow>\n              (\\<forall>jj<j. t ! (i + jj) = s ! jj) \\<and> j < length s\n            | Some p \\<Rightarrow> p = i \\<and> sublist_at s t i);\n         case sa of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         sa = (a, b); b = (aa, ba); a + length s \\<le> length t;\n         case saa of\n         (j, None) \\<Rightarrow>\n           j < length s \\<and> (\\<forall>jj<j. t ! (a + jj) = s ! jj)\n         | (j, Some p) \\<Rightarrow> sublist_at s t a;\n         case saa of\n         (j, pos) \\<Rightarrow> t ! (a + j) = s ! j \\<and> pos = None;\n         saa = (ab, bb); ab + 1 \\<noteq> length s\\<rbrakk>\n        \\<Longrightarrow> ((ab + 1, None), saa)\n                          \\<in> measure (\\<lambda>(j, uu_). length s - j)\nA total of 18 subgoals...", "apply (vc_solve solve: asm_rl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ab aaa aba.\n       \\<lbrakk>s \\<noteq> []; Suc (ab + aba) \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj; t ! (ab + aba) = s ! aba;\n        length s = Suc aba; \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        aaa < Suc aba\\<rbrakk>\n       \\<Longrightarrow> sublist_at s t ab\n 2. \\<And>ab aaa aba jj.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        t ! (ab + aba) = s ! aba; Suc aba \\<noteq> length s;\n        \\<forall>ii<ab. \\<not> sublist_at s t ii; aba < length s;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s;\n        jj < Suc aba\\<rbrakk>\n       \\<Longrightarrow> t ! (ab + jj) = s ! jj\n 3. \\<And>ab aaa aba ii.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        t ! (ab + aba) \\<noteq> s ! aba; aba < length s;\n        ii < Suc (ab + (aba - \\<ff> s aba));\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s;\n        sublist_at s t ii\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>ab aaa aba.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        t ! (ab + aba) \\<noteq> s ! aba; aba < length s;\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>jj<\\<ff> s aba - Suc 0.\n                             t ! Suc (ab + (aba - \\<ff> s aba) + jj) =\n                             s ! jj) \\<and>\n                         \\<ff> s aba - Suc 0 < length s\n 5. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of\n        None \\<Rightarrow>\n          (\\<forall>jj<aaa. t ! (ab + jj) = s ! jj) \\<and> aaa < length s\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; Suc (ab_ + aba_) \\<le> length t;\n     \\<forall>jj<aba_. t ! (ab_ + jj) = s ! jj; t ! (ab_ + aba_) = s ! aba_;\n     length s = Suc aba_; \\<forall>ii<ab_. \\<not> sublist_at s t ii;\n     aaa_ < Suc aba_\\<rbrakk>\n    \\<Longrightarrow> sublist_at s t ab_", "by (metis add_Suc_right all_positions_sublist less_antisym)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab aaa aba jj.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        t ! (ab + aba) = s ! aba; Suc aba \\<noteq> length s;\n        \\<forall>ii<ab. \\<not> sublist_at s t ii; aba < length s;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s;\n        jj < Suc aba\\<rbrakk>\n       \\<Longrightarrow> t ! (ab + jj) = s ! jj\n 2. \\<And>ab aaa aba ii.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        t ! (ab + aba) \\<noteq> s ! aba; aba < length s;\n        ii < Suc (ab + (aba - \\<ff> s aba));\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s;\n        sublist_at s t ii\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ab aaa aba.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        t ! (ab + aba) \\<noteq> s ! aba; aba < length s;\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>jj<\\<ff> s aba - Suc 0.\n                             t ! Suc (ab + (aba - \\<ff> s aba) + jj) =\n                             s ! jj) \\<and>\n                         \\<ff> s aba - Suc 0 < length s\n 4. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of\n        None \\<Rightarrow>\n          (\\<forall>jj<aaa. t ! (ab + jj) = s ! jj) \\<and> aaa < length s\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; ab_ + length s \\<le> length t;\n     t ! (ab_ + aba_) = s ! aba_; Suc aba_ \\<noteq> length s;\n     \\<forall>ii<ab_. \\<not> sublist_at s t ii; aba_ < length s;\n     \\<forall>jj<aba_. t ! (ab_ + jj) = s ! jj;\n     \\<forall>jj<aaa_. t ! (ab_ + jj) = s ! jj; aaa_ < length s;\n     jj_ < Suc aba_\\<rbrakk>\n    \\<Longrightarrow> t ! (ab_ + jj_) = s ! jj_", "using less_antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> ?n < ?m; ?n < Suc ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; ab_ + length s \\<le> length t;\n     t ! (ab_ + aba_) = s ! aba_; Suc aba_ \\<noteq> length s;\n     \\<forall>ii<ab_. \\<not> sublist_at s t ii; aba_ < length s;\n     \\<forall>jj<aba_. t ! (ab_ + jj) = s ! jj;\n     \\<forall>jj<aaa_. t ! (ab_ + jj) = s ! jj; aaa_ < length s;\n     jj_ < Suc aba_\\<rbrakk>\n    \\<Longrightarrow> t ! (ab_ + jj_) = s ! jj_", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab aaa aba ii.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        t ! (ab + aba) \\<noteq> s ! aba; aba < length s;\n        ii < Suc (ab + (aba - \\<ff> s aba));\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s;\n        sublist_at s t ii\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab aaa aba.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        t ! (ab + aba) \\<noteq> s ! aba; aba < length s;\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>jj<\\<ff> s aba - Suc 0.\n                             t ! Suc (ab + (aba - \\<ff> s aba) + jj) =\n                             s ! jj) \\<and>\n                         \\<ff> s aba - Suc 0 < length s\n 3. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of\n        None \\<Rightarrow>\n          (\\<forall>jj<aaa. t ! (ab + jj) = s ! jj) \\<and> aaa < length s\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal for i jout j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; i + length s \\<le> length t;\n     \\<forall>jj<j. t ! (i + jj) = s ! jj; t ! (i + j) \\<noteq> s ! j;\n     j < length s; ii_ < Suc (i + (j - \\<ff> s j));\n     \\<forall>ii<i. \\<not> sublist_at s t ii;\n     \\<forall>jj<jout. t ! (i + jj) = s ! jj; jout < length s;\n     sublist_at s t ii_\\<rbrakk>\n    \\<Longrightarrow> False", "using shift_safe[of i s t j]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ii<i. \\<not> sublist_at s t ii;\n   t ! (i + j) \\<noteq> s ! j; j < length s;\n   \\<forall>jj<j. t ! (i + jj) = s ! jj\\<rbrakk>\n  \\<Longrightarrow> \\<forall>ii<i + (j - \\<ff> s j + 1).\n                       \\<not> sublist_at s t ii\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; i + length s \\<le> length t;\n     \\<forall>jj<j. t ! (i + jj) = s ! jj; t ! (i + j) \\<noteq> s ! j;\n     j < length s; ii_ < Suc (i + (j - \\<ff> s j));\n     \\<forall>ii<i. \\<not> sublist_at s t ii;\n     \\<forall>jj<jout. t ! (i + jj) = s ! jj; jout < length s;\n     sublist_at s t ii_\\<rbrakk>\n    \\<Longrightarrow> False", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab aaa aba.\n       \\<lbrakk>s \\<noteq> []; ab + length s \\<le> length t;\n        \\<forall>jj<aba. t ! (ab + jj) = s ! jj;\n        t ! (ab + aba) \\<noteq> s ! aba; aba < length s;\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        \\<forall>jj<aaa. t ! (ab + jj) = s ! jj; aaa < length s\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>jj<\\<ff> s aba - Suc 0.\n                             t ! Suc (ab + (aba - \\<ff> s aba) + jj) =\n                             s ! jj) \\<and>\n                         \\<ff> s aba - Suc 0 < length s\n 2. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of\n        None \\<Rightarrow>\n          (\\<forall>jj<aaa. t ! (ab + jj) = s ! jj) \\<and> aaa < length s\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal for i jout j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; i + length s \\<le> length t;\n     \\<forall>jj<j. t ! (i + jj) = s ! jj; t ! (i + j) \\<noteq> s ! j;\n     j < length s; \\<forall>ii<i. \\<not> sublist_at s t ii;\n     \\<forall>jj<jout. t ! (i + jj) = s ! jj; jout < length s\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>jj<\\<ff> s j - Suc 0.\n                          t ! Suc (i + (j - \\<ff> s j) + jj) =\n                          s ! jj) \\<and>\n                      \\<ff> s j - Suc 0 < length s", "using reuse_matches[of j s t i] \\<ff>_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>j \\<le> length s; \\<forall>jj<j. t ! (i + jj) = s ! jj\\<rbrakk>\n  \\<Longrightarrow> \\<forall>jj<\\<ff> s j - 1.\n                       t ! (i + (j - \\<ff> s j + 1) + jj) = s ! jj\n  ?s \\<noteq> [] \\<Longrightarrow> \\<ff> ?s ?j - 1 < length ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; i + length s \\<le> length t;\n     \\<forall>jj<j. t ! (i + jj) = s ! jj; t ! (i + j) \\<noteq> s ! j;\n     j < length s; \\<forall>ii<i. \\<not> sublist_at s t ii;\n     \\<forall>jj<jout. t ! (i + jj) = s ! jj; jout < length s\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>jj<\\<ff> s j - Suc 0.\n                          t ! Suc (i + (j - \\<ff> s j) + jj) =\n                          s ! jj) \\<and>\n                      \\<ff> s j - Suc 0 < length s", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab aaa baa.\n       \\<lbrakk>s \\<noteq> [];\n        ab + length s \\<le> length t \\<longrightarrow>\n        (\\<exists>y. baa = Some y);\n        \\<forall>ii<ab. \\<not> sublist_at s t ii;\n        case baa of\n        None \\<Rightarrow>\n          (\\<forall>jj<aaa. t ! (ab + jj) = s ! jj) \\<and> aaa < length s\n        | Some p \\<Rightarrow> p = ab \\<and> sublist_at s t ab\\<rbrakk>\n       \\<Longrightarrow> case baa of\n                         None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                         | Some i \\<Rightarrow>\n                             sublist_at s t i \\<and>\n                             (\\<forall>ii<i. \\<not> sublist_at s t ii)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> [];\n     ab_ + length s \\<le> length t \\<longrightarrow>\n     (\\<exists>y. baa_ = Some y);\n     \\<forall>ii<ab_. \\<not> sublist_at s t ii;\n     case baa_ of\n     None \\<Rightarrow>\n       (\\<forall>jj<aaa_. t ! (ab_ + jj) = s ! jj) \\<and> aaa_ < length s\n     | Some p \\<Rightarrow> p = ab_ \\<and> sublist_at s t ab_\\<rbrakk>\n    \\<Longrightarrow> case baa_ of\n                      None \\<Rightarrow> \\<not> Ex (sublist_at s t)\n                      | Some i \\<Rightarrow>\n                          sublist_at s t i \\<and>\n                          (\\<forall>ii<i. \\<not> sublist_at s t ii)", "by (auto split: option.splits) (metis sublist_lengths add_less_cancel_right leI le_less_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Storing the @{const \\<ff>}-values\\<close>"], ["", "text\\<open>We refine the algorithm to compute the @{const \\<ff>}-values only once at the start:\\<close>"], ["", "definition compute_\\<ff>s_SPEC :: \"'a list \\<Rightarrow> nat list nres\" where\n  \"compute_\\<ff>s_SPEC s \\<equiv> SPEC (\\<lambda>\\<ff>s. length \\<ff>s = length s + 1 \\<and> (\\<forall>j\\<le>length s. \\<ff>s!j = \\<ff> s j))\""], ["", "definition \"kmp1 s t \\<equiv> do {\n  ASSERT (s \\<noteq> []);\n  let i=0;\n  let j=0;\n  let pos=None;\n  \\<ff>s \\<leftarrow> compute_\\<ff>s_SPEC (butlast s); \\<comment> \\<open>At the last char, we abort instead.\\<close>\n  (_,_,pos) \\<leftarrow> WHILEIT (I_outer s t) (\\<lambda>(i,j,pos). i + length s \\<le> length t \\<and> pos=None) (\\<lambda>(i,j,pos). do {\n    ASSERT (i + length s \\<le> length t);\n    (j,pos) \\<leftarrow> WHILEIT (I_in_na s t i) (\\<lambda>(j,pos). t!(i+j) = s!j \\<and> pos=None) (\\<lambda>(j,pos). do {\n      let j=j+1;\n      if j=length s then RETURN (j,Some i) else RETURN (j,None)\n    }) (j,pos);\n    if pos=None then do {\n      ASSERT (j < length \\<ff>s);\n      let i = i + (j - \\<ff>s!j + 1);\n      let j = max 0 (\\<ff>s!j - 1); \\<comment> \\<open>\\<open>max\\<close> not necessary\\<close>\n      RETURN (i,j,None)\n    } else RETURN (i,j,Some i)\n  }) (i,j,pos);\n\n  RETURN pos\n}\""], ["", "lemma \\<ff>_butlast[simp]: \"j < length s \\<Longrightarrow> \\<ff> (butlast s) j = \\<ff> s j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length s \\<Longrightarrow> \\<ff> (butlast s) j = \\<ff> s j", "by (cases j) (simp_all add: take_butlast)"], ["", "lemma kmp1_refine: \"kmp1 s t \\<le> kmp s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp1 s t \\<le> kmp s t", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp1 s t \\<le> \\<Down> Id (kmp s t)", "unfolding kmp1_def kmp_def Let_def compute_\\<ff>s_SPEC_def nres_monad_laws"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (s \\<noteq> []) \\<bind>\n    (\\<lambda>_.\n        SPEC\n         (\\<lambda>\\<ff>s.\n             length \\<ff>s = length (butlast s) + 1 \\<and>\n             (\\<forall>j\\<le>length (butlast s).\n                 \\<ff>s ! j = \\<ff> (butlast s) j)) \\<bind>\n        (\\<lambda>\\<ff>s.\n            WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n             (\\<lambda>(i, j, pos).\n                 i + length s \\<le> length t \\<and> pos = None)\n             (\\<lambda>(i, j, pos).\n                 ASSERT (i + length s \\<le> length t) \\<bind>\n                 (\\<lambda>_.\n                     WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n                      (\\<lambda>(j, pos).\n                          t ! (i + j) = s ! j \\<and> pos = None)\n                      (\\<lambda>(j, pos).\n                          if j + 1 = length s then RETURN (j + 1, Some i)\n                          else RETURN (j + 1, None))\n                      (j, pos) \\<bind>\n                     (\\<lambda>(j, pos).\n                         if pos = None\n                         then ASSERT (j < length \\<ff>s) \\<bind>\n                              (\\<lambda>_.\n                                  RETURN\n                                   (i + (j - \\<ff>s ! j + 1),\n                                    max 0 (\\<ff>s ! j - 1), None))\n                         else RETURN (i, j, Some i))))\n             (0, 0, None) \\<bind>\n            (\\<lambda>(_, uu_, y). RETURN y)))\n    \\<le> \\<Down> Id\n           (ASSERT (s \\<noteq> []) \\<bind>\n            (\\<lambda>_.\n                WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                 (\\<lambda>(i, j, pos).\n                     i + length s \\<le> length t \\<and> pos = None)\n                 (\\<lambda>(i, j, pos).\n                     ASSERT (i + length s \\<le> length t) \\<bind>\n                     (\\<lambda>_.\n                         WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n                          (\\<lambda>(j, pos).\n                              t ! (i + j) = s ! j \\<and> pos = None)\n                          (\\<lambda>(j, pos).\n                              if j + 1 = length s\n                              then RETURN (j + 1, Some i)\n                              else RETURN (j + 1, None))\n                          (j, pos) \\<bind>\n                         (\\<lambda>(j, pos).\n                             if pos = None\n                             then ASSERT (j < length s) \\<bind>\n                                  (\\<lambda>_.\nRETURN (i + (j - \\<ff> s j + 1), max 0 (\\<ff> s j - 1), None))\n                             else RETURN (i, j, Some i))))\n                 (0, 0, None) \\<bind>\n                (\\<lambda>(_, uu_, y). RETURN y)))", "apply (intro ASSERT_refine_right ASSERT_refine_left)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<noteq> [] \\<Longrightarrow> s \\<noteq> []\n 2. \\<lbrakk>s \\<noteq> []; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>\\<ff>s.\n                           length \\<ff>s = length (butlast s) + 1 \\<and>\n                           (\\<forall>j\\<le>length (butlast s).\n                               \\<ff>s ! j = \\<ff> (butlast s) j)) \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT (i + length s \\<le> length t) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  t ! (i + j) = s ! j \\<and> pos = None)\n                                    (\\<lambda>(j, pos).\n  if j + 1 = length s then RETURN (j + 1, Some i) else RETURN (j + 1, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          RETURN (i + (j - \\<ff>s ! j + 1), max 0 (\\<ff>s ! j - 1), None))\n else RETURN (i, j, Some i))))\n                           (0, 0, None) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y))\n                      \\<le> \\<Down> Id\n                             (WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                               (\\<lambda>(i, j, pos).\n                                   i + length s \\<le> length t \\<and>\n                                   pos = None)\n                               (\\<lambda>(i, j, pos).\n                                   ASSERT\n                                    (i + length s \\<le> length t) \\<bind>\n                                   (\\<lambda>_.\n WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n  (\\<lambda>(j, pos). t ! (i + j) = s ! j \\<and> pos = None)\n  (\\<lambda>(j, pos).\n      if j + 1 = length s then RETURN (j + 1, Some i)\n      else RETURN (j + 1, None))\n  (j, pos) \\<bind>\n (\\<lambda>(j, pos).\n     if pos = None\n     then ASSERT (j < length s) \\<bind>\n          (\\<lambda>_.\n              RETURN (i + (j - \\<ff> s j + 1), max 0 (\\<ff> s j - 1), None))\n     else RETURN (i, j, Some i))))\n                               (0, 0, None) \\<bind>\n                              (\\<lambda>(_, uu_, y). RETURN y))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> []; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> SPEC\n                       (\\<lambda>\\<ff>s.\n                           length \\<ff>s = length (butlast s) + 1 \\<and>\n                           (\\<forall>j\\<le>length (butlast s).\n                               \\<ff>s ! j = \\<ff> (butlast s) j)) \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT (i + length s \\<le> length t) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  t ! (i + j) = s ! j \\<and> pos = None)\n                                    (\\<lambda>(j, pos).\n  if j + 1 = length s then RETURN (j + 1, Some i) else RETURN (j + 1, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          RETURN (i + (j - \\<ff>s ! j + 1), max 0 (\\<ff>s ! j - 1), None))\n else RETURN (i, j, Some i))))\n                           (0, 0, None) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y))\n                      \\<le> \\<Down> Id\n                             (WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                               (\\<lambda>(i, j, pos).\n                                   i + length s \\<le> length t \\<and>\n                                   pos = None)\n                               (\\<lambda>(i, j, pos).\n                                   ASSERT\n                                    (i + length s \\<le> length t) \\<bind>\n                                   (\\<lambda>_.\n WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n  (\\<lambda>(j, pos). t ! (i + j) = s ! j \\<and> pos = None)\n  (\\<lambda>(j, pos).\n      if j + 1 = length s then RETURN (j + 1, Some i)\n      else RETURN (j + 1, None))\n  (j, pos) \\<bind>\n (\\<lambda>(j, pos).\n     if pos = None\n     then ASSERT (j < length s) \\<bind>\n          (\\<lambda>_.\n              RETURN (i + (j - \\<ff> s j + 1), max 0 (\\<ff> s j - 1), None))\n     else RETURN (i, j, Some i))))\n                               (0, 0, None) \\<bind>\n                              (\\<lambda>(_, uu_, y). RETURN y))", "apply (rule Refine_Basic.intro_spec_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<ff>s.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)}\\<rbrakk>\n       \\<Longrightarrow> WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                          (\\<lambda>(i, j, pos).\n                              i + length s \\<le> length t \\<and> pos = None)\n                          (\\<lambda>(i, j, pos).\n                              ASSERT (i + length s \\<le> length t) \\<bind>\n                              (\\<lambda>_.\n                                  WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n                                   (\\<lambda>(j, pos).\n t ! (i + j) = s ! j \\<and> pos = None)\n                                   (\\<lambda>(j, pos).\n if j + 1 = length s then RETURN (j + 1, Some i) else RETURN (j + 1, None))\n                                   (j, pos) \\<bind>\n                                  (\\<lambda>(j, pos).\nif pos = None\nthen ASSERT (j < length \\<ff>s) \\<bind>\n     (\\<lambda>_.\n         RETURN (i + (j - \\<ff>s ! j + 1), max 0 (\\<ff>s ! j - 1), None))\nelse RETURN (i, j, Some i))))\n                          (0, 0, None) \\<bind>\n                         (\\<lambda>(_, uu_, y). RETURN y)\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                                  (\\<lambda>(i, j, pos).\ni + length s \\<le> length t \\<and> pos = None)\n                                  (\\<lambda>(i, j, pos).\nASSERT (i + length s \\<le> length t) \\<bind>\n(\\<lambda>_.\n    WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n     (\\<lambda>(j, pos). t ! (i + j) = s ! j \\<and> pos = None)\n     (\\<lambda>(j, pos).\n         if j + 1 = length s then RETURN (j + 1, Some i)\n         else RETURN (j + 1, None))\n     (j, pos) \\<bind>\n    (\\<lambda>(j, pos).\n        if pos = None\n        then ASSERT (j < length s) \\<bind>\n             (\\<lambda>_.\n                 RETURN\n                  (i + (j - \\<ff> s j + 1), max 0 (\\<ff> s j - 1), None))\n        else RETURN (i, j, Some i))))\n                                  (0, 0, None) \\<bind>\n                                 (\\<lambda>(_, uu_, y). RETURN y))", "apply refine_rcg"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>\\<ff>s.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        I_outer s t (0, 0, None)\\<rbrakk>\n       \\<Longrightarrow> ((0, 0, None), 0, 0, None) \\<in> ?R'6 \\<ff>s\n 2. \\<And>\\<ff>s x x'.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s; I_outer s t x'\\<rbrakk>\n       \\<Longrightarrow> I_outer s t x\n 3. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s; I_outer s t x; I_outer s t x';\n        x2 = (x1a, x2a); x = (x1, x2); x2b = (x1c, x2c);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1 + length s \\<le> length t \\<and> x2a = None) =\n                         (x1b + length s \\<le> length t \\<and> x2c = None)\n 4. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        x1 + length s \\<le> length t\\<rbrakk>\n       \\<Longrightarrow> x1b + length s \\<le> length t\n 5. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t; I_in_na s t x1 (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a)\n                         \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c\n                                x2c\n 6. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a) \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        I_in_na s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> I_in_na s t x1b xa\n 7. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a) \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; xa = (x1d, x2d);\n        x'a = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (t ! (x1b + x1d) = s ! x1d \\<and> x2d = None) =\n                         (t ! (x1 + x1e) = s ! x1e \\<and> x2e = None)\n 8. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a) \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        case xa of\n        (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n        case x'a of\n        (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n        xa = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (x1e + 1 = length s) = (x1d + 1 = length s)\n 9. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x') \\<in> ?R'6 \\<ff>s;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a) \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        case xa of\n        (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n        case x'a of\n        (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n        xa = (x1e, x2e); x1e + 1 = length s; x1d + 1 = length s\\<rbrakk>\n       \\<Longrightarrow> ((x1e + 1, Some x1b), x1d + 1, Some x1)\n                         \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c\n                                x2c\n 10. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n        \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n         \\<ff>s\n         \\<in> {\\<ff>s.\n                length \\<ff>s = length (butlast s) + 1 \\<and>\n                (\\<forall>j\\<le>length (butlast s).\n                    \\<ff>s ! j = \\<ff> (butlast s) j)};\n         (x, x') \\<in> ?R'6 \\<ff>s;\n         case x of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         case x' of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n         x1b + length s \\<le> length t;\n         (xa, x'a) \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n         case xa of\n         (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n         case x'a of\n         (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n         I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n         xa = (x1e, x2e); x1e + 1 \\<noteq> length s;\n         x1d + 1 \\<noteq> length s\\<rbrakk>\n        \\<Longrightarrow> ((x1e + 1, None), x1d + 1, None)\n                          \\<in> ?R'114 \\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c\n                                 x2c\nA total of 15 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>\\<ff>s.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        I_outer s t (0, 0, None)\\<rbrakk>\n       \\<Longrightarrow> ((0, 0, None), 0, 0, None)\n                         \\<in> nat_rel \\<times>\\<^sub>r\n                               nat_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>option_rel\n 2. \\<And>\\<ff>s x x'.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_outer s t x'\\<rbrakk>\n       \\<Longrightarrow> I_outer s t x\n 3. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x = (x1, x2);\n        x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1 + length s \\<le> length t \\<and> x2a = None) =\n                         (x1b + length s \\<le> length t \\<and> x2c = None)\n 4. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        x1 + length s \\<le> length t\\<rbrakk>\n       \\<Longrightarrow> x1b + length s \\<le> length t\n 5. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t; I_in_na s t x1 (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a)\n                         \\<in> nat_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>option_rel\n 6. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a)\n        \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_in_na s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> I_in_na s t x1b xa\n 7. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a)\n        \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; xa = (x1d, x2d);\n        x'a = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (t ! (x1b + x1d) = s ! x1d \\<and> x2d = None) =\n                         (t ! (x1 + x1e) = s ! x1e \\<and> x2e = None)\n 8. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a)\n        \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case xa of\n        (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n        case x'a of\n        (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n        xa = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (x1e + 1 = length s) = (x1d + 1 = length s)\n 9. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n        \\<ff>s\n        \\<in> {\\<ff>s.\n               length \\<ff>s = length (butlast s) + 1 \\<and>\n               (\\<forall>j\\<le>length (butlast s).\n                   \\<ff>s ! j = \\<ff> (butlast s) j)};\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t;\n        (xa, x'a)\n        \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case xa of\n        (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n        case x'a of\n        (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n        xa = (x1e, x2e); x1e + 1 = length s; x1d + 1 = length s\\<rbrakk>\n       \\<Longrightarrow> ((x1e + 1, Some x1b), x1d + 1, Some x1)\n                         \\<in> nat_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>option_rel\n 10. \\<And>\\<ff>s x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n        \\<lbrakk>s \\<noteq> []; s \\<noteq> [];\n         \\<ff>s\n         \\<in> {\\<ff>s.\n                length \\<ff>s = length (butlast s) + 1 \\<and>\n                (\\<forall>j\\<le>length (butlast s).\n                    \\<ff>s ! j = \\<ff> (butlast s) j)};\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n         case x of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         case x' of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n         x1b + length s \\<le> length t;\n         (xa, x'a)\n         \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n         case xa of\n         (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n         case x'a of\n         (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n         I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n         xa = (x1e, x2e); x1e + 1 \\<noteq> length s;\n         x1d + 1 \\<noteq> length s\\<rbrakk>\n        \\<Longrightarrow> ((x1e + 1, None), x1d + 1, None)\n                          \\<in> nat_rel \\<times>\\<^sub>r\n                                \\<langle>nat_rel\\<rangle>option_rel\nA total of 15 subgoals...", "apply vc_solve"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Next, an algorithm that satisfies @{const compute_\\<ff>s_SPEC}:\\<close>"], ["", "subsection\\<open>Computing @{const \\<ff>}\\<close>"], ["", "subsubsection\\<open>Invariants\\<close>"], ["", "definition \"I_out_cb s \\<equiv> \\<lambda>(\\<ff>s,i,j).\n  length s + 1 = length \\<ff>s \\<and>\n  (\\<forall>jj<j. \\<ff>s!jj = \\<ff> s jj) \\<and>\n  \\<ff>s!(j-1) = i \\<and>\n  0 < j\""], ["", "definition \"I_in_cb s j \\<equiv> \\<lambda>i.\n  if j=1 then i=0 \\<comment> \\<open>first iteration\\<close>\n  else\n    strict_border (take (i-1) s) (take (j-1) s) \\<and>\n    \\<ff> s j \\<le> i + 1\""], ["", "subsubsection\\<open>Algorithm\\<close>"], ["", "text\\<open>Again, we follow Seidl@{cite GAD}, p.582. Apart from the +1-shift, we make another modification:\nInstead of directly setting @{term \\<open>\\<ff>s!1\\<close>}, we let the first loop-iteration (if there is one) do that for us.\nThis allows us to remove the precondition @{prop \\<open>s \\<noteq> []\\<close>}, as the index bounds are respected even in that corner case.\\<close>"], ["", "definition compute_\\<ff>s :: \"'a list \\<Rightarrow> nat list nres\" where\n  \"compute_\\<ff>s s = do {\n  let \\<ff>s=replicate (length s + 1) 0; \\<comment> \\<open>only the first 0 is needed\\<close>\n  let i=0;\n  let j=1;\n  (\\<ff>s,_,_) \\<leftarrow> WHILEIT (I_out_cb s) (\\<lambda>(\\<ff>s,_,j). j < length \\<ff>s) (\\<lambda>(\\<ff>s,i,j). do {\n    i \\<leftarrow> WHILEIT (I_in_cb s j) (\\<lambda>i. i>0 \\<and> s!(i-1) \\<noteq> s!(j-1)) (\\<lambda>i. do {\n      ASSERT (i-1 < length \\<ff>s);\n      let i=\\<ff>s!(i-1);\n      RETURN i\n    }) i;\n    let i=i+1;\n    ASSERT (j < length \\<ff>s);\n    let \\<ff>s=\\<ff>s[j:=i];\n    let j=j+1;\n    RETURN (\\<ff>s,i,j)\n  }) (\\<ff>s,i,j);\n  \n  RETURN \\<ff>s\n}\""], ["", "subsubsection\\<open>Correctness\\<close>"], ["", "lemma take_length_ib[simp]:\n  assumes \"0 < j\" \"j \\<le> length s\"\n    shows \"take (length (intrinsic_border (take j s))) s = intrinsic_border (take j s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length (intrinsic_border (take j s))) s =\n    intrinsic_border (take j s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (length (intrinsic_border (take j s))) s =\n    intrinsic_border (take j s)", "from assms"], ["proof (chain)\npicking this:\n  0 < j\n  j \\<le> length s", "have \"prefix (intrinsic_border (take j s)) (take j s)\""], ["proof (prove)\nusing this:\n  0 < j\n  j \\<le> length s\n\ngoal (1 subgoal):\n 1. prefix (intrinsic_border (take j s)) (take j s)", "by (metis intrinsic_borderI' border_def list.size(3) neq0_conv not_less strict_border_def take_eq_Nil)"], ["proof (state)\nthis:\n  prefix (intrinsic_border (take j s)) (take j s)\n\ngoal (1 subgoal):\n 1. take (length (intrinsic_border (take j s))) s =\n    intrinsic_border (take j s)", "also"], ["proof (state)\nthis:\n  prefix (intrinsic_border (take j s)) (take j s)\n\ngoal (1 subgoal):\n 1. take (length (intrinsic_border (take j s))) s =\n    intrinsic_border (take j s)", "have \"prefix (take j s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take j s) s", "by (simp add: \\<open>j \\<le> length s\\<close> take_is_prefix)"], ["proof (state)\nthis:\n  prefix (take j s) s\n\ngoal (1 subgoal):\n 1. take (length (intrinsic_border (take j s))) s =\n    intrinsic_border (take j s)", "finally"], ["proof (chain)\npicking this:\n  prefix (intrinsic_border (take j s)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix (intrinsic_border (take j s)) s\n\ngoal (1 subgoal):\n 1. take (length (intrinsic_border (take j s))) s =\n    intrinsic_border (take j s)", "by (metis append_eq_conv_conj prefixE)"], ["proof (state)\nthis:\n  take (length (intrinsic_border (take j s))) s =\n  intrinsic_border (take j s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ib_singleton[simp]: \"intrinsic_border [z] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intrinsic_border [z] = []", "by (metis intrinsic_border_less length_Cons length_greater_0_conv less_Suc0 list.size(3))"], ["", "lemma border_butlast: \"border xs ys \\<Longrightarrow> border (butlast xs) (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. border xs ys \\<Longrightarrow> border (butlast xs) (butlast ys)", "apply (auto simp: border_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prefix xs ys; suffix xs ys\\<rbrakk>\n    \\<Longrightarrow> prefix (butlast xs) (butlast ys)\n 2. \\<lbrakk>prefix xs ys; suffix xs ys\\<rbrakk>\n    \\<Longrightarrow> suffix (butlast xs) (butlast ys)", "apply (metis butlast_append prefixE prefix_order.eq_refl prefix_prefix prefixeq_butlast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix xs ys; suffix xs ys\\<rbrakk>\n    \\<Longrightarrow> suffix (butlast xs) (butlast ys)", "apply (metis Sublist.suffix_def append.right_neutral butlast.simps(1) butlast_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary strict_border_butlast: \"xs \\<noteq> [] \\<Longrightarrow> strict_border xs ys \\<Longrightarrow> strict_border (butlast xs) (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; strict_border xs ys\\<rbrakk>\n    \\<Longrightarrow> strict_border (butlast xs) (butlast ys)", "unfolding strict_border_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> [];\n     border xs ys \\<and> length xs < length ys\\<rbrakk>\n    \\<Longrightarrow> border (butlast xs) (butlast ys) \\<and>\n                      length (butlast xs) < length (butlast ys)", "by (simp add: border_butlast less_diff_conv)"], ["", "lemma border_take_lengths: \"i \\<le> length s \\<Longrightarrow> border (take i s) (take j s) \\<Longrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length s; border (take i s) (take j s)\\<rbrakk>\n    \\<Longrightarrow> i \\<le> j", "using border_length_le"], ["proof (prove)\nusing this:\n  border ?xs ?ys \\<Longrightarrow> length ?xs \\<le> length ?ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> length s; border (take i s) (take j s)\\<rbrakk>\n    \\<Longrightarrow> i \\<le> j", "by fastforce"], ["", "lemma border_step: \"border xs ys \\<longleftrightarrow> border (xs@[ys!length xs]) (ys@[ys!length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. border xs ys = border (xs @ [ys ! length xs]) (ys @ [ys ! length xs])", "apply (auto simp: border_def suffix_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       \\<lbrakk>prefix xs (zs @ xs); ys = zs @ xs;\n        \\<not> prefix (xs @ [(zs @ xs) ! length xs]) (zs @ xs)\\<rbrakk>\n       \\<Longrightarrow> zs = []\n 2. \\<And>zs.\n       \\<lbrakk>ys = zs @ xs;\n        prefix (xs @ [(zs @ xs) ! length xs]) (zs @ xs)\\<rbrakk>\n       \\<Longrightarrow> prefix xs (zs @ xs)", "using append_one_prefix prefixE"], ["proof (prove)\nusing this:\n  \\<lbrakk>prefix ?xs ?ys; length ?xs < length ?ys\\<rbrakk>\n  \\<Longrightarrow> prefix (?xs @ [?ys ! length ?xs]) ?ys\n  \\<lbrakk>prefix ?xs ?ys;\n   \\<And>zs. ?ys = ?xs @ zs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       \\<lbrakk>prefix xs (zs @ xs); ys = zs @ xs;\n        \\<not> prefix (xs @ [(zs @ xs) ! length xs]) (zs @ xs)\\<rbrakk>\n       \\<Longrightarrow> zs = []\n 2. \\<And>zs.\n       \\<lbrakk>ys = zs @ xs;\n        prefix (xs @ [(zs @ xs) ! length xs]) (zs @ xs)\\<rbrakk>\n       \\<Longrightarrow> prefix xs (zs @ xs)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs.\n       \\<lbrakk>ys = zs @ xs;\n        prefix (xs @ [(zs @ xs) ! length xs]) (zs @ xs)\\<rbrakk>\n       \\<Longrightarrow> prefix xs (zs @ xs)", "using append_prefixD"], ["proof (prove)\nusing this:\n  prefix (?xs @ ?ys) ?zs \\<Longrightarrow> prefix ?xs ?zs\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       \\<lbrakk>ys = zs @ xs;\n        prefix (xs @ [(zs @ xs) ! length xs]) (zs @ xs)\\<rbrakk>\n       \\<Longrightarrow> prefix xs (zs @ xs)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary strict_border_step: \"strict_border xs ys \\<longleftrightarrow> strict_border (xs@[ys!length xs]) (ys@[ys!length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_border xs ys =\n    strict_border (xs @ [ys ! length xs]) (ys @ [ys ! length xs])", "unfolding strict_border_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (border xs ys \\<and> length xs < length ys) =\n    (border (xs @ [ys ! length xs]) (ys @ [ys ! length xs]) \\<and>\n     length (xs @ [ys ! length xs]) < length (ys @ [ys ! length xs]))", "using border_step"], ["proof (prove)\nusing this:\n  border ?xs ?ys =\n  border (?xs @ [?ys ! length ?xs]) (?ys @ [?ys ! length ?xs])\n\ngoal (1 subgoal):\n 1. (border xs ys \\<and> length xs < length ys) =\n    (border (xs @ [ys ! length xs]) (ys @ [ys ! length xs]) \\<and>\n     length (xs @ [ys ! length xs]) < length (ys @ [ys ! length xs]))", "by auto"], ["", "lemma ib_butlast: \"length w \\<ge> 2 \\<Longrightarrow> length (intrinsic_border w) \\<le> length (intrinsic_border (butlast w)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "assume \"length w \\<ge> 2\""], ["proof (state)\nthis:\n  2 \\<le> length w\n\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "then"], ["proof (chain)\npicking this:\n  2 \\<le> length w", "have \"w \\<noteq> []\""], ["proof (prove)\nusing this:\n  2 \\<le> length w\n\ngoal (1 subgoal):\n 1. w \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "then"], ["proof (chain)\npicking this:\n  w \\<noteq> []", "have \"strict_border (intrinsic_border w) w\""], ["proof (prove)\nusing this:\n  w \\<noteq> []\n\ngoal (1 subgoal):\n 1. strict_border (intrinsic_border w) w", "by (fact intrinsic_borderI')"], ["proof (state)\nthis:\n  strict_border (intrinsic_border w) w\n\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "with \\<open>2 \\<le> length w\\<close>"], ["proof (chain)\npicking this:\n  2 \\<le> length w\n  strict_border (intrinsic_border w) w", "have \"strict_border (butlast (intrinsic_border w)) (butlast w)\""], ["proof (prove)\nusing this:\n  2 \\<le> length w\n  strict_border (intrinsic_border w) w\n\ngoal (1 subgoal):\n 1. strict_border (butlast (intrinsic_border w)) (butlast w)", "by (metis One_nat_def border_bot.bot.not_eq_extremum butlast.simps(1) len_greater_imp_nonempty length_butlast lessI less_le_trans numerals(2) strict_border_butlast zero_less_diff)"], ["proof (state)\nthis:\n  strict_border (butlast (intrinsic_border w)) (butlast w)\n\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "then"], ["proof (chain)\npicking this:\n  strict_border (butlast (intrinsic_border w)) (butlast w)", "have \"length (butlast (intrinsic_border w)) \\<le> length (intrinsic_border (butlast w))\""], ["proof (prove)\nusing this:\n  strict_border (butlast (intrinsic_border w)) (butlast w)\n\ngoal (1 subgoal):\n 1. length (butlast (intrinsic_border w))\n    \\<le> length (intrinsic_border (butlast w))", "using intrinsic_border_max"], ["proof (prove)\nusing this:\n  strict_border (butlast (intrinsic_border w)) (butlast w)\n  strict_border ?x ?ys \\<Longrightarrow>\n  length ?x \\<le> length (intrinsic_border ?ys)\n\ngoal (1 subgoal):\n 1. length (butlast (intrinsic_border w))\n    \\<le> length (intrinsic_border (butlast w))", "by blast"], ["proof (state)\nthis:\n  length (butlast (intrinsic_border w))\n  \\<le> length (intrinsic_border (butlast w))\n\ngoal (1 subgoal):\n 1. 2 \\<le> length w \\<Longrightarrow>\n    length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "then"], ["proof (chain)\npicking this:\n  length (butlast (intrinsic_border w))\n  \\<le> length (intrinsic_border (butlast w))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (butlast (intrinsic_border w))\n  \\<le> length (intrinsic_border (butlast w))\n\ngoal (1 subgoal):\n 1. length (intrinsic_border w)\n    \\<le> length (intrinsic_border (butlast w)) + 1", "by simp"], ["proof (state)\nthis:\n  length (intrinsic_border w)\n  \\<le> length (intrinsic_border (butlast w)) + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \\<ff>_Suc(*rm*): \"Suc i \\<le> length w \\<Longrightarrow> \\<ff> w (Suc i) \\<le> \\<ff> w i + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i \\<le> length w \\<Longrightarrow>\n    \\<ff> w (Suc i) \\<le> \\<ff> w i + 1", "apply (cases i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc i \\<le> length w; i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<ff> w (Suc i) \\<le> \\<ff> w i + 1\n 2. \\<And>nat.\n       \\<lbrakk>Suc i \\<le> length w; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<ff> w (Suc i) \\<le> \\<ff> w i + 1", "apply (simp_all add: take_Suc0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc (Suc nat) \\<le> length w; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length (intrinsic_border (take (Suc (Suc nat)) w))\n                         \\<le> Suc (length\n                                     (intrinsic_border (take (Suc nat) w)))", "by (metis One_nat_def Suc_eq_plus1 Suc_to_right butlast_take diff_is_0_eq ib_butlast length_take min.absorb2 nat.simps(3) not_less_eq_eq numerals(2))"], ["", "lemma \\<ff>_step_bound(*rm*):\n  assumes \"j \\<le> length w\"\n  shows \"\\<ff> w j \\<le> \\<ff> w (j-1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ff> w j \\<le> \\<ff> w (j - 1) + 1", "using assms[THEN j_le_\\<ff>_le] \\<ff>_Suc assms"], ["proof (prove)\nusing this:\n  \\<ff> w j \\<le> j\n  Suc ?i \\<le> length ?w \\<Longrightarrow>\n  \\<ff> ?w (Suc ?i) \\<le> \\<ff> ?w ?i + 1\n  j \\<le> length w\n\ngoal (1 subgoal):\n 1. \\<ff> w j \\<le> \\<ff> w (j - 1) + 1", "by (metis One_nat_def Suc_pred le_SucI not_gr_zero trans_le_add2)"], ["", "lemma border_take_\\<ff>: \"border (take (\\<ff> s i - 1) s ) (take i s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. border (take (\\<ff> s i - 1) s) (take i s)", "apply (cases i, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       border (take (length (intrinsic_border (take (Suc nat) s))) s)\n        (take (Suc nat) s)", "by (metis intrinsic_borderI' border_order.eq_iff border_order.less_imp_le border_positions nat.simps(3) nat_le_linear positions_border take_all take_eq_Nil take_length_ib zero_less_Suc)"], ["", "corollary \\<ff>_strict_borderI: \"y = \\<ff> s (i-1) \\<Longrightarrow> strict_border (take (i-1) s) (take (j-1) s) \\<Longrightarrow> strict_border (take (y-1) s) (take (j-1) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = \\<ff> s (i - 1);\n     strict_border (take (i - 1) s) (take (j - 1) s)\\<rbrakk>\n    \\<Longrightarrow> strict_border (take (y - 1) s) (take (j - 1) s)", "using border_order.less_le_not_le border_order.order.trans border_take_\\<ff>"], ["proof (prove)\nusing this:\n  strict_border ?x ?y = (border ?x ?y \\<and> \\<not> border ?y ?x)\n  \\<lbrakk>border ?a ?b; border ?b ?c\\<rbrakk>\n  \\<Longrightarrow> border ?a ?c\n  border (take (\\<ff> ?s ?i - 1) ?s) (take ?i ?s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = \\<ff> s (i - 1);\n     strict_border (take (i - 1) s) (take (j - 1) s)\\<rbrakk>\n    \\<Longrightarrow> strict_border (take (y - 1) s) (take (j - 1) s)", "by blast"], ["", "corollary strict_border_take_\\<ff>: \"0 < i \\<Longrightarrow> i \\<le> length s \\<Longrightarrow> strict_border (take (\\<ff> s i - 1) s ) (take i s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i \\<le> length s\\<rbrakk>\n    \\<Longrightarrow> strict_border (take (\\<ff> s i - 1) s) (take i s)", "by (meson border_order.less_le_not_le border_take_\\<ff> border_take_lengths j_le_\\<ff>_le' leD)"], ["", "lemma \\<ff>_is_max: \"j \\<le> length s \\<Longrightarrow> strict_border b (take j s) \\<Longrightarrow> \\<ff> s j \\<ge> length b + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> length s; strict_border b (take j s)\\<rbrakk>\n    \\<Longrightarrow> length b + 1 \\<le> \\<ff> s j", "by (metis \\<ff>.elims add_le_cancel_right add_less_same_cancel2 border_length_r_less intrinsic_border_max length_take min_absorb2 not_add_less2)"], ["", "theorem skipping_ok:\n  assumes j_bounds[simp]: \"1 < j\" \"j \\<le> length s\"\n    and mismatch: \"s!(i-1) \\<noteq> s!(j-1)\"\n    and greater_checked: \"\\<ff> s j \\<le> i + 1\"\n    and \"strict_border (take (i-1) s) (take (j-1) s)\"\n  shows \"\\<ff> s j \\<le> \\<ff> s (i-1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ff> s j \\<le> \\<ff> s (i - 1) + 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1 \\<Longrightarrow> False", "assume \"\\<not>\\<ff> s j \\<le> \\<ff> s (i-1) + 1\""], ["proof (state)\nthis:\n  \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1\n\ngoal (1 subgoal):\n 1. \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1", "have i_bounds: \"0 < i\" \"i \\<le> length s\""], ["proof (prove)\nusing this:\n  \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1\n\ngoal (1 subgoal):\n 1. 0 < i &&& i \\<le> length s", "using greater_checked assms(5) take_Nil"], ["proof (prove)\nusing this:\n  \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1\n  \\<ff> s j \\<le> i + 1\n  strict_border (take (i - 1) s) (take (j - 1) s)\n  take ?n [] = []\n\ngoal (1 subgoal):\n 1. 0 < i &&& i \\<le> length s", "by fastforce+"], ["proof (state)\nthis:\n  0 < i\n  i \\<le> length s\n\ngoal (1 subgoal):\n 1. \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < i\n  i \\<le> length s", "have i_less_j: \"i < j\""], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> length s\n\ngoal (1 subgoal):\n 1. i < j", "using assms(5) border_length_r_less nz_le_conv_less"], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> length s\n  strict_border (take (i - 1) s) (take (j - 1) s)\n  \\<forall>xs. strict_border xs ?ys \\<longrightarrow> length xs < length ?ys\n  \\<lbrakk>0 < ?k; ?k \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?k - Suc 0 < ?m\n\ngoal (1 subgoal):\n 1. i < j", "by auto"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1 \\<Longrightarrow> False", "from \\<open>\\<not>\\<ff> s j \\<le> \\<ff> s (i-1) + 1\\<close> greater_checked"], ["proof (chain)\npicking this:\n  \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1\n  \\<ff> s j \\<le> i + 1", "consider\n    (tested) \"\\<ff> s j = i + 1\" \\<comment> \\<open>This contradicts @{thm mismatch}\\<close> |\n    (skipped) \"\\<ff> s (i-1) + 1 < \\<ff> s j\" \"\\<ff> s j \\<le> i\"\n      \\<comment> \\<open>This contradicts @{thm \\<ff>_is_max[of \"i-1\" s]}\\<close>"], ["proof (prove)\nusing this:\n  \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1\n  \\<ff> s j \\<le> i + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s j = i + 1 \\<Longrightarrow> thesis;\n     \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<ff> s j = i + 1 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> \\<ff> s j \\<le> \\<ff> s (i - 1) + 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<ff> s j = i + 1 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<ff> s j = i + 1 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<ff> s j = i + 1 \\<Longrightarrow> False\n 2. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "case tested"], ["proof (state)\nthis:\n  \\<ff> s j = i + 1\n\ngoal (2 subgoals):\n 1. \\<ff> s j = i + 1 \\<Longrightarrow> False\n 2. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<ff> s j = i + 1", "have \"\\<ff> s j - 1 = i\""], ["proof (prove)\nusing this:\n  \\<ff> s j = i + 1\n\ngoal (1 subgoal):\n 1. \\<ff> s j - 1 = i", "by simp"], ["proof (state)\nthis:\n  \\<ff> s j - 1 = i\n\ngoal (2 subgoals):\n 1. \\<ff> s j = i + 1 \\<Longrightarrow> False\n 2. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<ff> s j - 1 = i\n\ngoal (2 subgoals):\n 1. \\<ff> s j = i + 1 \\<Longrightarrow> False\n 2. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "note border_positions[OF border_take_\\<ff>[of s j, unfolded this]]"], ["proof (state)\nthis:\n  \\<forall>ia<length (take i s).\n     take j s ! ia = take j s ! (length (take j s) - length (take i s) + ia)\n\ngoal (2 subgoals):\n 1. \\<ff> s j = i + 1 \\<Longrightarrow> False\n 2. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<ff> s j - 1 = i\n  \\<forall>ia<length (take i s).\n     take j s ! ia = take j s ! (length (take j s) - length (take i s) + ia)", "have \"take j s ! (i-1) = s!(j-1)\""], ["proof (prove)\nusing this:\n  \\<ff> s j - 1 = i\n  \\<forall>ia<length (take i s).\n     take j s ! ia = take j s ! (length (take j s) - length (take i s) + ia)\n\ngoal (1 subgoal):\n 1. take j s ! (i - 1) = s ! (j - 1)", "using i_bounds i_less_j"], ["proof (prove)\nusing this:\n  \\<ff> s j - 1 = i\n  \\<forall>ia<length (take i s).\n     take j s ! ia = take j s ! (length (take j s) - length (take i s) + ia)\n  0 < i\n  i \\<le> length s\n  i < j\n\ngoal (1 subgoal):\n 1. take j s ! (i - 1) = s ! (j - 1)", "by simp"], ["proof (state)\nthis:\n  take j s ! (i - 1) = s ! (j - 1)\n\ngoal (2 subgoals):\n 1. \\<ff> s j = i + 1 \\<Longrightarrow> False\n 2. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "with \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j\n  take j s ! (i - 1) = s ! (j - 1)", "have \"s!(i-1) = s!(j-1)\""], ["proof (prove)\nusing this:\n  i < j\n  take j s ! (i - 1) = s ! (j - 1)\n\ngoal (1 subgoal):\n 1. s ! (i - 1) = s ! (j - 1)", "by (simp add: less_imp_diff_less)"], ["proof (state)\nthis:\n  s ! (i - 1) = s ! (j - 1)\n\ngoal (2 subgoals):\n 1. \\<ff> s j = i + 1 \\<Longrightarrow> False\n 2. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "with mismatch"], ["proof (chain)\npicking this:\n  s ! (i - 1) \\<noteq> s ! (j - 1)\n  s ! (i - 1) = s ! (j - 1)", "show False"], ["proof (prove)\nusing this:\n  s ! (i - 1) \\<noteq> s ! (j - 1)\n  s ! (i - 1) = s ! (j - 1)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "case skipped"], ["proof (state)\nthis:\n  \\<ff> s (i - 1) + 1 < \\<ff> s j\n  \\<ff> s j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "let ?border = \"take (i-1) s\"\n      \\<comment> \\<open>This border of @{term \\<open>take (j-1) s\\<close>} could not be extended to a border of @{term \\<open>take j s\\<close>} due to the mismatch.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "let ?impossible = \"take (\\<ff> s j - 2) s\"\n      \\<comment> \\<open>A strict border longer than @{term \\<open>intrinsic_border ?border\\<close>}, a contradiction.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "have \"length (take j s) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take j s) = j", "by simp"], ["proof (state)\nthis:\n  length (take j s) = j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<ff> s j - 2 < i - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ff> s j - 2 < i - 1", "using skipped"], ["proof (prove)\nusing this:\n  \\<ff> s (i - 1) + 1 < \\<ff> s j\n  \\<ff> s j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<ff> s j - 2 < i - 1", "by linarith"], ["proof (state)\nthis:\n  \\<ff> s j - 2 < i - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<ff> s j - 2 < i - 1", "have less_s: \"\\<ff> s j - 2 < length s\" \"i - 1 < length s\""], ["proof (prove)\nusing this:\n  \\<ff> s j - 2 < i - 1\n\ngoal (1 subgoal):\n 1. \\<ff> s j - 2 < length s &&& i - 1 < length s", "using \\<open>i < j\\<close> j_bounds(2)"], ["proof (prove)\nusing this:\n  \\<ff> s j - 2 < i - 1\n  i < j\n  j \\<le> length s\n\ngoal (1 subgoal):\n 1. \\<ff> s j - 2 < length s &&& i - 1 < length s", "by linarith+"], ["proof (state)\nthis:\n  \\<ff> s j - 2 < length s\n  i - 1 < length s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<ff> s j - 2 < length s\n  i - 1 < length s", "have strict: \"length ?impossible < length ?border\""], ["proof (prove)\nusing this:\n  \\<ff> s j - 2 < length s\n  i - 1 < length s\n\ngoal (1 subgoal):\n 1. length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)", "using \\<open>\\<ff> s j - 2 < i - 1\\<close>"], ["proof (prove)\nusing this:\n  \\<ff> s j - 2 < length s\n  i - 1 < length s\n  \\<ff> s j - 2 < i - 1\n\ngoal (1 subgoal):\n 1. length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)", "by auto"], ["proof (state)\nthis:\n  length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "have \"prefix ?impossible (take j s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take (\\<ff> s j - 2) s) (take j s)", "using prefix_length_prefix take_is_prefix"], ["proof (prove)\nusing this:\n  \\<lbrakk>prefix ?ps ?xs; prefix ?qs ?xs;\n   length ?ps \\<le> length ?qs\\<rbrakk>\n  \\<Longrightarrow> prefix ?ps ?qs\n  prefix (take ?n ?xs) ?xs\n\ngoal (1 subgoal):\n 1. prefix (take (\\<ff> s j - 2) s) (take j s)", "by (metis (no_types, lifting) \\<open>length (take j s) = j\\<close> j_bounds(2) diff_le_self j_le_\\<ff>_le length_take less_s(1) min_simps(2) order_trans)"], ["proof (state)\nthis:\n  prefix (take (\\<ff> s j - 2) s) (take j s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  prefix (take (\\<ff> s j - 2) s) (take j s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "have \"prefix ?border (take j s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take (i - 1) s) (take j s)", "by (metis (no_types, lifting) \\<open>length (take j s) = j\\<close> diff_le_self i_less_j le_trans length_take less_or_eq_imp_le less_s(2) min_simps(2) prefix_length_prefix take_is_prefix)"], ["proof (state)\nthis:\n  prefix (take (i - 1) s) (take j s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  prefix (take (\\<ff> s j - 2) s) (take j s)\n  prefix (take (i - 1) s) (take j s)", "have \"prefix ?impossible ?border\""], ["proof (prove)\nusing this:\n  prefix (take (\\<ff> s j - 2) s) (take j s)\n  prefix (take (i - 1) s) (take j s)\n\ngoal (1 subgoal):\n 1. prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)", "using strict less_imp_le_nat prefix_length_prefix"], ["proof (prove)\nusing this:\n  prefix (take (\\<ff> s j - 2) s) (take j s)\n  prefix (take (i - 1) s) (take j s)\n  length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n  \\<lbrakk>prefix ?ps ?xs; prefix ?qs ?xs;\n   length ?ps \\<le> length ?qs\\<rbrakk>\n  \\<Longrightarrow> prefix ?ps ?qs\n\ngoal (1 subgoal):\n 1. prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)", "by blast"], ["proof (state)\nthis:\n  prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "have \"suffix (take (\\<ff> s j - 1) s) (take j s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suffix (take (\\<ff> s j - 1) s) (take j s)", "using border_take_\\<ff>"], ["proof (prove)\nusing this:\n  border (take (\\<ff> ?s ?i - 1) ?s) (take ?i ?s)\n\ngoal (1 subgoal):\n 1. suffix (take (\\<ff> s j - 1) s) (take j s)", "by (auto simp: border_def)"], ["proof (state)\nthis:\n  suffix (take (\\<ff> s j - 1) s) (take j s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "note suffix_butlast[OF this]"], ["proof (state)\nthis:\n  suffix (butlast (take (\\<ff> s j - 1) s)) (butlast (take j s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  suffix (butlast (take (\\<ff> s j - 1) s)) (butlast (take j s))", "have \"suffix ?impossible (take (j-1) s)\""], ["proof (prove)\nusing this:\n  suffix (butlast (take (\\<ff> s j - 1) s)) (butlast (take j s))\n\ngoal (1 subgoal):\n 1. suffix (take (\\<ff> s j - 2) s) (take (j - 1) s)", "by (metis One_nat_def j_bounds(2) butlast_take diff_diff_left \\<ff>_le len_greater_imp_nonempty less_or_eq_imp_le less_s(2) one_add_one)"], ["proof (state)\nthis:\n  suffix (take (\\<ff> s j - 2) s) (take (j - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  suffix (take (\\<ff> s j - 2) s) (take (j - 1) s)", "have \"suffix ?impossible (take (j-1) s)\" \"suffix ?border (take (j-1) s)\""], ["proof (prove)\nusing this:\n  suffix (take (\\<ff> s j - 2) s) (take (j - 1) s)\n\ngoal (1 subgoal):\n 1. suffix (take (\\<ff> s j - 2) s) (take (j - 1) s) &&&\n    suffix (take (i - 1) s) (take (j - 1) s)", "using assms(5)"], ["proof (prove)\nusing this:\n  suffix (take (\\<ff> s j - 2) s) (take (j - 1) s)\n  strict_border (take (i - 1) s) (take (j - 1) s)\n\ngoal (1 subgoal):\n 1. suffix (take (\\<ff> s j - 2) s) (take (j - 1) s) &&&\n    suffix (take (i - 1) s) (take (j - 1) s)", "by auto"], ["proof (state)\nthis:\n  suffix (take (\\<ff> s j - 2) s) (take (j - 1) s)\n  suffix (take (i - 1) s) (take (j - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "from suffix_length_suffix[OF this strict[THEN less_imp_le]]"], ["proof (chain)\npicking this:\n  suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)", "have \"suffix ?impossible ?border\""], ["proof (prove)\nusing this:\n  suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)", "."], ["proof (state)\nthis:\n  suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)\n  prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n  suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)", "have \"strict_border ?impossible ?border\""], ["proof (prove)\nusing this:\n  length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)\n  prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n  suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. strict_border (take (\\<ff> s j - 2) s) (take (i - 1) s)", "unfolding strict_border_def[unfolded border_def]"], ["proof (prove)\nusing this:\n  length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)\n  prefix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n  suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. (prefix (take (\\<ff> s j - 2) s) (take (i - 1) s) \\<and>\n     suffix (take (\\<ff> s j - 2) s) (take (i - 1) s)) \\<and>\n    length (take (\\<ff> s j - 2) s) < length (take (i - 1) s)", "by blast"], ["proof (state)\nthis:\n  strict_border (take (\\<ff> s j - 2) s) (take (i - 1) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "note \\<ff>_is_max[of \"i-1\" s, OF _ this]"], ["proof (state)\nthis:\n  i - 1 \\<le> length s \\<Longrightarrow>\n  length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i - 1 \\<le> length s \\<Longrightarrow>\n  length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)", "have \"length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i-1)\""], ["proof (prove)\nusing this:\n  i - 1 \\<le> length s \\<Longrightarrow>\n  length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)\n\ngoal (1 subgoal):\n 1. length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)", "using less_imp_le_nat less_s(2)"], ["proof (prove)\nusing this:\n  i - 1 \\<le> length s \\<Longrightarrow>\n  length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)\n  ?m < ?n \\<Longrightarrow> ?m \\<le> ?n\n  i - 1 < length s\n\ngoal (1 subgoal):\n 1. length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)", "by blast"], ["proof (state)\nthis:\n  length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)", "have \"\\<ff> s j - 1 \\<le> \\<ff> s (i-1)\""], ["proof (prove)\nusing this:\n  length (take (\\<ff> s j - 2) s) + 1 \\<le> \\<ff> s (i - 1)\n\ngoal (1 subgoal):\n 1. \\<ff> s j - 1 \\<le> \\<ff> s (i - 1)", "by (simp add: less_s(1))"], ["proof (state)\nthis:\n  \\<ff> s j - 1 \\<le> \\<ff> s (i - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<ff> s j - 1 \\<le> \\<ff> s (i - 1)", "have \"\\<ff> s j \\<le> \\<ff> s (i-1) + 1\""], ["proof (prove)\nusing this:\n  \\<ff> s j - 1 \\<le> \\<ff> s (i - 1)\n\ngoal (1 subgoal):\n 1. \\<ff> s j \\<le> \\<ff> s (i - 1) + 1", "using le_diff_conv"], ["proof (prove)\nusing this:\n  \\<ff> s j - 1 \\<le> \\<ff> s (i - 1)\n  (?j - ?k \\<le> ?i) = (?j \\<le> ?i + ?k)\n\ngoal (1 subgoal):\n 1. \\<ff> s j \\<le> \\<ff> s (i - 1) + 1", "by blast"], ["proof (state)\nthis:\n  \\<ff> s j \\<le> \\<ff> s (i - 1) + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<ff> s (i - 1) + 1 < \\<ff> s j; \\<ff> s j \\<le> i\\<rbrakk>\n    \\<Longrightarrow> False", "with skipped(1)"], ["proof (chain)\npicking this:\n  \\<ff> s (i - 1) + 1 < \\<ff> s j\n  \\<ff> s j \\<le> \\<ff> s (i - 1) + 1", "show False"], ["proof (prove)\nusing this:\n  \\<ff> s (i - 1) + 1 < \\<ff> s j\n  \\<ff> s j \\<le> \\<ff> s (i - 1) + 1\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extend_border:\n  assumes \"j \\<le> length s\"\n  assumes \"s!(i-1) = s!(j-1)\"\n  assumes \"strict_border (take (i-1) s) (take (j-1) s)\"\n  assumes \"\\<ff> s j \\<le> i + 1\"\n  shows \"\\<ff> s j = i + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "from assms(3)"], ["proof (chain)\npicking this:\n  strict_border (take (i - 1) s) (take (j - 1) s)", "have pos_in_range: \"i - 1 < length s \" \"length (take (i-1) s) = i - 1\""], ["proof (prove)\nusing this:\n  strict_border (take (i - 1) s) (take (j - 1) s)\n\ngoal (1 subgoal):\n 1. i - 1 < length s &&& length (take (i - 1) s) = i - 1", "using border_length_r_less min_less_iff_conj"], ["proof (prove)\nusing this:\n  strict_border (take (i - 1) s) (take (j - 1) s)\n  \\<forall>xs. strict_border xs ?ys \\<longrightarrow> length xs < length ?ys\n  (?z < min ?x ?y) = (?z < ?x \\<and> ?z < ?y)\n\ngoal (1 subgoal):\n 1. i - 1 < length s &&& length (take (i - 1) s) = i - 1", "by auto"], ["proof (state)\nthis:\n  i - 1 < length s\n  length (take (i - 1) s) = i - 1\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "with strict_border_step[THEN iffD1, OF assms(3)]"], ["proof (chain)\npicking this:\n  strict_border\n   (take (i - 1) s @ [take (j - 1) s ! length (take (i - 1) s)])\n   (take (j - 1) s @ [take (j - 1) s ! length (take (i - 1) s)])\n  i - 1 < length s\n  length (take (i - 1) s) = i - 1", "have \"strict_border (take (i-1) s @ [s!(i-1)]) (take (j-1) s @ [s!(i-1)])\""], ["proof (prove)\nusing this:\n  strict_border\n   (take (i - 1) s @ [take (j - 1) s ! length (take (i - 1) s)])\n   (take (j - 1) s @ [take (j - 1) s ! length (take (i - 1) s)])\n  i - 1 < length s\n  length (take (i - 1) s) = i - 1\n\ngoal (1 subgoal):\n 1. strict_border (take (i - 1) s @ [s ! (i - 1)])\n     (take (j - 1) s @ [s ! (i - 1)])", "by (metis assms(3) border_length_r_less length_take min_less_iff_conj nth_take)"], ["proof (state)\nthis:\n  strict_border (take (i - 1) s @ [s ! (i - 1)])\n   (take (j - 1) s @ [s ! (i - 1)])\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "with pos_in_range"], ["proof (chain)\npicking this:\n  i - 1 < length s\n  length (take (i - 1) s) = i - 1\n  strict_border (take (i - 1) s @ [s ! (i - 1)])\n   (take (j - 1) s @ [s ! (i - 1)])", "have \"strict_border (take i s) (take (j-1) s @ [s!(i-1)])\""], ["proof (prove)\nusing this:\n  i - 1 < length s\n  length (take (i - 1) s) = i - 1\n  strict_border (take (i - 1) s @ [s ! (i - 1)])\n   (take (j - 1) s @ [s ! (i - 1)])\n\ngoal (1 subgoal):\n 1. strict_border (take i s) (take (j - 1) s @ [s ! (i - 1)])", "by (metis Suc_eq_plus1 Suc_pred add.left_neutral border_bot.bot.not_eq_extremum border_order.less_asym neq0_conv take_0 take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  strict_border (take i s) (take (j - 1) s @ [s ! (i - 1)])\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "then"], ["proof (chain)\npicking this:\n  strict_border (take i s) (take (j - 1) s @ [s ! (i - 1)])", "have \"strict_border (take i s) (take (j-1) s @ [s!(j-1)])\""], ["proof (prove)\nusing this:\n  strict_border (take i s) (take (j - 1) s @ [s ! (i - 1)])\n\ngoal (1 subgoal):\n 1. strict_border (take i s) (take (j - 1) s @ [s ! (j - 1)])", "by (simp only: \\<open>s!(i-1) = s!(j-1)\\<close>)"], ["proof (state)\nthis:\n  strict_border (take i s) (take (j - 1) s @ [s ! (j - 1)])\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "then"], ["proof (chain)\npicking this:\n  strict_border (take i s) (take (j - 1) s @ [s ! (j - 1)])", "have \"strict_border (take i s) (take j s)\""], ["proof (prove)\nusing this:\n  strict_border (take i s) (take (j - 1) s @ [s ! (j - 1)])\n\ngoal (1 subgoal):\n 1. strict_border (take i s) (take j s)", "by (metis One_nat_def Suc_pred assms(1,3) diff_le_self less_le_trans neq0_conv nz_le_conv_less strict_border_imp_nonempty take_Suc_conv_app_nth take_eq_Nil)"], ["proof (state)\nthis:\n  strict_border (take i s) (take j s)\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "with \\<ff>_is_max[OF assms(1) this]"], ["proof (chain)\npicking this:\n  length (take i s) + 1 \\<le> \\<ff> s j\n  strict_border (take i s) (take j s)", "have \"\\<ff> s j \\<ge> i + 1\""], ["proof (prove)\nusing this:\n  length (take i s) + 1 \\<le> \\<ff> s j\n  strict_border (take i s) (take j s)\n\ngoal (1 subgoal):\n 1. i + 1 \\<le> \\<ff> s j", "using Suc_leI"], ["proof (prove)\nusing this:\n  length (take i s) + 1 \\<le> \\<ff> s j\n  strict_border (take i s) (take j s)\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n\ngoal (1 subgoal):\n 1. i + 1 \\<le> \\<ff> s j", "by fastforce"], ["proof (state)\nthis:\n  i + 1 \\<le> \\<ff> s j\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "with \\<open>\\<ff> s j \\<le> i + 1\\<close>"], ["proof (chain)\npicking this:\n  \\<ff> s j \\<le> i + 1\n  i + 1 \\<le> \\<ff> s j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<ff> s j \\<le> i + 1\n  i + 1 \\<le> \\<ff> s j\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "using le_antisym"], ["proof (prove)\nusing this:\n  \\<ff> s j \\<le> i + 1\n  i + 1 \\<le> \\<ff> s j\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. \\<ff> s j = i + 1", "by presburger"], ["proof (state)\nthis:\n  \\<ff> s j = i + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compute_\\<ff>s_correct: \"compute_\\<ff>s s \\<le> compute_\\<ff>s_SPEC s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_\\<ff>s s \\<le> compute_\\<ff>s_SPEC s", "unfolding compute_\\<ff>s_SPEC_def compute_\\<ff>s_def I_out_cb_def I_in_cb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let \\<ff>s = replicate (length s + 1) 0; i = 0; j = 1\n     in WHILE\\<^sub>T\\<^bsup>\\<lambda>(\\<ff>s, i, j).\n                                length s + 1 = length \\<ff>s \\<and>\n                                (\\<forall>jj<j.\n                                    \\<ff>s ! jj = \\<ff> s jj) \\<and>\n                                \\<ff>s ! (j - 1) = i \\<and> 0 < j\\<^esup>\n         (\\<lambda>(\\<ff>s, uu_, j). j < length \\<ff>s)\n         (\\<lambda>(\\<ff>s, i, j).\n             WHILE\\<^sub>T\\<^bsup>\\<lambda>i.\n                                     if j = 1 then i = 0\n                                     else strict_border (take (i - 1) s)\n     (take (j - 1) s) \\<and>\n    \\<ff> s j \\<le> i + 1\\<^esup>\n              (\\<lambda>i. 0 < i \\<and> s ! (i - 1) \\<noteq> s ! (j - 1))\n              (\\<lambda>i.\n                  ASSERT (i - 1 < length \\<ff>s) \\<bind>\n                  (\\<lambda>_. Let (\\<ff>s ! (i - 1)) RETURN))\n              i \\<bind>\n             (\\<lambda>i.\n                 let i = i + 1\n                 in ASSERT (j < length \\<ff>s) \\<bind>\n                    (\\<lambda>_.\n                        let \\<ff>s = \\<ff>s[j := i]; j = j + 1\n                        in RETURN (\\<ff>s, i, j))))\n         (\\<ff>s, i, j) \\<bind>\n        (\\<lambda>(\\<ff>s, uu_, uu_). RETURN \\<ff>s))\n    \\<le> SPEC\n           (\\<lambda>\\<ff>s.\n               length \\<ff>s = length s + 1 \\<and>\n               (\\<forall>j\\<le>length s. \\<ff>s ! j = \\<ff> s j))", "apply (simp, refine_vcg\n    WHILEIT_rule[where R=\"measure (\\<lambda>(\\<ff>s,i,j). length s + 1 - j)\"]\n    WHILEIT_rule[where R=\"measure id\"] \\<comment> \\<open>@{term \\<open>i::nat\\<close>} decreases with every iteration.\\<close>\n    )"], ["proof (prove)\ngoal (22 subgoals):\n 1. wf (measure (\\<lambda>(\\<ff>s, i, j). length s + 1 - j))\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>x2 = (x1a, x2a);\n        (0 # replicate (length s) 0, 0, Suc 0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Suc (length s) = length x1\n 3. \\<And>x1 x2 x1a x2a jj.\n       \\<lbrakk>x2 = (x1a, x2a);\n        (0 # replicate (length s) 0, 0, Suc 0) = (x1, x2); jj < x2a\\<rbrakk>\n       \\<Longrightarrow> x1 ! jj = \\<ff> s jj\n 4. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>x2 = (x1a, x2a);\n        (0 # replicate (length s) 0, 0, Suc 0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 ! (x2a - Suc 0) = x1a\n 5. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>x2 = (x1a, x2a);\n        (0 # replicate (length s) 0, 0, Suc 0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> 0 < x2a\n 6. \\<And>sa a b aa ba.\n       \\<lbrakk>case sa of\n                (\\<ff>s, ab) \\<Rightarrow>\n                  Suc (length s) = length \\<ff>s \\<and>\n                  (case ab of\n                   (i, j) \\<Rightarrow>\n                     (\\<forall>jj<j. \\<ff>s ! jj = \\<ff> s jj) \\<and>\n                     \\<ff>s ! (j - Suc 0) = i \\<and> 0 < j);\n        case sa of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        sa = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> wf (measure id)\n 7. \\<And>sa a b aa ba.\n       \\<lbrakk>case sa of\n                (\\<ff>s, ab) \\<Rightarrow>\n                  Suc (length s) = length \\<ff>s \\<and>\n                  (case ab of\n                   (i, j) \\<Rightarrow>\n                     (\\<forall>jj<j. \\<ff>s ! jj = \\<ff> s jj) \\<and>\n                     \\<ff>s ! (j - Suc 0) = i \\<and> 0 < j);\n        case sa of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        sa = (a, b); b = (aa, ba); ba = Suc 0\\<rbrakk>\n       \\<Longrightarrow> aa = 0\n 8. \\<And>sa a b aa ba.\n       \\<lbrakk>case sa of\n                (\\<ff>s, ab) \\<Rightarrow>\n                  Suc (length s) = length \\<ff>s \\<and>\n                  (case ab of\n                   (i, j) \\<Rightarrow>\n                     (\\<forall>jj<j. \\<ff>s ! jj = \\<ff> s jj) \\<and>\n                     \\<ff>s ! (j - Suc 0) = i \\<and> 0 < j);\n        case sa of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        sa = (a, b); b = (aa, ba); ba \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> strict_border (take (aa - Suc 0) s)\n                          (take (ba - Suc 0) s)\n 9. \\<And>sa a b aa ba.\n       \\<lbrakk>case sa of\n                (\\<ff>s, ab) \\<Rightarrow>\n                  Suc (length s) = length \\<ff>s \\<and>\n                  (case ab of\n                   (i, j) \\<Rightarrow>\n                     (\\<forall>jj<j. \\<ff>s ! jj = \\<ff> s jj) \\<and>\n                     \\<ff>s ! (j - Suc 0) = i \\<and> 0 < j);\n        case sa of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        sa = (a, b); b = (aa, ba); ba \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s ba \\<le> Suc aa\n 10. \\<And>sa a b aa ba saa.\n        \\<lbrakk>case sa of\n                 (\\<ff>s, ab) \\<Rightarrow>\n                   Suc (length s) = length \\<ff>s \\<and>\n                   (case ab of\n                    (i, j) \\<Rightarrow>\n                      (\\<forall>jj<j. \\<ff>s ! jj = \\<ff> s jj) \\<and>\n                      \\<ff>s ! (j - Suc 0) = i \\<and> 0 < j);\n         case sa of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n         sa = (a, b); b = (aa, ba);\n         (ba = Suc 0 \\<longrightarrow> saa = 0) \\<and>\n         (ba \\<noteq> Suc 0 \\<longrightarrow>\n          strict_border (take (saa - Suc 0) s) (take (ba - Suc 0) s) \\<and>\n          \\<ff> s ba \\<le> Suc saa);\n         0 < saa \\<and> s ! (saa - Suc 0) \\<noteq> s ! (ba - Suc 0)\\<rbrakk>\n        \\<Longrightarrow> saa - Suc 0 < length a\nA total of 22 subgoals...", "apply (vc_solve, fold One_nat_def)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>ab baa.\n       \\<lbrakk>baa < length ab; baa \\<noteq> 1; Suc (length s) = length ab;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> strict_border (take (\\<ff> s (baa - 1) - 1) s)\n                          (take (baa - 1) s)\n 2. \\<And>ab baa.\n       \\<lbrakk>baa < length ab; baa \\<noteq> 1; Suc (length s) = length ab;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s baa \\<le> Suc (\\<ff> s (baa - 1))\n 3. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; Suc (length s) = length ab; baa \\<noteq> 1;\n        0 < sa; s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> sa - 1 < length ab\n 4. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> strict_border (take (ab ! (sa - 1) - 1) s)\n                          (take (baa - 1) s)\n 5. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s baa \\<le> Suc (ab ! (sa - 1))\n 6. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab;\n        Suc (length s) = length ab; baa \\<noteq> 1; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> ab ! (sa - 1) < sa\n 7. \\<And>ab baa sa jj.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        jj < Suc baa; Suc (length s) = length ab;\n        baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> ab[baa := Suc sa] ! jj = \\<ff> s jj\n 8. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal for b j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length b; j \\<noteq> 1; Suc (length s) = length b;\n     \\<forall>jj<j. b ! jj = \\<ff> s jj; 0 < j\\<rbrakk>\n    \\<Longrightarrow> strict_border (take (\\<ff> s (j - 1) - 1) s)\n                       (take (j - 1) s)", "by (rule strict_border_take_\\<ff>, auto)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>ab baa.\n       \\<lbrakk>baa < length ab; baa \\<noteq> 1; Suc (length s) = length ab;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s baa \\<le> Suc (\\<ff> s (baa - 1))\n 2. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; Suc (length s) = length ab; baa \\<noteq> 1;\n        0 < sa; s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> sa - 1 < length ab\n 3. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> strict_border (take (ab ! (sa - 1) - 1) s)\n                          (take (baa - 1) s)\n 4. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s baa \\<le> Suc (ab ! (sa - 1))\n 5. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab;\n        Suc (length s) = length ab; baa \\<noteq> 1; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> ab ! (sa - 1) < sa\n 6. \\<And>ab baa sa jj.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        jj < Suc baa; Suc (length s) = length ab;\n        baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> ab[baa := Suc sa] ! jj = \\<ff> s jj\n 7. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>baa_ < length ab_; baa_ \\<noteq> 1;\n     Suc (length s) = length ab_; \\<forall>jj<baa_. ab_ ! jj = \\<ff> s jj;\n     0 < baa_\\<rbrakk>\n    \\<Longrightarrow> \\<ff> s baa_ \\<le> Suc (\\<ff> s (baa_ - 1))", "by (metis Suc_eq_plus1 \\<ff>_step_bound less_Suc_eq_le)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; Suc (length s) = length ab; baa \\<noteq> 1;\n        0 < sa; s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> sa - 1 < length ab\n 2. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> strict_border (take (ab ! (sa - 1) - 1) s)\n                          (take (baa - 1) s)\n 3. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s baa \\<le> Suc (ab ! (sa - 1))\n 4. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab;\n        Suc (length s) = length ab; baa \\<noteq> 1; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> ab ! (sa - 1) < sa\n 5. \\<And>ab baa sa jj.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        jj < Suc baa; Suc (length s) = length ab;\n        baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> ab[baa := Suc sa] ! jj = \\<ff> s jj\n 6. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>baa_ < length ab_; Suc (length s) = length ab_;\n     baa_ \\<noteq> 1; 0 < sa_; s ! (sa_ - 1) \\<noteq> s ! (baa_ - 1);\n     \\<forall>jj<baa_. ab_ ! jj = \\<ff> s jj; 0 < baa_;\n     strict_border (take (sa_ - 1) s) (take (baa_ - 1) s);\n     \\<ff> s baa_ \\<le> Suc sa_\\<rbrakk>\n    \\<Longrightarrow> sa_ - 1 < length ab_", "by fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> strict_border (take (ab ! (sa - 1) - 1) s)\n                          (take (baa - 1) s)\n 2. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s baa \\<le> Suc (ab ! (sa - 1))\n 3. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab;\n        Suc (length s) = length ab; baa \\<noteq> 1; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> ab ! (sa - 1) < sa\n 4. \\<And>ab baa sa jj.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        jj < Suc baa; Suc (length s) = length ab;\n        baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> ab[baa := Suc sa] ! jj = \\<ff> s jj\n 5. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>baa_ < length ab_; sa_ - 1 < length ab_; baa_ \\<noteq> 1;\n     Suc (length s) = length ab_;\n     strict_border (take (sa_ - 1) s) (take (baa_ - 1) s);\n     \\<ff> s baa_ \\<le> Suc sa_; 0 < sa_;\n     s ! (sa_ - 1) \\<noteq> s ! (baa_ - 1);\n     \\<forall>jj<baa_. ab_ ! jj = \\<ff> s jj; 0 < baa_\\<rbrakk>\n    \\<Longrightarrow> strict_border (take (ab_ ! (sa_ - 1) - 1) s)\n                       (take (baa_ - 1) s)", "by (metis (no_types, lifting) One_nat_def Suc_lessD Suc_pred border_length_r_less \\<ff>_strict_borderI length_take less_Suc_eq less_Suc_eq_le min.absorb2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab; baa \\<noteq> 1;\n        Suc (length s) = length ab;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> \\<ff> s baa \\<le> Suc (ab ! (sa - 1))\n 2. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab;\n        Suc (length s) = length ab; baa \\<noteq> 1; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> ab ! (sa - 1) < sa\n 3. \\<And>ab baa sa jj.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        jj < Suc baa; Suc (length s) = length ab;\n        baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> ab[baa := Suc sa] ! jj = \\<ff> s jj\n 4. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal for b j i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length b; i - 1 < length b; j \\<noteq> 1;\n     Suc (length s) = length b;\n     strict_border (take (i - 1) s) (take (j - 1) s); \\<ff> s j \\<le> Suc i;\n     0 < i; s ! (i - 1) \\<noteq> s ! (j - 1);\n     \\<forall>jj<j. b ! jj = \\<ff> s jj; 0 < j\\<rbrakk>\n    \\<Longrightarrow> \\<ff> s j \\<le> Suc (b ! (i - 1))", "by (metis (no_types, lifting) One_nat_def Suc_diff_1 Suc_eq_plus1 Suc_leI border_take_lengths less_Suc_eq_le less_antisym skipping_ok strict_border_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab baa sa.\n       \\<lbrakk>baa < length ab; sa - 1 < length ab;\n        Suc (length s) = length ab; baa \\<noteq> 1; 0 < sa;\n        s ! (sa - 1) \\<noteq> s ! (baa - 1);\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa;\n        strict_border (take (sa - 1) s) (take (baa - 1) s);\n        \\<ff> s baa \\<le> Suc sa\\<rbrakk>\n       \\<Longrightarrow> ab ! (sa - 1) < sa\n 2. \\<And>ab baa sa jj.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        jj < Suc baa; Suc (length s) = length ab;\n        baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> ab[baa := Suc sa] ! jj = \\<ff> s jj\n 3. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>baa_ < length ab_; sa_ - 1 < length ab_;\n     Suc (length s) = length ab_; baa_ \\<noteq> 1; 0 < sa_;\n     s ! (sa_ - 1) \\<noteq> s ! (baa_ - 1);\n     \\<forall>jj<baa_. ab_ ! jj = \\<ff> s jj; 0 < baa_;\n     strict_border (take (sa_ - 1) s) (take (baa_ - 1) s);\n     \\<ff> s baa_ \\<le> Suc sa_\\<rbrakk>\n    \\<Longrightarrow> ab_ ! (sa_ - 1) < sa_", "by (metis Suc_diff_1 border_take_lengths j_le_\\<ff>_le less_Suc_eq_le strict_border_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab baa sa jj.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        jj < Suc baa; Suc (length s) = length ab;\n        baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> ab[baa := Suc sa] ! jj = \\<ff> s jj\n 2. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal for b j i jj"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<or> s ! (i - 1) = s ! (j - 1); j < length b;\n     jj < Suc j; Suc (length s) = length b; j = 1 \\<longrightarrow> i = 0;\n     j \\<noteq> 1 \\<longrightarrow>\n     strict_border (take (i - 1) s) (take (j - 1) s) \\<and>\n     \\<ff> s j \\<le> Suc i;\n     \\<forall>jj<j. b ! jj = \\<ff> s jj; 0 < j\\<rbrakk>\n    \\<Longrightarrow> b[j := Suc i] ! jj = \\<ff> s jj", "by (metis Suc_eq_plus1 Suc_eq_plus1_left add.right_neutral extend_border \\<ff>_eq_0_iff_j_eq_0 j_le_\\<ff>_le le_zero_eq less_Suc_eq less_Suc_eq_le nth_list_update_eq nth_list_update_neq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab baa sa.\n       \\<lbrakk>sa = 0 \\<or> s ! (sa - 1) = s ! (baa - 1); baa < length ab;\n        Suc (length s) = length ab; baa = 1 \\<longrightarrow> sa = 0;\n        baa \\<noteq> 1 \\<longrightarrow>\n        strict_border (take (sa - 1) s) (take (baa - 1) s) \\<and>\n        \\<ff> s baa \\<le> Suc sa;\n        \\<forall>jj<baa. ab ! jj = \\<ff> s jj; 0 < baa\\<rbrakk>\n       \\<Longrightarrow> length ab - Suc baa < length ab - baa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sa_ = 0 \\<or> s ! (sa_ - 1) = s ! (baa_ - 1);\n     baa_ < length ab_; Suc (length s) = length ab_;\n     baa_ = 1 \\<longrightarrow> sa_ = 0;\n     baa_ \\<noteq> 1 \\<longrightarrow>\n     strict_border (take (sa_ - 1) s) (take (baa_ - 1) s) \\<and>\n     \\<ff> s baa_ \\<le> Suc sa_;\n     \\<forall>jj<baa_. ab_ ! jj = \\<ff> s jj; 0 < baa_\\<rbrakk>\n    \\<Longrightarrow> length ab_ - Suc baa_ < length ab_ - baa_", "by linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Index shift\\<close>"], ["", "text\\<open>To avoid inefficiencies, we refine @{const compute_\\<ff>s} to take @{term s}\ninstead of @{term \\<open>butlast s\\<close>} (it still only uses @{term \\<open>butlast s\\<close>}).\\<close>"], ["", "definition compute_butlast_\\<ff>s :: \"'a list \\<Rightarrow> nat list nres\" where\n  \"compute_butlast_\\<ff>s s = do {\n  let \\<ff>s=replicate (length s) 0;\n  let i=0;\n  let j=1;\n  (\\<ff>s,_,_) \\<leftarrow> WHILEIT (I_out_cb (butlast s)) (\\<lambda>(b,i,j). j < length b) (\\<lambda>(\\<ff>s,i,j). do {\n    ASSERT (j < length \\<ff>s);\n    i \\<leftarrow> WHILEIT (I_in_cb (butlast s) j) (\\<lambda>i. i>0 \\<and> s!(i-1) \\<noteq> s!(j-1)) (\\<lambda>i. do {\n      ASSERT (i-1 < length \\<ff>s);\n      let i=\\<ff>s!(i-1);\n      RETURN i\n    }) i;\n    let i=i+1;\n    ASSERT (j < length \\<ff>s);\n    let \\<ff>s=\\<ff>s[j:=i];\n    let j=j+1;\n    RETURN (\\<ff>s,i,j)\n  }) (\\<ff>s,i,j);\n  \n  RETURN \\<ff>s\n}\""], ["", "lemma compute_\\<ff>s_inner_bounds: \n  assumes \"I_out_cb s (\\<ff>s,ix,j)\"\n  assumes \"j < length \\<ff>s\"\n  assumes \"I_in_cb s j i\"\n  shows \"i-1 < length s\" \"j-1 < length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - 1 < length s &&& j - 1 < length s", "using assms"], ["proof (prove)\nusing this:\n  I_out_cb s (\\<ff>s, ix, j)\n  j < length \\<ff>s\n  I_in_cb s j i\n\ngoal (1 subgoal):\n 1. i - 1 < length s &&& j - 1 < length s", "by (auto simp: I_out_cb_def I_in_cb_def split: if_splits)"], ["", "lemma compute_butlast_\\<ff>s_refine[refine]:\n  assumes \"(s,s') \\<in> br butlast ((\\<noteq>) [])\"\n  shows \"compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')", "have \"compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s s')", "unfolding compute_butlast_\\<ff>s_def compute_\\<ff>s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let \\<ff>s = replicate (length s) 0; i = 0; j = 1\n     in WHILE\\<^sub>T\\<^bsup>I_out_cb (butlast s)\\<^esup>\n         (\\<lambda>(b, i, j). j < length b)\n         (\\<lambda>(\\<ff>s, i, j).\n             ASSERT (j < length \\<ff>s) \\<bind>\n             (\\<lambda>_.\n                 WHILE\\<^sub>T\\<^bsup>I_in_cb (butlast s) j\\<^esup>\n                  (\\<lambda>i.\n                      0 < i \\<and> s ! (i - 1) \\<noteq> s ! (j - 1))\n                  (\\<lambda>i.\n                      ASSERT (i - 1 < length \\<ff>s) \\<bind>\n                      (\\<lambda>_. Let (\\<ff>s ! (i - 1)) RETURN))\n                  i \\<bind>\n                 (\\<lambda>i.\n                     let i = i + 1\n                     in ASSERT (j < length \\<ff>s) \\<bind>\n                        (\\<lambda>_.\n                            let \\<ff>s = \\<ff>s[j := i]; j = j + 1\n                            in RETURN (\\<ff>s, i, j)))))\n         (\\<ff>s, i, j) \\<bind>\n        (\\<lambda>(\\<ff>s, uu_, uu_). RETURN \\<ff>s))\n    \\<le> \\<Down> Id\n           (let \\<ff>s = replicate (length s' + 1) 0; i = 0; j = 1\n            in WHILE\\<^sub>T\\<^bsup>I_out_cb s'\\<^esup>\n                (\\<lambda>(\\<ff>s, uu_, j). j < length \\<ff>s)\n                (\\<lambda>(\\<ff>s, i, j).\n                    WHILE\\<^sub>T\\<^bsup>I_in_cb s' j\\<^esup>\n                     (\\<lambda>i.\n                         0 < i \\<and> s' ! (i - 1) \\<noteq> s' ! (j - 1))\n                     (\\<lambda>i.\n                         ASSERT (i - 1 < length \\<ff>s) \\<bind>\n                         (\\<lambda>_. Let (\\<ff>s ! (i - 1)) RETURN))\n                     i \\<bind>\n                    (\\<lambda>i.\n                        let i = i + 1\n                        in ASSERT (j < length \\<ff>s) \\<bind>\n                           (\\<lambda>_.\n                               let \\<ff>s = \\<ff>s[j := i]; j = j + 1\n                               in RETURN (\\<ff>s, i, j))))\n                (\\<ff>s, i, j) \\<bind>\n               (\\<lambda>(\\<ff>s, uu_, uu_). RETURN \\<ff>s))", "apply (refine_rcg)"], ["proof (prove)\ngoal (11 subgoals):\n 1. I_out_cb s' (replicate (length s' + 1) 0, 0, 1) \\<Longrightarrow>\n    ((replicate (length s) 0, 0, 1), replicate (length s' + 1) 0, 0, 1)\n    \\<in> ?R'3\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x') \\<in> ?R'3; I_out_cb s' x'\\<rbrakk>\n       \\<Longrightarrow> I_out_cb (butlast s) x\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x') \\<in> ?R'3; I_out_cb (butlast s) x; I_out_cb s' x';\n        x2 = (x1a, x2a); x = (x1, x2); x2b = (x1c, x2c);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x2a < length x1) = (x2c < length x1b)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x') \\<in> ?R'3;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> x2c < length x1b\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x') \\<in> ?R'3;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        I_in_cb s' x2a x1a\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a)\n                         \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'3;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        I_in_cb s' x2a x'a\\<rbrakk>\n       \\<Longrightarrow> I_in_cb (butlast s) x2c xa\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'3;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        I_in_cb (butlast s) x2c xa; I_in_cb s' x2a x'a\\<rbrakk>\n       \\<Longrightarrow> (0 < xa \\<and>\n                          s ! (xa - 1) \\<noteq> s ! (x2c - 1)) =\n                         (0 < x'a \\<and>\n                          s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1))\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'3;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        0 < xa \\<and> s ! (xa - 1) \\<noteq> s ! (x2c - 1);\n        0 < x'a \\<and> s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1);\n        I_in_cb (butlast s) x2c xa; I_in_cb s' x2a x'a;\n        x'a - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> xa - 1 < length x1b\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x') \\<in> ?R'3;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        0 < xa \\<and> s ! (xa - 1) \\<noteq> s ! (x2c - 1);\n        0 < x'a \\<and> s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1);\n        I_in_cb (butlast s) x2c xa; I_in_cb s' x2a x'a; x'a - 1 < length x1;\n        xa - 1 < length x1b\\<rbrakk>\n       \\<Longrightarrow> (x1b ! (xa - 1), x1 ! (x'a - 1))\n                         \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c i ia.\n        \\<lbrakk>(x, x') \\<in> ?R'3;\n         case x of (b, i, j) \\<Rightarrow> j < length b;\n         case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n         I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n         x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n         (i, ia) \\<in> ?R'110 x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n         x2a < length x1; x2c < length x1b\\<rbrakk>\n        \\<Longrightarrow> ((x1b[x2c := i + 1], i + 1, x2c + 1), x1\n                           [x2a := ia + 1], ia + 1, x2a + 1)\n                          \\<in> ?R'3\nA total of 11 subgoals...", "apply (refine_dref_type)"], ["proof (prove)\ngoal (11 subgoals):\n 1. I_out_cb s' (replicate (length s' + 1) 0, 0, 1) \\<Longrightarrow>\n    ((replicate (length s) 0, 0, 1), replicate (length s' + 1) 0, 0, 1)\n    \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n          nat_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        I_out_cb s' x'\\<rbrakk>\n       \\<Longrightarrow> I_out_cb (butlast s) x\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x = (x1, x2); x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x2a < length x1) = (x2c < length x1b)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> x2c < length x1b\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        I_in_cb s' x2a x1a\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> nat_rel\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel; I_in_cb s' x2a x'a\\<rbrakk>\n       \\<Longrightarrow> I_in_cb (butlast s) x2c xa\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel; I_in_cb (butlast s) x2c xa;\n        I_in_cb s' x2a x'a\\<rbrakk>\n       \\<Longrightarrow> (0 < xa \\<and>\n                          s ! (xa - 1) \\<noteq> s ! (x2c - 1)) =\n                         (0 < x'a \\<and>\n                          s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1))\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel;\n        0 < xa \\<and> s ! (xa - 1) \\<noteq> s ! (x2c - 1);\n        0 < x'a \\<and> s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1);\n        I_in_cb (butlast s) x2c xa; I_in_cb s' x2a x'a;\n        x'a - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> xa - 1 < length x1b\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel;\n        0 < xa \\<and> s ! (xa - 1) \\<noteq> s ! (x2c - 1);\n        0 < x'a \\<and> s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1);\n        I_in_cb (butlast s) x2c xa; I_in_cb s' x2a x'a; x'a - 1 < length x1;\n        xa - 1 < length x1b\\<rbrakk>\n       \\<Longrightarrow> (x1b ! (xa - 1), x1 ! (x'a - 1)) \\<in> nat_rel\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c i ia.\n        \\<lbrakk>(x, x')\n                 \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                       nat_rel \\<times>\\<^sub>r nat_rel;\n         case x of (b, i, j) \\<Rightarrow> j < length b;\n         case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n         I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n         x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n         (i, ia) \\<in> nat_rel; x2a < length x1; x2c < length x1b\\<rbrakk>\n        \\<Longrightarrow> ((x1b[x2c := i + 1], i + 1, x2c + 1), x1\n                           [x2a := ia + 1], ia + 1, x2a + 1)\n                          \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                nat_rel \\<times>\\<^sub>r nat_rel\nA total of 11 subgoals...", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> br butlast ((\\<noteq>) [])\n\ngoal (11 subgoals):\n 1. I_out_cb s' (replicate (length s' + 1) 0, 0, 1) \\<Longrightarrow>\n    ((replicate (length s) 0, 0, 1), replicate (length s' + 1) 0, 0, 1)\n    \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n          nat_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>x x'.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        I_out_cb s' x'\\<rbrakk>\n       \\<Longrightarrow> I_out_cb (butlast s) x\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x = (x1, x2); x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x2a < length x1) = (x2c < length x1b)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> x2c < length x1b\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        I_in_cb s' x2a x1a\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> nat_rel\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel; I_in_cb s' x2a x'a\\<rbrakk>\n       \\<Longrightarrow> I_in_cb (butlast s) x2c xa\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel; I_in_cb (butlast s) x2c xa;\n        I_in_cb s' x2a x'a\\<rbrakk>\n       \\<Longrightarrow> (0 < xa \\<and>\n                          s ! (xa - 1) \\<noteq> s ! (x2c - 1)) =\n                         (0 < x'a \\<and>\n                          s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1))\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel;\n        0 < xa \\<and> s ! (xa - 1) \\<noteq> s ! (x2c - 1);\n        0 < x'a \\<and> s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1);\n        I_in_cb (butlast s) x2c xa; I_in_cb s' x2a x'a;\n        x'a - 1 < length x1\\<rbrakk>\n       \\<Longrightarrow> xa - 1 < length x1b\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>(x, x')\n                \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                      nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (b, i, j) \\<Rightarrow> j < length b;\n        case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n        I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n        (xa, x'a) \\<in> nat_rel;\n        0 < xa \\<and> s ! (xa - 1) \\<noteq> s ! (x2c - 1);\n        0 < x'a \\<and> s' ! (x'a - 1) \\<noteq> s' ! (x2a - 1);\n        I_in_cb (butlast s) x2c xa; I_in_cb s' x2a x'a; x'a - 1 < length x1;\n        xa - 1 < length x1b\\<rbrakk>\n       \\<Longrightarrow> (x1b ! (xa - 1), x1 ! (x'a - 1)) \\<in> nat_rel\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c i ia.\n        \\<lbrakk>(x, x')\n                 \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                       nat_rel \\<times>\\<^sub>r nat_rel;\n         case x of (b, i, j) \\<Rightarrow> j < length b;\n         case x' of (\\<ff>s, uu_, j) \\<Rightarrow> j < length \\<ff>s;\n         I_out_cb (butlast s) x; I_out_cb s' x'; x2 = (x1a, x2a);\n         x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b); x2c < length x1b;\n         (i, ia) \\<in> nat_rel; x2a < length x1; x2c < length x1b\\<rbrakk>\n        \\<Longrightarrow> ((x1b[x2c := i + 1], i + 1, x2c + 1), x1\n                           [x2a := ia + 1], ia + 1, x2a + 1)\n                          \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                nat_rel \\<times>\\<^sub>r nat_rel\nA total of 11 subgoals...", "apply (vc_solve simp: in_br_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>I_out_cb (butlast s)\n              (0 # replicate (length s - Suc 0) 0, 0, Suc 0);\n     s' = butlast s; [] \\<noteq> s\\<rbrakk>\n    \\<Longrightarrow> replicate (length s) 0 =\n                      0 # replicate (length s - Suc 0) 0\n 2. \\<And>x1 x1a x2a x'a.\n       \\<lbrakk>x2a < length x1; I_out_cb (butlast s) (x1, x1a, x2a);\n        I_in_cb (butlast s) x2a x'a; s' = butlast s; [] \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> (0 < x'a \\<and>\n                          s ! (x'a - Suc 0) \\<noteq> s ! (x2a - Suc 0)) =\n                         (0 < x'a \\<and>\n                          butlast s ! (x'a - Suc 0) \\<noteq>\n                          butlast s ! (x2a - Suc 0))", "apply (metis Suc_pred length_greater_0_conv replicate_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x1a x2a x'a.\n       \\<lbrakk>x2a < length x1; I_out_cb (butlast s) (x1, x1a, x2a);\n        I_in_cb (butlast s) x2a x'a; s' = butlast s; [] \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> (0 < x'a \\<and>\n                          s ! (x'a - Suc 0) \\<noteq> s ! (x2a - Suc 0)) =\n                         (0 < x'a \\<and>\n                          butlast s ! (x'a - Suc 0) \\<noteq>\n                          butlast s ! (x2a - Suc 0))", "by (metis One_nat_def compute_\\<ff>s_inner_bounds nth_butlast)"], ["proof (state)\nthis:\n  compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s s')\n\ngoal (1 subgoal):\n 1. compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')", "also"], ["proof (state)\nthis:\n  compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s s')\n\ngoal (1 subgoal):\n 1. compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')", "note compute_\\<ff>s_correct"], ["proof (state)\nthis:\n  compute_\\<ff>s ?s \\<le> compute_\\<ff>s_SPEC ?s\n\ngoal (1 subgoal):\n 1. compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')", "finally"], ["proof (chain)\npicking this:\n  compute_butlast_\\<ff>s s \\<le> compute_\\<ff>s_SPEC s'", "show ?thesis"], ["proof (prove)\nusing this:\n  compute_butlast_\\<ff>s s \\<le> compute_\\<ff>s_SPEC s'\n\ngoal (1 subgoal):\n 1. compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')", "by simp"], ["proof (state)\nthis:\n  compute_butlast_\\<ff>s s \\<le> \\<Down> Id (compute_\\<ff>s_SPEC s')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Conflation\\<close>"], ["", "text\\<open>We replace @{const compute_\\<ff>s_SPEC} with @{const compute_butlast_\\<ff>s}\\<close>"], ["", "definition \"kmp2 s t \\<equiv> do {\n  ASSERT (s \\<noteq> []);\n  let i=0;\n  let j=0;\n  let pos=None;\n  \\<ff>s \\<leftarrow> compute_butlast_\\<ff>s s;\n  (_,_,pos) \\<leftarrow> WHILEIT (I_outer s t) (\\<lambda>(i,j,pos). i + length s \\<le> length t \\<and> pos=None) (\\<lambda>(i,j,pos). do {\n    ASSERT (i + length s \\<le> length t \\<and> pos=None);\n    (j,pos) \\<leftarrow> WHILEIT (I_in_na s t i) (\\<lambda>(j,pos). t!(i+j) = s!j \\<and> pos=None) (\\<lambda>(j,pos). do {\n      let j=j+1;\n      if j=length s then RETURN (j,Some i) else RETURN (j,None)\n    }) (j,pos);\n    if pos=None then do {\n      ASSERT (j < length \\<ff>s);\n      let i = i + (j - \\<ff>s!j + 1);\n      let j = max 0 (\\<ff>s!j - 1); \\<comment> \\<open>\\<open>max\\<close> not necessary\\<close>\n      RETURN (i,j,None)\n    } else RETURN (i,j,Some i)\n  }) (i,j,pos);\n\n  RETURN pos\n}\""], ["", "text\\<open>Using @{thm [source] compute_butlast_\\<ff>s_refine} (it has attribute @{attribute refine}), the proof is trivial:\\<close>"], ["", "lemma kmp2_refine: \"kmp2 s t \\<le> kmp1 s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp2 s t \\<le> kmp1 s t", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp2 s t \\<le> \\<Down> Id (kmp1 s t)", "unfolding kmp2_def kmp1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (s \\<noteq> []) \\<bind>\n    (\\<lambda>_.\n        let i = 0; j = 0; pos = None\n        in compute_butlast_\\<ff>s s \\<bind>\n           (\\<lambda>\\<ff>s.\n               WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                (\\<lambda>(i, j, pos).\n                    i + length s \\<le> length t \\<and> pos = None)\n                (\\<lambda>(i, j, pos).\n                    ASSERT\n                     (i + length s \\<le> length t \\<and> pos = None) \\<bind>\n                    (\\<lambda>_.\n                        WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n                         (\\<lambda>(j, pos).\n                             t ! (i + j) = s ! j \\<and> pos = None)\n                         (\\<lambda>(j, pos).\n                             let j = j + 1\n                             in if j = length s then RETURN (j, Some i)\n                                else RETURN (j, None))\n                         (j, pos) \\<bind>\n                        (\\<lambda>(j, pos).\n                            if pos = None\n                            then ASSERT (j < length \\<ff>s) \\<bind>\n                                 (\\<lambda>_.\n                                     let i = i + (j - \\<ff>s ! j + 1);\n   j = max 0 (\\<ff>s ! j - 1)\n                                     in RETURN (i, j, None))\n                            else RETURN (i, j, Some i))))\n                (i, j, pos) \\<bind>\n               (\\<lambda>(uu_, uu_, pos). RETURN pos)))\n    \\<le> \\<Down> Id\n           (ASSERT (s \\<noteq> []) \\<bind>\n            (\\<lambda>_.\n                let i = 0; j = 0; pos = None\n                in compute_\\<ff>s_SPEC (butlast s) \\<bind>\n                   (\\<lambda>\\<ff>s.\n                       WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                        (\\<lambda>(i, j, pos).\n                            i + length s \\<le> length t \\<and> pos = None)\n                        (\\<lambda>(i, j, pos).\n                            ASSERT (i + length s \\<le> length t) \\<bind>\n                            (\\<lambda>_.\n                                WHILE\\<^sub>T\\<^bsup>I_in_na s t i\\<^esup>\n                                 (\\<lambda>(j, pos).\n                                     t ! (i + j) = s ! j \\<and> pos = None)\n                                 (\\<lambda>(j, pos).\n                                     let j = j + 1\n                                     in if j = length s\n  then RETURN (j, Some i) else RETURN (j, None))\n                                 (j, pos) \\<bind>\n                                (\\<lambda>(j, pos).\n                                    if pos = None\n                                    then ASSERT (j < length \\<ff>s) \\<bind>\n   (\\<lambda>_.\n       let i = i + (j - \\<ff>s ! j + 1); j = max 0 (\\<ff>s ! j - 1)\n       in RETURN (i, j, None))\n                                    else RETURN (i, j, Some i))))\n                        (i, j, pos) \\<bind>\n                       (\\<lambda>(uu_, uu_, pos). RETURN pos))))", "apply refine_rcg"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<lbrakk>s \\<noteq> []; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (s, butlast s) \\<in> br butlast ((\\<noteq>) [])\n 2. \\<And>\\<ff>s \\<ff>sa.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        I_outer s t (0, 0, None)\\<rbrakk>\n       \\<Longrightarrow> ((0, 0, None), 0, 0, None)\n                         \\<in> ?R'9 \\<ff>s \\<ff>sa\n 3. \\<And>\\<ff>s \\<ff>sa x x'.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa; I_outer s t x'\\<rbrakk>\n       \\<Longrightarrow> I_outer s t x\n 4. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa; I_outer s t x; I_outer s t x';\n        x2 = (x1a, x2a); x = (x1, x2); x2b = (x1c, x2c);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1 + length s \\<le> length t \\<and> x2a = None) =\n                         (x1b + length s \\<le> length t \\<and> x2c = None)\n 5. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        x1 + length s \\<le> length t\\<rbrakk>\n       \\<Longrightarrow> x1b + length s \\<le> length t\n 6. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        x1 + length s \\<le> length t\\<rbrakk>\n       \\<Longrightarrow> x2c = None\n 7. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t \\<and> x2c = None;\n        I_in_na s t x1 (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a)\n                         \\<in> ?R'118 \\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b\n                                x2b x1c x2c\n 8. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t \\<and> x2c = None;\n        (xa, x'a)\n        \\<in> ?R'118 \\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        I_in_na s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> I_in_na s t x1b xa\n 9. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d\n       x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t \\<and> x2c = None;\n        (xa, x'a)\n        \\<in> ?R'118 \\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; xa = (x1d, x2d);\n        x'a = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (t ! (x1b + x1d) = s ! x1d \\<and> x2d = None) =\n                         (t ! (x1 + x1e) = s ! x1e \\<and> x2e = None)\n 10. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d\n        x1e x2e.\n        \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n         (x, x') \\<in> ?R'9 \\<ff>s \\<ff>sa;\n         case x of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         case x' of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n         x1b + length s \\<le> length t \\<and> x2c = None;\n         (xa, x'a)\n         \\<in> ?R'118 \\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c;\n         case xa of\n         (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n         case x'a of\n         (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n         I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n         xa = (x1e, x2e)\\<rbrakk>\n        \\<Longrightarrow> (x1e + 1 = length s) = (x1d + 1 = length s)\nA total of 17 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<lbrakk>s \\<noteq> []; s \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (s, butlast s) \\<in> br butlast ((\\<noteq>) [])\n 2. \\<And>\\<ff>s \\<ff>sa.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        I_outer s t (0, 0, None)\\<rbrakk>\n       \\<Longrightarrow> ((0, 0, None), 0, 0, None)\n                         \\<in> nat_rel \\<times>\\<^sub>r\n                               nat_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>option_rel\n 3. \\<And>\\<ff>s \\<ff>sa x x'.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_outer s t x'\\<rbrakk>\n       \\<Longrightarrow> I_outer s t x\n 4. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x = (x1, x2);\n        x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1 + length s \\<le> length t \\<and> x2a = None) =\n                         (x1b + length s \\<le> length t \\<and> x2c = None)\n 5. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        x1 + length s \\<le> length t\\<rbrakk>\n       \\<Longrightarrow> x1b + length s \\<le> length t\n 6. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b);\n        x1 + length s \\<le> length t\\<rbrakk>\n       \\<Longrightarrow> x2c = None\n 7. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t \\<and> x2c = None;\n        I_in_na s t x1 (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a)\n                         \\<in> nat_rel \\<times>\\<^sub>r\n                               \\<langle>nat_rel\\<rangle>option_rel\n 8. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t \\<and> x2c = None;\n        (xa, x'a)\n        \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_in_na s t x1 x'a\\<rbrakk>\n       \\<Longrightarrow> I_in_na s t x1b xa\n 9. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d\n       x1e x2e.\n       \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n        (x, x')\n        \\<in> nat_rel \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        case x of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        case x' of\n        (i, j, pos) \\<Rightarrow>\n          i + length s \\<le> length t \\<and> pos = None;\n        I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n        x1b + length s \\<le> length t \\<and> x2c = None;\n        (xa, x'a)\n        \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n        I_in_na s t x1b xa; I_in_na s t x1 x'a; xa = (x1d, x2d);\n        x'a = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (t ! (x1b + x1d) = s ! x1d \\<and> x2d = None) =\n                         (t ! (x1 + x1e) = s ! x1e \\<and> x2e = None)\n 10. \\<And>\\<ff>s \\<ff>sa x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d\n        x1e x2e.\n        \\<lbrakk>s \\<noteq> []; s \\<noteq> []; (\\<ff>s, \\<ff>sa) \\<in> Id;\n         (x, x')\n         \\<in> nat_rel \\<times>\\<^sub>r\n               nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n         case x of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         case x' of\n         (i, j, pos) \\<Rightarrow>\n           i + length s \\<le> length t \\<and> pos = None;\n         I_outer s t x; I_outer s t x'; x2 = (x1a, x2a); x' = (x1, x2);\n         x2b = (x1c, x2c); x = (x1b, x2b); x1 + length s \\<le> length t;\n         x1b + length s \\<le> length t \\<and> x2c = None;\n         (xa, x'a)\n         \\<in> nat_rel \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>option_rel;\n         case xa of\n         (j, pos) \\<Rightarrow> t ! (x1b + j) = s ! j \\<and> pos = None;\n         case x'a of\n         (j, pos) \\<Rightarrow> t ! (x1 + j) = s ! j \\<and> pos = None;\n         I_in_na s t x1b xa; I_in_na s t x1 x'a; x'a = (x1d, x2d);\n         xa = (x1e, x2e)\\<rbrakk>\n        \\<Longrightarrow> (x1e + 1 = length s) = (x1d + 1 = length s)\nA total of 17 subgoals...", "apply (vc_solve simp: in_br_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma kmp2_correct: \"s \\<noteq> []\n  \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "assume \"s \\<noteq> []\""], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "have \"kmp2 s t \\<le> kmp1 s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp2 s t \\<le> kmp1 s t", "by (fact kmp2_refine)"], ["proof (state)\nthis:\n  kmp2 s t \\<le> kmp1 s t\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "also"], ["proof (state)\nthis:\n  kmp2 s t \\<le> kmp1 s t\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "have \"... \\<le> kmp s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp1 s t \\<le> kmp s t", "by (fact kmp1_refine)"], ["proof (state)\nthis:\n  kmp1 s t \\<le> kmp s t\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "also"], ["proof (state)\nthis:\n  kmp1 s t \\<le> kmp s t\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "have \"... \\<le> kmp_SPEC s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp s t \\<le> kmp_SPEC s t", "by (fact kmp_correct[OF \\<open>s \\<noteq> []\\<close>])"], ["proof (state)\nthis:\n  kmp s t \\<le> kmp_SPEC s t\n\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<Longrightarrow> kmp2 s t \\<le> kmp_SPEC s t", "finally"], ["proof (chain)\npicking this:\n  kmp2 s t \\<le> kmp_SPEC s t", "show ?thesis"], ["proof (prove)\nusing this:\n  kmp2 s t \\<le> kmp_SPEC s t\n\ngoal (1 subgoal):\n 1. kmp2 s t \\<le> kmp_SPEC s t", "."], ["proof (state)\nthis:\n  kmp2 s t \\<le> kmp_SPEC s t\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>For convenience, we also remove the precondition:\\<close>"], ["", "definition \"kmp3 s t \\<equiv> do {\n  if s=[] then RETURN (Some 0) else kmp2 s t\n}\""], ["", "lemma kmp3_correct: \"kmp3 s t \\<le> kmp_SPEC s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kmp3 s t \\<le> kmp_SPEC s t", "unfolding kmp3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if s = [] then RETURN (Some 0) else kmp2 s t) \\<le> kmp_SPEC s t", "by (simp add: kmp2_correct) (simp add: kmp_SPEC_def)"], ["", "section \\<open>Refinement to Imperative/HOL\\<close>"], ["", "lemma eq_id_param: \"((=), (=)) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel", "by simp"], ["", "lemmas in_bounds_aux = compute_\\<ff>s_inner_bounds[of \"butlast s\" for s, simplified]"], ["", "sepref_definition compute_butlast_\\<ff>s_impl is compute_butlast_\\<ff>s :: \"(arl_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, compute_butlast_\\<ff>s)\n    \\<in> (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "unfolding compute_butlast_\\<ff>s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>s.\n        let \\<ff>s = replicate (length s) 0; i = 0; j = 1\n        in WHILE\\<^sub>T\\<^bsup>I_out_cb (butlast s)\\<^esup>\n            (\\<lambda>(b, i, j). j < length b)\n            (\\<lambda>(\\<ff>s, i, j).\n                ASSERT (j < length \\<ff>s) \\<bind>\n                (\\<lambda>_.\n                    WHILE\\<^sub>T\\<^bsup>I_in_cb (butlast s) j\\<^esup>\n                     (\\<lambda>i.\n                         0 < i \\<and> s ! (i - 1) \\<noteq> s ! (j - 1))\n                     (\\<lambda>i.\n                         ASSERT (i - 1 < length \\<ff>s) \\<bind>\n                         (\\<lambda>_. Let (\\<ff>s ! (i - 1)) RETURN))\n                     i \\<bind>\n                    (\\<lambda>i.\n                        let i = i + 1\n                        in ASSERT (j < length \\<ff>s) \\<bind>\n                           (\\<lambda>_.\n                               let \\<ff>s = \\<ff>s[j := i]; j = j + 1\n                               in RETURN (\\<ff>s, i, j)))))\n            (\\<ff>s, i, j) \\<bind>\n           (\\<lambda>(\\<ff>s, uu_, uu_). RETURN \\<ff>s))\n    \\<in> (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "supply in_bounds_aux[dest]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>s.\n        let \\<ff>s = replicate (length s) 0; i = 0; j = 1\n        in WHILE\\<^sub>T\\<^bsup>I_out_cb (butlast s)\\<^esup>\n            (\\<lambda>(b, i, j). j < length b)\n            (\\<lambda>(\\<ff>s, i, j).\n                ASSERT (j < length \\<ff>s) \\<bind>\n                (\\<lambda>_.\n                    WHILE\\<^sub>T\\<^bsup>I_in_cb (butlast s) j\\<^esup>\n                     (\\<lambda>i.\n                         0 < i \\<and> s ! (i - 1) \\<noteq> s ! (j - 1))\n                     (\\<lambda>i.\n                         ASSERT (i - 1 < length \\<ff>s) \\<bind>\n                         (\\<lambda>_. Let (\\<ff>s ! (i - 1)) RETURN))\n                     i \\<bind>\n                    (\\<lambda>i.\n                        let i = i + 1\n                        in ASSERT (j < length \\<ff>s) \\<bind>\n                           (\\<lambda>_.\n                               let \\<ff>s = \\<ff>s[j := i]; j = j + 1\n                               in RETURN (\\<ff>s, i, j)))))\n            (\\<ff>s, i, j) \\<bind>\n           (\\<lambda>(\\<ff>s, uu_, uu_). RETURN \\<ff>s))\n    \\<in> (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "supply eq_id_param[where 'a='a, sepref_import_param]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>s.\n        let \\<ff>s = replicate (length s) 0; i = 0; j = 1\n        in WHILE\\<^sub>T\\<^bsup>I_out_cb (butlast s)\\<^esup>\n            (\\<lambda>(b, i, j). j < length b)\n            (\\<lambda>(\\<ff>s, i, j).\n                ASSERT (j < length \\<ff>s) \\<bind>\n                (\\<lambda>_.\n                    WHILE\\<^sub>T\\<^bsup>I_in_cb (butlast s) j\\<^esup>\n                     (\\<lambda>i.\n                         0 < i \\<and> s ! (i - 1) \\<noteq> s ! (j - 1))\n                     (\\<lambda>i.\n                         ASSERT (i - 1 < length \\<ff>s) \\<bind>\n                         (\\<lambda>_. Let (\\<ff>s ! (i - 1)) RETURN))\n                     i \\<bind>\n                    (\\<lambda>i.\n                        let i = i + 1\n                        in ASSERT (j < length \\<ff>s) \\<bind>\n                           (\\<lambda>_.\n                               let \\<ff>s = \\<ff>s[j := i]; j = j + 1\n                               in RETURN (\\<ff>s, i, j)))))\n            (\\<ff>s, i, j) \\<bind>\n           (\\<lambda>(\\<ff>s, uu_, uu_). RETURN \\<ff>s))\n    \\<in> (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "apply (rewrite array_fold_custom_replicate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>s.\n        let \\<ff>s = op_array_replicate (length s) 0; i = 0; j = 1\n        in WHILE\\<^sub>T\\<^bsup>I_out_cb (butlast s)\\<^esup>\n            (\\<lambda>(b, i, j). j < length b)\n            (\\<lambda>(\\<ff>s, i, j).\n                ASSERT (j < length \\<ff>s) \\<bind>\n                (\\<lambda>_.\n                    WHILE\\<^sub>T\\<^bsup>I_in_cb (butlast s) j\\<^esup>\n                     (\\<lambda>i.\n                         0 < i \\<and> s ! (i - 1) \\<noteq> s ! (j - 1))\n                     (\\<lambda>i.\n                         ASSERT (i - 1 < length \\<ff>s) \\<bind>\n                         (\\<lambda>_. Let (\\<ff>s ! (i - 1)) RETURN))\n                     i \\<bind>\n                    (\\<lambda>i.\n                        let i = i + 1\n                        in ASSERT (j < length \\<ff>s) \\<bind>\n                           (\\<lambda>_.\n                               let \\<ff>s = \\<ff>s[j := i]; j = j + 1\n                               in RETURN (\\<ff>s, i, j)))))\n            (\\<ff>s, i, j) \\<bind>\n           (\\<lambda>(\\<ff>s, uu_, uu_). RETURN \\<ff>s))\n    \\<in> (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "by sepref"], ["", "declare compute_butlast_\\<ff>s_impl.refine[sepref_fr_rules]"], ["", "sepref_register compute_\\<ff>s"], ["", "lemma kmp_inner_in_bound:\n  assumes \"i + length s \\<le> length t\"\n  assumes \"I_in_na s t i (j,None)\"\n  shows \"i + j < length t\" \"j < length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + j < length t &&& j < length s", "using assms"], ["proof (prove)\nusing this:\n  i + length s \\<le> length t\n  I_in_na s t i (j, None)\n\ngoal (1 subgoal):\n 1. i + j < length t &&& j < length s", "by (auto simp: I_in_na_def)"], ["", "sepref_definition kmp_impl is \"uncurry kmp3\" :: \"(arl_assn id_assn)\\<^sup>k *\\<^sub>a (arl_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry kmp3)\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "unfolding kmp3_def kmp2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>s t.\n          if s = [] then RETURN (Some 0)\n          else ASSERT (s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let i = 0; j = 0; pos = None\n                   in compute_butlast_\\<ff>s s \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT\n                                (i + length s \\<le> length t \\<and>\n                                 pos = None) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  t ! (i + j) = s ! j \\<and> pos = None)\n                                    (\\<lambda>(j, pos).\n  let j = j + 1\n  in if j = length s then RETURN (j, Some i) else RETURN (j, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          let i = i + (j - \\<ff>s ! j + 1); j = max 0 (\\<ff>s ! j - 1)\n          in RETURN (i, j, None))\n else RETURN (i, j, Some i))))\n                           (i, j, pos) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y)))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "apply (simp only: max_0L) \\<comment> \\<open>Avoid the unneeded @{const max}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>s t.\n          if s = [] then RETURN (Some 0)\n          else ASSERT (s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let i = 0; j = 0; pos = None\n                   in compute_butlast_\\<ff>s s \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT\n                                (i + length s \\<le> length t \\<and>\n                                 pos = None) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  t ! (i + j) = s ! j \\<and> pos = None)\n                                    (\\<lambda>(j, pos).\n  let j = j + 1\n  in if j = length s then RETURN (j, Some i) else RETURN (j, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          let i = i + (j - \\<ff>s ! j + 1); j = \\<ff>s ! j - 1\n          in RETURN (i, j, None))\n else RETURN (i, j, Some i))))\n                           (i, j, pos) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y)))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "apply (rewrite in \"WHILEIT (I_in_na _ _ _) \\<hole>\" conj_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>s t.\n          if s = [] then RETURN (Some 0)\n          else ASSERT (s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let i = 0; j = 0; pos = None\n                   in compute_butlast_\\<ff>s s \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT\n                                (i + length s \\<le> length t \\<and>\n                                 pos = None) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  pos = None \\<and> t ! (i + j) = s ! j)\n                                    (\\<lambda>(j, pos).\n  let j = j + 1\n  in if j = length s then RETURN (j, Some i) else RETURN (j, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          let i = i + (j - \\<ff>s ! j + 1); j = \\<ff>s ! j - 1\n          in RETURN (i, j, None))\n else RETURN (i, j, Some i))))\n                           (i, j, pos) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y)))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "apply (rewrite in \"WHILEIT (I_in_na _ _ _) \\<hole>\" short_circuit_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>s t.\n          if s = [] then RETURN (Some 0)\n          else ASSERT (s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let i = 0; j = 0; pos = None\n                   in compute_butlast_\\<ff>s s \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT\n                                (i + length s \\<le> length t \\<and>\n                                 pos = None) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  if pos = None then t ! (i + j) = s ! j else False)\n                                    (\\<lambda>(j, pos).\n  let j = j + 1\n  in if j = length s then RETURN (j, Some i) else RETURN (j, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          let i = i + (j - \\<ff>s ! j + 1); j = \\<ff>s ! j - 1\n          in RETURN (i, j, None))\n else RETURN (i, j, Some i))))\n                           (i, j, pos) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y)))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "supply kmp_inner_in_bound[dest]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>s t.\n          if s = [] then RETURN (Some 0)\n          else ASSERT (s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let i = 0; j = 0; pos = None\n                   in compute_butlast_\\<ff>s s \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT\n                                (i + length s \\<le> length t \\<and>\n                                 pos = None) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  if pos = None then t ! (i + j) = s ! j else False)\n                                    (\\<lambda>(j, pos).\n  let j = j + 1\n  in if j = length s then RETURN (j, Some i) else RETURN (j, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          let i = i + (j - \\<ff>s ! j + 1); j = \\<ff>s ! j - 1\n          in RETURN (i, j, None))\n else RETURN (i, j, Some i))))\n                           (i, j, pos) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y)))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "supply option.splits[split]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>s t.\n          if s = [] then RETURN (Some 0)\n          else ASSERT (s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let i = 0; j = 0; pos = None\n                   in compute_butlast_\\<ff>s s \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT\n                                (i + length s \\<le> length t \\<and>\n                                 pos = None) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  if pos = None then t ! (i + j) = s ! j else False)\n                                    (\\<lambda>(j, pos).\n  let j = j + 1\n  in if j = length s then RETURN (j, Some i) else RETURN (j, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          let i = i + (j - \\<ff>s ! j + 1); j = \\<ff>s ! j - 1\n          in RETURN (i, j, None))\n else RETURN (i, j, Some i))))\n                           (i, j, pos) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y)))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "supply eq_id_param[where 'a='a, sepref_import_param]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>s t.\n          if s = [] then RETURN (Some 0)\n          else ASSERT (s \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   let i = 0; j = 0; pos = None\n                   in compute_butlast_\\<ff>s s \\<bind>\n                      (\\<lambda>\\<ff>s.\n                          WHILE\\<^sub>T\\<^bsup>I_outer s t\\<^esup>\n                           (\\<lambda>(i, j, pos).\n                               i + length s \\<le> length t \\<and>\n                               pos = None)\n                           (\\<lambda>(i, j, pos).\n                               ASSERT\n                                (i + length s \\<le> length t \\<and>\n                                 pos = None) \\<bind>\n                               (\\<lambda>_.\n                                   WHILE\\<^sub>T\\<^bsup>I_in_na s t\n                   i\\<^esup>\n                                    (\\<lambda>(j, pos).\n  if pos = None then t ! (i + j) = s ! j else False)\n                                    (\\<lambda>(j, pos).\n  let j = j + 1\n  in if j = length s then RETURN (j, Some i) else RETURN (j, None))\n                                    (j, pos) \\<bind>\n                                   (\\<lambda>(j, pos).\n if pos = None\n then ASSERT (j < length \\<ff>s) \\<bind>\n      (\\<lambda>_.\n          let i = i + (j - \\<ff>s ! j + 1); j = \\<ff>s ! j - 1\n          in RETURN (i, j, None))\n else RETURN (i, j, Some i))))\n                           (i, j, pos) \\<bind>\n                          (\\<lambda>(_, uu_, y). RETURN y)))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          (arl_assn\n            id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a option_assn nat_assn", "by sepref"], ["", "export_code kmp_impl in SML_imp module_name KMP"], ["", "lemma kmp3_correct':\n  \"(uncurry kmp3, uncurry kmp_SPEC) \\<in> Id \\<times>\\<^sub>r Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry kmp3, uncurry kmp_SPEC)\n    \\<in> Id \\<times>\\<^sub>r\n          Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. kmp3 a b \\<le> kmp_SPEC a b", "apply (fact kmp3_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas kmp_impl_correct' = kmp_impl.refine[FCOMP kmp3_correct']"], ["", "subsection \\<open>Overall Correctness Theorem\\<close>"], ["", "text \\<open>The following theorem relates the final Imperative HOL algorithm to its specification,\n  using, beyond basic HOL concepts\n    \\<^item> Hoare triples for Imperative/HOL, provided by the Separation Logic Framework for Imperative/HOL (Theory @{theory Separation_Logic_Imperative_HOL.Sep_Main});\n    \\<^item> The assertion @{const arl_assn} to specify array-lists, which we use to represent the input strings of the algorithm;\n    \\<^item> The @{const sublist_at} function that we defined in section \\ref{sec:spec}.\n  \\<close>"], ["", "theorem kmp_impl_correct:\n  \"< arl_assn id_assn s si * arl_assn id_assn t ti > \n       kmp_impl si ti \n   <\\<lambda>r. arl_assn id_assn s si * arl_assn id_assn t ti * \\<up>(\n      case r of None \\<Rightarrow>  \\<nexists>i. sublist_at s t i\n              | Some i \\<Rightarrow> sublist_at s t i \\<and> (\\<forall>ii<i. \\<not> sublist_at s t ii)\n    )>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <arl_assn id_assn s si *\n     arl_assn id_assn t\n      ti> kmp_impl si\n           ti <\\<lambda>r.\n                  arl_assn id_assn s si * arl_assn id_assn t ti *\n                  \\<up>\n                   (case r of\n                    None \\<Rightarrow> \\<nexists>i. sublist_at s t i\n                    | Some i \\<Rightarrow>\n                        sublist_at s t i \\<and>\n                        (\\<forall>ii<i. \\<not> sublist_at s t ii))>\\<^sub>t", "by (sep_auto \n    simp: pure_def kmp_SPEC_def\n    split: option.split\n    heap:  kmp_impl_correct'[THEN hfrefD, THEN hn_refineD, of \"(s,t)\" \"(si,ti)\", simplified])"], ["", "definition \"kmp_string_impl \\<equiv> kmp_impl :: (char array \\<times> nat) \\<Rightarrow> _\""], ["", "section \\<open>Tests of Generated ML-Code\\<close>"], ["", "ML_val \\<open>\n  fun str2arl s = (Array.fromList (@{code String.explode} s), @{code nat_of_integer} (String.size s))\n  fun kmp s t = map_option @{code integer_of_nat} (@{code kmp_string_impl} (str2arl s) (str2arl t) ())\n  \n  val test1 = kmp \"anas\" \"bananas\"\n  val test2 = kmp \"\" \"bananas\"\n  val test3 = kmp \"hide_fact\" (File.read @{file \\<open>~~/src/HOL/Main.thy\\<close>})\n  val test4 = kmp \"sorry\" (File.read @{file \\<open>~~/src/HOL/HOL.thy\\<close>})  \n\\<close>"], ["", "end"]]}