{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/Syzygy.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma rep_monomial [simp]: \"rep (monomial c x) = c *s x\"", "lemma rep_zero [simp]: \"rep 0 = 0\"", "lemma rep_uminus [simp]: \"rep (- r) = - rep r\"", "lemma rep_plus: \"rep (r + s) = rep r + rep s\"", "lemma rep_minus: \"rep (r - s) = rep r - rep s\"", "lemma rep_smult: \"rep (monomial c 0 * r) = c *s rep r\"", "lemma rep_in_span: \"rep r \\<in> span (keys r)\"", "lemma spanE_rep:\n  assumes \"x \\<in> span B\"\n  obtains r where \"keys r \\<subseteq> B\" and \"x = rep r\"", "lemma representsI:\n  assumes \"keys r \\<subseteq> B\" and \"rep r = x\"\n  shows \"represents B r x\"", "lemma representsD1:\n  assumes \"represents B r x\"\n  shows \"keys r \\<subseteq> B\"", "lemma representsD2:\n  assumes \"represents B r x\"\n  shows \"x = rep r\"", "lemma represents_mono:\n  assumes \"represents B r x\" and \"B \\<subseteq> A\"\n  shows \"represents A r x\"", "lemma represents_self: \"represents {x} (monomial 1 x) x\"", "lemma represents_zero: \"represents B 0 0\"", "lemma represents_plus:\n  assumes \"represents A r x\" and \"represents B s y\"\n  shows \"represents (A \\<union> B) (r + s) (x + y)\"", "lemma represents_uminus:\n  assumes \"represents B r x\"\n  shows \"represents B (- r) (- x)\"", "lemma represents_minus:\n  assumes \"represents A r x\" and \"represents B s y\"\n  shows \"represents (A \\<union> B) (r - s) (x - y)\"", "lemma represents_scale:\n  assumes \"represents B r x\"\n  shows \"represents B (monomial c 0 * r) (c *s x)\"", "lemma represents_in_span:\n  assumes \"represents B r x\"\n  shows \"x \\<in> span B\"", "lemma syzygy_module_iff: \"s \\<in> syzygy_module B \\<longleftrightarrow> represents B s 0\"", "lemma syzygy_moduleI:\n  assumes \"represents B s 0\"\n  shows \"s \\<in> syzygy_module B\"", "lemma syzygy_moduleD:\n  assumes \"s \\<in> syzygy_module B\"\n  shows \"represents B s 0\"", "lemma zero_in_syzygy_module: \"0 \\<in> syzygy_module B\"", "lemma syzygy_module_closed_plus:\n  assumes \"s1 \\<in> syzygy_module B\" and \"s2 \\<in> syzygy_module B\"\n  shows \"s1 + s2 \\<in> syzygy_module B\"", "lemma syzygy_module_closed_minus:\n  assumes \"s1 \\<in> syzygy_module B\" and \"s2 \\<in> syzygy_module B\"\n  shows \"s1 - s2 \\<in> syzygy_module B\"", "lemma syzygy_module_closed_times_monomial:\n  assumes \"s \\<in> syzygy_module B\"\n  shows \"monomial c 0 * s \\<in> syzygy_module B\"", "lemma keys_rep_subset:\n  assumes \"u \\<in> keys (pmdl.rep r)\"\n  obtains t v where \"t \\<in> Keys (Poly_Mapping.range r)\" and \"v \\<in> Keys (keys r)\" and \"u = t \\<oplus> v\"", "lemma rep_mult_scalar: \"pmdl.rep (punit.monom_mult c 0 r) = c \\<odot> pmdl.rep r\"", "lemma represents_mult_scalar:\n  assumes \"pmdl.represents B r x\"\n  shows \"pmdl.represents B (punit.monom_mult c 0 r) (c \\<odot> x)\"", "lemma syzygy_module_closed_map_scale: \"s \\<in> pmdl.syzygy_module B \\<Longrightarrow> c \\<cdot> s \\<in> pmdl.syzygy_module B\"", "lemma phull_syzygy_module: \"phull (pmdl.syzygy_module B) = pmdl.syzygy_module B\"", "lemma lookup_pm_of_idx_pm:\n  \"lookup (pm_of_idx_pm xs f) = (\\<lambda>x. lookup f (Min {i. i < length xs \\<and> xs ! i = x}) when x \\<in> set xs)\"", "lemma lookup_pm_of_idx_pm_distinct:\n  assumes \"distinct xs\" and \"i < length xs\"\n  shows \"lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i\"", "lemma keys_pm_of_idx_pm_subset: \"keys (pm_of_idx_pm xs f) \\<subseteq> set xs\"", "lemma range_pm_of_idx_pm_subset: \"Poly_Mapping.range (pm_of_idx_pm xs f) \\<subseteq> lookup f ` {0..<length xs} - {0}\"", "lemma pm_of_idx_pm_zero [simp]: \"pm_of_idx_pm xs 0 = 0\"", "lemma pm_of_idx_pm_plus: \"pm_of_idx_pm xs (f + g) = pm_of_idx_pm xs f + pm_of_idx_pm xs g\"", "lemma pm_of_idx_pm_uminus: \"pm_of_idx_pm xs (- f) = - pm_of_idx_pm xs f\"", "lemma pm_of_idx_pm_minus: \"pm_of_idx_pm xs (f - g) = pm_of_idx_pm xs f - pm_of_idx_pm xs g\"", "lemma pm_of_idx_pm_monom_mult: \"pm_of_idx_pm xs (punit.monom_mult c 0 f) = punit.monom_mult c 0 (pm_of_idx_pm xs f)\"", "lemma pm_of_idx_pm_monomial:\n  assumes \"distinct xs\"\n  shows \"pm_of_idx_pm xs (monomial c i) = (monomial c (xs ! i) when i < length xs)\"", "lemma pm_of_idx_pm_take:\n  assumes \"keys f \\<subseteq> {0..<j}\"\n  shows \"pm_of_idx_pm (take j xs) f = pm_of_idx_pm xs f\"", "lemma lookup_idx_pm_of_pm: \"lookup (idx_pm_of_pm xs f) = (\\<lambda>i. lookup f (xs ! i) when i < length xs)\"", "lemma keys_idx_pm_of_pm_subset: \"keys (idx_pm_of_pm xs f) \\<subseteq> {0..<length xs}\"", "lemma idx_pm_of_pm_zero [simp]: \"idx_pm_of_pm xs 0 = 0\"", "lemma idx_pm_of_pm_plus: \"idx_pm_of_pm xs (f + g) = idx_pm_of_pm xs f + idx_pm_of_pm xs g\"", "lemma idx_pm_of_pm_minus: \"idx_pm_of_pm xs (f - g) = idx_pm_of_pm xs f - idx_pm_of_pm xs g\"", "lemma pm_of_idx_pm_of_pm:\n  assumes \"keys f \\<subseteq> set xs\"\n  shows \"pm_of_idx_pm xs (idx_pm_of_pm xs f) = f\"", "lemma idx_pm_of_pm_of_idx_pm:\n  assumes \"distinct xs\" and \"keys f \\<subseteq> {0..<length xs}\"\n  shows \"idx_pm_of_pm xs (pm_of_idx_pm xs f) = f\"", "lemma is_pot_ordI:\n  assumes \"\\<And>u v. component_of_term u < component_of_term v \\<Longrightarrow> u \\<prec>\\<^sub>t v\"\n  shows \"is_pot_ord\"", "lemma is_pot_ordD:\n  assumes \"is_pot_ord\" and \"component_of_term u < component_of_term v\"\n  shows \"u \\<prec>\\<^sub>t v\"", "lemma is_pot_ordD2:\n  assumes \"is_pot_ord\" and \"u \\<preceq>\\<^sub>t v\"\n  shows \"component_of_term u \\<le> component_of_term v\"", "lemma is_pot_ord:\n  assumes \"is_pot_ord\"\n  shows \"u \\<preceq>\\<^sub>t v \\<longleftrightarrow> (component_of_term u < component_of_term v \\<or>\n                    (component_of_term u = component_of_term v \\<and> pp_of_term u \\<preceq> pp_of_term v))\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma pair_of_map_component [term_simps]:\n  \"pair_of_term (map_component f v) = (pp_of_term v, f (component_of_term v))\"", "lemma pp_of_map_component [term_simps]: \"pp_of_term (map_component f v) = pp_of_term v\"", "lemma component_of_map_component [term_simps]:\n  \"component_of_term (map_component f v) = f (component_of_term v)\"", "lemma map_component_term_of_pair [term_simps]:\n  \"map_component f (term_of_pair (t, k)) = term_of_pair (t, f k)\"", "lemma map_component_comp: \"map_component f (map_component g x) = map_component (\\<lambda>k. f (g k)) x\"", "lemma map_component_id [term_simps]: \"map_component (\\<lambda>k. k) x = x\"", "lemma map_component_inj:\n  assumes \"inj f\" and \"map_component f u = map_component f v\"\n  shows \"u = v\"", "lemma keys_lift_poly_syz_aux:\n  \"{x. (if pair_of_term x = (0, i) then 1\n        else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x)\n        else 0) \\<noteq> 0} \\<subseteq> insert (term_of_pair (0, i)) (map_component (\\<lambda>k. k + n) ` keys b)\"\n  (is \"?l \\<subseteq> ?r\") for b::\"'t \\<Rightarrow>\\<^sub>0 'b::semiring_1\"", "lemma lookup_lift_poly_syz:\n  \"lookup (lift_poly_syz n b i) =\n    (\\<lambda>x. if pair_of_term x = (0, i) then 1 else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x) else 0)\"", "lemma keys_lift_poly_syz:\n  \"keys (lift_poly_syz n b i) = insert (term_of_pair (0, i)) (map_component (\\<lambda>k. k + n) ` keys b)\"", "lemma inj_map_component_plus: \"inj (map_component (\\<lambda>k. k + n))\"", "lemma lookup_proj_poly_syz: \"lookup (proj_poly_syz n p) x = lookup p (map_component (\\<lambda>k. k + n) x)\"", "lemma lookup_proj_poly_syz_alt:\n  \"lookup (proj_poly_syz n p) (term_of_pair (t, i)) = lookup p (term_of_pair (t, i + n))\"", "lemma keys_proj_poly_syz: \"keys (proj_poly_syz n p) = map_component (\\<lambda>k. k + n) -` keys p\"", "lemma proj_poly_syz_zero [simp]: \"proj_poly_syz n 0 = 0\"", "lemma proj_poly_syz_plus: \"proj_poly_syz n (p + q) = proj_poly_syz n p + proj_poly_syz n q\"", "lemma proj_poly_syz_sum: \"proj_poly_syz n (sum f A) = (\\<Sum>a\\<in>A. proj_poly_syz n (f a))\"", "lemma proj_poly_syz_sum_list: \"proj_poly_syz n (sum_list xs) = sum_list (map (proj_poly_syz n) xs)\"", "lemma proj_poly_syz_monom_mult:\n  \"proj_poly_syz n (monom_mult c t p) = monom_mult c t (proj_poly_syz n p)\"", "lemma proj_poly_syz_mult_scalar:\n  \"proj_poly_syz n (mult_scalar q p) = mult_scalar q (proj_poly_syz n p)\"", "lemma proj_poly_syz_lift_poly_syz:\n  assumes \"i < n\"\n  shows \"proj_poly_syz n (lift_poly_syz n p i) = p\"", "lemma proj_poly_syz_eq_zero_iff: \"proj_poly_syz n p = 0 \\<longleftrightarrow> (component_of_term ` keys p \\<subseteq> {0..<n})\"", "lemma component_of_lt_ge:\n  assumes \"is_pot_ord\" and \"proj_poly_syz n p \\<noteq> 0\"\n  shows \"n \\<le> component_of_term (lt p)\"", "lemma lt_proj_poly_syz:\n  assumes \"is_pot_ord\" and \"proj_poly_syz n p \\<noteq> 0\"\n  shows \"lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)\" (is \"_ = ?l\")", "lemma proj_proj_poly_syz: \"proj_poly k (proj_poly_syz n p) = proj_poly (k + n) p\"", "lemma poly_mapping_eqI_proj_syz:\n  assumes \"proj_poly_syz n p = proj_poly_syz n q\"\n    and \"\\<And>k. k < n \\<Longrightarrow> proj_poly k p = proj_poly k q\"\n  shows \"p = q\"", "lemma length_cofactor_list_syz [simp]: \"length (cofactor_list_syz n p) = n\"", "lemma cofactor_list_syz_nth:\n  assumes \"i < n\"\n  shows \"(cofactor_list_syz n p) ! i = proj_poly i p\"", "lemma cofactor_list_syz_zero [simp]: \"cofactor_list_syz n 0 = replicate n 0\"", "lemma cofactor_list_syz_plus:\n  \"cofactor_list_syz n (p + q) = map2 (+) (cofactor_list_syz n p) (cofactor_list_syz n q)\"", "lemma length_init_syzygy_list [simp]: \"length (init_syzygy_list bs) = length bs\"", "lemma init_syzygy_list_nth:\n  assumes \"i < length bs\"\n  shows \"(init_syzygy_list bs) ! i = lift_poly_syz (length bs) (bs ! i) i\"", "lemma Keys_init_syzygy_list:\n  \"Keys (set (init_syzygy_list bs)) =\n      map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union> (\\<lambda>i. term_of_pair (0, i)) ` {0..<length bs}\"", "lemma pp_of_Keys_init_syzygy_list_subset:\n  \"pp_of_term ` Keys (set (init_syzygy_list bs)) \\<subseteq> insert 0 (pp_of_term ` Keys (set bs))\"", "lemma pp_of_Keys_init_syzygy_list_superset:\n  \"pp_of_term ` Keys (set bs) \\<subseteq> pp_of_term ` Keys (set (init_syzygy_list bs))\"", "lemma pp_of_Keys_init_syzygy_list:\n  assumes \"bs \\<noteq> []\"\n  shows \"pp_of_term ` Keys (set (init_syzygy_list bs)) = insert 0 (pp_of_term ` Keys (set bs))\"", "lemma component_of_Keys_init_syzygy_list:\n  \"component_of_term ` Keys (set (init_syzygy_list bs)) =\n            (+) (length bs) ` component_of_term ` Keys (set bs) \\<union> {0..<length bs}\"", "lemma proj_lift_poly_syz:\n  assumes \"j < n\"\n  shows \"proj_poly j (lift_poly_syz n p i) = (1 when j = i)\"", "lemma length_proj_orig_basis [simp]: \"length (proj_orig_basis n bs) = length bs\"", "lemma proj_orig_basis_nth:\n  assumes \"i < length bs\"\n  shows \"(proj_orig_basis n bs) ! i = proj_poly_syz n (bs ! i)\"", "lemma proj_orig_basis_init_syzygy_list [simp]:\n  \"proj_orig_basis (length bs) (init_syzygy_list bs) = bs\"", "lemma set_proj_orig_basis: \"set (proj_orig_basis n bs) = proj_poly_syz n ` set bs\"", "lemma pmdl_proj_orig_basis':\n  \"pmdl (set (proj_orig_basis n bs)) = proj_poly_syz n ` pmdl (set bs)\" (is \"?A = ?B\")", "lemma filter_syzygy_basis_alt: \"filter_syzygy_basis n bs = [b\\<leftarrow>bs. proj_poly_syz n b = 0]\"", "lemma set_filter_syzygy_basis:\n  \"set (filter_syzygy_basis n bs) = {b\\<in>set bs. proj_poly_syz n b = 0}\"", "lemma syzygy_module_listI:\n  assumes \"s' \\<in> pmdl.syzygy_module (set bs)\" and \"s = atomize_poly (idx_pm_of_pm bs s')\"\n  shows \"s \\<in> syzygy_module_list bs\"", "lemma syzygy_module_listE:\n  assumes \"s \\<in> syzygy_module_list bs\"\n  obtains s' where \"s' \\<in> pmdl.syzygy_module (set bs)\" and \"s = atomize_poly (idx_pm_of_pm bs s')\"", "lemma monom_mult_atomize:\n  \"monom_mult c t (atomize_poly p) = atomize_poly (MPoly_Type_Class.punit.monom_mult (monomial c t) 0 p)\"", "lemma punit_monom_mult_monomial_idx_pm_of_pm:\n  \"MPoly_Type_Class.punit.monom_mult (monomial c t) (0::nat) (idx_pm_of_pm bs s) =\n    idx_pm_of_pm bs (MPoly_Type_Class.punit.monom_mult (monomial c t) (0::'t \\<Rightarrow>\\<^sub>0 'b::ring_1) s)\"", "lemma syzygy_module_list_closed_monom_mult:\n  assumes \"s \\<in> syzygy_module_list bs\"\n  shows \"monom_mult c t s \\<in> syzygy_module_list bs\"", "lemma pmdl_syzygy_module_list [simp]: \"pmdl (syzygy_module_list bs) = syzygy_module_list bs\"", "lemma syzygy_module_listI':\n  assumes \"distinct bs\" and \"sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s) bs) = 0\"\n    and \"component_of_term ` keys s \\<subseteq> {0..<length bs}\"\n  shows \"s \\<in> syzygy_module_list bs\"", "lemma component_of_syzygy_module_list:\n  assumes \"s \\<in> syzygy_module_list bs\"\n  shows \"component_of_term ` keys s \\<subseteq> {0..<length bs}\"", "lemma map2_mult_scalar_proj_poly_syz:\n  \"map2 mult_scalar xs (map (proj_poly_syz n) ys) =\n    map (proj_poly_syz n \\<circ> (\\<lambda>(x, y). mult_scalar x y)) (zip xs ys)\"", "lemma map2_times_proj:\n  \"map2 (*) xs (map (proj_poly k) ys) = map (proj_poly k \\<circ> (\\<lambda>(x, y). x \\<odot> y)) (zip xs ys)\"", "lemma syzygy_module_list_subset:\n  assumes \"distinct bs\"\n  shows \"syzygy_module_list bs \\<subseteq> pmdl (set (init_syzygy_list bs))\"", "lemma map2_mult_scalar_plus:\n  \"map2 (\\<odot>) (map2 (+) xs ys) zs = map2 (+) (map2 (\\<odot>) xs zs) (map2 (\\<odot>) ys zs)\"", "lemma syz_cofactors:\n  assumes \"p \\<in> pmdl (set (init_syzygy_list bs))\"\n  shows \"proj_poly_syz (length bs) p = sum_list (map2 mult_scalar (cofactor_list_syz (length bs) p) bs)\"", "lemma pmdl_proj_orig_basis:\n  assumes \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"pmdl (set (proj_orig_basis (length bs) gs)) = pmdl (set bs)\"", "lemma pmdl_filter_syzygy_basis_subset:\n  assumes \"distinct bs\" and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"pmdl (set (filter_syzygy_basis (length bs) gs)) \\<subseteq> pmdl (syzygy_module_list bs)\"", "lemma ex_filter_syzygy_basis_adds_lt:\n  assumes \"is_pot_ord\" and \"distinct bs\" and \"is_Groebner_basis (set gs)\"\n    and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n    and \"f \\<in> pmdl (syzygy_module_list bs)\" and \"f \\<noteq> 0\"\n  shows \"\\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs). g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\"", "lemma pmdl_filter_syzygy_basis:\n  fixes bs::\"('t \\<Rightarrow>\\<^sub>0 'b::field) list\"\n  assumes \"is_pot_ord\" and \"distinct bs\" and \"is_Groebner_basis (set gs)\" and\n    \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs\"", "lemma proj_orig_basis_isGB:\n  assumes \"is_pot_ord\" and \"is_Groebner_basis (set gs)\" and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"is_Groebner_basis (set (proj_orig_basis (length bs) gs))\"", "lemma filter_syzygy_basis_isGB:\n  assumes \"is_pot_ord\" and \"distinct bs\" and \"is_Groebner_basis (set gs)\"\n    and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"is_Groebner_basis (set (filter_syzygy_basis (length bs) gs))\""], "translations": [["", "lemma rep_monomial [simp]: \"rep (monomial c x) = c *s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (monomial c x) = c *s x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rep (monomial c x) = c *s x", "have sub: \"keys (monomial c x) \\<subseteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial c x) \\<subseteq> {x}", "by simp"], ["proof (state)\nthis:\n  keys (monomial c x) \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. rep (monomial c x) = c *s x", "have \"rep (monomial c x) = (\\<Sum>v\\<in>{x}. lookup (monomial c x) v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (monomial c x) = (\\<Sum>v\\<in>{x}. lookup (monomial c x) v *s v)", "unfolding rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys (monomial c x). lookup (monomial c x) v *s v) =\n    (\\<Sum>v\\<in>{x}. lookup (monomial c x) v *s v)", "by (rule sum.mono_neutral_left, simp, fact sub, simp)"], ["proof (state)\nthis:\n  rep (monomial c x) = (\\<Sum>v\\<in>{x}. lookup (monomial c x) v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c x) = c *s x", "also"], ["proof (state)\nthis:\n  rep (monomial c x) = (\\<Sum>v\\<in>{x}. lookup (monomial c x) v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c x) = c *s x", "have \"... = c *s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>{x}. lookup (monomial c x) v *s v) = c *s x", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>{x}. lookup (monomial c x) v *s v) = c *s x\n\ngoal (1 subgoal):\n 1. rep (monomial c x) = c *s x", "finally"], ["proof (chain)\npicking this:\n  rep (monomial c x) = c *s x", "show ?thesis"], ["proof (prove)\nusing this:\n  rep (monomial c x) = c *s x\n\ngoal (1 subgoal):\n 1. rep (monomial c x) = c *s x", "."], ["proof (state)\nthis:\n  rep (monomial c x) = c *s x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_zero [simp]: \"rep 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep 0 = (0::'b)", "by (simp add: rep_def)"], ["", "lemma rep_uminus [simp]: \"rep (- r) = - rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (- r) = - rep r", "by (simp add: keys_uminus sum_negf rep_def)"], ["", "lemma rep_plus: \"rep (r + s) = rep r + rep s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "from finite_keys finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)\n  finite (keys ?f)", "have fin: \"finite (keys r \\<union> keys s)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. finite (keys r \\<union> keys s)", "by (rule finite_UnI)"], ["proof (state)\nthis:\n  finite (keys r \\<union> keys s)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "from fin"], ["proof (chain)\npicking this:\n  finite (keys r \\<union> keys s)", "have eq1: \"(\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) = (\\<Sum>v\\<in>keys r. lookup r v *s v)\""], ["proof (prove)\nusing this:\n  finite (keys r \\<union> keys s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) =\n    (\\<Sum>v\\<in>keys r. lookup r v *s v)", "proof (rule sum.mono_neutral_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys r \\<subseteq> keys r \\<union> keys s\n 2. \\<forall>i\\<in>keys r \\<union> keys s - keys r.\n       lookup r i *s i = (0::'b)", "show \"\\<forall>v\\<in>keys r \\<union> keys s - keys r. lookup r v *s v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>keys r \\<union> keys s - keys r.\n       lookup r v *s v = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>keys r \\<union> keys s - keys r. lookup r v *s v = (0::'b)\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> keys r \\<union> keys s", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) =\n  (\\<Sum>v\\<in>keys r. lookup r v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "from fin"], ["proof (chain)\npicking this:\n  finite (keys r \\<union> keys s)", "have eq2: \"(\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) = (\\<Sum>v\\<in>keys s. lookup s v *s v)\""], ["proof (prove)\nusing this:\n  finite (keys r \\<union> keys s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n    (\\<Sum>v\\<in>keys s. lookup s v *s v)", "proof (rule sum.mono_neutral_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys s \\<subseteq> keys r \\<union> keys s\n 2. \\<forall>i\\<in>keys r \\<union> keys s - keys s.\n       lookup s i *s i = (0::'b)", "show \"\\<forall>v\\<in>keys r \\<union> keys s - keys s. lookup s v *s v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>keys r \\<union> keys s - keys s.\n       lookup s v *s v = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>keys r \\<union> keys s - keys s. lookup s v *s v = (0::'b)\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> keys r \\<union> keys s", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n  (\\<Sum>v\\<in>keys s. lookup s v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "have \"rep (r + s) = (\\<Sum>v\\<in>keys (r + s). lookup (r + s) v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (r + s) = (\\<Sum>v\\<in>keys (r + s). lookup (r + s) v *s v)", "by (simp only: rep_def)"], ["proof (state)\nthis:\n  rep (r + s) = (\\<Sum>v\\<in>keys (r + s). lookup (r + s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "also"], ["proof (state)\nthis:\n  rep (r + s) = (\\<Sum>v\\<in>keys (r + s). lookup (r + s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "have \"... = (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r + s) v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys (r + s). lookup (r + s) v *s v) =\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r + s) v *s v)", "proof (rule sum.mono_neutral_left)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (keys r \\<union> keys s)\n 2. keys (r + s) \\<subseteq> keys r \\<union> keys s\n 3. \\<forall>i\\<in>keys r \\<union> keys s - keys (r + s).\n       lookup (r + s) i *s i = (0::'b)", "show \"\\<forall>i\\<in>keys r \\<union> keys s - keys (r + s). lookup (r + s) i *s i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>keys r \\<union> keys s - keys (r + s).\n       lookup (r + s) i *s i = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>keys r \\<union> keys s - keys (r + s).\n     lookup (r + s) i *s i = (0::'b)\n\ngoal (2 subgoals):\n 1. finite (keys r \\<union> keys s)\n 2. keys (r + s) \\<subseteq> keys r \\<union> keys s", "qed (auto simp: Poly_Mapping.keys_add)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (r + s). lookup (r + s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r + s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (r + s). lookup (r + s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r + s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "have \"... = (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) + (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r + s) v *s v) =\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) +\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)", "by (simp add: lookup_add scale_left_distrib sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r + s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) +\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r + s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) +\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "have \"... = rep r + rep s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) +\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n    rep r + rep s", "by (simp only: eq1 eq2 rep_def)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) +\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n  rep r + rep s\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "finally"], ["proof (chain)\npicking this:\n  rep (r + s) = rep r + rep s", "show ?thesis"], ["proof (prove)\nusing this:\n  rep (r + s) = rep r + rep s\n\ngoal (1 subgoal):\n 1. rep (r + s) = rep r + rep s", "."], ["proof (state)\nthis:\n  rep (r + s) = rep r + rep s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_minus: \"rep (r - s) = rep r - rep s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "from finite_keys finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)\n  finite (keys ?f)", "have fin: \"finite (keys r \\<union> keys s)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. finite (keys r \\<union> keys s)", "by (rule finite_UnI)"], ["proof (state)\nthis:\n  finite (keys r \\<union> keys s)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "from fin"], ["proof (chain)\npicking this:\n  finite (keys r \\<union> keys s)", "have eq1: \"(\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) = (\\<Sum>v\\<in>keys r. lookup r v *s v)\""], ["proof (prove)\nusing this:\n  finite (keys r \\<union> keys s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) =\n    (\\<Sum>v\\<in>keys r. lookup r v *s v)", "proof (rule sum.mono_neutral_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys r \\<subseteq> keys r \\<union> keys s\n 2. \\<forall>i\\<in>keys r \\<union> keys s - keys r.\n       lookup r i *s i = (0::'b)", "show \"\\<forall>v\\<in>keys r \\<union> keys s - keys r. lookup r v *s v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>keys r \\<union> keys s - keys r.\n       lookup r v *s v = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>keys r \\<union> keys s - keys r. lookup r v *s v = (0::'b)\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> keys r \\<union> keys s", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) =\n  (\\<Sum>v\\<in>keys r. lookup r v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "from fin"], ["proof (chain)\npicking this:\n  finite (keys r \\<union> keys s)", "have eq2: \"(\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) = (\\<Sum>v\\<in>keys s. lookup s v *s v)\""], ["proof (prove)\nusing this:\n  finite (keys r \\<union> keys s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n    (\\<Sum>v\\<in>keys s. lookup s v *s v)", "proof (rule sum.mono_neutral_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys s \\<subseteq> keys r \\<union> keys s\n 2. \\<forall>i\\<in>keys r \\<union> keys s - keys s.\n       lookup s i *s i = (0::'b)", "show \"\\<forall>v\\<in>keys r \\<union> keys s - keys s. lookup s v *s v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>keys r \\<union> keys s - keys s.\n       lookup s v *s v = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>keys r \\<union> keys s - keys s. lookup s v *s v = (0::'b)\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> keys r \\<union> keys s", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n  (\\<Sum>v\\<in>keys s. lookup s v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "have \"rep (r - s) = (\\<Sum>v\\<in>keys (r - s). lookup (r - s) v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (r - s) = (\\<Sum>v\\<in>keys (r - s). lookup (r - s) v *s v)", "by (simp only: rep_def)"], ["proof (state)\nthis:\n  rep (r - s) = (\\<Sum>v\\<in>keys (r - s). lookup (r - s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "also"], ["proof (state)\nthis:\n  rep (r - s) = (\\<Sum>v\\<in>keys (r - s). lookup (r - s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "from fin keys_minus"], ["proof (chain)\npicking this:\n  finite (keys r \\<union> keys s)\n  keys (?p - ?q) \\<subseteq> keys ?p \\<union> keys ?q", "have \"... = (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r - s) v *s v)\""], ["proof (prove)\nusing this:\n  finite (keys r \\<union> keys s)\n  keys (?p - ?q) \\<subseteq> keys ?p \\<union> keys ?q\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys (r - s). lookup (r - s) v *s v) =\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r - s) v *s v)", "proof (rule sum.mono_neutral_left)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>keys r \\<union> keys s - keys (r - s).\n       lookup (r - s) i *s i = (0::'b)", "show \"\\<forall>i\\<in>keys r \\<union> keys s - keys (r - s). lookup (r - s) i *s i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>keys r \\<union> keys s - keys (r - s).\n       lookup (r - s) i *s i = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>keys r \\<union> keys s - keys (r - s).\n     lookup (r - s) i *s i = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (r - s). lookup (r - s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r - s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (r - s). lookup (r - s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r - s) v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "have \"... = (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) - (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r - s) v *s v) =\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) -\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)", "by (simp add: lookup_minus scale_left_diff_distrib sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r - s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) -\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup (r - s) v *s v) =\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) -\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v)\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "have \"... = rep r - rep s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) -\n    (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n    rep r - rep s", "by (simp only: eq1 eq2 rep_def)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup r v *s v) -\n  (\\<Sum>v\\<in>keys r \\<union> keys s. lookup s v *s v) =\n  rep r - rep s\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "finally"], ["proof (chain)\npicking this:\n  rep (r - s) = rep r - rep s", "show ?thesis"], ["proof (prove)\nusing this:\n  rep (r - s) = rep r - rep s\n\ngoal (1 subgoal):\n 1. rep (r - s) = rep r - rep s", "."], ["proof (state)\nthis:\n  rep (r - s) = rep r - rep s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_smult: \"rep (monomial c 0 * r) = c *s rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "have l: \"lookup (monomial c 0 * r) v = c * (lookup r v)\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial c (0::'b) * r) v = c * lookup r v", "unfolding mult_map_scale_conv_mult[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map ((*) c) r) v = c * lookup r v", "by (rule map_lookup, simp)"], ["proof (state)\nthis:\n  lookup (monomial c (0::'b) * r) ?v = c * lookup r ?v\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "have sub: \"keys (monomial c 0 * r) \\<subseteq> keys r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial c (0::'b) * r) \\<subseteq> keys r", "by (metis l lookup_not_eq_zero_eq_in_keys mult_zero_right subsetI)"], ["proof (state)\nthis:\n  keys (monomial c (0::'b) * r) \\<subseteq> keys r\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "have \"rep (monomial c 0 * r) = (\\<Sum>v\\<in>keys (monomial c 0 * r). lookup (monomial c 0 * r) v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) =\n    (\\<Sum>v\\<in>keys (monomial c (0::'b) * r).\n       lookup (monomial c (0::'b) * r) v *s v)", "by (simp only: rep_def)"], ["proof (state)\nthis:\n  rep (monomial c (0::'b) * r) =\n  (\\<Sum>v\\<in>keys (monomial c (0::'b) * r).\n     lookup (monomial c (0::'b) * r) v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "also"], ["proof (state)\nthis:\n  rep (monomial c (0::'b) * r) =\n  (\\<Sum>v\\<in>keys (monomial c (0::'b) * r).\n     lookup (monomial c (0::'b) * r) v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "from finite_keys sub"], ["proof (chain)\npicking this:\n  finite (keys ?f)\n  keys (monomial c (0::'b) * r) \\<subseteq> keys r", "have \"... = (\\<Sum>v\\<in>keys r. lookup (monomial c 0 * r) v *s v)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n  keys (monomial c (0::'b) * r) \\<subseteq> keys r\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys (monomial c (0::'b) * r).\n       lookup (monomial c (0::'b) * r) v *s v) =\n    (\\<Sum>v\\<in>keys r. lookup (monomial c (0::'b) * r) v *s v)", "proof (rule sum.mono_neutral_left)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>keys r - keys (monomial c (0::'b) * r).\n       lookup (monomial c (0::'b) * r) i *s i = (0::'b)", "show \"\\<forall>v\\<in>keys r - keys (monomial c 0 * r). lookup (monomial c 0 * r) v *s v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>keys r - keys (monomial c (0::'b) * r).\n       lookup (monomial c (0::'b) * r) v *s v = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>keys r - keys (monomial c (0::'b) * r).\n     lookup (monomial c (0::'b) * r) v *s v = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (monomial c (0::'b) * r).\n     lookup (monomial c (0::'b) * r) v *s v) =\n  (\\<Sum>v\\<in>keys r. lookup (monomial c (0::'b) * r) v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (monomial c (0::'b) * r).\n     lookup (monomial c (0::'b) * r) v *s v) =\n  (\\<Sum>v\\<in>keys r. lookup (monomial c (0::'b) * r) v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "have \"... = c *s (\\<Sum>v\\<in>keys r. lookup r v *s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r. lookup (monomial c (0::'b) * r) v *s v) =\n    c *s (\\<Sum>v\\<in>keys r. lookup r v *s v)", "by (simp add: l scale_sum_right)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r. lookup (monomial c (0::'b) * r) v *s v) =\n  c *s (\\<Sum>v\\<in>keys r. lookup r v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys r. lookup (monomial c (0::'b) * r) v *s v) =\n  c *s (\\<Sum>v\\<in>keys r. lookup r v *s v)\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "have \"... = c *s rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *s (\\<Sum>v\\<in>keys r. lookup r v *s v) = c *s rep r", "by (simp add: rep_def)"], ["proof (state)\nthis:\n  c *s (\\<Sum>v\\<in>keys r. lookup r v *s v) = c *s rep r\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "finally"], ["proof (chain)\npicking this:\n  rep (monomial c (0::'b) * r) = c *s rep r", "show ?thesis"], ["proof (prove)\nusing this:\n  rep (monomial c (0::'b) * r) = c *s rep r\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s rep r", "."], ["proof (state)\nthis:\n  rep (monomial c (0::'b) * r) = c *s rep r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_in_span: \"rep r \\<in> span (keys r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep r \\<in> local.span (keys r)", "unfolding rep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys r. lookup r v *s v) \\<in> local.span (keys r)", "by (fact sum_in_spanI)"], ["", "lemma spanE_rep:\n  assumes \"x \\<in> span B\"\n  obtains r where \"keys r \\<subseteq> B\" and \"x = rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>keys r \\<subseteq> B; x = rep r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>keys r \\<subseteq> B; x = rep r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> local.span B", "obtain A q where \"finite A\" and \"A \\<subseteq> B\" and x: \"x = (\\<Sum>a\\<in>A. q a *s a)\""], ["proof (prove)\nusing this:\n  x \\<in> local.span B\n\ngoal (1 subgoal):\n 1. (\\<And>A q.\n        \\<lbrakk>finite A; A \\<subseteq> B;\n         x = (\\<Sum>a\\<in>A. q a *s a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule spanE)"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> B\n  x = (\\<Sum>a\\<in>A. q a *s a)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>keys r \\<subseteq> B; x = rep r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define r where \"r = Abs_poly_mapping (\\<lambda>k. q k when k \\<in> A)\""], ["proof (state)\nthis:\n  r = Abs_poly_mapping (\\<lambda>k. q k when k \\<in> A)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>keys r \\<subseteq> B; x = rep r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"lookup r = (\\<lambda>k. q k when k \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup r = (\\<lambda>k. q k when k \\<in> A)", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Abs_poly_mapping (\\<lambda>k. q k when k \\<in> A)) =\n    (\\<lambda>k. q k when k \\<in> A)", "by (rule Abs_poly_mapping_inverse, simp add: \\<open>finite A\\<close>)"], ["proof (state)\nthis:\n  lookup r = (\\<lambda>k. q k when k \\<in> A)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>keys r \\<subseteq> B; x = rep r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \"keys r \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys r \\<subseteq> A", "by (auto simp: in_keys_iff 1)"], ["proof (state)\nthis:\n  keys r \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>keys r \\<subseteq> B; x = rep r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys ?r \\<subseteq> B\n 2. x = rep ?r", "have \"x = (\\<Sum>a\\<in>A. lookup r a *s a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (\\<Sum>a\\<in>A. lookup r a *s a)", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>A. q a *s a) = (\\<Sum>a\\<in>A. lookup r a *s a)", "by (rule sum.cong, simp_all add: 1)"], ["proof (state)\nthis:\n  x = (\\<Sum>a\\<in>A. lookup r a *s a)\n\ngoal (2 subgoals):\n 1. keys ?r \\<subseteq> B\n 2. x = rep ?r", "also"], ["proof (state)\nthis:\n  x = (\\<Sum>a\\<in>A. lookup r a *s a)\n\ngoal (2 subgoals):\n 1. keys ?r \\<subseteq> B\n 2. x = rep ?r", "from \\<open>finite A\\<close> 2"], ["proof (chain)\npicking this:\n  finite A\n  keys r \\<subseteq> A", "have \"... = (\\<Sum>a\\<in>keys r. lookup r a *s a)\""], ["proof (prove)\nusing this:\n  finite A\n  keys r \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>A. lookup r a *s a) = (\\<Sum>a\\<in>keys r. lookup r a *s a)", "proof (rule sum.mono_neutral_right)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>A - keys r. lookup r i *s i = (0::'b)", "show \"\\<forall>a\\<in>A - keys r. lookup r a *s a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A - keys r. lookup r a *s a = (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>A - keys r. lookup r a *s a = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>A. lookup r a *s a) = (\\<Sum>a\\<in>keys r. lookup r a *s a)\n\ngoal (2 subgoals):\n 1. keys ?r \\<subseteq> B\n 2. x = rep ?r", "finally"], ["proof (chain)\npicking this:\n  x = (\\<Sum>a\\<in>keys r. lookup r a *s a)", "show \"x = rep r\""], ["proof (prove)\nusing this:\n  x = (\\<Sum>a\\<in>keys r. lookup r a *s a)\n\ngoal (1 subgoal):\n 1. x = rep r", "by (simp only: rep_def)"], ["proof (state)\nthis:\n  x = rep r\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B", "from 2 \\<open>A \\<subseteq> B\\<close>"], ["proof (chain)\npicking this:\n  keys r \\<subseteq> A\n  A \\<subseteq> B", "show \"keys r \\<subseteq> B\""], ["proof (prove)\nusing this:\n  keys r \\<subseteq> A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B", "by (rule subset_trans)"], ["proof (state)\nthis:\n  keys r \\<subseteq> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma representsI:\n  assumes \"keys r \\<subseteq> B\" and \"rep r = x\"\n  shows \"represents B r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B r x", "unfolding represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B \\<and> rep r = x", "using assms"], ["proof (prove)\nusing this:\n  keys r \\<subseteq> B\n  rep r = x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B \\<and> rep r = x", "by blast"], ["", "lemma representsD1:\n  assumes \"represents B r x\"\n  shows \"keys r \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B", "using assms"], ["proof (prove)\nusing this:\n  represents B r x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B", "unfolding represents_def"], ["proof (prove)\nusing this:\n  keys r \\<subseteq> B \\<and> rep r = x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B", "by blast"], ["", "lemma representsD2:\n  assumes \"represents B r x\"\n  shows \"x = rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = rep r", "using assms"], ["proof (prove)\nusing this:\n  represents B r x\n\ngoal (1 subgoal):\n 1. x = rep r", "unfolding represents_def"], ["proof (prove)\nusing this:\n  keys r \\<subseteq> B \\<and> rep r = x\n\ngoal (1 subgoal):\n 1. x = rep r", "by blast"], ["", "lemma represents_mono:\n  assumes \"represents B r x\" and \"B \\<subseteq> A\"\n  shows \"represents A r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents A r x", "proof (rule representsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys r \\<subseteq> A\n 2. rep r = x", "from assms(1)"], ["proof (chain)\npicking this:\n  represents B r x", "have \"keys r \\<subseteq> B\""], ["proof (prove)\nusing this:\n  represents B r x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B", "by (rule representsD1)"], ["proof (state)\nthis:\n  keys r \\<subseteq> B\n\ngoal (2 subgoals):\n 1. keys r \\<subseteq> A\n 2. rep r = x", "thus \"keys r \\<subseteq> A\""], ["proof (prove)\nusing this:\n  keys r \\<subseteq> B\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> A", "using assms(2)"], ["proof (prove)\nusing this:\n  keys r \\<subseteq> B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> A", "by (rule subset_trans)"], ["proof (state)\nthis:\n  keys r \\<subseteq> A\n\ngoal (1 subgoal):\n 1. rep r = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rep r = x", "from assms(1)"], ["proof (chain)\npicking this:\n  represents B r x", "have \"x = rep r\""], ["proof (prove)\nusing this:\n  represents B r x\n\ngoal (1 subgoal):\n 1. x = rep r", "by (rule representsD2)"], ["proof (state)\nthis:\n  x = rep r\n\ngoal (1 subgoal):\n 1. rep r = x", "thus \"rep r = x\""], ["proof (prove)\nusing this:\n  x = rep r\n\ngoal (1 subgoal):\n 1. rep r = x", "by (rule HOL.sym)"], ["proof (state)\nthis:\n  rep r = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_self: \"represents {x} (monomial 1 x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents {x} (monomial (1::'a) x) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. represents {x} (monomial (1::'a) x) x", "have sub: \"keys (monomial (1::'a) x) \\<subseteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial (1::'a) x) \\<subseteq> {x}", "by simp"], ["proof (state)\nthis:\n  keys (monomial (1::'a) x) \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. represents {x} (monomial (1::'a) x) x", "moreover"], ["proof (state)\nthis:\n  keys (monomial (1::'a) x) \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. represents {x} (monomial (1::'a) x) x", "have \"rep (monomial (1::'a) x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep (monomial (1::'a) x) = x", "by simp"], ["proof (state)\nthis:\n  rep (monomial (1::'a) x) = x\n\ngoal (1 subgoal):\n 1. represents {x} (monomial (1::'a) x) x", "ultimately"], ["proof (chain)\npicking this:\n  keys (monomial (1::'a) x) \\<subseteq> {x}\n  rep (monomial (1::'a) x) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (monomial (1::'a) x) \\<subseteq> {x}\n  rep (monomial (1::'a) x) = x\n\ngoal (1 subgoal):\n 1. represents {x} (monomial (1::'a) x) x", "by (rule representsI)"], ["proof (state)\nthis:\n  represents {x} (monomial (1::'a) x) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_zero: \"represents B 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B 0 (0::'b)", "by (rule representsI, simp_all)"], ["", "lemma represents_plus:\n  assumes \"represents A r x\" and \"represents B s y\"\n  shows \"represents (A \\<union> B) (r + s) (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r + s) (x + y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r + s) (x + y)", "from assms(1)"], ["proof (chain)\npicking this:\n  represents A r x", "have r: \"keys r \\<subseteq> A\" and x: \"x = rep r\""], ["proof (prove)\nusing this:\n  represents A r x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> A &&& x = rep r", "by (rule representsD1, rule representsD2)"], ["proof (state)\nthis:\n  keys r \\<subseteq> A\n  x = rep r\n\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r + s) (x + y)", "from assms(2)"], ["proof (chain)\npicking this:\n  represents B s y", "have s: \"keys s \\<subseteq> B\" and y: \"y = rep s\""], ["proof (prove)\nusing this:\n  represents B s y\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> B &&& y = rep s", "by (rule representsD1, rule representsD2)"], ["proof (state)\nthis:\n  keys s \\<subseteq> B\n  y = rep s\n\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r + s) (x + y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r + s) (x + y)", "proof (rule representsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (r + s) \\<subseteq> A \\<union> B\n 2. rep (r + s) = x + y", "from r s"], ["proof (chain)\npicking this:\n  keys r \\<subseteq> A\n  keys s \\<subseteq> B", "have \"keys r \\<union> keys s \\<subseteq> A \\<union> B\""], ["proof (prove)\nusing this:\n  keys r \\<subseteq> A\n  keys s \\<subseteq> B\n\ngoal (1 subgoal):\n 1. keys r \\<union> keys s \\<subseteq> A \\<union> B", "by blast"], ["proof (state)\nthis:\n  keys r \\<union> keys s \\<subseteq> A \\<union> B\n\ngoal (2 subgoals):\n 1. keys (r + s) \\<subseteq> A \\<union> B\n 2. rep (r + s) = x + y", "thus \"keys (r + s) \\<subseteq> A \\<union> B\""], ["proof (prove)\nusing this:\n  keys r \\<union> keys s \\<subseteq> A \\<union> B\n\ngoal (1 subgoal):\n 1. keys (r + s) \\<subseteq> A \\<union> B", "by (meson Poly_Mapping.keys_add subset_trans)"], ["proof (state)\nthis:\n  keys (r + s) \\<subseteq> A \\<union> B\n\ngoal (1 subgoal):\n 1. rep (r + s) = x + y", "qed (simp add: rep_plus x y)"], ["proof (state)\nthis:\n  represents (A \\<union> B) (r + s) (x + y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_uminus:\n  assumes \"represents B r x\"\n  shows \"represents B (- r) (- x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B (- r) (- x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. represents B (- r) (- x)", "from assms"], ["proof (chain)\npicking this:\n  represents B r x", "have r: \"keys r \\<subseteq> B\" and x: \"x = rep r\""], ["proof (prove)\nusing this:\n  represents B r x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B &&& x = rep r", "by (rule representsD1, rule representsD2)"], ["proof (state)\nthis:\n  keys r \\<subseteq> B\n  x = rep r\n\ngoal (1 subgoal):\n 1. represents B (- r) (- x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B (- r) (- x)", "proof (rule representsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (- r) \\<subseteq> B\n 2. rep (- r) = - x", "from r"], ["proof (chain)\npicking this:\n  keys r \\<subseteq> B", "show \"keys (- r) \\<subseteq> B\""], ["proof (prove)\nusing this:\n  keys r \\<subseteq> B\n\ngoal (1 subgoal):\n 1. keys (- r) \\<subseteq> B", "by (simp only: keys_uminus)"], ["proof (state)\nthis:\n  keys (- r) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. rep (- r) = - x", "qed (simp add: x)"], ["proof (state)\nthis:\n  represents B (- r) (- x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_minus:\n  assumes \"represents A r x\" and \"represents B s y\"\n  shows \"represents (A \\<union> B) (r - s) (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r - s) (x - y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r - s) (x - y)", "from assms(1)"], ["proof (chain)\npicking this:\n  represents A r x", "have r: \"keys r \\<subseteq> A\" and x: \"x = rep r\""], ["proof (prove)\nusing this:\n  represents A r x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> A &&& x = rep r", "by (rule representsD1, rule representsD2)"], ["proof (state)\nthis:\n  keys r \\<subseteq> A\n  x = rep r\n\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r - s) (x - y)", "from assms(2)"], ["proof (chain)\npicking this:\n  represents B s y", "have s: \"keys s \\<subseteq> B\" and y: \"y = rep s\""], ["proof (prove)\nusing this:\n  represents B s y\n\ngoal (1 subgoal):\n 1. keys s \\<subseteq> B &&& y = rep s", "by (rule representsD1, rule representsD2)"], ["proof (state)\nthis:\n  keys s \\<subseteq> B\n  y = rep s\n\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r - s) (x - y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. represents (A \\<union> B) (r - s) (x - y)", "proof (rule representsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (r - s) \\<subseteq> A \\<union> B\n 2. rep (r - s) = x - y", "from r s"], ["proof (chain)\npicking this:\n  keys r \\<subseteq> A\n  keys s \\<subseteq> B", "have \"keys r \\<union> keys s \\<subseteq> A \\<union> B\""], ["proof (prove)\nusing this:\n  keys r \\<subseteq> A\n  keys s \\<subseteq> B\n\ngoal (1 subgoal):\n 1. keys r \\<union> keys s \\<subseteq> A \\<union> B", "by blast"], ["proof (state)\nthis:\n  keys r \\<union> keys s \\<subseteq> A \\<union> B\n\ngoal (2 subgoals):\n 1. keys (r - s) \\<subseteq> A \\<union> B\n 2. rep (r - s) = x - y", "with keys_minus"], ["proof (chain)\npicking this:\n  keys (?p - ?q) \\<subseteq> keys ?p \\<union> keys ?q\n  keys r \\<union> keys s \\<subseteq> A \\<union> B", "show \"keys (r - s) \\<subseteq> A \\<union> B\""], ["proof (prove)\nusing this:\n  keys (?p - ?q) \\<subseteq> keys ?p \\<union> keys ?q\n  keys r \\<union> keys s \\<subseteq> A \\<union> B\n\ngoal (1 subgoal):\n 1. keys (r - s) \\<subseteq> A \\<union> B", "by (rule subset_trans)"], ["proof (state)\nthis:\n  keys (r - s) \\<subseteq> A \\<union> B\n\ngoal (1 subgoal):\n 1. rep (r - s) = x - y", "qed (simp only: rep_minus x y)"], ["proof (state)\nthis:\n  represents (A \\<union> B) (r - s) (x - y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_scale:\n  assumes \"represents B r x\"\n  shows \"represents B (monomial c 0 * r) (c *s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B (monomial c (0::'b) * r) (c *s x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. represents B (monomial c (0::'b) * r) (c *s x)", "from assms"], ["proof (chain)\npicking this:\n  represents B r x", "have r: \"keys r \\<subseteq> B\" and x: \"x = rep r\""], ["proof (prove)\nusing this:\n  represents B r x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B &&& x = rep r", "by (rule representsD1, rule representsD2)"], ["proof (state)\nthis:\n  keys r \\<subseteq> B\n  x = rep r\n\ngoal (1 subgoal):\n 1. represents B (monomial c (0::'b) * r) (c *s x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B (monomial c (0::'b) * r) (c *s x)", "proof (rule representsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (monomial c (0::'b) * r) \\<subseteq> B\n 2. rep (monomial c (0::'b) * r) = c *s x", "have l: \"lookup (monomial c 0 * r) v = c * (lookup r v)\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monomial c (0::'b) * r) v = c * lookup r v", "unfolding mult_map_scale_conv_mult[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.map ((*) c) r) v = c * lookup r v", "by (rule map_lookup, simp)"], ["proof (state)\nthis:\n  lookup (monomial c (0::'b) * r) ?v = c * lookup r ?v\n\ngoal (2 subgoals):\n 1. keys (monomial c (0::'b) * r) \\<subseteq> B\n 2. rep (monomial c (0::'b) * r) = c *s x", "have sub: \"keys (monomial c 0 * r) \\<subseteq> keys r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monomial c (0::'b) * r) \\<subseteq> keys r", "by (metis l lookup_not_eq_zero_eq_in_keys mult_zero_right subsetI)"], ["proof (state)\nthis:\n  keys (monomial c (0::'b) * r) \\<subseteq> keys r\n\ngoal (2 subgoals):\n 1. keys (monomial c (0::'b) * r) \\<subseteq> B\n 2. rep (monomial c (0::'b) * r) = c *s x", "thus \"keys (monomial c 0 * r) \\<subseteq> B\""], ["proof (prove)\nusing this:\n  keys (monomial c (0::'b) * r) \\<subseteq> keys r\n\ngoal (1 subgoal):\n 1. keys (monomial c (0::'b) * r) \\<subseteq> B", "using r"], ["proof (prove)\nusing this:\n  keys (monomial c (0::'b) * r) \\<subseteq> keys r\n  keys r \\<subseteq> B\n\ngoal (1 subgoal):\n 1. keys (monomial c (0::'b) * r) \\<subseteq> B", "by (rule subset_trans)"], ["proof (state)\nthis:\n  keys (monomial c (0::'b) * r) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. rep (monomial c (0::'b) * r) = c *s x", "qed (simp only: rep_smult x)"], ["proof (state)\nthis:\n  represents B (monomial c (0::'b) * r) (c *s x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_in_span:\n  assumes \"represents B r x\"\n  shows \"x \\<in> span B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "from assms"], ["proof (chain)\npicking this:\n  represents B r x", "have r: \"keys r \\<subseteq> B\" and x: \"x = rep r\""], ["proof (prove)\nusing this:\n  represents B r x\n\ngoal (1 subgoal):\n 1. keys r \\<subseteq> B &&& x = rep r", "by (rule representsD1, rule representsD2)"], ["proof (state)\nthis:\n  keys r \\<subseteq> B\n  x = rep r\n\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "have \"x \\<in> span (keys r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> local.span (keys r)", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rep r \\<in> local.span (keys r)", "by (fact rep_in_span)"], ["proof (state)\nthis:\n  x \\<in> local.span (keys r)\n\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "also"], ["proof (state)\nthis:\n  x \\<in> local.span (keys r)\n\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "from r"], ["proof (chain)\npicking this:\n  keys r \\<subseteq> B", "have \"... \\<subseteq> span B\""], ["proof (prove)\nusing this:\n  keys r \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.span (keys r) \\<subseteq> local.span B", "by (rule span_mono)"], ["proof (state)\nthis:\n  local.span (keys r) \\<subseteq> local.span B\n\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "finally"], ["proof (chain)\npicking this:\n  x \\<in> local.span B", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> local.span B\n\ngoal (1 subgoal):\n 1. x \\<in> local.span B", "."], ["proof (state)\nthis:\n  x \\<in> local.span B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma syzygy_module_iff: \"s \\<in> syzygy_module B \\<longleftrightarrow> represents B s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in> syzygy_module B) = represents B s (0::'b)", "by (simp add: syzygy_module_def)"], ["", "lemma syzygy_moduleI:\n  assumes \"represents B s 0\"\n  shows \"s \\<in> syzygy_module B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> syzygy_module B", "unfolding syzygy_module_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B s (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  represents B s (0::'b)\n\ngoal (1 subgoal):\n 1. represents B s (0::'b)", "."], ["", "lemma syzygy_moduleD:\n  assumes \"s \\<in> syzygy_module B\"\n  shows \"represents B s 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents B s (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> syzygy_module B\n\ngoal (1 subgoal):\n 1. represents B s (0::'b)", "unfolding syzygy_module_iff"], ["proof (prove)\nusing this:\n  represents B s (0::'b)\n\ngoal (1 subgoal):\n 1. represents B s (0::'b)", "."], ["", "lemma zero_in_syzygy_module: \"0 \\<in> syzygy_module B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> syzygy_module B", "using represents_zero"], ["proof (prove)\nusing this:\n  represents ?B 0 (0::'b)\n\ngoal (1 subgoal):\n 1. 0 \\<in> syzygy_module B", "by (rule syzygy_moduleI)"], ["", "lemma syzygy_module_closed_plus:\n  assumes \"s1 \\<in> syzygy_module B\" and \"s2 \\<in> syzygy_module B\"\n  shows \"s1 + s2 \\<in> syzygy_module B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "from assms(1)"], ["proof (chain)\npicking this:\n  s1 \\<in> syzygy_module B", "have \"represents B s1 0\""], ["proof (prove)\nusing this:\n  s1 \\<in> syzygy_module B\n\ngoal (1 subgoal):\n 1. represents B s1 (0::'b)", "by (rule syzygy_moduleD)"], ["proof (state)\nthis:\n  represents B s1 (0::'b)\n\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "moreover"], ["proof (state)\nthis:\n  represents B s1 (0::'b)\n\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "from assms(2)"], ["proof (chain)\npicking this:\n  s2 \\<in> syzygy_module B", "have \"represents B s2 0\""], ["proof (prove)\nusing this:\n  s2 \\<in> syzygy_module B\n\ngoal (1 subgoal):\n 1. represents B s2 (0::'b)", "by (rule syzygy_moduleD)"], ["proof (state)\nthis:\n  represents B s2 (0::'b)\n\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "ultimately"], ["proof (chain)\npicking this:\n  represents B s1 (0::'b)\n  represents B s2 (0::'b)", "have \"represents (B \\<union> B) (s1 + s2) (0 + 0)\""], ["proof (prove)\nusing this:\n  represents B s1 (0::'b)\n  represents B s2 (0::'b)\n\ngoal (1 subgoal):\n 1. represents (B \\<union> B) (s1 + s2) ((0::'b) + (0::'b))", "by (rule represents_plus)"], ["proof (state)\nthis:\n  represents (B \\<union> B) (s1 + s2) ((0::'b) + (0::'b))\n\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "hence \"represents B (s1 + s2) 0\""], ["proof (prove)\nusing this:\n  represents (B \\<union> B) (s1 + s2) ((0::'b) + (0::'b))\n\ngoal (1 subgoal):\n 1. represents B (s1 + s2) (0::'b)", "by simp"], ["proof (state)\nthis:\n  represents B (s1 + s2) (0::'b)\n\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "thus ?thesis"], ["proof (prove)\nusing this:\n  represents B (s1 + s2) (0::'b)\n\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module B", "by (rule syzygy_moduleI)"], ["proof (state)\nthis:\n  s1 + s2 \\<in> syzygy_module B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma syzygy_module_closed_minus:\n  assumes \"s1 \\<in> syzygy_module B\" and \"s2 \\<in> syzygy_module B\"\n  shows \"s1 - s2 \\<in> syzygy_module B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "from assms(1)"], ["proof (chain)\npicking this:\n  s1 \\<in> syzygy_module B", "have \"represents B s1 0\""], ["proof (prove)\nusing this:\n  s1 \\<in> syzygy_module B\n\ngoal (1 subgoal):\n 1. represents B s1 (0::'b)", "by (rule syzygy_moduleD)"], ["proof (state)\nthis:\n  represents B s1 (0::'b)\n\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "moreover"], ["proof (state)\nthis:\n  represents B s1 (0::'b)\n\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "from assms(2)"], ["proof (chain)\npicking this:\n  s2 \\<in> syzygy_module B", "have \"represents B s2 0\""], ["proof (prove)\nusing this:\n  s2 \\<in> syzygy_module B\n\ngoal (1 subgoal):\n 1. represents B s2 (0::'b)", "by (rule syzygy_moduleD)"], ["proof (state)\nthis:\n  represents B s2 (0::'b)\n\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "ultimately"], ["proof (chain)\npicking this:\n  represents B s1 (0::'b)\n  represents B s2 (0::'b)", "have \"represents (B \\<union> B) (s1 - s2) (0 - 0)\""], ["proof (prove)\nusing this:\n  represents B s1 (0::'b)\n  represents B s2 (0::'b)\n\ngoal (1 subgoal):\n 1. represents (B \\<union> B) (s1 - s2) ((0::'b) - (0::'b))", "by (rule represents_minus)"], ["proof (state)\nthis:\n  represents (B \\<union> B) (s1 - s2) ((0::'b) - (0::'b))\n\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "hence \"represents B (s1 - s2) 0\""], ["proof (prove)\nusing this:\n  represents (B \\<union> B) (s1 - s2) ((0::'b) - (0::'b))\n\ngoal (1 subgoal):\n 1. represents B (s1 - s2) (0::'b)", "by simp"], ["proof (state)\nthis:\n  represents B (s1 - s2) (0::'b)\n\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "thus ?thesis"], ["proof (prove)\nusing this:\n  represents B (s1 - s2) (0::'b)\n\ngoal (1 subgoal):\n 1. s1 - s2 \\<in> syzygy_module B", "by (rule syzygy_moduleI)"], ["proof (state)\nthis:\n  s1 - s2 \\<in> syzygy_module B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma syzygy_module_closed_times_monomial:\n  assumes \"s \\<in> syzygy_module B\"\n  shows \"monomial c 0 * s \\<in> syzygy_module B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial c (0::'b) * s \\<in> syzygy_module B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial c (0::'b) * s \\<in> syzygy_module B", "from assms(1)"], ["proof (chain)\npicking this:\n  s \\<in> syzygy_module B", "have \"represents B s 0\""], ["proof (prove)\nusing this:\n  s \\<in> syzygy_module B\n\ngoal (1 subgoal):\n 1. represents B s (0::'b)", "by (rule syzygy_moduleD)"], ["proof (state)\nthis:\n  represents B s (0::'b)\n\ngoal (1 subgoal):\n 1. monomial c (0::'b) * s \\<in> syzygy_module B", "hence \"represents B (monomial c 0 * s) (c *s 0)\""], ["proof (prove)\nusing this:\n  represents B s (0::'b)\n\ngoal (1 subgoal):\n 1. represents B (monomial c (0::'b) * s) (c *s (0::'b))", "by (rule represents_scale)"], ["proof (state)\nthis:\n  represents B (monomial c (0::'b) * s) (c *s (0::'b))\n\ngoal (1 subgoal):\n 1. monomial c (0::'b) * s \\<in> syzygy_module B", "hence \"represents B (monomial c 0 * s) 0\""], ["proof (prove)\nusing this:\n  represents B (monomial c (0::'b) * s) (c *s (0::'b))\n\ngoal (1 subgoal):\n 1. represents B (monomial c (0::'b) * s) (0::'b)", "by simp"], ["proof (state)\nthis:\n  represents B (monomial c (0::'b) * s) (0::'b)\n\ngoal (1 subgoal):\n 1. monomial c (0::'b) * s \\<in> syzygy_module B", "thus ?thesis"], ["proof (prove)\nusing this:\n  represents B (monomial c (0::'b) * s) (0::'b)\n\ngoal (1 subgoal):\n 1. monomial c (0::'b) * s \\<in> syzygy_module B", "by (rule syzygy_moduleI)"], ["proof (state)\nthis:\n  monomial c (0::'b) * s \\<in> syzygy_module B\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* module *)"], ["", "context term_powerprod\nbegin"], ["", "lemma keys_rep_subset:\n  assumes \"u \\<in> keys (pmdl.rep r)\"\n  obtains t v where \"t \\<in> Keys (Poly_Mapping.range r)\" and \"v \\<in> Keys (keys r)\" and \"u = t \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> Keys (Poly_Mapping.range r); v \\<in> Keys (keys r);\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> Keys (Poly_Mapping.range r); v \\<in> Keys (keys r);\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note assms"], ["proof (state)\nthis:\n  u \\<in> keys (pmdl.rep r)\n\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> Keys (Poly_Mapping.range r); v \\<in> Keys (keys r);\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  u \\<in> keys (pmdl.rep r)\n\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> Keys (Poly_Mapping.range r); v \\<in> Keys (keys r);\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"keys (pmdl.rep r) \\<subseteq> (\\<Union>v\\<in>keys r. keys (lookup r v \\<odot> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (pmdl.rep r)\n    \\<subseteq> (\\<Union>v\\<in>keys r. keys (lookup r v \\<odot> v))", "by (simp add: pmdl.rep_def keys_sum_subset)"], ["proof (state)\nthis:\n  keys (pmdl.rep r)\n  \\<subseteq> (\\<Union>v\\<in>keys r. keys (lookup r v \\<odot> v))\n\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> Keys (Poly_Mapping.range r); v \\<in> Keys (keys r);\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  u \\<in> (\\<Union>v\\<in>keys r. keys (lookup r v \\<odot> v))", "obtain v0 where \"v0 \\<in> keys r\" and \"u \\<in> keys (lookup r v0 \\<odot> v0)\""], ["proof (prove)\nusing this:\n  u \\<in> (\\<Union>v\\<in>keys r. keys (lookup r v \\<odot> v))\n\ngoal (1 subgoal):\n 1. (\\<And>v0.\n        \\<lbrakk>v0 \\<in> keys r;\n         u \\<in> keys (lookup r v0 \\<odot> v0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v0 \\<in> keys r\n  u \\<in> keys (lookup r v0 \\<odot> v0)\n\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> Keys (Poly_Mapping.range r); v \\<in> Keys (keys r);\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this(2)"], ["proof (chain)\npicking this:\n  u \\<in> keys (lookup r v0 \\<odot> v0)", "obtain t v where \"t \\<in> keys (lookup r v0)\" and \"v \\<in> keys v0\" and \"u = t \\<oplus> v\""], ["proof (prove)\nusing this:\n  u \\<in> keys (lookup r v0 \\<odot> v0)\n\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> keys (lookup r v0); v \\<in> keys v0;\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_keys_mult_scalarE)"], ["proof (state)\nthis:\n  t \\<in> keys (lookup r v0)\n  v \\<in> keys v0\n  u = t \\<oplus> v\n\ngoal (1 subgoal):\n 1. (\\<And>t v.\n        \\<lbrakk>t \\<in> Keys (Poly_Mapping.range r); v \\<in> Keys (keys r);\n         u = t \\<oplus> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?t11 \\<in> Keys (Poly_Mapping.range r)\n 2. ?v11 \\<in> Keys (keys r)\n 3. u = ?t11 \\<oplus> ?v11", "from \\<open>v0 \\<in> keys r\\<close>"], ["proof (chain)\npicking this:\n  v0 \\<in> keys r", "have \"lookup r v0 \\<in> Poly_Mapping.range r\""], ["proof (prove)\nusing this:\n  v0 \\<in> keys r\n\ngoal (1 subgoal):\n 1. lookup r v0 \\<in> Poly_Mapping.range r", "by (rule in_keys_lookup_in_range)"], ["proof (state)\nthis:\n  lookup r v0 \\<in> Poly_Mapping.range r\n\ngoal (3 subgoals):\n 1. ?t11 \\<in> Keys (Poly_Mapping.range r)\n 2. ?v11 \\<in> Keys (keys r)\n 3. u = ?t11 \\<oplus> ?v11", "with \\<open>t \\<in> keys (lookup r v0)\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> keys (lookup r v0)\n  lookup r v0 \\<in> Poly_Mapping.range r", "show \"t \\<in> Keys (Poly_Mapping.range r)\""], ["proof (prove)\nusing this:\n  t \\<in> keys (lookup r v0)\n  lookup r v0 \\<in> Poly_Mapping.range r\n\ngoal (1 subgoal):\n 1. t \\<in> Keys (Poly_Mapping.range r)", "by (rule in_KeysI)"], ["proof (state)\nthis:\n  t \\<in> Keys (Poly_Mapping.range r)\n\ngoal (2 subgoals):\n 1. ?v11 \\<in> Keys (keys r)\n 2. u = t \\<oplus> ?v11", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ?v11 \\<in> Keys (keys r)\n 2. u = t \\<oplus> ?v11", "from \\<open>v \\<in> keys v0\\<close> \\<open>v0 \\<in> keys r\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> keys v0\n  v0 \\<in> keys r", "show \"v \\<in> Keys (keys r)\""], ["proof (prove)\nusing this:\n  v \\<in> keys v0\n  v0 \\<in> keys r\n\ngoal (1 subgoal):\n 1. v \\<in> Keys (keys r)", "by (rule in_KeysI)"], ["proof (state)\nthis:\n  v \\<in> Keys (keys r)\n\ngoal (1 subgoal):\n 1. u = t \\<oplus> v", "qed fact"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rep_mult_scalar: \"pmdl.rep (punit.monom_mult c 0 r) = c \\<odot> pmdl.rep r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl.rep (punit.monom_mult c 0 r) = c \\<odot> pmdl.rep r", "unfolding punit.mult_scalar_monomial[symmetric] punit_mult_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl.rep (monomial c 0 * r) = c \\<odot> pmdl.rep r", "by (fact pmdl.rep_smult)"], ["", "lemma represents_mult_scalar:\n  assumes \"pmdl.represents B r x\"\n  shows \"pmdl.represents B (punit.monom_mult c 0 r) (c \\<odot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl.represents B (punit.monom_mult c 0 r) (c \\<odot> x)", "unfolding punit.mult_scalar_monomial[symmetric] punit_mult_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl.represents B (monomial c 0 * r) (c \\<odot> x)", "using assms"], ["proof (prove)\nusing this:\n  pmdl.represents B r x\n\ngoal (1 subgoal):\n 1. pmdl.represents B (monomial c 0 * r) (c \\<odot> x)", "by (rule pmdl.represents_scale)"], ["", "lemma syzygy_module_closed_map_scale: \"s \\<in> pmdl.syzygy_module B \\<Longrightarrow> c \\<cdot> s \\<in> pmdl.syzygy_module B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> pmdl.syzygy_module B \\<Longrightarrow>\n    c \\<cdot> s \\<in> pmdl.syzygy_module B", "unfolding map_scale_eq_times"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> pmdl.syzygy_module B \\<Longrightarrow>\n    monomial c 0 * s \\<in> pmdl.syzygy_module B", "by (rule pmdl.syzygy_module_closed_times_monomial)"], ["", "lemma phull_syzygy_module: \"phull (pmdl.syzygy_module B) = pmdl.syzygy_module B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phull (pmdl.syzygy_module B) = pmdl.syzygy_module B", "unfolding phull.span_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. phull.subspace (pmdl.syzygy_module B)", "apply (rule phull.subspaceI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<in> pmdl.syzygy_module B\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> pmdl.syzygy_module B;\n        y \\<in> pmdl.syzygy_module B\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> pmdl.syzygy_module B\n 3. \\<And>c x.\n       x \\<in> pmdl.syzygy_module B \\<Longrightarrow>\n       c \\<cdot> x \\<in> pmdl.syzygy_module B", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> pmdl.syzygy_module B", "by (fact pmdl.zero_in_syzygy_module)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> pmdl.syzygy_module B;\n        y \\<in> pmdl.syzygy_module B\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> pmdl.syzygy_module B\n 2. \\<And>c x.\n       x \\<in> pmdl.syzygy_module B \\<Longrightarrow>\n       c \\<cdot> x \\<in> pmdl.syzygy_module B", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> pmdl.syzygy_module B;\n     y_ \\<in> pmdl.syzygy_module B\\<rbrakk>\n    \\<Longrightarrow> x_ + y_ \\<in> pmdl.syzygy_module B", "by (fact pmdl.syzygy_module_closed_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       x \\<in> pmdl.syzygy_module B \\<Longrightarrow>\n       c \\<cdot> x \\<in> pmdl.syzygy_module B", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> pmdl.syzygy_module B \\<Longrightarrow>\n    c_ \\<cdot> x_ \\<in> pmdl.syzygy_module B", "by (fact syzygy_module_closed_map_scale)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "(* term_powerprod *)"], ["", "subsection \\<open>Polynomial Mappings on List-Indices\\<close>"], ["", "definition pm_of_idx_pm :: \"('a list) \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>0 'b::zero\"\n  where \"pm_of_idx_pm xs f = Abs_poly_mapping (\\<lambda>x. lookup f (Min {i. i < length xs \\<and> xs ! i = x}) when x \\<in> set xs)\""], ["", "definition idx_pm_of_pm :: \"('a list) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> nat \\<Rightarrow>\\<^sub>0 'b::zero\"\n  where \"idx_pm_of_pm xs f = Abs_poly_mapping (\\<lambda>i. lookup f (xs ! i) when i < length xs)\""], ["", "lemma lookup_pm_of_idx_pm:\n  \"lookup (pm_of_idx_pm xs f) = (\\<lambda>x. lookup f (Min {i. i < length xs \\<and> xs ! i = x}) when x \\<in> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) =\n    (\\<lambda>x.\n        lookup f (Min {i. i < length xs \\<and> xs ! i = x}) when\n        x \\<in> set xs)", "unfolding pm_of_idx_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping\n       (\\<lambda>x.\n           lookup f (Min {i. i < length xs \\<and> xs ! i = x}) when\n           x \\<in> set xs)) =\n    (\\<lambda>x.\n        lookup f (Min {i. i < length xs \\<and> xs ! i = x}) when\n        x \\<in> set xs)", "by (rule Abs_poly_mapping_inverse, simp)"], ["", "lemma lookup_pm_of_idx_pm_distinct:\n  assumes \"distinct xs\" and \"i < length xs\"\n  shows \"lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i", "from assms"], ["proof (chain)\npicking this:\n  distinct xs\n  i < length xs", "have \"{j. j < length xs \\<and> xs ! j = xs ! i} = {i}\""], ["proof (prove)\nusing this:\n  distinct xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. {j. j < length xs \\<and> xs ! j = xs ! i} = {i}", "using distinct_Ex1 nth_mem"], ["proof (prove)\nusing this:\n  distinct xs\n  i < length xs\n  \\<lbrakk>distinct ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!i. i < length ?xs \\<and> ?xs ! i = ?x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. {j. j < length xs \\<and> xs ! j = xs ! i} = {i}", "by fastforce"], ["proof (state)\nthis:\n  {j. j < length xs \\<and> xs ! j = xs ! i} = {i}\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i", "moreover"], ["proof (state)\nthis:\n  {j. j < length xs \\<and> xs ! j = xs ! i} = {i}\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i", "from assms(2)"], ["proof (chain)\npicking this:\n  i < length xs", "have \"xs ! i \\<in> set xs\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs ! i \\<in> set xs", "by (rule nth_mem)"], ["proof (state)\nthis:\n  xs ! i \\<in> set xs\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i", "ultimately"], ["proof (chain)\npicking this:\n  {j. j < length xs \\<and> xs ! j = xs ! i} = {i}\n  xs ! i \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  {j. j < length xs \\<and> xs ! j = xs ! i} = {i}\n  xs ! i \\<in> set xs\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i", "by (simp add: lookup_pm_of_idx_pm)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs f) (xs ! i) = lookup f i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_pm_of_idx_pm_subset: \"keys (pm_of_idx_pm xs f) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (pm_of_idx_pm xs f) \\<subseteq> set xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (pm_of_idx_pm xs f) \\<Longrightarrow> x \\<in> set xs", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (pm_of_idx_pm xs f) \\<Longrightarrow> x \\<in> set xs", "assume \"t \\<in> keys (pm_of_idx_pm xs f)\""], ["proof (state)\nthis:\n  t \\<in> keys (pm_of_idx_pm xs f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (pm_of_idx_pm xs f) \\<Longrightarrow> x \\<in> set xs", "hence \"lookup (pm_of_idx_pm xs f) t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<in> keys (pm_of_idx_pm xs f)\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs f) t \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs f) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (pm_of_idx_pm xs f) \\<Longrightarrow> x \\<in> set xs", "thus \"t \\<in> set xs\""], ["proof (prove)\nusing this:\n  lookup (pm_of_idx_pm xs f) t \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. t \\<in> set xs", "by (simp add: lookup_pm_of_idx_pm)"], ["proof (state)\nthis:\n  t \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma range_pm_of_idx_pm_subset: \"Poly_Mapping.range (pm_of_idx_pm xs f) \\<subseteq> lookup f ` {0..<length xs} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.range (pm_of_idx_pm xs f)\n    \\<subseteq> lookup f ` {0..<length xs} - {0::'a}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Poly_Mapping.range (pm_of_idx_pm xs f) \\<Longrightarrow>\n       x \\<in> lookup f ` {0..<length xs} - {0::'a}", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Poly_Mapping.range (pm_of_idx_pm xs f) \\<Longrightarrow>\n       x \\<in> lookup f ` {0..<length xs} - {0::'a}", "assume \"c \\<in> Poly_Mapping.range (pm_of_idx_pm xs f)\""], ["proof (state)\nthis:\n  c \\<in> Poly_Mapping.range (pm_of_idx_pm xs f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Poly_Mapping.range (pm_of_idx_pm xs f) \\<Longrightarrow>\n       x \\<in> lookup f ` {0..<length xs} - {0::'a}", "then"], ["proof (chain)\npicking this:\n  c \\<in> Poly_Mapping.range (pm_of_idx_pm xs f)", "obtain t where t: \"t \\<in> keys (pm_of_idx_pm xs f)\" and c: \"c = lookup (pm_of_idx_pm xs f) t\""], ["proof (prove)\nusing this:\n  c \\<in> Poly_Mapping.range (pm_of_idx_pm xs f)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys (pm_of_idx_pm xs f);\n         c = lookup (pm_of_idx_pm xs f) t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis DiffE imageE insertCI not_in_keys_iff_lookup_eq_zero range.rep_eq)"], ["proof (state)\nthis:\n  t \\<in> keys (pm_of_idx_pm xs f)\n  c = lookup (pm_of_idx_pm xs f) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Poly_Mapping.range (pm_of_idx_pm xs f) \\<Longrightarrow>\n       x \\<in> lookup f ` {0..<length xs} - {0::'a}", "from t keys_pm_of_idx_pm_subset"], ["proof (chain)\npicking this:\n  t \\<in> keys (pm_of_idx_pm xs f)\n  keys (pm_of_idx_pm ?xs ?f) \\<subseteq> set ?xs", "have \"t \\<in> set xs\""], ["proof (prove)\nusing this:\n  t \\<in> keys (pm_of_idx_pm xs f)\n  keys (pm_of_idx_pm ?xs ?f) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. t \\<in> set xs", ".."], ["proof (state)\nthis:\n  t \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Poly_Mapping.range (pm_of_idx_pm xs f) \\<Longrightarrow>\n       x \\<in> lookup f ` {0..<length xs} - {0::'a}", "hence c1: \"c = lookup f (Min {i. i < length xs \\<and> xs ! i = t})\""], ["proof (prove)\nusing this:\n  t \\<in> set xs\n\ngoal (1 subgoal):\n 1. c = lookup f (Min {i. i < length xs \\<and> xs ! i = t})", "by (simp add: lookup_pm_of_idx_pm c)"], ["proof (state)\nthis:\n  c = lookup f (Min {i. i < length xs \\<and> xs ! i = t})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Poly_Mapping.range (pm_of_idx_pm xs f) \\<Longrightarrow>\n       x \\<in> lookup f ` {0..<length xs} - {0::'a}", "show \"c \\<in> lookup f ` {0..<length xs} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> lookup f ` {0..<length xs} - {0::'a}", "proof (intro DiffI image_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. c = lookup f ?x1\n 2. ?x1 \\<in> {0..<length xs}\n 3. c \\<notin> {0::'a}", "from \\<open>t \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> set xs", "obtain i where \"i < length xs\" and \"t = xs ! i\""], ["proof (prove)\nusing this:\n  t \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; t = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length xs\n  t = xs ! i\n\ngoal (3 subgoals):\n 1. c = lookup f ?x1\n 2. ?x1 \\<in> {0..<length xs}\n 3. c \\<notin> {0::'a}", "have \"finite {i. i < length xs \\<and> xs ! i = t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. i < length xs \\<and> xs ! i = t}", "by simp"], ["proof (state)\nthis:\n  finite {i. i < length xs \\<and> xs ! i = t}\n\ngoal (3 subgoals):\n 1. c = lookup f ?x1\n 2. ?x1 \\<in> {0..<length xs}\n 3. c \\<notin> {0::'a}", "moreover"], ["proof (state)\nthis:\n  finite {i. i < length xs \\<and> xs ! i = t}\n\ngoal (3 subgoals):\n 1. c = lookup f ?x1\n 2. ?x1 \\<in> {0..<length xs}\n 3. c \\<notin> {0::'a}", "from \\<open>i < length xs\\<close> \\<open>t = xs ! i\\<close>"], ["proof (chain)\npicking this:\n  i < length xs\n  t = xs ! i", "have \"{i. i < length xs \\<and> xs ! i = t} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  i < length xs\n  t = xs ! i\n\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> xs ! i = t} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {i. i < length xs \\<and> xs ! i = t} \\<noteq> {}\n\ngoal (3 subgoals):\n 1. c = lookup f ?x1\n 2. ?x1 \\<in> {0..<length xs}\n 3. c \\<notin> {0::'a}", "ultimately"], ["proof (chain)\npicking this:\n  finite {i. i < length xs \\<and> xs ! i = t}\n  {i. i < length xs \\<and> xs ! i = t} \\<noteq> {}", "have \"Min {i. i < length xs \\<and> xs ! i = t} \\<in> {i. i < length xs \\<and> xs ! i = t}\""], ["proof (prove)\nusing this:\n  finite {i. i < length xs \\<and> xs ! i = t}\n  {i. i < length xs \\<and> xs ! i = t} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> xs ! i = t}\n    \\<in> {i. i < length xs \\<and> xs ! i = t}", "by (rule Min_in)"], ["proof (state)\nthis:\n  Min {i. i < length xs \\<and> xs ! i = t}\n  \\<in> {i. i < length xs \\<and> xs ! i = t}\n\ngoal (3 subgoals):\n 1. c = lookup f ?x1\n 2. ?x1 \\<in> {0..<length xs}\n 3. c \\<notin> {0::'a}", "thus \"Min {i. i < length xs \\<and> xs ! i = t} \\<in> {0..<length xs}\""], ["proof (prove)\nusing this:\n  Min {i. i < length xs \\<and> xs ! i = t}\n  \\<in> {i. i < length xs \\<and> xs ! i = t}\n\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> xs ! i = t} \\<in> {0..<length xs}", "by simp"], ["proof (state)\nthis:\n  Min {i. i < length xs \\<and> xs ! i = t} \\<in> {0..<length xs}\n\ngoal (2 subgoals):\n 1. c = lookup f (Min {i. i < length xs \\<and> xs ! i = t})\n 2. c \\<notin> {0::'a}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. c = lookup f (Min {i. i < length xs \\<and> xs ! i = t})\n 2. c \\<notin> {0::'a}", "from t"], ["proof (chain)\npicking this:\n  t \\<in> keys (pm_of_idx_pm xs f)", "show \"c \\<notin> {0}\""], ["proof (prove)\nusing this:\n  t \\<in> keys (pm_of_idx_pm xs f)\n\ngoal (1 subgoal):\n 1. c \\<notin> {0::'a}", "by (simp add: c in_keys_iff)"], ["proof (state)\nthis:\n  c \\<notin> {0::'a}\n\ngoal (1 subgoal):\n 1. c = lookup f (Min {i. i < length xs \\<and> xs ! i = t})", "qed (fact c1)"], ["proof (state)\nthis:\n  c \\<in> lookup f ` {0..<length xs} - {0::'a}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary range_pm_of_idx_pm_subset': \"Poly_Mapping.range (pm_of_idx_pm xs f) \\<subseteq> Poly_Mapping.range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.range (pm_of_idx_pm xs f) \\<subseteq> Poly_Mapping.range f", "using range_pm_of_idx_pm_subset"], ["proof (prove)\nusing this:\n  Poly_Mapping.range (pm_of_idx_pm ?xs ?f)\n  \\<subseteq> lookup ?f ` {0..<length ?xs} - {0::?'a}\n\ngoal (1 subgoal):\n 1. Poly_Mapping.range (pm_of_idx_pm xs f) \\<subseteq> Poly_Mapping.range f", "proof (rule subset_trans)"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup f ` {0..<length xs} - {0::'a} \\<subseteq> Poly_Mapping.range f", "show \"lookup f ` {0..<length xs} - {0} \\<subseteq> Poly_Mapping.range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup f ` {0..<length xs} - {0::'a} \\<subseteq> Poly_Mapping.range f", "by (transfer, auto)"], ["proof (state)\nthis:\n  lookup f ` {0..<length xs} - {0::'a} \\<subseteq> Poly_Mapping.range f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pm_of_idx_pm_zero [simp]: \"pm_of_idx_pm xs 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs 0 = 0", "by (rule poly_mapping_eqI, simp add: lookup_pm_of_idx_pm)"], ["", "lemma pm_of_idx_pm_plus: \"pm_of_idx_pm xs (f + g) = pm_of_idx_pm xs f + pm_of_idx_pm xs g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (f + g) = pm_of_idx_pm xs f + pm_of_idx_pm xs g", "by (rule poly_mapping_eqI, simp add: lookup_pm_of_idx_pm lookup_add when_def)"], ["", "lemma pm_of_idx_pm_uminus: \"pm_of_idx_pm xs (- f) = - pm_of_idx_pm xs f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (- f) = - pm_of_idx_pm xs f", "by (rule poly_mapping_eqI, simp add: lookup_pm_of_idx_pm when_def)"], ["", "lemma pm_of_idx_pm_minus: \"pm_of_idx_pm xs (f - g) = pm_of_idx_pm xs f - pm_of_idx_pm xs g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (f - g) = pm_of_idx_pm xs f - pm_of_idx_pm xs g", "by (rule poly_mapping_eqI, simp add: lookup_pm_of_idx_pm lookup_minus when_def)"], ["", "lemma pm_of_idx_pm_monom_mult: \"pm_of_idx_pm xs (punit.monom_mult c 0 f) = punit.monom_mult c 0 (pm_of_idx_pm xs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (punit.monom_mult c 0 f) =\n    punit.monom_mult c (0::'a) (pm_of_idx_pm xs f)", "by (rule poly_mapping_eqI, simp add: lookup_pm_of_idx_pm punit.lookup_monom_mult_zero when_def)"], ["", "lemma pm_of_idx_pm_monomial:\n  assumes \"distinct xs\"\n  shows \"pm_of_idx_pm xs (monomial c i) = (monomial c (xs ! i) when i < length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "from assms"], ["proof (chain)\npicking this:\n  distinct xs", "have *: \"{i. i < length xs \\<and> xs ! i = xs ! j} = {j}\" if \"j < length xs\" for j"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> xs ! i = xs ! j} = {j}", "using distinct_Ex1 nth_mem that"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<lbrakk>distinct ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!i. i < length ?xs \\<and> ?xs ! i = ?x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> xs ! i = xs ! j} = {j}", "by fastforce"], ["proof (state)\nthis:\n  ?j < length xs \\<Longrightarrow>\n  {i. i < length xs \\<and> xs ! i = xs ! ?j} = {?j}\n\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "proof (cases \"i < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)\n 2. \\<not> i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "case True"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)\n 2. \\<not> i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "have \"pm_of_idx_pm xs (monomial c i) = monomial c (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) = monomial c (xs ! i)", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm xs (monomial c i)) k =\n       lookup (monomial c (xs ! i)) k", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm xs (monomial c i)) k =\n       lookup (monomial c (xs ! i)) k", "show \"lookup (pm_of_idx_pm xs (monomial c i)) k = lookup (monomial c (xs ! i)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "proof (cases \"xs ! i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs ! i = k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k\n 2. xs ! i \\<noteq> k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "case True"], ["proof (state)\nthis:\n  xs ! i = k\n\ngoal (2 subgoals):\n 1. xs ! i = k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k\n 2. xs ! i \\<noteq> k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "with \\<open>i < length xs\\<close>"], ["proof (chain)\npicking this:\n  i < length xs\n  xs ! i = k", "have \"k \\<in> set xs\""], ["proof (prove)\nusing this:\n  i < length xs\n  xs ! i = k\n\ngoal (1 subgoal):\n 1. k \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  k \\<in> set xs\n\ngoal (2 subgoals):\n 1. xs ! i = k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k\n 2. xs ! i \\<noteq> k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> set xs\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "by (simp add: lookup_pm_of_idx_pm lookup_single *[OF \\<open>i < length xs\\<close>] True[symmetric])"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs (monomial c i)) k = lookup (monomial c (xs ! i)) k\n\ngoal (1 subgoal):\n 1. xs ! i \\<noteq> k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs ! i \\<noteq> k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "case False"], ["proof (state)\nthis:\n  xs ! i \\<noteq> k\n\ngoal (1 subgoal):\n 1. xs ! i \\<noteq> k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "have \"lookup (pm_of_idx_pm xs (monomial c i)) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "proof (cases \"k \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n 2. k \\<notin> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "case True"], ["proof (state)\nthis:\n  k \\<in> set xs\n\ngoal (2 subgoals):\n 1. k \\<in> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n 2. k \\<notin> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "then"], ["proof (chain)\npicking this:\n  k \\<in> set xs", "obtain j where \"j < length xs\" and \"k = xs ! j\""], ["proof (prove)\nusing this:\n  k \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length xs; k = xs ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  j < length xs\n  k = xs ! j\n\ngoal (2 subgoals):\n 1. k \\<in> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n 2. k \\<notin> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "with False"], ["proof (chain)\npicking this:\n  xs ! i \\<noteq> k\n  j < length xs\n  k = xs ! j", "have \"i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}\""], ["proof (prove)\nusing this:\n  xs ! i \\<noteq> k\n  j < length xs\n  k = xs ! j\n\ngoal (1 subgoal):\n 1. i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}", "by (auto simp: \\<open>k = xs ! j\\<close> *[OF \\<open>j < length xs\\<close>])"], ["proof (state)\nthis:\n  i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}\n\ngoal (2 subgoals):\n 1. k \\<in> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n 2. k \\<notin> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "by (simp add: lookup_pm_of_idx_pm True lookup_single)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n\ngoal (1 subgoal):\n 1. k \\<notin> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<notin> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "case False"], ["proof (state)\nthis:\n  k \\<notin> set xs\n\ngoal (1 subgoal):\n 1. k \\<notin> set xs \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<notin> set xs\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "by (simp add: lookup_pm_of_idx_pm)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n\ngoal (1 subgoal):\n 1. xs ! i \\<noteq> k \\<Longrightarrow>\n    lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "with False"], ["proof (chain)\npicking this:\n  xs ! i \\<noteq> k\n  lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs ! i \\<noteq> k\n  lookup (pm_of_idx_pm xs (monomial c i)) k = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm xs (monomial c i)) k =\n    lookup (monomial c (xs ! i)) k", "by (simp add: lookup_single)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs (monomial c i)) k = lookup (monomial c (xs ! i)) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm xs (monomial c i)) k = lookup (monomial c (xs ! i)) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pm_of_idx_pm xs (monomial c i) = monomial c (xs ! i)\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)\n 2. \\<not> i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "with True"], ["proof (chain)\npicking this:\n  i < length xs\n  pm_of_idx_pm xs (monomial c i) = monomial c (xs ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length xs\n  pm_of_idx_pm xs (monomial c i) = monomial c (xs ! i)\n\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "by simp"], ["proof (state)\nthis:\n  pm_of_idx_pm xs (monomial c i) = (monomial c (xs ! i) when i < length xs)\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "case False"], ["proof (state)\nthis:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "have \"pm_of_idx_pm xs (monomial c i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) = 0", "proof (rule poly_mapping_eqI, simp add: lookup_pm_of_idx_pm when_def, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) =\n       (0::'b)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) =\n       (0::'b)", "assume \"k \\<in> set xs\""], ["proof (state)\nthis:\n  k \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) =\n       (0::'b)", "then"], ["proof (chain)\npicking this:\n  k \\<in> set xs", "obtain j where \"j < length xs\" and \"k = xs ! j\""], ["proof (prove)\nusing this:\n  k \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length xs; k = xs ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  j < length xs\n  k = xs ! j\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) =\n       (0::'b)", "with False"], ["proof (chain)\npicking this:\n  \\<not> i < length xs\n  j < length xs\n  k = xs ! j", "have \"i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}\""], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n  j < length xs\n  k = xs ! j\n\ngoal (1 subgoal):\n 1. i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}", "by (auto simp: \\<open>k = xs ! j\\<close> *[OF \\<open>j < length xs\\<close>])"], ["proof (state)\nthis:\n  i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) =\n       (0::'b)", "thus \"lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) = 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> Min {i. i < length xs \\<and> xs ! i = k}\n\ngoal (1 subgoal):\n 1. lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) =\n    (0::'b)", "by (simp add: lookup_single)"], ["proof (state)\nthis:\n  lookup (monomial c i) (Min {i. i < length xs \\<and> xs ! i = k}) = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pm_of_idx_pm xs (monomial c i) = 0\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "with False"], ["proof (chain)\npicking this:\n  \\<not> i < length xs\n  pm_of_idx_pm xs (monomial c i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n  pm_of_idx_pm xs (monomial c i) = 0\n\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (monomial c i) =\n    (monomial c (xs ! i) when i < length xs)", "by simp"], ["proof (state)\nthis:\n  pm_of_idx_pm xs (monomial c i) = (monomial c (xs ! i) when i < length xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pm_of_idx_pm xs (monomial c i) = (monomial c (xs ! i) when i < length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pm_of_idx_pm_take:\n  assumes \"keys f \\<subseteq> {0..<j}\"\n  shows \"pm_of_idx_pm (take j xs) f = pm_of_idx_pm xs f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm (take j xs) f = pm_of_idx_pm xs f", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "let ?xs = \"take j xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "let ?A = \"{k. k < length xs \\<and> xs ! k = i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "let ?B = \"{k. k < length xs \\<and> k < j \\<and> xs ! k = i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "have A_fin: \"finite ?A\" and B_fin: \"finite ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {k. k < length xs \\<and> xs ! k = i} &&&\n    finite {k. k < length xs \\<and> k < j \\<and> xs ! k = i}", "by fastforce+"], ["proof (state)\nthis:\n  finite {k. k < length xs \\<and> xs ! k = i}\n  finite {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "have A_ne: \"i \\<in> set xs \\<Longrightarrow> ?A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    {k. k < length xs \\<and> xs ! k = i} \\<noteq> {}", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  i \\<in> set xs \\<Longrightarrow>\n  {k. k < length xs \\<and> xs ! k = i} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "have B_ne: \"i \\<in> set ?xs \\<Longrightarrow> ?B \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    {k. k < length xs \\<and> k < j \\<and> xs ! k = i} \\<noteq> {}", "by (auto simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  i \\<in> set (take j xs) \\<Longrightarrow>\n  {k. k < length xs \\<and> k < j \\<and> xs ! k = i} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "define m1 where \"m1 = Min ?A\""], ["proof (state)\nthis:\n  m1 = Min {k. k < length xs \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "define m2 where \"m2 = Min ?B\""], ["proof (state)\nthis:\n  m2 = Min {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "have m1: \"m1 \\<in> ?A\" if \"i \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<in> {k. k < length xs \\<and> xs ! k = i}", "unfolding m1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {k. k < length xs \\<and> xs ! k = i}\n    \\<in> {k. k < length xs \\<and> xs ! k = i}", "by (rule Min_in, fact A_fin, rule A_ne, fact that)"], ["proof (state)\nthis:\n  i \\<in> set xs \\<Longrightarrow>\n  m1 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "have m2: \"m2 \\<in> ?B\" if \"i \\<in> set ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}", "unfolding m2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n    \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}", "by (rule Min_in, fact B_fin, rule B_ne, fact that)"], ["proof (state)\nthis:\n  i \\<in> set (take j xs) \\<Longrightarrow>\n  m2 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (pm_of_idx_pm (take j xs) f) k = lookup (pm_of_idx_pm xs f) k", "show \"lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "proof (cases \"i \\<in> set ?xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "case True"], ["proof (state)\nthis:\n  i \\<in> set (take j xs)\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "hence \"i \\<in> set xs\""], ["proof (prove)\nusing this:\n  i \\<in> set (take j xs)\n\ngoal (1 subgoal):\n 1. i \\<in> set xs", "using set_take_subset"], ["proof (prove)\nusing this:\n  i \\<in> set (take j xs)\n  set (take ?n ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. i \\<in> set xs", ".."], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "hence \"m1 \\<in> ?A\""], ["proof (prove)\nusing this:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. m1 \\<in> {k. k < length xs \\<and> xs ! k = i}", "by (rule m1)"], ["proof (state)\nthis:\n  m1 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "hence \"m1 < length xs\" and \"xs ! m1 = i\""], ["proof (prove)\nusing this:\n  m1 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. m1 < length xs &&& xs ! m1 = i", "by simp_all"], ["proof (state)\nthis:\n  m1 < length xs\n  xs ! m1 = i\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "from True"], ["proof (chain)\npicking this:\n  i \\<in> set (take j xs)", "have \"m2 \\<in> ?B\""], ["proof (prove)\nusing this:\n  i \\<in> set (take j xs)\n\ngoal (1 subgoal):\n 1. m2 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}", "by (rule m2)"], ["proof (state)\nthis:\n  m2 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "hence \"m2 < length xs\" and \"m2 < j\" and \"xs ! m2 = i\""], ["proof (prove)\nusing this:\n  m2 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. m2 < length xs &&& m2 < j &&& xs ! m2 = i", "by simp_all"], ["proof (state)\nthis:\n  m2 < length xs\n  m2 < j\n  xs ! m2 = i\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "hence \"m2 \\<in> ?A\""], ["proof (prove)\nusing this:\n  m2 < length xs\n  m2 < j\n  xs ! m2 = i\n\ngoal (1 subgoal):\n 1. m2 \\<in> {k. k < length xs \\<and> xs ! k = i}", "by simp"], ["proof (state)\nthis:\n  m2 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "with A_fin"], ["proof (chain)\npicking this:\n  finite {k. k < length xs \\<and> xs ! k = i}\n  m2 \\<in> {k. k < length xs \\<and> xs ! k = i}", "have \"m1 \\<le> m2\""], ["proof (prove)\nusing this:\n  finite {k. k < length xs \\<and> xs ! k = i}\n  m2 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. m1 \\<le> m2", "unfolding m1_def"], ["proof (prove)\nusing this:\n  finite {k. k < length xs \\<and> xs ! k = i}\n  m2 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. Min {k. k < length xs \\<and> xs ! k = i} \\<le> m2", "by (rule Min_le)"], ["proof (state)\nthis:\n  m1 \\<le> m2\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "with \\<open>m2 < j\\<close>"], ["proof (chain)\npicking this:\n  m2 < j\n  m1 \\<le> m2", "have \"m1 < j\""], ["proof (prove)\nusing this:\n  m2 < j\n  m1 \\<le> m2\n\ngoal (1 subgoal):\n 1. m1 < j", "by simp"], ["proof (state)\nthis:\n  m1 < j\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "with \\<open>m1 < length xs\\<close> \\<open>xs ! m1 = i\\<close>"], ["proof (chain)\npicking this:\n  m1 < length xs\n  xs ! m1 = i\n  m1 < j", "have \"m1 \\<in> ?B\""], ["proof (prove)\nusing this:\n  m1 < length xs\n  xs ! m1 = i\n  m1 < j\n\ngoal (1 subgoal):\n 1. m1 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}", "by simp"], ["proof (state)\nthis:\n  m1 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "with B_fin"], ["proof (chain)\npicking this:\n  finite {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n  m1 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}", "have \"m2 \\<le> m1\""], ["proof (prove)\nusing this:\n  finite {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n  m1 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. m2 \\<le> m1", "unfolding m2_def"], ["proof (prove)\nusing this:\n  finite {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n  m1 \\<in> {k. k < length xs \\<and> k < j \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. Min {k. k < length xs \\<and> k < j \\<and> xs ! k = i} \\<le> m1", "by (rule Min_le)"], ["proof (state)\nthis:\n  m2 \\<le> m1\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "with \\<open>m1 \\<le> m2\\<close>"], ["proof (chain)\npicking this:\n  m1 \\<le> m2\n  m2 \\<le> m1", "have \"m1 = m2\""], ["proof (prove)\nusing this:\n  m1 \\<le> m2\n  m2 \\<le> m1\n\ngoal (1 subgoal):\n 1. m1 = m2", "by (rule le_antisym)"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal (2 subgoals):\n 1. i \\<in> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n 2. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "with True \\<open>i \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  i \\<in> set (take j xs)\n  i \\<in> set xs\n  m1 = m2", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> set (take j xs)\n  i \\<in> set xs\n  m1 = m2\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "by (simp add: lookup_pm_of_idx_pm m1_def m2_def cong: conj_cong)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n\ngoal (1 subgoal):\n 1. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "case False"], ["proof (state)\nthis:\n  i \\<notin> set (take j xs)\n\ngoal (1 subgoal):\n 1. i \\<notin> set (take j xs) \\<Longrightarrow>\n    lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> set (take j xs)\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i", "proof (simp add: lookup_pm_of_idx_pm when_def m1_def[symmetric], intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set (take j xs); i \\<notin> set (take j xs);\n     i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> lookup f m1 = (0::'a)", "assume \"i \\<in> set xs\""], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set (take j xs); i \\<notin> set (take j xs);\n     i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> lookup f m1 = (0::'a)", "hence \"m1 \\<in> ?A\""], ["proof (prove)\nusing this:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. m1 \\<in> {k. k < length xs \\<and> xs ! k = i}", "by (rule m1)"], ["proof (state)\nthis:\n  m1 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set (take j xs); i \\<notin> set (take j xs);\n     i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> lookup f m1 = (0::'a)", "hence \"m1 < length xs\" and \"xs ! m1 = i\""], ["proof (prove)\nusing this:\n  m1 \\<in> {k. k < length xs \\<and> xs ! k = i}\n\ngoal (1 subgoal):\n 1. m1 < length xs &&& xs ! m1 = i", "by simp_all"], ["proof (state)\nthis:\n  m1 < length xs\n  xs ! m1 = i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set (take j xs); i \\<notin> set (take j xs);\n     i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> lookup f m1 = (0::'a)", "have \"m1 \\<notin> keys f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<notin> keys f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m1 \\<in> keys f \\<Longrightarrow> False", "assume \"m1 \\<in> keys f\""], ["proof (state)\nthis:\n  m1 \\<in> keys f\n\ngoal (1 subgoal):\n 1. m1 \\<in> keys f \\<Longrightarrow> False", "hence \"m1 \\<in> {0..<j}\""], ["proof (prove)\nusing this:\n  m1 \\<in> keys f\n\ngoal (1 subgoal):\n 1. m1 \\<in> {0..<j}", "using assms"], ["proof (prove)\nusing this:\n  m1 \\<in> keys f\n  keys f \\<subseteq> {0..<j}\n\ngoal (1 subgoal):\n 1. m1 \\<in> {0..<j}", ".."], ["proof (state)\nthis:\n  m1 \\<in> {0..<j}\n\ngoal (1 subgoal):\n 1. m1 \\<in> keys f \\<Longrightarrow> False", "hence \"m1 < j\""], ["proof (prove)\nusing this:\n  m1 \\<in> {0..<j}\n\ngoal (1 subgoal):\n 1. m1 < j", "by simp"], ["proof (state)\nthis:\n  m1 < j\n\ngoal (1 subgoal):\n 1. m1 \\<in> keys f \\<Longrightarrow> False", "with \\<open>m1 < length xs\\<close>"], ["proof (chain)\npicking this:\n  m1 < length xs\n  m1 < j", "have \"m1 < length ?xs\""], ["proof (prove)\nusing this:\n  m1 < length xs\n  m1 < j\n\ngoal (1 subgoal):\n 1. m1 < length (take j xs)", "by simp"], ["proof (state)\nthis:\n  m1 < length (take j xs)\n\ngoal (1 subgoal):\n 1. m1 \\<in> keys f \\<Longrightarrow> False", "hence \"?xs ! m1 \\<in> set ?xs\""], ["proof (prove)\nusing this:\n  m1 < length (take j xs)\n\ngoal (1 subgoal):\n 1. take j xs ! m1 \\<in> set (take j xs)", "by (rule nth_mem)"], ["proof (state)\nthis:\n  take j xs ! m1 \\<in> set (take j xs)\n\ngoal (1 subgoal):\n 1. m1 \\<in> keys f \\<Longrightarrow> False", "with \\<open>m1 < j\\<close>"], ["proof (chain)\npicking this:\n  m1 < j\n  take j xs ! m1 \\<in> set (take j xs)", "have \"i \\<in> set ?xs\""], ["proof (prove)\nusing this:\n  m1 < j\n  take j xs ! m1 \\<in> set (take j xs)\n\ngoal (1 subgoal):\n 1. i \\<in> set (take j xs)", "by (simp add: \\<open>xs ! m1 = i\\<close>)"], ["proof (state)\nthis:\n  i \\<in> set (take j xs)\n\ngoal (1 subgoal):\n 1. m1 \\<in> keys f \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  i \\<notin> set (take j xs)\n  i \\<in> set (take j xs)", "show False"], ["proof (prove)\nusing this:\n  i \\<notin> set (take j xs)\n  i \\<in> set (take j xs)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m1 \\<notin> keys f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set (take j xs); i \\<notin> set (take j xs);\n     i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> lookup f m1 = (0::'a)", "thus \"lookup f m1 = 0\""], ["proof (prove)\nusing this:\n  m1 \\<notin> keys f\n\ngoal (1 subgoal):\n 1. lookup f m1 = (0::'a)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup f m1 = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm (take j xs) f) i = lookup (pm_of_idx_pm xs f) i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_idx_pm_of_pm: \"lookup (idx_pm_of_pm xs f) = (\\<lambda>i. lookup f (xs ! i) when i < length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (idx_pm_of_pm xs f) =\n    (\\<lambda>i. lookup f (xs ! i) when i < length xs)", "unfolding idx_pm_of_pm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping (\\<lambda>i. lookup f (xs ! i) when i < length xs)) =\n    (\\<lambda>i. lookup f (xs ! i) when i < length xs)", "by (rule Abs_poly_mapping_inverse, simp)"], ["", "lemma keys_idx_pm_of_pm_subset: \"keys (idx_pm_of_pm xs f) \\<subseteq> {0..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (idx_pm_of_pm xs f) \\<subseteq> {0..<length xs}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (idx_pm_of_pm xs f) \\<Longrightarrow>\n       x \\<in> {0..<length xs}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (idx_pm_of_pm xs f) \\<Longrightarrow>\n       x \\<in> {0..<length xs}", "assume \"i \\<in> keys (idx_pm_of_pm xs f)\""], ["proof (state)\nthis:\n  i \\<in> keys (idx_pm_of_pm xs f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (idx_pm_of_pm xs f) \\<Longrightarrow>\n       x \\<in> {0..<length xs}", "hence \"lookup (idx_pm_of_pm xs f) i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<in> keys (idx_pm_of_pm xs f)\n\ngoal (1 subgoal):\n 1. lookup (idx_pm_of_pm xs f) i \\<noteq> (0::'a)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (idx_pm_of_pm xs f) i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (idx_pm_of_pm xs f) \\<Longrightarrow>\n       x \\<in> {0..<length xs}", "thus \"i \\<in> {0..<length xs}\""], ["proof (prove)\nusing this:\n  lookup (idx_pm_of_pm xs f) i \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. i \\<in> {0..<length xs}", "by (simp add: lookup_idx_pm_of_pm)"], ["proof (state)\nthis:\n  i \\<in> {0..<length xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idx_pm_of_pm_zero [simp]: \"idx_pm_of_pm xs 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_pm_of_pm xs 0 = 0", "by (rule poly_mapping_eqI, simp add: lookup_idx_pm_of_pm)"], ["", "lemma idx_pm_of_pm_plus: \"idx_pm_of_pm xs (f + g) = idx_pm_of_pm xs f + idx_pm_of_pm xs g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_pm_of_pm xs (f + g) = idx_pm_of_pm xs f + idx_pm_of_pm xs g", "by (rule poly_mapping_eqI, simp add: lookup_idx_pm_of_pm lookup_add when_def)"], ["", "lemma idx_pm_of_pm_minus: \"idx_pm_of_pm xs (f - g) = idx_pm_of_pm xs f - idx_pm_of_pm xs g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_pm_of_pm xs (f - g) = idx_pm_of_pm xs f - idx_pm_of_pm xs g", "by (rule poly_mapping_eqI, simp add: lookup_idx_pm_of_pm lookup_minus when_def)"], ["", "lemma pm_of_idx_pm_of_pm:\n  assumes \"keys f \\<subseteq> set xs\"\n  shows \"pm_of_idx_pm xs (idx_pm_of_pm xs f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm xs (idx_pm_of_pm xs f) = f", "proof (rule poly_mapping_eqI, simp add: lookup_pm_of_idx_pm when_def, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "assume \"k \\<in> set xs\""], ["proof (state)\nthis:\n  k \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "define i where \"i = Min {i. i < length xs \\<and> xs ! i = k}\""], ["proof (state)\nthis:\n  i = Min {i. i < length xs \\<and> xs ! i = k}\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "have \"finite {i. i < length xs \\<and> xs ! i = k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. i < length xs \\<and> xs ! i = k}", "by simp"], ["proof (state)\nthis:\n  finite {i. i < length xs \\<and> xs ! i = k}\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "moreover"], ["proof (state)\nthis:\n  finite {i. i < length xs \\<and> xs ! i = k}\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "from \\<open>k \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> set xs", "have \"{i. i < length xs \\<and> xs ! i = k} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  k \\<in> set xs\n\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> xs ! i = k} \\<noteq> {}", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  {i. i < length xs \\<and> xs ! i = k} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  finite {i. i < length xs \\<and> xs ! i = k}\n  {i. i < length xs \\<and> xs ! i = k} \\<noteq> {}", "have \"i \\<in> {i. i < length xs \\<and> xs ! i = k}\""], ["proof (prove)\nusing this:\n  finite {i. i < length xs \\<and> xs ! i = k}\n  {i. i < length xs \\<and> xs ! i = k} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. i \\<in> {i. i < length xs \\<and> xs ! i = k}", "unfolding i_def"], ["proof (prove)\nusing this:\n  finite {i. i < length xs \\<and> xs ! i = k}\n  {i. i < length xs \\<and> xs ! i = k} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> xs ! i = k}\n    \\<in> {i. i < length xs \\<and> xs ! i = k}", "by (rule Min_in)"], ["proof (state)\nthis:\n  i \\<in> {i. i < length xs \\<and> xs ! i = k}\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "hence \"i < length xs\" and \"xs ! i = k\""], ["proof (prove)\nusing this:\n  i \\<in> {i. i < length xs \\<and> xs ! i = k}\n\ngoal (1 subgoal):\n 1. i < length xs &&& xs ! i = k", "by simp_all"], ["proof (state)\nthis:\n  i < length xs\n  xs ! i = k\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<in> set xs \\<Longrightarrow>\n       lookup (idx_pm_of_pm xs f)\n        (Min {i. i < length xs \\<and> xs ! i = k}) =\n       lookup f k\n 2. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "thus \"lookup (idx_pm_of_pm xs f) i = lookup f k\""], ["proof (prove)\nusing this:\n  i < length xs\n  xs ! i = k\n\ngoal (1 subgoal):\n 1. lookup (idx_pm_of_pm xs f) i = lookup f k", "by (simp add: lookup_idx_pm_of_pm)"], ["proof (state)\nthis:\n  lookup (idx_pm_of_pm xs f) i = lookup f k\n\ngoal (1 subgoal):\n 1. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "assume \"k \\<notin> set xs\""], ["proof (state)\nthis:\n  k \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>k. k \\<notin> set xs \\<Longrightarrow> lookup f k = (0::'b)", "with assms"], ["proof (chain)\npicking this:\n  keys f \\<subseteq> set xs\n  k \\<notin> set xs", "show \"lookup f k = 0\""], ["proof (prove)\nusing this:\n  keys f \\<subseteq> set xs\n  k \\<notin> set xs\n\ngoal (1 subgoal):\n 1. lookup f k = (0::'b)", "by (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  lookup f k = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idx_pm_of_pm_of_idx_pm:\n  assumes \"distinct xs\" and \"keys f \\<subseteq> {0..<length xs}\"\n  shows \"idx_pm_of_pm xs (pm_of_idx_pm xs f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_pm_of_pm xs (pm_of_idx_pm xs f) = f", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) k = lookup f k", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) k = lookup f k", "show \"lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "proof (cases \"i < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i\n 2. \\<not> i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "case True"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i\n 2. \\<not> i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "with assms(1)"], ["proof (chain)\npicking this:\n  distinct xs\n  i < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "by (simp add: lookup_idx_pm_of_pm lookup_pm_of_idx_pm_distinct)"], ["proof (state)\nthis:\n  lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "case False"], ["proof (state)\nthis:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "hence \"i \\<notin> {0..<length xs}\""], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. i \\<notin> {0..<length xs}", "by simp"], ["proof (state)\nthis:\n  i \\<notin> {0..<length xs}\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "with assms(2)"], ["proof (chain)\npicking this:\n  keys f \\<subseteq> {0..<length xs}\n  i \\<notin> {0..<length xs}", "have \"i \\<notin> keys f\""], ["proof (prove)\nusing this:\n  keys f \\<subseteq> {0..<length xs}\n  i \\<notin> {0..<length xs}\n\ngoal (1 subgoal):\n 1. i \\<notin> keys f", "by blast"], ["proof (state)\nthis:\n  i \\<notin> keys f\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow>\n    lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "with False"], ["proof (chain)\npicking this:\n  \\<not> i < length xs\n  i \\<notin> keys f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n  i \\<notin> keys f\n\ngoal (1 subgoal):\n 1. lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i", "by (simp add: in_keys_iff lookup_idx_pm_of_pm)"], ["proof (state)\nthis:\n  lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (idx_pm_of_pm xs (pm_of_idx_pm xs f)) i = lookup f i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>POT Orders\\<close>"], ["", "context ordered_term\nbegin"], ["", "definition is_pot_ord :: bool\n  where \"is_pot_ord \\<longleftrightarrow> (\\<forall>u v. component_of_term u < component_of_term v \\<longrightarrow> u \\<prec>\\<^sub>t v)\""], ["", "lemma is_pot_ordI:\n  assumes \"\\<And>u v. component_of_term u < component_of_term v \\<Longrightarrow> u \\<prec>\\<^sub>t v\"\n  shows \"is_pot_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pot_ord", "unfolding is_pot_ord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v.\n       component_of_term u < component_of_term v \\<longrightarrow>\n       u \\<prec>\\<^sub>t v", "using assms"], ["proof (prove)\nusing this:\n  component_of_term ?u29 < component_of_term ?v29 \\<Longrightarrow>\n  ?u29 \\<prec>\\<^sub>t ?v29\n\ngoal (1 subgoal):\n 1. \\<forall>u v.\n       component_of_term u < component_of_term v \\<longrightarrow>\n       u \\<prec>\\<^sub>t v", "by blast"], ["", "lemma is_pot_ordD:\n  assumes \"is_pot_ord\" and \"component_of_term u < component_of_term v\"\n  shows \"u \\<prec>\\<^sub>t v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<prec>\\<^sub>t v", "using assms"], ["proof (prove)\nusing this:\n  is_pot_ord\n  component_of_term u < component_of_term v\n\ngoal (1 subgoal):\n 1. u \\<prec>\\<^sub>t v", "unfolding is_pot_ord_def"], ["proof (prove)\nusing this:\n  \\<forall>u v.\n     component_of_term u < component_of_term v \\<longrightarrow>\n     u \\<prec>\\<^sub>t v\n  component_of_term u < component_of_term v\n\ngoal (1 subgoal):\n 1. u \\<prec>\\<^sub>t v", "by blast"], ["", "lemma is_pot_ordD2:\n  assumes \"is_pot_ord\" and \"u \\<preceq>\\<^sub>t v\"\n  shows \"component_of_term u \\<le> component_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term u \\<le> component_of_term v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> component_of_term u \\<le> component_of_term v \\<Longrightarrow>\n    False", "assume \"\\<not> component_of_term u \\<le> component_of_term v\""], ["proof (state)\nthis:\n  \\<not> component_of_term u \\<le> component_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> component_of_term u \\<le> component_of_term v \\<Longrightarrow>\n    False", "hence \"component_of_term v < component_of_term u\""], ["proof (prove)\nusing this:\n  \\<not> component_of_term u \\<le> component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term v < component_of_term u", "by simp"], ["proof (state)\nthis:\n  component_of_term v < component_of_term u\n\ngoal (1 subgoal):\n 1. \\<not> component_of_term u \\<le> component_of_term v \\<Longrightarrow>\n    False", "with assms(1)"], ["proof (chain)\npicking this:\n  is_pot_ord\n  component_of_term v < component_of_term u", "have \"v \\<prec>\\<^sub>t u\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  component_of_term v < component_of_term u\n\ngoal (1 subgoal):\n 1. v \\<prec>\\<^sub>t u", "by (rule is_pot_ordD)"], ["proof (state)\nthis:\n  v \\<prec>\\<^sub>t u\n\ngoal (1 subgoal):\n 1. \\<not> component_of_term u \\<le> component_of_term v \\<Longrightarrow>\n    False", "with assms(2)"], ["proof (chain)\npicking this:\n  u \\<preceq>\\<^sub>t v\n  v \\<prec>\\<^sub>t u", "show False"], ["proof (prove)\nusing this:\n  u \\<preceq>\\<^sub>t v\n  v \\<prec>\\<^sub>t u\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_pot_ord:\n  assumes \"is_pot_ord\"\n  shows \"u \\<preceq>\\<^sub>t v \\<longleftrightarrow> (component_of_term u < component_of_term v \\<or>\n                    (component_of_term u = component_of_term v \\<and> pp_of_term u \\<preceq> pp_of_term v))\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<preceq>\\<^sub>t v) =\n    (component_of_term u < component_of_term v \\<or>\n     component_of_term u = component_of_term v \\<and>\n     pp_of_term u \\<preceq> pp_of_term v)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<preceq>\\<^sub>t v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v\n 2. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "assume ?l"], ["proof (state)\nthis:\n  u \\<preceq>\\<^sub>t v\n\ngoal (2 subgoals):\n 1. u \\<preceq>\\<^sub>t v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v\n 2. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "with assms"], ["proof (chain)\npicking this:\n  is_pot_ord\n  u \\<preceq>\\<^sub>t v", "have \"component_of_term u \\<le> component_of_term v\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  u \\<preceq>\\<^sub>t v\n\ngoal (1 subgoal):\n 1. component_of_term u \\<le> component_of_term v", "by (rule is_pot_ordD2)"], ["proof (state)\nthis:\n  component_of_term u \\<le> component_of_term v\n\ngoal (2 subgoals):\n 1. u \\<preceq>\\<^sub>t v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v\n 2. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "hence \"component_of_term u < component_of_term v \\<or> component_of_term u = component_of_term v\""], ["proof (prove)\nusing this:\n  component_of_term u \\<le> component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v", "by (simp add: order_class.le_less)"], ["proof (state)\nthis:\n  component_of_term u < component_of_term v \\<or>\n  component_of_term u = component_of_term v\n\ngoal (2 subgoals):\n 1. u \\<preceq>\\<^sub>t v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v\n 2. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "thus ?r"], ["proof (prove)\nusing this:\n  component_of_term u < component_of_term v \\<or>\n  component_of_term u = component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. component_of_term u < component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v\n 2. component_of_term u = component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "assume \"component_of_term u < component_of_term v\""], ["proof (state)\nthis:\n  component_of_term u < component_of_term v\n\ngoal (2 subgoals):\n 1. component_of_term u < component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v\n 2. component_of_term u = component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "thus ?r"], ["proof (prove)\nusing this:\n  component_of_term u < component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", ".."], ["proof (state)\nthis:\n  component_of_term u < component_of_term v \\<or>\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "assume 1: \"component_of_term u = component_of_term v\""], ["proof (state)\nthis:\n  component_of_term u = component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "moreover"], ["proof (state)\nthis:\n  component_of_term u = component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "have \"pp_of_term u \\<preceq> pp_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term u \\<preceq> pp_of_term v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow> False", "assume \"\\<not> pp_of_term u \\<preceq> pp_of_term v\""], ["proof (state)\nthis:\n  \\<not> pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow> False", "hence 2: \"pp_of_term v \\<preceq> pp_of_term u\" and 3: \"pp_of_term u \\<noteq> pp_of_term v\""], ["proof (prove)\nusing this:\n  \\<not> pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. pp_of_term v \\<preceq> pp_of_term u &&&\n    pp_of_term u \\<noteq> pp_of_term v", "by simp_all"], ["proof (state)\nthis:\n  pp_of_term v \\<preceq> pp_of_term u\n  pp_of_term u \\<noteq> pp_of_term v\n\ngoal (1 subgoal):\n 1. \\<not> pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow> False", "from 1"], ["proof (chain)\npicking this:\n  component_of_term u = component_of_term v", "have \"component_of_term v \\<le> component_of_term u\""], ["proof (prove)\nusing this:\n  component_of_term u = component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term v \\<le> component_of_term u", "by simp"], ["proof (state)\nthis:\n  component_of_term v \\<le> component_of_term u\n\ngoal (1 subgoal):\n 1. \\<not> pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow> False", "with 2"], ["proof (chain)\npicking this:\n  pp_of_term v \\<preceq> pp_of_term u\n  component_of_term v \\<le> component_of_term u", "have \"v \\<preceq>\\<^sub>t u\""], ["proof (prove)\nusing this:\n  pp_of_term v \\<preceq> pp_of_term u\n  component_of_term v \\<le> component_of_term u\n\ngoal (1 subgoal):\n 1. v \\<preceq>\\<^sub>t u", "by (rule ord_termI)"], ["proof (state)\nthis:\n  v \\<preceq>\\<^sub>t u\n\ngoal (1 subgoal):\n 1. \\<not> pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow> False", "with \\<open>?l\\<close>"], ["proof (chain)\npicking this:\n  u \\<preceq>\\<^sub>t v\n  v \\<preceq>\\<^sub>t u", "have \"u = v\""], ["proof (prove)\nusing this:\n  u \\<preceq>\\<^sub>t v\n  v \\<preceq>\\<^sub>t u\n\ngoal (1 subgoal):\n 1. u = v", "by simp"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. \\<not> pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow> False", "with 3"], ["proof (chain)\npicking this:\n  pp_of_term u \\<noteq> pp_of_term v\n  u = v", "show False"], ["proof (prove)\nusing this:\n  pp_of_term u \\<noteq> pp_of_term v\n  u = v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<Longrightarrow>\n    component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "ultimately"], ["proof (chain)\npicking this:\n  component_of_term u = component_of_term v\n  pp_of_term u \\<preceq> pp_of_term v", "show ?r"], ["proof (prove)\nusing this:\n  component_of_term u = component_of_term v\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v", "by simp"], ["proof (state)\nthis:\n  component_of_term u < component_of_term v \\<or>\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component_of_term u < component_of_term v \\<or>\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "assume ?r"], ["proof (state)\nthis:\n  component_of_term u < component_of_term v \\<or>\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u < component_of_term v \\<or>\n    component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "thus ?l"], ["proof (prove)\nusing this:\n  component_of_term u < component_of_term v \\<or>\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. u \\<preceq>\\<^sub>t v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. component_of_term u < component_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v\n 2. component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "assume \"component_of_term u < component_of_term v\""], ["proof (state)\nthis:\n  component_of_term u < component_of_term v\n\ngoal (2 subgoals):\n 1. component_of_term u < component_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v\n 2. component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "with assms"], ["proof (chain)\npicking this:\n  is_pot_ord\n  component_of_term u < component_of_term v", "have \"u \\<prec>\\<^sub>t v\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  component_of_term u < component_of_term v\n\ngoal (1 subgoal):\n 1. u \\<prec>\\<^sub>t v", "by (rule is_pot_ordD)"], ["proof (state)\nthis:\n  u \\<prec>\\<^sub>t v\n\ngoal (2 subgoals):\n 1. component_of_term u < component_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v\n 2. component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "thus ?l"], ["proof (prove)\nusing this:\n  u \\<prec>\\<^sub>t v\n\ngoal (1 subgoal):\n 1. u \\<preceq>\\<^sub>t v", "by simp"], ["proof (state)\nthis:\n  u \\<preceq>\\<^sub>t v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "assume \"component_of_term u = component_of_term v \\<and> pp_of_term u \\<preceq> pp_of_term v\""], ["proof (state)\nthis:\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "hence \"pp_of_term u \\<preceq> pp_of_term v\" and \"component_of_term u \\<le> component_of_term v\""], ["proof (prove)\nusing this:\n  component_of_term u = component_of_term v \\<and>\n  pp_of_term u \\<preceq> pp_of_term v\n\ngoal (1 subgoal):\n 1. pp_of_term u \\<preceq> pp_of_term v &&&\n    component_of_term u \\<le> component_of_term v", "by simp_all"], ["proof (state)\nthis:\n  pp_of_term u \\<preceq> pp_of_term v\n  component_of_term u \\<le> component_of_term v\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v \\<and>\n    pp_of_term u \\<preceq> pp_of_term v \\<Longrightarrow>\n    u \\<preceq>\\<^sub>t v", "thus ?l"], ["proof (prove)\nusing this:\n  pp_of_term u \\<preceq> pp_of_term v\n  component_of_term u \\<le> component_of_term v\n\ngoal (1 subgoal):\n 1. u \\<preceq>\\<^sub>t v", "by (rule ord_termI)"], ["proof (state)\nthis:\n  u \\<preceq>\\<^sub>t v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<preceq>\\<^sub>t v\n\ngoal:\nNo subgoals!", "qed"], ["", "definition map_component :: \"('k \\<Rightarrow> 'k) \\<Rightarrow> 't \\<Rightarrow> 't\"\n  where \"map_component f v = term_of_pair (pp_of_term v, f (component_of_term v))\""], ["", "lemma pair_of_map_component [term_simps]:\n  \"pair_of_term (map_component f v) = (pp_of_term v, f (component_of_term v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_of_term (map_component f v) =\n    (pp_of_term v, f (component_of_term v))", "by (simp add: map_component_def pair_term)"], ["", "lemma pp_of_map_component [term_simps]: \"pp_of_term (map_component f v) = pp_of_term v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term (map_component f v) = pp_of_term v", "by (simp add: pp_of_term_def pair_of_map_component)"], ["", "lemma component_of_map_component [term_simps]:\n  \"component_of_term (map_component f v) = f (component_of_term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term (map_component f v) = f (component_of_term v)", "by (simp add: component_of_term_def pair_of_map_component)"], ["", "lemma map_component_term_of_pair [term_simps]:\n  \"map_component f (term_of_pair (t, k)) = term_of_pair (t, f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_component f (term_of_pair (t, k)) = term_of_pair (t, f k)", "by (simp add: map_component_def term_simps)"], ["", "lemma map_component_comp: \"map_component f (map_component g x) = map_component (\\<lambda>k. f (g k)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_component f (map_component g x) =\n    map_component (\\<lambda>k. f (g k)) x", "by (simp add: map_component_def term_simps)"], ["", "lemma map_component_id [term_simps]: \"map_component (\\<lambda>k. k) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k) x = x", "by (simp add: map_component_def term_simps)"], ["", "lemma map_component_inj:\n  assumes \"inj f\" and \"map_component f u = map_component f v\"\n  shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v", "from assms(2)"], ["proof (chain)\npicking this:\n  map_component f u = map_component f v", "have \"term_of_pair (pp_of_term u, f (component_of_term u)) =\n                      term_of_pair (pp_of_term v, f (component_of_term v))\""], ["proof (prove)\nusing this:\n  map_component f u = map_component f v\n\ngoal (1 subgoal):\n 1. term_of_pair (pp_of_term u, f (component_of_term u)) =\n    term_of_pair (pp_of_term v, f (component_of_term v))", "by (simp only: map_component_def)"], ["proof (state)\nthis:\n  term_of_pair (pp_of_term u, f (component_of_term u)) =\n  term_of_pair (pp_of_term v, f (component_of_term v))\n\ngoal (1 subgoal):\n 1. u = v", "hence \"(pp_of_term u, f (component_of_term u)) = (pp_of_term v, f (component_of_term v))\""], ["proof (prove)\nusing this:\n  term_of_pair (pp_of_term u, f (component_of_term u)) =\n  term_of_pair (pp_of_term v, f (component_of_term v))\n\ngoal (1 subgoal):\n 1. (pp_of_term u, f (component_of_term u)) =\n    (pp_of_term v, f (component_of_term v))", "by (rule term_of_pair_injective)"], ["proof (state)\nthis:\n  (pp_of_term u, f (component_of_term u)) =\n  (pp_of_term v, f (component_of_term v))\n\ngoal (1 subgoal):\n 1. u = v", "hence 1: \"pp_of_term u = pp_of_term v\" and \"f (component_of_term u) = f (component_of_term v)\""], ["proof (prove)\nusing this:\n  (pp_of_term u, f (component_of_term u)) =\n  (pp_of_term v, f (component_of_term v))\n\ngoal (1 subgoal):\n 1. pp_of_term u = pp_of_term v &&&\n    f (component_of_term u) = f (component_of_term v)", "by simp_all"], ["proof (state)\nthis:\n  pp_of_term u = pp_of_term v\n  f (component_of_term u) = f (component_of_term v)\n\ngoal (1 subgoal):\n 1. u = v", "from assms(1) this(2)"], ["proof (chain)\npicking this:\n  inj f\n  f (component_of_term u) = f (component_of_term v)", "have \"component_of_term u = component_of_term v\""], ["proof (prove)\nusing this:\n  inj f\n  f (component_of_term u) = f (component_of_term v)\n\ngoal (1 subgoal):\n 1. component_of_term u = component_of_term v", "by (rule injD)"], ["proof (state)\nthis:\n  component_of_term u = component_of_term v\n\ngoal (1 subgoal):\n 1. u = v", "with 1"], ["proof (chain)\npicking this:\n  pp_of_term u = pp_of_term v\n  component_of_term u = component_of_term v", "show ?thesis"], ["proof (prove)\nusing this:\n  pp_of_term u = pp_of_term v\n  component_of_term u = component_of_term v\n\ngoal (1 subgoal):\n 1. u = v", "by (metis term_of_pair_pair)"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* ordered_term *)"], ["", "subsection \\<open>Gr\\\"obner Bases of Syzygy Modules\\<close>"], ["", "locale gd_inf_term =\n    gd_term pair_of_term term_of_pair ord ord_strict ord_term ord_term_strict\n      for pair_of_term::\"'t \\<Rightarrow> ('a::graded_dickson_powerprod \\<times> nat)\"\n      and term_of_pair::\"('a \\<times> nat) \\<Rightarrow> 't\"\n      and ord::\"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infixl \"\\<preceq>\" 50)\n      and ord_strict (infixl \"\\<prec>\" 50)\n      and ord_term::\"'t \\<Rightarrow> 't \\<Rightarrow> bool\" (infixl \"\\<preceq>\\<^sub>t\" 50)\n      and ord_term_strict::\"'t \\<Rightarrow> 't \\<Rightarrow> bool\" (infixl \"\\<prec>\\<^sub>t\" 50)\nbegin"], ["", "text \\<open>In order to compute a Gr\\\"obner basis of the syzygy module of a list \\<open>bs\\<close> of polynomials, one\n  first needs to ``lift'' \\<open>bs\\<close> to a new list \\<open>bs'\\<close> by adding further components, compute a Gr\\\"obner\n  basis \\<open>gs\\<close> of \\<open>bs'\\<close>, and then filter out those elements of \\<open>gs\\<close> whose only non-zero components are\n  those that were newly added to \\<open>bs\\<close>.\n  Function \\<open>init_syzygy_list\\<close> takes care of constructing \\<open>bs'\\<close>, and function \\<open>filter_syzygy_basis\\<close>\n  does the filtering. Function \\<open>proj_orig_basis\\<close>, finally, projects the Gr\\\"obner basis \\<open>gs\\<close> of \\<open>bs'\\<close>\n  to a Gr\\\"obner basis of the original list \\<open>bs\\<close>.\\<close>"], ["", "definition lift_poly_syz :: \"nat \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> nat \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::semiring_1)\"\n  where \"lift_poly_syz n b i = Abs_poly_mapping\n              (\\<lambda>x. if pair_of_term x = (0, i) then 1\n                   else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x)\n                   else 0)\""], ["", "definition proj_poly_syz :: \"nat \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::semiring_1)\"\n  where \"proj_poly_syz n b = Poly_Mapping.map_key (\\<lambda>x. map_component (\\<lambda>k. k + n) x) b\""], ["", "definition cofactor_list_syz :: \"nat \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b::semiring_1) list\"\n  where \"cofactor_list_syz n b = map (\\<lambda>i. proj_poly i b) [0..<n]\""], ["", "definition init_syzygy_list :: \"('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::semiring_1) list\"\n  where \"init_syzygy_list bs = map_idx (lift_poly_syz (length bs)) bs 0\""], ["", "definition proj_orig_basis :: \"nat \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::semiring_1) list\"\n  where \"proj_orig_basis n bs = map (proj_poly_syz n) bs\""], ["", "definition filter_syzygy_basis :: \"nat \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::semiring_1) list\"\n  where \"filter_syzygy_basis n bs = [b\\<leftarrow>bs. component_of_term ` keys b \\<subseteq> {0..<n}]\""], ["", "definition syzygy_module_list :: \"('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::comm_ring_1) set\"\n  where \"syzygy_module_list bs = atomize_poly ` idx_pm_of_pm bs ` pmdl.syzygy_module (set bs)\""], ["", "subsubsection \\<open>@{const lift_poly_syz}\\<close>"], ["", "lemma keys_lift_poly_syz_aux:\n  \"{x. (if pair_of_term x = (0, i) then 1\n        else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x)\n        else 0) \\<noteq> 0} \\<subseteq> insert (term_of_pair (0, i)) (map_component (\\<lambda>k. k + n) ` keys b)\"\n  (is \"?l \\<subseteq> ?r\") for b::\"'t \\<Rightarrow>\\<^sub>0 'b::semiring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (if pair_of_term x = (0::'a, i) then 1::'b\n         else if n \\<le> component_of_term x\n              then lookup b (map_component (\\<lambda>k. k - n) x)\n              else (0::'b)) \\<noteq>\n        (0::'b)}\n    \\<subseteq> insert (term_of_pair (0::'a, i))\n                 (map_component (\\<lambda>k. k + n) ` keys b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> insert (term_of_pair (0::'a, i))\n                (map_component (\\<lambda>k. k + n) ` keys b)", "fix x::'t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> insert (term_of_pair (0::'a, i))\n                (map_component (\\<lambda>k. k + n) ` keys b)", "assume \"x \\<in> ?l\""], ["proof (state)\nthis:\n  x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n               else if n \\<le> component_of_term x\n                    then lookup b (map_component (\\<lambda>k. k - n) x)\n                    else (0::'b)) \\<noteq>\n              (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> insert (term_of_pair (0::'a, i))\n                (map_component (\\<lambda>k. k + n) ` keys b)", "hence \"(if pair_of_term x = (0, i) then 1 else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x) else 0) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n               else if n \\<le> component_of_term x\n                    then lookup b (map_component (\\<lambda>k. k - n) x)\n                    else (0::'b)) \\<noteq>\n              (0::'b)}\n\ngoal (1 subgoal):\n 1. (if pair_of_term x = (0::'a, i) then 1::'b\n     else if n \\<le> component_of_term x\n          then lookup b (map_component (\\<lambda>k. k - n) x)\n          else (0::'b)) \\<noteq>\n    (0::'b)", "by simp"], ["proof (state)\nthis:\n  (if pair_of_term x = (0::'a, i) then 1::'b\n   else if n \\<le> component_of_term x\n        then lookup b (map_component (\\<lambda>k. k - n) x)\n        else (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> insert (term_of_pair (0::'a, i))\n                (map_component (\\<lambda>k. k + n) ` keys b)", "hence \"pair_of_term x = (0, i) \\<or> (n \\<le> component_of_term x \\<and> lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  (if pair_of_term x = (0::'a, i) then 1::'b\n   else if n \\<le> component_of_term x\n        then lookup b (map_component (\\<lambda>k. k - n) x)\n        else (0::'b)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. pair_of_term x = (0::'a, i) \\<or>\n    n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq> (0::'b)", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  pair_of_term x = (0::'a, i) \\<or>\n  n \\<le> component_of_term x \\<and>\n  lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)} \\<Longrightarrow>\n       x \\<in> insert (term_of_pair (0::'a, i))\n                (map_component (\\<lambda>k. k + n) ` keys b)", "thus \"x \\<in> ?r\""], ["proof (prove)\nusing this:\n  pair_of_term x = (0::'a, i) \\<or>\n  n \\<le> component_of_term x \\<and>\n  lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pair_of_term x = (0::'a, i) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)\n 2. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "assume \"pair_of_term x = (0, i)\""], ["proof (state)\nthis:\n  pair_of_term x = (0::'a, i)\n\ngoal (2 subgoals):\n 1. pair_of_term x = (0::'a, i) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)\n 2. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "hence \"(0, i) = pair_of_term x\""], ["proof (prove)\nusing this:\n  pair_of_term x = (0::'a, i)\n\ngoal (1 subgoal):\n 1. (0::'a, i) = pair_of_term x", "by (rule sym)"], ["proof (state)\nthis:\n  (0::'a, i) = pair_of_term x\n\ngoal (2 subgoals):\n 1. pair_of_term x = (0::'a, i) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)\n 2. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "hence \"x = term_of_pair (0, i)\""], ["proof (prove)\nusing this:\n  (0::'a, i) = pair_of_term x\n\ngoal (1 subgoal):\n 1. x = term_of_pair (0::'a, i)", "by (simp add: term_pair)"], ["proof (state)\nthis:\n  x = term_of_pair (0::'a, i)\n\ngoal (2 subgoals):\n 1. pair_of_term x = (0::'a, i) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)\n 2. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = term_of_pair (0::'a, i)\n\ngoal (1 subgoal):\n 1. x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "by simp"], ["proof (state)\nthis:\n  x \\<in> insert (term_of_pair (0::'a, i))\n           (map_component (\\<lambda>k. k + n) ` keys b)\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "assume \"n \\<le> component_of_term x \\<and> lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<le> component_of_term x \\<and>\n  lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "hence \"n \\<le> component_of_term x\" and 2: \"map_component (\\<lambda>k. k - n) x \\<in> keys b\""], ["proof (prove)\nusing this:\n  n \\<le> component_of_term x \\<and>\n  lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x &&&\n    map_component (\\<lambda>k. k - n) x \\<in> keys b", "by (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  n \\<le> component_of_term x\n  map_component (\\<lambda>k. k - n) x \\<in> keys b\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "from this(1)"], ["proof (chain)\npicking this:\n  n \\<le> component_of_term x", "have 3: \"map_component (\\<lambda>k. k - n + n) x = x\""], ["proof (prove)\nusing this:\n  n \\<le> component_of_term x\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k - n + n) x = x", "by (simp add: map_component_def term_simps)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k - n + n) x = x\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "from 2"], ["proof (chain)\npicking this:\n  map_component (\\<lambda>k. k - n) x \\<in> keys b", "have \"map_component (\\<lambda>k. k + n) (map_component (\\<lambda>k. k - n) x) \\<in> map_component (\\<lambda>k. k + n) ` keys b\""], ["proof (prove)\nusing this:\n  map_component (\\<lambda>k. k - n) x \\<in> keys b\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) (map_component (\\<lambda>k. k - n) x)\n    \\<in> map_component (\\<lambda>k. k + n) ` keys b", "by (rule imageI)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) (map_component (\\<lambda>k. k - n) x)\n  \\<in> map_component (\\<lambda>k. k + n) ` keys b\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "with 3"], ["proof (chain)\npicking this:\n  map_component (\\<lambda>k. k - n + n) x = x\n  map_component (\\<lambda>k. k + n) (map_component (\\<lambda>k. k - n) x)\n  \\<in> map_component (\\<lambda>k. k + n) ` keys b", "have \"x \\<in> map_component (\\<lambda>k. k + n) ` keys b\""], ["proof (prove)\nusing this:\n  map_component (\\<lambda>k. k - n + n) x = x\n  map_component (\\<lambda>k. k + n) (map_component (\\<lambda>k. k - n) x)\n  \\<in> map_component (\\<lambda>k. k + n) ` keys b\n\ngoal (1 subgoal):\n 1. x \\<in> map_component (\\<lambda>k. k + n) ` keys b", "by (simp add: map_component_comp)"], ["proof (state)\nthis:\n  x \\<in> map_component (\\<lambda>k. k + n) ` keys b\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term x \\<and>\n    lookup b (map_component (\\<lambda>k. k - n) x) \\<noteq>\n    (0::'b) \\<Longrightarrow>\n    x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> map_component (\\<lambda>k. k + n) ` keys b\n\ngoal (1 subgoal):\n 1. x \\<in> insert (term_of_pair (0::'a, i))\n             (map_component (\\<lambda>k. k + n) ` keys b)", "by simp"], ["proof (state)\nthis:\n  x \\<in> insert (term_of_pair (0::'a, i))\n           (map_component (\\<lambda>k. k + n) ` keys b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> insert (term_of_pair (0::'a, i))\n           (map_component (\\<lambda>k. k + n) ` keys b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_lift_poly_syz:\n  \"lookup (lift_poly_syz n b i) =\n    (\\<lambda>x. if pair_of_term x = (0, i) then 1 else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_syz n b i) =\n    (\\<lambda>x.\n        if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b))", "unfolding lift_poly_syz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Abs_poly_mapping\n       (\\<lambda>x.\n           if pair_of_term x = (0::'a, i) then 1::'b\n           else if n \\<le> component_of_term x\n                then lookup b (map_component (\\<lambda>k. k - n) x)\n                else (0::'b))) =\n    (\\<lambda>x.\n        if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b))", "proof (rule Abs_poly_mapping_inverse)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "from finite_keys"], ["proof (chain)\npicking this:\n  finite (keys ?f)", "have \"finite (map_component (\\<lambda>k. k + n) ` keys b)\""], ["proof (prove)\nusing this:\n  finite (keys ?f)\n\ngoal (1 subgoal):\n 1. finite (map_component (\\<lambda>k. k + n) ` keys b)", ".."], ["proof (state)\nthis:\n  finite (map_component (\\<lambda>k. k + n) ` keys b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "hence \"finite (insert (term_of_pair (0, i)) (map_component (\\<lambda>k. k + n) ` keys b))\""], ["proof (prove)\nusing this:\n  finite (map_component (\\<lambda>k. k + n) ` keys b)\n\ngoal (1 subgoal):\n 1. finite\n     (insert (term_of_pair (0::'a, i))\n       (map_component (\\<lambda>k. k + n) ` keys b))", "by (rule finite.insertI)"], ["proof (state)\nthis:\n  finite\n   (insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "with keys_lift_poly_syz_aux"], ["proof (chain)\npicking this:\n  {x. (if pair_of_term x = (0::'a, ?i) then 1::?'b\n       else if ?n \\<le> component_of_term x\n            then lookup ?b (map_component (\\<lambda>k. k - ?n) x)\n            else (0::?'b)) \\<noteq>\n      (0::?'b)}\n  \\<subseteq> insert (term_of_pair (0::'a, ?i))\n               (map_component (\\<lambda>k. k + ?n) ` keys ?b)\n  finite\n   (insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b))", "have \"finite {x. (if pair_of_term x = (0, i) then 1\n                    else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x)\n                    else 0) \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {x. (if pair_of_term x = (0::'a, ?i) then 1::?'b\n       else if ?n \\<le> component_of_term x\n            then lookup ?b (map_component (\\<lambda>k. k - ?n) x)\n            else (0::?'b)) \\<noteq>\n      (0::?'b)}\n  \\<subseteq> insert (term_of_pair (0::'a, ?i))\n               (map_component (\\<lambda>k. k + ?n) ` keys ?b)\n  finite\n   (insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b))\n\ngoal (1 subgoal):\n 1. finite\n     {x. (if pair_of_term x = (0::'a, i) then 1::'b\n          else if n \\<le> component_of_term x\n               then lookup b (map_component (\\<lambda>k. k - n) x)\n               else (0::'b)) \\<noteq>\n         (0::'b)}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {x. (if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b)) \\<noteq>\n       (0::'b)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "thus \"(\\<lambda>x. if pair_of_term x = (0, i) then 1\n              else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x)\n              else 0) \\<in>\n          {f. finite {x. f x \\<noteq> 0}}\""], ["proof (prove)\nusing this:\n  finite\n   {x. (if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b)) \\<noteq>\n       (0::'b)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if pair_of_term x = (0::'a, i) then 1::'b\n        else if n \\<le> component_of_term x\n             then lookup b (map_component (\\<lambda>k. k - n) x)\n             else (0::'b))\n    \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      if pair_of_term x = (0::'a, i) then 1::'b\n      else if n \\<le> component_of_term x\n           then lookup b (map_component (\\<lambda>k. k - n) x) else (0::'b))\n  \\<in> {f. finite {x. f x \\<noteq> (0::'b)}}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lookup_lift_poly_syz_alt:\n  \"lookup (lift_poly_syz n b i) (term_of_pair (t, j)) =\n          (if (t, j) = (0, i) then 1 else if n \\<le> j then lookup b (term_of_pair (t, j - n)) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_syz n b i) (term_of_pair (t, j)) =\n    (if (t, j) = (0::'a, i) then 1::'b\n     else if n \\<le> j then lookup b (term_of_pair (t, j - n)) else (0::'b))", "by (simp only: lookup_lift_poly_syz term_simps)"], ["", "lemma keys_lift_poly_syz:\n  \"keys (lift_poly_syz n b i) = insert (term_of_pair (0, i)) (map_component (\\<lambda>k. k + n) ` keys b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (lift_poly_syz n b i) =\n    insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (lift_poly_syz n b i)\n    \\<subseteq> insert (term_of_pair (0::'a, i))\n                 (map_component (\\<lambda>k. k + n) ` keys b)\n 2. insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)\n    \\<subseteq> keys (lift_poly_syz n b i)", "have \"keys (lift_poly_syz n b i) \\<subseteq>\n          {x. (if pair_of_term x = (0, i) then 1\n              else if n \\<le> component_of_term x then lookup b (map_component (\\<lambda>k. k - n) x)\n              else 0) \\<noteq> 0}\"\n    (is \"_ \\<subseteq> ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (lift_poly_syz n b i)\n    \\<subseteq> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                     else if n \\<le> component_of_term x\n                          then lookup b\n                                (map_component (\\<lambda>k. k - n) x)\n                          else (0::'b)) \\<noteq>\n                    (0::'b)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (lift_poly_syz n b i) \\<Longrightarrow>\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (lift_poly_syz n b i) \\<Longrightarrow>\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)}", "assume \"x \\<in> keys (lift_poly_syz n b i)\""], ["proof (state)\nthis:\n  x \\<in> keys (lift_poly_syz n b i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (lift_poly_syz n b i) \\<Longrightarrow>\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)}", "hence \"lookup (lift_poly_syz n b i) x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys (lift_poly_syz n b i)\n\ngoal (1 subgoal):\n 1. lookup (lift_poly_syz n b i) x \\<noteq> (0::'b)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  lookup (lift_poly_syz n b i) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> keys (lift_poly_syz n b i) \\<Longrightarrow>\n       x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                    else if n \\<le> component_of_term x\n                         then lookup b (map_component (\\<lambda>k. k - n) x)\n                         else (0::'b)) \\<noteq>\n                   (0::'b)}", "thus \"x \\<in> ?A\""], ["proof (prove)\nusing this:\n  lookup (lift_poly_syz n b i) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                 else if n \\<le> component_of_term x\n                      then lookup b (map_component (\\<lambda>k. k - n) x)\n                      else (0::'b)) \\<noteq>\n                (0::'b)}", "by (simp add: lookup_lift_poly_syz)"], ["proof (state)\nthis:\n  x \\<in> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n               else if n \\<le> component_of_term x\n                    then lookup b (map_component (\\<lambda>k. k - n) x)\n                    else (0::'b)) \\<noteq>\n              (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  keys (lift_poly_syz n b i)\n  \\<subseteq> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                   else if n \\<le> component_of_term x\n                        then lookup b (map_component (\\<lambda>k. k - n) x)\n                        else (0::'b)) \\<noteq>\n                  (0::'b)}\n\ngoal (2 subgoals):\n 1. keys (lift_poly_syz n b i)\n    \\<subseteq> insert (term_of_pair (0::'a, i))\n                 (map_component (\\<lambda>k. k + n) ` keys b)\n 2. insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)\n    \\<subseteq> keys (lift_poly_syz n b i)", "also"], ["proof (state)\nthis:\n  keys (lift_poly_syz n b i)\n  \\<subseteq> {x. (if pair_of_term x = (0::'a, i) then 1::'b\n                   else if n \\<le> component_of_term x\n                        then lookup b (map_component (\\<lambda>k. k - n) x)\n                        else (0::'b)) \\<noteq>\n                  (0::'b)}\n\ngoal (2 subgoals):\n 1. keys (lift_poly_syz n b i)\n    \\<subseteq> insert (term_of_pair (0::'a, i))\n                 (map_component (\\<lambda>k. k + n) ` keys b)\n 2. insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)\n    \\<subseteq> keys (lift_poly_syz n b i)", "note keys_lift_poly_syz_aux"], ["proof (state)\nthis:\n  {x. (if pair_of_term x = (0::'a, ?i) then 1::?'b\n       else if ?n \\<le> component_of_term x\n            then lookup ?b (map_component (\\<lambda>k. k - ?n) x)\n            else (0::?'b)) \\<noteq>\n      (0::?'b)}\n  \\<subseteq> insert (term_of_pair (0::'a, ?i))\n               (map_component (\\<lambda>k. k + ?n) ` keys ?b)\n\ngoal (2 subgoals):\n 1. keys (lift_poly_syz n b i)\n    \\<subseteq> insert (term_of_pair (0::'a, i))\n                 (map_component (\\<lambda>k. k + n) ` keys b)\n 2. insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)\n    \\<subseteq> keys (lift_poly_syz n b i)", "finally"], ["proof (chain)\npicking this:\n  keys (lift_poly_syz n b i)\n  \\<subseteq> insert (term_of_pair (0::'a, i))\n               (map_component (\\<lambda>k. k + n) ` keys b)", "show \"keys (lift_poly_syz n b i) \\<subseteq> insert (term_of_pair (0, i)) (map_component (\\<lambda>k. k + n) ` keys b)\""], ["proof (prove)\nusing this:\n  keys (lift_poly_syz n b i)\n  \\<subseteq> insert (term_of_pair (0::'a, i))\n               (map_component (\\<lambda>k. k + n) ` keys b)\n\ngoal (1 subgoal):\n 1. keys (lift_poly_syz n b i)\n    \\<subseteq> insert (term_of_pair (0::'a, i))\n                 (map_component (\\<lambda>k. k + n) ` keys b)", "."], ["proof (state)\nthis:\n  keys (lift_poly_syz n b i)\n  \\<subseteq> insert (term_of_pair (0::'a, i))\n               (map_component (\\<lambda>k. k + n) ` keys b)\n\ngoal (1 subgoal):\n 1. insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)\n    \\<subseteq> keys (lift_poly_syz n b i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)\n    \\<subseteq> keys (lift_poly_syz n b i)", "show \"insert (term_of_pair (0, i)) (map_component (\\<lambda>k. k + n) ` keys b) \\<subseteq> keys (lift_poly_syz n b i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (term_of_pair (0::'a, i))\n     (map_component (\\<lambda>k. k + n) ` keys b)\n    \\<subseteq> keys (lift_poly_syz n b i)", "proof (simp, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. term_of_pair (0::'a, i) \\<in> keys (lift_poly_syz n b i)\n 2. map_component (\\<lambda>k. k + n) ` keys b\n    \\<subseteq> keys (lift_poly_syz n b i)", "have \"lookup (lift_poly_syz n b i) (term_of_pair (0, i)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lift_poly_syz n b i) (term_of_pair (0::'a, i)) \\<noteq> (0::'b)", "by (simp add: lookup_lift_poly_syz_alt)"], ["proof (state)\nthis:\n  lookup (lift_poly_syz n b i) (term_of_pair (0::'a, i)) \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. term_of_pair (0::'a, i) \\<in> keys (lift_poly_syz n b i)\n 2. map_component (\\<lambda>k. k + n) ` keys b\n    \\<subseteq> keys (lift_poly_syz n b i)", "thus \"term_of_pair (0, i) \\<in> keys (lift_poly_syz n b i)\""], ["proof (prove)\nusing this:\n  lookup (lift_poly_syz n b i) (term_of_pair (0::'a, i)) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. term_of_pair (0::'a, i) \\<in> keys (lift_poly_syz n b i)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  term_of_pair (0::'a, i) \\<in> keys (lift_poly_syz n b i)\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) ` keys b\n    \\<subseteq> keys (lift_poly_syz n b i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) ` keys b\n    \\<subseteq> keys (lift_poly_syz n b i)", "show \"map_component (\\<lambda>k. k + n) ` keys b \\<subseteq> keys (lift_poly_syz n b i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) ` keys b\n    \\<subseteq> keys (lift_poly_syz n b i)", "proof (rule, elim imageE, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = map_component (\\<lambda>k. k + n) xa;\n        xa \\<in> keys b\\<rbrakk>\n       \\<Longrightarrow> map_component (\\<lambda>k. k + n) xa\n                         \\<in> keys (lift_poly_syz n b i)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = map_component (\\<lambda>k. k + n) xa;\n        xa \\<in> keys b\\<rbrakk>\n       \\<Longrightarrow> map_component (\\<lambda>k. k + n) xa\n                         \\<in> keys (lift_poly_syz n b i)", "assume \"x \\<in> keys b\""], ["proof (state)\nthis:\n  x \\<in> keys b\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = map_component (\\<lambda>k. k + n) xa;\n        xa \\<in> keys b\\<rbrakk>\n       \\<Longrightarrow> map_component (\\<lambda>k. k + n) xa\n                         \\<in> keys (lift_poly_syz n b i)", "hence \"lookup (lift_poly_syz n b i) (map_component (\\<lambda>k. k + n) x) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<in> keys b\n\ngoal (1 subgoal):\n 1. lookup (lift_poly_syz n b i)\n     (map_component (\\<lambda>k. k + n) x) \\<noteq>\n    (0::'b)", "by (simp add: in_keys_iff lookup_lift_poly_syz_alt map_component_def term_simps)"], ["proof (state)\nthis:\n  lookup (lift_poly_syz n b i)\n   (map_component (\\<lambda>k. k + n) x) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x = map_component (\\<lambda>k. k + n) xa;\n        xa \\<in> keys b\\<rbrakk>\n       \\<Longrightarrow> map_component (\\<lambda>k. k + n) xa\n                         \\<in> keys (lift_poly_syz n b i)", "thus \"map_component (\\<lambda>k. k + n) x \\<in> keys (lift_poly_syz n b i)\""], ["proof (prove)\nusing this:\n  lookup (lift_poly_syz n b i)\n   (map_component (\\<lambda>k. k + n) x) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) x \\<in> keys (lift_poly_syz n b i)", "by (simp add: in_keys_iff)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) x \\<in> keys (lift_poly_syz n b i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) ` keys b\n  \\<subseteq> keys (lift_poly_syz n b i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert (term_of_pair (0::'a, i))\n   (map_component (\\<lambda>k. k + n) ` keys b)\n  \\<subseteq> keys (lift_poly_syz n b i)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const proj_poly_syz}\\<close>"], ["", "lemma inj_map_component_plus: \"inj (map_component (\\<lambda>k. k + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (map_component (\\<lambda>k. k + n))", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       map_component (\\<lambda>k. k + n) x =\n       map_component (\\<lambda>k. k + n) y \\<Longrightarrow>\n       x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       map_component (\\<lambda>k. k + n) x =\n       map_component (\\<lambda>k. k + n) y \\<Longrightarrow>\n       x = y", "have \"inj (\\<lambda>k::nat. k + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>k. k + n)", "by (simp add: inj_def)"], ["proof (state)\nthis:\n  inj (\\<lambda>k. k + n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       map_component (\\<lambda>k. k + n) x =\n       map_component (\\<lambda>k. k + n) y \\<Longrightarrow>\n       x = y", "moreover"], ["proof (state)\nthis:\n  inj (\\<lambda>k. k + n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       map_component (\\<lambda>k. k + n) x =\n       map_component (\\<lambda>k. k + n) y \\<Longrightarrow>\n       x = y", "assume \"map_component (\\<lambda>k. k + n) x = map_component (\\<lambda>k. k + n) y\""], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) x = map_component (\\<lambda>k. k + n) y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       map_component (\\<lambda>k. k + n) x =\n       map_component (\\<lambda>k. k + n) y \\<Longrightarrow>\n       x = y", "ultimately"], ["proof (chain)\npicking this:\n  inj (\\<lambda>k. k + n)\n  map_component (\\<lambda>k. k + n) x = map_component (\\<lambda>k. k + n) y", "show \"x = y\""], ["proof (prove)\nusing this:\n  inj (\\<lambda>k. k + n)\n  map_component (\\<lambda>k. k + n) x = map_component (\\<lambda>k. k + n) y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule map_component_inj)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_proj_poly_syz: \"lookup (proj_poly_syz n p) x = lookup p (map_component (\\<lambda>k. k + n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (proj_poly_syz n p) x =\n    lookup p (map_component (\\<lambda>k. k + n) x)", "by (simp add: proj_poly_syz_def map_key.rep_eq[OF inj_map_component_plus])"], ["", "lemma lookup_proj_poly_syz_alt:\n  \"lookup (proj_poly_syz n p) (term_of_pair (t, i)) = lookup p (term_of_pair (t, i + n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (proj_poly_syz n p) (term_of_pair (t, i)) =\n    lookup p (term_of_pair (t, i + n))", "by (simp add: lookup_proj_poly_syz map_component_term_of_pair)"], ["", "lemma keys_proj_poly_syz: \"keys (proj_poly_syz n p) = map_component (\\<lambda>k. k + n) -` keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (proj_poly_syz n p) = map_component (\\<lambda>k. k + n) -` keys p", "by (simp add: proj_poly_syz_def keys_map_key[OF inj_map_component_plus])"], ["", "lemma proj_poly_syz_zero [simp]: \"proj_poly_syz n 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n 0 = 0", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly_syz)"], ["", "lemma proj_poly_syz_plus: \"proj_poly_syz n (p + q) = proj_poly_syz n p + proj_poly_syz n q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (p + q) = proj_poly_syz n p + proj_poly_syz n q", "by (simp add: proj_poly_syz_def map_key_plus[OF inj_map_component_plus])"], ["", "lemma proj_poly_syz_sum: \"proj_poly_syz n (sum f A) = (\\<Sum>a\\<in>A. proj_poly_syz n (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (sum f A) = (\\<Sum>a\\<in>A. proj_poly_syz n (f a))", "by (rule fun_sum_commute, simp_all add: proj_poly_syz_plus)"], ["", "lemma proj_poly_syz_sum_list: \"proj_poly_syz n (sum_list xs) = sum_list (map (proj_poly_syz n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (sum_list xs) = sum_list (map (proj_poly_syz n) xs)", "by (rule fun_sum_list_commute, simp_all add: proj_poly_syz_plus)"], ["", "lemma proj_poly_syz_monom_mult:\n  \"proj_poly_syz n (monom_mult c t p) = monom_mult c t (proj_poly_syz n p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (monom_mult c t p) = monom_mult c t (proj_poly_syz n p)", "by (rule poly_mapping_eqI,\n      simp add: lookup_proj_poly_syz lookup_monom_mult term_simps adds_pp_def sminus_def)"], ["", "lemma proj_poly_syz_mult_scalar:\n  \"proj_poly_syz n (mult_scalar q p) = mult_scalar q (proj_poly_syz n p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (q \\<odot> p) = q \\<odot> proj_poly_syz n p", "by (rule fun_mult_scalar_commute, simp_all add: proj_poly_syz_plus proj_poly_syz_monom_mult)"], ["", "lemma proj_poly_syz_lift_poly_syz:\n  assumes \"i < n\"\n  shows \"proj_poly_syz n (lift_poly_syz n p i) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (lift_poly_syz n p i) = p", "proof (rule poly_mapping_eqI, simp add: lookup_proj_poly_syz lookup_lift_poly_syz term_simps map_component_comp,\n      rule, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>pp_of_term k = (0::'a); component_of_term k + n = i\\<rbrakk>\n       \\<Longrightarrow> lookup p k = (1::'b)", "fix x::'t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>pp_of_term k = (0::'a); component_of_term k + n = i\\<rbrakk>\n       \\<Longrightarrow> lookup p k = (1::'b)", "assume \"component_of_term x + n = i\""], ["proof (state)\nthis:\n  component_of_term x + n = i\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>pp_of_term k = (0::'a); component_of_term k + n = i\\<rbrakk>\n       \\<Longrightarrow> lookup p k = (1::'b)", "hence \"n \\<le> i\""], ["proof (prove)\nusing this:\n  component_of_term x + n = i\n\ngoal (1 subgoal):\n 1. n \\<le> i", "by simp"], ["proof (state)\nthis:\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>pp_of_term k = (0::'a); component_of_term k + n = i\\<rbrakk>\n       \\<Longrightarrow> lookup p k = (1::'b)", "with assms"], ["proof (chain)\npicking this:\n  i < n\n  n \\<le> i", "show \"lookup p x = 1\""], ["proof (prove)\nusing this:\n  i < n\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. lookup p x = (1::'b)", "by simp"], ["proof (state)\nthis:\n  lookup p x = (1::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_poly_syz_eq_zero_iff: \"proj_poly_syz n p = 0 \\<longleftrightarrow> (component_of_term ` keys p \\<subseteq> {0..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (proj_poly_syz n p = 0) =\n    (component_of_term ` keys p \\<subseteq> {0..<n})", "unfolding keys_eq_empty[symmetric] keys_proj_poly_syz"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_component (\\<lambda>k. k + n) -` keys p = {}) =\n    (component_of_term ` keys p \\<subseteq> {0..<n})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. map_component (\\<lambda>k. k + n) -` keys p = {} \\<Longrightarrow>\n    component_of_term ` keys p \\<subseteq> {0..<n}\n 2. component_of_term ` keys p \\<subseteq> {0..<n} \\<Longrightarrow>\n    map_component (\\<lambda>k. k + n) -` keys p = {}", "assume \"map_component (\\<lambda>k. k + n) -` keys p = {}\" (is \"?A = {}\")"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) -` keys p = {}\n\ngoal (2 subgoals):\n 1. map_component (\\<lambda>k. k + n) -` keys p = {} \\<Longrightarrow>\n    component_of_term ` keys p \\<subseteq> {0..<n}\n 2. component_of_term ` keys p \\<subseteq> {0..<n} \\<Longrightarrow>\n    map_component (\\<lambda>k. k + n) -` keys p = {}", "show \"component_of_term ` keys p \\<subseteq> {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> {0..<n}", "proof (rule, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"i \\<in> component_of_term ` keys p\""], ["proof (state)\nthis:\n  i \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i \\<in> component_of_term ` keys p", "obtain x where x: \"x \\<in> keys p\" and i: \"i = component_of_term x\""], ["proof (prove)\nusing this:\n  i \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> keys p; i = component_of_term x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> keys p\n  i = component_of_term x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"i \\<notin> {0..<n}\""], ["proof (state)\nthis:\n  i \\<notin> {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"i - n + n = i\""], ["proof (prove)\nusing this:\n  i \\<notin> {0..<n}\n\ngoal (1 subgoal):\n 1. i - n + n = i", "by simp"], ["proof (state)\nthis:\n  i - n + n = i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "hence 1: \"map_component (\\<lambda>k. k - n + n) x = x\""], ["proof (prove)\nusing this:\n  i - n + n = i\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k - n + n) x = x", "by (simp add: map_component_def i term_simps)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k - n + n) x = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "have \"map_component (\\<lambda>k. k - n) x \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k - n) x\n    \\<in> map_component (\\<lambda>k. k + n) -` keys p", "by (rule vimageI2, simp add: map_component_comp x 1)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k - n) x\n  \\<in> map_component (\\<lambda>k. k + n) -` keys p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> component_of_term ` keys p;\n        x \\<notin> {0..<n}\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  map_component (\\<lambda>k. k - n) x\n  \\<in> map_component (\\<lambda>k. k + n) -` keys p\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>?A = {}\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component_of_term ` keys p \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> {0..<n} \\<Longrightarrow>\n    map_component (\\<lambda>k. k + n) -` keys p = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> {0..<n} \\<Longrightarrow>\n    map_component (\\<lambda>k. k + n) -` keys p = {}", "assume a: \"component_of_term ` keys p \\<subseteq> {0..<n}\""], ["proof (state)\nthis:\n  component_of_term ` keys p \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys p \\<subseteq> {0..<n} \\<Longrightarrow>\n    map_component (\\<lambda>k. k + n) -` keys p = {}", "show \"map_component (\\<lambda>k. k + n) -` keys p = {}\" (is \"?A = {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) -` keys p = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) -` keys p \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"?A \\<noteq> {}\""], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) -` keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) -` keys p \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  map_component (\\<lambda>k. k + n) -` keys p \\<noteq> {}", "obtain x where \"x \\<in> ?A\""], ["proof (prove)\nusing this:\n  map_component (\\<lambda>k. k + n) -` keys p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> map_component (\\<lambda>k. k + n) -`\n                keys p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> map_component (\\<lambda>k. k + n) -` keys p\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) -` keys p \\<noteq>\n    {} \\<Longrightarrow>\n    False", "hence \"map_component (\\<lambda>k. k + n) x \\<in> keys p\""], ["proof (prove)\nusing this:\n  x \\<in> map_component (\\<lambda>k. k + n) -` keys p\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) x \\<in> keys p", "by (rule vimageD)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) x \\<in> keys p\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) -` keys p \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with a"], ["proof (chain)\npicking this:\n  component_of_term ` keys p \\<subseteq> {0..<n}\n  map_component (\\<lambda>k. k + n) x \\<in> keys p", "have \"component_of_term (map_component (\\<lambda>k. k + n) x) \\<in> {0..<n}\""], ["proof (prove)\nusing this:\n  component_of_term ` keys p \\<subseteq> {0..<n}\n  map_component (\\<lambda>k. k + n) x \\<in> keys p\n\ngoal (1 subgoal):\n 1. component_of_term (map_component (\\<lambda>k. k + n) x) \\<in> {0..<n}", "by blast"], ["proof (state)\nthis:\n  component_of_term (map_component (\\<lambda>k. k + n) x) \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) -` keys p \\<noteq>\n    {} \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  component_of_term (map_component (\\<lambda>k. k + n) x) \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. False", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) -` keys p = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma component_of_lt_ge:\n  assumes \"is_pot_ord\" and \"proj_poly_syz n p \\<noteq> 0\"\n  shows \"n \\<le> component_of_term (lt p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "from assms(2)"], ["proof (chain)\npicking this:\n  proj_poly_syz n p \\<noteq> 0", "have \"\\<not> component_of_term ` keys p \\<subseteq> {0..<n}\""], ["proof (prove)\nusing this:\n  proj_poly_syz n p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> component_of_term ` keys p \\<subseteq> {0..<n}", "by (simp add: proj_poly_syz_eq_zero_iff)"], ["proof (state)\nthis:\n  \\<not> component_of_term ` keys p \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "then"], ["proof (chain)\npicking this:\n  \\<not> component_of_term ` keys p \\<subseteq> {0..<n}", "obtain i where \"i \\<in> component_of_term ` keys p\" and \"i \\<notin> {0..<n}\""], ["proof (prove)\nusing this:\n  \\<not> component_of_term ` keys p \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> component_of_term ` keys p;\n         i \\<notin> {0..<n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  i \\<in> component_of_term ` keys p\n  i \\<notin> {0..<n}\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "from this(1)"], ["proof (chain)\npicking this:\n  i \\<in> component_of_term ` keys p", "obtain x where \"x \\<in> keys p\" and i: \"i = component_of_term x\""], ["proof (prove)\nusing this:\n  i \\<in> component_of_term ` keys p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> keys p; i = component_of_term x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> keys p\n  i = component_of_term x\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "from this(1)"], ["proof (chain)\npicking this:\n  x \\<in> keys p", "have \"x \\<preceq>\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  x \\<in> keys p\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>t lt p", "by (rule lt_max_keys)"], ["proof (state)\nthis:\n  x \\<preceq>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "with assms(1)"], ["proof (chain)\npicking this:\n  is_pot_ord\n  x \\<preceq>\\<^sub>t lt p", "have \"component_of_term x \\<le> component_of_term (lt p)\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  x \\<preceq>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. component_of_term x \\<le> component_of_term (lt p)", "by (rule is_pot_ordD2)"], ["proof (state)\nthis:\n  component_of_term x \\<le> component_of_term (lt p)\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "with \\<open>i \\<notin> {0..<n}\\<close>"], ["proof (chain)\npicking this:\n  i \\<notin> {0..<n}\n  component_of_term x \\<le> component_of_term (lt p)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> {0..<n}\n  component_of_term x \\<le> component_of_term (lt p)\n\ngoal (1 subgoal):\n 1. n \\<le> component_of_term (lt p)", "by (simp add: i)"], ["proof (state)\nthis:\n  n \\<le> component_of_term (lt p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lt_proj_poly_syz:\n  assumes \"is_pot_ord\" and \"proj_poly_syz n p \\<noteq> 0\"\n  shows \"lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)\" (is \"_ = ?l\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)", "from component_of_lt_ge[OF assms]"], ["proof (chain)\npicking this:\n  n \\<le> component_of_term (lt p)", "have \"component_of_term (lt p) - n + n = component_of_term (lt p)\""], ["proof (prove)\nusing this:\n  n \\<le> component_of_term (lt p)\n\ngoal (1 subgoal):\n 1. component_of_term (lt p) - n + n = component_of_term (lt p)", "by simp"], ["proof (state)\nthis:\n  component_of_term (lt p) - n + n = component_of_term (lt p)\n\ngoal (1 subgoal):\n 1. lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)", "hence eq: \"map_component (\\<lambda>k. k - n + n) (lt p) = lt p\""], ["proof (prove)\nusing this:\n  component_of_term (lt p) - n + n = component_of_term (lt p)\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k - n + n) (lt p) = lt p", "by (simp add: map_component_def term_simps)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k - n + n) (lt p) = lt p\n\ngoal (1 subgoal):\n 1. lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)", "proof (rule lt_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup (proj_poly_syz n p)\n     (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n    (0::'b)\n 2. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "have \"lookup (proj_poly_syz n p) ?l = lc p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (proj_poly_syz n p) (map_component (\\<lambda>k. k - n) (lt p)) =\n    lc p", "by (simp add: lc_def lookup_proj_poly_syz term_simps map_component_comp eq)"], ["proof (state)\nthis:\n  lookup (proj_poly_syz n p) (map_component (\\<lambda>k. k - n) (lt p)) =\n  lc p\n\ngoal (2 subgoals):\n 1. lookup (proj_poly_syz n p)\n     (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n    (0::'b)\n 2. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "also"], ["proof (state)\nthis:\n  lookup (proj_poly_syz n p) (map_component (\\<lambda>k. k - n) (lt p)) =\n  lc p\n\ngoal (2 subgoals):\n 1. lookup (proj_poly_syz n p)\n     (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n    (0::'b)\n 2. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "have \"... \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc p \\<noteq> (0::'b)", "proof (rule lc_not_0, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> False", "assume \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> False", "hence \"proj_poly_syz n p = 0\""], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. proj_poly_syz n p = 0", "by simp"], ["proof (state)\nthis:\n  proj_poly_syz n p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  proj_poly_syz n p \\<noteq> 0\n  proj_poly_syz n p = 0", "show False"], ["proof (prove)\nusing this:\n  proj_poly_syz n p \\<noteq> 0\n  proj_poly_syz n p = 0\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lc p \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. lookup (proj_poly_syz n p)\n     (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n    (0::'b)\n 2. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "finally"], ["proof (chain)\npicking this:\n  lookup (proj_poly_syz n p)\n   (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n  (0::'b)", "show \"lookup (proj_poly_syz n p) ?l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup (proj_poly_syz n p)\n   (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (proj_poly_syz n p)\n     (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n    (0::'b)", "."], ["proof (state)\nthis:\n  lookup (proj_poly_syz n p)\n   (map_component (\\<lambda>k. k - n) (lt p)) \\<noteq>\n  (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "assume \"lookup (proj_poly_syz n p) x \\<noteq> 0\""], ["proof (state)\nthis:\n  lookup (proj_poly_syz n p) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "hence \"map_component (\\<lambda>k. k + n) x \\<in> keys p\""], ["proof (prove)\nusing this:\n  lookup (proj_poly_syz n p) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) x \\<in> keys p", "by (simp add: in_keys_iff lookup_proj_poly_syz)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) x \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "hence \"map_component (\\<lambda>k. k + n) x \\<preceq>\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  map_component (\\<lambda>k. k + n) x \\<in> keys p\n\ngoal (1 subgoal):\n 1. map_component (\\<lambda>k. k + n) x \\<preceq>\\<^sub>t lt p", "by (rule lt_max_keys)"], ["proof (state)\nthis:\n  map_component (\\<lambda>k. k + n) x \\<preceq>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       lookup (proj_poly_syz n p) u \\<noteq> (0::'b) \\<Longrightarrow>\n       u \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "with assms(1)"], ["proof (chain)\npicking this:\n  is_pot_ord\n  map_component (\\<lambda>k. k + n) x \\<preceq>\\<^sub>t lt p", "show \"x \\<preceq>\\<^sub>t ?l\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  map_component (\\<lambda>k. k + n) x \\<preceq>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. x \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)", "by (auto simp add: is_pot_ord term_simps)"], ["proof (state)\nthis:\n  x \\<preceq>\\<^sub>t map_component (\\<lambda>k. k - n) (lt p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (proj_poly_syz n p) = map_component (\\<lambda>k. k - n) (lt p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_proj_poly_syz: \"proj_poly k (proj_poly_syz n p) = proj_poly (k + n) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k (proj_poly_syz n p) = proj_poly (k + n) p", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_proj_poly_syz_alt)"], ["", "lemma poly_mapping_eqI_proj_syz:\n  assumes \"proj_poly_syz n p = proj_poly_syz n q\"\n    and \"\\<And>k. k < n \\<Longrightarrow> proj_poly k p = proj_poly k q\"\n  shows \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule poly_mapping_eqI_proj)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. proj_poly k p = proj_poly k q", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. proj_poly k p = proj_poly k q", "show \"proj_poly k p = proj_poly k q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k p = proj_poly k q", "proof (cases \"k < n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow> proj_poly k p = proj_poly k q\n 2. \\<not> k < n \\<Longrightarrow> proj_poly k p = proj_poly k q", "case True"], ["proof (state)\nthis:\n  k < n\n\ngoal (2 subgoals):\n 1. k < n \\<Longrightarrow> proj_poly k p = proj_poly k q\n 2. \\<not> k < n \\<Longrightarrow> proj_poly k p = proj_poly k q", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. proj_poly k p = proj_poly k q", "by (rule assms(2))"], ["proof (state)\nthis:\n  proj_poly k p = proj_poly k q\n\ngoal (1 subgoal):\n 1. \\<not> k < n \\<Longrightarrow> proj_poly k p = proj_poly k q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < n \\<Longrightarrow> proj_poly k p = proj_poly k q", "case False"], ["proof (state)\nthis:\n  \\<not> k < n\n\ngoal (1 subgoal):\n 1. \\<not> k < n \\<Longrightarrow> proj_poly k p = proj_poly k q", "have \"proj_poly (k - n + n) p = proj_poly (k - n + n) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly (k - n + n) p = proj_poly (k - n + n) q", "by (simp only: proj_proj_poly_syz[symmetric] assms(1))"], ["proof (state)\nthis:\n  proj_poly (k - n + n) p = proj_poly (k - n + n) q\n\ngoal (1 subgoal):\n 1. \\<not> k < n \\<Longrightarrow> proj_poly k p = proj_poly k q", "with False"], ["proof (chain)\npicking this:\n  \\<not> k < n\n  proj_poly (k - n + n) p = proj_poly (k - n + n) q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> k < n\n  proj_poly (k - n + n) p = proj_poly (k - n + n) q\n\ngoal (1 subgoal):\n 1. proj_poly k p = proj_poly k q", "by simp"], ["proof (state)\nthis:\n  proj_poly k p = proj_poly k q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_poly k p = proj_poly k q\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const cofactor_list_syz}\\<close>"], ["", "lemma length_cofactor_list_syz [simp]: \"length (cofactor_list_syz n p) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (cofactor_list_syz n p) = n", "by (simp add: cofactor_list_syz_def)"], ["", "lemma cofactor_list_syz_nth:\n  assumes \"i < n\"\n  shows \"(cofactor_list_syz n p) ! i = proj_poly i p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactor_list_syz n p ! i = proj_poly i p", "by (simp add: cofactor_list_syz_def map_idx_nth assms)"], ["", "lemma cofactor_list_syz_zero [simp]: \"cofactor_list_syz n 0 = replicate n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactor_list_syz n 0 = replicate n 0", "by (rule nth_equalityI, simp_all add: cofactor_list_syz_nth proj_zero)"], ["", "lemma cofactor_list_syz_plus:\n  \"cofactor_list_syz n (p + q) = map2 (+) (cofactor_list_syz n p) (cofactor_list_syz n q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactor_list_syz n (p + q) =\n    map2 (+) (cofactor_list_syz n p) (cofactor_list_syz n q)", "by (rule nth_equalityI, simp_all add: cofactor_list_syz_nth proj_plus)"], ["", "subsubsection \\<open>@{const init_syzygy_list}\\<close>"], ["", "lemma length_init_syzygy_list [simp]: \"length (init_syzygy_list bs) = length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (init_syzygy_list bs) = length bs", "by (simp add: init_syzygy_list_def)"], ["", "lemma init_syzygy_list_nth:\n  assumes \"i < length bs\"\n  shows \"(init_syzygy_list bs) ! i = lift_poly_syz (length bs) (bs ! i) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_syzygy_list bs ! i = lift_poly_syz (length bs) (bs ! i) i", "by (simp add: init_syzygy_list_def map_idx_nth[OF assms])"], ["", "lemma Keys_init_syzygy_list:\n  \"Keys (set (init_syzygy_list bs)) =\n      map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union> (\\<lambda>i. term_of_pair (0, i)) ` {0..<length bs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (set (init_syzygy_list bs)) =\n    map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union>\n    (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Keys (set (init_syzygy_list bs)) =\n    map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union>\n    (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}", "have eq1: \"(\\<Union>b\\<in>set bs. map_component (\\<lambda>k. k + length bs) ` keys b) =\n              (\\<Union>i\\<in>{0..<length bs}. map_component (\\<lambda>k. k + length bs) ` keys (bs ! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>b\\<in>set bs.\n        map_component (\\<lambda>k. k + length bs) ` keys b) =\n    (\\<Union>i\\<in>{0..<length bs}.\n        map_component (\\<lambda>k. k + length bs) ` keys (bs ! i))", "by (fact UN_upt[symmetric])"], ["proof (state)\nthis:\n  (\\<Union>b\\<in>set bs.\n      map_component (\\<lambda>k. k + length bs) ` keys b) =\n  (\\<Union>i\\<in>{0..<length bs}.\n      map_component (\\<lambda>k. k + length bs) ` keys (bs ! i))\n\ngoal (1 subgoal):\n 1. Keys (set (init_syzygy_list bs)) =\n    map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union>\n    (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}", "have eq2: \"(\\<lambda>i. term_of_pair (0, i)) ` {0..<length bs} = (\\<Union>i\\<in>{0..<length bs}. {term_of_pair (0, i)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n    (\\<Union>i\\<in>{0..<length bs}. {term_of_pair (0::'a, i)})", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n  (\\<Union>i\\<in>{0..<length bs}. {term_of_pair (0::'a, i)})\n\ngoal (1 subgoal):\n 1. Keys (set (init_syzygy_list bs)) =\n    map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union>\n    (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (set (init_syzygy_list bs)) =\n    map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union>\n    (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}", "by (simp add: init_syzygy_list_def set_map_idx Keys_def keys_lift_poly_syz image_UN\n        eq1 eq2 UN_Un_distrib[symmetric])"], ["proof (state)\nthis:\n  Keys (set (init_syzygy_list bs)) =\n  map_component (\\<lambda>k. k + length bs) ` Keys (set bs) \\<union>\n  (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_of_Keys_init_syzygy_list_subset:\n  \"pp_of_term ` Keys (set (init_syzygy_list bs)) \\<subseteq> insert 0 (pp_of_term ` Keys (set bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term ` Keys (set (init_syzygy_list bs))\n    \\<subseteq> insert (0::'a) (pp_of_term ` Keys (set bs))", "by (auto simp add: Keys_init_syzygy_list image_Un rev_image_eqI term_simps)"], ["", "lemma pp_of_Keys_init_syzygy_list_superset:\n  \"pp_of_term ` Keys (set bs) \\<subseteq> pp_of_term ` Keys (set (init_syzygy_list bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term ` Keys (set bs)\n    \\<subseteq> pp_of_term ` Keys (set (init_syzygy_list bs))", "by (simp add: Keys_init_syzygy_list image_Un term_simps image_image)"], ["", "lemma pp_of_Keys_init_syzygy_list:\n  assumes \"bs \\<noteq> []\"\n  shows \"pp_of_term ` Keys (set (init_syzygy_list bs)) = insert 0 (pp_of_term ` Keys (set bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_of_term ` Keys (set (init_syzygy_list bs)) =\n    insert (0::'a) (pp_of_term ` Keys (set bs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pp_of_term ` Keys (set (init_syzygy_list bs))\n    \\<subseteq> insert (0::'a) (pp_of_term ` Keys (set bs))\n 2. insert (0::'a) (pp_of_term ` Keys (set bs))\n    \\<subseteq> pp_of_term ` Keys (set (init_syzygy_list bs))", "show \"insert 0 (pp_of_term ` Keys (set bs)) \\<subseteq> pp_of_term ` Keys (set (init_syzygy_list bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (0::'a) (pp_of_term ` Keys (set bs))\n    \\<subseteq> pp_of_term ` Keys (set (init_syzygy_list bs))", "proof (simp add: pp_of_Keys_init_syzygy_list_superset)"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "from assms"], ["proof (chain)\npicking this:\n  bs \\<noteq> []", "have \"{0..<length bs} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  bs \\<noteq> []\n\ngoal (1 subgoal):\n 1. {0..<length bs} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {0..<length bs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "hence \"Pair 0 ` {0..<length bs} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {0..<length bs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Pair (0::'c) ` {0..<length bs} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Pair (0::?'c49) ` {0..<length bs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "then"], ["proof (chain)\npicking this:\n  Pair (0::?'c49) ` {0..<length bs} \\<noteq> {}", "obtain x::'t where x: \"x \\<in> (\\<lambda>i. term_of_pair (0, i)) ` {0..<length bs}\""], ["proof (prove)\nusing this:\n  Pair (0::?'c49) ` {0..<length bs} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> (\\<lambda>i. term_of_pair (0::'a, i)) `\n                {0..<length bs} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "hence \"pp_of_term ` (\\<lambda>i. term_of_pair (0, i)) ` {0..<length bs} = {pp_of_term x}\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}\n\ngoal (1 subgoal):\n 1. pp_of_term ` (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n    {pp_of_term x}", "using image_subset_iff"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}\n  (?f ` ?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. ?f x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. pp_of_term ` (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n    {pp_of_term x}", "by (auto simp: term_simps)"], ["proof (state)\nthis:\n  pp_of_term ` (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n  {pp_of_term x}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "also"], ["proof (state)\nthis:\n  pp_of_term ` (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n  {pp_of_term x}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "from x"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}", "have \"... = {0}\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}\n\ngoal (1 subgoal):\n 1. {pp_of_term x} = {0::'a}", "using pp_of_term_of_pair"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs}\n  pp_of_term (term_of_pair (?t, ?k)) = ?t\n\ngoal (1 subgoal):\n 1. {pp_of_term x} = {0::'a}", "by auto"], ["proof (state)\nthis:\n  {pp_of_term x} = {0::'a}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "finally"], ["proof (chain)\npicking this:\n  pp_of_term ` (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n  {0::'a}", "show \"0 \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))\""], ["proof (prove)\nusing this:\n  pp_of_term ` (\\<lambda>i. term_of_pair (0::'a, i)) ` {0..<length bs} =\n  {0::'a}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))", "by (simp add: Keys_init_syzygy_list image_Un)"], ["proof (state)\nthis:\n  (0::'a) \\<in> pp_of_term ` Keys (set (init_syzygy_list bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert (0::'a) (pp_of_term ` Keys (set bs))\n  \\<subseteq> pp_of_term ` Keys (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. pp_of_term ` Keys (set (init_syzygy_list bs))\n    \\<subseteq> insert (0::'a) (pp_of_term ` Keys (set bs))", "qed (fact pp_of_Keys_init_syzygy_list_subset)"], ["", "lemma component_of_Keys_init_syzygy_list:\n  \"component_of_term ` Keys (set (init_syzygy_list bs)) =\n            (+) (length bs) ` component_of_term ` Keys (set bs) \\<union> {0..<length bs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (set (init_syzygy_list bs)) =\n    (+) (length bs) ` component_of_term ` Keys (set bs) \\<union>\n    {0..<length bs}", "by (simp add: Keys_init_syzygy_list image_Un image_comp o_def ac_simps term_simps)"], ["", "lemma proj_lift_poly_syz:\n  assumes \"j < n\"\n  shows \"proj_poly j (lift_poly_syz n p i) = (1 when j = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly j (lift_poly_syz n p i) = (1 when j = i)", "proof (simp add: when_def, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow> proj_poly i (lift_poly_syz n p i) = 1\n 2. j \\<noteq> i \\<Longrightarrow> proj_poly j (lift_poly_syz n p i) = 0", "assume \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow> proj_poly i (lift_poly_syz n p i) = 1\n 2. j \\<noteq> i \\<Longrightarrow> proj_poly j (lift_poly_syz n p i) = 0", "with assms"], ["proof (chain)\npicking this:\n  j < n\n  j = i", "have \"\\<not> n \\<le> i\""], ["proof (prove)\nusing this:\n  j < n\n  j = i\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> i", "by simp"], ["proof (state)\nthis:\n  \\<not> n \\<le> i\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow> proj_poly i (lift_poly_syz n p i) = 1\n 2. j \\<noteq> i \\<Longrightarrow> proj_poly j (lift_poly_syz n p i) = 0", "show \"proj_poly i (lift_poly_syz n p i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly i (lift_poly_syz n p i) = 1", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_lift_poly_syz_alt \\<open>\\<not> n \\<le> i\\<close> lookup_one)"], ["proof (state)\nthis:\n  proj_poly i (lift_poly_syz n p i) = 1\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow> proj_poly j (lift_poly_syz n p i) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow> proj_poly j (lift_poly_syz n p i) = 0", "assume \"j \\<noteq> i\""], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow> proj_poly j (lift_poly_syz n p i) = 0", "from assms"], ["proof (chain)\npicking this:\n  j < n", "have \"\\<not> n \\<le> j\""], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> j", "by simp"], ["proof (state)\nthis:\n  \\<not> n \\<le> j\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow> proj_poly j (lift_poly_syz n p i) = 0", "show \"proj_poly j (lift_poly_syz n p i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly j (lift_poly_syz n p i) = 0", "by (rule poly_mapping_eqI, simp add: lookup_proj_poly lookup_lift_poly_syz_alt \\<open>\\<not> n \\<le> j\\<close> \\<open>j \\<noteq> i\\<close>)"], ["proof (state)\nthis:\n  proj_poly j (lift_poly_syz n p i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const proj_orig_basis}\\<close>"], ["", "lemma length_proj_orig_basis [simp]: \"length (proj_orig_basis n bs) = length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (proj_orig_basis n bs) = length bs", "by (simp add: proj_orig_basis_def)"], ["", "lemma proj_orig_basis_nth:\n  assumes \"i < length bs\"\n  shows \"(proj_orig_basis n bs) ! i = proj_poly_syz n (bs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_orig_basis n bs ! i = proj_poly_syz n (bs ! i)", "by (simp add: proj_orig_basis_def assms)"], ["", "lemma proj_orig_basis_init_syzygy_list [simp]:\n  \"proj_orig_basis (length bs) (init_syzygy_list bs) = bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_orig_basis (length bs) (init_syzygy_list bs) = bs", "by (rule nth_equalityI, simp_all add: init_syzygy_list_nth proj_orig_basis_nth proj_poly_syz_lift_poly_syz)"], ["", "lemma set_proj_orig_basis: \"set (proj_orig_basis n bs) = proj_poly_syz n ` set bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (proj_orig_basis n bs) = proj_poly_syz n ` set bs", "by (simp add: proj_orig_basis_def)"], ["", "text \\<open>The following lemma could be generalized from @{const proj_poly_syz} to arbitrary module homomorphisms,\n  i.\\,e. functions respecting \\<open>0\\<close>, addition and scalar multiplication.\\<close>"], ["", "lemma pmdl_proj_orig_basis':\n  \"pmdl (set (proj_orig_basis n bs)) = proj_poly_syz n ` pmdl (set bs)\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (proj_orig_basis n bs)) = proj_poly_syz n ` pmdl (set bs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pmdl (set (proj_orig_basis n bs))\n    \\<subseteq> proj_poly_syz n ` pmdl (set bs)\n 2. proj_poly_syz n ` pmdl (set bs)\n    \\<subseteq> pmdl (set (proj_orig_basis n bs))", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (proj_orig_basis n bs))\n    \\<subseteq> proj_poly_syz n ` pmdl (set bs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (proj_orig_basis n bs)) \\<Longrightarrow>\n       x \\<in> proj_poly_syz n ` pmdl (set bs)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (proj_orig_basis n bs)) \\<Longrightarrow>\n       x \\<in> proj_poly_syz n ` pmdl (set bs)", "assume \"p \\<in> pmdl (set (proj_orig_basis n bs))\""], ["proof (state)\nthis:\n  p \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (proj_orig_basis n bs)) \\<Longrightarrow>\n       x \\<in> proj_poly_syz n ` pmdl (set bs)", "thus \"p \\<in> proj_poly_syz n ` pmdl (set bs)\""], ["proof (prove)\nusing this:\n  p \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (1 subgoal):\n 1. p \\<in> proj_poly_syz n ` pmdl (set bs)", "proof (induct rule: pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> proj_poly_syz n ` pmdl (set bs)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "case module_0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<in> proj_poly_syz n ` pmdl (set bs)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "have \"0 = proj_poly_syz n 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = proj_poly_syz n 0", "by simp"], ["proof (state)\nthis:\n  0 = proj_poly_syz n 0\n\ngoal (2 subgoals):\n 1. 0 \\<in> proj_poly_syz n ` pmdl (set bs)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "also"], ["proof (state)\nthis:\n  0 = proj_poly_syz n 0\n\ngoal (2 subgoals):\n 1. 0 \\<in> proj_poly_syz n ` pmdl (set bs)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "from pmdl.span_zero"], ["proof (chain)\npicking this:\n  0 \\<in> pmdl ?S", "have \"... \\<in> proj_poly_syz n ` pmdl (set bs)\""], ["proof (prove)\nusing this:\n  0 \\<in> pmdl ?S\n\ngoal (1 subgoal):\n 1. proj_poly_syz n 0 \\<in> proj_poly_syz n ` pmdl (set bs)", "by (rule imageI)"], ["proof (state)\nthis:\n  proj_poly_syz n 0 \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (2 subgoals):\n 1. 0 \\<in> proj_poly_syz n ` pmdl (set bs)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "finally"], ["proof (chain)\npicking this:\n  0 \\<in> proj_poly_syz n ` pmdl (set bs)", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. 0 \\<in> proj_poly_syz n ` pmdl (set bs)", "."], ["proof (state)\nthis:\n  0 \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "case (module_plus p b c t)"], ["proof (state)\nthis:\n  p \\<in> pmdl (set (proj_orig_basis n bs))\n  p \\<in> proj_poly_syz n ` pmdl (set bs)\n  b \\<in> set (proj_orig_basis n bs)\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "from module_plus(2)"], ["proof (chain)\npicking this:\n  p \\<in> proj_poly_syz n ` pmdl (set bs)", "obtain q where \"q \\<in> pmdl (set bs)\" and p: \"p = proj_poly_syz n q\""], ["proof (prove)\nusing this:\n  p \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> pmdl (set bs); p = proj_poly_syz n q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<in> pmdl (set bs)\n  p = proj_poly_syz n q\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "from module_plus(3)"], ["proof (chain)\npicking this:\n  b \\<in> set (proj_orig_basis n bs)", "obtain a where \"a \\<in> set bs\" and b: \"b = proj_poly_syz n a\""], ["proof (prove)\nusing this:\n  b \\<in> set (proj_orig_basis n bs)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set bs; b = proj_poly_syz n a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_proj_orig_basis"], ["proof (prove)\nusing this:\n  b \\<in> proj_poly_syz n ` set bs\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set bs; b = proj_poly_syz n a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  a \\<in> set bs\n  b = proj_poly_syz n a\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "have \"p + monom_mult c t b = proj_poly_syz n (q + monom_mult c t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + monom_mult c t b = proj_poly_syz n (q + monom_mult c t a)", "by (simp add: p b proj_poly_syz_monom_mult proj_poly_syz_plus)"], ["proof (state)\nthis:\n  p + monom_mult c t b = proj_poly_syz n (q + monom_mult c t a)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "also"], ["proof (state)\nthis:\n  p + monom_mult c t b = proj_poly_syz n (q + monom_mult c t a)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "have \"... \\<in> proj_poly_syz n ` pmdl (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (q + monom_mult c t a)\n    \\<in> proj_poly_syz n ` pmdl (set bs)", "proof (rule imageI, rule pmdl.span_add)"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> pmdl (set bs)\n 2. monom_mult c t a \\<in> pmdl (set bs)", "show \"monom_mult c t a \\<in> pmdl (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t a \\<in> pmdl (set bs)", "by (rule pmdl_closed_monom_mult, rule pmdl.span_base, fact)"], ["proof (state)\nthis:\n  monom_mult c t a \\<in> pmdl (set bs)\n\ngoal (1 subgoal):\n 1. q \\<in> pmdl (set bs)", "qed fact"], ["proof (state)\nthis:\n  proj_poly_syz n (q + monom_mult c t a)\n  \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (proj_orig_basis n bs));\n        a \\<in> proj_poly_syz n ` pmdl (set bs);\n        p \\<in> set (proj_orig_basis n bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p\n                         \\<in> proj_poly_syz n ` pmdl (set bs)", "finally"], ["proof (chain)\npicking this:\n  p + monom_mult c t b \\<in> proj_poly_syz n ` pmdl (set bs)", "show ?case"], ["proof (prove)\nusing this:\n  p + monom_mult c t b \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. p + monom_mult c t b \\<in> proj_poly_syz n ` pmdl (set bs)", "."], ["proof (state)\nthis:\n  p + monom_mult c t b \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl (set (proj_orig_basis n bs))\n  \\<subseteq> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. proj_poly_syz n ` pmdl (set bs)\n    \\<subseteq> pmdl (set (proj_orig_basis n bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_poly_syz n ` pmdl (set bs)\n    \\<subseteq> pmdl (set (proj_orig_basis n bs))", "show \"?B \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n ` pmdl (set bs)\n    \\<subseteq> pmdl (set (proj_orig_basis n bs))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proj_poly_syz n ` pmdl (set bs) \\<Longrightarrow>\n       x \\<in> pmdl (set (proj_orig_basis n bs))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proj_poly_syz n ` pmdl (set bs) \\<Longrightarrow>\n       x \\<in> pmdl (set (proj_orig_basis n bs))", "assume \"p \\<in> proj_poly_syz n ` pmdl (set bs)\""], ["proof (state)\nthis:\n  p \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proj_poly_syz n ` pmdl (set bs) \\<Longrightarrow>\n       x \\<in> pmdl (set (proj_orig_basis n bs))", "then"], ["proof (chain)\npicking this:\n  p \\<in> proj_poly_syz n ` pmdl (set bs)", "obtain q where \"q \\<in> pmdl (set bs)\" and p: \"p = proj_poly_syz n q\""], ["proof (prove)\nusing this:\n  p \\<in> proj_poly_syz n ` pmdl (set bs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> pmdl (set bs); p = proj_poly_syz n q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q \\<in> pmdl (set bs)\n  p = proj_poly_syz n q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> proj_poly_syz n ` pmdl (set bs) \\<Longrightarrow>\n       x \\<in> pmdl (set (proj_orig_basis n bs))", "from this(1)"], ["proof (chain)\npicking this:\n  q \\<in> pmdl (set bs)", "show \"p \\<in> pmdl (set (proj_orig_basis n bs))\""], ["proof (prove)\nusing this:\n  q \\<in> pmdl (set bs)\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl (set (proj_orig_basis n bs))", "unfolding p"], ["proof (prove)\nusing this:\n  q \\<in> pmdl (set bs)\n\ngoal (1 subgoal):\n 1. proj_poly_syz n q \\<in> pmdl (set (proj_orig_basis n bs))", "proof (induct rule: pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "case module_0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "have \"proj_poly_syz n 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n 0 = 0", "by simp"], ["proof (state)\nthis:\n  proj_poly_syz n 0 = 0\n\ngoal (2 subgoals):\n 1. proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "also"], ["proof (state)\nthis:\n  proj_poly_syz n 0 = 0\n\ngoal (2 subgoals):\n 1. proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "have \"... \\<in> pmdl (set (proj_orig_basis n bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> pmdl (set (proj_orig_basis n bs))", "by (fact pmdl.span_zero)"], ["proof (state)\nthis:\n  0 \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (2 subgoals):\n 1. proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "finally"], ["proof (chain)\npicking this:\n  proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))", "show ?case"], ["proof (prove)\nusing this:\n  proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (1 subgoal):\n 1. proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))", "."], ["proof (state)\nthis:\n  proj_poly_syz n 0 \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "case (module_plus q b c t)"], ["proof (state)\nthis:\n  q \\<in> pmdl (set bs)\n  proj_poly_syz n q \\<in> pmdl (set (proj_orig_basis n bs))\n  b \\<in> set bs\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "have \"proj_poly_syz n (q + monom_mult c t b) =\n            proj_poly_syz n q + monom_mult c t (proj_poly_syz n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n (q + monom_mult c t b) =\n    proj_poly_syz n q + monom_mult c t (proj_poly_syz n b)", "by (simp add: proj_poly_syz_plus proj_poly_syz_monom_mult)"], ["proof (state)\nthis:\n  proj_poly_syz n (q + monom_mult c t b) =\n  proj_poly_syz n q + monom_mult c t (proj_poly_syz n b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "also"], ["proof (state)\nthis:\n  proj_poly_syz n (q + monom_mult c t b) =\n  proj_poly_syz n q + monom_mult c t (proj_poly_syz n b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "have \"... \\<in> pmdl (set (proj_orig_basis n bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n q + monom_mult c t (proj_poly_syz n b)\n    \\<in> pmdl (set (proj_orig_basis n bs))", "proof (rule pmdl.span_add)"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_poly_syz n q \\<in> pmdl (set (proj_orig_basis n bs))\n 2. monom_mult c t (proj_poly_syz n b)\n    \\<in> pmdl (set (proj_orig_basis n bs))", "show \"monom_mult c t (proj_poly_syz n b) \\<in> pmdl (set (proj_orig_basis n bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (proj_poly_syz n b)\n    \\<in> pmdl (set (proj_orig_basis n bs))", "proof (rule pmdl_closed_monom_mult, rule pmdl.span_base)"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_poly_syz n b \\<in> set (proj_orig_basis n bs)", "show \"proj_poly_syz n b \\<in> set (proj_orig_basis n bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz n b \\<in> set (proj_orig_basis n bs)", "by (simp add: set_proj_orig_basis, rule imageI, fact)"], ["proof (state)\nthis:\n  proj_poly_syz n b \\<in> set (proj_orig_basis n bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom_mult c t (proj_poly_syz n b) \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (1 subgoal):\n 1. proj_poly_syz n q \\<in> pmdl (set (proj_orig_basis n bs))", "qed fact"], ["proof (state)\nthis:\n  proj_poly_syz n q + monom_mult c t (proj_poly_syz n b)\n  \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set bs);\n        proj_poly_syz n a \\<in> pmdl (set (proj_orig_basis n bs));\n        p \\<in> set bs; c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz n (a + monom_mult c t p)\n                         \\<in> pmdl (set (proj_orig_basis n bs))", "finally"], ["proof (chain)\npicking this:\n  proj_poly_syz n (q + monom_mult c t b)\n  \\<in> pmdl (set (proj_orig_basis n bs))", "show ?case"], ["proof (prove)\nusing this:\n  proj_poly_syz n (q + monom_mult c t b)\n  \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal (1 subgoal):\n 1. proj_poly_syz n (q + monom_mult c t b)\n    \\<in> pmdl (set (proj_orig_basis n bs))", "."], ["proof (state)\nthis:\n  proj_poly_syz n (q + monom_mult c t b)\n  \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> pmdl (set (proj_orig_basis n bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_poly_syz n ` pmdl (set bs)\n  \\<subseteq> pmdl (set (proj_orig_basis n bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>@{const filter_syzygy_basis}\\<close>"], ["", "lemma filter_syzygy_basis_alt: \"filter_syzygy_basis n bs = [b\\<leftarrow>bs. proj_poly_syz n b = 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_syzygy_basis n bs = filter (\\<lambda>b. proj_poly_syz n b = 0) bs", "by (simp add: filter_syzygy_basis_def proj_poly_syz_eq_zero_iff)"], ["", "lemma set_filter_syzygy_basis:\n  \"set (filter_syzygy_basis n bs) = {b\\<in>set bs. proj_poly_syz n b = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter_syzygy_basis n bs) = {b \\<in> set bs. proj_poly_syz n b = 0}", "by (simp add: filter_syzygy_basis_alt)"], ["", "subsubsection \\<open>@{const syzygy_module_list}\\<close>"], ["", "lemma syzygy_module_listI:\n  assumes \"s' \\<in> pmdl.syzygy_module (set bs)\" and \"s = atomize_poly (idx_pm_of_pm bs s')\"\n  shows \"s \\<in> syzygy_module_list bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> syzygy_module_list bs", "unfolding assms(2) syzygy_module_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atomize_poly (idx_pm_of_pm bs s')\n    \\<in> atomize_poly ` idx_pm_of_pm bs ` pmdl.syzygy_module (set bs)", "by (intro imageI, fact assms(1))"], ["", "lemma syzygy_module_listE:\n  assumes \"s \\<in> syzygy_module_list bs\"\n  obtains s' where \"s' \\<in> pmdl.syzygy_module (set bs)\" and \"s = atomize_poly (idx_pm_of_pm bs s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> pmdl.syzygy_module (set bs);\n         s = atomize_poly (idx_pm_of_pm bs s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> pmdl.syzygy_module (set bs);\n         s = atomize_poly (idx_pm_of_pm bs s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding syzygy_module_list_def"], ["proof (prove)\nusing this:\n  s \\<in> atomize_poly ` idx_pm_of_pm bs ` pmdl.syzygy_module (set bs)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> pmdl.syzygy_module (set bs);\n         s = atomize_poly (idx_pm_of_pm bs s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim imageE, simp)"], ["", "lemma monom_mult_atomize:\n  \"monom_mult c t (atomize_poly p) = atomize_poly (MPoly_Type_Class.punit.monom_mult (monomial c t) 0 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (atomize_poly p) =\n    atomize_poly (MPoly_Type_Class.punit.monom_mult (monomial c t) 0 p)", "by (rule poly_mapping_eqI_proj, simp add: proj_monom_mult proj_atomize_poly\n      MPoly_Type_Class.punit.lookup_monom_mult times_monomial_left)"], ["", "lemma punit_monom_mult_monomial_idx_pm_of_pm:\n  \"MPoly_Type_Class.punit.monom_mult (monomial c t) (0::nat) (idx_pm_of_pm bs s) =\n    idx_pm_of_pm bs (MPoly_Type_Class.punit.monom_mult (monomial c t) (0::'t \\<Rightarrow>\\<^sub>0 'b::ring_1) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type_Class.punit.monom_mult (monomial c t) 0 (idx_pm_of_pm bs s) =\n    idx_pm_of_pm bs (MPoly_Type_Class.punit.monom_mult (monomial c t) 0 s)", "by (rule poly_mapping_eqI, simp add: MPoly_Type_Class.punit.lookup_monom_mult lookup_idx_pm_of_pm when_def)"], ["", "lemma syzygy_module_list_closed_monom_mult:\n  assumes \"s \\<in> syzygy_module_list bs\"\n  shows \"monom_mult c t s \\<in> syzygy_module_list bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t s \\<in> syzygy_module_list bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monom_mult c t s \\<in> syzygy_module_list bs", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> syzygy_module_list bs", "obtain s' where s': \"s' \\<in> pmdl.syzygy_module (set bs)\"\n    and s: \"s = atomize_poly (idx_pm_of_pm bs s')\""], ["proof (prove)\nusing this:\n  s \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> pmdl.syzygy_module (set bs);\n         s = atomize_poly (idx_pm_of_pm bs s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule syzygy_module_listE)"], ["proof (state)\nthis:\n  s' \\<in> pmdl.syzygy_module (set bs)\n  s = atomize_poly (idx_pm_of_pm bs s')\n\ngoal (1 subgoal):\n 1. monom_mult c t s \\<in> syzygy_module_list bs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t s \\<in> syzygy_module_list bs", "unfolding s"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (atomize_poly (idx_pm_of_pm bs s'))\n    \\<in> syzygy_module_list bs", "proof (rule syzygy_module_listI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?s' \\<in> pmdl.syzygy_module (set bs)\n 2. monom_mult c t (atomize_poly (idx_pm_of_pm bs s')) =\n    atomize_poly (idx_pm_of_pm bs ?s')", "from s'"], ["proof (chain)\npicking this:\n  s' \\<in> pmdl.syzygy_module (set bs)", "show \"(monomial c t) \\<cdot> s' \\<in> pmdl.syzygy_module (set bs)\""], ["proof (prove)\nusing this:\n  s' \\<in> pmdl.syzygy_module (set bs)\n\ngoal (1 subgoal):\n 1. monomial c t \\<cdot> s' \\<in> pmdl.syzygy_module (set bs)", "by (rule syzygy_module_closed_map_scale)"], ["proof (state)\nthis:\n  monomial c t \\<cdot> s' \\<in> pmdl.syzygy_module (set bs)\n\ngoal (1 subgoal):\n 1. monom_mult c t (atomize_poly (idx_pm_of_pm bs s')) =\n    atomize_poly (idx_pm_of_pm bs (monomial c t \\<cdot> s'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. monom_mult c t (atomize_poly (idx_pm_of_pm bs s')) =\n    atomize_poly (idx_pm_of_pm bs (monomial c t \\<cdot> s'))", "show \"monom_mult c t (atomize_poly (idx_pm_of_pm bs s')) =\n          atomize_poly (idx_pm_of_pm bs ((monomial c t) \\<cdot> s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult c t (atomize_poly (idx_pm_of_pm bs s')) =\n    atomize_poly (idx_pm_of_pm bs (monomial c t \\<cdot> s'))", "by (simp add: monom_mult_atomize punit_monom_mult_monomial_idx_pm_of_pm\n            MPoly_Type_Class.punit.map_scale_eq_monom_mult)"], ["proof (state)\nthis:\n  monom_mult c t (atomize_poly (idx_pm_of_pm bs s')) =\n  atomize_poly (idx_pm_of_pm bs (monomial c t \\<cdot> s'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom_mult c t s \\<in> syzygy_module_list bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmdl_syzygy_module_list [simp]: \"pmdl (syzygy_module_list bs) = syzygy_module_list bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (syzygy_module_list bs) = syzygy_module_list bs", "proof (rule pmdl_idI)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<in> syzygy_module_list bs\n 2. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 3. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "show \"0 \\<in> syzygy_module_list bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> syzygy_module_list bs", "by (rule syzygy_module_listI, fact pmdl.zero_in_syzygy_module, simp add: atomize_zero)"], ["proof (state)\nthis:\n  0 \\<in> syzygy_module_list bs\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 2. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 2. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "fix s1 s2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 2. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "assume \"s1 \\<in> syzygy_module_list bs\""], ["proof (state)\nthis:\n  s1 \\<in> syzygy_module_list bs\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 2. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "then"], ["proof (chain)\npicking this:\n  s1 \\<in> syzygy_module_list bs", "obtain s1' where s1': \"s1' \\<in> pmdl.syzygy_module (set bs)\"\n    and s1: \"s1 = atomize_poly (idx_pm_of_pm bs s1')\""], ["proof (prove)\nusing this:\n  s1 \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. (\\<And>s1'.\n        \\<lbrakk>s1' \\<in> pmdl.syzygy_module (set bs);\n         s1 = atomize_poly (idx_pm_of_pm bs s1')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule syzygy_module_listE)"], ["proof (state)\nthis:\n  s1' \\<in> pmdl.syzygy_module (set bs)\n  s1 = atomize_poly (idx_pm_of_pm bs s1')\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 2. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "assume \"s2 \\<in> syzygy_module_list bs\""], ["proof (state)\nthis:\n  s2 \\<in> syzygy_module_list bs\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 2. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "then"], ["proof (chain)\npicking this:\n  s2 \\<in> syzygy_module_list bs", "obtain s2' where s2': \"s2' \\<in> pmdl.syzygy_module (set bs)\"\n    and s2: \"s2 = atomize_poly (idx_pm_of_pm bs s2')\""], ["proof (prove)\nusing this:\n  s2 \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. (\\<And>s2'.\n        \\<lbrakk>s2' \\<in> pmdl.syzygy_module (set bs);\n         s2 = atomize_poly (idx_pm_of_pm bs s2')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule syzygy_module_listE)"], ["proof (state)\nthis:\n  s2' \\<in> pmdl.syzygy_module (set bs)\n  s2 = atomize_poly (idx_pm_of_pm bs s2')\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> syzygy_module_list bs;\n        b2 \\<in> syzygy_module_list bs\\<rbrakk>\n       \\<Longrightarrow> b1 + b2 \\<in> syzygy_module_list bs\n 2. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "show \"s1 + s2 \\<in> syzygy_module_list bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 + s2 \\<in> syzygy_module_list bs", "proof (rule syzygy_module_listI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?s' \\<in> pmdl.syzygy_module (set bs)\n 2. s1 + s2 = atomize_poly (idx_pm_of_pm bs ?s')", "from s1' s2'"], ["proof (chain)\npicking this:\n  s1' \\<in> pmdl.syzygy_module (set bs)\n  s2' \\<in> pmdl.syzygy_module (set bs)", "show \"s1' + s2' \\<in> pmdl.syzygy_module (set bs)\""], ["proof (prove)\nusing this:\n  s1' \\<in> pmdl.syzygy_module (set bs)\n  s2' \\<in> pmdl.syzygy_module (set bs)\n\ngoal (1 subgoal):\n 1. s1' + s2' \\<in> pmdl.syzygy_module (set bs)", "by (rule pmdl.syzygy_module_closed_plus)"], ["proof (state)\nthis:\n  s1' + s2' \\<in> pmdl.syzygy_module (set bs)\n\ngoal (1 subgoal):\n 1. s1 + s2 = atomize_poly (idx_pm_of_pm bs (s1' + s2'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s1 + s2 = atomize_poly (idx_pm_of_pm bs (s1' + s2'))", "show \"s1 + s2 = atomize_poly (idx_pm_of_pm bs (s1' + s2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 + s2 = atomize_poly (idx_pm_of_pm bs (s1' + s2'))", "by (simp add: idx_pm_of_pm_plus atomize_plus s1 s2)"], ["proof (state)\nthis:\n  s1 + s2 = atomize_poly (idx_pm_of_pm bs (s1' + s2'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s1 + s2 \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. \\<And>c t b.\n       b \\<in> syzygy_module_list bs \\<Longrightarrow>\n       monom_mult c t b \\<in> syzygy_module_list bs", "qed (fact syzygy_module_list_closed_monom_mult)"], ["", "text \\<open>The following lemma also holds without the distinctness constraint on \\<open>bs\\<close>, but then the\n  proof becomes more difficult.\\<close>"], ["", "lemma syzygy_module_listI':\n  assumes \"distinct bs\" and \"sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s) bs) = 0\"\n    and \"component_of_term ` keys s \\<subseteq> {0..<length bs}\"\n  shows \"s \\<in> syzygy_module_list bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> syzygy_module_list bs", "proof (rule syzygy_module_listI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?s' \\<in> pmdl.syzygy_module (set bs)\n 2. s = atomize_poly (idx_pm_of_pm bs ?s')", "show \"pm_of_idx_pm bs (vectorize_poly s) \\<in> pmdl.syzygy_module (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pm_of_idx_pm bs (vectorize_poly s) \\<in> pmdl.syzygy_module (set bs)", "proof (rule pmdl.syzygy_moduleI, rule pmdl.representsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "have \"(\\<Sum>v\\<in>keys (pm_of_idx_pm bs (vectorize_poly s)).\n              mult_scalar (lookup (pm_of_idx_pm bs (vectorize_poly s)) v) v) =\n          (\\<Sum>b\\<in>set bs. mult_scalar (lookup (pm_of_idx_pm bs (vectorize_poly s)) b) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys (pm_of_idx_pm bs (vectorize_poly s)).\n       lookup (pm_of_idx_pm bs (vectorize_poly s)) v \\<odot> v) =\n    (\\<Sum>b\\<in>set bs.\n       lookup (pm_of_idx_pm bs (vectorize_poly s)) b \\<odot> b)", "by (rule sum.mono_neutral_left, fact finite_set, fact keys_pm_of_idx_pm_subset, simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (pm_of_idx_pm bs (vectorize_poly s)).\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) v \\<odot> v) =\n  (\\<Sum>b\\<in>set bs.\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) b \\<odot> b)\n\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys (pm_of_idx_pm bs (vectorize_poly s)).\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) v \\<odot> v) =\n  (\\<Sum>b\\<in>set bs.\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) b \\<odot> b)\n\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "have \"... = sum_list (map (\\<lambda>b. mult_scalar (lookup (pm_of_idx_pm bs (vectorize_poly s)) b) b) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>set bs.\n       lookup (pm_of_idx_pm bs (vectorize_poly s)) b \\<odot> b) =\n    (\\<Sum>b\\<leftarrow>bs. lookup (pm_of_idx_pm bs (vectorize_poly s))\n                             b \\<odot>\n                            b)", "by (simp only: sum_code distinct_remdups_id[OF assms(1)])"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set bs.\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) b \\<odot> b) =\n  (\\<Sum>b\\<leftarrow>bs. lookup (pm_of_idx_pm bs (vectorize_poly s))\n                           b \\<odot>\n                          b)\n\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set bs.\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) b \\<odot> b) =\n  (\\<Sum>b\\<leftarrow>bs. lookup (pm_of_idx_pm bs (vectorize_poly s))\n                           b \\<odot>\n                          b)\n\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "have \"... = sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<leftarrow>bs. lookup (pm_of_idx_pm bs (vectorize_poly s))\n                             b \\<odot>\n                            b) =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)", "proof (rule arg_cong[of _ _ sum_list], rule nth_equalityI, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) \\<odot> bs ! i =\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) \\<odot> bs ! i =\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i", "assume \"i < length bs\""], ["proof (state)\nthis:\n  i < length bs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) \\<odot> bs ! i =\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i", "with assms(1)"], ["proof (chain)\npicking this:\n  distinct bs\n  i < length bs", "have \"lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) =\n                          cofactor_list_syz (length bs) s ! i\""], ["proof (prove)\nusing this:\n  distinct bs\n  i < length bs\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) =\n    cofactor_list_syz (length bs) s ! i", "by (simp add: lookup_pm_of_idx_pm_distinct[OF assms(1)] cofactor_list_syz_nth lookup_vectorize_poly)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) =\n  cofactor_list_syz (length bs) s ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) \\<odot> bs ! i =\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i", "thus \"mult_scalar (lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i)) (bs ! i) =\n            mult_scalar (cofactor_list_syz (length bs) s ! i) (bs ! i)\""], ["proof (prove)\nusing this:\n  lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) =\n  cofactor_list_syz (length bs) s ! i\n\ngoal (1 subgoal):\n 1. lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) \\<odot> bs ! i =\n    cofactor_list_syz (length bs) s ! i \\<odot> bs ! i", "by (simp only:)"], ["proof (state)\nthis:\n  lookup (pm_of_idx_pm bs (vectorize_poly s)) (bs ! i) \\<odot> bs ! i =\n  cofactor_list_syz (length bs) s ! i \\<odot> bs ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>bs. lookup (pm_of_idx_pm bs (vectorize_poly s))\n                           b \\<odot>\n                          b) =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)\n\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>bs. lookup (pm_of_idx_pm bs (vectorize_poly s))\n                           b \\<odot>\n                          b) =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)\n\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) = 0", "by (fact assms(2))"], ["proof (state)\nthis:\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) = 0\n\ngoal (2 subgoals):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs\n 2. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>v\\<in>keys (pm_of_idx_pm bs (vectorize_poly s)).\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) v \\<odot> v) =\n  0", "show \"pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>keys (pm_of_idx_pm bs (vectorize_poly s)).\n     lookup (pm_of_idx_pm bs (vectorize_poly s)) v \\<odot> v) =\n  0\n\ngoal (1 subgoal):\n 1. pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0", "by (simp only: pmdl.rep_def)"], ["proof (state)\nthis:\n  pmdl.rep (pm_of_idx_pm bs (vectorize_poly s)) = 0\n\ngoal (1 subgoal):\n 1. keys (pm_of_idx_pm bs (vectorize_poly s)) \\<subseteq> set bs", "qed (fact keys_pm_of_idx_pm_subset)"], ["proof (state)\nthis:\n  pm_of_idx_pm bs (vectorize_poly s) \\<in> pmdl.syzygy_module (set bs)\n\ngoal (1 subgoal):\n 1. s = atomize_poly (idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s = atomize_poly (idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)))", "from assms(3)"], ["proof (chain)\npicking this:\n  component_of_term ` keys s \\<subseteq> {0..<length bs}", "have \"keys (vectorize_poly s) \\<subseteq> {0..<length bs}\""], ["proof (prove)\nusing this:\n  component_of_term ` keys s \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. keys (vectorize_poly s) \\<subseteq> {0..<length bs}", "by (simp add: keys_vectorize_poly)"], ["proof (state)\nthis:\n  keys (vectorize_poly s) \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. s = atomize_poly (idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)))", "with assms(1)"], ["proof (chain)\npicking this:\n  distinct bs\n  keys (vectorize_poly s) \\<subseteq> {0..<length bs}", "have \"idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)) = vectorize_poly s\""], ["proof (prove)\nusing this:\n  distinct bs\n  keys (vectorize_poly s) \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)) = vectorize_poly s", "by (rule idx_pm_of_pm_of_idx_pm)"], ["proof (state)\nthis:\n  idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)) = vectorize_poly s\n\ngoal (1 subgoal):\n 1. s = atomize_poly (idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)))", "thus \"s = atomize_poly (idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)))\""], ["proof (prove)\nusing this:\n  idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)) = vectorize_poly s\n\ngoal (1 subgoal):\n 1. s = atomize_poly (idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)))", "by (simp add: atomize_vectorize_poly)"], ["proof (state)\nthis:\n  s = atomize_poly (idx_pm_of_pm bs (pm_of_idx_pm bs (vectorize_poly s)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma component_of_syzygy_module_list:\n  assumes \"s \\<in> syzygy_module_list bs\"\n  shows \"component_of_term ` keys s \\<subseteq> {0..<length bs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "from assms"], ["proof (chain)\npicking this:\n  s \\<in> syzygy_module_list bs", "obtain s' where s: \"s = atomize_poly (idx_pm_of_pm bs s')\""], ["proof (prove)\nusing this:\n  s \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        s = atomize_poly (idx_pm_of_pm bs s') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule syzygy_module_listE)"], ["proof (state)\nthis:\n  s = atomize_poly (idx_pm_of_pm bs s')\n\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "have \"component_of_term ` keys s \\<subseteq> (\\<Union>x\\<in>{0..<length bs}. {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys s\n    \\<subseteq> (\\<Union>x\\<in>{0..<length bs}. {x})", "by (simp only: s keys_atomize_poly image_UN, rule UN_mono, fact keys_idx_pm_of_pm_subset, auto simp: term_simps)"], ["proof (state)\nthis:\n  component_of_term ` keys s\n  \\<subseteq> (\\<Union>x\\<in>{0..<length bs}. {x})\n\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "also"], ["proof (state)\nthis:\n  component_of_term ` keys s\n  \\<subseteq> (\\<Union>x\\<in>{0..<length bs}. {x})\n\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "have \"... = {0..<length bs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>{0..<length bs}. {x}) = {0..<length bs}", "by simp"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>{0..<length bs}. {x}) = {0..<length bs}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "finally"], ["proof (chain)\npicking this:\n  component_of_term ` keys s \\<subseteq> {0..<length bs}", "show ?thesis"], ["proof (prove)\nusing this:\n  component_of_term ` keys s \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "."], ["proof (state)\nthis:\n  component_of_term ` keys s \\<subseteq> {0..<length bs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map2_mult_scalar_proj_poly_syz:\n  \"map2 mult_scalar xs (map (proj_poly_syz n) ys) =\n    map (proj_poly_syz n \\<circ> (\\<lambda>(x, y). mult_scalar x y)) (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<odot>) xs (map (proj_poly_syz n) ys) =\n    map (proj_poly_syz n \\<circ> (\\<lambda>(x, y). x \\<odot> y)) (zip xs ys)", "by (rule nth_equalityI, simp_all add: proj_poly_syz_mult_scalar)"], ["", "lemma map2_times_proj:\n  \"map2 (*) xs (map (proj_poly k) ys) = map (proj_poly k \\<circ> (\\<lambda>(x, y). x \\<odot> y)) (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (*) xs (map (proj_poly k) ys) =\n    map (proj_poly k \\<circ> (\\<lambda>(x, y). x \\<odot> y)) (zip xs ys)", "by (rule nth_equalityI, simp_all add: proj_mult_scalar)"], ["", "text \\<open>Probably the following lemma also holds without the distinctness constraint on \\<open>bs\\<close>.\\<close>"], ["", "lemma syzygy_module_list_subset:\n  assumes \"distinct bs\"\n  shows \"syzygy_module_list bs \\<subseteq> pmdl (set (init_syzygy_list bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syzygy_module_list bs \\<subseteq> pmdl (set (init_syzygy_list bs))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "let ?as = \"init_syzygy_list bs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "assume \"s \\<in> syzygy_module_list bs\""], ["proof (state)\nthis:\n  s \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "then"], ["proof (chain)\npicking this:\n  s \\<in> syzygy_module_list bs", "obtain s' where s': \"s' \\<in> pmdl.syzygy_module (set bs)\"\n    and s: \"s = atomize_poly (idx_pm_of_pm bs s')\""], ["proof (prove)\nusing this:\n  s \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> pmdl.syzygy_module (set bs);\n         s = atomize_poly (idx_pm_of_pm bs s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule syzygy_module_listE)"], ["proof (state)\nthis:\n  s' \\<in> pmdl.syzygy_module (set bs)\n  s = atomize_poly (idx_pm_of_pm bs s')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "from s'"], ["proof (chain)\npicking this:\n  s' \\<in> pmdl.syzygy_module (set bs)", "have \"pmdl.represents (set bs) s' 0\""], ["proof (prove)\nusing this:\n  s' \\<in> pmdl.syzygy_module (set bs)\n\ngoal (1 subgoal):\n 1. pmdl.represents (set bs) s' 0", "by (rule pmdl.syzygy_moduleD)"], ["proof (state)\nthis:\n  pmdl.represents (set bs) s' 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "hence \"keys s' \\<subseteq> set bs\" and 1: \"0 = pmdl.rep s'\""], ["proof (prove)\nusing this:\n  pmdl.represents (set bs) s' 0\n\ngoal (1 subgoal):\n 1. keys s' \\<subseteq> set bs &&& 0 = pmdl.rep s'", "by (rule pmdl.representsD1, rule pmdl.representsD2)"], ["proof (state)\nthis:\n  keys s' \\<subseteq> set bs\n  0 = pmdl.rep s'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "have \"s = sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s) (init_syzygy_list bs))\"\n    (is \"_ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs))", "proof (rule poly_mapping_eqI_proj_syz)"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"proj_poly_syz (length bs) ?r =\n            sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s)\n                                            (map (proj_poly_syz (length bs)) (init_syzygy_list bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs)\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs))) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (map (proj_poly_syz (length bs)) (init_syzygy_list bs)))", "by (simp add: proj_poly_syz_sum_list map2_mult_scalar_proj_poly_syz)"], ["proof (state)\nthis:\n  proj_poly_syz (length bs)\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs))) =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n     (map (proj_poly_syz (length bs)) (init_syzygy_list bs)))\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "also"], ["proof (state)\nthis:\n  proj_poly_syz (length bs)\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs))) =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n     (map (proj_poly_syz (length bs)) (init_syzygy_list bs)))\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"... = sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (map (proj_poly_syz (length bs)) (init_syzygy_list bs))) =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)", "by (simp add: proj_orig_basis_def[symmetric])"], ["proof (state)\nthis:\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n     (map (proj_poly_syz (length bs)) (init_syzygy_list bs))) =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "also"], ["proof (state)\nthis:\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n     (map (proj_poly_syz (length bs)) (init_syzygy_list bs))) =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"... = sum_list (map (\\<lambda>b. mult_scalar (lookup s' b) b) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) =\n    (\\<Sum>b\\<leftarrow>bs. lookup s' b \\<odot> b)", "proof (rule arg_cong[of _ _ sum_list], rule nth_equalityI, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i =\n       lookup s' (bs ! i) \\<odot> bs ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i =\n       lookup s' (bs ! i) \\<odot> bs ! i", "assume \"i < length bs\""], ["proof (state)\nthis:\n  i < length bs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i =\n       lookup s' (bs ! i) \\<odot> bs ! i", "with assms(1)"], ["proof (chain)\npicking this:\n  distinct bs\n  i < length bs", "have \"lookup s' (bs ! i) = cofactor_list_syz (length bs) s ! i\""], ["proof (prove)\nusing this:\n  distinct bs\n  i < length bs\n\ngoal (1 subgoal):\n 1. lookup s' (bs ! i) = cofactor_list_syz (length bs) s ! i", "by (simp add: s cofactor_list_syz_nth lookup_idx_pm_of_pm proj_atomize_poly)"], ["proof (state)\nthis:\n  lookup s' (bs ! i) = cofactor_list_syz (length bs) s ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length bs \\<Longrightarrow>\n       cofactor_list_syz (length bs) s ! i \\<odot> bs ! i =\n       lookup s' (bs ! i) \\<odot> bs ! i", "thus \"mult_scalar (cofactor_list_syz (length bs) s ! i) (bs ! i) =\n            mult_scalar (lookup s' (bs ! i)) (bs ! i)\""], ["proof (prove)\nusing this:\n  lookup s' (bs ! i) = cofactor_list_syz (length bs) s ! i\n\ngoal (1 subgoal):\n 1. cofactor_list_syz (length bs) s ! i \\<odot> bs ! i =\n    lookup s' (bs ! i) \\<odot> bs ! i", "by (simp only:)"], ["proof (state)\nthis:\n  cofactor_list_syz (length bs) s ! i \\<odot> bs ! i =\n  lookup s' (bs ! i) \\<odot> bs ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) =\n  (\\<Sum>b\\<leftarrow>bs. lookup s' b \\<odot> b)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "also"], ["proof (state)\nthis:\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) =\n  (\\<Sum>b\\<leftarrow>bs. lookup s' b \\<odot> b)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"... = (\\<Sum>b\\<in>set bs. mult_scalar (lookup s' b) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<leftarrow>bs. lookup s' b \\<odot> b) =\n    (\\<Sum>b\\<in>set bs. lookup s' b \\<odot> b)", "by (simp only: sum_code distinct_remdups_id[OF assms])"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>bs. lookup s' b \\<odot> b) =\n  (\\<Sum>b\\<in>set bs. lookup s' b \\<odot> b)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<leftarrow>bs. lookup s' b \\<odot> b) =\n  (\\<Sum>b\\<in>set bs. lookup s' b \\<odot> b)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"... = (\\<Sum>v\\<in>keys s'. mult_scalar (lookup s' v) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>set bs. lookup s' b \\<odot> b) =\n    (\\<Sum>v\\<in>keys s'. lookup s' v \\<odot> v)", "by (rule sum.mono_neutral_right, fact finite_set, fact, simp add: in_keys_iff)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set bs. lookup s' b \\<odot> b) =\n  (\\<Sum>v\\<in>keys s'. lookup s' v \\<odot> v)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set bs. lookup s' b \\<odot> b) =\n  (\\<Sum>v\\<in>keys s'. lookup s' v \\<odot> v)\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>keys s'. lookup s' v \\<odot> v) = 0", "by (simp add: 1 pmdl.rep_def)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>keys s'. lookup s' v \\<odot> v) = 0\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "finally"], ["proof (chain)\npicking this:\n  proj_poly_syz (length bs)\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs))) =\n  0", "have eq: \"proj_poly_syz (length bs) ?r = 0\""], ["proof (prove)\nusing this:\n  proj_poly_syz (length bs)\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs))) =\n  0\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs)\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs))) =\n    0", "."], ["proof (state)\nthis:\n  proj_poly_syz (length bs)\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs))) =\n  0\n\ngoal (2 subgoals):\n 1. proj_poly_syz ?n s =\n    proj_poly_syz ?n\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))\n 2. \\<And>k.\n       k < ?n \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "show \"proj_poly_syz (length bs) s = proj_poly_syz (length bs) ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) s =\n    proj_poly_syz (length bs)\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))", "by (simp add: eq \\<open>s \\<in> syzygy_module_list bs\\<close> proj_poly_syz_eq_zero_iff component_of_syzygy_module_list)"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) s =\n  proj_poly_syz (length bs)\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "assume \"k < length bs\""], ["proof (state)\nthis:\n  k < length bs\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"proj_poly k s = map2 (*) (cofactor_list_syz (length bs) s) (map (proj_poly k)\n                                            (init_syzygy_list bs)) ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly k s =\n    map2 (*) (cofactor_list_syz (length bs) s)\n     (map (proj_poly k) (init_syzygy_list bs)) !\n    k", "by (simp add: \\<open>k < length bs\\<close> init_syzygy_list_nth proj_lift_poly_syz cofactor_list_syz_nth)"], ["proof (state)\nthis:\n  proj_poly k s =\n  map2 (*) (cofactor_list_syz (length bs) s)\n   (map (proj_poly k) (init_syzygy_list bs)) !\n  k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "also"], ["proof (state)\nthis:\n  proj_poly k s =\n  map2 (*) (cofactor_list_syz (length bs) s)\n   (map (proj_poly k) (init_syzygy_list bs)) !\n  k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"... = sum_list (map2 (*) (cofactor_list_syz (length bs) s)\n                                            (map (proj_poly k) (init_syzygy_list bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (*) (cofactor_list_syz (length bs) s)\n     (map (proj_poly k) (init_syzygy_list bs)) !\n    k =\n    sum_list\n     (map2 (*) (cofactor_list_syz (length bs) s)\n       (map (proj_poly k) (init_syzygy_list bs)))", "by (rule sum_list_eq_nthI[symmetric],\n          simp_all add: \\<open>k < length bs\\<close> init_syzygy_list_nth proj_lift_poly_syz)"], ["proof (state)\nthis:\n  map2 (*) (cofactor_list_syz (length bs) s)\n   (map (proj_poly k) (init_syzygy_list bs)) !\n  k =\n  sum_list\n   (map2 (*) (cofactor_list_syz (length bs) s)\n     (map (proj_poly k) (init_syzygy_list bs)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "also"], ["proof (state)\nthis:\n  map2 (*) (cofactor_list_syz (length bs) s)\n   (map (proj_poly k) (init_syzygy_list bs)) !\n  k =\n  sum_list\n   (map2 (*) (cofactor_list_syz (length bs) s)\n     (map (proj_poly k) (init_syzygy_list bs)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "have \"... = proj_poly k ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (*) (cofactor_list_syz (length bs) s)\n       (map (proj_poly k) (init_syzygy_list bs))) =\n    proj_poly k\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))", "by (simp add: proj_sum_list map2_times_proj)"], ["proof (state)\nthis:\n  sum_list\n   (map2 (*) (cofactor_list_syz (length bs) s)\n     (map (proj_poly k) (init_syzygy_list bs))) =\n  proj_poly k\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs)))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length bs \\<Longrightarrow>\n       proj_poly k s =\n       proj_poly k\n        (sum_list\n          (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n            (init_syzygy_list bs)))", "finally"], ["proof (chain)\npicking this:\n  proj_poly k s =\n  proj_poly k\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs)))", "show \"proj_poly k s = proj_poly k ?r\""], ["proof (prove)\nusing this:\n  proj_poly k s =\n  proj_poly k\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs)))\n\ngoal (1 subgoal):\n 1. proj_poly k s =\n    proj_poly k\n     (sum_list\n       (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n         (init_syzygy_list bs)))", "."], ["proof (state)\nthis:\n  proj_poly k s =\n  proj_poly k\n   (sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) s) (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "also"], ["proof (state)\nthis:\n  s =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) s) (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "have \"\\<dots> \\<in> pmdl (set (init_syzygy_list bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) s)\n       (init_syzygy_list bs))\n    \\<in> pmdl (set (init_syzygy_list bs))", "by (fact pmdl.span_listI)"], ["proof (state)\nthis:\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) s) (init_syzygy_list bs))\n  \\<in> pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> syzygy_module_list bs \\<Longrightarrow>\n       x \\<in> pmdl (set (init_syzygy_list bs))", "finally"], ["proof (chain)\npicking this:\n  s \\<in> pmdl (set (init_syzygy_list bs))", "show \"s \\<in> pmdl (set (init_syzygy_list bs))\""], ["proof (prove)\nusing this:\n  s \\<in> pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. s \\<in> pmdl (set (init_syzygy_list bs))", "."], ["proof (state)\nthis:\n  s \\<in> pmdl (set (init_syzygy_list bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Cofactors\\<close>"], ["", "lemma map2_mult_scalar_plus:\n  \"map2 (\\<odot>) (map2 (+) xs ys) zs = map2 (+) (map2 (\\<odot>) xs zs) (map2 (\\<odot>) ys zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<odot>) (map2 (+) xs ys) zs =\n    map2 (+) (map2 (\\<odot>) xs zs) (map2 (\\<odot>) ys zs)", "by (rule nth_equalityI, simp_all add: mult_scalar_distrib_right)"], ["", "lemma syz_cofactors:\n  assumes \"p \\<in> pmdl (set (init_syzygy_list bs))\"\n  shows \"proj_poly_syz (length bs) p = sum_list (map2 mult_scalar (cofactor_list_syz (length bs) p) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) p =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs)", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) p =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs)", "proof (induct rule: pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_poly_syz (length bs) 0 =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) 0) bs)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "case module_0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. proj_poly_syz (length bs) 0 =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) 0) bs)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) 0 =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) 0) bs)", "by (simp, rule sum_list_zeroI', simp)"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) 0 =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) 0) bs)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "case (module_plus p b c t)"], ["proof (state)\nthis:\n  p \\<in> pmdl (set (init_syzygy_list bs))\n  proj_poly_syz (length bs) p =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs)\n  b \\<in> set (init_syzygy_list bs)\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "from this(3)"], ["proof (chain)\npicking this:\n  b \\<in> set (init_syzygy_list bs)", "obtain i where i: \"i < length bs\" and b: \"b = (init_syzygy_list bs) ! i\""], ["proof (prove)\nusing this:\n  b \\<in> set (init_syzygy_list bs)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length bs; b = init_syzygy_list bs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding length_init_syzygy_list[symmetric, of bs]"], ["proof (prove)\nusing this:\n  b \\<in> set (init_syzygy_list bs)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (init_syzygy_list bs);\n         b = init_syzygy_list bs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length bs\n  b = init_syzygy_list bs ! i\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "have \"proj_poly_syz (length bs) (p + monom_mult c t b) =\n        proj_poly_syz (length bs) p + monom_mult c t (bs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) (p + monom_mult c t b) =\n    proj_poly_syz (length bs) p + monom_mult c t (bs ! i)", "by (simp only: proj_poly_syz_plus proj_poly_syz_monom_mult b init_syzygy_list_nth[OF i]\n        proj_poly_syz_lift_poly_syz[OF i])"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) (p + monom_mult c t b) =\n  proj_poly_syz (length bs) p + monom_mult c t (bs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "also"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) (p + monom_mult c t b) =\n  proj_poly_syz (length bs) p + monom_mult c t (bs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "have \"... = sum_list (map2 mult_scalar (cofactor_list_syz (length bs) p) bs) +\n                    monom_mult c t (bs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) p + monom_mult c t (bs ! i) =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs) +\n    monom_mult c t (bs ! i)", "by (simp only: module_plus(2))"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) p + monom_mult c t (bs ! i) =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs) +\n  monom_mult c t (bs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "also"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) p + monom_mult c t (bs ! i) =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs) +\n  monom_mult c t (bs ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "have \"... = sum_list (map2 mult_scalar (cofactor_list_syz (length bs) (p + monom_mult c t b)) bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs) +\n    monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (p + monom_mult c t b))\n       bs)", "proof (simp add: cofactor_list_syz_plus map2_mult_scalar_plus sum_list_map2_plus)"], ["proof (state)\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "have proj_b: \"j < length bs \\<Longrightarrow> proj_poly j b = (1 when j = i)\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length bs \\<Longrightarrow> proj_poly j b = (1 when j = i)", "by (simp add: b init_syzygy_list_nth i proj_lift_poly_syz)"], ["proof (state)\nthis:\n  ?j48 < length bs \\<Longrightarrow> proj_poly ?j48 b = (1 when ?j48 = i)\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "have eq: \"j < length bs \\<Longrightarrow> (map2 mult_scalar (cofactor_list_syz (length bs) (monom_mult c t b)) bs) ! j =\n              (monom_mult c t (bs ! i) when j = i)\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length bs \\<Longrightarrow>\n    map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs !\n    j =\n    (monom_mult c t (bs ! i) when j = i)", "by (simp add: cofactor_list_syz_nth proj_monom_mult proj_b mult_scalar_monom_mult when_def)"], ["proof (state)\nthis:\n  ?j48 < length bs \\<Longrightarrow>\n  map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs !\n  ?j48 =\n  (monom_mult c t (bs ! i) when ?j48 = i)\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "have \"sum_list (map2 mult_scalar (cofactor_list_syz (length bs) (monom_mult c t b)) bs) =\n          (map2 mult_scalar (cofactor_list_syz (length bs) (monom_mult c t b)) bs) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b))\n       bs) =\n    map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs ! i", "by (rule sum_list_eq_nthI, simp add: i, simp add: eq del: nth_zip nth_map)"], ["proof (state)\nthis:\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs) =\n  map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs ! i\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "also"], ["proof (state)\nthis:\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs) =\n  map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs ! i\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "have \"... = mult_scalar (punit.monom_mult c t (proj_poly i b)) (bs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs !\n    i =\n    local.punit.monom_mult c t (proj_poly i b) \\<odot> bs ! i", "by (simp add: i cofactor_list_syz_nth proj_monom_mult)"], ["proof (state)\nthis:\n  map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs ! i =\n  local.punit.monom_mult c t (proj_poly i b) \\<odot> bs ! i\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "also"], ["proof (state)\nthis:\n  map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs ! i =\n  local.punit.monom_mult c t (proj_poly i b) \\<odot> bs ! i\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "have \"... = monom_mult c t (bs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.punit.monom_mult c t (proj_poly i b) \\<odot> bs ! i =\n    monom_mult c t (bs ! i)", "by (simp add: proj_b i mult_scalar_monomial times_monomial_left[symmetric])"], ["proof (state)\nthis:\n  local.punit.monom_mult c t (proj_poly i b) \\<odot> bs ! i =\n  monom_mult c t (bs ! i)\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "finally"], ["proof (chain)\npicking this:\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs) =\n  monom_mult c t (bs ! i)", "show \"monom_mult c t (bs ! i) =\n          sum_list (map2 mult_scalar (cofactor_list_syz (length bs) (monom_mult c t b)) bs)\""], ["proof (prove)\nusing this:\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs) =\n  monom_mult c t (bs ! i)\n\ngoal (1 subgoal):\n 1. monom_mult c t (bs ! i) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)", "by (simp only:)"], ["proof (state)\nthis:\n  monom_mult c t (bs ! i) =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (monom_mult c t b)) bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) p) bs) +\n  monom_mult c t (bs ! i) =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (p + monom_mult c t b))\n     bs)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (set (init_syzygy_list bs));\n        proj_poly_syz (length bs) a =\n        sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) a) bs);\n        p \\<in> set (init_syzygy_list bs); c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> proj_poly_syz (length bs) (a + monom_mult c t p) =\n                         sum_list\n                          (map2 (\\<odot>)\n                            (cofactor_list_syz (length bs)\n                              (a + monom_mult c t p))\n                            bs)", "finally"], ["proof (chain)\npicking this:\n  proj_poly_syz (length bs) (p + monom_mult c t b) =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (p + monom_mult c t b))\n     bs)", "show ?case"], ["proof (prove)\nusing this:\n  proj_poly_syz (length bs) (p + monom_mult c t b) =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (p + monom_mult c t b))\n     bs)\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) (p + monom_mult c t b) =\n    sum_list\n     (map2 (\\<odot>) (cofactor_list_syz (length bs) (p + monom_mult c t b))\n       bs)", "."], ["proof (state)\nthis:\n  proj_poly_syz (length bs) (p + monom_mult c t b) =\n  sum_list\n   (map2 (\\<odot>) (cofactor_list_syz (length bs) (p + monom_mult c t b))\n     bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Modules\\<close>"], ["", "lemma pmdl_proj_orig_basis:\n  assumes \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"pmdl (set (proj_orig_basis (length bs) gs)) = pmdl (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (proj_orig_basis (length bs) gs)) = pmdl (set bs)", "by (simp add: pmdl_proj_orig_basis' assms,\n      simp only: pmdl_proj_orig_basis'[symmetric] proj_orig_basis_init_syzygy_list)"], ["", "lemma pmdl_filter_syzygy_basis_subset:\n  assumes \"distinct bs\" and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"pmdl (set (filter_syzygy_basis (length bs) gs)) \\<subseteq> pmdl (syzygy_module_list bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs))\n    \\<subseteq> pmdl (syzygy_module_list bs)", "proof (rule pmdl.span_mono, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "assume \"s \\<in> set (filter_syzygy_basis (length bs) gs)\""], ["proof (state)\nthis:\n  s \\<in> set (filter_syzygy_basis (length bs) gs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "hence \"s \\<in> set gs\" and eq: \"proj_poly_syz (length bs) s = 0\""], ["proof (prove)\nusing this:\n  s \\<in> set (filter_syzygy_basis (length bs) gs)\n\ngoal (1 subgoal):\n 1. s \\<in> set gs &&& proj_poly_syz (length bs) s = 0", "by (simp_all add: set_filter_syzygy_basis)"], ["proof (state)\nthis:\n  s \\<in> set gs\n  proj_poly_syz (length bs) s = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> set gs", "have \"s \\<in> pmdl (set gs)\""], ["proof (prove)\nusing this:\n  s \\<in> set gs\n\ngoal (1 subgoal):\n 1. s \\<in> pmdl (set gs)", "by (rule pmdl.span_base)"], ["proof (state)\nthis:\n  s \\<in> pmdl (set gs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "hence \"s \\<in> pmdl (set (init_syzygy_list bs))\""], ["proof (prove)\nusing this:\n  s \\<in> pmdl (set gs)\n\ngoal (1 subgoal):\n 1. s \\<in> pmdl (set (init_syzygy_list bs))", "by (simp only: assms)"], ["proof (state)\nthis:\n  s \\<in> pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "hence \"proj_poly_syz (length bs) s =\n          sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s) bs)\""], ["proof (prove)\nusing this:\n  s \\<in> pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) s =\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)", "by (rule syz_cofactors)"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) s =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "hence \"distinct bs\" and \"sum_list (map2 mult_scalar (cofactor_list_syz (length bs) s) bs) = 0\""], ["proof (prove)\nusing this:\n  proj_poly_syz (length bs) s =\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs)\n\ngoal (1 subgoal):\n 1. distinct bs &&&\n    sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) = 0", "by (simp_all only: eq assms(1))"], ["proof (state)\nthis:\n  distinct bs\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "moreover"], ["proof (state)\nthis:\n  distinct bs\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "from eq"], ["proof (chain)\npicking this:\n  proj_poly_syz (length bs) s = 0", "have \"component_of_term ` keys s \\<subseteq> {0..<length bs}\""], ["proof (prove)\nusing this:\n  proj_poly_syz (length bs) s = 0\n\ngoal (1 subgoal):\n 1. component_of_term ` keys s \\<subseteq> {0..<length bs}", "by (simp only: proj_poly_syz_eq_zero_iff)"], ["proof (state)\nthis:\n  component_of_term ` keys s \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (filter_syzygy_basis (length bs) gs) \\<Longrightarrow>\n       x \\<in> syzygy_module_list bs", "ultimately"], ["proof (chain)\npicking this:\n  distinct bs\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) = 0\n  component_of_term ` keys s \\<subseteq> {0..<length bs}", "show \"s \\<in> syzygy_module_list bs\""], ["proof (prove)\nusing this:\n  distinct bs\n  sum_list (map2 (\\<odot>) (cofactor_list_syz (length bs) s) bs) = 0\n  component_of_term ` keys s \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. s \\<in> syzygy_module_list bs", "by (rule syzygy_module_listI')"], ["proof (state)\nthis:\n  s \\<in> syzygy_module_list bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_filter_syzygy_basis_adds_lt:\n  assumes \"is_pot_ord\" and \"distinct bs\" and \"is_Groebner_basis (set gs)\"\n    and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n    and \"f \\<in> pmdl (syzygy_module_list bs)\" and \"f \\<noteq> 0\"\n  shows \"\\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs). g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "from assms(5)"], ["proof (chain)\npicking this:\n  f \\<in> pmdl (syzygy_module_list bs)", "have \"f \\<in> syzygy_module_list bs\""], ["proof (prove)\nusing this:\n  f \\<in> pmdl (syzygy_module_list bs)\n\ngoal (1 subgoal):\n 1. f \\<in> syzygy_module_list bs", "by simp"], ["proof (state)\nthis:\n  f \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "also"], ["proof (state)\nthis:\n  f \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "from assms(2)"], ["proof (chain)\npicking this:\n  distinct bs", "have \"... \\<subseteq> pmdl (set (init_syzygy_list bs))\""], ["proof (prove)\nusing this:\n  distinct bs\n\ngoal (1 subgoal):\n 1. syzygy_module_list bs \\<subseteq> pmdl (set (init_syzygy_list bs))", "by (rule syzygy_module_list_subset)"], ["proof (state)\nthis:\n  syzygy_module_list bs \\<subseteq> pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "also"], ["proof (state)\nthis:\n  syzygy_module_list bs \\<subseteq> pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "have \"... = pmdl (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (init_syzygy_list bs)) = pmdl (set gs)", "by (simp only: assms(4))"], ["proof (state)\nthis:\n  pmdl (set (init_syzygy_list bs)) = pmdl (set gs)\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "finally"], ["proof (chain)\npicking this:\n  f \\<in> pmdl (set gs)", "have \"f \\<in> pmdl (set gs)\""], ["proof (prove)\nusing this:\n  f \\<in> pmdl (set gs)\n\ngoal (1 subgoal):\n 1. f \\<in> pmdl (set gs)", "."], ["proof (state)\nthis:\n  f \\<in> pmdl (set gs)\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "with assms(3, 6)"], ["proof (chain)\npicking this:\n  is_Groebner_basis (set gs)\n  f \\<noteq> 0\n  f \\<in> pmdl (set gs)", "obtain g where \"g \\<in> set gs\" and \"g \\<noteq> 0\"\n    and adds: \"lt g adds\\<^sub>t lt f\""], ["proof (prove)\nusing this:\n  is_Groebner_basis (set gs)\n  f \\<noteq> 0\n  f \\<in> pmdl (set gs)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> set gs; g \\<noteq> 0;\n         lt g adds\\<^sub>t lt f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding GB_alt_3_finite[OF finite_set]"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>pmdl (set gs).\n     f \\<noteq> 0 \\<longrightarrow>\n     (\\<exists>g\\<in>set gs. g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f)\n  f \\<noteq> 0\n  f \\<in> pmdl (set gs)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> set gs; g \\<noteq> 0;\n         lt g adds\\<^sub>t lt f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<in> set gs\n  g \\<noteq> 0\n  lt g adds\\<^sub>t lt f\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "proof (intro bexI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?g \\<noteq> 0\n 2. lt ?g adds\\<^sub>t lt f\n 3. ?g \\<in> set (filter_syzygy_basis (length bs) gs)", "show \"g \\<in> set (filter_syzygy_basis (length bs) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> set (filter_syzygy_basis (length bs) gs)", "proof (simp add: set_filter_syzygy_basis, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<in> set gs\n 2. proj_poly_syz (length bs) g = 0", "show \"proj_poly_syz (length bs) g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0 \\<Longrightarrow> False", "assume \"proj_poly_syz (length bs) g \\<noteq> 0\""], ["proof (state)\nthis:\n  proj_poly_syz (length bs) g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0 \\<Longrightarrow> False", "with assms(1)"], ["proof (chain)\npicking this:\n  is_pot_ord\n  proj_poly_syz (length bs) g \\<noteq> 0", "have \"length bs \\<le> component_of_term (lt g)\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  proj_poly_syz (length bs) g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length bs \\<le> component_of_term (lt g)", "by (rule component_of_lt_ge)"], ["proof (state)\nthis:\n  length bs \\<le> component_of_term (lt g)\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  length bs \\<le> component_of_term (lt g)\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0 \\<Longrightarrow> False", "from adds"], ["proof (chain)\npicking this:\n  lt g adds\\<^sub>t lt f", "have \"... = component_of_term (lt f)\""], ["proof (prove)\nusing this:\n  lt g adds\\<^sub>t lt f\n\ngoal (1 subgoal):\n 1. component_of_term (lt g) = component_of_term (lt f)", "by (simp add: adds_term_def)"], ["proof (state)\nthis:\n  component_of_term (lt g) = component_of_term (lt f)\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  component_of_term (lt g) = component_of_term (lt f)\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0 \\<Longrightarrow> False", "have \"... < length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term (lt f) < length bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term (lt f) < length bs", "from \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have \"lt f \\<in> keys f\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt f \\<in> keys f", "by (rule lt_in_keys)"], ["proof (state)\nthis:\n  lt f \\<in> keys f\n\ngoal (1 subgoal):\n 1. component_of_term (lt f) < length bs", "hence \"component_of_term (lt f) \\<in> component_of_term ` keys f\""], ["proof (prove)\nusing this:\n  lt f \\<in> keys f\n\ngoal (1 subgoal):\n 1. component_of_term (lt f) \\<in> component_of_term ` keys f", "by (rule imageI)"], ["proof (state)\nthis:\n  component_of_term (lt f) \\<in> component_of_term ` keys f\n\ngoal (1 subgoal):\n 1. component_of_term (lt f) < length bs", "also"], ["proof (state)\nthis:\n  component_of_term (lt f) \\<in> component_of_term ` keys f\n\ngoal (1 subgoal):\n 1. component_of_term (lt f) < length bs", "from \\<open>f \\<in> syzygy_module_list bs\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> syzygy_module_list bs", "have \"... \\<subseteq> {0..<length bs}\""], ["proof (prove)\nusing this:\n  f \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. component_of_term ` keys f \\<subseteq> {0..<length bs}", "by (rule component_of_syzygy_module_list)"], ["proof (state)\nthis:\n  component_of_term ` keys f \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. component_of_term (lt f) < length bs", "finally"], ["proof (chain)\npicking this:\n  component_of_term (lt f) \\<in> {0..<length bs}", "show \"component_of_term (lt f) < length bs\""], ["proof (prove)\nusing this:\n  component_of_term (lt f) \\<in> {0..<length bs}\n\ngoal (1 subgoal):\n 1. component_of_term (lt f) < length bs", "by simp"], ["proof (state)\nthis:\n  component_of_term (lt f) < length bs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component_of_term (lt f) < length bs\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  length bs < length bs", "show False"], ["proof (prove)\nusing this:\n  length bs < length bs\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) g = 0\n\ngoal (1 subgoal):\n 1. g \\<in> set gs", "qed fact"], ["proof (state)\nthis:\n  g \\<in> set (filter_syzygy_basis (length bs) gs)\n\ngoal (2 subgoals):\n 1. g \\<noteq> 0\n 2. lt g adds\\<^sub>t lt f", "qed fact+"], ["proof (state)\nthis:\n  \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n     g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmdl_filter_syzygy_basis:\n  fixes bs::\"('t \\<Rightarrow>\\<^sub>0 'b::field) list\"\n  assumes \"is_pot_ord\" and \"distinct bs\" and \"is_Groebner_basis (set gs)\" and\n    \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs", "from finite_set"], ["proof (chain)\npicking this:\n  finite (set ?xs)", "have \"pmdl (set (filter_syzygy_basis (length bs) gs)) = pmdl (syzygy_module_list bs)\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs)) =\n    pmdl (syzygy_module_list bs)", "proof (rule pmdl_eqI_adds_lt_finite)"], ["proof (state)\ngoal (2 subgoals):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs))\n    \\<subseteq> pmdl (syzygy_module_list bs)\n 2. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (syzygy_module_list bs); f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "from assms(2, 4)"], ["proof (chain)\npicking this:\n  distinct bs\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))", "show \"pmdl (set (filter_syzygy_basis (length bs) gs)) \\<subseteq> pmdl (syzygy_module_list bs)\""], ["proof (prove)\nusing this:\n  distinct bs\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs))\n    \\<subseteq> pmdl (syzygy_module_list bs)", "by (rule pmdl_filter_syzygy_basis_subset)"], ["proof (state)\nthis:\n  pmdl (set (filter_syzygy_basis (length bs) gs))\n  \\<subseteq> pmdl (syzygy_module_list bs)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (syzygy_module_list bs); f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (syzygy_module_list bs); f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (syzygy_module_list bs); f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "assume \"f \\<in> pmdl (syzygy_module_list bs)\" and \"f \\<noteq> 0\""], ["proof (state)\nthis:\n  f \\<in> pmdl (syzygy_module_list bs)\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (syzygy_module_list bs); f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "with assms"], ["proof (chain)\npicking this:\n  is_pot_ord\n  distinct bs\n  is_Groebner_basis (set gs)\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))\n  f \\<in> pmdl (syzygy_module_list bs)\n  f \\<noteq> 0", "show \"\\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs). g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  distinct bs\n  is_Groebner_basis (set gs)\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))\n  f \\<in> pmdl (syzygy_module_list bs)\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "by (rule ex_filter_syzygy_basis_adds_lt)"], ["proof (state)\nthis:\n  \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n     g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl (set (filter_syzygy_basis (length bs) gs)) =\n  pmdl (syzygy_module_list bs)\n\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs", "thus ?thesis"], ["proof (prove)\nusing this:\n  pmdl (set (filter_syzygy_basis (length bs) gs)) =\n  pmdl (syzygy_module_list bs)\n\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs", "by simp"], ["proof (state)\nthis:\n  pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Gr\\\"obner Bases\\<close>"], ["", "lemma proj_orig_basis_isGB:\n  assumes \"is_pot_ord\" and \"is_Groebner_basis (set gs)\" and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"is_Groebner_basis (set (proj_orig_basis (length bs) gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Groebner_basis (set (proj_orig_basis (length bs) gs))", "unfolding GB_alt_3_finite[OF finite_set]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>pmdl (set (proj_orig_basis (length bs) gs)).\n       f \\<noteq> 0 \\<longrightarrow>\n       (\\<exists>g\\<in>set (proj_orig_basis (length bs) gs).\n           g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f)", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "assume \"f \\<in> pmdl (set (proj_orig_basis (length bs) gs))\""], ["proof (state)\nthis:\n  f \\<in> pmdl (set (proj_orig_basis (length bs) gs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "also"], ["proof (state)\nthis:\n  f \\<in> pmdl (set (proj_orig_basis (length bs) gs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "have \"... = proj_poly_syz (length bs) ` pmdl (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (proj_orig_basis (length bs) gs)) =\n    proj_poly_syz (length bs) ` pmdl (set gs)", "by (fact pmdl_proj_orig_basis')"], ["proof (state)\nthis:\n  pmdl (set (proj_orig_basis (length bs) gs)) =\n  proj_poly_syz (length bs) ` pmdl (set gs)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "finally"], ["proof (chain)\npicking this:\n  f \\<in> proj_poly_syz (length bs) ` pmdl (set gs)", "obtain h where \"h \\<in> pmdl (set gs)\" and f: \"f = proj_poly_syz (length bs) h\""], ["proof (prove)\nusing this:\n  f \\<in> proj_poly_syz (length bs) ` pmdl (set gs)\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> pmdl (set gs);\n         f = proj_poly_syz (length bs) h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  h \\<in> pmdl (set gs)\n  f = proj_poly_syz (length bs) h\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "assume \"f \\<noteq> 0\""], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "with assms(1)"], ["proof (chain)\npicking this:\n  is_pot_ord\n  f \\<noteq> 0", "have ltf: \"lt f = map_component (\\<lambda>k. k - length bs) (lt h)\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt f = map_component (\\<lambda>k. k - length bs) (lt h)", "unfolding f"], ["proof (prove)\nusing this:\n  is_pot_ord\n  proj_poly_syz (length bs) h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt (proj_poly_syz (length bs) h) =\n    map_component (\\<lambda>k. k - length bs) (lt h)", "by (rule lt_proj_poly_syz)"], ["proof (state)\nthis:\n  lt f = map_component (\\<lambda>k. k - length bs) (lt h)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "from \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by (auto simp add: f)"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "with assms(2) \\<open>h \\<in> pmdl (set gs)\\<close>"], ["proof (chain)\npicking this:\n  is_Groebner_basis (set gs)\n  h \\<in> pmdl (set gs)\n  h \\<noteq> 0", "obtain g where \"g \\<in> set gs\" and \"g \\<noteq> 0\"\n    and \"lt g adds\\<^sub>t lt h\""], ["proof (prove)\nusing this:\n  is_Groebner_basis (set gs)\n  h \\<in> pmdl (set gs)\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> set gs; g \\<noteq> 0;\n         lt g adds\\<^sub>t lt h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding GB_alt_3_finite[OF finite_set]"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>pmdl (set gs).\n     f \\<noteq> 0 \\<longrightarrow>\n     (\\<exists>g\\<in>set gs. g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f)\n  h \\<in> pmdl (set gs)\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> set gs; g \\<noteq> 0;\n         lt g adds\\<^sub>t lt h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<in> set gs\n  g \\<noteq> 0\n  lt g adds\\<^sub>t lt h\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "from this(3)"], ["proof (chain)\npicking this:\n  lt g adds\\<^sub>t lt h", "have 1: \"component_of_term (lt g) = component_of_term (lt h)\"\n    and 2: \"pp_of_term (lt g) adds pp_of_term (lt h)\""], ["proof (prove)\nusing this:\n  lt g adds\\<^sub>t lt h\n\ngoal (1 subgoal):\n 1. component_of_term (lt g) = component_of_term (lt h) &&& lp g adds lp h", "by (simp_all add: adds_term_def)"], ["proof (state)\nthis:\n  component_of_term (lt g) = component_of_term (lt h)\n  lp g adds lp h\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "let ?g = \"proj_poly_syz (length bs) g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "have \"?g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0", "proof (simp add: proj_poly_syz_eq_zero_iff, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` keys g \\<subseteq> {0..<length bs} \\<Longrightarrow>\n    False", "assume \"component_of_term ` keys g \\<subseteq> {0..<length bs}\""], ["proof (state)\nthis:\n  component_of_term ` keys g \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys g \\<subseteq> {0..<length bs} \\<Longrightarrow>\n    False", "from assms(1) \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  is_pot_ord\n  f \\<noteq> 0", "have \"length bs \\<le> component_of_term (lt h)\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length bs \\<le> component_of_term (lt h)", "unfolding f"], ["proof (prove)\nusing this:\n  is_pot_ord\n  proj_poly_syz (length bs) h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length bs \\<le> component_of_term (lt h)", "by (rule component_of_lt_ge)"], ["proof (state)\nthis:\n  length bs \\<le> component_of_term (lt h)\n\ngoal (1 subgoal):\n 1. component_of_term ` keys g \\<subseteq> {0..<length bs} \\<Longrightarrow>\n    False", "hence \"component_of_term (lt g) \\<notin> {0..<length bs}\""], ["proof (prove)\nusing this:\n  length bs \\<le> component_of_term (lt h)\n\ngoal (1 subgoal):\n 1. component_of_term (lt g) \\<notin> {0..<length bs}", "by (simp add: 1)"], ["proof (state)\nthis:\n  component_of_term (lt g) \\<notin> {0..<length bs}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys g \\<subseteq> {0..<length bs} \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  component_of_term (lt g) \\<notin> {0..<length bs}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys g \\<subseteq> {0..<length bs} \\<Longrightarrow>\n    False", "from \\<open>g \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have \"lt g \\<in> keys g\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt g \\<in> keys g", "by (rule lt_in_keys)"], ["proof (state)\nthis:\n  lt g \\<in> keys g\n\ngoal (1 subgoal):\n 1. component_of_term ` keys g \\<subseteq> {0..<length bs} \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  component_of_term (lt g) \\<notin> {0..<length bs}\n  lt g \\<in> keys g", "show False"], ["proof (prove)\nusing this:\n  component_of_term (lt g) \\<notin> {0..<length bs}\n  lt g \\<in> keys g\n\ngoal (1 subgoal):\n 1. False", "using \\<open>component_of_term ` keys g \\<subseteq> {0..<length bs}\\<close>"], ["proof (prove)\nusing this:\n  component_of_term (lt g) \\<notin> {0..<length bs}\n  lt g \\<in> keys g\n  component_of_term ` keys g \\<subseteq> {0..<length bs}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "with assms(1)"], ["proof (chain)\npicking this:\n  is_pot_ord\n  proj_poly_syz (length bs) g \\<noteq> 0", "have ltg: \"lt ?g = map_component (\\<lambda>k. k - length bs) (lt g)\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  proj_poly_syz (length bs) g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt (proj_poly_syz (length bs) g) =\n    map_component (\\<lambda>k. k - length bs) (lt g)", "by (rule lt_proj_poly_syz)"], ["proof (state)\nthis:\n  lt (proj_poly_syz (length bs) g) =\n  map_component (\\<lambda>k. k - length bs) (lt g)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (proj_orig_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (proj_orig_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "show \"\\<exists>g\\<in>set (proj_orig_basis (length bs) gs). g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (proj_orig_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "proof (intro bexI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. ?g \\<noteq> 0\n 2. lt ?g adds\\<^sub>t lt f\n 3. ?g \\<in> set (proj_orig_basis (length bs) gs)", "show \"lt ?g adds\\<^sub>t lt f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (proj_poly_syz (length bs) g) adds\\<^sub>t lt f", "by (simp add: ltf ltg adds_term_def 1 2 term_simps)"], ["proof (state)\nthis:\n  lt (proj_poly_syz (length bs) g) adds\\<^sub>t lt f\n\ngoal (2 subgoals):\n 1. proj_poly_syz (length bs) g \\<noteq> 0\n 2. proj_poly_syz (length bs) g \\<in> set (proj_orig_basis (length bs) gs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. proj_poly_syz (length bs) g \\<noteq> 0\n 2. proj_poly_syz (length bs) g \\<in> set (proj_orig_basis (length bs) gs)", "show \"?g \\<in> set (proj_orig_basis (length bs) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<in> set (proj_orig_basis (length bs) gs)", "unfolding set_proj_orig_basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<in> proj_poly_syz (length bs) ` set gs", "using \\<open>g \\<in> set gs\\<close>"], ["proof (prove)\nusing this:\n  g \\<in> set gs\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<in> proj_poly_syz (length bs) ` set gs", "by (rule imageI)"], ["proof (state)\nthis:\n  proj_poly_syz (length bs) g \\<in> set (proj_orig_basis (length bs) gs)\n\ngoal (1 subgoal):\n 1. proj_poly_syz (length bs) g \\<noteq> 0", "qed fact"], ["proof (state)\nthis:\n  \\<exists>g\\<in>set (proj_orig_basis (length bs) gs).\n     g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_syzygy_basis_isGB:\n  assumes \"is_pot_ord\" and \"distinct bs\" and \"is_Groebner_basis (set gs)\"\n    and \"pmdl (set gs) = pmdl (set (init_syzygy_list bs))\"\n  shows \"is_Groebner_basis (set (filter_syzygy_basis (length bs) gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Groebner_basis (set (filter_syzygy_basis (length bs) gs))", "unfolding GB_alt_3_finite[OF finite_set]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>pmdl (set (filter_syzygy_basis (length bs) gs)).\n       f \\<noteq> 0 \\<longrightarrow>\n       (\\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n           g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f)", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "fix f::\"'t \\<Rightarrow>\\<^sub>0 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "assume \"f \\<noteq> 0\""], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "assume \"f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs))\""], ["proof (state)\nthis:\n  f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "also"], ["proof (state)\nthis:\n  f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "from assms"], ["proof (chain)\npicking this:\n  is_pot_ord\n  distinct bs\n  is_Groebner_basis (set gs)\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))", "have \"... = syzygy_module_list bs\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  distinct bs\n  is_Groebner_basis (set gs)\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))\n\ngoal (1 subgoal):\n 1. pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs", "by (rule pmdl_filter_syzygy_basis)"], ["proof (state)\nthis:\n  pmdl (set (filter_syzygy_basis (length bs) gs)) = syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "finally"], ["proof (chain)\npicking this:\n  f \\<in> syzygy_module_list bs", "have \"f \\<in> pmdl (syzygy_module_list bs)\""], ["proof (prove)\nusing this:\n  f \\<in> syzygy_module_list bs\n\ngoal (1 subgoal):\n 1. f \\<in> pmdl (syzygy_module_list bs)", "by simp"], ["proof (state)\nthis:\n  f \\<in> pmdl (syzygy_module_list bs)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>f \\<in> pmdl (set (filter_syzygy_basis (length bs) gs));\n        f \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>set\n   (filter_syzygy_basis (length bs) gs).\n                            g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "from assms this \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  is_pot_ord\n  distinct bs\n  is_Groebner_basis (set gs)\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))\n  f \\<in> pmdl (syzygy_module_list bs)\n  f \\<noteq> 0", "show \"\\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs). g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\""], ["proof (prove)\nusing this:\n  is_pot_ord\n  distinct bs\n  is_Groebner_basis (set gs)\n  pmdl (set gs) = pmdl (set (init_syzygy_list bs))\n  f \\<in> pmdl (syzygy_module_list bs)\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n       g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f", "by (rule ex_filter_syzygy_basis_adds_lt)"], ["proof (state)\nthis:\n  \\<exists>g\\<in>set (filter_syzygy_basis (length bs) gs).\n     g \\<noteq> 0 \\<and> lt g adds\\<^sub>t lt f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gd_inf_term *)"], ["", "end"], ["", "(* theory *)"]]}