{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/Buchberger.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma trdsp_alt: \"trdsp bs (p, q) = trd bs (spoly (fst p) (fst q))\"", "lemma trdsp_in_pmdl: \"trdsp bs (p, q) \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\"", "lemma dgrad_p_set_le_trdsp:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d {trdsp bs (p, q)} (insert (fst p) (insert (fst q) (set bs)))\"", "lemma components_trdsp_subset:\n  \"component_of_term ` keys (trdsp bs (p, q)) \\<subseteq> component_of_term ` Keys (insert (fst p) (insert (fst q) (set bs)))\"", "lemma set_gb_red_aux: \"set (gb_red_aux bs ps) = (trdsp (map fst bs)) ` set ps - {0}\"", "lemma in_set_gb_red_auxI:\n  assumes \"(p, q) \\<in> set ps\" and \"h = trdsp (map fst bs) (p, q)\" and \"h \\<noteq> 0\"\n  shows \"h \\<in> set (gb_red_aux bs ps)\"", "lemma in_set_gb_red_auxE:\n  assumes \"h \\<in> set (gb_red_aux bs ps)\"\n  obtains p q where \"(p, q) \\<in> set ps\" and \"h = trdsp (map fst bs) (p, q)\"", "lemma gb_red_aux_not_zero: \"0 \\<notin> set (gb_red_aux bs ps)\"", "lemma gb_red_aux_irredudible:\n  assumes \"h \\<in> set (gb_red_aux bs ps)\" and \"b \\<in> set bs\" and \"fst b \\<noteq> 0\"\n  shows \"\\<not> lt (fst b) adds\\<^sub>t lt h\"", "lemma gb_red_aux_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (gb_red_aux bs ps)) (args_to_set ([], bs, ps))\"", "lemma components_gb_red_aux_subset:\n  \"component_of_term ` Keys (set (gb_red_aux bs ps)) \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\"", "lemma pmdl_gb_red_aux: \"set (gb_red_aux bs ps) \\<subseteq> pmdl (args_to_set ([], bs, ps))\"", "lemma gb_red_aux_spoly_reducible:\n  assumes \"(p, q) \\<in> set ps\"\n  shows \"(red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) 0\"", "lemma fst_set_fst_gb_red: \"fst ` set (fst (gb_red gs bs ps sps data)) = set (gb_red_aux (gs @ bs) sps)\"", "lemma rcp_spec_gb_red: \"rcp_spec gb_red\"", "lemmas compl_struct_gb_red = compl_struct_rcp[OF rcp_spec_gb_red]", "lemmas compl_pmdl_gb_red = compl_pmdl_rcp[OF rcp_spec_gb_red]", "lemmas compl_conn_gb_red = compl_conn_rcp[OF rcp_spec_gb_red]", "lemma sel_spec_gb_sel: \"sel_spec gb_sel\"", "lemma struct_spec_gb: \"struct_spec gb_sel add_pairs_canon add_basis_canon gb_red\"", "lemmas gb_aux_simps [code] = gb_schema_aux_simps[OF struct_spec_gb, folded gb_aux_def]", "lemmas gb_simps [code] = gb_schema_direct_def[of gb_sel add_pairs_canon add_basis_canon gb_red, folded gb_def gb_aux_def]", "lemmas gb_isGB = gb_schema_direct_isGB[OF struct_spec_gb compl_conn_gb_red, folded gb_def]", "lemmas gb_pmdl = gb_schema_direct_pmdl[OF struct_spec_gb compl_pmdl_gb_red, folded gb_def]", "lemma (in gd_term) struct_spec_gb_punit: \"punit.struct_spec punit.gb_sel add_pairs_punit_canon punit.add_basis_canon punit.gb_red\"", "lemmas gb_aux_punit_simps [code] = punit.gb_schema_aux_simps[OF struct_spec_gb_punit, folded gb_aux_punit_def]", "lemmas gb_punit_simps [code] = punit.gb_schema_direct_def[of \"punit.gb_sel\" add_pairs_punit_canon\n                                \"punit.add_basis_canon\" \"punit.gb_red\", folded gb_punit_def gb_aux_punit_def]", "lemmas gb_punit_isGB = punit.gb_schema_direct_isGB[OF struct_spec_gb_punit punit.compl_conn_gb_red, folded gb_punit_def]", "lemmas gb_punit_pmdl = punit.gb_schema_direct_pmdl[OF struct_spec_gb_punit punit.compl_pmdl_gb_red, folded gb_punit_def]"], "translations": [["", "lemma trdsp_alt: \"trdsp bs (p, q) = trd bs (spoly (fst p) (fst q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trdsp bs (p, q) = trd bs (spoly (fst p) (fst q))", "by (simp add: trdsp_def)"], ["", "lemma trdsp_in_pmdl: \"trdsp bs (p, q) \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trdsp bs (p, q) \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))", "unfolding trdsp_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. trd bs (spoly (fst p) (fst q))\n    \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))", "proof (rule pmdl_closed_trd)"], ["proof (state)\ngoal (2 subgoals):\n 1. spoly (fst p) (fst q)\n    \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\n 2. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "have \"spoly (fst p) (fst q) \\<in> pmdl {fst p, fst q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spoly (fst p) (fst q) \\<in> pmdl {fst p, fst q}", "proof (rule pmdl_closed_spoly)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst p \\<in> pmdl {fst p, fst q}\n 2. fst q \\<in> pmdl {fst p, fst q}", "show \"fst p \\<in> pmdl {fst p, fst q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst p \\<in> pmdl {fst p, fst q}", "by (rule pmdl.span_base, simp)"], ["proof (state)\nthis:\n  fst p \\<in> pmdl {fst p, fst q}\n\ngoal (1 subgoal):\n 1. fst q \\<in> pmdl {fst p, fst q}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst q \\<in> pmdl {fst p, fst q}", "show \"fst q \\<in> pmdl {fst p, fst q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst q \\<in> pmdl {fst p, fst q}", "by (rule pmdl.span_base, simp)"], ["proof (state)\nthis:\n  fst q \\<in> pmdl {fst p, fst q}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spoly (fst p) (fst q) \\<in> pmdl {fst p, fst q}\n\ngoal (2 subgoals):\n 1. spoly (fst p) (fst q)\n    \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\n 2. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "also"], ["proof (state)\nthis:\n  spoly (fst p) (fst q) \\<in> pmdl {fst p, fst q}\n\ngoal (2 subgoals):\n 1. spoly (fst p) (fst q)\n    \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\n 2. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "have \"... \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl {fst p, fst q}\n    \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "by (rule pmdl.span_mono, simp)"], ["proof (state)\nthis:\n  pmdl {fst p, fst q}\n  \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))\n\ngoal (2 subgoals):\n 1. spoly (fst p) (fst q)\n    \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\n 2. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "finally"], ["proof (chain)\npicking this:\n  spoly (fst p) (fst q)\n  \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))", "show \"spoly (fst p) (fst q) \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\nusing this:\n  spoly (fst p) (fst q)\n  \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\n\ngoal (1 subgoal):\n 1. spoly (fst p) (fst q)\n    \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))", "."], ["proof (state)\nthis:\n  spoly (fst p) (fst q)\n  \\<in> pmdl (insert (fst p) (insert (fst q) (set bs)))\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "have \"set bs \\<subseteq> insert (fst p) (insert (fst q) (set bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set bs \\<subseteq> insert (fst p) (insert (fst q) (set bs))", "by blast"], ["proof (state)\nthis:\n  set bs \\<subseteq> insert (fst p) (insert (fst q) (set bs))\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "also"], ["proof (state)\nthis:\n  set bs \\<subseteq> insert (fst p) (insert (fst q) (set bs))\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "have \"... \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (fst p) (insert (fst q) (set bs))\n    \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "by (fact pmdl.span_superset)"], ["proof (state)\nthis:\n  insert (fst p) (insert (fst q) (set bs))\n  \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "finally"], ["proof (chain)\npicking this:\n  set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "show \"set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\nusing this:\n  set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))", "."], ["proof (state)\nthis:\n  set bs \\<subseteq> pmdl (insert (fst p) (insert (fst q) (set bs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dgrad_p_set_le_trdsp:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d {trdsp bs (p, q)} (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "let ?h = \"trdsp bs (p, q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "have \"(red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) (trdsp bs (p, q))", "unfolding trdsp_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q))\n     (trd bs (spoly (fst p) (fst q)))", "by (rule trd_red_rtrancl)"], ["proof (state)\nthis:\n  (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) (trdsp bs (p, q))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "with assms"], ["proof (chain)\npicking this:\n  dickson_grading d\n  (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) (trdsp bs (p, q))", "have \"dgrad_p_set_le d {?h} (insert (spoly (fst p) (fst q)) (set bs))\""], ["proof (prove)\nusing this:\n  dickson_grading d\n  (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) (trdsp bs (p, q))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (spoly (fst p) (fst q)) (set bs))", "by (rule dgrad_p_set_le_red_rtrancl)"], ["proof (state)\nthis:\n  dgrad_p_set_le d {trdsp bs (p, q)}\n   (insert (spoly (fst p) (fst q)) (set bs))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "also"], ["proof (state)\nthis:\n  dgrad_p_set_le d {trdsp bs (p, q)}\n   (insert (spoly (fst p) (fst q)) (set bs))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "have \"dgrad_p_set_le d ... ({fst p, fst q} \\<union> set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (insert (spoly (fst p) (fst q)) (set bs))\n     ({fst p, fst q} \\<union> set bs)", "proof (rule dgrad_p_set_leI_insert)"], ["proof (state)\ngoal (2 subgoals):\n 1. dgrad_p_set_le d (set bs) ({fst p, fst q} \\<union> set bs)\n 2. dgrad_p_set_le d {spoly (fst p) (fst q)}\n     ({fst p, fst q} \\<union> set bs)", "show \"dgrad_p_set_le d (set bs) ({fst p, fst q} \\<union> set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set bs) ({fst p, fst q} \\<union> set bs)", "by (rule dgrad_p_set_le_subset, blast)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set bs) ({fst p, fst q} \\<union> set bs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {spoly (fst p) (fst q)}\n     ({fst p, fst q} \\<union> set bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {spoly (fst p) (fst q)}\n     ({fst p, fst q} \\<union> set bs)", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"dgrad_p_set_le d {spoly (fst p) (fst q)} {fst p, fst q}\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {spoly (fst p) (fst q)} {fst p, fst q}", "by (rule dgrad_p_set_le_spoly)"], ["proof (state)\nthis:\n  dgrad_p_set_le d {spoly (fst p) (fst q)} {fst p, fst q}\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {spoly (fst p) (fst q)}\n     ({fst p, fst q} \\<union> set bs)", "also"], ["proof (state)\nthis:\n  dgrad_p_set_le d {spoly (fst p) (fst q)} {fst p, fst q}\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {spoly (fst p) (fst q)}\n     ({fst p, fst q} \\<union> set bs)", "have \"dgrad_p_set_le d ... ({fst p, fst q} \\<union> set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {fst p, fst q} ({fst p, fst q} \\<union> set bs)", "by (rule dgrad_p_set_le_subset, blast)"], ["proof (state)\nthis:\n  dgrad_p_set_le d {fst p, fst q} ({fst p, fst q} \\<union> set bs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {spoly (fst p) (fst q)}\n     ({fst p, fst q} \\<union> set bs)", "finally"], ["proof (chain)\npicking this:\n  dgrad_p_set_le d {spoly (fst p) (fst q)} ({fst p, fst q} \\<union> set bs)", "show \"dgrad_p_set_le d {spoly (fst p) (fst q)} ({fst p, fst q} \\<union> set bs)\""], ["proof (prove)\nusing this:\n  dgrad_p_set_le d {spoly (fst p) (fst q)} ({fst p, fst q} \\<union> set bs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {spoly (fst p) (fst q)}\n     ({fst p, fst q} \\<union> set bs)", "."], ["proof (state)\nthis:\n  dgrad_p_set_le d {spoly (fst p) (fst q)} ({fst p, fst q} \\<union> set bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dgrad_p_set_le d (insert (spoly (fst p) (fst q)) (set bs))\n   ({fst p, fst q} \\<union> set bs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "finally"], ["proof (chain)\npicking this:\n  dgrad_p_set_le d {trdsp bs (p, q)} ({fst p, fst q} \\<union> set bs)", "show ?thesis"], ["proof (prove)\nusing this:\n  dgrad_p_set_le d {trdsp bs (p, q)} ({fst p, fst q} \\<union> set bs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp bs (p, q)}\n     (insert (fst p) (insert (fst q) (set bs)))", "by simp"], ["proof (state)\nthis:\n  dgrad_p_set_le d {trdsp bs (p, q)}\n   (insert (fst p) (insert (fst q) (set bs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma components_trdsp_subset:\n  \"component_of_term ` keys (trdsp bs (p, q)) \\<subseteq> component_of_term ` Keys (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "let ?h = \"trdsp bs (p, q)\""], ["proof (state)\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "have \"(red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) (trdsp bs (p, q))", "unfolding trdsp_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q))\n     (trd bs (spoly (fst p) (fst q)))", "by (rule trd_red_rtrancl)"], ["proof (state)\nthis:\n  (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) (trdsp bs (p, q))\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "hence \"component_of_term ` keys ?h \\<subseteq>\n              component_of_term ` keys (spoly (fst p) (fst q)) \\<union> component_of_term ` Keys (set bs)\""], ["proof (prove)\nusing this:\n  (red (set bs))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) (trdsp bs (p, q))\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term ` keys (spoly (fst p) (fst q)) \\<union>\n                component_of_term ` Keys (set bs)", "by (rule components_red_rtrancl_subset)"], ["proof (state)\nthis:\n  component_of_term ` keys (trdsp bs (p, q))\n  \\<subseteq> component_of_term ` keys (spoly (fst p) (fst q)) \\<union>\n              component_of_term ` Keys (set bs)\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "also"], ["proof (state)\nthis:\n  component_of_term ` keys (trdsp bs (p, q))\n  \\<subseteq> component_of_term ` keys (spoly (fst p) (fst q)) \\<union>\n              component_of_term ` Keys (set bs)\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "have \"... \\<subseteq> component_of_term ` Keys {fst p, fst q} \\<union> component_of_term ` Keys (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys (spoly (fst p) (fst q)) \\<union>\n    component_of_term ` Keys (set bs)\n    \\<subseteq> component_of_term ` Keys {fst p, fst q} \\<union>\n                component_of_term ` Keys (set bs)", "using components_spoly_subset"], ["proof (prove)\nusing this:\n  component_of_term ` keys (spoly ?p ?q)\n  \\<subseteq> component_of_term ` Keys {?p, ?q}\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (spoly (fst p) (fst q)) \\<union>\n    component_of_term ` Keys (set bs)\n    \\<subseteq> component_of_term ` Keys {fst p, fst q} \\<union>\n                component_of_term ` Keys (set bs)", "by force"], ["proof (state)\nthis:\n  component_of_term ` keys (spoly (fst p) (fst q)) \\<union>\n  component_of_term ` Keys (set bs)\n  \\<subseteq> component_of_term ` Keys {fst p, fst q} \\<union>\n              component_of_term ` Keys (set bs)\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "also"], ["proof (state)\nthis:\n  component_of_term ` keys (spoly (fst p) (fst q)) \\<union>\n  component_of_term ` Keys (set bs)\n  \\<subseteq> component_of_term ` Keys {fst p, fst q} \\<union>\n              component_of_term ` Keys (set bs)\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "have \"... = component_of_term ` Keys (insert (fst p) (insert (fst q) (set bs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys {fst p, fst q} \\<union>\n    component_of_term ` Keys (set bs) =\n    component_of_term ` Keys (insert (fst p) (insert (fst q) (set bs)))", "by (simp add: Keys_insert image_Un Un_assoc)"], ["proof (state)\nthis:\n  component_of_term ` Keys {fst p, fst q} \\<union>\n  component_of_term ` Keys (set bs) =\n  component_of_term ` Keys (insert (fst p) (insert (fst q) (set bs)))\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "finally"], ["proof (chain)\npicking this:\n  component_of_term ` keys (trdsp bs (p, q))\n  \\<subseteq> component_of_term `\n              Keys (insert (fst p) (insert (fst q) (set bs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  component_of_term ` keys (trdsp bs (p, q))\n  \\<subseteq> component_of_term `\n              Keys (insert (fst p) (insert (fst q) (set bs)))\n\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp bs (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set bs)))", "."], ["proof (state)\nthis:\n  component_of_term ` keys (trdsp bs (p, q))\n  \\<subseteq> component_of_term `\n              Keys (insert (fst p) (insert (fst q) (set bs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gb_red_aux :: \"('t, 'b::field, 'c) pdata list \\<Rightarrow> ('t, 'b, 'c) pdata_pair list \\<Rightarrow>\n                          ('t \\<Rightarrow>\\<^sub>0 'b) list\"\n  where \"gb_red_aux bs ps =\n              (let bs' = map fst bs in\n                filter (\\<lambda>h. h \\<noteq> 0) (map (trdsp bs') ps)\n              )\""], ["", "text \\<open>Actually, @{const gb_red_aux} is only called on singleton lists.\\<close>"], ["", "lemma set_gb_red_aux: \"set (gb_red_aux bs ps) = (trdsp (map fst bs)) ` set ps - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (gb_red_aux bs ps) = trdsp (map fst bs) ` set ps - {0}", "by (simp add: gb_red_aux_def, blast)"], ["", "lemma in_set_gb_red_auxI:\n  assumes \"(p, q) \\<in> set ps\" and \"h = trdsp (map fst bs) (p, q)\" and \"h \\<noteq> 0\"\n  shows \"h \\<in> set (gb_red_aux bs ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> set (gb_red_aux bs ps)", "using assms(1, 3)"], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<in> set (gb_red_aux bs ps)", "unfolding set_gb_red_aux assms(2)"], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n  trdsp (map fst bs) (p, q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. trdsp (map fst bs) (p, q) \\<in> trdsp (map fst bs) ` set ps - {0}", "by force"], ["", "lemma in_set_gb_red_auxE:\n  assumes \"h \\<in> set (gb_red_aux bs ps)\"\n  obtains p q where \"(p, q) \\<in> set ps\" and \"h = trdsp (map fst bs) (p, q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>(p, q) \\<in> set ps; h = trdsp (map fst bs) (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>(p, q) \\<in> set ps; h = trdsp (map fst bs) (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_gb_red_aux"], ["proof (prove)\nusing this:\n  h \\<in> trdsp (map fst bs) ` set ps - {0}\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>(p, q) \\<in> set ps; h = trdsp (map fst bs) (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["", "lemma gb_red_aux_not_zero: \"0 \\<notin> set (gb_red_aux bs ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> set (gb_red_aux bs ps)", "by (simp add: set_gb_red_aux)"], ["", "lemma gb_red_aux_irredudible:\n  assumes \"h \\<in> set (gb_red_aux bs ps)\" and \"b \\<in> set bs\" and \"fst b \\<noteq> 0\"\n  shows \"\\<not> lt (fst b) adds\\<^sub>t lt h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt (fst b) adds\\<^sub>t lt h", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt (fst b) adds\\<^sub>t lt h \\<Longrightarrow> False", "assume \"lt (fst b) adds\\<^sub>t (lt h)\""], ["proof (state)\nthis:\n  lt (fst b) adds\\<^sub>t lt h\n\ngoal (1 subgoal):\n 1. lt (fst b) adds\\<^sub>t lt h \\<Longrightarrow> False", "from assms(1)"], ["proof (chain)\npicking this:\n  h \\<in> set (gb_red_aux bs ps)", "obtain p q :: \"('t, 'b, 'c) pdata\" where h: \"h = trdsp (map fst bs) (p, q)\""], ["proof (prove)\nusing this:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        h = trdsp (map fst bs) (p, q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule in_set_gb_red_auxE)"], ["proof (state)\nthis:\n  h = trdsp (map fst bs) (p, q)\n\ngoal (1 subgoal):\n 1. lt (fst b) adds\\<^sub>t lt h \\<Longrightarrow> False", "have \"\\<not> is_red (set (map fst bs)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (map fst bs)) h", "unfolding h trdsp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (map fst bs))\n            (trd (map fst bs) (spoly (fst (fst (p, q))) (fst (snd (p, q)))))", "by (rule trd_irred)"], ["proof (state)\nthis:\n  \\<not> is_red (set (map fst bs)) h\n\ngoal (1 subgoal):\n 1. lt (fst b) adds\\<^sub>t lt h \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> is_red (set (map fst bs)) h\n\ngoal (1 subgoal):\n 1. lt (fst b) adds\\<^sub>t lt h \\<Longrightarrow> False", "have \"is_red (set (map fst bs)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red (set (map fst bs)) h", "proof (rule is_red_addsI)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?f \\<in> set (map fst bs)\n 2. ?f \\<noteq> 0\n 3. ?v \\<in> keys h\n 4. lt ?f adds\\<^sub>t ?v", "from assms(2)"], ["proof (chain)\npicking this:\n  b \\<in> set bs", "show \"fst b \\<in> set (map fst bs)\""], ["proof (prove)\nusing this:\n  b \\<in> set bs\n\ngoal (1 subgoal):\n 1. fst b \\<in> set (map fst bs)", "by (simp)"], ["proof (state)\nthis:\n  fst b \\<in> set (map fst bs)\n\ngoal (3 subgoals):\n 1. fst b \\<noteq> 0\n 2. ?v \\<in> keys h\n 3. lt (fst b) adds\\<^sub>t ?v", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. fst b \\<noteq> 0\n 2. ?v \\<in> keys h\n 3. lt (fst b) adds\\<^sub>t ?v", "from assms(1)"], ["proof (chain)\npicking this:\n  h \\<in> set (gb_red_aux bs ps)", "have \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0", "by (simp add: set_gb_red_aux)"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (3 subgoals):\n 1. fst b \\<noteq> 0\n 2. ?v \\<in> keys h\n 3. lt (fst b) adds\\<^sub>t ?v", "thus \"lt h \\<in> keys h\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt h \\<in> keys h", "by (rule lt_in_keys)"], ["proof (state)\nthis:\n  lt h \\<in> keys h\n\ngoal (2 subgoals):\n 1. fst b \\<noteq> 0\n 2. lt (fst b) adds\\<^sub>t lt h", "qed fact+"], ["proof (state)\nthis:\n  is_red (set (map fst bs)) h\n\ngoal (1 subgoal):\n 1. lt (fst b) adds\\<^sub>t lt h \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_red (set (map fst bs)) h\n  is_red (set (map fst bs)) h", "show False"], ["proof (prove)\nusing this:\n  \\<not> is_red (set (map fst bs)) h\n  is_red (set (map fst bs)) h\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gb_red_aux_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (gb_red_aux bs ps)) (args_to_set ([], bs, ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (gb_red_aux bs ps)) (args_to_set ([], bs, ps))", "proof (rule dgrad_p_set_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       dgrad_p_set_le d {f} (args_to_set ([], bs, ps))", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       dgrad_p_set_le d {f} (args_to_set ([], bs, ps))", "assume \"h \\<in> set (gb_red_aux bs ps)\""], ["proof (state)\nthis:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       dgrad_p_set_le d {f} (args_to_set ([], bs, ps))", "then"], ["proof (chain)\npicking this:\n  h \\<in> set (gb_red_aux bs ps)", "obtain p q where \"(p, q) \\<in> set ps\" and h: \"h = trdsp (map fst bs) (p, q)\""], ["proof (prove)\nusing this:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>(p, q) \\<in> set ps; h = trdsp (map fst bs) (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_set_gb_red_auxE)"], ["proof (state)\nthis:\n  (p, q) \\<in> set ps\n  h = trdsp (map fst bs) (p, q)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       dgrad_p_set_le d {f} (args_to_set ([], bs, ps))", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"dgrad_p_set_le d {h} (insert (fst p) (insert (fst q) (set (map fst bs))))\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {h}\n     (insert (fst p) (insert (fst q) (set (map fst bs))))", "unfolding h"], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trdsp (map fst bs) (p, q)}\n     (insert (fst p) (insert (fst q) (set (map fst bs))))", "by (rule dgrad_p_set_le_trdsp)"], ["proof (state)\nthis:\n  dgrad_p_set_le d {h} (insert (fst p) (insert (fst q) (set (map fst bs))))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       dgrad_p_set_le d {f} (args_to_set ([], bs, ps))", "also"], ["proof (state)\nthis:\n  dgrad_p_set_le d {h} (insert (fst p) (insert (fst q) (set (map fst bs))))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       dgrad_p_set_le d {f} (args_to_set ([], bs, ps))", "have \"dgrad_p_set_le d ... (args_to_set ([], bs, ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (insert (fst p) (insert (fst q) (set (map fst bs))))\n     (args_to_set ([], bs, ps))", "proof (rule dgrad_p_set_le_subset, intro insert_subsetI)"], ["proof (state)\ngoal (3 subgoals):\n 1. fst p \\<in> args_to_set ([], bs, ps)\n 2. fst q \\<in> args_to_set ([], bs, ps)\n 3. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "from \\<open>(p, q) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (p, q) \\<in> set ps", "have \"fst p \\<in> fst ` fst ` set ps\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n\ngoal (1 subgoal):\n 1. fst p \\<in> fst ` fst ` set ps", "by force"], ["proof (state)\nthis:\n  fst p \\<in> fst ` fst ` set ps\n\ngoal (3 subgoals):\n 1. fst p \\<in> args_to_set ([], bs, ps)\n 2. fst q \\<in> args_to_set ([], bs, ps)\n 3. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "thus \"fst p \\<in> args_to_set ([], bs, ps)\""], ["proof (prove)\nusing this:\n  fst p \\<in> fst ` fst ` set ps\n\ngoal (1 subgoal):\n 1. fst p \\<in> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  fst p \\<in> args_to_set ([], bs, ps)\n\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "from \\<open>(p, q) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (p, q) \\<in> set ps", "have \"fst q \\<in> fst ` snd ` set ps\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n\ngoal (1 subgoal):\n 1. fst q \\<in> fst ` snd ` set ps", "by force"], ["proof (state)\nthis:\n  fst q \\<in> fst ` snd ` set ps\n\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "thus \"fst q \\<in> args_to_set ([], bs, ps)\""], ["proof (prove)\nusing this:\n  fst q \\<in> fst ` snd ` set ps\n\ngoal (1 subgoal):\n 1. fst q \\<in> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  fst q \\<in> args_to_set ([], bs, ps)\n\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "show \"set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dgrad_p_set_le d (insert (fst p) (insert (fst q) (set (map fst bs))))\n   (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       dgrad_p_set_le d {f} (args_to_set ([], bs, ps))", "finally"], ["proof (chain)\npicking this:\n  dgrad_p_set_le d {h} (args_to_set ([], bs, ps))", "show \"dgrad_p_set_le d {h} (args_to_set ([], bs, ps))\""], ["proof (prove)\nusing this:\n  dgrad_p_set_le d {h} (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {h} (args_to_set ([], bs, ps))", "."], ["proof (state)\nthis:\n  dgrad_p_set_le d {h} (args_to_set ([], bs, ps))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma components_gb_red_aux_subset:\n  \"component_of_term ` Keys (set (gb_red_aux bs ps)) \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (set (gb_red_aux bs ps))\n    \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "assume \"k \\<in> component_of_term ` Keys (set (gb_red_aux bs ps))\""], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys (set (gb_red_aux bs ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "then"], ["proof (chain)\npicking this:\n  k \\<in> component_of_term ` Keys (set (gb_red_aux bs ps))", "obtain v where \"v \\<in> Keys (set (gb_red_aux bs ps))\" and k: \"k = component_of_term v\""], ["proof (prove)\nusing this:\n  k \\<in> component_of_term ` Keys (set (gb_red_aux bs ps))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> Keys (set (gb_red_aux bs ps));\n         k = component_of_term v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> Keys (set (gb_red_aux bs ps))\n  k = component_of_term v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "from this(1)"], ["proof (chain)\npicking this:\n  v \\<in> Keys (set (gb_red_aux bs ps))", "obtain h where \"h \\<in> set (gb_red_aux bs ps)\" and \"v \\<in> keys h\""], ["proof (prove)\nusing this:\n  v \\<in> Keys (set (gb_red_aux bs ps))\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> set (gb_red_aux bs ps); v \\<in> keys h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_KeysE)"], ["proof (state)\nthis:\n  h \\<in> set (gb_red_aux bs ps)\n  v \\<in> keys h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> set (gb_red_aux bs ps)", "obtain p q where \"(p, q) \\<in> set ps\" and h: \"h = trdsp (map fst bs) (p, q)\""], ["proof (prove)\nusing this:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>(p, q) \\<in> set ps; h = trdsp (map fst bs) (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_set_gb_red_auxE)"], ["proof (state)\nthis:\n  (p, q) \\<in> set ps\n  h = trdsp (map fst bs) (p, q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "from \\<open>v \\<in> keys h\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> keys h", "have \"k \\<in> component_of_term ` keys h\""], ["proof (prove)\nusing this:\n  v \\<in> keys h\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` keys h", "by (simp add: k)"], ["proof (state)\nthis:\n  k \\<in> component_of_term ` keys h\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "have \"component_of_term ` keys h \\<subseteq> component_of_term ` Keys (insert (fst p) (insert (fst q) (set (map fst bs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys h\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set (map fst bs))))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` keys (trdsp (map fst bs) (p, q))\n    \\<subseteq> component_of_term `\n                Keys (insert (fst p) (insert (fst q) (set (map fst bs))))", "by (rule components_trdsp_subset)"], ["proof (state)\nthis:\n  component_of_term ` keys h\n  \\<subseteq> component_of_term `\n              Keys (insert (fst p) (insert (fst q) (set (map fst bs))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "also"], ["proof (state)\nthis:\n  component_of_term ` keys h\n  \\<subseteq> component_of_term `\n              Keys (insert (fst p) (insert (fst q) (set (map fst bs))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "have \"... \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term `\n    Keys (insert (fst p) (insert (fst q) (set (map fst bs))))\n    \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))", "proof (rule image_mono, rule Keys_mono, intro insert_subsetI)"], ["proof (state)\ngoal (3 subgoals):\n 1. fst p \\<in> args_to_set ([], bs, ps)\n 2. fst q \\<in> args_to_set ([], bs, ps)\n 3. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "from \\<open>(p, q) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (p, q) \\<in> set ps", "have \"fst p \\<in> fst ` fst ` set ps\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n\ngoal (1 subgoal):\n 1. fst p \\<in> fst ` fst ` set ps", "by force"], ["proof (state)\nthis:\n  fst p \\<in> fst ` fst ` set ps\n\ngoal (3 subgoals):\n 1. fst p \\<in> args_to_set ([], bs, ps)\n 2. fst q \\<in> args_to_set ([], bs, ps)\n 3. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "thus \"fst p \\<in> args_to_set ([], bs, ps)\""], ["proof (prove)\nusing this:\n  fst p \\<in> fst ` fst ` set ps\n\ngoal (1 subgoal):\n 1. fst p \\<in> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  fst p \\<in> args_to_set ([], bs, ps)\n\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "from \\<open>(p, q) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (p, q) \\<in> set ps", "have \"fst q \\<in> fst ` snd ` set ps\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n\ngoal (1 subgoal):\n 1. fst q \\<in> fst ` snd ` set ps", "by force"], ["proof (state)\nthis:\n  fst q \\<in> fst ` snd ` set ps\n\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "thus \"fst q \\<in> args_to_set ([], bs, ps)\""], ["proof (prove)\nusing this:\n  fst q \\<in> fst ` snd ` set ps\n\ngoal (1 subgoal):\n 1. fst q \\<in> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  fst q \\<in> args_to_set ([], bs, ps)\n\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "show \"set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  component_of_term `\n  Keys (insert (fst p) (insert (fst q) (set (map fst bs))))\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "finally"], ["proof (chain)\npicking this:\n  component_of_term ` keys h\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))", "have \"component_of_term ` keys h \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\""], ["proof (prove)\nusing this:\n  component_of_term ` keys h\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. component_of_term ` keys h\n    \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))", "."], ["proof (state)\nthis:\n  component_of_term ` keys h\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> component_of_term `\n               Keys (set (gb_red_aux bs ps)) \\<Longrightarrow>\n       x \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", "with \\<open>k \\<in> component_of_term ` keys h\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> component_of_term ` keys h\n  component_of_term ` keys h\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))", "show \"k \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))\""], ["proof (prove)\nusing this:\n  k \\<in> component_of_term ` keys h\n  component_of_term ` keys h\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. k \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))", ".."], ["proof (state)\nthis:\n  k \\<in> component_of_term ` Keys (args_to_set ([], bs, ps))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmdl_gb_red_aux: \"set (gb_red_aux bs ps) \\<subseteq> pmdl (args_to_set ([], bs, ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (gb_red_aux bs ps) \\<subseteq> pmdl (args_to_set ([], bs, ps))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       x \\<in> pmdl (args_to_set ([], bs, ps))", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       x \\<in> pmdl (args_to_set ([], bs, ps))", "assume \"h \\<in> set (gb_red_aux bs ps)\""], ["proof (state)\nthis:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       x \\<in> pmdl (args_to_set ([], bs, ps))", "then"], ["proof (chain)\npicking this:\n  h \\<in> set (gb_red_aux bs ps)", "obtain p q where \"(p, q) \\<in> set ps\" and h: \"h = trdsp (map fst bs) (p, q)\""], ["proof (prove)\nusing this:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>(p, q) \\<in> set ps; h = trdsp (map fst bs) (p, q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule in_set_gb_red_auxE)"], ["proof (state)\nthis:\n  (p, q) \\<in> set ps\n  h = trdsp (map fst bs) (p, q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       x \\<in> pmdl (args_to_set ([], bs, ps))", "have \"h \\<in> pmdl (insert (fst p) (insert (fst q) (set (map fst bs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<in> pmdl (insert (fst p) (insert (fst q) (set (map fst bs))))", "unfolding h"], ["proof (prove)\ngoal (1 subgoal):\n 1. trdsp (map fst bs) (p, q)\n    \\<in> pmdl (insert (fst p) (insert (fst q) (set (map fst bs))))", "by (fact trdsp_in_pmdl)"], ["proof (state)\nthis:\n  h \\<in> pmdl (insert (fst p) (insert (fst q) (set (map fst bs))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       x \\<in> pmdl (args_to_set ([], bs, ps))", "also"], ["proof (state)\nthis:\n  h \\<in> pmdl (insert (fst p) (insert (fst q) (set (map fst bs))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       x \\<in> pmdl (args_to_set ([], bs, ps))", "have \"... \\<subseteq> pmdl (args_to_set ([], bs, ps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (insert (fst p) (insert (fst q) (set (map fst bs))))\n    \\<subseteq> pmdl (args_to_set ([], bs, ps))", "proof (rule pmdl.span_mono, intro insert_subsetI)"], ["proof (state)\ngoal (3 subgoals):\n 1. fst p \\<in> args_to_set ([], bs, ps)\n 2. fst q \\<in> args_to_set ([], bs, ps)\n 3. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "from \\<open>(p, q) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (p, q) \\<in> set ps", "have \"fst p \\<in> fst ` fst ` set ps\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n\ngoal (1 subgoal):\n 1. fst p \\<in> fst ` fst ` set ps", "by force"], ["proof (state)\nthis:\n  fst p \\<in> fst ` fst ` set ps\n\ngoal (3 subgoals):\n 1. fst p \\<in> args_to_set ([], bs, ps)\n 2. fst q \\<in> args_to_set ([], bs, ps)\n 3. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "thus \"fst p \\<in> args_to_set ([], bs, ps)\""], ["proof (prove)\nusing this:\n  fst p \\<in> fst ` fst ` set ps\n\ngoal (1 subgoal):\n 1. fst p \\<in> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  fst p \\<in> args_to_set ([], bs, ps)\n\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "from \\<open>(p, q) \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  (p, q) \\<in> set ps", "have \"fst q \\<in> fst ` snd ` set ps\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n\ngoal (1 subgoal):\n 1. fst q \\<in> fst ` snd ` set ps", "by force"], ["proof (state)\nthis:\n  fst q \\<in> fst ` snd ` set ps\n\ngoal (2 subgoals):\n 1. fst q \\<in> args_to_set ([], bs, ps)\n 2. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "thus \"fst q \\<in> args_to_set ([], bs, ps)\""], ["proof (prove)\nusing this:\n  fst q \\<in> fst ` snd ` set ps\n\ngoal (1 subgoal):\n 1. fst q \\<in> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  fst q \\<in> args_to_set ([], bs, ps)\n\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "show \"set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)", "by (auto simp add: args_to_set_alt)"], ["proof (state)\nthis:\n  set (map fst bs) \\<subseteq> args_to_set ([], bs, ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl (insert (fst p) (insert (fst q) (set (map fst bs))))\n  \\<subseteq> pmdl (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (gb_red_aux bs ps) \\<Longrightarrow>\n       x \\<in> pmdl (args_to_set ([], bs, ps))", "finally"], ["proof (chain)\npicking this:\n  h \\<in> pmdl (args_to_set ([], bs, ps))", "show \"h \\<in> pmdl (args_to_set ([], bs, ps))\""], ["proof (prove)\nusing this:\n  h \\<in> pmdl (args_to_set ([], bs, ps))\n\ngoal (1 subgoal):\n 1. h \\<in> pmdl (args_to_set ([], bs, ps))", "."], ["proof (state)\nthis:\n  h \\<in> pmdl (args_to_set ([], bs, ps))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gb_red_aux_spoly_reducible:\n  assumes \"(p, q) \\<in> set ps\"\n  shows \"(red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "define h where \"h = trdsp (map fst bs) (p, q)\""], ["proof (state)\nthis:\n  h = trdsp (map fst bs) (p, q)\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "from trd_red_rtrancl[of \"map fst bs\" \"spoly (fst p) (fst q)\"]"], ["proof (chain)\npicking this:\n  (red (set (map fst bs)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q))\n   (trd (map fst bs) (spoly (fst p) (fst q)))", "have \"(red (set (map fst bs)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) h\""], ["proof (prove)\nusing this:\n  (red (set (map fst bs)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q))\n   (trd (map fst bs) (spoly (fst p) (fst q)))\n\ngoal (1 subgoal):\n 1. (red (set (map fst bs)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) h", "by (simp only: h_def trdsp_alt)"], ["proof (state)\nthis:\n  (red (set (map fst bs)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) h\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "hence \"(red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) h\""], ["proof (prove)\nusing this:\n  (red (set (map fst bs)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) h\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) h", "proof (rule red_rtrancl_subset)"], ["proof (state)\ngoal (1 subgoal):\n 1. set (map fst bs)\n    \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)", "show \"set (map fst bs) \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst bs)\n    \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)", "by simp"], ["proof (state)\nthis:\n  set (map fst bs) \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n   (spoly (fst p) (fst q)) h\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "moreover"], ["proof (state)\nthis:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n   (spoly (fst p) (fst q)) h\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "have \"(red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "proof (cases \"h = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0\n 2. h \\<noteq> 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "case True"], ["proof (state)\nthis:\n  h = 0\n\ngoal (2 subgoals):\n 1. h = 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0\n 2. h \\<noteq> 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* 0 0", ".."], ["proof (state)\nthis:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "case False"], ["proof (state)\nthis:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "hence \"red {h} h 0\""], ["proof (prove)\nusing this:\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. red {h} h 0", "by (rule red_self)"], ["proof (state)\nthis:\n  red {h} h 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "hence \"red (fst ` set bs \\<union> set (gb_red_aux bs ps)) h 0\""], ["proof (prove)\nusing this:\n  red {h} h 0\n\ngoal (1 subgoal):\n 1. red (fst ` set bs \\<union> set (gb_red_aux bs ps)) h 0", "proof (rule red_subset)"], ["proof (state)\ngoal (1 subgoal):\n 1. {h} \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)", "from assms h_def False"], ["proof (chain)\npicking this:\n  (p, q) \\<in> set ps\n  h = trdsp (map fst bs) (p, q)\n  h \\<noteq> 0", "have \"h \\<in> set (gb_red_aux bs ps)\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set ps\n  h = trdsp (map fst bs) (p, q)\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. h \\<in> set (gb_red_aux bs ps)", "by (rule in_set_gb_red_auxI)"], ["proof (state)\nthis:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. {h} \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)", "thus \"{h} \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)\""], ["proof (prove)\nusing this:\n  h \\<in> set (gb_red_aux bs ps)\n\ngoal (1 subgoal):\n 1. {h} \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)", "by simp"], ["proof (state)\nthis:\n  {h} \\<subseteq> fst ` set bs \\<union> set (gb_red_aux bs ps)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  red (fst ` set bs \\<union> set (gb_red_aux bs ps)) h 0\n\ngoal (1 subgoal):\n 1. h \\<noteq> 0 \\<Longrightarrow>\n    (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  red (fst ` set bs \\<union> set (gb_red_aux bs ps)) h 0\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", ".."], ["proof (state)\nthis:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "ultimately"], ["proof (chain)\npicking this:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n   (spoly (fst p) (fst q)) h\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n   (spoly (fst p) (fst q)) h\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>* h 0\n\ngoal (1 subgoal):\n 1. (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "by simp"], ["proof (state)\nthis:\n  (red (fst ` set bs \\<union> set (gb_red_aux bs ps)))\\<^sup>*\\<^sup>*\n   (spoly (fst p) (fst q)) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gb_red :: \"('t, 'b::field, 'c::default, 'd) complT\"\n  where \"gb_red gs bs ps sps data = (map (\\<lambda>h. (h, default)) (gb_red_aux (gs @ bs) sps), snd data)\""], ["", "lemma fst_set_fst_gb_red: \"fst ` set (fst (gb_red gs bs ps sps data)) = set (gb_red_aux (gs @ bs) sps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (fst (gb_red gs bs ps sps data)) =\n    set (gb_red_aux (gs @ bs) sps)", "by (simp add: gb_red_def, force)"], ["", "lemma rcp_spec_gb_red: \"rcp_spec gb_red\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcp_spec gb_red", "proof (rule rcp_specI)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>gs bs ps sps data.\n       0 \\<notin> fst ` set (fst (gb_red gs bs ps sps data))\n 2. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 3. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 5. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "fix gs bs::\"('t, 'b, 'c) pdata list\" and ps sps and data::\"nat \\<times> 'd\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>gs bs ps sps data.\n       0 \\<notin> fst ` set (fst (gb_red gs bs ps sps data))\n 2. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 3. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 5. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "from gb_red_aux_not_zero"], ["proof (chain)\npicking this:\n  0 \\<notin> set (gb_red_aux ?bs ?ps)", "show \"0 \\<notin> fst ` set (fst (gb_red gs bs ps sps data))\""], ["proof (prove)\nusing this:\n  0 \\<notin> set (gb_red_aux ?bs ?ps)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> fst ` set (fst (gb_red gs bs ps sps data))", "unfolding fst_set_fst_gb_red"], ["proof (prove)\nusing this:\n  0 \\<notin> set (gb_red_aux ?bs ?ps)\n\ngoal (1 subgoal):\n 1. 0 \\<notin> set (gb_red_aux (gs @ bs) sps)", "."], ["proof (state)\nthis:\n  0 \\<notin> fst ` set (fst (gb_red gs bs ps sps data))\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "fix gs bs::\"('t, 'b, 'c) pdata list\" and ps sps h b and data::\"nat \\<times> 'd\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "assume \"h \\<in> set (fst (gb_red gs bs ps sps data))\" and \"b \\<in> set gs \\<union> set bs\""], ["proof (state)\nthis:\n  h \\<in> set (fst (gb_red gs bs ps sps data))\n  b \\<in> set gs \\<union> set bs\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "from this(1)"], ["proof (chain)\npicking this:\n  h \\<in> set (fst (gb_red gs bs ps sps data))", "have \"fst h \\<in> fst ` set (fst (gb_red gs bs ps sps data))\""], ["proof (prove)\nusing this:\n  h \\<in> set (fst (gb_red gs bs ps sps data))\n\ngoal (1 subgoal):\n 1. fst h \\<in> fst ` set (fst (gb_red gs bs ps sps data))", "by simp"], ["proof (state)\nthis:\n  fst h \\<in> fst ` set (fst (gb_red gs bs ps sps data))\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "hence \"fst h \\<in> set (gb_red_aux (gs @ bs) sps)\""], ["proof (prove)\nusing this:\n  fst h \\<in> fst ` set (fst (gb_red gs bs ps sps data))\n\ngoal (1 subgoal):\n 1. fst h \\<in> set (gb_red_aux (gs @ bs) sps)", "by (simp only: fst_set_fst_gb_red)"], ["proof (state)\nthis:\n  fst h \\<in> set (gb_red_aux (gs @ bs) sps)\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "moreover"], ["proof (state)\nthis:\n  fst h \\<in> set (gb_red_aux (gs @ bs) sps)\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "from \\<open>b \\<in> set gs \\<union> set bs\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> set gs \\<union> set bs", "have \"b \\<in> set (gs @ bs)\""], ["proof (prove)\nusing this:\n  b \\<in> set gs \\<union> set bs\n\ngoal (1 subgoal):\n 1. b \\<in> set (gs @ bs)", "by simp"], ["proof (state)\nthis:\n  b \\<in> set (gs @ bs)\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "moreover"], ["proof (state)\nthis:\n  b \\<in> set (gs @ bs)\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "assume \"fst b \\<noteq> 0\""], ["proof (state)\nthis:\n  fst b \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<And>gs bs ps sps h b data.\n       \\<lbrakk>h \\<in> set (fst (gb_red gs bs ps sps data));\n        b \\<in> set gs \\<union> set bs; fst b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n 2. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 4. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "ultimately"], ["proof (chain)\npicking this:\n  fst h \\<in> set (gb_red_aux (gs @ bs) sps)\n  b \\<in> set (gs @ bs)\n  fst b \\<noteq> 0", "show \"\\<not> lt (fst b) adds\\<^sub>t lt (fst h)\""], ["proof (prove)\nusing this:\n  fst h \\<in> set (gb_red_aux (gs @ bs) sps)\n  b \\<in> set (gs @ bs)\n  fst b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> lt (fst b) adds\\<^sub>t lt (fst h)", "by (rule gb_red_aux_irredudible)"], ["proof (state)\nthis:\n  \\<not> lt (fst b) adds\\<^sub>t lt (fst h)\n\ngoal (3 subgoals):\n 1. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "fix gs bs::\"('t, 'b, 'c) pdata list\" and ps sps and d::\"'a \\<Rightarrow> nat\" and data::\"nat \\<times> 'd\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "assume \"dickson_grading d\""], ["proof (state)\nthis:\n  dickson_grading d\n\ngoal (3 subgoals):\n 1. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "hence \"dgrad_p_set_le d (set (gb_red_aux (gs @ bs) sps)) (args_to_set ([], gs @ bs, sps))\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (gb_red_aux (gs @ bs) sps))\n     (args_to_set ([], gs @ bs, sps))", "by (rule gb_red_aux_dgrad_p_set_le)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (gb_red_aux (gs @ bs) sps))\n   (args_to_set ([], gs @ bs, sps))\n\ngoal (3 subgoals):\n 1. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "also"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (gb_red_aux (gs @ bs) sps))\n   (args_to_set ([], gs @ bs, sps))\n\ngoal (3 subgoals):\n 1. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "have \"... = args_to_set (gs, bs, sps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args_to_set ([], gs @ bs, sps) = args_to_set (gs, bs, sps)", "by (simp add: args_to_set_alt image_Un)"], ["proof (state)\nthis:\n  args_to_set ([], gs @ bs, sps) = args_to_set (gs, bs, sps)\n\ngoal (3 subgoals):\n 1. \\<And>gs bs ps sps d data.\n       dickson_grading d \\<Longrightarrow>\n       dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n        (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 3. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "finally"], ["proof (chain)\npicking this:\n  dgrad_p_set_le d (set (gb_red_aux (gs @ bs) sps))\n   (args_to_set (gs, bs, sps))", "show \"dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data))) (args_to_set (gs, bs, sps))\""], ["proof (prove)\nusing this:\n  dgrad_p_set_le d (set (gb_red_aux (gs @ bs) sps))\n   (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n     (args_to_set (gs, bs, sps))", "by (simp only: fst_set_fst_gb_red)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (fst ` set (fst (gb_red gs bs ps sps data)))\n   (args_to_set (gs, bs, sps))\n\ngoal (2 subgoals):\n 1. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "fix gs bs::\"('t, 'b, 'c) pdata list\" and ps sps and data::\"nat \\<times> 'd\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "have \"component_of_term ` Keys (set (gb_red_aux (gs @ bs) sps)) \\<subseteq>\n          component_of_term ` Keys (args_to_set ([], gs @ bs, sps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (set (gb_red_aux (gs @ bs) sps))\n    \\<subseteq> component_of_term ` Keys (args_to_set ([], gs @ bs, sps))", "by (rule components_gb_red_aux_subset)"], ["proof (state)\nthis:\n  component_of_term ` Keys (set (gb_red_aux (gs @ bs) sps))\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], gs @ bs, sps))\n\ngoal (2 subgoals):\n 1. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "also"], ["proof (state)\nthis:\n  component_of_term ` Keys (set (gb_red_aux (gs @ bs) sps))\n  \\<subseteq> component_of_term ` Keys (args_to_set ([], gs @ bs, sps))\n\ngoal (2 subgoals):\n 1. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "have \"... = component_of_term ` Keys (args_to_set (gs, bs, sps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. component_of_term ` Keys (args_to_set ([], gs @ bs, sps)) =\n    component_of_term ` Keys (args_to_set (gs, bs, sps))", "by (simp add: args_to_set_alt image_Un)"], ["proof (state)\nthis:\n  component_of_term ` Keys (args_to_set ([], gs @ bs, sps)) =\n  component_of_term ` Keys (args_to_set (gs, bs, sps))\n\ngoal (2 subgoals):\n 1. \\<And>gs bs ps sps data.\n       component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n       \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n 2. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "finally"], ["proof (chain)\npicking this:\n  component_of_term ` Keys (set (gb_red_aux (gs @ bs) sps))\n  \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))", "show \"component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data))) \\<subseteq>\n                component_of_term ` Keys (args_to_set (gs, bs, sps))\""], ["proof (prove)\nusing this:\n  component_of_term ` Keys (set (gb_red_aux (gs @ bs) sps))\n  \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n    \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))", "by (simp only: fst_set_fst_gb_red)"], ["proof (state)\nthis:\n  component_of_term ` Keys (fst ` set (fst (gb_red gs bs ps sps data)))\n  \\<subseteq> component_of_term ` Keys (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "fix gs bs::\"('t, 'b, 'c) pdata list\" and ps sps and data::\"nat \\<times> 'd\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "have \"set (gb_red_aux (gs @ bs) sps) \\<subseteq> pmdl (args_to_set ([], gs @ bs, sps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (gb_red_aux (gs @ bs) sps)\n    \\<subseteq> pmdl (args_to_set ([], gs @ bs, sps))", "by (fact pmdl_gb_red_aux)"], ["proof (state)\nthis:\n  set (gb_red_aux (gs @ bs) sps)\n  \\<subseteq> pmdl (args_to_set ([], gs @ bs, sps))\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "also"], ["proof (state)\nthis:\n  set (gb_red_aux (gs @ bs) sps)\n  \\<subseteq> pmdl (args_to_set ([], gs @ bs, sps))\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "have \"... = pmdl (args_to_set (gs, bs, sps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (args_to_set ([], gs @ bs, sps)) = pmdl (args_to_set (gs, bs, sps))", "by (simp add: args_to_set_alt image_Un)"], ["proof (state)\nthis:\n  pmdl (args_to_set ([], gs @ bs, sps)) = pmdl (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "finally"], ["proof (chain)\npicking this:\n  set (gb_red_aux (gs @ bs) sps)\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps))", "have \"fst ` set (fst (gb_red gs bs ps sps data)) \\<subseteq> pmdl (args_to_set (gs, bs, sps))\""], ["proof (prove)\nusing this:\n  set (gb_red_aux (gs @ bs) sps)\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. fst ` set (fst (gb_red gs bs ps sps data))\n    \\<subseteq> pmdl (args_to_set (gs, bs, sps))", "by (simp only: fst_set_fst_gb_red)"], ["proof (state)\nthis:\n  fst ` set (fst (gb_red gs bs ps sps data))\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "moreover"], ["proof (state)\nthis:\n  fst ` set (fst (gb_red gs bs ps sps data))\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "{"], ["proof (state)\nthis:\n  fst ` set (fst (gb_red gs bs ps sps data))\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps))\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "fix p q :: \"('t, 'b, 'c) pdata\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "assume \"(p, q) \\<in> set sps\""], ["proof (state)\nthis:\n  (p, q) \\<in> set sps\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "hence \"(red (fst ` set (gs @ bs) \\<union> set (gb_red_aux (gs @ bs) sps)))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) 0\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> set sps\n\ngoal (1 subgoal):\n 1. (red (fst ` set (gs @ bs) \\<union>\n          set (gb_red_aux (gs @ bs) sps)))\\<^sup>*\\<^sup>*\n     (spoly (fst p) (fst q)) 0", "by (rule gb_red_aux_spoly_reducible)"], ["proof (state)\nthis:\n  (red (fst ` set (gs @ bs) \\<union>\n        set (gb_red_aux (gs @ bs) sps)))\\<^sup>*\\<^sup>*\n   (spoly (fst p) (fst q)) 0\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "}"], ["proof (state)\nthis:\n  (?p96, ?q96) \\<in> set sps \\<Longrightarrow>\n  (red (fst ` set (gs @ bs) \\<union>\n        set (gb_red_aux (gs @ bs) sps)))\\<^sup>*\\<^sup>*\n   (spoly (fst ?p96) (fst ?q96)) 0\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps sps data.\n       \\<lbrakk>is_Groebner_basis (fst ` set gs);\n        unique_idx (gs @ bs) data\\<rbrakk>\n       \\<Longrightarrow> fst ` set (fst (gb_red gs bs ps sps data))\n                         \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n                         (\\<forall>(p, q)\\<in>set sps.\n                             set sps\n                             \\<subseteq> set bs \\<times>\n   (set gs \\<union> set bs) \\<longrightarrow>\n                             (red (fst ` (set gs \\<union> set bs) \\<union>\n                                   fst `\n                                   set (fst\n   (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n                              (spoly (fst p) (fst q)) 0)", "ultimately"], ["proof (chain)\npicking this:\n  fst ` set (fst (gb_red gs bs ps sps data))\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps))\n  (?p96, ?q96) \\<in> set sps \\<Longrightarrow>\n  (red (fst ` set (gs @ bs) \\<union>\n        set (gb_red_aux (gs @ bs) sps)))\\<^sup>*\\<^sup>*\n   (spoly (fst ?p96) (fst ?q96)) 0", "show\n    \"fst ` set (fst (gb_red gs bs ps sps data)) \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n     (\\<forall>(p, q)\\<in>set sps.\n         set sps \\<subseteq> set bs \\<times> (set gs \\<union> set bs) \\<longrightarrow>\n         (red (fst ` (set gs \\<union> set bs) \\<union> fst ` set (fst (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>* (spoly (fst p) (fst q)) 0)\""], ["proof (prove)\nusing this:\n  fst ` set (fst (gb_red gs bs ps sps data))\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps))\n  (?p96, ?q96) \\<in> set sps \\<Longrightarrow>\n  (red (fst ` set (gs @ bs) \\<union>\n        set (gb_red_aux (gs @ bs) sps)))\\<^sup>*\\<^sup>*\n   (spoly (fst ?p96) (fst ?q96)) 0\n\ngoal (1 subgoal):\n 1. fst ` set (fst (gb_red gs bs ps sps data))\n    \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n    (\\<forall>(p, q)\\<in>set sps.\n        set sps\n        \\<subseteq> set bs \\<times>\n                    (set gs \\<union> set bs) \\<longrightarrow>\n        (red (fst ` (set gs \\<union> set bs) \\<union>\n              fst ` set (fst (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n         (spoly (fst p) (fst q)) 0)", "by (auto simp add: image_Un fst_set_fst_gb_red)"], ["proof (state)\nthis:\n  fst ` set (fst (gb_red gs bs ps sps data))\n  \\<subseteq> pmdl (args_to_set (gs, bs, sps)) \\<and>\n  (\\<forall>(p, q)\\<in>set sps.\n      set sps\n      \\<subseteq> set bs \\<times> (set gs \\<union> set bs) \\<longrightarrow>\n      (red (fst ` (set gs \\<union> set bs) \\<union>\n            fst ` set (fst (gb_red gs bs ps sps data))))\\<^sup>*\\<^sup>*\n       (spoly (fst p) (fst q)) 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas compl_struct_gb_red = compl_struct_rcp[OF rcp_spec_gb_red]"], ["", "lemmas compl_pmdl_gb_red = compl_pmdl_rcp[OF rcp_spec_gb_red]"], ["", "lemmas compl_conn_gb_red = compl_conn_rcp[OF rcp_spec_gb_red]"], ["", "subsection \\<open>Pair Selection\\<close>"], ["", "primrec gb_sel :: \"('t, 'b::zero, 'c, 'd) selT\" where\n  \"gb_sel gs bs [] data = []\"|\n  \"gb_sel gs bs (p # ps) data = [p]\""], ["", "lemma sel_spec_gb_sel: \"sel_spec gb_sel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sel_spec gb_sel", "proof (rule sel_specI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gs bs ps data.\n       ps \\<noteq> [] \\<Longrightarrow>\n       gb_sel gs bs ps data \\<noteq> [] \\<and>\n       set (gb_sel gs bs ps data) \\<subseteq> set ps", "fix gs bs :: \"('t, 'b, 'c) pdata list\" and ps::\"('t, 'b, 'c) pdata_pair list\" and data::\"nat \\<times> 'd\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gs bs ps data.\n       ps \\<noteq> [] \\<Longrightarrow>\n       gb_sel gs bs ps data \\<noteq> [] \\<and>\n       set (gb_sel gs bs ps data) \\<subseteq> set ps", "assume \"ps \\<noteq> []\""], ["proof (state)\nthis:\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps data.\n       ps \\<noteq> [] \\<Longrightarrow>\n       gb_sel gs bs ps data \\<noteq> [] \\<and>\n       set (gb_sel gs bs ps data) \\<subseteq> set ps", "then"], ["proof (chain)\npicking this:\n  ps \\<noteq> []", "obtain p ps' where ps: \"ps = p # ps'\""], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>p ps'. ps = p # ps' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson list.exhaust)"], ["proof (state)\nthis:\n  ps = p # ps'\n\ngoal (1 subgoal):\n 1. \\<And>gs bs ps data.\n       ps \\<noteq> [] \\<Longrightarrow>\n       gb_sel gs bs ps data \\<noteq> [] \\<and>\n       set (gb_sel gs bs ps data) \\<subseteq> set ps", "show \"gb_sel gs bs ps data \\<noteq> [] \\<and> set (gb_sel gs bs ps data) \\<subseteq> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_sel gs bs ps data \\<noteq> [] \\<and>\n    set (gb_sel gs bs ps data) \\<subseteq> set ps", "by (simp add: ps)"], ["proof (state)\nthis:\n  gb_sel gs bs ps data \\<noteq> [] \\<and>\n  set (gb_sel gs bs ps data) \\<subseteq> set ps\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Buchberger's Algorithm\\<close>"], ["", "lemma struct_spec_gb: \"struct_spec gb_sel add_pairs_canon add_basis_canon gb_red\""], ["proof (prove)\ngoal (1 subgoal):\n 1. struct_spec gb_sel add_pairs_canon add_basis_canon gb_red", "using sel_spec_gb_sel ap_spec_add_pairs_canon ab_spec_add_basis_sorted compl_struct_gb_red"], ["proof (prove)\nusing this:\n  sel_spec gb_sel\n  ap_spec add_pairs_canon\n  ab_spec (add_basis_sorted ?rel)\n  compl_struct gb_red\n\ngoal (1 subgoal):\n 1. struct_spec gb_sel add_pairs_canon add_basis_canon gb_red", "by (rule struct_specI)"], ["", "definition gb_aux :: \"('t, 'b, 'c) pdata list \\<Rightarrow> nat \\<times> nat \\<times> 'd \\<Rightarrow> ('t, 'b, 'c) pdata list \\<Rightarrow>\n                   ('t, 'b, 'c) pdata_pair list \\<Rightarrow> ('t, 'b::field, 'c::default) pdata list\"\n  where \"gb_aux = gb_schema_aux gb_sel add_pairs_canon add_basis_canon gb_red\""], ["", "lemmas gb_aux_simps [code] = gb_schema_aux_simps[OF struct_spec_gb, folded gb_aux_def]"], ["", "definition gb :: \"('t, 'b, 'c) pdata' list \\<Rightarrow> 'd \\<Rightarrow> ('t, 'b::field, 'c::default) pdata' list\"\n  where \"gb = gb_schema_direct gb_sel add_pairs_canon add_basis_canon gb_red\""], ["", "lemmas gb_simps [code] = gb_schema_direct_def[of gb_sel add_pairs_canon add_basis_canon gb_red, folded gb_def gb_aux_def]"], ["", "lemmas gb_isGB = gb_schema_direct_isGB[OF struct_spec_gb compl_conn_gb_red, folded gb_def]"], ["", "lemmas gb_pmdl = gb_schema_direct_pmdl[OF struct_spec_gb compl_pmdl_gb_red, folded gb_def]"], ["", "subsubsection \\<open>Special Case: \\<open>punit\\<close>\\<close>"], ["", "lemma (in gd_term) struct_spec_gb_punit: \"punit.struct_spec punit.gb_sel add_pairs_punit_canon punit.add_basis_canon punit.gb_red\""], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.struct_spec punit.gb_sel add_pairs_punit_canon\n     punit.add_basis_canon punit.gb_red", "using punit.sel_spec_gb_sel ap_spec_add_pairs_punit_canon ab_spec_add_basis_sorted punit.compl_struct_gb_red"], ["proof (prove)\nusing this:\n  sel_spec punit.gb_sel\n  punit.ap_spec add_pairs_punit_canon\n  ab_spec (add_basis_sorted ?rel)\n  punit.compl_struct punit.gb_red\n\ngoal (1 subgoal):\n 1. punit.struct_spec punit.gb_sel add_pairs_punit_canon\n     punit.add_basis_canon punit.gb_red", "by (rule punit.struct_specI)"], ["", "definition gb_aux_punit :: \"('a, 'b, 'c) pdata list \\<Rightarrow> nat \\<times> nat \\<times> 'd \\<Rightarrow> ('a, 'b, 'c) pdata list \\<Rightarrow>\n                   ('a, 'b, 'c) pdata_pair list \\<Rightarrow> ('a, 'b::field, 'c::default) pdata list\"\n  where \"gb_aux_punit = punit.gb_schema_aux punit.gb_sel add_pairs_punit_canon punit.add_basis_canon punit.gb_red\""], ["", "lemmas gb_aux_punit_simps [code] = punit.gb_schema_aux_simps[OF struct_spec_gb_punit, folded gb_aux_punit_def]"], ["", "definition gb_punit :: \"('a, 'b, 'c) pdata' list \\<Rightarrow> 'd \\<Rightarrow> ('a, 'b::field, 'c::default) pdata' list\"\n  where \"gb_punit = punit.gb_schema_direct punit.gb_sel add_pairs_punit_canon punit.add_basis_canon punit.gb_red\""], ["", "lemmas gb_punit_simps [code] = punit.gb_schema_direct_def[of \"punit.gb_sel\" add_pairs_punit_canon\n                                \"punit.add_basis_canon\" \"punit.gb_red\", folded gb_punit_def gb_aux_punit_def]"], ["", "lemmas gb_punit_isGB = punit.gb_schema_direct_isGB[OF struct_spec_gb_punit punit.compl_conn_gb_red, folded gb_punit_def]"], ["", "lemmas gb_punit_pmdl = punit.gb_schema_direct_pmdl[OF struct_spec_gb_punit punit.compl_pmdl_gb_red, folded gb_punit_def]"], ["", "end"], ["", "(* gd_term *)"], ["", "end"], ["", "(* theory *)"]]}