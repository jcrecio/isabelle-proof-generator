{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/Buchberger_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma (in gd_term) compute_trd_aux [code]:\n  \"trd_aux fs p r =\n    (if is_zero p then\n      r\n    else\n      case find_adds fs (lt p) of\n        None   \\<Rightarrow> trd_aux fs (tail p) (plus_monomial_less r (lc p) (lt p))\n      | Some f \\<Rightarrow> trd_aux fs (tail p - monom_mult (lc p / lc f) (lp p - lp f) (tail f)) r\n    )\"", "lemma compute_spoly_punit [code]:\n  \"spoly_punit to p q = (let t1 = lt_punit to p; t2 = lt_punit to q; l = lcs t1 t2 in\n         (monom_mult_punit (1 / lc_punit to p) (l - t1) p) - (monom_mult_punit (1 / lc_punit to q) (l - t2) q))\"", "lemma compute_trd_punit [code]: \"trd_punit to fs p = trd_aux_punit to fs p (change_ord to 0)\"", "lemma\n  \"lt_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = sparse\\<^sub>0 [(0, 2), (2, 3)]\"", "lemma\n  \"lc_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 1\"", "lemma\n  \"tail_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 3 * X\\<^sup>2 * Y\"", "lemma\n  \"ord_strict_p_punit DRLEX (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2) (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2)\"", "lemma\n  \"trd_punit DRLEX [Y\\<^sup>2 * Z + 2 * Y * Z ^ 3] (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z ^ 3) =\n    X\\<^sup>2 * Z ^ 4 + Y ^ 4 * Z\"", "lemma\n  \"spoly_punit DRLEX (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2) (Y\\<^sup>2 * Z + 2 * Z ^ 3) =\n    -2 * Y ^ 3 * Z\\<^sup>2 - (C\\<^sub>0 (1 / 2)) * X\\<^sup>2 * Y\\<^sup>2 * Z\\<^sup>2\"", "lemma\n  \"gb_punit DRLEX\n    [\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ())\n    ] () =\n    [\n     (-2 * Y ^ 3 * Z\\<^sup>2 - (C\\<^sub>0 (1 / 2)) * X\\<^sup>2 * Y\\<^sup>2 * Z\\<^sup>2, ()),\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ()),\n     (- (C\\<^sub>0 (1 / 2)) * X\\<^sup>2 * Y ^ 4 * Z - 2 * Y ^ 5 * Z, ())\n    ]\"", "lemma\n  \"gb_punit DRLEX\n    [\n     (X\\<^sup>2 * Z\\<^sup>2 - Y, ()),\n     (Y\\<^sup>2 * Z - 1, ())\n    ] () =\n    [\n     (- (Y ^ 3) + X\\<^sup>2 * Z, ()),\n     (X\\<^sup>2 * Z\\<^sup>2 - Y, ()),\n     (Y\\<^sup>2 * Z - 1, ())\n    ]\"", "lemma\n  \"gb_punit DRLEX\n    [\n     (X ^ 3 - X * Y * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z - 1, ())\n    ] () =\n    [\n     (- (X ^ 3 * Y) + X * Z, ()),\n     (X ^ 3 - X * Y * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z - 1, ()),\n     (- (X * Z ^ 3) + X ^ 5, ())\n    ]\"", "lemma\n  \"gb_punit DRLEX\n    [\n     (X\\<^sup>2 + Y\\<^sup>2 + Z\\<^sup>2 - 1, ()),\n     (X * Y - Z - 1, ()),\n     (Y\\<^sup>2 + X, ()),\n     (Z\\<^sup>2 + X, ())\n    ] () =\n    [\n     (1, ())\n    ]\"", "lemma compute_adds_term_pprod [code]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\"", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\"", "lemma compute_shift_map_keys_pprod [code abstract]:\n  \"list_of_oalist_ntm (shift_map_keys_pprod t f xs) = map_raw (\\<lambda>(k, v). (splus_pprod t k, f v)) (list_of_oalist_ntm xs)\"", "lemma compute_trd_pprod [code]: \"trd_pprod to fs p = trd_aux_pprod to fs p (change_ord to 0)\"", "lemmas [code] = conversep_iff", "lemma\n  \"ord_p_pprod (POT DRLEX) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z) + Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z\\<^sup>2 + 2 * Y ^ 3 * Z\\<^sup>2))\"", "lemma\n  \"tail_pprod (POT DRLEX) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z) + Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)) = Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)\"", "lemma\n  \"lt_pprod (POT DRLEX) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z) + Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)) = (sparse\\<^sub>0 [(0, 2), (2, 1)], 1)\"", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 1)}\"", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 2 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 2)}\"", "lemma\n  \"Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4) + Vec\\<^sub>0 1 (- 2 * Y ^ 3 * Z\\<^sup>2) =\n    Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4)\"", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 0) = 1\"", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 1) = 0\"", "lemma\n  \"Vec\\<^sub>0 0 (0 * X^2 * Z^7) + Vec\\<^sub>0 1 (0 * Y^3*Z\\<^sup>2) = 0\"", "lemma\n  \"monom_mult_pprod 3 (sparse\\<^sub>0 [(1, 2::nat)]) (Vec\\<^sub>0 0 (X\\<^sup>2 * Z) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    Vec\\<^sub>0 0 (3 * Y\\<^sup>2 * Z * X\\<^sup>2) + Vec\\<^sub>0 1 (6 * Y ^ 5 * Z\\<^sup>2)\"", "lemma\n  \"trd_pprod DRLEX [Vec\\<^sub>0 0 (Y\\<^sup>2 * Z + 2 * Y * Z ^ 3)] (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z ^ 3)) =\n    Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 4 + Y ^ 4 * Z)\"", "lemma\n  \"length (gb_pprod (POT DRLEX)\n    [\n     (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2), ()),\n     (Vec\\<^sub>0 0 (Y\\<^sup>2 * Z + 2 * Z ^ 3), ())\n    ] ()) = 4\""], "translations": [["", "lemma (in gd_term) compute_trd_aux [code]:\n  \"trd_aux fs p r =\n    (if is_zero p then\n      r\n    else\n      case find_adds fs (lt p) of\n        None   \\<Rightarrow> trd_aux fs (tail p) (plus_monomial_less r (lc p) (lt p))\n      | Some f \\<Rightarrow> trd_aux fs (tail p - monom_mult (lc p / lc f) (lp p - lp f) (tail f)) r\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd_aux fs p r =\n    (if is_zero p then r\n     else case find_adds fs (lt p) of\n          None \\<Rightarrow>\n            trd_aux fs (tail p) (plus_monomial_less r (lc p) (lt p))\n          | Some f \\<Rightarrow>\n              trd_aux fs\n               (tail p - monom_mult (lc p / lc f) (lp p - lp f) (tail f)) r)", "by (simp only: trd_aux.simps[of fs p r] plus_monomial_less_def is_zero_def)"], ["", "subsection \\<open>Scalar Polynomials\\<close>"], ["", "global_interpretation punit': gd_powerprod \"ord_pp_punit cmp_term\" \"ord_pp_strict_punit cmp_term\"\n  rewrites \"punit.adds_term = (adds)\"\n  and \"punit.pp_of_term = (\\<lambda>x. x)\"\n  and \"punit.component_of_term = (\\<lambda>_. ())\"\n  and \"punit.monom_mult = monom_mult_punit\"\n  and \"punit.mult_scalar = mult_scalar_punit\"\n  and \"punit'.punit.min_term = min_term_punit\"\n  and \"punit'.punit.lt = lt_punit cmp_term\"\n  and \"punit'.punit.lc = lc_punit cmp_term\"\n  and \"punit'.punit.tail = tail_punit cmp_term\"\n  and \"punit'.punit.ord_p = ord_p_punit cmp_term\"\n  and \"punit'.punit.ord_strict_p = ord_strict_p_punit cmp_term\"\n  for cmp_term :: \"('a::nat, 'b::{nat,add_wellorder}) pp nat_term_order\"\n\n  defines find_adds_punit = punit'.punit.find_adds\n  and trd_aux_punit = punit'.punit.trd_aux\n  and trd_punit = punit'.punit.trd\n  and spoly_punit = punit'.punit.spoly\n  and count_const_lt_components_punit = punit'.punit.count_const_lt_components\n  and count_rem_components_punit = punit'.punit.count_rem_components\n  and const_lt_component_punit = punit'.punit.const_lt_component\n  and full_gb_punit = punit'.punit.full_gb\n  and add_pairs_single_sorted_punit = punit'.punit.add_pairs_single_sorted\n  and add_pairs_punit = punit'.punit.add_pairs\n  and canon_pair_order_aux_punit = punit'.punit.canon_pair_order_aux\n  and canon_basis_order_punit = punit'.punit.canon_basis_order\n  and new_pairs_sorted_punit = punit'.punit.new_pairs_sorted\n  and product_crit_punit = punit'.punit.product_crit\n  and chain_ncrit_punit = punit'.punit.chain_ncrit\n  and chain_ocrit_punit = punit'.punit.chain_ocrit\n  and apply_icrit_punit = punit'.punit.apply_icrit\n  and apply_ncrit_punit = punit'.punit.apply_ncrit\n  and apply_ocrit_punit = punit'.punit.apply_ocrit\n  and trdsp_punit = punit'.punit.trdsp\n  and gb_sel_punit = punit'.punit.gb_sel\n  and gb_red_aux_punit = punit'.punit.gb_red_aux\n  and gb_red_punit = punit'.punit.gb_red\n  and gb_aux_punit = punit'.punit.gb_aux_punit\n  and gb_punit = punit'.punit.gb_punit \\<comment>\\<open>Faster, because incorporates product criterion.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gd_powerprod (ord_pp_punit cmp_term)\n       (ord_pp_strict_punit cmp_term) &&&\n      punit.adds_term = (adds) &&& punit.pp_of_term = (\\<lambda>x. x)) &&&\n     punit.component_of_term = (\\<lambda>_. ()) &&&\n     punit.monom_mult = monom_mult_punit &&&\n     punit.mult_scalar = mult_scalar_punit) &&&\n    (ordered_term.min_term fst = min_term_punit &&&\n     ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term &&&\n     ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term) &&&\n    ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term &&&\n    ordered_term.ord_p (ord_pp_strict_punit cmp_term) =\n    ord_p_punit cmp_term &&&\n    ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_powerprod (ord_pp_punit cmp_term) (ord_pp_strict_punit cmp_term)", "by (fact gd_powerprod_ord_pp_punit)"], ["proof (prove)\ngoal (11 subgoals):\n 1. punit.adds_term = (adds)\n 2. punit.pp_of_term = (\\<lambda>x. x)\n 3. punit.component_of_term = (\\<lambda>_. ())\n 4. punit.monom_mult = monom_mult_punit\n 5. punit.mult_scalar = mult_scalar_punit\n 6. ordered_term.min_term fst = min_term_punit\n 7. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 8. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 9. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 10. ordered_term.ord_p (ord_pp_strict_punit cmp_term) =\n     ord_p_punit cmp_term\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.adds_term = (adds)", "by (fact punit_adds_term)"], ["proof (prove)\ngoal (10 subgoals):\n 1. punit.pp_of_term = (\\<lambda>x. x)\n 2. punit.component_of_term = (\\<lambda>_. ())\n 3. punit.monom_mult = monom_mult_punit\n 4. punit.mult_scalar = mult_scalar_punit\n 5. ordered_term.min_term fst = min_term_punit\n 6. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 7. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 8. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 9. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 10. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n     ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.pp_of_term = (\\<lambda>x. x)", "by (simp add: id_def)"], ["proof (prove)\ngoal (9 subgoals):\n 1. punit.component_of_term = (\\<lambda>_. ())\n 2. punit.monom_mult = monom_mult_punit\n 3. punit.mult_scalar = mult_scalar_punit\n 4. ordered_term.min_term fst = min_term_punit\n 5. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 6. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 7. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 8. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 9. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.component_of_term = (\\<lambda>_. ())", "by (fact punit_component_of_term)"], ["proof (prove)\ngoal (8 subgoals):\n 1. punit.monom_mult = monom_mult_punit\n 2. punit.mult_scalar = mult_scalar_punit\n 3. ordered_term.min_term fst = min_term_punit\n 4. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 5. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 6. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 7. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 8. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult = monom_mult_punit", "by (simp only: monom_mult_punit_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. punit.mult_scalar = mult_scalar_punit\n 2. ordered_term.min_term fst = min_term_punit\n 3. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 4. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 5. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 6. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 7. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.mult_scalar = mult_scalar_punit", "by (simp only: mult_scalar_punit_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ordered_term.min_term fst = min_term_punit\n 2. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 3. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 4. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 5. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 6. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.min_term fst = min_term_punit", "using min_term_punit_def"], ["proof (prove)\nusing this:\n  min_term_punit \\<equiv> ordered_term.min_term fst\n\ngoal (1 subgoal):\n 1. ordered_term.min_term fst = min_term_punit", "by fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 2. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 3. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 4. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 5. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term", "by (simp only: lt_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 2. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 3. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 4. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term", "by (simp only: lc_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 2. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 3. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term", "by (simp only: tail_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 2. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term", "by (simp only: ord_p_punit_def ord_pp_strict_punit_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "by (simp only: ord_strict_p_punit_def ord_pp_strict_punit_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_spoly_punit [code]:\n  \"spoly_punit to p q = (let t1 = lt_punit to p; t2 = lt_punit to q; l = lcs t1 t2 in\n         (monom_mult_punit (1 / lc_punit to p) (l - t1) p) - (monom_mult_punit (1 / lc_punit to q) (l - t2) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spoly_punit to p q =\n    (let t1 = lt_punit to p; t2 = lt_punit to q; l = lcs t1 t2\n     in monom_mult_punit ((1::'c) / lc_punit to p) (l - t1) p -\n        monom_mult_punit ((1::'c) / lc_punit to q) (l - t2) q)", "by (simp add: punit'.punit.spoly_def Let_def punit'.punit.lc_def)"], ["", "lemma compute_trd_punit [code]: \"trd_punit to fs p = trd_aux_punit to fs p (change_ord to 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd_punit to fs p = trd_aux_punit to fs p (change_ord to 0)", "by (simp only: punit'.punit.trd_def change_ord_def)"], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"lt_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = sparse\\<^sub>0 [(0, 2), (2, 3)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n      3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1) =\n    sparse\\<^sub>0 [(0, 2), (2, 3)]", "by eval"], ["", "lemma\n  \"lc_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n      3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1) =\n    1", "by eval"], ["", "lemma\n  \"tail_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 3 * X\\<^sup>2 * Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n      3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1) =\n    3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1", "by eval"], ["", "lemma\n  \"ord_strict_p_punit DRLEX (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2) (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_strict_p_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 7 +\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)", "by eval"], ["", "lemma\n  \"trd_punit DRLEX [Y\\<^sup>2 * Z + 2 * Y * Z ^ 3] (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z ^ 3) =\n    X\\<^sup>2 * Z ^ 4 + Y ^ 4 * Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd_punit DRLEX\n     [(V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 +\n      2 * V\\<^sub>0 1 * V\\<^sub>0 2 ^ 3]\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n      2 * V\\<^sub>0 1 ^ 3 * V\\<^sub>0 2 ^ 3) =\n    (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 + V\\<^sub>0 1 ^ 4 * V\\<^sub>0 2", "by eval"], ["", "lemma\n  \"spoly_punit DRLEX (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2) (Y\\<^sup>2 * Z + 2 * Z ^ 3) =\n    -2 * Y ^ 3 * Z\\<^sup>2 - (C\\<^sub>0 (1 / 2)) * X\\<^sup>2 * Y\\<^sup>2 * Z\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spoly_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)\n     ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 + 2 * V\\<^sub>0 2 ^ 3) =\n    - 2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2 -\n    C\\<^sub>0 (1 / 2) * (V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 1)\\<^sup>2 *\n    (V\\<^sub>0 2)\\<^sup>2", "by eval"], ["", "lemma\n  \"gb_punit DRLEX\n    [\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ())\n    ] () =\n    [\n     (-2 * Y ^ 3 * Z\\<^sup>2 - (C\\<^sub>0 (1 / 2)) * X\\<^sup>2 * Y\\<^sup>2 * Z\\<^sup>2, ()),\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ()),\n     (- (C\\<^sub>0 (1 / 2)) * X\\<^sup>2 * Y ^ 4 * Z - 2 * Y ^ 5 * Z, ())\n    ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_punit DRLEX\n     [((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n       2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2,\n       ()),\n      ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 + 2 * V\\<^sub>0 2 ^ 3, ())]\n     () =\n    [(- 2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2 -\n      C\\<^sub>0 (1 / 2) * (V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 1)\\<^sup>2 *\n      (V\\<^sub>0 2)\\<^sup>2,\n      ()),\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2,\n      ()),\n     ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 + 2 * V\\<^sub>0 2 ^ 3, ()),\n     (- C\\<^sub>0 (1 / 2) * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1 ^ 4 *\n      V\\<^sub>0 2 -\n      2 * V\\<^sub>0 1 ^ 5 * V\\<^sub>0 2,\n      ())]", "by eval"], ["", "lemma\n  \"gb_punit DRLEX\n    [\n     (X\\<^sup>2 * Z\\<^sup>2 - Y, ()),\n     (Y\\<^sup>2 * Z - 1, ())\n    ] () =\n    [\n     (- (Y ^ 3) + X\\<^sup>2 * Z, ()),\n     (X\\<^sup>2 * Z\\<^sup>2 - Y, ()),\n     (Y\\<^sup>2 * Z - 1, ())\n    ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_punit DRLEX\n     [((V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 1, ()),\n      ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 - 1, ())]\n     () =\n    [(- (V\\<^sub>0 1 ^ 3) + (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2, ()),\n     ((V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 1, ()),\n     ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 - 1, ())]", "by eval"], ["", "lemma\n  \"gb_punit DRLEX\n    [\n     (X ^ 3 - X * Y * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z - 1, ())\n    ] () =\n    [\n     (- (X ^ 3 * Y) + X * Z, ()),\n     (X ^ 3 - X * Y * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z - 1, ()),\n     (- (X * Z ^ 3) + X ^ 5, ())\n    ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_punit DRLEX\n     [(V\\<^sub>0 0 ^ 3 - V\\<^sub>0 0 * V\\<^sub>0 1 * (V\\<^sub>0 2)\\<^sup>2,\n       ()),\n      ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 - 1, ())]\n     () =\n    [(- (V\\<^sub>0 0 ^ 3 * V\\<^sub>0 1) + V\\<^sub>0 0 * V\\<^sub>0 2, ()),\n     (V\\<^sub>0 0 ^ 3 - V\\<^sub>0 0 * V\\<^sub>0 1 * (V\\<^sub>0 2)\\<^sup>2,\n      ()),\n     ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 - 1, ()),\n     (- (V\\<^sub>0 0 * V\\<^sub>0 2 ^ 3) + V\\<^sub>0 0 ^ 5, ())]", "by eval"], ["", "lemma\n  \"gb_punit DRLEX\n    [\n     (X\\<^sup>2 + Y\\<^sup>2 + Z\\<^sup>2 - 1, ()),\n     (X * Y - Z - 1, ()),\n     (Y\\<^sup>2 + X, ()),\n     (Z\\<^sup>2 + X, ())\n    ] () =\n    [\n     (1, ())\n    ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_punit DRLEX\n     [((V\\<^sub>0 0)\\<^sup>2 + (V\\<^sub>0 1)\\<^sup>2 +\n       (V\\<^sub>0 2)\\<^sup>2 -\n       1,\n       ()),\n      (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2 - 1, ()),\n      ((V\\<^sub>0 1)\\<^sup>2 + V\\<^sub>0 0, ()),\n      ((V\\<^sub>0 2)\\<^sup>2 + V\\<^sub>0 0, ())]\n     () =\n    [(1, ())]", "by eval"], ["", "end"], ["", "value [code] \"length (gb_punit DRLEX (map (\\<lambda>p. (p, ())) ((katsura DRLEX 2)::(_ \\<Rightarrow>\\<^sub>0 rat) list)) ())\""], ["", "value [code] \"length (gb_punit DRLEX (map (\\<lambda>p. (p, ())) ((cyclic DRLEX 5)::(_ \\<Rightarrow>\\<^sub>0 rat) list)) ())\""], ["", "subsection \\<open>Vector Polynomials\\<close>"], ["", "text \\<open>We must define the following four constants outside the global interpretation, since otherwise\n  their types are too general.\\<close>"], ["", "definition splus_pprod :: \"('a::nat, 'b::nat) pp \\<Rightarrow> _\"\n  where \"splus_pprod = pprod.splus\""], ["", "definition monom_mult_pprod :: \"'c::semiring_0 \\<Rightarrow> ('a::nat, 'b::nat) pp \\<Rightarrow> _\"\n  where \"monom_mult_pprod = pprod.monom_mult\""], ["", "definition mult_scalar_pprod :: \"(('a::nat, 'b::nat) pp \\<Rightarrow>\\<^sub>0 'c::semiring_0) \\<Rightarrow> _\"\n  where \"mult_scalar_pprod = pprod.mult_scalar\""], ["", "definition adds_term_pprod :: \"(('a::nat, 'b::nat) pp \\<times> _) \\<Rightarrow> _\"\n  where \"adds_term_pprod = pprod.adds_term\""], ["", "global_interpretation pprod': gd_nat_term \"\\<lambda>x::('a, 'b) pp \\<times> 'c. x\" \"\\<lambda>x. x\" cmp_term\n  rewrites \"pprod.pp_of_term = fst\"\n  and \"pprod.component_of_term = snd\"\n  and \"pprod.splus = splus_pprod\"\n  and \"pprod.monom_mult = monom_mult_pprod\"\n  and \"pprod.mult_scalar = mult_scalar_pprod\"\n  and \"pprod.adds_term = adds_term_pprod\"\n  for cmp_term :: \"(('a::nat, 'b::nat) pp \\<times> 'c::{nat,the_min}) nat_term_order\"\n  defines shift_map_keys_pprod = pprod'.shift_map_keys\n  and min_term_pprod = pprod'.min_term\n  and lt_pprod = pprod'.lt\n  and lc_pprod = pprod'.lc\n  and tail_pprod = pprod'.tail\n  and comp_opt_p_pprod = pprod'.comp_opt_p\n  and ord_p_pprod = pprod'.ord_p\n  and ord_strict_p_pprod = pprod'.ord_strict_p\n  and find_adds_pprod = pprod'.find_adds\n  and trd_aux_pprod= pprod'.trd_aux\n  and trd_pprod = pprod'.trd\n  and spoly_pprod = pprod'.spoly\n  and count_const_lt_components_pprod = pprod'.count_const_lt_components\n  and count_rem_components_pprod = pprod'.count_rem_components\n  and const_lt_component_pprod = pprod'.const_lt_component\n  and full_gb_pprod = pprod'.full_gb\n  and keys_to_list_pprod = pprod'.keys_to_list\n  and Keys_to_list_pprod = pprod'.Keys_to_list\n  and add_pairs_single_sorted_pprod = pprod'.add_pairs_single_sorted\n  and add_pairs_pprod = pprod'.add_pairs\n  and canon_pair_order_aux_pprod = pprod'.canon_pair_order_aux\n  and canon_basis_order_pprod = pprod'.canon_basis_order\n  and new_pairs_sorted_pprod = pprod'.new_pairs_sorted\n  and component_crit_pprod = pprod'.component_crit\n  and chain_ncrit_pprod = pprod'.chain_ncrit\n  and chain_ocrit_pprod = pprod'.chain_ocrit\n  and apply_icrit_pprod = pprod'.apply_icrit\n  and apply_ncrit_pprod = pprod'.apply_ncrit\n  and apply_ocrit_pprod = pprod'.apply_ocrit\n  and trdsp_pprod = pprod'.trdsp\n  and gb_sel_pprod = pprod'.gb_sel\n  and gb_red_aux_pprod = pprod'.gb_red_aux\n  and gb_red_pprod = pprod'.gb_red\n  and gb_aux_pprod = pprod'.gb_aux\n  and gb_pprod = pprod'.gb"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gd_nat_term (\\<lambda>x. x) (\\<lambda>x. x) cmp_term &&&\n     pprod.pp_of_term = fst &&& pprod.component_of_term = snd) &&&\n    (pprod.splus = splus_pprod &&& pprod.monom_mult = monom_mult_pprod) &&&\n    pprod.mult_scalar = mult_scalar_pprod &&&\n    pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_nat_term (\\<lambda>x. x) (\\<lambda>x. x) cmp_term", "by (fact gd_nat_term_id)"], ["proof (prove)\ngoal (6 subgoals):\n 1. pprod.pp_of_term = fst\n 2. pprod.component_of_term = snd\n 3. pprod.splus = splus_pprod\n 4. pprod.monom_mult = monom_mult_pprod\n 5. pprod.mult_scalar = mult_scalar_pprod\n 6. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.pp_of_term = fst", "by (fact pprod_pp_of_term)"], ["proof (prove)\ngoal (5 subgoals):\n 1. pprod.component_of_term = snd\n 2. pprod.splus = splus_pprod\n 3. pprod.monom_mult = monom_mult_pprod\n 4. pprod.mult_scalar = mult_scalar_pprod\n 5. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.component_of_term = snd", "by (fact pprod_component_of_term)"], ["proof (prove)\ngoal (4 subgoals):\n 1. pprod.splus = splus_pprod\n 2. pprod.monom_mult = monom_mult_pprod\n 3. pprod.mult_scalar = mult_scalar_pprod\n 4. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.splus = splus_pprod", "by (simp only: splus_pprod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. pprod.monom_mult = monom_mult_pprod\n 2. pprod.mult_scalar = mult_scalar_pprod\n 3. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.monom_mult = monom_mult_pprod", "by (simp only: monom_mult_pprod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pprod.mult_scalar = mult_scalar_pprod\n 2. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.mult_scalar = mult_scalar_pprod", "by (simp only: mult_scalar_pprod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.adds_term = adds_term_pprod", "by (simp only: adds_term_pprod_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_adds_term_pprod [code]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adds_term_pprod u v =\n    (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))", "by (simp add: adds_term_pprod_def pprod.adds_term_def adds_pp_add_linorder_def)"], ["", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splus_pprod t (s, i) = (t + s, i)", "by (simp add: splus_pprod_def pprod.splus_def)"], ["", "lemma compute_shift_map_keys_pprod [code abstract]:\n  \"list_of_oalist_ntm (shift_map_keys_pprod t f xs) = map_raw (\\<lambda>(k, v). (splus_pprod t k, f v)) (list_of_oalist_ntm xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_ntm (shift_map_keys_pprod t f xs) =\n    map_raw (\\<lambda>(k, v). (splus_pprod t k, f v))\n     (list_of_oalist_ntm xs)", "by (simp add: pprod'.list_of_oalist_shift_keys case_prod_beta')"], ["", "lemma compute_trd_pprod [code]: \"trd_pprod to fs p = trd_aux_pprod to fs p (change_ord to 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd_pprod to fs p = trd_aux_pprod to fs p (change_ord to 0)", "by (simp only: pprod'.trd_def change_ord_def)"], ["", "lemmas [code] = conversep_iff"], ["", "definition Vec\\<^sub>0 :: \"nat \\<Rightarrow> (('a, nat) pp \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> (('a::nat, nat) pp \\<times> nat) \\<Rightarrow>\\<^sub>0 'b::semiring_1\" where\n  \"Vec\\<^sub>0 i p = mult_scalar_pprod p (Poly_Mapping.single (0, i) 1)\""], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"ord_p_pprod (POT DRLEX) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z) + Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z\\<^sup>2 + 2 * Y ^ 3 * Z\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_p_pprod (POT DRLEX)\n     (Vec\\<^sub>0 1 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2) +\n      Vec\\<^sub>0 0 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2))\n     (Vec\\<^sub>0 1\n       ((V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 2)\\<^sup>2 +\n        2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2))", "by eval"], ["", "lemma\n  \"tail_pprod (POT DRLEX) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z) + Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)) = Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_pprod (POT DRLEX)\n     (Vec\\<^sub>0 1 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2) +\n      Vec\\<^sub>0 0 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)) =\n    Vec\\<^sub>0 0 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)", "by eval"], ["", "lemma\n  \"lt_pprod (POT DRLEX) (Vec\\<^sub>0 1 (X\\<^sup>2 * Z) + Vec\\<^sub>0 0 (2 * Y ^ 3 * Z\\<^sup>2)) = (sparse\\<^sub>0 [(0, 2), (2, 1)], 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_pprod (POT DRLEX)\n     (Vec\\<^sub>0 1 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2) +\n      Vec\\<^sub>0 0 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)) =\n    (sparse\\<^sub>0 [(0, 2), (2, 1)], 1)", "by eval"], ["", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (Vec\\<^sub>0 0 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3) +\n      Vec\\<^sub>0 1 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0),\n     (sparse\\<^sub>0 [(1, 3), (2, 2)], 1)}", "by eval"], ["", "lemma\n  \"keys (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3) + Vec\\<^sub>0 2 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0), (sparse\\<^sub>0 [(1, 3), (2, 2)], 2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (Vec\\<^sub>0 0 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3) +\n      Vec\\<^sub>0 2 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)) =\n    {(sparse\\<^sub>0 [(0, 2), (2, 3)], 0),\n     (sparse\\<^sub>0 [(1, 3), (2, 2)], 2)}", "by eval"], ["", "lemma\n  \"Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4) + Vec\\<^sub>0 1 (- 2 * Y ^ 3 * Z\\<^sup>2) =\n    Vec\\<^sub>0 1 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 3 (X\\<^sup>2 * Z ^ 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vec\\<^sub>0 1\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 7 +\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2) +\n    Vec\\<^sub>0 3 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4) +\n    Vec\\<^sub>0 1 (- 2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2) =\n    Vec\\<^sub>0 1 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 7) +\n    Vec\\<^sub>0 3 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4)", "by eval"], ["", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Vec\\<^sub>0 0 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 7) +\n      Vec\\<^sub>0 1 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2 + 2))\n     (sparse\\<^sub>0 [(0, 2), (2, 7)], 0) =\n    1", "by eval"], ["", "lemma\n  \"lookup (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 7) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2 + 2)) (sparse\\<^sub>0 [(0, 2), (2, 7)], 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Vec\\<^sub>0 0 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 7) +\n      Vec\\<^sub>0 1 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2 + 2))\n     (sparse\\<^sub>0 [(0, 2), (2, 7)], 1) =\n    0", "by eval"], ["", "lemma\n  \"Vec\\<^sub>0 0 (0 * X^2 * Z^7) + Vec\\<^sub>0 1 (0 * Y^3*Z\\<^sup>2) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vec\\<^sub>0 0 (0 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 7) +\n    Vec\\<^sub>0 1 (0 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2) =\n    0", "by eval"], ["", "lemma\n  \"monom_mult_pprod 3 (sparse\\<^sub>0 [(1, 2::nat)]) (Vec\\<^sub>0 0 (X\\<^sup>2 * Z) + Vec\\<^sub>0 1 (2 * Y ^ 3 * Z\\<^sup>2)) =\n    Vec\\<^sub>0 0 (3 * Y\\<^sup>2 * Z * X\\<^sup>2) + Vec\\<^sub>0 1 (6 * Y ^ 5 * Z\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult_pprod 3 (sparse\\<^sub>0 [(1, 2)])\n     (Vec\\<^sub>0 0 ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2) +\n      Vec\\<^sub>0 1 (2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)) =\n    Vec\\<^sub>0 0\n     (3 * (V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 * (V\\<^sub>0 0)\\<^sup>2) +\n    Vec\\<^sub>0 1 (6 * V\\<^sub>0 1 ^ 5 * (V\\<^sub>0 2)\\<^sup>2)", "by eval"], ["", "lemma\n  \"trd_pprod DRLEX [Vec\\<^sub>0 0 (Y\\<^sup>2 * Z + 2 * Y * Z ^ 3)] (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z ^ 3)) =\n    Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 4 + Y ^ 4 * Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd_pprod DRLEX\n     [Vec\\<^sub>0 0\n       ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 +\n        2 * V\\<^sub>0 1 * V\\<^sub>0 2 ^ 3)]\n     (Vec\\<^sub>0 0\n       ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n        2 * V\\<^sub>0 1 ^ 3 * V\\<^sub>0 2 ^ 3)) =\n    Vec\\<^sub>0 0\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 +\n      V\\<^sub>0 1 ^ 4 * V\\<^sub>0 2)", "by eval"], ["", "lemma\n  \"length (gb_pprod (POT DRLEX)\n    [\n     (Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2), ()),\n     (Vec\\<^sub>0 0 (Y\\<^sup>2 * Z + 2 * Z ^ 3), ())\n    ] ()) = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (gb_pprod (POT DRLEX)\n       [(Vec\\<^sub>0 0\n          ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n           2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2),\n         ()),\n        (Vec\\<^sub>0 0\n          ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 + 2 * V\\<^sub>0 2 ^ 3),\n         ())]\n       ()) =\n    4", "by eval"], ["", "end"], ["", "end"], ["", "(* theory *)"]]}