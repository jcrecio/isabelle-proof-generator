{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/General.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma distinct_reorder: \"distinct (xs @ (y # ys)) = distinct (y # (xs @ ys))\"", "lemma set_reorder: \"set (xs @ (y # ys)) = set (y # (xs @ ys))\"", "lemma distinctI:\n  assumes \"\\<And>i j. i < j \\<Longrightarrow> i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> xs ! i \\<noteq> xs ! j\"\n  shows \"distinct xs\"", "lemma filter_nth_pairE:\n  assumes \"i < j\" and \"i < length (filter P xs)\" and \"j < length (filter P xs)\"\n  obtains i' j' where \"i' < j'\" and \"i' < length xs\" and \"j' < length xs\"\n    and \"(filter P xs) ! i = xs ! i'\" and \"(filter P xs) ! j = xs ! j'\"", "lemma distinct_filterI:\n  assumes \"\\<And>i j. i < j \\<Longrightarrow> i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> P (xs ! i) \\<Longrightarrow> P (xs ! j) \\<Longrightarrow> xs ! i \\<noteq> xs ! j\"\n  shows \"distinct (filter P xs)\"", "lemma set_zip_map: \"set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` (set xs)\"", "lemma set_zip_map1: \"set (zip (map f xs) xs) = (\\<lambda>x. (f x, x)) ` (set xs)\"", "lemma set_zip_map2: \"set (zip xs (map f xs)) = (\\<lambda>x. (x, f x)) ` (set xs)\"", "lemma UN_upt: \"(\\<Union>i\\<in>{0..<length xs}. f (xs ! i)) = (\\<Union>x\\<in>set xs. f x)\"", "lemma sum_list_zeroI':\n  assumes \"\\<And>i. i < length xs \\<Longrightarrow> xs ! i = 0\"\n  shows \"sum_list xs = 0\"", "lemma sum_list_map2_plus:\n  assumes \"length xs = length ys\"\n  shows \"sum_list (map2 (+) xs ys) = sum_list xs + sum_list (ys::'a::comm_monoid_add list)\"", "lemma sum_list_eq_nthI:\n  assumes \"i < length xs\" and \"\\<And>j. j < length xs \\<Longrightarrow> j \\<noteq> i \\<Longrightarrow> xs ! j = 0\"\n  shows \"sum_list xs = xs ! i\"", "lemma max_list_Max: \"xs \\<noteq> [] \\<Longrightarrow> max_list xs = Max (set xs)\"", "lemma max_list_ge:\n  assumes \"x \\<in> set xs\"\n  shows \"x \\<le> max_list xs\"", "lemma max_list_boundedI:\n  assumes \"xs \\<noteq> []\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<le> a\"\n  shows \"max_list xs \\<le> a\"", "lemma insort_wrt_not_Nil [simp]: \"insort_wrt r x xs \\<noteq> []\"", "lemma length_insort_wrt [simp]: \"length (insort_wrt r x xs) = Suc (length xs)\"", "lemma set_insort_wrt [simp]: \"set (insort_wrt r x xs) = insert x (set xs)\"", "lemma sorted_wrt_insort_wrt_imp_sorted_wrt:\n  assumes \"sorted_wrt r (insort_wrt s x xs)\"\n  shows \"sorted_wrt r xs\"", "lemma sorted_wrt_imp_sorted_wrt_insort_wrt:\n  assumes \"transp r\" and \"\\<And>a. r a x \\<or> r x a\" and \"sorted_wrt r xs\"\n  shows \"sorted_wrt r (insort_wrt r x xs)\"", "lemma set_diff_list: \"set (xs -- ys) = set xs - set ys\"", "lemma diff_list_disjoint: \"set ys \\<inter> set (xs -- ys) = {}\"", "lemma subset_append_diff_cancel:\n  assumes \"set ys \\<subseteq> set xs\"\n  shows \"set (ys @ (xs -- ys)) = set xs\"", "lemma set_insert_list: \"set (insert_list x xs) = insert x (set xs)\"", "lemma set_remdups_wrt: \"f ` set (remdups_wrt f xs) = f ` set xs\"", "lemma subset_remdups_wrt: \"set (remdups_wrt f xs) \\<subseteq> set xs\"", "lemma remdups_wrt_distinct_wrt:\n  assumes \"x \\<in> set (remdups_wrt f xs)\" and \"y \\<in> set (remdups_wrt f xs)\" and \"x \\<noteq> y\"\n  shows \"f x \\<noteq> f y\"", "lemma distinct_remdups_wrt: \"distinct (remdups_wrt f xs)\"", "lemma map_remdups_wrt: \"map f (remdups_wrt f xs) = remdups (map f xs)\"", "lemma remdups_wrt_append:\n  \"remdups_wrt f (xs @ ys) = (filter (\\<lambda>a. f a \\<notin> f ` set ys) (remdups_wrt f xs)) @ (remdups_wrt f ys)\"", "lemma map_idx_eq_map2: \"map_idx f xs n = map2 f xs [n..<n + length xs]\"", "lemma length_map_idx [simp]: \"length (map_idx f xs n) = length xs\"", "lemma map_idx_append: \"map_idx f (xs @ ys) n = (map_idx f xs n) @ (map_idx f ys (n + length xs))\"", "lemma map_idx_nth:\n  assumes \"i < length xs\"\n  shows \"(map_idx f xs n) ! i = f (xs ! i) (n + i)\"", "lemma map_map_idx: \"map f (map_idx g xs n) = map_idx (\\<lambda>x i. f (g x i)) xs n\"", "lemma map_idx_map: \"map_idx f (map g xs) n = map_idx (f \\<circ> g) xs n\"", "lemma map_idx_no_idx: \"map_idx (\\<lambda>x _. f x) xs n = map f xs\"", "lemma map_idx_no_elem: \"map_idx (\\<lambda>_. f) xs n = map f [n..<n + length xs]\"", "lemma map_idx_eq_map: \"map_idx f xs n = map (\\<lambda>i. f (xs ! i) (i + n)) [0..<length xs]\"", "lemma set_map_idx: \"set (map_idx f xs n) = (\\<lambda>i. f (xs ! i) (i + n)) ` {0..<length xs}\"", "lemma length_map_dup[simp]: \"length (map_dup f g xs) = length xs\"", "lemma map_dup_distinct:\n  assumes \"distinct xs\"\n  shows \"map_dup f g xs = map f xs\"", "lemma filter_map_dup_const:\n  \"filter (\\<lambda>x. x \\<noteq> c) (map_dup f (\\<lambda>_. c) xs) = filter (\\<lambda>x. x \\<noteq> c) (map f (remdups xs))\"", "lemma filter_zip_map_dup_const:\n  \"filter (\\<lambda>(a, b). a \\<noteq> c) (zip (map_dup f (\\<lambda>_. c) xs) xs) =\n    filter (\\<lambda>(a, b). a \\<noteq> c) (zip (map f (remdups xs)) (remdups xs))\"", "lemma filter_min_aux_supset: \"set ys \\<subseteq> set (filter_min_aux xs ys)\"", "lemma filter_min_aux_subset: \"set (filter_min_aux xs ys) \\<subseteq> set xs \\<union> set ys\"", "lemma filter_min_aux_relE:\n  assumes \"transp rel\" and \"x \\<in> set xs\" and \"x \\<notin> set (filter_min_aux xs ys)\"\n  obtains y where \"y \\<in> set (filter_min_aux xs ys)\" and \"rel y x\"", "lemma filter_min_aux_minimal:\n  assumes \"transp rel\" and \"x \\<in> set (filter_min_aux xs ys)\" and \"y \\<in> set (filter_min_aux xs ys)\"\n    and \"rel x y\"\n  assumes \"\\<And>a b. a \\<in> set xs \\<union> set ys \\<Longrightarrow> b \\<in> set ys \\<Longrightarrow> rel a b \\<Longrightarrow> a = b\"\n  shows \"x = y\"", "lemma filter_min_aux_distinct:\n  assumes \"reflp rel\" and \"distinct ys\"\n  shows \"distinct (filter_min_aux xs ys)\"", "lemma filter_min_subset: \"set (filter_min xs) \\<subseteq> set xs\"", "lemma filter_min_cases:\n  assumes \"transp rel\" and \"x \\<in> set xs\"\n  assumes \"x \\<in> set (filter_min xs) \\<Longrightarrow> thesis\"\n  assumes \"\\<And>y. y \\<in> set (filter_min xs) \\<Longrightarrow> x \\<notin> set (filter_min xs) \\<Longrightarrow> rel y x \\<Longrightarrow> thesis\"\n  shows thesis", "lemma filter_min_minimal:\n  assumes \"transp rel\" and \"x \\<in> set (filter_min xs)\" and \"y \\<in> set (filter_min xs)\" and \"rel x y\"\n  shows \"x = y\"", "lemma filter_min_distinct:\n  assumes \"reflp rel\"\n  shows \"distinct (filter_min xs)\"", "lemma filter_min_append_subset: \"set (filter_min_append xs ys) \\<subseteq> set xs \\<union> set ys\"", "lemma filter_min_append_cases:\n  assumes \"transp rel\" and \"x \\<in> set xs \\<union> set ys\"\n  assumes \"x \\<in> set (filter_min_append xs ys) \\<Longrightarrow> thesis\"\n  assumes \"\\<And>y. y \\<in> set (filter_min_append xs ys) \\<Longrightarrow> x \\<notin> set (filter_min_append xs ys) \\<Longrightarrow> rel y x \\<Longrightarrow> thesis\"\n  shows thesis", "lemma filter_min_append_minimal:\n  assumes \"\\<And>x' y'. x' \\<in> set xs \\<Longrightarrow> y' \\<in> set xs \\<Longrightarrow> rel x' y' \\<Longrightarrow> x' = y'\"\n    and \"\\<And>x' y'. x' \\<in> set ys \\<Longrightarrow> y' \\<in> set ys \\<Longrightarrow> rel x' y' \\<Longrightarrow> x' = y'\"\n    and \"x \\<in> set (filter_min_append xs ys)\" and \"y \\<in> set (filter_min_append xs ys)\" and \"rel x y\"\n  shows \"x = y\"", "lemma filter_min_append_distinct:\n  assumes \"reflp rel\" and \"distinct xs\" and \"distinct ys\"\n  shows \"distinct (filter_min_append xs ys)\""], "translations": [["", "lemma distinct_reorder: \"distinct (xs @ (y # ys)) = distinct (y # (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs @ y # ys) = distinct (y # xs @ ys)", "by auto"], ["", "lemma set_reorder: \"set (xs @ (y # ys)) = set (y # (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs @ y # ys) = set (y # xs @ ys)", "by simp"], ["", "lemma distinctI:\n  assumes \"\\<And>i j. i < j \\<Longrightarrow> i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> xs ! i \\<noteq> xs ! j\"\n  shows \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?i < length xs; ?j < length xs\\<rbrakk>\n  \\<Longrightarrow> xs ! ?i \\<noteq> xs ! ?j\n\ngoal (1 subgoal):\n 1. distinct xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; i < length []; j < length []\\<rbrakk>\n        \\<Longrightarrow> [] ! i \\<noteq> [] ! j) \\<Longrightarrow>\n    distinct []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n                    \\<Longrightarrow> xs ! i \\<noteq>\nxs ! j) \\<Longrightarrow>\n                distinct xs;\n        \\<And>i j.\n           \\<lbrakk>i < j; i < length (a # xs); j < length (a # xs)\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i \\<noteq> (a # xs) ! j\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?i < length []; ?j < length []\\<rbrakk>\n  \\<Longrightarrow> [] ! ?i \\<noteq> [] ! ?j\n\ngoal (2 subgoals):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; i < length []; j < length []\\<rbrakk>\n        \\<Longrightarrow> [] ! i \\<noteq> [] ! j) \\<Longrightarrow>\n    distinct []\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n                    \\<Longrightarrow> xs ! i \\<noteq>\nxs ! j) \\<Longrightarrow>\n                distinct xs;\n        \\<And>i j.\n           \\<lbrakk>i < j; i < length (a # xs); j < length (a # xs)\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i \\<noteq> (a # xs) ! j\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct []", "by simp"], ["proof (state)\nthis:\n  distinct []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n                    \\<Longrightarrow> xs ! i \\<noteq>\nxs ! j) \\<Longrightarrow>\n                distinct xs;\n        \\<And>i j.\n           \\<lbrakk>i < j; i < length (a # xs); j < length (a # xs)\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i \\<noteq> (a # xs) ! j\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n                    \\<Longrightarrow> xs ! i \\<noteq>\nxs ! j) \\<Longrightarrow>\n                distinct xs;\n        \\<And>i j.\n           \\<lbrakk>i < j; i < length (a # xs); j < length (a # xs)\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i \\<noteq> (a # xs) ! j\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  (\\<And>i j.\n      \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n      \\<Longrightarrow> xs ! i \\<noteq> xs ! j) \\<Longrightarrow>\n  distinct xs\n  \\<lbrakk>?i < ?j; ?i < length (x # xs); ?j < length (x # xs)\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! ?i \\<noteq> (x # xs) ! ?j\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>i j.\n                    \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n                    \\<Longrightarrow> xs ! i \\<noteq>\nxs ! j) \\<Longrightarrow>\n                distinct xs;\n        \\<And>i j.\n           \\<lbrakk>i < j; i < length (a # xs); j < length (a # xs)\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! i \\<noteq> (a # xs) ! j\\<rbrakk>\n       \\<Longrightarrow> distinct (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (x # xs)", "proof (simp, intro conjI, rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> False\n 2. distinct xs", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> False\n 2. distinct xs", "then"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain j where \"j < length xs\" and \"x = xs ! j\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length xs; x = xs ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  j < length xs\n  x = xs ! j\n\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> False\n 2. distinct xs", "hence \"Suc j < length (x # xs)\""], ["proof (prove)\nusing this:\n  j < length xs\n  x = xs ! j\n\ngoal (1 subgoal):\n 1. Suc j < length (x # xs)", "by simp"], ["proof (state)\nthis:\n  Suc j < length (x # xs)\n\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> False\n 2. distinct xs", "have \"(x # xs) ! 0 \\<noteq> (x # xs) ! (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs) ! 0 \\<noteq> (x # xs) ! Suc j", "by (rule Cons(2), simp, simp, fact)"], ["proof (state)\nthis:\n  (x # xs) ! 0 \\<noteq> (x # xs) ! Suc j\n\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> False\n 2. distinct xs", "thus False"], ["proof (prove)\nusing this:\n  (x # xs) ! 0 \\<noteq> (x # xs) ! Suc j\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>x = xs ! j\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. distinct xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct xs", "show \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "proof (rule Cons(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<noteq> xs ! j", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<noteq> xs ! j", "assume \"i < j\" and \"i < length xs\" and \"j < length xs\""], ["proof (state)\nthis:\n  i < j\n  i < length xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<noteq> xs ! j", "hence \"Suc i < Suc j\" and \"Suc i < length (x # xs)\" and \"Suc j < length (x # xs)\""], ["proof (prove)\nusing this:\n  i < j\n  i < length xs\n  j < length xs\n\ngoal (1 subgoal):\n 1. Suc i < Suc j &&& Suc i < length (x # xs) &&& Suc j < length (x # xs)", "by simp_all"], ["proof (state)\nthis:\n  Suc i < Suc j\n  Suc i < length (x # xs)\n  Suc j < length (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<noteq> xs ! j", "hence \"(x # xs) ! (Suc i) \\<noteq> (x # xs) ! (Suc j)\""], ["proof (prove)\nusing this:\n  Suc i < Suc j\n  Suc i < length (x # xs)\n  Suc j < length (x # xs)\n\ngoal (1 subgoal):\n 1. (x # xs) ! Suc i \\<noteq> (x # xs) ! Suc j", "by (rule Cons(2))"], ["proof (state)\nthis:\n  (x # xs) ! Suc i \\<noteq> (x # xs) ! Suc j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length xs; j < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! i \\<noteq> xs ! j", "thus \"xs ! i \\<noteq> xs ! j\""], ["proof (prove)\nusing this:\n  (x # xs) ! Suc i \\<noteq> (x # xs) ! Suc j\n\ngoal (1 subgoal):\n 1. xs ! i \\<noteq> xs ! j", "by simp"], ["proof (state)\nthis:\n  xs ! i \\<noteq> xs ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_nth_pairE:\n  assumes \"i < j\" and \"i < length (filter P xs)\" and \"j < length (filter P xs)\"\n  obtains i' j' where \"i' < j'\" and \"i' < length xs\" and \"j' < length xs\"\n    and \"(filter P xs) ! i = xs ! i'\" and \"(filter P xs) ! j = xs ! j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        \\<lbrakk>i' < j'; i' < length xs; j' < length xs;\n         filter P xs ! i = xs ! i'; filter P xs ! j = xs ! j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  i < j\n  i < length (filter P xs)\n  j < length (filter P xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        \\<lbrakk>i' < j'; i' < length xs; j' < length xs;\n         filter P xs ! i = xs ! i'; filter P xs ! j = xs ! j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct xs arbitrary: i j thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j thesis.\n       \\<lbrakk>\\<And>i' j'.\n                   \\<lbrakk>i' < j'; i' < length []; j' < length [];\n                    filter P [] ! i = [] ! i';\n                    filter P [] ! j = [] ! j'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        i < j; i < length (filter P []); j < length (filter P [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a xs i j thesis.\n       \\<lbrakk>\\<And>i j thesis.\n                   \\<lbrakk>\\<And>i' j'.\n                               \\<lbrakk>i' < j'; i' < length xs;\n                                j' < length xs; filter P xs ! i = xs ! i';\n                                filter P xs ! j = xs ! j'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < j; i < length (filter P xs);\n                    j < length (filter P xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i' j'.\n           \\<lbrakk>i' < j'; i' < length (a # xs); j' < length (a # xs);\n            filter P (a # xs) ! i = (a # xs) ! i';\n            filter P (a # xs) ! j = (a # xs) ! j'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < j; i < length (filter P (a # xs));\n        j < length (filter P (a # xs))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?i' < ?j'; ?i' < length []; ?j' < length [];\n   filter P [] ! i = [] ! ?i'; filter P [] ! j = [] ! ?j'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  i < j\n  i < length (filter P [])\n  j < length (filter P [])\n\ngoal (2 subgoals):\n 1. \\<And>i j thesis.\n       \\<lbrakk>\\<And>i' j'.\n                   \\<lbrakk>i' < j'; i' < length []; j' < length [];\n                    filter P [] ! i = [] ! i';\n                    filter P [] ! j = [] ! j'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        i < j; i < length (filter P []); j < length (filter P [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a xs i j thesis.\n       \\<lbrakk>\\<And>i j thesis.\n                   \\<lbrakk>\\<And>i' j'.\n                               \\<lbrakk>i' < j'; i' < length xs;\n                                j' < length xs; filter P xs ! i = xs ! i';\n                                filter P xs ! j = xs ! j'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < j; i < length (filter P xs);\n                    j < length (filter P xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i' j'.\n           \\<lbrakk>i' < j'; i' < length (a # xs); j' < length (a # xs);\n            filter P (a # xs) ! i = (a # xs) ! i';\n            filter P (a # xs) ! j = (a # xs) ! j'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < j; i < length (filter P (a # xs));\n        j < length (filter P (a # xs))\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Nil(3)"], ["proof (chain)\npicking this:\n  i < length (filter P [])", "show ?case"], ["proof (prove)\nusing this:\n  i < length (filter P [])\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a xs i j thesis.\n       \\<lbrakk>\\<And>i j thesis.\n                   \\<lbrakk>\\<And>i' j'.\n                               \\<lbrakk>i' < j'; i' < length xs;\n                                j' < length xs; filter P xs ! i = xs ! i';\n                                filter P xs ! j = xs ! j'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < j; i < length (filter P xs);\n                    j < length (filter P xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i' j'.\n           \\<lbrakk>i' < j'; i' < length (a # xs); j' < length (a # xs);\n            filter P (a # xs) ! i = (a # xs) ! i';\n            filter P (a # xs) ! j = (a # xs) ! j'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < j; i < length (filter P (a # xs));\n        j < length (filter P (a # xs))\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i j thesis.\n       \\<lbrakk>\\<And>i j thesis.\n                   \\<lbrakk>\\<And>i' j'.\n                               \\<lbrakk>i' < j'; i' < length xs;\n                                j' < length xs; filter P xs ! i = xs ! i';\n                                filter P xs ! j = xs ! j'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < j; i < length (filter P xs);\n                    j < length (filter P xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i' j'.\n           \\<lbrakk>i' < j'; i' < length (a # xs); j' < length (a # xs);\n            filter P (a # xs) ! i = (a # xs) ! i';\n            filter P (a # xs) ! j = (a # xs) ! j'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < j; i < length (filter P (a # xs));\n        j < length (filter P (a # xs))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i' j'.\n              \\<lbrakk>i' < j'; i' < length xs; j' < length xs;\n               filter P xs ! ?i = xs ! i';\n               filter P xs ! ?j = xs ! j'\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   ?i < ?j; ?i < length (filter P xs); ?j < length (filter P xs)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?i' < ?j'; ?i' < length (x # xs); ?j' < length (x # xs);\n   filter P (x # xs) ! i = (x # xs) ! ?i';\n   filter P (x # xs) ! j = (x # xs) ! ?j'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  i < j\n  i < length (filter P (x # xs))\n  j < length (filter P (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs i j thesis.\n       \\<lbrakk>\\<And>i j thesis.\n                   \\<lbrakk>\\<And>i' j'.\n                               \\<lbrakk>i' < j'; i' < length xs;\n                                j' < length xs; filter P xs ! i = xs ! i';\n                                filter P xs ! j = xs ! j'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < j; i < length (filter P xs);\n                    j < length (filter P xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i' j'.\n           \\<lbrakk>i' < j'; i' < length (a # xs); j' < length (a # xs);\n            filter P (a # xs) ! i = (a # xs) ! i';\n            filter P (a # xs) ! j = (a # xs) ! j'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < j; i < length (filter P (a # xs));\n        j < length (filter P (a # xs))\\<rbrakk>\n       \\<Longrightarrow> thesis", "let ?ys = \"filter P (x # xs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i j thesis.\n       \\<lbrakk>\\<And>i j thesis.\n                   \\<lbrakk>\\<And>i' j'.\n                               \\<lbrakk>i' < j'; i' < length xs;\n                                j' < length xs; filter P xs ! i = xs ! i';\n                                filter P xs ! j = xs ! j'\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    i < j; i < length (filter P xs);\n                    j < length (filter P xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>i' j'.\n           \\<lbrakk>i' < j'; i' < length (a # xs); j' < length (a # xs);\n            filter P (a # xs) ! i = (a # xs) ! i';\n            filter P (a # xs) ! j = (a # xs) ! j'\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        i < j; i < length (filter P (a # xs));\n        j < length (filter P (a # xs))\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"P x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> thesis\n 2. \\<not> P x \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  P x\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> thesis\n 2. \\<not> P x \\<Longrightarrow> thesis", "hence *: \"?ys = x # (filter P xs)\""], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. filter P (x # xs) = x # filter P xs", "by simp"], ["proof (state)\nthis:\n  filter P (x # xs) = x # filter P xs\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> thesis\n 2. \\<not> P x \\<Longrightarrow> thesis", "from \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j", "obtain j0 where j: \"j = Suc j0\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. (\\<And>j0. j = Suc j0 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using lessE"], ["proof (prove)\nusing this:\n  i < j\n  \\<lbrakk>?i < ?k; ?k = Suc ?i \\<Longrightarrow> ?P;\n   \\<And>j.\n      \\<lbrakk>?i < j; ?k = Suc j\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>j0. j = Suc j0 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  j = Suc j0\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> thesis\n 2. \\<not> P x \\<Longrightarrow> thesis", "have len_ys: \"length ?ys = Suc (length (filter P xs))\" and ys_j: \"?ys ! j = (filter P xs) ! j0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P (x # xs)) = Suc (length (filter P xs)) &&&\n    filter P (x # xs) ! j = filter P xs ! j0", "by (simp only: * length_Cons, simp only: j * nth_Cons_Suc)"], ["proof (state)\nthis:\n  length (filter P (x # xs)) = Suc (length (filter P xs))\n  filter P (x # xs) ! j = filter P xs ! j0\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> thesis\n 2. \\<not> P x \\<Longrightarrow> thesis", "from Cons(5)"], ["proof (chain)\npicking this:\n  j < length (filter P (x # xs))", "have \"j0 < length (filter P xs)\""], ["proof (prove)\nusing this:\n  j < length (filter P (x # xs))\n\ngoal (1 subgoal):\n 1. j0 < length (filter P xs)", "unfolding len_ys j"], ["proof (prove)\nusing this:\n  Suc j0 < Suc (length (filter P xs))\n\ngoal (1 subgoal):\n 1. j0 < length (filter P xs)", "by auto"], ["proof (state)\nthis:\n  j0 < length (filter P xs)\n\ngoal (2 subgoals):\n 1. P x \\<Longrightarrow> thesis\n 2. \\<not> P x \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> thesis\n 2. i \\<noteq> 0 \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> thesis\n 2. i \\<noteq> 0 \\<Longrightarrow> thesis", "from \\<open>j0 < length (filter P xs)\\<close>"], ["proof (chain)\npicking this:\n  j0 < length (filter P xs)", "obtain j' where \"j' < length xs\" and **: \"(filter P xs) ! j0 = xs ! j'\""], ["proof (prove)\nusing this:\n  j0 < length (filter P xs)\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j' < length xs; filter P xs ! j0 = xs ! j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) in_set_conv_nth mem_Collect_eq nth_mem set_filter)"], ["proof (state)\nthis:\n  j' < length xs\n  filter P xs ! j0 = xs ! j'\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> thesis\n 2. i \\<noteq> 0 \\<Longrightarrow> thesis", "have \"0 < Suc j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Suc j'", "by simp"], ["proof (state)\nthis:\n  0 < Suc j'\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> thesis\n 2. i \\<noteq> 0 \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < Suc j'\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2), simp, simp add: \\<open>j' < length xs\\<close>, simp only: True * nth_Cons_0,\n            simp only: ys_j nth_Cons_Suc **)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "obtain i0 where i: \"i = Suc i0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i0. i = Suc i0 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using lessE"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  \\<lbrakk>?i < ?k; ?k = Suc ?i \\<Longrightarrow> ?P;\n   \\<And>j.\n      \\<lbrakk>?i < j; ?k = Suc j\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>i0. i = Suc i0 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  i = Suc i0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "have ys_i: \"?ys ! i = (filter P xs) ! i0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P (x # xs) ! i = filter P xs ! i0", "by (simp only: i * nth_Cons_Suc)"], ["proof (state)\nthis:\n  filter P (x # xs) ! i = filter P xs ! i0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "from Cons(3)"], ["proof (chain)\npicking this:\n  i < j", "have \"i0 < j0\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. i0 < j0", "by (simp add: i j)"], ["proof (state)\nthis:\n  i0 < j0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "from Cons(4)"], ["proof (chain)\npicking this:\n  i < length (filter P (x # xs))", "have \"i0 < length (filter P xs)\""], ["proof (prove)\nusing this:\n  i < length (filter P (x # xs))\n\ngoal (1 subgoal):\n 1. i0 < length (filter P xs)", "unfolding len_ys i"], ["proof (prove)\nusing this:\n  Suc i0 < Suc (length (filter P xs))\n\ngoal (1 subgoal):\n 1. i0 < length (filter P xs)", "by auto"], ["proof (state)\nthis:\n  i0 < length (filter P xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "from _ \\<open>i0 < j0\\<close> this \\<open>j0 < length (filter P xs)\\<close>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  i0 < j0\n  i0 < length (filter P xs)\n  j0 < length (filter P xs)", "obtain i' j'\n        where \"i' < j'\" and \"i' < length xs\" and \"j' < length xs\"\n          and i': \"filter P xs ! i0 = xs ! i'\" and j': \"filter P xs ! j0 = xs ! j'\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  i0 < j0\n  i0 < length (filter P xs)\n  j0 < length (filter P xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        \\<lbrakk>i' < j'; i' < length xs; j' < length xs;\n         filter P xs ! i0 = xs ! i'; filter P xs ! j0 = xs ! j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule Cons(1))"], ["proof (state)\nthis:\n  i' < j'\n  i' < length xs\n  j' < length xs\n  filter P xs ! i0 = xs ! i'\n  filter P xs ! j0 = xs ! j'\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "from \\<open>i' < j'\\<close>"], ["proof (chain)\npicking this:\n  i' < j'", "have \"Suc i' < Suc j'\""], ["proof (prove)\nusing this:\n  i' < j'\n\ngoal (1 subgoal):\n 1. Suc i' < Suc j'", "by simp"], ["proof (state)\nthis:\n  Suc i' < Suc j'\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc i' < Suc j'\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2), simp add: \\<open>i' < length xs\\<close>, simp add: \\<open>j' < length xs\\<close>,\n            simp only: ys_i nth_Cons_Suc i', simp only: ys_j nth_Cons_Suc j')"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow> thesis", "hence *: \"?ys = filter P xs\""], ["proof (prove)\nusing this:\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. filter P (x # xs) = filter P xs", "by simp"], ["proof (state)\nthis:\n  filter P (x # xs) = filter P xs\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow> thesis", "with Cons(4) Cons(5)"], ["proof (chain)\npicking this:\n  i < length (filter P (x # xs))\n  j < length (filter P (x # xs))\n  filter P (x # xs) = filter P xs", "have \"i < length (filter P xs)\" and \"j < length (filter P xs)\""], ["proof (prove)\nusing this:\n  i < length (filter P (x # xs))\n  j < length (filter P (x # xs))\n  filter P (x # xs) = filter P xs\n\ngoal (1 subgoal):\n 1. i < length (filter P xs) &&& j < length (filter P xs)", "by simp_all"], ["proof (state)\nthis:\n  i < length (filter P xs)\n  j < length (filter P xs)\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow> thesis", "with _ \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  i < j\n  i < length (filter P xs)\n  j < length (filter P xs)", "obtain i' j' where \"i' < j'\" and \"i' < length xs\" and \"j' < length xs\"\n      and i': \"filter P xs ! i = xs ! i'\" and j': \"filter P xs ! j = xs ! j'\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  i < j\n  i < length (filter P xs)\n  j < length (filter P xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        \\<lbrakk>i' < j'; i' < length xs; j' < length xs;\n         filter P xs ! i = xs ! i'; filter P xs ! j = xs ! j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule Cons(1))"], ["proof (state)\nthis:\n  i' < j'\n  i' < length xs\n  j' < length xs\n  filter P xs ! i = xs ! i'\n  filter P xs ! j = xs ! j'\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow> thesis", "from \\<open>i' < j'\\<close>"], ["proof (chain)\npicking this:\n  i' < j'", "have \"Suc i' < Suc j'\""], ["proof (prove)\nusing this:\n  i' < j'\n\ngoal (1 subgoal):\n 1. Suc i' < Suc j'", "by simp"], ["proof (state)\nthis:\n  Suc i' < Suc j'\n\ngoal (1 subgoal):\n 1. \\<not> P x \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc i' < Suc j'\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2), simp add: \\<open>i' < length xs\\<close>, simp add: \\<open>j' < length xs\\<close>,\n          simp only: * nth_Cons_Suc i', simp only: * nth_Cons_Suc j')"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_filterI:\n  assumes \"\\<And>i j. i < j \\<Longrightarrow> i < length xs \\<Longrightarrow> j < length xs \\<Longrightarrow> P (xs ! i) \\<Longrightarrow> P (xs ! j) \\<Longrightarrow> xs ! i \\<noteq> xs ! j\"\n  shows \"distinct (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (filter P xs)", "proof (rule distinctI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length (filter P xs);\n        j < length (filter P xs)\\<rbrakk>\n       \\<Longrightarrow> filter P xs ! i \\<noteq> filter P xs ! j", "fix i j::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length (filter P xs);\n        j < length (filter P xs)\\<rbrakk>\n       \\<Longrightarrow> filter P xs ! i \\<noteq> filter P xs ! j", "assume \"i < j\" and \"i < length (filter P xs)\" and \"j < length (filter P xs)\""], ["proof (state)\nthis:\n  i < j\n  i < length (filter P xs)\n  j < length (filter P xs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length (filter P xs);\n        j < length (filter P xs)\\<rbrakk>\n       \\<Longrightarrow> filter P xs ! i \\<noteq> filter P xs ! j", "then"], ["proof (chain)\npicking this:\n  i < j\n  i < length (filter P xs)\n  j < length (filter P xs)", "obtain i' j' where \"i' < j'\" and \"i' < length xs\" and \"j' < length xs\"\n    and i: \"(filter P xs) ! i = xs ! i'\" and j: \"(filter P xs) ! j = xs ! j'\""], ["proof (prove)\nusing this:\n  i < j\n  i < length (filter P xs)\n  j < length (filter P xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        \\<lbrakk>i' < j'; i' < length xs; j' < length xs;\n         filter P xs ! i = xs ! i'; filter P xs ! j = xs ! j'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule filter_nth_pairE)"], ["proof (state)\nthis:\n  i' < j'\n  i' < length xs\n  j' < length xs\n  filter P xs ! i = xs ! i'\n  filter P xs ! j = xs ! j'\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; i < length (filter P xs);\n        j < length (filter P xs)\\<rbrakk>\n       \\<Longrightarrow> filter P xs ! i \\<noteq> filter P xs ! j", "from \\<open>i' < j'\\<close> \\<open>i' < length xs\\<close> \\<open>j' < length xs\\<close>"], ["proof (chain)\npicking this:\n  i' < j'\n  i' < length xs\n  j' < length xs", "show \"(filter P xs) ! i \\<noteq> (filter P xs) ! j\""], ["proof (prove)\nusing this:\n  i' < j'\n  i' < length xs\n  j' < length xs\n\ngoal (1 subgoal):\n 1. filter P xs ! i \\<noteq> filter P xs ! j", "unfolding i j"], ["proof (prove)\nusing this:\n  i' < j'\n  i' < length xs\n  j' < length xs\n\ngoal (1 subgoal):\n 1. xs ! i' \\<noteq> xs ! j'", "proof (rule assms)"], ["proof (state)\ngoal (2 subgoals):\n 1. P (xs ! i')\n 2. P (xs ! j')", "from \\<open>i < length (filter P xs)\\<close>"], ["proof (chain)\npicking this:\n  i < length (filter P xs)", "show \"P (xs ! i')\""], ["proof (prove)\nusing this:\n  i < length (filter P xs)\n\ngoal (1 subgoal):\n 1. P (xs ! i')", "unfolding i[symmetric]"], ["proof (prove)\nusing this:\n  i < length (filter P xs)\n\ngoal (1 subgoal):\n 1. P (filter P xs ! i)", "using nth_mem"], ["proof (prove)\nusing this:\n  i < length (filter P xs)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. P (filter P xs ! i)", "by force"], ["proof (state)\nthis:\n  P (xs ! i')\n\ngoal (1 subgoal):\n 1. P (xs ! j')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P (xs ! j')", "from \\<open>j < length (filter P xs)\\<close>"], ["proof (chain)\npicking this:\n  j < length (filter P xs)", "show \"P (xs ! j')\""], ["proof (prove)\nusing this:\n  j < length (filter P xs)\n\ngoal (1 subgoal):\n 1. P (xs ! j')", "unfolding j[symmetric]"], ["proof (prove)\nusing this:\n  j < length (filter P xs)\n\ngoal (1 subgoal):\n 1. P (filter P xs ! j)", "using nth_mem"], ["proof (prove)\nusing this:\n  j < length (filter P xs)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. P (filter P xs ! j)", "by force"], ["proof (state)\nthis:\n  P (xs ! j')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter P xs ! i \\<noteq> filter P xs ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_zip_map: \"set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` set xs", "have \"{(map f xs ! i, map g xs ! i) |i. i < length xs} = {(f (xs ! i), g (xs ! i)) |i. i < length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(map f xs ! i, map g xs ! i) |i. i < length xs} =\n    {(f (xs ! i), g (xs ! i)) |i. i < length xs}", "proof (rule Collect_eqI, rule, elim exE conjE, intro exI conjI, simp add: map_nth, assumption,\n      elim exE conjE, intro exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x = (f (xs ! i), g (xs ! i)); i < length xs\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (map f xs ! ?i14 x i, map g xs ! ?i14 x i) \\<and>\n                         ?i14 x i < length xs", "fix x i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x = (f (xs ! i), g (xs ! i)); i < length xs\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (map f xs ! ?i14 x i, map g xs ! ?i14 x i) \\<and>\n                         ?i14 x i < length xs", "assume \"x = (f (xs ! i), g (xs ! i))\" and \"i < length xs\""], ["proof (state)\nthis:\n  x = (f (xs ! i), g (xs ! i))\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>x = (f (xs ! i), g (xs ! i)); i < length xs\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (map f xs ! ?i14 x i, map g xs ! ?i14 x i) \\<and>\n                         ?i14 x i < length xs", "thus \"x = (map f xs ! i, map g xs ! i) \\<and> i < length xs\""], ["proof (prove)\nusing this:\n  x = (f (xs ! i), g (xs ! i))\n  i < length xs\n\ngoal (1 subgoal):\n 1. x = (map f xs ! i, map g xs ! i) \\<and> i < length xs", "by (simp add: map_nth)"], ["proof (state)\nthis:\n  x = (map f xs ! i, map g xs ! i) \\<and> i < length xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(map f xs ! i, map g xs ! i) |i. i < length xs} =\n  {(f (xs ! i), g (xs ! i)) |i. i < length xs}\n\ngoal (1 subgoal):\n 1. set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` set xs", "also"], ["proof (state)\nthis:\n  {(map f xs ! i, map g xs ! i) |i. i < length xs} =\n  {(f (xs ! i), g (xs ! i)) |i. i < length xs}\n\ngoal (1 subgoal):\n 1. set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` set xs", "have \"... = (\\<lambda>x. (f x, g x)) ` {xs ! i | i. i < length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(f (xs ! i), g (xs ! i)) |i. i < length xs} =\n    (\\<lambda>x. (f x, g x)) ` {xs ! i |i. i < length xs}", "by blast"], ["proof (state)\nthis:\n  {(f (xs ! i), g (xs ! i)) |i. i < length xs} =\n  (\\<lambda>x. (f x, g x)) ` {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` set xs", "finally"], ["proof (chain)\npicking this:\n  {(map f xs ! i, map g xs ! i) |i. i < length xs} =\n  (\\<lambda>x. (f x, g x)) ` {xs ! i |i. i < length xs}", "show \"set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` (set xs)\""], ["proof (prove)\nusing this:\n  {(map f xs ! i, map g xs ! i) |i. i < length xs} =\n  (\\<lambda>x. (f x, g x)) ` {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` set xs", "by (simp add: set_zip set_conv_nth[symmetric])"], ["proof (state)\nthis:\n  set (zip (map f xs) (map g xs)) = (\\<lambda>x. (f x, g x)) ` set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_zip_map1: \"set (zip (map f xs) xs) = (\\<lambda>x. (f x, x)) ` (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (zip (map f xs) xs) = (\\<lambda>x. (f x, x)) ` set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (zip (map f xs) xs) = (\\<lambda>x. (f x, x)) ` set xs", "have \"set (zip (map f xs) (map id xs)) = (\\<lambda>x. (f x, id x)) ` (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (zip (map f xs) (map id xs)) = (\\<lambda>x. (f x, id x)) ` set xs", "by (rule set_zip_map)"], ["proof (state)\nthis:\n  set (zip (map f xs) (map id xs)) = (\\<lambda>x. (f x, id x)) ` set xs\n\ngoal (1 subgoal):\n 1. set (zip (map f xs) xs) = (\\<lambda>x. (f x, x)) ` set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (zip (map f xs) (map id xs)) = (\\<lambda>x. (f x, id x)) ` set xs\n\ngoal (1 subgoal):\n 1. set (zip (map f xs) xs) = (\\<lambda>x. (f x, x)) ` set xs", "by simp"], ["proof (state)\nthis:\n  set (zip (map f xs) xs) = (\\<lambda>x. (f x, x)) ` set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_zip_map2: \"set (zip xs (map f xs)) = (\\<lambda>x. (x, f x)) ` (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (zip xs (map f xs)) = (\\<lambda>x. (x, f x)) ` set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (zip xs (map f xs)) = (\\<lambda>x. (x, f x)) ` set xs", "have \"set (zip (map id xs) (map f xs)) = (\\<lambda>x. (id x, f x)) ` (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (zip (map id xs) (map f xs)) = (\\<lambda>x. (id x, f x)) ` set xs", "by (rule set_zip_map)"], ["proof (state)\nthis:\n  set (zip (map id xs) (map f xs)) = (\\<lambda>x. (id x, f x)) ` set xs\n\ngoal (1 subgoal):\n 1. set (zip xs (map f xs)) = (\\<lambda>x. (x, f x)) ` set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (zip (map id xs) (map f xs)) = (\\<lambda>x. (id x, f x)) ` set xs\n\ngoal (1 subgoal):\n 1. set (zip xs (map f xs)) = (\\<lambda>x. (x, f x)) ` set xs", "by simp"], ["proof (state)\nthis:\n  set (zip xs (map f xs)) = (\\<lambda>x. (x, f x)) ` set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UN_upt: \"(\\<Union>i\\<in>{0..<length xs}. f (xs ! i)) = (\\<Union>x\\<in>set xs. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>{0..<length xs}. f (xs ! i)) = \\<Union> (f ` set xs)", "by (metis image_image map_nth set_map set_upt)"], ["", "lemma sum_list_zeroI':\n  assumes \"\\<And>i. i < length xs \\<Longrightarrow> xs ! i = 0\"\n  shows \"sum_list xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "proof (rule sum_list_zeroI, rule, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x = (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x = (0::'a)", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain i where \"i < length xs\" and \"x = xs ! i\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; x = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length xs\n  x = xs ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x = (0::'a)", "from this(1)"], ["proof (chain)\npicking this:\n  i < length xs", "show \"x = 0\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "unfolding \\<open>x = xs ! i\\<close>"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs ! i = (0::'a)", "by (rule assms)"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_map2_plus:\n  assumes \"length xs = length ys\"\n  shows \"sum_list (map2 (+) xs ys) = sum_list xs + sum_list (ys::'a::comm_monoid_add list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys", "proof (induct rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (map2 (+) [] []) = sum_list [] + sum_list []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys\\<rbrakk>\n       \\<Longrightarrow> sum_list (map2 (+) (x # xs) (y # ys)) =\n                         sum_list (x # xs) + sum_list (y # ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum_list (map2 (+) [] []) = sum_list [] + sum_list []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys\\<rbrakk>\n       \\<Longrightarrow> sum_list (map2 (+) (x # xs) (y # ys)) =\n                         sum_list (x # xs) + sum_list (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (+) [] []) = sum_list [] + sum_list []", "by simp"], ["proof (state)\nthis:\n  sum_list (map2 (+) [] []) = sum_list [] + sum_list []\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys\\<rbrakk>\n       \\<Longrightarrow> sum_list (map2 (+) (x # xs) (y # ys)) =\n                         sum_list (x # xs) + sum_list (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys\\<rbrakk>\n       \\<Longrightarrow> sum_list (map2 (+) (x # xs) (y # ys)) =\n                         sum_list (x # xs) + sum_list (y # ys)", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        sum_list (map2 (+) xs ys) = sum_list xs + sum_list ys\\<rbrakk>\n       \\<Longrightarrow> sum_list (map2 (+) (x # xs) (y # ys)) =\n                         sum_list (x # xs) + sum_list (y # ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (+) (x # xs) (y # ys)) =\n    sum_list (x # xs) + sum_list (y # ys)", "by (simp add: Cons(2) ac_simps)"], ["proof (state)\nthis:\n  sum_list (map2 (+) (x # xs) (y # ys)) =\n  sum_list (x # xs) + sum_list (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_eq_nthI:\n  assumes \"i < length xs\" and \"\\<And>j. j < length xs \\<Longrightarrow> j \\<noteq> i \\<Longrightarrow> xs ! j = 0\"\n  shows \"sum_list xs = xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = xs ! i", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n  \\<lbrakk>?j < length xs; ?j \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> xs ! ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list xs = xs ! i", "proof (induct xs arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length [];\n        \\<And>j.\n           \\<lbrakk>j < length []; j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> [] ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] = [] ! i\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs;\n                    \\<And>j.\n                       \\<lbrakk>j < length xs; j \\<noteq> i\\<rbrakk>\n                       \\<Longrightarrow> xs ! j = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> sum_list xs = xs ! i;\n        i < length (a # xs);\n        \\<And>j.\n           \\<lbrakk>j < length (a # xs); j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # xs) = (a # xs) ! i", "case Nil"], ["proof (state)\nthis:\n  i < length []\n  \\<lbrakk>?j < length []; ?j \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> [] ! ?j = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length [];\n        \\<And>j.\n           \\<lbrakk>j < length []; j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> [] ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list [] = [] ! i\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs;\n                    \\<And>j.\n                       \\<lbrakk>j < length xs; j \\<noteq> i\\<rbrakk>\n                       \\<Longrightarrow> xs ! j = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> sum_list xs = xs ! i;\n        i < length (a # xs);\n        \\<And>j.\n           \\<lbrakk>j < length (a # xs); j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # xs) = (a # xs) ! i", "from Nil(1)"], ["proof (chain)\npicking this:\n  i < length []", "show ?case"], ["proof (prove)\nusing this:\n  i < length []\n\ngoal (1 subgoal):\n 1. sum_list [] = [] ! i", "by simp"], ["proof (state)\nthis:\n  sum_list [] = [] ! i\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs;\n                    \\<And>j.\n                       \\<lbrakk>j < length xs; j \\<noteq> i\\<rbrakk>\n                       \\<Longrightarrow> xs ! j = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> sum_list xs = xs ! i;\n        i < length (a # xs);\n        \\<And>j.\n           \\<lbrakk>j < length (a # xs); j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # xs) = (a # xs) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs;\n                    \\<And>j.\n                       \\<lbrakk>j < length xs; j \\<noteq> i\\<rbrakk>\n                       \\<Longrightarrow> xs ! j = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> sum_list xs = xs ! i;\n        i < length (a # xs);\n        \\<And>j.\n           \\<lbrakk>j < length (a # xs); j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # xs) = (a # xs) ! i", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs;\n   \\<And>j.\n      \\<lbrakk>j < length xs; j \\<noteq> ?i\\<rbrakk>\n      \\<Longrightarrow> xs ! j = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> sum_list xs = xs ! ?i\n  i < length (x # xs)\n  \\<lbrakk>?j < length (x # xs); ?j \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> (x # xs) ! ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs;\n                    \\<And>j.\n                       \\<lbrakk>j < length xs; j \\<noteq> i\\<rbrakk>\n                       \\<Longrightarrow> xs ! j = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> sum_list xs = xs ! i;\n        i < length (a # xs);\n        \\<And>j.\n           \\<lbrakk>j < length (a # xs); j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # xs) = (a # xs) ! i", "have *: \"xs ! j = 0\" if \"j < length xs\" and \"Suc j \\<noteq> i\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! j = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs ! j = (0::'a)", "have \"xs ! j = (x # xs) ! (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! j = (x # xs) ! Suc j", "by simp"], ["proof (state)\nthis:\n  xs ! j = (x # xs) ! Suc j\n\ngoal (1 subgoal):\n 1. xs ! j = (0::'a)", "also"], ["proof (state)\nthis:\n  xs ! j = (x # xs) ! Suc j\n\ngoal (1 subgoal):\n 1. xs ! j = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs) ! Suc j = (0::'a)", "by (rule Cons(3), simp add: \\<open>j < length xs\\<close>, fact)"], ["proof (state)\nthis:\n  (x # xs) ! Suc j = (0::'a)\n\ngoal (1 subgoal):\n 1. xs ! j = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  xs ! j = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs ! j = (0::'a)\n\ngoal (1 subgoal):\n 1. xs ! j = (0::'a)", "."], ["proof (state)\nthis:\n  xs ! j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?j < length xs; Suc ?j \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> xs ! ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>i < length xs;\n                    \\<And>j.\n                       \\<lbrakk>j < length xs; j \\<noteq> i\\<rbrakk>\n                       \\<Longrightarrow> xs ! j = (0::'a)\\<rbrakk>\n                   \\<Longrightarrow> sum_list xs = xs ! i;\n        i < length (a # xs);\n        \\<And>j.\n           \\<lbrakk>j < length (a # xs); j \\<noteq> i\\<rbrakk>\n           \\<Longrightarrow> (a # xs) ! j = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> sum_list (a # xs) = (a # xs) ! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (x # xs) = (x # xs) ! i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "have \"sum_list xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list xs = (0::'a)", "by (rule sum_list_zeroI', erule *, simp add: 0)"], ["proof (state)\nthis:\n  sum_list xs = (0::'a)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "with 0"], ["proof (chain)\npicking this:\n  i = 0\n  sum_list xs = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n  sum_list xs = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list (x # xs) = (x # xs) ! i", "by simp"], ["proof (state)\nthis:\n  sum_list (x # xs) = (x # xs) ! i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "case (Suc k)"], ["proof (state)\nthis:\n  i = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "with Cons(2)"], ["proof (chain)\npicking this:\n  i < length (x # xs)\n  i = Suc k", "have \"k < length xs\""], ["proof (prove)\nusing this:\n  i < length (x # xs)\n  i = Suc k\n\ngoal (1 subgoal):\n 1. k < length xs", "by simp"], ["proof (state)\nthis:\n  k < length xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "hence \"sum_list xs = xs ! k\""], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. sum_list xs = xs ! k", "proof (rule Cons(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < length xs; j \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> xs ! j = (0::'a)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < length xs; j \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> xs ! j = (0::'a)", "assume \"j < length xs\""], ["proof (state)\nthis:\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < length xs; j \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> xs ! j = (0::'a)", "assume \"j \\<noteq> k\""], ["proof (state)\nthis:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < length xs; j \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> xs ! j = (0::'a)", "hence \"Suc j \\<noteq> i\""], ["proof (prove)\nusing this:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. Suc j \\<noteq> i", "by (simp add: Suc)"], ["proof (state)\nthis:\n  Suc j \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < length xs; j \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> xs ! j = (0::'a)", "with \\<open>j < length xs\\<close>"], ["proof (chain)\npicking this:\n  j < length xs\n  Suc j \\<noteq> i", "show \"xs ! j = 0\""], ["proof (prove)\nusing this:\n  j < length xs\n  Suc j \\<noteq> i\n\ngoal (1 subgoal):\n 1. xs ! j = (0::'a)", "by (rule *)"], ["proof (state)\nthis:\n  xs ! j = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list xs = xs ! k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "moreover"], ["proof (state)\nthis:\n  sum_list xs = xs ! k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "have \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = (0::'a)", "have \"x = (x # xs) ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (x # xs) ! 0", "by simp"], ["proof (state)\nthis:\n  x = (x # xs) ! 0\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "also"], ["proof (state)\nthis:\n  x = (x # xs) ! 0\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs) ! 0 = (0::'a)", "by (rule Cons(3), simp_all add: Suc)"], ["proof (state)\nthis:\n  (x # xs) ! 0 = (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  x = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "."], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow> sum_list (x # xs) = (x # xs) ! i", "ultimately"], ["proof (chain)\npicking this:\n  sum_list xs = xs ! k\n  x = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list xs = xs ! k\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. sum_list (x # xs) = (x # xs) ! i", "by (simp add: Suc)"], ["proof (state)\nthis:\n  sum_list (x # xs) = (x # xs) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (x # xs) = (x # xs) ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\\<open>max_list\\<close>\\<close>"], ["", "fun (in ord) max_list :: \"'a list \\<Rightarrow> 'a\" where\n  \"max_list (x # xs) = (case xs of [] \\<Rightarrow> x | _ \\<Rightarrow> max x (max_list xs))\""], ["", "context linorder\nbegin"], ["", "lemma max_list_Max: \"xs \\<noteq> [] \\<Longrightarrow> max_list xs = Max (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> max_list xs = Max (set xs)", "by (induct xs rule: induct_list012, auto)"], ["", "lemma max_list_ge:\n  assumes \"x \\<in> set xs\"\n  shows \"x \\<le> max_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> max_list xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> max_list xs", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. x \\<le> max_list xs", "from finite_set assms"], ["proof (chain)\npicking this:\n  finite (set ?xs)\n  x \\<in> set xs", "have \"x \\<le> Max (set xs)\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<le> Max (set xs)", "by (rule Max_ge)"], ["proof (state)\nthis:\n  x \\<le> Max (set xs)\n\ngoal (1 subgoal):\n 1. x \\<le> max_list xs", "also"], ["proof (state)\nthis:\n  x \\<le> Max (set xs)\n\ngoal (1 subgoal):\n 1. x \\<le> max_list xs", "from \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"Max (set xs) = max_list xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Max (set xs) = max_list xs", "by (rule max_list_Max[symmetric])"], ["proof (state)\nthis:\n  Max (set xs) = max_list xs\n\ngoal (1 subgoal):\n 1. x \\<le> max_list xs", "finally"], ["proof (chain)\npicking this:\n  x \\<le> max_list xs", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> max_list xs\n\ngoal (1 subgoal):\n 1. x \\<le> max_list xs", "."], ["proof (state)\nthis:\n  x \\<le> max_list xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_list_boundedI:\n  assumes \"xs \\<noteq> []\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x \\<le> a\"\n  shows \"max_list xs \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list xs \\<le> a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max_list xs \\<le> a", "from assms(1)"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"set xs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. set xs \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  set xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. max_list xs \\<le> a", "from assms(1)"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"max_list xs = Max (set xs)\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. max_list xs = Max (set xs)", "by (rule max_list_Max)"], ["proof (state)\nthis:\n  max_list xs = Max (set xs)\n\ngoal (1 subgoal):\n 1. max_list xs \\<le> a", "also"], ["proof (state)\nthis:\n  max_list xs = Max (set xs)\n\ngoal (1 subgoal):\n 1. max_list xs \\<le> a", "from finite_set \\<open>set xs \\<noteq> {}\\<close> assms(2)"], ["proof (chain)\npicking this:\n  finite (set ?xs)\n  set xs \\<noteq> {}\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> a", "have \"\\<dots> \\<le> a\""], ["proof (prove)\nusing this:\n  finite (set ?xs)\n  set xs \\<noteq> {}\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> a\n\ngoal (1 subgoal):\n 1. Max (set xs) \\<le> a", "by (rule Max.boundedI)"], ["proof (state)\nthis:\n  Max (set xs) \\<le> a\n\ngoal (1 subgoal):\n 1. max_list xs \\<le> a", "finally"], ["proof (chain)\npicking this:\n  max_list xs \\<le> a", "show ?thesis"], ["proof (prove)\nusing this:\n  max_list xs \\<le> a\n\ngoal (1 subgoal):\n 1. max_list xs \\<le> a", "."], ["proof (state)\nthis:\n  max_list xs \\<le> a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>\\<open>insort_wrt\\<close>\\<close>"], ["", "primrec insort_wrt :: \"('c \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> 'c \\<Rightarrow> 'c list \\<Rightarrow> 'c list\" where\n  \"insort_wrt _ x [] = [x]\" |\n  \"insort_wrt r x (y # ys) =\n    (if r x y then (x # y # ys) else y # (insort_wrt r x ys))\""], ["", "lemma insort_wrt_not_Nil [simp]: \"insort_wrt r x xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insort_wrt r x xs \\<noteq> []", "by (induct xs, simp_all)"], ["", "lemma length_insort_wrt [simp]: \"length (insort_wrt r x xs) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insort_wrt r x xs) = Suc (length xs)", "by (induct xs, simp_all)"], ["", "lemma set_insort_wrt [simp]: \"set (insort_wrt r x xs) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insort_wrt r x xs) = insert x (set xs)", "by (induct xs, auto)"], ["", "lemma sorted_wrt_insort_wrt_imp_sorted_wrt:\n  assumes \"sorted_wrt r (insort_wrt s x xs)\"\n  shows \"sorted_wrt r xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r xs", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt r (insort_wrt s x xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt r xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt r (insort_wrt s x []) \\<Longrightarrow> sorted_wrt r []\n 2. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r (insort_wrt s x xs) \\<Longrightarrow>\n                sorted_wrt r xs;\n        sorted_wrt r (insort_wrt s x (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (a # xs)", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt s x [])\n\ngoal (2 subgoals):\n 1. sorted_wrt r (insort_wrt s x []) \\<Longrightarrow> sorted_wrt r []\n 2. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r (insort_wrt s x xs) \\<Longrightarrow>\n                sorted_wrt r xs;\n        sorted_wrt r (insort_wrt s x (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r []", "by simp"], ["proof (state)\nthis:\n  sorted_wrt r []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r (insort_wrt s x xs) \\<Longrightarrow>\n                sorted_wrt r xs;\n        sorted_wrt r (insort_wrt s x (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r (insort_wrt s x xs) \\<Longrightarrow>\n                sorted_wrt r xs;\n        sorted_wrt r (insort_wrt s x (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt s x xs) \\<Longrightarrow> sorted_wrt r xs\n  sorted_wrt r (insort_wrt s x (a # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r (insort_wrt s x xs) \\<Longrightarrow>\n                sorted_wrt r xs;\n        sorted_wrt r (insort_wrt s x (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r (a # xs)", "proof (cases \"s x a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s x a \\<Longrightarrow> sorted_wrt r (a # xs)\n 2. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "case True"], ["proof (state)\nthis:\n  s x a\n\ngoal (2 subgoals):\n 1. s x a \\<Longrightarrow> sorted_wrt r (a # xs)\n 2. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "with Cons.prems"], ["proof (chain)\npicking this:\n  sorted_wrt r (insort_wrt s x (a # xs))\n  s x a", "have \"sorted_wrt r (x # a # xs)\""], ["proof (prove)\nusing this:\n  sorted_wrt r (insort_wrt s x (a # xs))\n  s x a\n\ngoal (1 subgoal):\n 1. sorted_wrt r (x # a # xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt r (x # a # xs)\n\ngoal (2 subgoals):\n 1. s x a \\<Longrightarrow> sorted_wrt r (a # xs)\n 2. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt r (x # a # xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt r (a # xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt r (a # xs)\n\ngoal (1 subgoal):\n 1. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "case False"], ["proof (state)\nthis:\n  \\<not> s x a\n\ngoal (1 subgoal):\n 1. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "with Cons(2)"], ["proof (chain)\npicking this:\n  sorted_wrt r (insort_wrt s x (a # xs))\n  \\<not> s x a", "have \"sorted_wrt r (a # (insort_wrt s x xs))\""], ["proof (prove)\nusing this:\n  sorted_wrt r (insort_wrt s x (a # xs))\n  \\<not> s x a\n\ngoal (1 subgoal):\n 1. sorted_wrt r (a # insort_wrt s x xs)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt r (a # insort_wrt s x xs)\n\ngoal (1 subgoal):\n 1. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "hence *: \"(\\<forall>y\\<in>set xs. r a y)\" and \"sorted_wrt r (insort_wrt s x xs)\""], ["proof (prove)\nusing this:\n  sorted_wrt r (a # insort_wrt s x xs)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs. r a y &&& sorted_wrt r (insort_wrt s x xs)", "by (simp_all)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set xs. r a y\n  sorted_wrt r (insort_wrt s x xs)\n\ngoal (1 subgoal):\n 1. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "from this(2)"], ["proof (chain)\npicking this:\n  sorted_wrt r (insort_wrt s x xs)", "have \"sorted_wrt r xs\""], ["proof (prove)\nusing this:\n  sorted_wrt r (insort_wrt s x xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt r xs", "by (rule Cons(1))"], ["proof (state)\nthis:\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. \\<not> s x a \\<Longrightarrow> sorted_wrt r (a # xs)", "with *"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set xs. r a y\n  sorted_wrt r xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set xs. r a y\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. sorted_wrt r (a # xs)", "by (simp)"], ["proof (state)\nthis:\n  sorted_wrt r (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt r (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_wrt_imp_sorted_wrt_insort_wrt:\n  assumes \"transp r\" and \"\\<And>a. r a x \\<or> r x a\" and \"sorted_wrt r xs\"\n  shows \"sorted_wrt r (insort_wrt r x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x xs)", "using assms(3)"], ["proof (prove)\nusing this:\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt r [] \\<Longrightarrow> sorted_wrt r (insort_wrt r x [])\n 2. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r xs \\<Longrightarrow>\n                sorted_wrt r (insort_wrt r x xs);\n        sorted_wrt r (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt r []\n\ngoal (2 subgoals):\n 1. sorted_wrt r [] \\<Longrightarrow> sorted_wrt r (insort_wrt r x [])\n 2. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r xs \\<Longrightarrow>\n                sorted_wrt r (insort_wrt r x xs);\n        sorted_wrt r (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x [])", "by simp"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt r x [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r xs \\<Longrightarrow>\n                sorted_wrt r (insort_wrt r x xs);\n        sorted_wrt r (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r xs \\<Longrightarrow>\n                sorted_wrt r (insort_wrt r x xs);\n        sorted_wrt r (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  sorted_wrt r xs \\<Longrightarrow> sorted_wrt r (insort_wrt r x xs)\n  sorted_wrt r (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>sorted_wrt r xs \\<Longrightarrow>\n                sorted_wrt r (insort_wrt r x xs);\n        sorted_wrt r (a # xs)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x (a # xs))", "proof (cases \"r x a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))\n 2. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "case True"], ["proof (state)\nthis:\n  r x a\n\ngoal (2 subgoals):\n 1. r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))\n 2. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "with Cons(2) assms(1)"], ["proof (chain)\npicking this:\n  sorted_wrt r (a # xs)\n  transp r\n  r x a", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_wrt r (a # xs)\n  transp r\n  r x a\n\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x (a # xs))", "by (auto dest: transpD)"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt r x (a # xs))\n\ngoal (1 subgoal):\n 1. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "case False"], ["proof (state)\nthis:\n  \\<not> r x a\n\ngoal (1 subgoal):\n 1. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "with assms(2)"], ["proof (chain)\npicking this:\n  r ?a x \\<or> r x ?a\n  \\<not> r x a", "have \"r a x\""], ["proof (prove)\nusing this:\n  r ?a x \\<or> r x ?a\n  \\<not> r x a\n\ngoal (1 subgoal):\n 1. r a x", "by blast"], ["proof (state)\nthis:\n  r a x\n\ngoal (1 subgoal):\n 1. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "from Cons(2)"], ["proof (chain)\npicking this:\n  sorted_wrt r (a # xs)", "have *: \"(\\<forall>y\\<in>set xs. r a y)\" and \"sorted_wrt r xs\""], ["proof (prove)\nusing this:\n  sorted_wrt r (a # xs)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs. r a y &&& sorted_wrt r xs", "by (simp_all)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set xs. r a y\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "from this(2)"], ["proof (chain)\npicking this:\n  sorted_wrt r xs", "have \"sorted_wrt r (insort_wrt r x xs)\""], ["proof (prove)\nusing this:\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x xs)", "by (rule Cons(1))"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt r x xs)\n\ngoal (1 subgoal):\n 1. \\<not> r x a \\<Longrightarrow> sorted_wrt r (insort_wrt r x (a # xs))", "with \\<open>r a x\\<close> *"], ["proof (chain)\npicking this:\n  r a x\n  \\<forall>y\\<in>set xs. r a y\n  sorted_wrt r (insort_wrt r x xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  r a x\n  \\<forall>y\\<in>set xs. r a y\n  sorted_wrt r (insort_wrt r x xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x (a # xs))", "by (simp add: False)"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt r x (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt r x (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary sorted_wrt_insort_wrt:\n  assumes \"transp r\" and \"\\<And>a. r a x \\<or> r x a\"\n  shows \"sorted_wrt r (insort_wrt r x xs) \\<longleftrightarrow> sorted_wrt r xs\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x xs) = sorted_wrt r xs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt r (insort_wrt r x xs) \\<Longrightarrow> sorted_wrt r xs\n 2. sorted_wrt r xs \\<Longrightarrow> sorted_wrt r (insort_wrt r x xs)", "assume ?l"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt r x xs)\n\ngoal (2 subgoals):\n 1. sorted_wrt r (insort_wrt r x xs) \\<Longrightarrow> sorted_wrt r xs\n 2. sorted_wrt r xs \\<Longrightarrow> sorted_wrt r (insort_wrt r x xs)", "then"], ["proof (chain)\npicking this:\n  sorted_wrt r (insort_wrt r x xs)", "show ?r"], ["proof (prove)\nusing this:\n  sorted_wrt r (insort_wrt r x xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt r xs", "by (rule sorted_wrt_insort_wrt_imp_sorted_wrt)"], ["proof (state)\nthis:\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. sorted_wrt r xs \\<Longrightarrow> sorted_wrt r (insort_wrt r x xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt r xs \\<Longrightarrow> sorted_wrt r (insort_wrt r x xs)", "assume ?r"], ["proof (state)\nthis:\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. sorted_wrt r xs \\<Longrightarrow> sorted_wrt r (insort_wrt r x xs)", "with assms"], ["proof (chain)\npicking this:\n  transp r\n  r ?a x \\<or> r x ?a\n  sorted_wrt r xs", "show ?l"], ["proof (prove)\nusing this:\n  transp r\n  r ?a x \\<or> r x ?a\n  sorted_wrt r xs\n\ngoal (1 subgoal):\n 1. sorted_wrt r (insort_wrt r x xs)", "by (rule sorted_wrt_imp_sorted_wrt_insort_wrt)"], ["proof (state)\nthis:\n  sorted_wrt r (insort_wrt r x xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\\<open>diff_list\\<close> and \\<open>insert_list\\<close>\\<close>"], ["", "definition diff_list :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" (infixl \"--\" 65)\n  where \"diff_list xs ys = fold removeAll ys xs\""], ["", "lemma set_diff_list: \"set (xs -- ys) = set xs - set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs -- ys) = set xs - set ys", "by (simp only: diff_list_def, induct ys arbitrary: xs, auto)"], ["", "lemma diff_list_disjoint: \"set ys \\<inter> set (xs -- ys) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<inter> set (xs -- ys) = {}", "unfolding set_diff_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<inter> (set xs - set ys) = {}", "by (rule Diff_disjoint)"], ["", "lemma subset_append_diff_cancel:\n  assumes \"set ys \\<subseteq> set xs\"\n  shows \"set (ys @ (xs -- ys)) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ys @ xs -- ys) = set xs", "by (simp only: set_append set_diff_list Un_Diff_cancel, rule Un_absorb1, fact)"], ["", "definition insert_list :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\n  where \"insert_list x xs = (if x \\<in> set xs then xs else x # xs)\""], ["", "lemma set_insert_list: \"set (insert_list x xs) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_list x xs) = insert x (set xs)", "by (auto simp add: insert_list_def)"], ["", "subsubsection \\<open>\\<open>remdups_wrt\\<close>\\<close>"], ["", "primrec remdups_wrt :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  remdups_wrt_base: \"remdups_wrt _ [] = []\" |\n  remdups_wrt_rec: \"remdups_wrt f (x # xs) = (if f x \\<in> f ` set xs then remdups_wrt f xs else x # remdups_wrt f xs)\""], ["", "lemma set_remdups_wrt: \"f ` set (remdups_wrt f xs) = f ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set (remdups_wrt f xs) = f ` set xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` set (remdups_wrt f []) = f ` set []\n 2. \\<And>a xs.\n       f ` set (remdups_wrt f xs) = f ` set xs \\<Longrightarrow>\n       f ` set (remdups_wrt f (a # xs)) = f ` set (a # xs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. f ` set (remdups_wrt f []) = f ` set []\n 2. \\<And>a xs.\n       f ` set (remdups_wrt f xs) = f ` set xs \\<Longrightarrow>\n       f ` set (remdups_wrt f (a # xs)) = f ` set (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set (remdups_wrt f []) = f ` set []", "unfolding remdups_wrt_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set [] = f ` set []", ".."], ["proof (state)\nthis:\n  f ` set (remdups_wrt f []) = f ` set []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       f ` set (remdups_wrt f xs) = f ` set xs \\<Longrightarrow>\n       f ` set (remdups_wrt f (a # xs)) = f ` set (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       f ` set (remdups_wrt f xs) = f ` set xs \\<Longrightarrow>\n       f ` set (remdups_wrt f (a # xs)) = f ` set (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  f ` set (remdups_wrt f xs) = f ` set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       f ` set (remdups_wrt f xs) = f ` set xs \\<Longrightarrow>\n       f ` set (remdups_wrt f (a # xs)) = f ` set (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set (remdups_wrt f (a # xs)) = f ` set (a # xs)", "unfolding remdups_wrt_rec"], ["proof (prove)\ngoal (1 subgoal):\n 1. f `\n    set (if f a \\<in> f ` set xs then remdups_wrt f xs\n         else a # remdups_wrt f xs) =\n    f ` set (a # xs)", "proof (simp only: split: if_splits, intro conjI, intro impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "assume \"f a \\<in> f ` set xs\""], ["proof (state)\nthis:\n  f a \\<in> f ` set xs\n\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "have \"f ` set (a # xs) = insert (f a) (f ` set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set (a # xs) = insert (f a) (f ` set xs)", "by simp"], ["proof (state)\nthis:\n  f ` set (a # xs) = insert (f a) (f ` set xs)\n\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "have \"f ` set (remdups_wrt f xs) = f ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` set (remdups_wrt f xs) = f ` set xs", "by fact"], ["proof (state)\nthis:\n  f ` set (remdups_wrt f xs) = f ` set xs\n\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "also"], ["proof (state)\nthis:\n  f ` set (remdups_wrt f xs) = f ` set xs\n\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "from \\<open>f a \\<in> f ` set xs\\<close>"], ["proof (chain)\npicking this:\n  f a \\<in> f ` set xs", "have \"... = insert (f a) (f ` set xs)\""], ["proof (prove)\nusing this:\n  f a \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. f ` set xs = insert (f a) (f ` set xs)", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  f ` set xs = insert (f a) (f ` set xs)\n\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "also"], ["proof (state)\nthis:\n  f ` set xs = insert (f a) (f ` set xs)\n\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "have \"... = f ` set (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (f a) (f ` set xs) = f ` set (a # xs)", "by simp"], ["proof (state)\nthis:\n  insert (f a) (f ` set xs) = f ` set (a # xs)\n\ngoal (2 subgoals):\n 1. f a \\<in> f ` set xs \\<Longrightarrow>\n    f ` set (remdups_wrt f xs) = f ` set (a # xs)\n 2. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "finally"], ["proof (chain)\npicking this:\n  f ` set (remdups_wrt f xs) = f ` set (a # xs)", "show \"f ` set (remdups_wrt f xs) = f ` set (a # xs)\""], ["proof (prove)\nusing this:\n  f ` set (remdups_wrt f xs) = f ` set (a # xs)\n\ngoal (1 subgoal):\n 1. f ` set (remdups_wrt f xs) = f ` set (a # xs)", "."], ["proof (state)\nthis:\n  f ` set (remdups_wrt f xs) = f ` set (a # xs)\n\ngoal (1 subgoal):\n 1. f a \\<notin> f ` set xs \\<longrightarrow>\n    f ` set (a # remdups_wrt f xs) = f ` set (a # xs)", "qed (simp add: Cons.hyps)"], ["proof (state)\nthis:\n  f ` set (remdups_wrt f (a # xs)) = f ` set (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset_remdups_wrt: \"set (remdups_wrt f xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups_wrt f xs) \\<subseteq> set xs", "by (induct xs, auto)"], ["", "lemma remdups_wrt_distinct_wrt:\n  assumes \"x \\<in> set (remdups_wrt f xs)\" and \"y \\<in> set (remdups_wrt f xs)\" and \"x \\<noteq> y\"\n  shows \"f x \\<noteq> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  x \\<in> set (remdups_wrt f xs)\n  y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set (remdups_wrt f []);\n     y \\<in> set (remdups_wrt f [])\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set (remdups_wrt f xs);\n                 y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n                \\<Longrightarrow> f x \\<noteq> f y;\n        x \\<in> set (remdups_wrt f (a # xs));\n        y \\<in> set (remdups_wrt f (a # xs))\\<rbrakk>\n       \\<Longrightarrow> f x \\<noteq> f y", "case Nil"], ["proof (state)\nthis:\n  x \\<in> set (remdups_wrt f [])\n  y \\<in> set (remdups_wrt f [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set (remdups_wrt f []);\n     y \\<in> set (remdups_wrt f [])\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set (remdups_wrt f xs);\n                 y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n                \\<Longrightarrow> f x \\<noteq> f y;\n        x \\<in> set (remdups_wrt f (a # xs));\n        y \\<in> set (remdups_wrt f (a # xs))\\<rbrakk>\n       \\<Longrightarrow> f x \\<noteq> f y", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (remdups_wrt f [])\n  y \\<in> set (remdups_wrt f [])\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "unfolding remdups_wrt_base"], ["proof (prove)\nusing this:\n  x \\<in> set []\n  y \\<in> set []\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "by simp"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set (remdups_wrt f xs);\n                 y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n                \\<Longrightarrow> f x \\<noteq> f y;\n        x \\<in> set (remdups_wrt f (a # xs));\n        y \\<in> set (remdups_wrt f (a # xs))\\<rbrakk>\n       \\<Longrightarrow> f x \\<noteq> f y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set (remdups_wrt f xs);\n                 y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n                \\<Longrightarrow> f x \\<noteq> f y;\n        x \\<in> set (remdups_wrt f (a # xs));\n        y \\<in> set (remdups_wrt f (a # xs))\\<rbrakk>\n       \\<Longrightarrow> f x \\<noteq> f y", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> set (remdups_wrt f xs);\n   y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n  \\<Longrightarrow> f x \\<noteq> f y\n  x \\<in> set (remdups_wrt f (a # xs))\n  y \\<in> set (remdups_wrt f (a # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<in> set (remdups_wrt f xs);\n                 y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n                \\<Longrightarrow> f x \\<noteq> f y;\n        x \\<in> set (remdups_wrt f (a # xs));\n        y \\<in> set (remdups_wrt f (a # xs))\\<rbrakk>\n       \\<Longrightarrow> f x \\<noteq> f y", "from Cons(2) Cons(3)"], ["proof (chain)\npicking this:\n  x \\<in> set (remdups_wrt f (a # xs))\n  y \\<in> set (remdups_wrt f (a # xs))", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set (remdups_wrt f (a # xs))\n  y \\<in> set (remdups_wrt f (a # xs))\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "unfolding remdups_wrt_rec"], ["proof (prove)\nusing this:\n  x \\<in> set (if f a \\<in> f ` set xs then remdups_wrt f xs\n               else a # remdups_wrt f xs)\n  y \\<in> set (if f a \\<in> f ` set xs then remdups_wrt f xs\n               else a # remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "proof (simp only: split: if_splits)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>f a \\<in> f ` set xs; x \\<in> set (remdups_wrt f xs); True;\n     y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 2. \\<lbrakk>f a \\<in> f ` set xs; x \\<in> set (remdups_wrt f xs);\n     \\<not> True; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 3. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "assume \"x \\<in> set (remdups_wrt f xs)\" and \"y \\<in> set (remdups_wrt f xs)\""], ["proof (state)\nthis:\n  x \\<in> set (remdups_wrt f xs)\n  y \\<in> set (remdups_wrt f xs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f a \\<in> f ` set xs; x \\<in> set (remdups_wrt f xs); True;\n     y \\<in> set (remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 2. \\<lbrakk>f a \\<in> f ` set xs; x \\<in> set (remdups_wrt f xs);\n     \\<not> True; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 3. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "thus \"f x \\<noteq> f y\""], ["proof (prove)\nusing this:\n  x \\<in> set (remdups_wrt f xs)\n  y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f a \\<in> f ` set xs; x \\<in> set (remdups_wrt f xs);\n     \\<not> True; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 2. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>f a \\<in> f ` set xs; x \\<in> set (remdups_wrt f xs);\n     \\<not> True; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 2. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "assume \"\\<not> True\""], ["proof (state)\nthis:\n  \\<not> True\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f a \\<in> f ` set xs; x \\<in> set (remdups_wrt f xs);\n     \\<not> True; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y\n 2. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "thus \"f x \\<noteq> f y\""], ["proof (prove)\nusing this:\n  \\<not> True\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "by simp"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "assume \"f a \\<notin> f ` set xs\" and xin: \"x \\<in> set (a # remdups_wrt f xs)\" and yin: \"y \\<in> set (a # remdups_wrt f xs)\""], ["proof (state)\nthis:\n  f a \\<notin> f ` set xs\n  x \\<in> set (a # remdups_wrt f xs)\n  y \\<in> set (a # remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "from yin"], ["proof (chain)\npicking this:\n  y \\<in> set (a # remdups_wrt f xs)", "have y: \"y = a \\<or> y \\<in> set (remdups_wrt f xs)\""], ["proof (prove)\nusing this:\n  y \\<in> set (a # remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. y = a \\<or> y \\<in> set (remdups_wrt f xs)", "by simp"], ["proof (state)\nthis:\n  y = a \\<or> y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "from xin"], ["proof (chain)\npicking this:\n  x \\<in> set (a # remdups_wrt f xs)", "have \"x = a \\<or> x \\<in> set (remdups_wrt f xs)\""], ["proof (prove)\nusing this:\n  x \\<in> set (a # remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. x = a \\<or> x \\<in> set (remdups_wrt f xs)", "by simp"], ["proof (state)\nthis:\n  x = a \\<or> x \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f a \\<notin> f ` set xs; x \\<in> set (a # remdups_wrt f xs);\n     \\<not> False; y \\<in> set (a # remdups_wrt f xs)\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> f y", "thus \"f x \\<noteq> f y\""], ["proof (prove)\nusing this:\n  x = a \\<or> x \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow> f x \\<noteq> f y\n 2. x \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "assume \"x = a\""], ["proof (state)\nthis:\n  x = a\n\ngoal (2 subgoals):\n 1. x = a \\<Longrightarrow> f x \\<noteq> f y\n 2. x \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "from y"], ["proof (chain)\npicking this:\n  y = a \\<or> y \\<in> set (remdups_wrt f xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<or> y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y = a \\<Longrightarrow> f x \\<noteq> f y\n 2. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "assume \"y = a\""], ["proof (state)\nthis:\n  y = a\n\ngoal (2 subgoals):\n 1. y = a \\<Longrightarrow> f x \\<noteq> f y\n 2. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  y = a", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  y = a\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "unfolding \\<open>x = a\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> y\n  y = a\n\ngoal (1 subgoal):\n 1. f a \\<noteq> f y", "by simp"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "assume \"y \\<in> set (remdups_wrt f xs)\""], ["proof (state)\nthis:\n  y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "have \"y \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set xs", "by (rule, fact, rule subset_remdups_wrt)"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "hence \"f y \\<in> f ` set xs\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. f y \\<in> f ` set xs", "by simp"], ["proof (state)\nthis:\n  f y \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "with \\<open>f a \\<notin> f ` set xs\\<close>"], ["proof (chain)\npicking this:\n  f a \\<notin> f ` set xs\n  f y \\<in> f ` set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  f a \\<notin> f ` set xs\n  f y \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "unfolding \\<open>x = a\\<close>"], ["proof (prove)\nusing this:\n  f a \\<notin> f ` set xs\n  f y \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. f a \\<noteq> f y", "by auto"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal (1 subgoal):\n 1. x \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "assume \"x \\<in> set (remdups_wrt f xs)\""], ["proof (state)\nthis:\n  x \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "from y"], ["proof (chain)\npicking this:\n  y = a \\<or> y \\<in> set (remdups_wrt f xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  y = a \\<or> y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y = a \\<Longrightarrow> f x \\<noteq> f y\n 2. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "assume \"y = a\""], ["proof (state)\nthis:\n  y = a\n\ngoal (2 subgoals):\n 1. y = a \\<Longrightarrow> f x \\<noteq> f y\n 2. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "have \"x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by (rule, fact, rule subset_remdups_wrt)"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. y = a \\<Longrightarrow> f x \\<noteq> f y\n 2. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "hence \"f x \\<in> f ` set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. f x \\<in> f ` set xs", "by simp"], ["proof (state)\nthis:\n  f x \\<in> f ` set xs\n\ngoal (2 subgoals):\n 1. y = a \\<Longrightarrow> f x \\<noteq> f y\n 2. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "with \\<open>f a \\<notin> f ` set xs\\<close>"], ["proof (chain)\npicking this:\n  f a \\<notin> f ` set xs\n  f x \\<in> f ` set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  f a \\<notin> f ` set xs\n  f x \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "unfolding \\<open>y = a\\<close>"], ["proof (prove)\nusing this:\n  f a \\<notin> f ` set xs\n  f x \\<in> f ` set xs\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f a", "by auto"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "assume \"y \\<in> set (remdups_wrt f xs)\""], ["proof (state)\nthis:\n  y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. y \\<in> set (remdups_wrt f xs) \\<Longrightarrow> f x \\<noteq> f y", "with \\<open>x \\<in> set (remdups_wrt f xs)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set (remdups_wrt f xs)\n  y \\<in> set (remdups_wrt f xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (remdups_wrt f xs)\n  y \\<in> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f x \\<noteq> f y", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x \\<noteq> f y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_remdups_wrt: \"distinct (remdups_wrt f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remdups_wrt f xs)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (remdups_wrt f [])\n 2. \\<And>a xs.\n       distinct (remdups_wrt f xs) \\<Longrightarrow>\n       distinct (remdups_wrt f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. distinct (remdups_wrt f [])\n 2. \\<And>a xs.\n       distinct (remdups_wrt f xs) \\<Longrightarrow>\n       distinct (remdups_wrt f (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remdups_wrt f [])", "unfolding remdups_wrt_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct []", "by simp"], ["proof (state)\nthis:\n  distinct (remdups_wrt f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       distinct (remdups_wrt f xs) \\<Longrightarrow>\n       distinct (remdups_wrt f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       distinct (remdups_wrt f xs) \\<Longrightarrow>\n       distinct (remdups_wrt f (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  distinct (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       distinct (remdups_wrt f xs) \\<Longrightarrow>\n       distinct (remdups_wrt f (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (remdups_wrt f (a # xs))", "unfolding remdups_wrt_rec"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (if f a \\<in> f ` set xs then remdups_wrt f xs\n      else a # remdups_wrt f xs)", "proof (split if_split, intro conjI impI, rule Cons.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. f a \\<notin> f ` set xs \\<Longrightarrow>\n    distinct (a # remdups_wrt f xs)", "assume \"f a \\<notin> f ` set xs\""], ["proof (state)\nthis:\n  f a \\<notin> f ` set xs\n\ngoal (1 subgoal):\n 1. f a \\<notin> f ` set xs \\<Longrightarrow>\n    distinct (a # remdups_wrt f xs)", "hence \"a \\<notin> set xs\""], ["proof (prove)\nusing this:\n  f a \\<notin> f ` set xs\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set xs\n\ngoal (1 subgoal):\n 1. f a \\<notin> f ` set xs \\<Longrightarrow>\n    distinct (a # remdups_wrt f xs)", "hence \"a \\<notin> set (remdups_wrt f xs)\""], ["proof (prove)\nusing this:\n  a \\<notin> set xs\n\ngoal (1 subgoal):\n 1. a \\<notin> set (remdups_wrt f xs)", "using subset_remdups_wrt[of f xs]"], ["proof (prove)\nusing this:\n  a \\<notin> set xs\n  set (remdups_wrt f xs) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. a \\<notin> set (remdups_wrt f xs)", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. f a \\<notin> f ` set xs \\<Longrightarrow>\n    distinct (a # remdups_wrt f xs)", "with Cons.hyps"], ["proof (chain)\npicking this:\n  distinct (remdups_wrt f xs)\n  a \\<notin> set (remdups_wrt f xs)", "show \"distinct (a # remdups_wrt f xs)\""], ["proof (prove)\nusing this:\n  distinct (remdups_wrt f xs)\n  a \\<notin> set (remdups_wrt f xs)\n\ngoal (1 subgoal):\n 1. distinct (a # remdups_wrt f xs)", "by simp"], ["proof (state)\nthis:\n  distinct (a # remdups_wrt f xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (remdups_wrt f (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_remdups_wrt: \"map f (remdups_wrt f xs) = remdups (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (remdups_wrt f xs) = remdups (map f xs)", "by (induct xs, auto)"], ["", "lemma remdups_wrt_append:\n  \"remdups_wrt f (xs @ ys) = (filter (\\<lambda>a. f a \\<notin> f ` set ys) (remdups_wrt f xs)) @ (remdups_wrt f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_wrt f (xs @ ys) =\n    filter (\\<lambda>a. f a \\<notin> f ` set ys) (remdups_wrt f xs) @\n    remdups_wrt f ys", "by (induct xs, auto)"], ["", "subsubsection \\<open>\\<open>map_idx\\<close>\\<close>"], ["", "primrec map_idx :: \"('a \\<Rightarrow> nat \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'b list\" where\n  \"map_idx f [] n = []\"|\n  \"map_idx f (x # xs) n = (f x n) # (map_idx f xs (Suc n))\""], ["", "lemma map_idx_eq_map2: \"map_idx f xs n = map2 f xs [n..<n + length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f xs n = map2 f xs [n..<n + length xs]", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. map_idx f [] n = map2 f [] [n..<n + length []]\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n = map2 f xs [n..<n + length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n = map2 f (a # xs) [n..<n + length (a # xs)]", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. map_idx f [] n = map2 f [] [n..<n + length []]\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n = map2 f xs [n..<n + length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n = map2 f (a # xs) [n..<n + length (a # xs)]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f [] n = map2 f [] [n..<n + length []]", "by simp"], ["proof (state)\nthis:\n  map_idx f [] n = map2 f [] [n..<n + length []]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n = map2 f xs [n..<n + length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n = map2 f (a # xs) [n..<n + length (a # xs)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n = map2 f xs [n..<n + length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n = map2 f (a # xs) [n..<n + length (a # xs)]", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_idx f xs ?n = map2 f xs [?n..<?n + length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n = map2 f xs [n..<n + length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n = map2 f (a # xs) [n..<n + length (a # xs)]", "have eq: \"[n..<n + length (x # xs)] = n # [Suc n..<Suc (n + length xs)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n..<n + length (x # xs)] = n # [Suc n..<Suc (n + length xs)]", "by (metis add_Suc_right length_Cons less_add_Suc1 upt_conv_Cons)"], ["proof (state)\nthis:\n  [n..<n + length (x # xs)] = n # [Suc n..<Suc (n + length xs)]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n = map2 f xs [n..<n + length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n = map2 f (a # xs) [n..<n + length (a # xs)]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f (x # xs) n = map2 f (x # xs) [n..<n + length (x # xs)]", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f (x # xs) n =\n    map2 f (x # xs) (n # [Suc n..<Suc (n + length xs)])", "by (simp add: Cons del: upt_Suc)"], ["proof (state)\nthis:\n  map_idx f (x # xs) n = map2 f (x # xs) [n..<n + length (x # xs)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_map_idx [simp]: \"length (map_idx f xs n) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map_idx f xs n) = length xs", "by (simp add: map_idx_eq_map2)"], ["", "lemma map_idx_append: \"map_idx f (xs @ ys) n = (map_idx f xs n) @ (map_idx f ys (n + length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f (xs @ ys) n = map_idx f xs n @ map_idx f ys (n + length xs)", "by (simp add: map_idx_eq_map2 ab_semigroup_add_class.add_ac(1) zip_append1)"], ["", "lemma map_idx_nth:\n  assumes \"i < length xs\"\n  shows \"(map_idx f xs n) ! i = f (xs ! i) (n + i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f xs n ! i = f (xs ! i) (n + i)", "using assms"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. map_idx f xs n ! i = f (xs ! i) (n + i)", "by (simp add: map_idx_eq_map2)"], ["", "lemma map_map_idx: \"map f (map_idx g xs n) = map_idx (\\<lambda>x i. f (g x i)) xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (map_idx g xs n) = map_idx (\\<lambda>x i. f (g x i)) xs n", "by (auto simp add: map_idx_eq_map2)"], ["", "lemma map_idx_map: \"map_idx f (map g xs) n = map_idx (f \\<circ> g) xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f (map g xs) n = map_idx (f \\<circ> g) xs n", "by (simp add: map_idx_eq_map2 map_zip_map)"], ["", "lemma map_idx_no_idx: \"map_idx (\\<lambda>x _. f x) xs n = map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx (\\<lambda>x _. f x) xs n = map f xs", "by (induct xs arbitrary: n, simp_all)"], ["", "lemma map_idx_no_elem: \"map_idx (\\<lambda>_. f) xs n = map f [n..<n + length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx (\\<lambda>_. f) xs n = map f [n..<n + length xs]", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. map_idx (\\<lambda>_. f) [] n = map f [n..<n + length []]\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_idx (\\<lambda>_. f) xs n =\n           map f [n..<n + length xs]) \\<Longrightarrow>\n       map_idx (\\<lambda>_. f) (a # xs) n = map f [n..<n + length (a # xs)]", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. map_idx (\\<lambda>_. f) [] n = map f [n..<n + length []]\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_idx (\\<lambda>_. f) xs n =\n           map f [n..<n + length xs]) \\<Longrightarrow>\n       map_idx (\\<lambda>_. f) (a # xs) n = map f [n..<n + length (a # xs)]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx (\\<lambda>_. f) [] n = map f [n..<n + length []]", "by simp"], ["proof (state)\nthis:\n  map_idx (\\<lambda>_. f) [] n = map f [n..<n + length []]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx (\\<lambda>_. f) xs n =\n           map f [n..<n + length xs]) \\<Longrightarrow>\n       map_idx (\\<lambda>_. f) (a # xs) n = map f [n..<n + length (a # xs)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx (\\<lambda>_. f) xs n =\n           map f [n..<n + length xs]) \\<Longrightarrow>\n       map_idx (\\<lambda>_. f) (a # xs) n = map f [n..<n + length (a # xs)]", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_idx (\\<lambda>_. f) xs ?n = map f [?n..<?n + length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx (\\<lambda>_. f) xs n =\n           map f [n..<n + length xs]) \\<Longrightarrow>\n       map_idx (\\<lambda>_. f) (a # xs) n = map f [n..<n + length (a # xs)]", "have eq: \"[n..<n + length (x # xs)] = n # [Suc n..<Suc (n + length xs)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n..<n + length (x # xs)] = n # [Suc n..<Suc (n + length xs)]", "by (metis add_Suc_right length_Cons less_add_Suc1 upt_conv_Cons)"], ["proof (state)\nthis:\n  [n..<n + length (x # xs)] = n # [Suc n..<Suc (n + length xs)]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx (\\<lambda>_. f) xs n =\n           map f [n..<n + length xs]) \\<Longrightarrow>\n       map_idx (\\<lambda>_. f) (a # xs) n = map f [n..<n + length (a # xs)]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx (\\<lambda>_. f) (x # xs) n = map f [n..<n + length (x # xs)]", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx (\\<lambda>_. f) (x # xs) n =\n    map f (n # [Suc n..<Suc (n + length xs)])", "by (simp add: Cons del: upt_Suc)"], ["proof (state)\nthis:\n  map_idx (\\<lambda>_. f) (x # xs) n = map f [n..<n + length (x # xs)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_idx_eq_map: \"map_idx f xs n = map (\\<lambda>i. f (xs ! i) (i + n)) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f xs n = map (\\<lambda>i. f (xs ! i) (i + n)) [0..<length xs]", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       map_idx f [] n = map (\\<lambda>i. f ([] ! i) (i + n)) [0..<length []]\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n.\n       map_idx f [] n = map (\\<lambda>i. f ([] ! i) (i + n)) [0..<length []]\n 2. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_idx f [] n = map (\\<lambda>i. f ([] ! i) (i + n)) [0..<length []]", "by simp"], ["proof (state)\nthis:\n  map_idx f [] n = map (\\<lambda>i. f ([] ! i) (i + n)) [0..<length []]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_idx f xs ?n = map (\\<lambda>i. f (xs ! i) (i + ?n)) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "have eq: \"[0..<length (x # xs)] = 0 # [Suc 0..<Suc (length xs)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<length (x # xs)] = 0 # [Suc 0..<Suc (length xs)]", "by (metis length_Cons upt_conv_Cons zero_less_Suc)"], ["proof (state)\nthis:\n  [0..<length (x # xs)] = 0 # [Suc 0..<Suc (length xs)]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "have \"map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [Suc 0..<Suc (length xs)] =\n        map ((\\<lambda>i. f ((x # xs) ! i) (i + n)) \\<circ> Suc) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [Suc 0..<Suc (length xs)] =\n    map ((\\<lambda>i. f ((x # xs) ! i) (i + n)) \\<circ> Suc) [0..<length xs]", "by (metis map_Suc_upt map_map)"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [Suc 0..<Suc (length xs)] =\n  map ((\\<lambda>i. f ((x # xs) ! i) (i + n)) \\<circ> Suc) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [Suc 0..<Suc (length xs)] =\n  map ((\\<lambda>i. f ((x # xs) ! i) (i + n)) \\<circ> Suc) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "have \"... = map (\\<lambda>i. f (xs ! i) (Suc (i + n))) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>i. f ((x # xs) ! i) (i + n)) \\<circ> Suc)\n     [0..<length xs] =\n    map (\\<lambda>i. f (xs ! i) (Suc (i + n))) [0..<length xs]", "by (rule map_cong, fact refl, simp)"], ["proof (state)\nthis:\n  map ((\\<lambda>i. f ((x # xs) ! i) (i + n)) \\<circ> Suc) [0..<length xs] =\n  map (\\<lambda>i. f (xs ! i) (Suc (i + n))) [0..<length xs]\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n.\n           map_idx f xs n =\n           map (\\<lambda>i. f (xs ! i) (i + n))\n            [0..<length xs]) \\<Longrightarrow>\n       map_idx f (a # xs) n =\n       map (\\<lambda>i. f ((a # xs) ! i) (i + n)) [0..<length (a # xs)]", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [Suc 0..<Suc (length xs)] =\n  map (\\<lambda>i. f (xs ! i) (Suc (i + n))) [0..<length xs]", "show ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [Suc 0..<Suc (length xs)] =\n  map (\\<lambda>i. f (xs ! i) (Suc (i + n))) [0..<length xs]\n\ngoal (1 subgoal):\n 1. map_idx f (x # xs) n =\n    map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [0..<length (x # xs)]", "unfolding eq"], ["proof (prove)\nusing this:\n  map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [Suc 0..<Suc (length xs)] =\n  map (\\<lambda>i. f (xs ! i) (Suc (i + n))) [0..<length xs]\n\ngoal (1 subgoal):\n 1. map_idx f (x # xs) n =\n    map (\\<lambda>i. f ((x # xs) ! i) (i + n))\n     (0 # [Suc 0..<Suc (length xs)])", "by (simp add: Cons del: upt_Suc)"], ["proof (state)\nthis:\n  map_idx f (x # xs) n =\n  map (\\<lambda>i. f ((x # xs) ! i) (i + n)) [0..<length (x # xs)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_map_idx: \"set (map_idx f xs n) = (\\<lambda>i. f (xs ! i) (i + n)) ` {0..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map_idx f xs n) =\n    (\\<lambda>i. f (xs ! i) (i + n)) ` {0..<length xs}", "by (simp add: map_idx_eq_map)"], ["", "subsubsection \\<open>\\<open>map_dup\\<close>\\<close>"], ["", "primrec map_dup :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'b list\" where\n  \"map_dup _ _ [] = []\"|\n  \"map_dup f g (x # xs) = (if x \\<in> set xs then g x else f x) # (map_dup f g xs)\""], ["", "lemma length_map_dup[simp]: \"length (map_dup f g xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map_dup f g xs) = length xs", "by (induct xs, simp_all)"], ["", "lemma map_dup_distinct:\n  assumes \"distinct xs\"\n  shows \"map_dup f g xs = map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dup f g xs = map f xs", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. map_dup f g xs = map f xs", "by (induct xs, simp_all)"], ["", "lemma filter_map_dup_const:\n  \"filter (\\<lambda>x. x \\<noteq> c) (map_dup f (\\<lambda>_. c) xs) = filter (\\<lambda>x. x \\<noteq> c) (map f (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> c) (map_dup f (\\<lambda>_. c) xs) =\n    filter (\\<lambda>x. x \\<noteq> c) (map f (remdups xs))", "by (induct xs, simp_all)"], ["", "lemma filter_zip_map_dup_const:\n  \"filter (\\<lambda>(a, b). a \\<noteq> c) (zip (map_dup f (\\<lambda>_. c) xs) xs) =\n    filter (\\<lambda>(a, b). a \\<noteq> c) (zip (map f (remdups xs)) (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(a, b). a \\<noteq> c)\n     (zip (map_dup f (\\<lambda>_. c) xs) xs) =\n    filter (\\<lambda>(a, b). a \\<noteq> c)\n     (zip (map f (remdups xs)) (remdups xs))", "by (induct xs, simp_all)"], ["", "subsubsection \\<open>Filtering Minimal Elements\\<close>"], ["", "context\n  fixes rel :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\nbegin"], ["", "primrec filter_min_aux :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"filter_min_aux [] ys = ys\"|\n  \"filter_min_aux (x # xs) ys =\n    (if (\\<exists>y\\<in>(set xs \\<union> set ys). rel y x) then (filter_min_aux xs ys)\n    else (filter_min_aux xs (x # ys)))\""], ["", "definition filter_min :: \"'a list \\<Rightarrow> 'a list\"\n  where \"filter_min xs = filter_min_aux xs []\""], ["", "definition filter_min_append :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\n  where \"filter_min_append xs ys =\n                  (let P = (\\<lambda>zs. \\<lambda>x. \\<not> (\\<exists>z\\<in>set zs. rel z x)); ys1 = filter (P xs) ys in\n                    (filter (P ys1) xs) @ ys1)\""], ["", "lemma filter_min_aux_supset: \"set ys \\<subseteq> set (filter_min_aux xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (local.filter_min_aux xs ys)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. set ys \\<subseteq> set (local.filter_min_aux [] ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys. set ys \\<subseteq> set (local.filter_min_aux [] ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (local.filter_min_aux [] ys)", "by simp"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (local.filter_min_aux [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  set ?ys \\<subseteq> set (local.filter_min_aux xs ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "have \"set ys \\<subseteq> set (x # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (x # ys)", "by auto"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (x # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "also"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (x # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "have \"set (x # ys) \\<subseteq> set (filter_min_aux xs (x # ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (x # ys) \\<subseteq> set (local.filter_min_aux xs (x # ys))", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  set (x # ys) \\<subseteq> set (local.filter_min_aux xs (x # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "finally"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> set (local.filter_min_aux xs (x # ys))", "have \"set ys \\<subseteq> set (filter_min_aux xs (x # ys))\""], ["proof (prove)\nusing this:\n  set ys \\<subseteq> set (local.filter_min_aux xs (x # ys))\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (local.filter_min_aux xs (x # ys))", "."], ["proof (state)\nthis:\n  set ys \\<subseteq> set (local.filter_min_aux xs (x # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "moreover"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (local.filter_min_aux xs (x # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "have \"set ys \\<subseteq> set (filter_min_aux xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (local.filter_min_aux xs ys)", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (local.filter_min_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (local.filter_min_aux (a # xs) ys)", "ultimately"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> set (local.filter_min_aux xs (x # ys))\n  set ys \\<subseteq> set (local.filter_min_aux xs ys)", "show ?case"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> set (local.filter_min_aux xs (x # ys))\n  set ys \\<subseteq> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (local.filter_min_aux (x # xs) ys)", "by simp"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (local.filter_min_aux (x # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_min_aux_subset: \"set (filter_min_aux xs ys) \\<subseteq> set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.filter_min_aux xs ys) \\<subseteq> set xs \\<union> set ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       set (local.filter_min_aux [] ys) \\<subseteq> set [] \\<union> set ys\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       set (local.filter_min_aux [] ys) \\<subseteq> set [] \\<union> set ys\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.filter_min_aux [] ys) \\<subseteq> set [] \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  set (local.filter_min_aux [] ys) \\<subseteq> set [] \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  set (local.filter_min_aux xs ?ys) \\<subseteq> set xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "note Cons.hyps"], ["proof (state)\nthis:\n  set (local.filter_min_aux xs ?ys) \\<subseteq> set xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "also"], ["proof (state)\nthis:\n  set (local.filter_min_aux xs ?ys) \\<subseteq> set xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "have \"set xs \\<union> set ys \\<subseteq> set (x # xs) \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<union> set ys \\<subseteq> set (x # xs) \\<union> set ys", "by fastforce"], ["proof (state)\nthis:\n  set xs \\<union> set ys \\<subseteq> set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "finally"], ["proof (chain)\npicking this:\n  set (local.filter_min_aux xs ys) \\<subseteq> set (x # xs) \\<union> set ys", "have c1: \"set (filter_min_aux xs ys) \\<subseteq> set (x # xs) \\<union> set ys\""], ["proof (prove)\nusing this:\n  set (local.filter_min_aux xs ys) \\<subseteq> set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. set (local.filter_min_aux xs ys)\n    \\<subseteq> set (x # xs) \\<union> set ys", "."], ["proof (state)\nthis:\n  set (local.filter_min_aux xs ys) \\<subseteq> set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "note Cons.hyps"], ["proof (state)\nthis:\n  set (local.filter_min_aux xs ?ys) \\<subseteq> set xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "also"], ["proof (state)\nthis:\n  set (local.filter_min_aux xs ?ys) \\<subseteq> set xs \\<union> set ?ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "have \"set xs \\<union> set (x # ys) = set (x # xs) \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<union> set (x # ys) = set (x # xs) \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  set xs \\<union> set (x # ys) = set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "finally"], ["proof (chain)\npicking this:\n  set (local.filter_min_aux xs (x # ys))\n  \\<subseteq> set (x # xs) \\<union> set ys", "have \"set (filter_min_aux xs (x # ys)) \\<subseteq> set (x # xs) \\<union> set ys\""], ["proof (prove)\nusing this:\n  set (local.filter_min_aux xs (x # ys))\n  \\<subseteq> set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. set (local.filter_min_aux xs (x # ys))\n    \\<subseteq> set (x # xs) \\<union> set ys", "."], ["proof (state)\nthis:\n  set (local.filter_min_aux xs (x # ys))\n  \\<subseteq> set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set (local.filter_min_aux xs ys)\n           \\<subseteq> set xs \\<union> set ys) \\<Longrightarrow>\n       set (local.filter_min_aux (a # xs) ys)\n       \\<subseteq> set (a # xs) \\<union> set ys", "with c1"], ["proof (chain)\npicking this:\n  set (local.filter_min_aux xs ys) \\<subseteq> set (x # xs) \\<union> set ys\n  set (local.filter_min_aux xs (x # ys))\n  \\<subseteq> set (x # xs) \\<union> set ys", "show ?case"], ["proof (prove)\nusing this:\n  set (local.filter_min_aux xs ys) \\<subseteq> set (x # xs) \\<union> set ys\n  set (local.filter_min_aux xs (x # ys))\n  \\<subseteq> set (x # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. set (local.filter_min_aux (x # xs) ys)\n    \\<subseteq> set (x # xs) \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  set (local.filter_min_aux (x # xs) ys)\n  \\<subseteq> set (x # xs) \\<union> set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_min_aux_relE:\n  assumes \"transp rel\" and \"x \\<in> set xs\" and \"x \\<notin> set (filter_min_aux xs ys)\"\n  obtains y where \"y \\<in> set (filter_min_aux xs ys)\" and \"rel y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs ys); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs ys); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induct xs arbitrary: x ys thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ys thesis.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min_aux [] ys);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        x \\<in> set []; x \\<notin> set (local.filter_min_aux [] ys)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a xs x ys thesis.\n       \\<lbrakk>\\<And>x ys thesis.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>y\n  \\<in> set (local.filter_min_aux xs ys);\n                                rel y x\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    x \\<in> set xs;\n                    x \\<notin> set (local.filter_min_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (local.filter_min_aux (a # xs) ys);\n            rel y x\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in> set (a # xs);\n        x \\<notin> set (local.filter_min_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> set (local.filter_min_aux [] ys); rel ?y x\\<rbrakk>\n  \\<Longrightarrow> thesis\n  x \\<in> set []\n  x \\<notin> set (local.filter_min_aux [] ys)\n\ngoal (2 subgoals):\n 1. \\<And>x ys thesis.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min_aux [] ys);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        x \\<in> set []; x \\<notin> set (local.filter_min_aux [] ys)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a xs x ys thesis.\n       \\<lbrakk>\\<And>x ys thesis.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>y\n  \\<in> set (local.filter_min_aux xs ys);\n                                rel y x\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    x \\<in> set xs;\n                    x \\<notin> set (local.filter_min_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (local.filter_min_aux (a # xs) ys);\n            rel y x\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in> set (a # xs);\n        x \\<notin> set (local.filter_min_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Nil(2)"], ["proof (chain)\npicking this:\n  x \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set []\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a xs x ys thesis.\n       \\<lbrakk>\\<And>x ys thesis.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>y\n  \\<in> set (local.filter_min_aux xs ys);\n                                rel y x\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    x \\<in> set xs;\n                    x \\<notin> set (local.filter_min_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (local.filter_min_aux (a # xs) ys);\n            rel y x\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in> set (a # xs);\n        x \\<notin> set (local.filter_min_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x ys thesis.\n       \\<lbrakk>\\<And>x ys thesis.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>y\n  \\<in> set (local.filter_min_aux xs ys);\n                                rel y x\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    x \\<in> set xs;\n                    x \\<notin> set (local.filter_min_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (local.filter_min_aux (a # xs) ys);\n            rel y x\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in> set (a # xs);\n        x \\<notin> set (local.filter_min_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons x0 xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>y.\n              \\<lbrakk>y \\<in> set (local.filter_min_aux xs ?ys);\n               rel y ?x\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   ?x \\<in> set xs; ?x \\<notin> set (local.filter_min_aux xs ?ys)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?y \\<in> set (local.filter_min_aux (x0 # xs) ys);\n   rel ?y x\\<rbrakk>\n  \\<Longrightarrow> thesis\n  x \\<in> set (x0 # xs)\n  x \\<notin> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x ys thesis.\n       \\<lbrakk>\\<And>x ys thesis.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>y\n  \\<in> set (local.filter_min_aux xs ys);\n                                rel y x\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    x \\<in> set xs;\n                    x \\<notin> set (local.filter_min_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (local.filter_min_aux (a # xs) ys);\n            rel y x\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in> set (a # xs);\n        x \\<notin> set (local.filter_min_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Cons(3)"], ["proof (chain)\npicking this:\n  x \\<in> set (x0 # xs)", "have \"x = x0 \\<or> x \\<in> set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set (x0 # xs)\n\ngoal (1 subgoal):\n 1. x = x0 \\<or> x \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  x = x0 \\<or> x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs x ys thesis.\n       \\<lbrakk>\\<And>x ys thesis.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>y\n  \\<in> set (local.filter_min_aux xs ys);\n                                rel y x\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    x \\<in> set xs;\n                    x \\<notin> set (local.filter_min_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>y \\<in> set (local.filter_min_aux (a # xs) ys);\n            rel y x\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        x \\<in> set (a # xs);\n        x \\<notin> set (local.filter_min_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  x = x0 \\<or> x \\<in> set xs\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x0 \\<Longrightarrow> thesis\n 2. x \\<in> set xs \\<Longrightarrow> thesis", "assume \"x = x0\""], ["proof (state)\nthis:\n  x = x0\n\ngoal (2 subgoals):\n 1. x = x0 \\<Longrightarrow> thesis\n 2. x \\<in> set xs \\<Longrightarrow> thesis", "from Cons(4)"], ["proof (chain)\npicking this:\n  x \\<notin> set (local.filter_min_aux (x0 # xs) ys)", "have *: \"\\<exists>y\\<in>set xs \\<union> set ys. rel y x0\""], ["proof (prove)\nusing this:\n  x \\<notin> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0", "proof (simp add: \\<open>x = x0\\<close> split: if_splits)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x0;\n     x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"x0 \\<notin> set (filter_min_aux xs (x0 # ys))\""], ["proof (state)\nthis:\n  x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x0;\n     x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x0;\n     x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\\<rbrakk>\n    \\<Longrightarrow> False", "from filter_min_aux_supset"], ["proof (chain)\npicking this:\n  set ?ys \\<subseteq> set (local.filter_min_aux ?xs ?ys)", "have \"x0 \\<in> set (filter_min_aux xs (x0 # ys))\""], ["proof (prove)\nusing this:\n  set ?ys \\<subseteq> set (local.filter_min_aux ?xs ?ys)\n\ngoal (1 subgoal):\n 1. x0 \\<in> set (local.filter_min_aux xs (x0 # ys))", "by (rule subsetD) simp"], ["proof (state)\nthis:\n  x0 \\<in> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x0;\n     x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\n  x0 \\<in> set (local.filter_min_aux xs (x0 # ys))", "show False"], ["proof (prove)\nusing this:\n  x0 \\<notin> set (local.filter_min_aux xs (x0 # ys))\n  x0 \\<in> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (2 subgoals):\n 1. x = x0 \\<Longrightarrow> thesis\n 2. x \\<in> set xs \\<Longrightarrow> thesis", "hence eq: \"filter_min_aux (x0 # xs) ys = filter_min_aux xs ys\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (1 subgoal):\n 1. local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys", "by simp"], ["proof (state)\nthis:\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys\n\ngoal (2 subgoals):\n 1. x = x0 \\<Longrightarrow> thesis\n 2. x \\<in> set xs \\<Longrightarrow> thesis", "from *"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0", "obtain x1 where \"x1 \\<in> set xs \\<union> set ys\" and \"rel x1 x\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>x1 \\<in> set xs \\<union> set ys; rel x1 x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>x = x0\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>x1 \\<in> set xs \\<union> set ys; rel x1 x0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x1 \\<in> set xs \\<union> set ys\n  rel x1 x\n\ngoal (2 subgoals):\n 1. x = x0 \\<Longrightarrow> thesis\n 2. x \\<in> set xs \\<Longrightarrow> thesis", "from this(1)"], ["proof (chain)\npicking this:\n  x1 \\<in> set xs \\<union> set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  x1 \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x1 \\<in> set xs \\<Longrightarrow> thesis\n 2. x1 \\<in> set ys \\<Longrightarrow> thesis", "assume \"x1 \\<in> set xs\""], ["proof (state)\nthis:\n  x1 \\<in> set xs\n\ngoal (2 subgoals):\n 1. x1 \\<in> set xs \\<Longrightarrow> thesis\n 2. x1 \\<in> set ys \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"x1 \\<in> set (filter_min_aux xs ys)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x1 \\<in> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis\n 2. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  x1 \\<in> set (local.filter_min_aux xs ys)\n\ngoal (2 subgoals):\n 1. x1 \\<in> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis\n 2. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "hence \"x1 \\<in> set (filter_min_aux (x0 # xs) ys)\""], ["proof (prove)\nusing this:\n  x1 \\<in> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)", "by (simp only: eq)"], ["proof (state)\nthis:\n  x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (2 subgoals):\n 1. x1 \\<in> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis\n 2. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>rel x1 x\\<close>"], ["proof (prove)\nusing this:\n  x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  rel x1 x\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  x1 \\<notin> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "with \\<open>x1 \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  x1 \\<in> set xs\n  x1 \\<notin> set (local.filter_min_aux xs ys)", "obtain y where \"y \\<in> set (filter_min_aux xs ys)\" and \"rel y x1\""], ["proof (prove)\nusing this:\n  x1 \\<in> set xs\n  x1 \\<notin> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs ys); rel y x1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.hyps"], ["proof (prove)\nusing this:\n  x1 \\<in> set xs\n  x1 \\<notin> set (local.filter_min_aux xs ys)\n  \\<lbrakk>\\<And>y.\n              \\<lbrakk>y \\<in> set (local.filter_min_aux xs ?ys);\n               rel y ?x\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   ?x \\<in> set xs; ?x \\<notin> set (local.filter_min_aux xs ?ys)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs ys); rel y x1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_aux xs ys)\n  rel y x1\n\ngoal (1 subgoal):\n 1. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "from this(1)"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min_aux xs ys)", "have \"y \\<in> set (filter_min_aux (x0 # xs) ys)\""], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set (local.filter_min_aux (x0 # xs) ys)", "by (simp only: eq)"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "from assms(1) \\<open>rel y x1\\<close> \\<open>rel x1 x\\<close>"], ["proof (chain)\npicking this:\n  transp rel\n  rel y x1\n  rel x1 x", "have \"rel y x\""], ["proof (prove)\nusing this:\n  transp rel\n  rel y x1\n  rel x1 x\n\ngoal (1 subgoal):\n 1. rel y x", "by (rule transpD)"], ["proof (state)\nthis:\n  rel y x\n\ngoal (1 subgoal):\n 1. x1 \\<notin> set (local.filter_min_aux xs ys) \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  rel y x", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  rel y x\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. x1 \\<in> set ys \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x1 \\<in> set ys \\<Longrightarrow> thesis", "assume \"x1 \\<in> set ys\""], ["proof (state)\nthis:\n  x1 \\<in> set ys\n\ngoal (1 subgoal):\n 1. x1 \\<in> set ys \\<Longrightarrow> thesis", "hence \"x1 \\<in> set (filter_min_aux (x0 # xs) ys)\""], ["proof (prove)\nusing this:\n  x1 \\<in> set ys\n\ngoal (1 subgoal):\n 1. x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)", "using filter_min_aux_supset"], ["proof (prove)\nusing this:\n  x1 \\<in> set ys\n  set ?ys \\<subseteq> set (local.filter_min_aux ?xs ?ys)\n\ngoal (1 subgoal):\n 1. x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)", ".."], ["proof (state)\nthis:\n  x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. x1 \\<in> set ys \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>rel x1 x\\<close>"], ["proof (prove)\nusing this:\n  x1 \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  rel x1 x\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> thesis", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"\\<exists>y\\<in>set xs \\<union> set ys. rel y x0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "hence eq: \"filter_min_aux (x0 # xs) ys = filter_min_aux xs ys\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (1 subgoal):\n 1. local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys", "by simp"], ["proof (state)\nthis:\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "with Cons(4)"], ["proof (chain)\npicking this:\n  x \\<notin> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys", "have \"x \\<notin> set (filter_min_aux xs ys)\""], ["proof (prove)\nusing this:\n  x \\<notin> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min_aux xs ys)", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set (local.filter_min_aux xs ys)\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "with \\<open>x \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs ys)", "obtain y where \"y \\<in> set (filter_min_aux xs ys)\" and \"rel y x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs ys); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.hyps"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs ys)\n  \\<lbrakk>\\<And>y.\n              \\<lbrakk>y \\<in> set (local.filter_min_aux xs ?ys);\n               rel y ?x\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   ?x \\<in> set xs; ?x \\<notin> set (local.filter_min_aux xs ?ys)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs ys); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_aux xs ys)\n  rel y x\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "from this(1)"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min_aux xs ys)", "have \"y \\<in> set (filter_min_aux (x0 # xs) ys)\""], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set (local.filter_min_aux (x0 # xs) ys)", "by (simp only: eq)"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>rel y x\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  rel y x\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>y\\<in>set xs \\<union> set ys. rel y x0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "hence eq: \"filter_min_aux (x0 # xs) ys = filter_min_aux xs (x0 # ys)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>set xs \\<union> set ys. rel y x0)\n\ngoal (1 subgoal):\n 1. local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)", "by simp"], ["proof (state)\nthis:\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "with Cons(4)"], ["proof (chain)\npicking this:\n  x \\<notin> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)", "have \"x \\<notin> set (filter_min_aux xs (x0 # ys))\""], ["proof (prove)\nusing this:\n  x \\<notin> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min_aux xs (x0 # ys))", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "with \\<open>x \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs (x0 # ys))", "obtain y where \"y \\<in> set (filter_min_aux xs (x0 # ys))\" and \"rel y x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs (x0 # ys));\n         rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.hyps"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs (x0 # ys))\n  \\<lbrakk>\\<And>y.\n              \\<lbrakk>y \\<in> set (local.filter_min_aux xs ?ys);\n               rel y ?x\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   ?x \\<in> set xs; ?x \\<notin> set (local.filter_min_aux xs ?ys)\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs (x0 # ys));\n         rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_aux xs (x0 # ys))\n  rel y x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "from this(1)"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min_aux xs (x0 # ys))", "have \"y \\<in> set (filter_min_aux (x0 # xs) ys)\""], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. y \\<in> set (local.filter_min_aux (x0 # xs) ys)", "by (simp only: eq)"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>rel y x\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  rel y x\n\ngoal (1 subgoal):\n 1. thesis", "by (rule Cons(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_min_aux_minimal:\n  assumes \"transp rel\" and \"x \\<in> set (filter_min_aux xs ys)\" and \"y \\<in> set (filter_min_aux xs ys)\"\n    and \"rel x y\"\n  assumes \"\\<And>a b. a \\<in> set xs \\<union> set ys \\<Longrightarrow> b \\<in> set ys \\<Longrightarrow> rel a b \\<Longrightarrow> a = b\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms(2-5)"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux xs ys)\n  y \\<in> set (local.filter_min_aux xs ys)\n  rel x y\n  \\<lbrakk>?a \\<in> set xs \\<union> set ys; ?b \\<in> set ys;\n   rel ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. x = y", "proof (induct xs arbitrary: x y ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y ys.\n       \\<lbrakk>x \\<in> set (local.filter_min_aux [] ys);\n        y \\<in> set (local.filter_min_aux [] ys); rel x y;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> set [] \\<union> set ys; b \\<in> set ys;\n            rel a b\\<rbrakk>\n           \\<Longrightarrow> a = b\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "case Nil"], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min_aux [] ys)\n  y \\<in> set (local.filter_min_aux [] ys)\n  rel x y\n  \\<lbrakk>?a \\<in> set [] \\<union> set ys; ?b \\<in> set ys;\n   rel ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (2 subgoals):\n 1. \\<And>x y ys.\n       \\<lbrakk>x \\<in> set (local.filter_min_aux [] ys);\n        y \\<in> set (local.filter_min_aux [] ys); rel x y;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> set [] \\<union> set ys; b \\<in> set ys;\n            rel a b\\<rbrakk>\n           \\<Longrightarrow> a = b\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "from Nil(1)"], ["proof (chain)\npicking this:\n  x \\<in> set (local.filter_min_aux [] ys)", "have \"x \\<in> set [] \\<union> set ys\""], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux [] ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set [] \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  x \\<in> set [] \\<union> set ys\n\ngoal (2 subgoals):\n 1. \\<And>x y ys.\n       \\<lbrakk>x \\<in> set (local.filter_min_aux [] ys);\n        y \\<in> set (local.filter_min_aux [] ys); rel x y;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> set [] \\<union> set ys; b \\<in> set ys;\n            rel a b\\<rbrakk>\n           \\<Longrightarrow> a = b\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  x \\<in> set [] \\<union> set ys\n\ngoal (2 subgoals):\n 1. \\<And>x y ys.\n       \\<lbrakk>x \\<in> set (local.filter_min_aux [] ys);\n        y \\<in> set (local.filter_min_aux [] ys); rel x y;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> set [] \\<union> set ys; b \\<in> set ys;\n            rel a b\\<rbrakk>\n           \\<Longrightarrow> a = b\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "from Nil(2)"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min_aux [] ys)", "have \"y \\<in> set ys\""], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_aux [] ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  y \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<And>x y ys.\n       \\<lbrakk>x \\<in> set (local.filter_min_aux [] ys);\n        y \\<in> set (local.filter_min_aux [] ys); rel x y;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> set [] \\<union> set ys; b \\<in> set ys;\n            rel a b\\<rbrakk>\n           \\<Longrightarrow> a = b\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set [] \\<union> set ys\n  y \\<in> set ys", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> set [] \\<union> set ys\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. x = y", "using Nil(3)"], ["proof (prove)\nusing this:\n  x \\<in> set [] \\<union> set ys\n  y \\<in> set ys\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule Nil(4))"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "case (Cons x0 xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (local.filter_min_aux xs ?ys);\n   ?y \\<in> set (local.filter_min_aux xs ?ys); rel ?x ?y;\n   \\<And>a b.\n      \\<lbrakk>a \\<in> set xs \\<union> set ?ys; b \\<in> set ?ys;\n       rel a b\\<rbrakk>\n      \\<Longrightarrow> a = b\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  x \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  rel x y\n  \\<lbrakk>?a \\<in> set (x0 # xs) \\<union> set ys; ?b \\<in> set ys;\n   rel ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. \\<And>a xs x y ys.\n       \\<lbrakk>\\<And>x y ys.\n                   \\<lbrakk>x \\<in> set (local.filter_min_aux xs ys);\n                    y \\<in> set (local.filter_min_aux xs ys); rel x y;\n                    \\<And>a b.\n                       \\<lbrakk>a \\<in> set xs \\<union> set ys;\n                        b \\<in> set ys; rel a b\\<rbrakk>\n                       \\<Longrightarrow> a = b\\<rbrakk>\n                   \\<Longrightarrow> x = y;\n        x \\<in> set (local.filter_min_aux (a # xs) ys);\n        y \\<in> set (local.filter_min_aux (a # xs) ys); rel x y;\n        \\<And>aa b.\n           \\<lbrakk>aa \\<in> set (a # xs) \\<union> set ys; b \\<in> set ys;\n            rel aa b\\<rbrakk>\n           \\<Longrightarrow> aa = b\\<rbrakk>\n       \\<Longrightarrow> x = y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (cases \"\\<exists>y\\<in>set xs \\<union> set ys. rel y x0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> x = y\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "case True"], ["proof (state)\nthis:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> x = y\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "hence eq: \"filter_min_aux (x0 # xs) ys = filter_min_aux xs ys\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (1 subgoal):\n 1. local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys", "by simp"], ["proof (state)\nthis:\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> x = y\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "with Cons(2, 3)"], ["proof (chain)\npicking this:\n  x \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys", "have \"x \\<in> set (filter_min_aux xs ys)\" and \"y \\<in> set (filter_min_aux xs ys)\""], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs ys\n\ngoal (1 subgoal):\n 1. x \\<in> set (local.filter_min_aux xs ys) &&&\n    y \\<in> set (local.filter_min_aux xs ys)", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min_aux xs ys)\n  y \\<in> set (local.filter_min_aux xs ys)\n\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0 \\<Longrightarrow> x = y\n 2. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux xs ys)\n  y \\<in> set (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. x = y", "using Cons(4)"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux xs ys)\n  y \\<in> set (local.filter_min_aux xs ys)\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set ys; b \\<in> set ys;\n        rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set ys; b \\<in> set ys;\n        rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume \"a \\<in> set xs \\<union> set ys\""], ["proof (state)\nthis:\n  a \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set ys; b \\<in> set ys;\n        rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "hence \"a \\<in> set (x0 # xs) \\<union> set ys\""], ["proof (prove)\nusing this:\n  a \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. a \\<in> set (x0 # xs) \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (x0 # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set ys; b \\<in> set ys;\n        rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "moreover"], ["proof (state)\nthis:\n  a \\<in> set (x0 # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set ys; b \\<in> set ys;\n        rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume \"b \\<in> set ys\" and \"rel a b\""], ["proof (state)\nthis:\n  b \\<in> set ys\n  rel a b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set ys; b \\<in> set ys;\n        rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> set (x0 # xs) \\<union> set ys\n  b \\<in> set ys\n  rel a b", "show \"a = b\""], ["proof (prove)\nusing this:\n  a \\<in> set (x0 # xs) \\<union> set ys\n  b \\<in> set ys\n  rel a b\n\ngoal (1 subgoal):\n 1. a = b", "by (rule Cons(5))"], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>y\\<in>set xs \\<union> set ys. rel y x0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "hence eq: \"filter_min_aux (x0 # xs) ys = filter_min_aux xs (x0 # ys)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>set xs \\<union> set ys. rel y x0)\n\ngoal (1 subgoal):\n 1. local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)", "by simp"], ["proof (state)\nthis:\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "with Cons(2, 3)"], ["proof (chain)\npicking this:\n  x \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)", "have \"x \\<in> set (filter_min_aux xs (x0 # ys))\" and \"y \\<in> set (filter_min_aux xs (x0 # ys))\""], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  y \\<in> set (local.filter_min_aux (x0 # xs) ys)\n  local.filter_min_aux (x0 # xs) ys = local.filter_min_aux xs (x0 # ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set (local.filter_min_aux xs (x0 # ys)) &&&\n    y \\<in> set (local.filter_min_aux xs (x0 # ys))", "by simp_all"], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min_aux xs (x0 # ys))\n  y \\<in> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>set xs \\<union> set ys.\n               rel y x0) \\<Longrightarrow>\n    x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux xs (x0 # ys))\n  y \\<in> set (local.filter_min_aux xs (x0 # ys))\n\ngoal (1 subgoal):\n 1. x = y", "using Cons(4)"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_aux xs (x0 # ys))\n  y \\<in> set (local.filter_min_aux xs (x0 # ys))\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set (x0 # ys);\n        b \\<in> set (x0 # ys); rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set (x0 # ys);\n        b \\<in> set (x0 # ys); rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume a: \"a \\<in> set xs \\<union> set (x0 # ys)\" and \"b \\<in> set (x0 # ys)\" and \"rel a b\""], ["proof (state)\nthis:\n  a \\<in> set xs \\<union> set (x0 # ys)\n  b \\<in> set (x0 # ys)\n  rel a b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set (x0 # ys);\n        b \\<in> set (x0 # ys); rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "from this(2)"], ["proof (chain)\npicking this:\n  b \\<in> set (x0 # ys)", "have \"b = x0 \\<or> b \\<in> set ys\""], ["proof (prove)\nusing this:\n  b \\<in> set (x0 # ys)\n\ngoal (1 subgoal):\n 1. b = x0 \\<or> b \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  b = x0 \\<or> b \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> set xs \\<union> set (x0 # ys);\n        b \\<in> set (x0 # ys); rel a b\\<rbrakk>\n       \\<Longrightarrow> a = b", "thus \"a = b\""], ["proof (prove)\nusing this:\n  b = x0 \\<or> b \\<in> set ys\n\ngoal (1 subgoal):\n 1. a = b", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b = x0 \\<Longrightarrow> a = b\n 2. b \\<in> set ys \\<Longrightarrow> a = b", "assume \"b = x0\""], ["proof (state)\nthis:\n  b = x0\n\ngoal (2 subgoals):\n 1. b = x0 \\<Longrightarrow> a = b\n 2. b \\<in> set ys \\<Longrightarrow> a = b", "from a"], ["proof (chain)\npicking this:\n  a \\<in> set xs \\<union> set (x0 # ys)", "have \"a = x0 \\<or> a \\<in> set xs \\<union> set ys\""], ["proof (prove)\nusing this:\n  a \\<in> set xs \\<union> set (x0 # ys)\n\ngoal (1 subgoal):\n 1. a = x0 \\<or> a \\<in> set xs \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  a = x0 \\<or> a \\<in> set xs \\<union> set ys\n\ngoal (2 subgoals):\n 1. b = x0 \\<Longrightarrow> a = b\n 2. b \\<in> set ys \\<Longrightarrow> a = b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = x0 \\<or> a \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. a = b", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a = x0 \\<Longrightarrow> a = b\n 2. a \\<in> set xs \\<union> set ys \\<Longrightarrow> a = b", "assume \"a = x0\""], ["proof (state)\nthis:\n  a = x0\n\ngoal (2 subgoals):\n 1. a = x0 \\<Longrightarrow> a = b\n 2. a \\<in> set xs \\<union> set ys \\<Longrightarrow> a = b", "with \\<open>b = x0\\<close>"], ["proof (chain)\npicking this:\n  b = x0\n  a = x0", "show ?thesis"], ["proof (prove)\nusing this:\n  b = x0\n  a = x0\n\ngoal (1 subgoal):\n 1. a = b", "by simp"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<union> set ys \\<Longrightarrow> a = b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<union> set ys \\<Longrightarrow> a = b", "assume \"a \\<in> set xs \\<union> set ys\""], ["proof (state)\nthis:\n  a \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<union> set ys \\<Longrightarrow> a = b", "hence \"\\<exists>y\\<in>set xs \\<union> set ys. rel y x0\""], ["proof (prove)\nusing this:\n  a \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0", "using \\<open>rel a b\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> set xs \\<union> set ys\n  rel a b\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0", "unfolding \\<open>b = x0\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> set xs \\<union> set ys\n  rel a x0\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x0", ".."], ["proof (state)\nthis:\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (1 subgoal):\n 1. a \\<in> set xs \\<union> set ys \\<Longrightarrow> a = b", "with False"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>y\\<in>set xs \\<union> set ys. rel y x0)\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>set xs \\<union> set ys. rel y x0)\n  \\<exists>y\\<in>set xs \\<union> set ys. rel y x0\n\ngoal (1 subgoal):\n 1. a = b", ".."], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. b \\<in> set ys \\<Longrightarrow> a = b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> set ys \\<Longrightarrow> a = b", "from a"], ["proof (chain)\npicking this:\n  a \\<in> set xs \\<union> set (x0 # ys)", "have \"a \\<in> set (x0 # xs) \\<union> set ys\""], ["proof (prove)\nusing this:\n  a \\<in> set xs \\<union> set (x0 # ys)\n\ngoal (1 subgoal):\n 1. a \\<in> set (x0 # xs) \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (x0 # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. b \\<in> set ys \\<Longrightarrow> a = b", "moreover"], ["proof (state)\nthis:\n  a \\<in> set (x0 # xs) \\<union> set ys\n\ngoal (1 subgoal):\n 1. b \\<in> set ys \\<Longrightarrow> a = b", "assume \"b \\<in> set ys\""], ["proof (state)\nthis:\n  b \\<in> set ys\n\ngoal (1 subgoal):\n 1. b \\<in> set ys \\<Longrightarrow> a = b", "ultimately"], ["proof (chain)\npicking this:\n  a \\<in> set (x0 # xs) \\<union> set ys\n  b \\<in> set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> set (x0 # xs) \\<union> set ys\n  b \\<in> set ys\n\ngoal (1 subgoal):\n 1. a = b", "using \\<open>rel a b\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> set (x0 # xs) \\<union> set ys\n  b \\<in> set ys\n  rel a b\n\ngoal (1 subgoal):\n 1. a = b", "by (rule Cons(5))"], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_min_aux_distinct:\n  assumes \"reflp rel\" and \"distinct ys\"\n  shows \"distinct (filter_min_aux xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (local.filter_min_aux xs ys)", "using assms(2)"], ["proof (prove)\nusing this:\n  distinct ys\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_aux xs ys)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       distinct ys \\<Longrightarrow> distinct (local.filter_min_aux [] ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   distinct ys \\<Longrightarrow>\n                   distinct (local.filter_min_aux xs ys);\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> distinct (local.filter_min_aux (a # xs) ys)", "case Nil"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       distinct ys \\<Longrightarrow> distinct (local.filter_min_aux [] ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   distinct ys \\<Longrightarrow>\n                   distinct (local.filter_min_aux xs ys);\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> distinct (local.filter_min_aux (a # xs) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct ys\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_aux [] ys)", "by simp"], ["proof (state)\nthis:\n  distinct (local.filter_min_aux [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   distinct ys \\<Longrightarrow>\n                   distinct (local.filter_min_aux xs ys);\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> distinct (local.filter_min_aux (a # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   distinct ys \\<Longrightarrow>\n                   distinct (local.filter_min_aux xs ys);\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> distinct (local.filter_min_aux (a # xs) ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct ?ys \\<Longrightarrow> distinct (local.filter_min_aux xs ?ys)\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   distinct ys \\<Longrightarrow>\n                   distinct (local.filter_min_aux xs ys);\n        distinct ys\\<rbrakk>\n       \\<Longrightarrow> distinct (local.filter_min_aux (a # xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (local.filter_min_aux (x # xs) ys)", "proof (simp split: if_split, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y\\<in>set xs \\<union> set ys. rel y x \\<Longrightarrow>\n    distinct (local.filter_min_aux xs ys)\n 2. \\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x \\<Longrightarrow>\n    distinct (local.filter_min_aux xs (x # ys))", "from Cons(2)"], ["proof (chain)\npicking this:\n  distinct ys", "show \"distinct (filter_min_aux xs ys)\""], ["proof (prove)\nusing this:\n  distinct ys\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_aux xs ys)", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  distinct (local.filter_min_aux xs ys)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x \\<Longrightarrow>\n    distinct (local.filter_min_aux xs (x # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x \\<Longrightarrow>\n    distinct (local.filter_min_aux xs (x # ys))", "assume a: \"\\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x\""], ["proof (state)\nthis:\n  \\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x \\<Longrightarrow>\n    distinct (local.filter_min_aux xs (x # ys))", "show \"distinct (filter_min_aux xs (x # ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (local.filter_min_aux xs (x # ys))", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (x # ys)", "have \"x \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set ys", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow> False", "assume \"x \\<in> set ys\""], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow> False", "hence \"x \\<in> set xs \\<union> set ys\""], ["proof (prove)\nusing this:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<union> set ys", "by simp"], ["proof (state)\nthis:\n  x \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow> False", "with a"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x\n  x \\<in> set xs \\<union> set ys", "have \"\\<not> rel x x\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set xs \\<union> set ys. \\<not> rel y x\n  x \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. \\<not> rel x x", ".."], ["proof (state)\nthis:\n  \\<not> rel x x\n\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> rel x x\n\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow> False", "from assms(1)"], ["proof (chain)\npicking this:\n  reflp rel", "have \"rel x x\""], ["proof (prove)\nusing this:\n  reflp rel\n\ngoal (1 subgoal):\n 1. rel x x", "by (rule reflpD)"], ["proof (state)\nthis:\n  rel x x\n\ngoal (1 subgoal):\n 1. x \\<in> set ys \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> rel x x\n  rel x x", "show False"], ["proof (prove)\nusing this:\n  \\<not> rel x x\n  rel x x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. distinct (x # ys)", "with Cons(2)"], ["proof (chain)\npicking this:\n  distinct ys\n  x \\<notin> set ys", "show \"distinct (x # ys)\""], ["proof (prove)\nusing this:\n  distinct ys\n  x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. distinct (x # ys)", "by simp"], ["proof (state)\nthis:\n  distinct (x # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (local.filter_min_aux xs (x # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (local.filter_min_aux (x # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_min_subset: \"set (filter_min xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.filter_min xs) \\<subseteq> set xs", "using filter_min_aux_subset[of xs \"[]\"]"], ["proof (prove)\nusing this:\n  set (local.filter_min_aux xs []) \\<subseteq> set xs \\<union> set []\n\ngoal (1 subgoal):\n 1. set (local.filter_min xs) \\<subseteq> set xs", "by (simp add: filter_min_def)"], ["", "lemma filter_min_cases:\n  assumes \"transp rel\" and \"x \\<in> set xs\"\n  assumes \"x \\<in> set (filter_min xs) \\<Longrightarrow> thesis\"\n  assumes \"\\<And>y. y \\<in> set (filter_min xs) \\<Longrightarrow> x \\<notin> set (filter_min xs) \\<Longrightarrow> rel y x \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"x \\<in> set (filter_min xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (local.filter_min xs) \\<Longrightarrow> thesis\n 2. x \\<notin> set (local.filter_min xs) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min xs)\n\ngoal (2 subgoals):\n 1. x \\<in> set (local.filter_min xs) \\<Longrightarrow> thesis\n 2. x \\<notin> set (local.filter_min xs) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min xs)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule assms(3))"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min xs) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min xs) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  x \\<notin> set (local.filter_min xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min xs) \\<Longrightarrow> thesis", "with assms(1, 2)"], ["proof (chain)\npicking this:\n  transp rel\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min xs)", "obtain y where \"y \\<in> set (filter_min xs)\" and \"rel y x\""], ["proof (prove)\nusing this:\n  transp rel\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min xs)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min xs); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding filter_min_def"], ["proof (prove)\nusing this:\n  transp rel\n  x \\<in> set xs\n  x \\<notin> set (local.filter_min_aux xs [])\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_aux xs []); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule filter_min_aux_relE)"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min xs)\n  rel y x\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min xs) \\<Longrightarrow> thesis", "from this(1) False this(2)"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min xs)\n  x \\<notin> set (local.filter_min xs)\n  rel y x", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min xs)\n  x \\<notin> set (local.filter_min xs)\n  rel y x\n\ngoal (1 subgoal):\n 1. thesis", "by (rule assms(4))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary filter_min_relE:\n  assumes \"transp rel\" and \"reflp rel\" and \"x \\<in> set xs\"\n  obtains y where \"y \\<in> set (filter_min xs)\" and \"rel y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min xs); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1, 3)"], ["proof (prove)\nusing this:\n  transp rel\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min xs); rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule filter_min_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min xs); rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min xs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min xs);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min xs);\n        x \\<notin> set (local.filter_min xs); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"x \\<in> set (filter_min xs)\""], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min xs); rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min xs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min xs);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min xs);\n        x \\<notin> set (local.filter_min xs); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min xs); rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min xs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min xs);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min xs);\n        x \\<notin> set (local.filter_min xs); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  reflp rel", "have \"rel x x\""], ["proof (prove)\nusing this:\n  reflp rel\n\ngoal (1 subgoal):\n 1. rel x x", "by (rule reflpD)"], ["proof (state)\nthis:\n  rel x x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min xs); rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min xs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min xs);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min xs);\n        x \\<notin> set (local.filter_min xs); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set (local.filter_min xs)\n  rel x x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min xs)\n  rel x x\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min xs);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min xs);\n        x \\<notin> set (local.filter_min xs); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["", "lemma filter_min_minimal:\n  assumes \"transp rel\" and \"x \\<in> set (filter_min xs)\" and \"y \\<in> set (filter_min xs)\" and \"rel x y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  transp rel\n  x \\<in> set (local.filter_min xs)\n  y \\<in> set (local.filter_min xs)\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", "unfolding filter_min_def"], ["proof (prove)\nusing this:\n  transp rel\n  x \\<in> set (local.filter_min_aux xs [])\n  y \\<in> set (local.filter_min_aux xs [])\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule filter_min_aux_minimal) simp"], ["", "lemma filter_min_distinct:\n  assumes \"reflp rel\"\n  shows \"distinct (filter_min xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (local.filter_min xs)", "unfolding filter_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (local.filter_min_aux xs [])", "by (rule filter_min_aux_distinct, fact, simp)"], ["", "lemma filter_min_append_subset: \"set (filter_min_append xs ys) \\<subseteq> set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.filter_min_append xs ys) \\<subseteq> set xs \\<union> set ys", "by (auto simp: filter_min_append_def)"], ["", "lemma filter_min_append_cases:\n  assumes \"transp rel\" and \"x \\<in> set xs \\<union> set ys\"\n  assumes \"x \\<in> set (filter_min_append xs ys) \\<Longrightarrow> thesis\"\n  assumes \"\\<And>y. y \\<in> set (filter_min_append xs ys) \\<Longrightarrow> x \\<notin> set (filter_min_append xs ys) \\<Longrightarrow> rel y x \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"x \\<in> set (filter_min_append xs ys)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis\n 2. x \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min_append xs ys)\n\ngoal (2 subgoals):\n 1. x \\<in> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis\n 2. x \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_append xs ys)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule assms(3))"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  x \\<notin> set (local.filter_min_append xs ys)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "define P where \"P = (\\<lambda>zs. \\<lambda>a. \\<not> (\\<exists>z\\<in>set zs. rel z a))\""], ["proof (state)\nthis:\n  P = (\\<lambda>zs a. \\<not> (\\<exists>z\\<in>set zs. rel z a))\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  x \\<in> set xs \\<union> set ys", "obtain y where \"y \\<in> set (filter_min_append xs ys)\" and \"rel y x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n         rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "with False"], ["proof (chain)\npicking this:\n  x \\<notin> set (local.filter_min_append xs ys)\n  x \\<in> set xs", "obtain y where \"y \\<in> set (filter_min_append xs ys)\" and \"rel y x\""], ["proof (prove)\nusing this:\n  x \\<notin> set (local.filter_min_append xs ys)\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n         rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: filter_min_append_def P_def)"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_append xs ys)\n  rel y x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_append xs ys)\n  rel y x\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"x \\<in> set ys\""], ["proof (state)\nthis:\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "with False"], ["proof (chain)\npicking this:\n  x \\<notin> set (local.filter_min_append xs ys)\n  x \\<in> set ys", "obtain y where \"y \\<in> set xs\" and \"rel y x\""], ["proof (prove)\nusing this:\n  x \\<notin> set (local.filter_min_append xs ys)\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set xs; rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: filter_min_append_def P_def)"], ["proof (state)\nthis:\n  y \\<in> set xs\n  rel y x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"y \\<in> set (filter_min_append xs ys)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis\n 2. y \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_append xs ys)\n\ngoal (2 subgoals):\n 1. y \\<in> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis\n 2. y \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_append xs ys)\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>rel y x\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_append xs ys)\n  rel y x\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. y \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  y \\<notin> set (local.filter_min_append xs ys)\n\ngoal (1 subgoal):\n 1. y \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "with \\<open>y \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> set xs\n  y \\<notin> set (local.filter_min_append xs ys)", "obtain y' where y': \"y' \\<in> set (filter_min_append xs ys)\" and \"rel y' y\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  y \\<notin> set (local.filter_min_append xs ys)\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y' \\<in> set (local.filter_min_append xs ys);\n         rel y' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: filter_min_append_def P_def)"], ["proof (state)\nthis:\n  y' \\<in> set (local.filter_min_append xs ys)\n  rel y' y\n\ngoal (1 subgoal):\n 1. y \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "from assms(1) this(2) \\<open>rel y x\\<close>"], ["proof (chain)\npicking this:\n  transp rel\n  rel y' y\n  rel y x", "have \"rel y' x\""], ["proof (prove)\nusing this:\n  transp rel\n  rel y' y\n  rel y x\n\ngoal (1 subgoal):\n 1. rel y' x", "by (rule transpD)"], ["proof (state)\nthis:\n  rel y' x\n\ngoal (1 subgoal):\n 1. y \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "with y'"], ["proof (chain)\npicking this:\n  y' \\<in> set (local.filter_min_append xs ys)\n  rel y' x", "show ?thesis"], ["proof (prove)\nusing this:\n  y' \\<in> set (local.filter_min_append xs ys)\n  rel y' x\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> set (local.filter_min_append xs ys)\n  rel y x\n\ngoal (1 subgoal):\n 1. x \\<notin> set (local.filter_min_append xs ys) \\<Longrightarrow> thesis", "from this(1) False this(2)"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min_append xs ys)\n  x \\<notin> set (local.filter_min_append xs ys)\n  rel y x", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_append xs ys)\n  x \\<notin> set (local.filter_min_append xs ys)\n  rel y x\n\ngoal (1 subgoal):\n 1. thesis", "by (rule assms(4))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary filter_min_append_relE:\n  assumes \"transp rel\" and \"reflp rel\" and \"x \\<in> set xs \\<union> set ys\"\n  obtains y where \"y \\<in> set (filter_min_append xs ys)\" and \"rel y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n         rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1, 3)"], ["proof (prove)\nusing this:\n  transp rel\n  x \\<in> set xs \\<union> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n         rel y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule filter_min_append_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min_append xs ys)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min_append xs ys);\n        x \\<notin> set (local.filter_min_append xs ys); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"x \\<in> set (filter_min_append xs ys)\""], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min_append xs ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min_append xs ys)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min_append xs ys);\n        x \\<notin> set (local.filter_min_append xs ys); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (local.filter_min_append xs ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min_append xs ys)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min_append xs ys);\n        x \\<notin> set (local.filter_min_append xs ys); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  reflp rel", "have \"rel x x\""], ["proof (prove)\nusing this:\n  reflp rel\n\ngoal (1 subgoal):\n 1. rel x x", "by (rule reflpD)"], ["proof (state)\nthis:\n  rel x x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y.\n                \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                 rel y x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     x \\<in> set (local.filter_min_append xs ys)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min_append xs ys);\n        x \\<notin> set (local.filter_min_append xs ys); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set (local.filter_min_append xs ys)\n  rel x x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_append xs ys)\n  rel x x\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> set (local.filter_min_append xs ys);\n                    rel y x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> set (local.filter_min_append xs ys);\n        x \\<notin> set (local.filter_min_append xs ys); rel y x\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["", "lemma filter_min_append_minimal:\n  assumes \"\\<And>x' y'. x' \\<in> set xs \\<Longrightarrow> y' \\<in> set xs \\<Longrightarrow> rel x' y' \\<Longrightarrow> x' = y'\"\n    and \"\\<And>x' y'. x' \\<in> set ys \\<Longrightarrow> y' \\<in> set ys \\<Longrightarrow> rel x' y' \\<Longrightarrow> x' = y'\"\n    and \"x \\<in> set (filter_min_append xs ys)\" and \"y \\<in> set (filter_min_append xs ys)\" and \"rel x y\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "define P where \"P = (\\<lambda>zs. \\<lambda>a. \\<not> (\\<exists>z\\<in>set zs. rel z a))\""], ["proof (state)\nthis:\n  P = (\\<lambda>zs a. \\<not> (\\<exists>z\\<in>set zs. rel z a))\n\ngoal (1 subgoal):\n 1. x = y", "define ys1 where \"ys1 = filter (P xs) ys\""], ["proof (state)\nthis:\n  ys1 = filter (P xs) ys\n\ngoal (1 subgoal):\n 1. x = y", "from assms(3)"], ["proof (chain)\npicking this:\n  x \\<in> set (local.filter_min_append xs ys)", "have \"x \\<in> set xs \\<union> set ys1\""], ["proof (prove)\nusing this:\n  x \\<in> set (local.filter_min_append xs ys)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<union> set ys1", "by (auto simp: filter_min_append_def P_def ys1_def)"], ["proof (state)\nthis:\n  x \\<in> set xs \\<union> set ys1\n\ngoal (1 subgoal):\n 1. x = y", "moreover"], ["proof (state)\nthis:\n  x \\<in> set xs \\<union> set ys1\n\ngoal (1 subgoal):\n 1. x = y", "from assms(4)"], ["proof (chain)\npicking this:\n  y \\<in> set (local.filter_min_append xs ys)", "have \"y \\<in> set (filter (P ys1) xs) \\<union> set ys1\""], ["proof (prove)\nusing this:\n  y \\<in> set (local.filter_min_append xs ys)\n\ngoal (1 subgoal):\n 1. y \\<in> set (filter (P ys1) xs) \\<union> set ys1", "by (simp add: filter_min_append_def P_def ys1_def)"], ["proof (state)\nthis:\n  y \\<in> set (filter (P ys1) xs) \\<union> set ys1\n\ngoal (1 subgoal):\n 1. x = y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set xs \\<union> set ys1\n  y \\<in> set (filter (P ys1) xs) \\<union> set ys1", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set xs \\<union> set ys1\n  y \\<in> set (filter (P ys1) xs) \\<union> set ys1\n\ngoal (1 subgoal):\n 1. x = y", "proof (elim UnE)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 4. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 4. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"y \\<in> set (filter (P ys1) xs)\""], ["proof (state)\nthis:\n  y \\<in> set (filter (P ys1) xs)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 4. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "hence \"y \\<in> set xs\""], ["proof (prove)\nusing this:\n  y \\<in> set (filter (P ys1) xs)\n\ngoal (1 subgoal):\n 1. y \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  y \\<in> set xs\n\ngoal (4 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 4. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "with \\<open>x \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  y \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. x = y", "using assms(5)"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  y \\<in> set xs\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule assms(1))"], ["proof (state)\nthis:\n  x = y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"y \\<in> set ys1\""], ["proof (state)\nthis:\n  y \\<in> set ys1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "hence \"\\<And>z. z \\<in> set xs \\<Longrightarrow> \\<not> rel z y\""], ["proof (prove)\nusing this:\n  y \\<in> set ys1\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set xs \\<Longrightarrow> \\<not> rel z y", "by (simp add: ys1_def P_def)"], ["proof (state)\nthis:\n  ?z \\<in> set xs \\<Longrightarrow> \\<not> rel ?z y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  ?z \\<in> set xs \\<Longrightarrow> \\<not> rel ?z y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"x \\<in> set xs\""], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  ?z \\<in> set xs \\<Longrightarrow> \\<not> rel ?z y\n  x \\<in> set xs", "have \"\\<not> rel x y\""], ["proof (prove)\nusing this:\n  ?z \\<in> set xs \\<Longrightarrow> \\<not> rel ?z y\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<not> rel x y", "by blast"], ["proof (state)\nthis:\n  \\<not> rel x y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> set xs; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 3. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> rel x y\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>rel x y\\<close>"], ["proof (prove)\nusing this:\n  \\<not> rel x y\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", ".."], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"y \\<in> set (filter (P ys1) xs)\""], ["proof (state)\nthis:\n  y \\<in> set (filter (P ys1) xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "hence \"\\<And>z. z \\<in> set ys1 \\<Longrightarrow> \\<not> rel z y\""], ["proof (prove)\nusing this:\n  y \\<in> set (filter (P ys1) xs)\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set ys1 \\<Longrightarrow> \\<not> rel z y", "by (simp add: P_def)"], ["proof (state)\nthis:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"x \\<in> set ys1\""], ["proof (state)\nthis:\n  x \\<in> set ys1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z y\n  x \\<in> set ys1", "have \"\\<not> rel x y\""], ["proof (prove)\nusing this:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z y\n  x \\<in> set ys1\n\ngoal (1 subgoal):\n 1. \\<not> rel x y", "by blast"], ["proof (state)\nthis:\n  \\<not> rel x y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set (filter (P ys1) xs)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> rel x y\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>rel x y\\<close>"], ["proof (prove)\nusing this:\n  \\<not> rel x y\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", ".."], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"x \\<in> set ys1\" and \"y \\<in> set ys1\""], ["proof (state)\nthis:\n  x \\<in> set ys1\n  y \\<in> set ys1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "hence \"x \\<in> set ys\" and \"y \\<in> set ys\""], ["proof (prove)\nusing this:\n  x \\<in> set ys1\n  y \\<in> set ys1\n\ngoal (1 subgoal):\n 1. x \\<in> set ys &&& y \\<in> set ys", "by (simp_all add: ys1_def)"], ["proof (state)\nthis:\n  x \\<in> set ys\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys1; y \\<in> set ys1\\<rbrakk>\n    \\<Longrightarrow> x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set ys\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. x = y", "using assms(5)"], ["proof (prove)\nusing this:\n  x \\<in> set ys\n  y \\<in> set ys\n  rel x y\n\ngoal (1 subgoal):\n 1. x = y", "by (rule assms(2))"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_min_append_distinct:\n  assumes \"reflp rel\" and \"distinct xs\" and \"distinct ys\"\n  shows \"distinct (filter_min_append xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "define P where \"P = (\\<lambda>zs. \\<lambda>a. \\<not> (\\<exists>z\\<in>set zs. rel z a))\""], ["proof (state)\nthis:\n  P = (\\<lambda>zs a. \\<not> (\\<exists>z\\<in>set zs. rel z a))\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "define ys1 where \"ys1 = filter (P xs) ys\""], ["proof (state)\nthis:\n  ys1 = filter (P xs) ys\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "from assms(2)"], ["proof (chain)\npicking this:\n  distinct xs", "have \"distinct (filter (P ys1) xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (filter (P ys1) xs)", "by simp"], ["proof (state)\nthis:\n  distinct (filter (P ys1) xs)\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "moreover"], ["proof (state)\nthis:\n  distinct (filter (P ys1) xs)\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "from assms(3)"], ["proof (chain)\npicking this:\n  distinct ys", "have \"distinct ys1\""], ["proof (prove)\nusing this:\n  distinct ys\n\ngoal (1 subgoal):\n 1. distinct ys1", "by (simp add: ys1_def)"], ["proof (state)\nthis:\n  distinct ys1\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "moreover"], ["proof (state)\nthis:\n  distinct ys1\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "have \"set (filter (P ys1) xs) \\<inter> set ys1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (P ys1) xs) \\<inter> set ys1 = {}", "proof (simp add: set_eq_iff, intro allI impI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"P ys1 x\""], ["proof (state)\nthis:\n  P ys1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<And>z. z \\<in> set ys1 \\<Longrightarrow> \\<not> rel z x\""], ["proof (prove)\nusing this:\n  P ys1 x\n\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> set ys1 \\<Longrightarrow> \\<not> rel z x", "by (simp add: P_def)"], ["proof (state)\nthis:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> set ys1\""], ["proof (state)\nthis:\n  x \\<in> set ys1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z x\n  x \\<in> set ys1", "have \"\\<not> rel x x\""], ["proof (prove)\nusing this:\n  ?z \\<in> set ys1 \\<Longrightarrow> \\<not> rel ?z x\n  x \\<in> set ys1\n\ngoal (1 subgoal):\n 1. \\<not> rel x x", "by blast"], ["proof (state)\nthis:\n  \\<not> rel x x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> rel x x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "from assms(1)"], ["proof (chain)\npicking this:\n  reflp rel", "have \"rel x x\""], ["proof (prove)\nusing this:\n  reflp rel\n\ngoal (1 subgoal):\n 1. rel x x", "by (rule reflpD)"], ["proof (state)\nthis:\n  rel x x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P ys1 x; x \\<in> set xs; x \\<in> set ys1\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> rel x x\n  rel x x", "show False"], ["proof (prove)\nusing this:\n  \\<not> rel x x\n  rel x x\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (filter (P ys1) xs) \\<inter> set ys1 = {}\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (filter (P ys1) xs)\n  distinct ys1\n  set (filter (P ys1) xs) \\<inter> set ys1 = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (filter (P ys1) xs)\n  distinct ys1\n  set (filter (P ys1) xs) \\<inter> set ys1 = {}\n\ngoal (1 subgoal):\n 1. distinct (local.filter_min_append xs ys)", "by (simp add: filter_min_append_def ys1_def P_def)"], ["proof (state)\nthis:\n  distinct (local.filter_min_append xs ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "(* theory *)"]]}