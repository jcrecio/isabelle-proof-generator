{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/F4_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma remdups_wrt_rev_notin: \"v \\<in> set vs \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f xs vs)\"", "lemma distinct_remdups_wrt_rev: \"distinct (map f (remdups_wrt_rev f xs vs))\"", "lemma map_of_remdups_wrt_rev':\n  \"map_of (remdups_wrt_rev fst xs vs) k = map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs) k\"", "lemma (in term_powerprod) compute_list_to_poly [code]:\n  \"list_to_poly ts cs = distr\\<^sub>0 DRLEX (remdups_wrt_rev fst (zip ts cs) [])\"", "lemma (in ordered_term) compute_Macaulay_list [code]:\n  \"Macaulay_list ps =\n     (let ts = Keys_to_list ps in\n      filter (\\<lambda>p. p \\<noteq> 0) (mat_to_polys ts (row_echelon (polys_to_mat ts ps)))\n     )\"", "lemma\n  \"lt_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = sparse\\<^sub>0 [(0, 2), (2, 3)]\"", "lemma\n  \"lc_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 1\"", "lemma\n  \"tail_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 3 * X\\<^sup>2 * Y\"", "lemma\n  \"ord_strict_p_punit DRLEX (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2) (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2)\"", "lemma\n  \"f4_punit DRLEX\n    [\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ())\n    ] () =\n    [\n     (X\\<^sup>2 * Y\\<^sup>2 * Z\\<^sup>2 + 4 * Y ^ 3 * Z\\<^sup>2, ()),\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ()),\n     (X\\<^sup>2 * Y ^ 4 * Z + 4 * Y ^ 5 * Z, ())\n    ]\"", "lemma\n  \"f4_punit DRLEX\n    [\n     (X\\<^sup>2 + Y\\<^sup>2 + Z\\<^sup>2 - 1, ()),\n     (X * Y - Z - 1, ()),\n     (Y\\<^sup>2 + X, ()),\n     (Z\\<^sup>2 + X, ())\n    ] () =\n    [\n     (1, ())\n    ]\""], "translations": [["", "lemma remdups_wrt_rev_notin: \"v \\<in> set vs \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f xs vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set vs \\<Longrightarrow>\n    v \\<notin> f ` set (remdups_wrt_rev f xs vs)", "proof (induct xs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       v \\<in> set vs \\<Longrightarrow>\n       v \\<notin> f ` set (remdups_wrt_rev f [] vs)\n 2. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "case Nil"], ["proof (state)\nthis:\n  v \\<in> set vs\n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       v \\<in> set vs \\<Longrightarrow>\n       v \\<notin> f ` set (remdups_wrt_rev f [] vs)\n 2. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f [] vs)", "by simp"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f [] vs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  v \\<in> set ?vs \\<Longrightarrow>\n  v \\<notin> f ` set (remdups_wrt_rev f xs ?vs)\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  v \\<in> set vs", "have 1: \"v \\<notin> f ` set (remdups_wrt_rev f xs vs)\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f xs vs)", "by (rule Cons(1))"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f xs vs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  v \\<in> set vs", "have \"v \\<in> set (f x # vs)\""], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<in> set (f x # vs)", "by simp"], ["proof (state)\nthis:\n  v \\<in> set (f x # vs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "hence 2: \"v \\<notin> f ` set (remdups_wrt_rev f xs (f x # vs))\""], ["proof (prove)\nusing this:\n  v \\<in> set (f x # vs)\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f xs (f x # vs))", "by (rule Cons(1))"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f xs (f x # vs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       \\<lbrakk>\\<And>vs.\n                   v \\<in> set vs \\<Longrightarrow>\n                   v \\<notin> f ` set (remdups_wrt_rev f xs vs);\n        v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> f ` set (remdups_wrt_rev f (a # xs) vs)", "from Cons(2)"], ["proof (chain)\npicking this:\n  v \\<in> set vs", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> set vs\n\ngoal (1 subgoal):\n 1. v \\<notin> f ` set (remdups_wrt_rev f (x # xs) vs)", "by (auto simp: Let_def 1 2 List.member_def)"], ["proof (state)\nthis:\n  v \\<notin> f ` set (remdups_wrt_rev f (x # xs) vs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_remdups_wrt_rev: \"distinct (map f (remdups_wrt_rev f xs vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (remdups_wrt_rev f xs vs))", "proof (induct xs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs. distinct (map f (remdups_wrt_rev f [] vs))\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vs. distinct (map f (remdups_wrt_rev f [] vs))\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (remdups_wrt_rev f [] vs))", "by simp"], ["proof (state)\nthis:\n  distinct (map f (remdups_wrt_rev f [] vs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (map f (remdups_wrt_rev f xs ?vs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           distinct (map f (remdups_wrt_rev f xs vs))) \\<Longrightarrow>\n       distinct (map f (remdups_wrt_rev f (a # xs) vs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map f (remdups_wrt_rev f (x # xs) vs))", "by (simp add: Let_def Cons(1) remdups_wrt_rev_notin)"], ["proof (state)\nthis:\n  distinct (map f (remdups_wrt_rev f (x # xs) vs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_remdups_wrt_rev':\n  \"map_of (remdups_wrt_rev fst xs vs) k = map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst xs vs) k =\n    map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs) k", "proof (induct xs arbitrary: vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       map_of (remdups_wrt_rev fst [] vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>vs.\n       map_of (remdups_wrt_rev fst [] vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k\n 2. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst [] vs) k =\n    map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k", "by simp"], ["proof (state)\nthis:\n  map_of (remdups_wrt_rev fst [] vs) k =\n  map_of (filter (\\<lambda>x. fst x \\<notin> set vs) []) k\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "case (Cons x xs)"], ["proof (state)\nthis:\n  map_of (remdups_wrt_rev fst xs ?vs) k =\n  map_of (filter (\\<lambda>x. fst x \\<notin> set ?vs) xs) k\n\ngoal (1 subgoal):\n 1. \\<And>a xs vs.\n       (\\<And>vs.\n           map_of (remdups_wrt_rev fst xs vs) k =\n           map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n            k) \\<Longrightarrow>\n       map_of (remdups_wrt_rev fst (a # xs) vs) k =\n       map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (a # xs)) k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst (x # xs) vs) k =\n    map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (x # xs)) k", "proof (simp add: Let_def List.member_def Cons, intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "assume \"k \\<noteq> fst x\""], ["proof (state)\nthis:\n  k \\<noteq> fst x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "have \"map_of (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs) xs) =\n          map_of (filter (\\<lambda>y. fst y \\<noteq> fst x) (filter (\\<lambda>y. fst y \\<notin> set vs) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n       xs) =\n    map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x)\n       (filter (\\<lambda>y. fst y \\<notin> set vs) xs))", "by (simp only: filter_filter conj_commute)"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x)\n     (filter (\\<lambda>y. fst y \\<notin> set vs) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "also"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x)\n     (filter (\\<lambda>y. fst y \\<notin> set vs) xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "have \"... = map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |` {y. y \\<noteq> fst x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x)\n       (filter (\\<lambda>y. fst y \\<notin> set vs) xs)) =\n    map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n    {y. y \\<noteq> fst x}", "by (rule map_of_filter)"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x)\n     (filter (\\<lambda>y. fst y \\<notin> set vs) xs)) =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n  {y. y \\<noteq> fst x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<noteq> fst x; fst x \\<notin> set vs\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (filter\n                         (\\<lambda>xa.\n                             fst xa \\<noteq> fst x \\<and>\n                             fst xa \\<notin> set vs)\n                         xs)\n                       k =\n                      map_of (filter (\\<lambda>x. fst x \\<notin> set vs) xs)\n                       k", "finally"], ["proof (chain)\npicking this:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n  {y. y \\<noteq> fst x}", "show \"map_of (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs) xs) k =\n                  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) k\""], ["proof (prove)\nusing this:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs) =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) |`\n  {y. y \\<noteq> fst x}\n\ngoal (1 subgoal):\n 1. map_of\n     (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n       xs)\n     k =\n    map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) k", "by (simp add: restrict_map_def \\<open>k \\<noteq> fst x\\<close>)"], ["proof (state)\nthis:\n  map_of\n   (filter (\\<lambda>y. fst y \\<noteq> fst x \\<and> fst y \\<notin> set vs)\n     xs)\n   k =\n  map_of (filter (\\<lambda>y. fst y \\<notin> set vs) xs) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of (remdups_wrt_rev fst (x # xs) vs) k =\n  map_of (filter (\\<lambda>x. fst x \\<notin> set vs) (x # xs)) k\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary map_of_remdups_wrt_rev: \"map_of (remdups_wrt_rev fst xs []) = map_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (remdups_wrt_rev fst xs []) = map_of xs", "by (rule ext, simp add: map_of_remdups_wrt_rev')"], ["", "lemma (in term_powerprod) compute_list_to_poly [code]:\n  \"list_to_poly ts cs = distr\\<^sub>0 DRLEX (remdups_wrt_rev fst (zip ts cs) [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_to_poly ts cs =\n    distr\\<^sub>0 DRLEX (remdups_wrt_rev fst (zip ts cs) [])", "by (rule poly_mapping_eqI,\n      simp add: lookup_list_to_poly list_to_fun_def distr\\<^sub>0_def oalist_of_list_ntm_def\n        oa_ntm.lookup_oalist_of_list distinct_remdups_wrt_rev lookup_dflt_def map_of_remdups_wrt_rev)"], ["", "lemma (in ordered_term) compute_Macaulay_list [code]:\n  \"Macaulay_list ps =\n     (let ts = Keys_to_list ps in\n      filter (\\<lambda>p. p \\<noteq> 0) (mat_to_polys ts (row_echelon (polys_to_mat ts ps)))\n     )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Macaulay_list ps =\n    (let ts = Keys_to_list ps\n     in filter (\\<lambda>p. p \\<noteq> 0)\n         (mat_to_polys ts (row_echelon (polys_to_mat ts ps))))", "by (simp add: Macaulay_list_def Macaulay_mat_def Let_def)"], ["", "declare conversep_iff [code]"], ["", "derive (eq) ceq poly_mapping"], ["", "derive (no) ccompare poly_mapping"], ["", "derive (dlist) set_impl poly_mapping"], ["", "derive (no) cenum poly_mapping"], ["", "derive (eq) ceq rat"], ["", "derive (no) ccompare rat"], ["", "derive (dlist) set_impl rat"], ["", "derive (no) cenum rat"], ["", "global_interpretation punit': gd_powerprod \"ord_pp_punit cmp_term\" \"ord_pp_strict_punit cmp_term\"\n  rewrites \"punit.adds_term = (adds)\"\n  and \"punit.pp_of_term = (\\<lambda>x. x)\"\n  and \"punit.component_of_term = (\\<lambda>_. ())\"\n  and \"punit.monom_mult = monom_mult_punit\"\n  and \"punit.mult_scalar = mult_scalar_punit\"\n  and \"punit'.punit.min_term = min_term_punit\"\n  and \"punit'.punit.lt = lt_punit cmp_term\"\n  and \"punit'.punit.lc = lc_punit cmp_term\"\n  and \"punit'.punit.tail = tail_punit cmp_term\"\n  and \"punit'.punit.ord_p = ord_p_punit cmp_term\"\n  and \"punit'.punit.ord_strict_p = ord_strict_p_punit cmp_term\"\n  and \"punit'.punit.keys_to_list = keys_to_list_punit cmp_term\"\n  for cmp_term :: \"('a::nat, 'b::{nat,add_wellorder}) pp nat_term_order\"\n\n  defines max_punit = punit'.ordered_powerprod_lin.max\n  and max_list_punit = punit'.ordered_powerprod_lin.max_list\n  and find_adds_punit = punit'.punit.find_adds\n  and trd_aux_punit = punit'.punit.trd_aux\n  and trd_punit = punit'.punit.trd\n  and spoly_punit = punit'.punit.spoly\n  and count_const_lt_components_punit = punit'.punit.count_const_lt_components\n  and count_rem_components_punit = punit'.punit.count_rem_components\n  and const_lt_component_punit = punit'.punit.const_lt_component\n  and full_gb_punit = punit'.punit.full_gb\n  and add_pairs_single_sorted_punit = punit'.punit.add_pairs_single_sorted\n  and add_pairs_punit = punit'.punit.add_pairs\n  and canon_pair_order_aux_punit = punit'.punit.canon_pair_order_aux\n  and canon_basis_order_punit = punit'.punit.canon_basis_order\n  and new_pairs_sorted_punit = punit'.punit.new_pairs_sorted\n  and product_crit_punit = punit'.punit.product_crit\n  and chain_ncrit_punit = punit'.punit.chain_ncrit\n  and chain_ocrit_punit = punit'.punit.chain_ocrit\n  and apply_icrit_punit = punit'.punit.apply_icrit\n  and apply_ncrit_punit = punit'.punit.apply_ncrit\n  and apply_ocrit_punit = punit'.punit.apply_ocrit\n  and Keys_to_list_punit = punit'.punit.Keys_to_list\n  and sym_preproc_addnew_punit = punit'.punit.sym_preproc_addnew\n  and sym_preproc_aux_punit = punit'.punit.sym_preproc_aux\n  and sym_preproc_punit = punit'.punit.sym_preproc\n  and Macaulay_mat_punit = punit'.punit.Macaulay_mat\n  and Macaulay_list_punit = punit'.punit.Macaulay_list\n  and pdata_pairs_to_list_punit = punit'.punit.pdata_pairs_to_list\n  and Macaulay_red_punit = punit'.punit.Macaulay_red\n  and f4_sel_aux_punit = punit'.punit.f4_sel_aux\n  and f4_sel_punit = punit'.punit.f4_sel\n  and f4_red_aux_punit = punit'.punit.f4_red_aux\n  and f4_red_punit = punit'.punit.f4_red\n  and f4_aux_punit = punit'.punit.f4_aux_punit\n  and f4_punit = punit'.punit.f4_punit"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gd_powerprod (ord_pp_punit cmp_term)\n       (ord_pp_strict_punit cmp_term) &&&\n      punit.adds_term = (adds) &&& punit.pp_of_term = (\\<lambda>x. x)) &&&\n     punit.component_of_term = (\\<lambda>_. ()) &&&\n     punit.monom_mult = monom_mult_punit &&&\n     punit.mult_scalar = mult_scalar_punit) &&&\n    (ordered_term.min_term fst = min_term_punit &&&\n     ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term &&&\n     ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term) &&&\n    (ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term &&&\n     ordered_term.ord_p (ord_pp_strict_punit cmp_term) =\n     ord_p_punit cmp_term) &&&\n    ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term &&&\n    ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_powerprod (ord_pp_punit cmp_term) (ord_pp_strict_punit cmp_term)", "by (fact gd_powerprod_ord_pp_punit)"], ["proof (prove)\ngoal (12 subgoals):\n 1. punit.adds_term = (adds)\n 2. punit.pp_of_term = (\\<lambda>x. x)\n 3. punit.component_of_term = (\\<lambda>_. ())\n 4. punit.monom_mult = monom_mult_punit\n 5. punit.mult_scalar = mult_scalar_punit\n 6. ordered_term.min_term fst = min_term_punit\n 7. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 8. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 9. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 10. ordered_term.ord_p (ord_pp_strict_punit cmp_term) =\n     ord_p_punit cmp_term\nA total of 12 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.adds_term = (adds)", "by (fact punit_adds_term)"], ["proof (prove)\ngoal (11 subgoals):\n 1. punit.pp_of_term = (\\<lambda>x. x)\n 2. punit.component_of_term = (\\<lambda>_. ())\n 3. punit.monom_mult = monom_mult_punit\n 4. punit.mult_scalar = mult_scalar_punit\n 5. ordered_term.min_term fst = min_term_punit\n 6. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 7. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 8. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 9. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 10. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n     ord_strict_p_punit cmp_term\nA total of 11 subgoals...", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.pp_of_term = (\\<lambda>x. x)", "by (simp add: id_def)"], ["proof (prove)\ngoal (10 subgoals):\n 1. punit.component_of_term = (\\<lambda>_. ())\n 2. punit.monom_mult = monom_mult_punit\n 3. punit.mult_scalar = mult_scalar_punit\n 4. ordered_term.min_term fst = min_term_punit\n 5. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 6. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 7. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 8. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 9. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 10. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n     keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.component_of_term = (\\<lambda>_. ())", "by (fact punit_component_of_term)"], ["proof (prove)\ngoal (9 subgoals):\n 1. punit.monom_mult = monom_mult_punit\n 2. punit.mult_scalar = mult_scalar_punit\n 3. ordered_term.min_term fst = min_term_punit\n 4. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 5. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 6. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 7. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 8. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 9. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.monom_mult = monom_mult_punit", "by (simp only: monom_mult_punit_def)"], ["proof (prove)\ngoal (8 subgoals):\n 1. punit.mult_scalar = mult_scalar_punit\n 2. ordered_term.min_term fst = min_term_punit\n 3. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 4. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 5. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 6. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 7. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 8. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. punit.mult_scalar = mult_scalar_punit", "by (simp only: mult_scalar_punit_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. ordered_term.min_term fst = min_term_punit\n 2. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 3. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 4. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 5. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 6. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 7. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.min_term fst = min_term_punit", "using min_term_punit_def"], ["proof (prove)\nusing this:\n  min_term_punit \\<equiv> ordered_term.min_term fst\n\ngoal (1 subgoal):\n 1. ordered_term.min_term fst = min_term_punit", "by fastforce"], ["proof (prove)\ngoal (6 subgoals):\n 1. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term\n 2. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 3. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 4. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 5. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 6. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lt fst (ord_pp_punit cmp_term) = lt_punit cmp_term", "by (simp only: lt_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term\n 2. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 3. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 4. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 5. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.lc fst (ord_pp_punit cmp_term) = lc_punit cmp_term", "by (simp only: lc_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term\n 2. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 3. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 4. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.tail fst (ord_pp_punit cmp_term) = tail_punit cmp_term", "by (simp only: tail_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term\n 2. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 3. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.ord_p (ord_pp_strict_punit cmp_term) = ord_p_punit cmp_term", "by (simp only: ord_p_punit_def ord_pp_strict_punit_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term\n 2. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.ord_strict_p (ord_pp_strict_punit cmp_term) =\n    ord_strict_p_punit cmp_term", "by (simp only: ord_strict_p_punit_def ord_pp_strict_punit_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.keys_to_list (ord_pp_punit cmp_term) =\n    keys_to_list_punit cmp_term", "by (simp only: keys_to_list_punit_def ord_pp_punit_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Computations\\<close>"], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"lt_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = sparse\\<^sub>0 [(0, 2), (2, 3)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n      3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1) =\n    sparse\\<^sub>0 [(0, 2), (2, 3)]", "by eval"], ["", "lemma\n  \"lc_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n      3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1) =\n    1", "by eval"], ["", "lemma\n  \"tail_punit DRLEX (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y) = 3 * X\\<^sup>2 * Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n      3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1) =\n    3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1", "by eval"], ["", "lemma\n  \"ord_strict_p_punit DRLEX (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2) (X\\<^sup>2 * Z ^ 7 + 2 * Y ^ 3 * Z\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_strict_p_punit DRLEX\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 7 +\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2)", "by eval"], ["", "lemma\n  \"f4_punit DRLEX\n    [\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ())\n    ] () =\n    [\n     (X\\<^sup>2 * Y\\<^sup>2 * Z\\<^sup>2 + 4 * Y ^ 3 * Z\\<^sup>2, ()),\n     (X\\<^sup>2 * Z ^ 4 - 2 * Y ^ 3 * Z\\<^sup>2, ()),\n     (Y\\<^sup>2 * Z + 2 * Z ^ 3, ()),\n     (X\\<^sup>2 * Y ^ 4 * Z + 4 * Y ^ 5 * Z, ())\n    ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f4_punit DRLEX\n     [((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n       2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2,\n       ()),\n      ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 + 2 * V\\<^sub>0 2 ^ 3, ())]\n     () =\n    [((V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 1)\\<^sup>2 *\n      (V\\<^sub>0 2)\\<^sup>2 +\n      4 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2,\n      ()),\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 4 -\n      2 * V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2,\n      ()),\n     ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 + 2 * V\\<^sub>0 2 ^ 3, ()),\n     ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1 ^ 4 * V\\<^sub>0 2 +\n      4 * V\\<^sub>0 1 ^ 5 * V\\<^sub>0 2,\n      ())]", "by eval"], ["", "lemma\n  \"f4_punit DRLEX\n    [\n     (X\\<^sup>2 + Y\\<^sup>2 + Z\\<^sup>2 - 1, ()),\n     (X * Y - Z - 1, ()),\n     (Y\\<^sup>2 + X, ()),\n     (Z\\<^sup>2 + X, ())\n    ] () =\n    [\n     (1, ())\n    ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f4_punit DRLEX\n     [((V\\<^sub>0 0)\\<^sup>2 + (V\\<^sub>0 1)\\<^sup>2 +\n       (V\\<^sub>0 2)\\<^sup>2 -\n       1,\n       ()),\n      (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2 - 1, ()),\n      ((V\\<^sub>0 1)\\<^sup>2 + V\\<^sub>0 0, ()),\n      ((V\\<^sub>0 2)\\<^sup>2 + V\\<^sub>0 0, ())]\n     () =\n    [(1, ())]", "by eval"], ["", "end"], ["", "value [code] \"length (f4_punit DRLEX (map (\\<lambda>p. (p, ())) ((cyclic DRLEX 4)::(_ \\<Rightarrow>\\<^sub>0 rat) list)) ())\""], ["", "value [code] \"length (f4_punit DRLEX (map (\\<lambda>p. (p, ())) ((katsura DRLEX 2)::(_ \\<Rightarrow>\\<^sub>0 rat) list)) ())\""], ["", "end"], ["", "(* theory *)"]]}