{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/Auto_Reduction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma is_red_monic: \"is_red B (monic p) \\<longleftrightarrow> is_red B p\"", "lemma red_image_monic [simp]: \"red (monic ` B) = red B\"", "lemma is_red_image_monic [simp]: \"is_red (monic ` B) p \\<longleftrightarrow> is_red B p\"", "lemma is_auto_reducedD:\n  assumes \"is_auto_reduced B\" and \"b \\<in> B\"\n  shows \"\\<not> is_red (B - {b}) b\"", "lemma image_monic_is_auto_reduced:\n  assumes \"is_auto_reduced B\"\n  shows \"is_auto_reduced (monic ` B)\"", "lemma is_minimal_basisI:\n  assumes \"\\<And>p. p \\<in> B \\<Longrightarrow> p \\<noteq> 0\" and \"\\<And>p q. p \\<in> B \\<Longrightarrow> q \\<in> B \\<Longrightarrow> p \\<noteq> q \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q\"\n  shows \"is_minimal_basis B\"", "lemma is_minimal_basisD1:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\"\n  shows \"p \\<noteq> 0\"", "lemma is_minimal_basisD2:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"q \\<in> B\" and \"p \\<noteq> q\"\n  shows \"\\<not> lt p adds\\<^sub>t lt q\"", "lemma is_minimal_basisD3:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"q \\<in> B\" and \"p \\<noteq> q\"\n  shows \"\\<not> lt q adds\\<^sub>t lt p\"", "lemma is_minimal_basis_subset:\n  assumes \"is_minimal_basis B\" and \"A \\<subseteq> B\"\n  shows \"is_minimal_basis A\"", "lemma nadds_red:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and red: \"red B p r\"\n  shows \"r \\<noteq> 0 \\<and> lt r = lt p\"", "lemma nadds_red_nonzero:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and \"red B p r\"\n  shows \"r \\<noteq> 0\"", "lemma nadds_red_lt:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and \"red B p r\"\n  shows \"lt r = lt p\"", "lemma nadds_red_rtrancl_lt:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and rtrancl: \"(red B)\\<^sup>*\\<^sup>* p r\"\n  shows \"lt r = lt p\"", "lemma nadds_red_rtrancl_nonzero:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and \"p \\<noteq> 0\" and rtrancl: \"(red B)\\<^sup>*\\<^sup>* p r\"\n  shows \"r \\<noteq> 0\"", "lemma minimal_basis_red_rtrancl_nonzero:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"(red (B - {p}))\\<^sup>*\\<^sup>* p r\"\n  shows \"r \\<noteq> 0\"", "lemma minimal_basis_red_rtrancl_lt:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"(red (B - {p}))\\<^sup>*\\<^sup>* p r\"\n  shows \"lt r = lt p\"", "lemma is_minimal_basis_replace:\n  assumes major: \"is_minimal_basis B\" and \"p \\<in> B\" and red: \"(red (B - {p}))\\<^sup>*\\<^sup>* p r\"\n  shows \"is_minimal_basis (insert r (B - {p}))\"", "lemma comp_min_basis_subset': \"set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}\"", "lemma comp_min_basis_subset: \"set (comp_min_basis xs) \\<subseteq> set xs\"", "lemma comp_min_basis_nonzero: \"p \\<in> set (comp_min_basis xs) \\<Longrightarrow> p \\<noteq> 0\"", "lemma comp_min_basis_adds:\n  assumes \"p \\<in> set xs\" and \"p \\<noteq> 0\"\n  obtains q where \"q \\<in> set (comp_min_basis xs)\" and \"lt q adds\\<^sub>t lt p\"", "lemma comp_min_basis_is_red:\n  assumes \"is_red (set xs) f\"\n  shows \"is_red (set (comp_min_basis xs)) f\"", "lemma comp_min_basis_nadds:\n  assumes \"p \\<in> set (comp_min_basis xs)\" and \"q \\<in> set (comp_min_basis xs)\" and \"p \\<noteq> q\"\n  shows \"\\<not> lt q adds\\<^sub>t lt p\"", "lemma comp_min_basis_is_minimal_basis: \"is_minimal_basis (set (comp_min_basis xs))\"", "lemma comp_min_basis_distinct: \"distinct (comp_min_basis xs)\"", "lemma is_minimal_basis_trd_is_minimal_basis:\n  assumes \"is_minimal_basis (set (x # xs))\" and \"x \\<notin> set xs\"\n  shows \"is_minimal_basis (set ((trd xs x) # xs))\"", "lemma is_minimal_basis_trd_distinct:\n  assumes min: \"is_minimal_basis (set (x # xs))\" and dist: \"distinct (x # xs)\"\n  shows \"distinct ((trd xs x) # xs)\"", "lemma subset_comp_red_basis_aux: \"set ys \\<subseteq> set (comp_red_basis_aux xs ys)\"", "lemma comp_red_basis_aux_nonzero:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\" and \"p \\<in> set (comp_red_basis_aux xs ys)\"\n  shows \"p \\<noteq> 0\"", "lemma comp_red_basis_aux_lt:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\"\n  shows \"lt ` set (xs @ ys) = lt ` set (comp_red_basis_aux xs ys)\"", "lemma comp_red_basis_aux_pmdl:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\"\n  shows \"pmdl (set (comp_red_basis_aux xs ys)) \\<subseteq> pmdl (set (xs @ ys))\"", "lemma comp_red_basis_aux_irred:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\"\n    and \"\\<And>y. y \\<in> set ys \\<Longrightarrow> \\<not> is_red (set (xs @ ys) - {y}) y\"\n    and \"p \\<in> set (comp_red_basis_aux xs ys)\"\n  shows \"\\<not> is_red (set (comp_red_basis_aux xs ys) - {p}) p\"", "lemma comp_red_basis_aux_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (comp_red_basis_aux xs ys)) (set xs \\<union> set ys)\"", "lemma comp_red_basis_nonzero:\n  assumes \"p \\<in> set (comp_red_basis xs)\"\n  shows \"p \\<noteq> 0\"", "lemma pmdl_comp_red_basis_subset: \"pmdl (set (comp_red_basis xs)) \\<subseteq> pmdl (set xs)\"", "lemma comp_red_basis_adds:\n  assumes \"p \\<in> set xs\" and \"p \\<noteq> 0\"\n  obtains q where \"q \\<in> set (comp_red_basis xs)\" and \"lt q adds\\<^sub>t lt p\"", "lemma comp_red_basis_lt:\n  assumes \"p \\<in> set (comp_red_basis xs)\"\n  obtains q where \"q \\<in> set xs\" and \"q \\<noteq> 0\" and \"lt q = lt p\"", "lemma comp_red_basis_is_red: \"is_red (set (comp_red_basis xs)) f \\<longleftrightarrow> is_red (set xs) f\"", "lemma comp_red_basis_is_auto_reduced: \"is_auto_reduced (set (comp_red_basis xs))\"", "lemma comp_red_basis_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)\"", "lemma set_comp_red_monic_basis: \"set (comp_red_monic_basis xs) = monic ` (set (comp_red_basis xs))\"", "lemma comp_red_monic_basis_nonzero:\n  assumes \"p \\<in> set (comp_red_monic_basis xs)\"\n  shows \"p \\<noteq> 0\"", "lemma comp_red_monic_basis_is_monic_set: \"is_monic_set (set (comp_red_monic_basis xs))\"", "lemma pmdl_comp_red_monic_basis_subset: \"pmdl (set (comp_red_monic_basis xs)) \\<subseteq> pmdl (set xs)\"", "lemma comp_red_monic_basis_is_auto_reduced: \"is_auto_reduced (set (comp_red_monic_basis xs))\"", "lemma comp_red_monic_basis_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)\""], "translations": [["", "lemma is_red_monic: \"is_red B (monic p) \\<longleftrightarrow> is_red B p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red B (monic p) = is_red B p", "unfolding is_red_adds_iff keys_monic"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f\\<in>B.\n        \\<exists>v\\<in>keys p. f \\<noteq> 0 \\<and> lt f adds\\<^sub>t v) =\n    (\\<exists>f\\<in>B.\n        \\<exists>v\\<in>keys p. f \\<noteq> 0 \\<and> lt f adds\\<^sub>t v)", ".."], ["", "lemma red_image_monic [simp]: \"red (monic ` B) = red B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red (monic ` B) = red B", "proof (rule, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. red (monic ` B) x xa = red B x xa", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. red (monic ` B) x xa = red B x xa", "show \"red (monic ` B) p q \\<longleftrightarrow> red B p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red (monic ` B) p q = red B p q", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "assume \"red (monic ` B) p q\""], ["proof (state)\nthis:\n  red (monic ` B) p q\n\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "then"], ["proof (chain)\npicking this:\n  red (monic ` B) p q", "obtain f t where \"f \\<in> monic ` B\" and *: \"red_single p q f t\""], ["proof (prove)\nusing this:\n  red (monic ` B) p q\n\ngoal (1 subgoal):\n 1. (\\<And>f t.\n        \\<lbrakk>f \\<in> monic ` B; red_single p q f t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule red_setE)"], ["proof (state)\nthis:\n  f \\<in> monic ` B\n  red_single p q f t\n\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "from this(1)"], ["proof (chain)\npicking this:\n  f \\<in> monic ` B", "obtain g where \"g \\<in> B\" and \"f = monic g\""], ["proof (prove)\nusing this:\n  f \\<in> monic ` B\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> B; f = monic g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  g \\<in> B\n  f = monic g\n\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "from *"], ["proof (chain)\npicking this:\n  red_single p q f t", "have \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  red_single p q f t\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by (simp add: red_single_def)"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "hence \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by (simp add: monic_0_iff \\<open>f = monic g\\<close>)"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "hence \"lc g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc g \\<noteq> (0::'b)", "by (rule lc_not_0)"], ["proof (state)\nthis:\n  lc g \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "have eq: \"monom_mult (lc g) 0 f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (lc g) (0::'a) f = g", "by (simp add: \\<open>f = monic g\\<close> mult_lc_monic[OF \\<open>g \\<noteq> 0\\<close>])"], ["proof (state)\nthis:\n  monom_mult (lc g) (0::'a) f = g\n\ngoal (2 subgoals):\n 1. red (monic ` B) p q \\<Longrightarrow> red B p q\n 2. red B p q \\<Longrightarrow> red (monic ` B) p q", "from \\<open>g \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> B", "show \"red B p q\""], ["proof (prove)\nusing this:\n  g \\<in> B\n\ngoal (1 subgoal):\n 1. red B p q", "proof (rule red_setI)"], ["proof (state)\ngoal (1 subgoal):\n 1. red_single p q g ?t", "from * \\<open>lc g \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  red_single p q f t\n  lc g \\<noteq> (0::'b)", "have \"red_single p q (monom_mult (lc g) 0 f) t\""], ["proof (prove)\nusing this:\n  red_single p q f t\n  lc g \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. red_single p q (monom_mult (lc g) (0::'a) f) t", "by (rule red_single_mult_const)"], ["proof (state)\nthis:\n  red_single p q (monom_mult (lc g) (0::'a) f) t\n\ngoal (1 subgoal):\n 1. red_single p q g ?t", "thus \"red_single p q g t\""], ["proof (prove)\nusing this:\n  red_single p q (monom_mult (lc g) (0::'a) f) t\n\ngoal (1 subgoal):\n 1. red_single p q g t", "by (simp only: eq)"], ["proof (state)\nthis:\n  red_single p q g t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  red B p q\n\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "assume \"red B p q\""], ["proof (state)\nthis:\n  red B p q\n\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "then"], ["proof (chain)\npicking this:\n  red B p q", "obtain f t where \"f \\<in> B\" and *: \"red_single p q f t\""], ["proof (prove)\nusing this:\n  red B p q\n\ngoal (1 subgoal):\n 1. (\\<And>f t.\n        \\<lbrakk>f \\<in> B; red_single p q f t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule red_setE)"], ["proof (state)\nthis:\n  f \\<in> B\n  red_single p q f t\n\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "from *"], ["proof (chain)\npicking this:\n  red_single p q f t", "have \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  red_single p q f t\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by (simp add: red_single_def)"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "hence \"lc f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc f \\<noteq> (0::'b)", "by (rule lc_not_0)"], ["proof (state)\nthis:\n  lc f \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "hence \"1 / lc f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lc f \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (1::'b) / lc f \\<noteq> (0::'b)", "by simp"], ["proof (state)\nthis:\n  (1::'b) / lc f \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "from \\<open>f \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> B", "have \"monic f \\<in> monic ` B\""], ["proof (prove)\nusing this:\n  f \\<in> B\n\ngoal (1 subgoal):\n 1. monic f \\<in> monic ` B", "by (rule imageI)"], ["proof (state)\nthis:\n  monic f \\<in> monic ` B\n\ngoal (1 subgoal):\n 1. red B p q \\<Longrightarrow> red (monic ` B) p q", "thus \"red (monic ` B) p q\""], ["proof (prove)\nusing this:\n  monic f \\<in> monic ` B\n\ngoal (1 subgoal):\n 1. red (monic ` B) p q", "proof (rule red_setI)"], ["proof (state)\ngoal (1 subgoal):\n 1. red_single p q (monic f) ?t", "from * \\<open>1 / lc f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  red_single p q f t\n  (1::'b) / lc f \\<noteq> (0::'b)", "show \"red_single p q (monic f) t\""], ["proof (prove)\nusing this:\n  red_single p q f t\n  (1::'b) / lc f \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. red_single p q (monic f) t", "unfolding monic_def"], ["proof (prove)\nusing this:\n  red_single p q f t\n  (1::'b) / lc f \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. red_single p q (monom_mult ((1::'b) / lc f) (0::'a) f) t", "by (rule red_single_mult_const)"], ["proof (state)\nthis:\n  red_single p q (monic f) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  red (monic ` B) p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  red (monic ` B) p q = red B p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_red_image_monic [simp]: \"is_red (monic ` B) p \\<longleftrightarrow> is_red B p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red (monic ` B) p = is_red B p", "by (simp add: is_red_def)"], ["", "subsection \\<open>Minimal Bases and Auto-reduced Bases\\<close>"], ["", "definition is_auto_reduced :: \"('t \\<Rightarrow>\\<^sub>0 'b::field) set \\<Rightarrow> bool\" where\n  \"is_auto_reduced B \\<equiv> (\\<forall>b\\<in>B. \\<not> is_red (B - {b}) b)\""], ["", "definition is_minimal_basis :: \"('t \\<Rightarrow>\\<^sub>0 'b::zero) set \\<Rightarrow> bool\" where\n  \"is_minimal_basis B \\<longleftrightarrow> (0 \\<notin> B \\<and> (\\<forall>p q. p \\<in> B \\<longrightarrow> q \\<in> B \\<longrightarrow> p \\<noteq> q \\<longrightarrow> \\<not> lt p adds\\<^sub>t lt q))\""], ["", "lemma is_auto_reducedD:\n  assumes \"is_auto_reduced B\" and \"b \\<in> B\"\n  shows \"\\<not> is_red (B - {b}) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (B - {b}) b", "using assms"], ["proof (prove)\nusing this:\n  is_auto_reduced B\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<not> is_red (B - {b}) b", "unfolding is_auto_reduced_def"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>B. \\<not> is_red (B - {b}) b\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<not> is_red (B - {b}) b", "by auto"], ["", "text \\<open>The converse of the following lemma is only true if @{term B} is minimal!\\<close>"], ["", "lemma image_monic_is_auto_reduced:\n  assumes \"is_auto_reduced B\"\n  shows \"is_auto_reduced (monic ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_auto_reduced (monic ` B)", "unfolding is_auto_reduced_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>monic ` B. \\<not> is_red (monic ` B - {b}) b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> monic ` B \\<Longrightarrow> \\<not> is_red (monic ` B - {b}) b", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> monic ` B \\<Longrightarrow> \\<not> is_red (monic ` B - {b}) b", "assume \"b \\<in> monic ` B\""], ["proof (state)\nthis:\n  b \\<in> monic ` B\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> monic ` B \\<Longrightarrow> \\<not> is_red (monic ` B - {b}) b", "then"], ["proof (chain)\npicking this:\n  b \\<in> monic ` B", "obtain b' where b_def: \"b = monic b'\" and \"b' \\<in> B\""], ["proof (prove)\nusing this:\n  b \\<in> monic ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b = monic b'; b' \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  b = monic b'\n  b' \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> monic ` B \\<Longrightarrow> \\<not> is_red (monic ` B - {b}) b", "from assms \\<open>b' \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  is_auto_reduced B\n  b' \\<in> B", "have nred: \"\\<not> is_red (B - {b'}) b'\""], ["proof (prove)\nusing this:\n  is_auto_reduced B\n  b' \\<in> B\n\ngoal (1 subgoal):\n 1. \\<not> is_red (B - {b'}) b'", "by (rule is_auto_reducedD)"], ["proof (state)\nthis:\n  \\<not> is_red (B - {b'}) b'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> monic ` B \\<Longrightarrow> \\<not> is_red (monic ` B - {b}) b", "show \"\\<not> is_red ((monic ` B) - {b}) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (monic ` B - {b}) b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. is_red (monic ` B - {b}) b \\<Longrightarrow> False", "assume red: \"is_red ((monic ` B) - {b}) b\""], ["proof (state)\nthis:\n  is_red (monic ` B - {b}) b\n\ngoal (1 subgoal):\n 1. is_red (monic ` B - {b}) b \\<Longrightarrow> False", "have \"(monic ` B) - {b} \\<subseteq> monic ` (B - {b'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic ` B - {b} \\<subseteq> monic ` (B - {b'})", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic ` B - {monic b'} \\<subseteq> monic ` (B - {b'})", "by auto"], ["proof (state)\nthis:\n  monic ` B - {b} \\<subseteq> monic ` (B - {b'})\n\ngoal (1 subgoal):\n 1. is_red (monic ` B - {b}) b \\<Longrightarrow> False", "with red"], ["proof (chain)\npicking this:\n  is_red (monic ` B - {b}) b\n  monic ` B - {b} \\<subseteq> monic ` (B - {b'})", "have \"is_red (monic ` (B - {b'})) b\""], ["proof (prove)\nusing this:\n  is_red (monic ` B - {b}) b\n  monic ` B - {b} \\<subseteq> monic ` (B - {b'})\n\ngoal (1 subgoal):\n 1. is_red (monic ` (B - {b'})) b", "by (rule is_red_subset)"], ["proof (state)\nthis:\n  is_red (monic ` (B - {b'})) b\n\ngoal (1 subgoal):\n 1. is_red (monic ` B - {b}) b \\<Longrightarrow> False", "hence \"is_red (B - {b'}) b'\""], ["proof (prove)\nusing this:\n  is_red (monic ` (B - {b'})) b\n\ngoal (1 subgoal):\n 1. is_red (B - {b'}) b'", "unfolding b_def is_red_monic is_red_image_monic"], ["proof (prove)\nusing this:\n  is_red (B - {b'}) b'\n\ngoal (1 subgoal):\n 1. is_red (B - {b'}) b'", "."], ["proof (state)\nthis:\n  is_red (B - {b'}) b'\n\ngoal (1 subgoal):\n 1. is_red (monic ` B - {b}) b \\<Longrightarrow> False", "with nred"], ["proof (chain)\npicking this:\n  \\<not> is_red (B - {b'}) b'\n  is_red (B - {b'}) b'", "show False"], ["proof (prove)\nusing this:\n  \\<not> is_red (B - {b'}) b'\n  is_red (B - {b'}) b'\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_red (monic ` B - {b}) b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_minimal_basisI:\n  assumes \"\\<And>p. p \\<in> B \\<Longrightarrow> p \\<noteq> 0\" and \"\\<And>p q. p \\<in> B \\<Longrightarrow> q \\<in> B \\<Longrightarrow> p \\<noteq> q \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q\"\n  shows \"is_minimal_basis B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_minimal_basis B", "unfolding is_minimal_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> B \\<and>\n    (\\<forall>p q.\n        p \\<in> B \\<longrightarrow>\n        q \\<in> B \\<longrightarrow>\n        p \\<noteq> q \\<longrightarrow> \\<not> lt p adds\\<^sub>t lt q)", "using assms"], ["proof (prove)\nusing this:\n  ?p30 \\<in> B \\<Longrightarrow> ?p30 \\<noteq> 0\n  \\<lbrakk>?p30 \\<in> B; ?q30 \\<in> B; ?p30 \\<noteq> ?q30\\<rbrakk>\n  \\<Longrightarrow> \\<not> lt ?p30 adds\\<^sub>t lt ?q30\n\ngoal (1 subgoal):\n 1. 0 \\<notin> B \\<and>\n    (\\<forall>p q.\n        p \\<in> B \\<longrightarrow>\n        q \\<in> B \\<longrightarrow>\n        p \\<noteq> q \\<longrightarrow> \\<not> lt p adds\\<^sub>t lt q)", "by auto"], ["", "lemma is_minimal_basisD1:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\"\n  shows \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "unfolding is_minimal_basis_def"], ["proof (prove)\nusing this:\n  0 \\<notin> B \\<and>\n  (\\<forall>p q.\n      p \\<in> B \\<longrightarrow>\n      q \\<in> B \\<longrightarrow>\n      p \\<noteq> q \\<longrightarrow> \\<not> lt p adds\\<^sub>t lt q)\n  p \\<in> B\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["", "lemma is_minimal_basisD2:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"q \\<in> B\" and \"p \\<noteq> q\"\n  shows \"\\<not> lt p adds\\<^sub>t lt q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt p adds\\<^sub>t lt q", "using assms"], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n  q \\<in> B\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<not> lt p adds\\<^sub>t lt q", "unfolding is_minimal_basis_def"], ["proof (prove)\nusing this:\n  0 \\<notin> B \\<and>\n  (\\<forall>p q.\n      p \\<in> B \\<longrightarrow>\n      q \\<in> B \\<longrightarrow>\n      p \\<noteq> q \\<longrightarrow> \\<not> lt p adds\\<^sub>t lt q)\n  p \\<in> B\n  q \\<in> B\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<not> lt p adds\\<^sub>t lt q", "by auto"], ["", "lemma is_minimal_basisD3:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"q \\<in> B\" and \"p \\<noteq> q\"\n  shows \"\\<not> lt q adds\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "using assms"], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n  q \\<in> B\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "unfolding is_minimal_basis_def"], ["proof (prove)\nusing this:\n  0 \\<notin> B \\<and>\n  (\\<forall>p q.\n      p \\<in> B \\<longrightarrow>\n      q \\<in> B \\<longrightarrow>\n      p \\<noteq> q \\<longrightarrow> \\<not> lt p adds\\<^sub>t lt q)\n  p \\<in> B\n  q \\<in> B\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "by auto"], ["", "lemma is_minimal_basis_subset:\n  assumes \"is_minimal_basis B\" and \"A \\<subseteq> B\"\n  shows \"is_minimal_basis A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_minimal_basis A", "proof (intro is_minimal_basisI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> A \\<Longrightarrow> p \\<noteq> 0\n 2. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> A \\<Longrightarrow> p \\<noteq> 0\n 2. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "assume \"p \\<in> A\""], ["proof (state)\nthis:\n  p \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> A \\<Longrightarrow> p \\<noteq> 0\n 2. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "with \\<open>A \\<subseteq> B\\<close>"], ["proof (chain)\npicking this:\n  A \\<subseteq> B\n  p \\<in> A", "have \"p \\<in> B\""], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  p \\<in> A\n\ngoal (1 subgoal):\n 1. p \\<in> B", ".."], ["proof (state)\nthis:\n  p \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>p. p \\<in> A \\<Longrightarrow> p \\<noteq> 0\n 2. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "with \\<open>is_minimal_basis B\\<close>"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  p \\<in> B", "show \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by (rule is_minimal_basisD1)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "assume \"p \\<in> A\" and \"q \\<in> A\" and \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<in> A\n  q \\<in> A\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "from \\<open>p \\<in> A\\<close> and \\<open>q \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> A\n  q \\<in> A", "have \"p \\<in> B\" and \"q \\<in> B\""], ["proof (prove)\nusing this:\n  p \\<in> A\n  q \\<in> A\n\ngoal (1 subgoal):\n 1. p \\<in> B &&& q \\<in> B", "using \\<open>A \\<subseteq> B\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> A\n  q \\<in> A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. p \\<in> B &&& q \\<in> B", "by auto"], ["proof (state)\nthis:\n  p \\<in> B\n  q \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>p \\<in> A; q \\<in> A; p \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt p adds\\<^sub>t lt q", "from \\<open>is_minimal_basis B\\<close> this \\<open>p \\<noteq> q\\<close>"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  p \\<in> B\n  q \\<in> B\n  p \\<noteq> q", "show \" \\<not> lt p adds\\<^sub>t lt q\""], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n  q \\<in> B\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<not> lt p adds\\<^sub>t lt q", "by (rule is_minimal_basisD2)"], ["proof (state)\nthis:\n  \\<not> lt p adds\\<^sub>t lt q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nadds_red:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and red: \"red B p r\"\n  shows \"r \\<noteq> 0 \\<and> lt r = lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "from red"], ["proof (chain)\npicking this:\n  red B p r", "obtain q t where \"q \\<in> B\" and rs: \"red_single p r q t\""], ["proof (prove)\nusing this:\n  red B p r\n\ngoal (1 subgoal):\n 1. (\\<And>q t.\n        \\<lbrakk>q \\<in> B; red_single p r q t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule red_setE)"], ["proof (state)\nthis:\n  q \\<in> B\n  red_single p r q t\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "from rs"], ["proof (chain)\npicking this:\n  red_single p r q t", "have \"q \\<noteq> 0\" and \"lookup p (t \\<oplus> lt q) \\<noteq> 0\"\n    and r_def: \"r = p - monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q\""], ["proof (prove)\nusing this:\n  red_single p r q t\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&&\n    lookup p (t \\<oplus> lt q) \\<noteq> (0::'b) &&&\n    r = p - monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q", "unfolding red_single_def"], ["proof (prove)\nusing this:\n  q \\<noteq> 0 \\<and>\n  lookup p (t \\<oplus> lt q) \\<noteq> (0::'b) \\<and>\n  r = p - monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&&\n    lookup p (t \\<oplus> lt q) \\<noteq> (0::'b) &&&\n    r = p - monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q", "by simp_all"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  lookup p (t \\<oplus> lt q) \\<noteq> (0::'b)\n  r = p - monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "have \"t \\<oplus> lt q \\<preceq>\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus> lt q \\<preceq>\\<^sub>t lt p", "by (rule lt_max, fact)"], ["proof (state)\nthis:\n  t \\<oplus> lt q \\<preceq>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "moreover"], ["proof (state)\nthis:\n  t \\<oplus> lt q \\<preceq>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "have \"t \\<oplus> lt q \\<noteq> lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus> lt q \\<noteq> lt p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<oplus> lt q = lt p \\<Longrightarrow> False", "assume \"t \\<oplus> lt q = lt p\""], ["proof (state)\nthis:\n  t \\<oplus> lt q = lt p\n\ngoal (1 subgoal):\n 1. t \\<oplus> lt q = lt p \\<Longrightarrow> False", "hence \"lt q adds\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  t \\<oplus> lt q = lt p\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p", "by (metis adds_term_triv)"], ["proof (state)\nthis:\n  lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. t \\<oplus> lt q = lt p \\<Longrightarrow> False", "with nadds[OF \\<open>q \\<in> B\\<close>]"], ["proof (chain)\npicking this:\n  \\<not> lt q adds\\<^sub>t lt p\n  lt q adds\\<^sub>t lt p", "show False"], ["proof (prove)\nusing this:\n  \\<not> lt q adds\\<^sub>t lt p\n  lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<oplus> lt q \\<noteq> lt p\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "ultimately"], ["proof (chain)\npicking this:\n  t \\<oplus> lt q \\<preceq>\\<^sub>t lt p\n  t \\<oplus> lt q \\<noteq> lt p", "have \"t \\<oplus> lt q \\<prec>\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  t \\<oplus> lt q \\<preceq>\\<^sub>t lt p\n  t \\<oplus> lt q \\<noteq> lt p\n\ngoal (1 subgoal):\n 1. t \\<oplus> lt q \\<prec>\\<^sub>t lt p", "by simp"], ["proof (state)\nthis:\n  t \\<oplus> lt q \\<prec>\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "let ?m = \"monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q\""], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "from \\<open>lookup p (t \\<oplus> lt q) \\<noteq> 0\\<close> lc_not_0[OF \\<open>q \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  lookup p (t \\<oplus> lt q) \\<noteq> (0::'b)\n  lc q \\<noteq> (0::'b)", "have c0: \"lookup p (t \\<oplus> lt q) / lc q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup p (t \\<oplus> lt q) \\<noteq> (0::'b)\n  lc q \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup p (t \\<oplus> lt q) / lc q \\<noteq> (0::'b)", "by simp"], ["proof (state)\nthis:\n  lookup p (t \\<oplus> lt q) / lc q \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "from \\<open>q \\<noteq> 0\\<close> c0"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  lookup p (t \\<oplus> lt q) / lc q \\<noteq> (0::'b)", "have \"?m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  lookup p (t \\<oplus> lt q) / lc q \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q \\<noteq> 0", "by (simp add: monom_mult_eq_zero_iff)"], ["proof (state)\nthis:\n  monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "have \"lt (-?m) = lt ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n    lt (monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q)", "by (fact lt_uminus)"], ["proof (state)\nthis:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n  lt (monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "also"], ["proof (state)\nthis:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n  lt (monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "have lt1: \"lt ?m = t \\<oplus> lt q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n    t \\<oplus> lt q", "by (rule lt_monom_mult, fact+)"], ["proof (state)\nthis:\n  lt (monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) = t \\<oplus> lt q\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "finally"], ["proof (chain)\npicking this:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n  t \\<oplus> lt q", "have lt2: \"lt (-?m) = t \\<oplus> lt q\""], ["proof (prove)\nusing this:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n  t \\<oplus> lt q\n\ngoal (1 subgoal):\n 1. lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n    t \\<oplus> lt q", "."], ["proof (state)\nthis:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) =\n  t \\<oplus> lt q\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<and> lt r = lt p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<noteq> 0\n 2. lt r = lt p", "show \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> False", "assume \"r = 0\""], ["proof (state)\nthis:\n  r = 0\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> False", "hence \"p = ?m\""], ["proof (prove)\nusing this:\n  r = 0\n\ngoal (1 subgoal):\n 1. p = monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q", "unfolding r_def"], ["proof (prove)\nusing this:\n  p - monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q = 0\n\ngoal (1 subgoal):\n 1. p = monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q", "by simp"], ["proof (state)\nthis:\n  p = monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> False", "with lt1 \\<open>t \\<oplus> lt q \\<noteq> lt p\\<close>"], ["proof (chain)\npicking this:\n  lt (monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) = t \\<oplus> lt q\n  t \\<oplus> lt q \\<noteq> lt p\n  p = monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q", "show False"], ["proof (prove)\nusing this:\n  lt (monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) = t \\<oplus> lt q\n  t \\<oplus> lt q \\<noteq> lt p\n  p = monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt r = lt p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lt r = lt p", "have \"lt (-?m + p) = lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q + p) = lt p", "proof (rule lt_plus_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t\n           q) \\<prec>\\<^sub>t\n    lt p", "show \"lt (-?m) \\<prec>\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t\n           q) \\<prec>\\<^sub>t\n    lt p", "unfolding lt2"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<oplus> lt q \\<prec>\\<^sub>t lt p", "by fact"], ["proof (state)\nthis:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) \\<prec>\\<^sub>t\n  lt p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q + p) = lt p\n\ngoal (1 subgoal):\n 1. lt r = lt p", "thus \"lt r = lt p\""], ["proof (prove)\nusing this:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q + p) = lt p\n\ngoal (1 subgoal):\n 1. lt r = lt p", "unfolding r_def"], ["proof (prove)\nusing this:\n  lt (- monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q + p) = lt p\n\ngoal (1 subgoal):\n 1. lt (p - monom_mult (lookup p (t \\<oplus> lt q) / lc q) t q) = lt p", "by simp"], ["proof (state)\nthis:\n  lt r = lt p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r \\<noteq> 0 \\<and> lt r = lt p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nadds_red_nonzero:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and \"red B p r\"\n  shows \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "using nadds_red[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>q. q \\<in> B \\<Longrightarrow> q \\<in> B) \\<Longrightarrow>\n  r \\<noteq> 0 \\<and> lt r = lt p\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by simp"], ["", "lemma nadds_red_lt:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and \"red B p r\"\n  shows \"lt r = lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt r = lt p", "using nadds_red[OF assms]"], ["proof (prove)\nusing this:\n  (\\<And>q. q \\<in> B \\<Longrightarrow> q \\<in> B) \\<Longrightarrow>\n  r \\<noteq> 0 \\<and> lt r = lt p\n\ngoal (1 subgoal):\n 1. lt r = lt p", "by simp"], ["", "lemma nadds_red_rtrancl_lt:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and rtrancl: \"(red B)\\<^sup>*\\<^sup>* p r\"\n  shows \"lt r = lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt r = lt p", "using rtrancl"], ["proof (prove)\nusing this:\n  (red B)\\<^sup>*\\<^sup>* p r\n\ngoal (1 subgoal):\n 1. lt r = lt p", "proof (induct rule: rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. lt p = lt p\n 2. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z; lt y = lt p\\<rbrakk>\n       \\<Longrightarrow> lt z = lt p", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lt p = lt p\n 2. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z; lt y = lt p\\<rbrakk>\n       \\<Longrightarrow> lt z = lt p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt p = lt p", ".."], ["proof (state)\nthis:\n  lt p = lt p\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z; lt y = lt p\\<rbrakk>\n       \\<Longrightarrow> lt z = lt p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z; lt y = lt p\\<rbrakk>\n       \\<Longrightarrow> lt z = lt p", "case (step y z)"], ["proof (state)\nthis:\n  (red B)\\<^sup>*\\<^sup>* p y\n  red B y z\n  lt y = lt p\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z; lt y = lt p\\<rbrakk>\n       \\<Longrightarrow> lt z = lt p", "have \"lt z = lt y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt z = lt y", "proof (rule nadds_red_lt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt y\n 2. red ?B y z", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt y\n 2. red ?B y z", "assume \"q \\<in> B\""], ["proof (state)\nthis:\n  q \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt y\n 2. red ?B y z", "thus \"\\<not> lt q adds\\<^sub>t lt y\""], ["proof (prove)\nusing this:\n  q \\<in> B\n\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt y", "unfolding \\<open>lt y = lt p\\<close>"], ["proof (prove)\nusing this:\n  q \\<in> B\n\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "by (rule nadds)"], ["proof (state)\nthis:\n  \\<not> lt q adds\\<^sub>t lt y\n\ngoal (1 subgoal):\n 1. red B y z", "qed fact"], ["proof (state)\nthis:\n  lt z = lt y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z; lt y = lt p\\<rbrakk>\n       \\<Longrightarrow> lt z = lt p", "with \\<open>lt y = lt p\\<close>"], ["proof (chain)\npicking this:\n  lt y = lt p\n  lt z = lt y", "show ?case"], ["proof (prove)\nusing this:\n  lt y = lt p\n  lt z = lt y\n\ngoal (1 subgoal):\n 1. lt z = lt p", "by simp"], ["proof (state)\nthis:\n  lt z = lt p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nadds_red_rtrancl_nonzero:\n  assumes nadds: \"\\<And>q. q \\<in> B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\" and \"p \\<noteq> 0\" and rtrancl: \"(red B)\\<^sup>*\\<^sup>* p r\"\n  shows \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "using rtrancl"], ["proof (prove)\nusing this:\n  (red B)\\<^sup>*\\<^sup>* p r\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "proof (induct rule: rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z;\n        y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> z \\<noteq> 0", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z;\n        y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> z \\<noteq> 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by fact"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z;\n        y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> z \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z;\n        y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> z \\<noteq> 0", "case (step y z)"], ["proof (state)\nthis:\n  (red B)\\<^sup>*\\<^sup>* p y\n  red B y z\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z;\n        y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> z \\<noteq> 0", "from nadds \\<open>(red B)\\<^sup>*\\<^sup>* p y\\<close>"], ["proof (chain)\npicking this:\n  ?q30 \\<in> B \\<Longrightarrow> \\<not> lt ?q30 adds\\<^sub>t lt p\n  (red B)\\<^sup>*\\<^sup>* p y", "have \"lt y = lt p\""], ["proof (prove)\nusing this:\n  ?q30 \\<in> B \\<Longrightarrow> \\<not> lt ?q30 adds\\<^sub>t lt p\n  (red B)\\<^sup>*\\<^sup>* p y\n\ngoal (1 subgoal):\n 1. lt y = lt p", "by (rule nadds_red_rtrancl_lt)"], ["proof (state)\nthis:\n  lt y = lt p\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(red B)\\<^sup>*\\<^sup>* p y; red B y z;\n        y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> z \\<noteq> 0", "show \"z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "proof (rule nadds_red_nonzero)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt ?p\n 2. red ?B ?p z", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt ?p\n 2. red ?B ?p z", "assume \"q \\<in> B\""], ["proof (state)\nthis:\n  q \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt ?p\n 2. red ?B ?p z", "thus \"\\<not> lt q adds\\<^sub>t lt y\""], ["proof (prove)\nusing this:\n  q \\<in> B\n\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt y", "unfolding \\<open>lt y = lt p\\<close>"], ["proof (prove)\nusing this:\n  q \\<in> B\n\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "by (rule nadds)"], ["proof (state)\nthis:\n  \\<not> lt q adds\\<^sub>t lt y\n\ngoal (1 subgoal):\n 1. red B y z", "qed fact"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minimal_basis_red_rtrancl_nonzero:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"(red (B - {p}))\\<^sup>*\\<^sup>* p r\"\n  shows \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "proof (rule nadds_red_rtrancl_nonzero)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt ?p\n 2. ?p \\<noteq> 0\n 3. (red ?B)\\<^sup>*\\<^sup>* ?p r", "fix q"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt ?p\n 2. ?p \\<noteq> 0\n 3. (red ?B)\\<^sup>*\\<^sup>* ?p r", "assume \"q \\<in> (B - {p})\""], ["proof (state)\nthis:\n  q \\<in> B - {p}\n\ngoal (3 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt ?p\n 2. ?p \\<noteq> 0\n 3. (red ?B)\\<^sup>*\\<^sup>* ?p r", "hence \"q \\<in> B\" and \"q \\<noteq> p\""], ["proof (prove)\nusing this:\n  q \\<in> B - {p}\n\ngoal (1 subgoal):\n 1. q \\<in> B &&& q \\<noteq> p", "by auto"], ["proof (state)\nthis:\n  q \\<in> B\n  q \\<noteq> p\n\ngoal (3 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt ?p\n 2. ?p \\<noteq> 0\n 3. (red ?B)\\<^sup>*\\<^sup>* ?p r", "show \"\\<not> lt q adds\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "by (rule is_minimal_basisD2, fact+)"], ["proof (state)\nthis:\n  \\<not> lt q adds\\<^sub>t lt p\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. (red (B - {p}))\\<^sup>*\\<^sup>* p r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. (red (B - {p}))\\<^sup>*\\<^sup>* p r", "show \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by (rule is_minimal_basisD1, fact+)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (red (B - {p}))\\<^sup>*\\<^sup>* p r", "qed fact"], ["", "lemma minimal_basis_red_rtrancl_lt:\n  assumes \"is_minimal_basis B\" and \"p \\<in> B\" and \"(red (B - {p}))\\<^sup>*\\<^sup>* p r\"\n  shows \"lt r = lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt r = lt p", "proof (rule nadds_red_rtrancl_lt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\n 2. (red ?B)\\<^sup>*\\<^sup>* p r", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\n 2. (red ?B)\\<^sup>*\\<^sup>* p r", "assume \"q \\<in> (B - {p})\""], ["proof (state)\nthis:\n  q \\<in> B - {p}\n\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\n 2. (red ?B)\\<^sup>*\\<^sup>* p r", "hence \"q \\<in> B\" and \"q \\<noteq> p\""], ["proof (prove)\nusing this:\n  q \\<in> B - {p}\n\ngoal (1 subgoal):\n 1. q \\<in> B &&& q \\<noteq> p", "by auto"], ["proof (state)\nthis:\n  q \\<in> B\n  q \\<noteq> p\n\ngoal (2 subgoals):\n 1. \\<And>q. q \\<in> ?B \\<Longrightarrow> \\<not> lt q adds\\<^sub>t lt p\n 2. (red ?B)\\<^sup>*\\<^sup>* p r", "show \"\\<not> lt q adds\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "by (rule is_minimal_basisD2, fact+)"], ["proof (state)\nthis:\n  \\<not> lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. (red (B - {p}))\\<^sup>*\\<^sup>* p r", "qed fact"], ["", "lemma is_minimal_basis_replace:\n  assumes major: \"is_minimal_basis B\" and \"p \\<in> B\" and red: \"(red (B - {p}))\\<^sup>*\\<^sup>* p r\"\n  shows \"is_minimal_basis (insert r (B - {p}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_minimal_basis (insert r (B - {p}))", "proof (rule is_minimal_basisI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pa. pa \\<in> insert r (B - {p}) \\<Longrightarrow> pa \\<noteq> 0\n 2. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pa. pa \\<in> insert r (B - {p}) \\<Longrightarrow> pa \\<noteq> 0\n 2. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "assume \"q \\<in> insert r (B - {p})\""], ["proof (state)\nthis:\n  q \\<in> insert r (B - {p})\n\ngoal (2 subgoals):\n 1. \\<And>pa. pa \\<in> insert r (B - {p}) \\<Longrightarrow> pa \\<noteq> 0\n 2. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "hence \"q = r \\<or> q \\<in> B \\<and> q \\<noteq> p\""], ["proof (prove)\nusing this:\n  q \\<in> insert r (B - {p})\n\ngoal (1 subgoal):\n 1. q = r \\<or> q \\<in> B \\<and> q \\<noteq> p", "by simp"], ["proof (state)\nthis:\n  q = r \\<or> q \\<in> B \\<and> q \\<noteq> p\n\ngoal (2 subgoals):\n 1. \\<And>pa. pa \\<in> insert r (B - {p}) \\<Longrightarrow> pa \\<noteq> 0\n 2. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "thus \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q = r \\<or> q \\<in> B \\<and> q \\<noteq> p\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. q = r \\<Longrightarrow> q \\<noteq> 0\n 2. q \\<in> B \\<and> q \\<noteq> p \\<Longrightarrow> q \\<noteq> 0", "assume \"q = r\""], ["proof (state)\nthis:\n  q = r\n\ngoal (2 subgoals):\n 1. q = r \\<Longrightarrow> q \\<noteq> 0\n 2. q \\<in> B \\<and> q \\<noteq> p \\<Longrightarrow> q \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  p \\<in> B\n  (red (B - {p}))\\<^sup>*\\<^sup>* p r", "show ?thesis"], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n  (red (B - {p}))\\<^sup>*\\<^sup>* p r\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "unfolding \\<open>q = r\\<close>"], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n  (red (B - {p}))\\<^sup>*\\<^sup>* p r\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by (rule minimal_basis_red_rtrancl_nonzero)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<in> B \\<and> q \\<noteq> p \\<Longrightarrow> q \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in> B \\<and> q \\<noteq> p \\<Longrightarrow> q \\<noteq> 0", "assume \"q \\<in> B \\<and> q \\<noteq> p\""], ["proof (state)\nthis:\n  q \\<in> B \\<and> q \\<noteq> p\n\ngoal (1 subgoal):\n 1. q \\<in> B \\<and> q \\<noteq> p \\<Longrightarrow> q \\<noteq> 0", "hence \"q \\<in> B\""], ["proof (prove)\nusing this:\n  q \\<in> B \\<and> q \\<noteq> p\n\ngoal (1 subgoal):\n 1. q \\<in> B", ".."], ["proof (state)\nthis:\n  q \\<in> B\n\ngoal (1 subgoal):\n 1. q \\<in> B \\<and> q \\<noteq> p \\<Longrightarrow> q \\<noteq> 0", "with major"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  q \\<in> B", "show ?thesis"], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  q \\<in> B\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by (rule is_minimal_basisD1)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "assume \"a \\<in> insert r (B - {p})\" and \"b \\<in> insert r (B - {p})\" and \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<in> insert r (B - {p})\n  b \\<in> insert r (B - {p})\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "from assms"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  p \\<in> B\n  (red (B - {p}))\\<^sup>*\\<^sup>* p r", "have ltr: \"lt r = lt p\""], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n  (red (B - {p}))\\<^sup>*\\<^sup>* p r\n\ngoal (1 subgoal):\n 1. lt r = lt p", "by (rule minimal_basis_red_rtrancl_lt)"], ["proof (state)\nthis:\n  lt r = lt p\n\ngoal (1 subgoal):\n 1. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "from \\<open>b \\<in> insert r (B - {p})\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> insert r (B - {p})", "have b: \"b = r \\<or> b \\<in> B \\<and> b \\<noteq> p\""], ["proof (prove)\nusing this:\n  b \\<in> insert r (B - {p})\n\ngoal (1 subgoal):\n 1. b = r \\<or> b \\<in> B \\<and> b \\<noteq> p", "by simp"], ["proof (state)\nthis:\n  b = r \\<or> b \\<in> B \\<and> b \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "from \\<open>a \\<in> insert r (B - {p})\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> insert r (B - {p})", "have \"a = r \\<or> a \\<in> B \\<and> a \\<noteq> p\""], ["proof (prove)\nusing this:\n  a \\<in> insert r (B - {p})\n\ngoal (1 subgoal):\n 1. a = r \\<or> a \\<in> B \\<and> a \\<noteq> p", "by simp"], ["proof (state)\nthis:\n  a = r \\<or> a \\<in> B \\<and> a \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<And>pa q.\n       \\<lbrakk>pa \\<in> insert r (B - {p}); q \\<in> insert r (B - {p});\n        pa \\<noteq> q\\<rbrakk>\n       \\<Longrightarrow> \\<not> lt pa adds\\<^sub>t lt q", "thus \"\\<not> lt a adds\\<^sub>t lt b\""], ["proof (prove)\nusing this:\n  a = r \\<or> a \\<in> B \\<and> a \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt b", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. a \\<in> B \\<and> a \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "assume \"a = r\""], ["proof (state)\nthis:\n  a = r\n\ngoal (2 subgoals):\n 1. a = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. a \\<in> B \\<and> a \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "hence lta: \"lt a = lt p\""], ["proof (prove)\nusing this:\n  a = r\n\ngoal (1 subgoal):\n 1. lt a = lt p", "using ltr"], ["proof (prove)\nusing this:\n  a = r\n  lt r = lt p\n\ngoal (1 subgoal):\n 1. lt a = lt p", "by simp"], ["proof (state)\nthis:\n  lt a = lt p\n\ngoal (2 subgoals):\n 1. a = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. a \\<in> B \\<and> a \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "from b"], ["proof (chain)\npicking this:\n  b = r \\<or> b \\<in> B \\<and> b \\<noteq> p", "show ?thesis"], ["proof (prove)\nusing this:\n  b = r \\<or> b \\<in> B \\<and> b \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt b", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "assume \"b = r\""], ["proof (state)\nthis:\n  b = r\n\ngoal (2 subgoals):\n 1. b = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "with \\<open>a \\<noteq> b\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  b = r", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  b = r\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt b", "unfolding \\<open>a = r\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> b\n  b = r\n\ngoal (1 subgoal):\n 1. \\<not> lt r adds\\<^sub>t lt b", "by simp"], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt b\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "assume \"b \\<in> B \\<and> b \\<noteq> p\""], ["proof (state)\nthis:\n  b \\<in> B \\<and> b \\<noteq> p\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "hence \"b \\<in> B\" and \"p \\<noteq> b\""], ["proof (prove)\nusing this:\n  b \\<in> B \\<and> b \\<noteq> p\n\ngoal (1 subgoal):\n 1. b \\<in> B &&& p \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  b \\<in> B\n  p \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "with major \\<open>p \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  p \\<in> B\n  b \\<in> B\n  p \\<noteq> b", "have \"\\<not> lt p adds\\<^sub>t lt b\""], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  p \\<in> B\n  b \\<in> B\n  p \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> lt p adds\\<^sub>t lt b", "by (rule is_minimal_basisD2)"], ["proof (state)\nthis:\n  \\<not> lt p adds\\<^sub>t lt b\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lt p adds\\<^sub>t lt b\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt b", "unfolding lta"], ["proof (prove)\nusing this:\n  \\<not> lt p adds\\<^sub>t lt b\n\ngoal (1 subgoal):\n 1. \\<not> lt p adds\\<^sub>t lt b", "."], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt b\n\ngoal (1 subgoal):\n 1. a \\<in> B \\<and> a \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> B \\<and> a \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "assume \"a \\<in> B \\<and> a \\<noteq> p\""], ["proof (state)\nthis:\n  a \\<in> B \\<and> a \\<noteq> p\n\ngoal (1 subgoal):\n 1. a \\<in> B \\<and> a \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "hence \"a \\<in> B\" and \"a \\<noteq> p\""], ["proof (prove)\nusing this:\n  a \\<in> B \\<and> a \\<noteq> p\n\ngoal (1 subgoal):\n 1. a \\<in> B &&& a \\<noteq> p", "by simp_all"], ["proof (state)\nthis:\n  a \\<in> B\n  a \\<noteq> p\n\ngoal (1 subgoal):\n 1. a \\<in> B \\<and> a \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "from b"], ["proof (chain)\npicking this:\n  b = r \\<or> b \\<in> B \\<and> b \\<noteq> p", "show ?thesis"], ["proof (prove)\nusing this:\n  b = r \\<or> b \\<in> B \\<and> b \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt b", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. b = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "assume \"b = r\""], ["proof (state)\nthis:\n  b = r\n\ngoal (2 subgoals):\n 1. b = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "from major \\<open>a \\<in> B\\<close> \\<open>p \\<in> B\\<close> \\<open>a \\<noteq> p\\<close>"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  a \\<in> B\n  p \\<in> B\n  a \\<noteq> p", "have \"\\<not> lt a adds\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  a \\<in> B\n  p \\<in> B\n  a \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt p", "by (rule is_minimal_basisD2)"], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt p\n\ngoal (2 subgoals):\n 1. b = r \\<Longrightarrow> \\<not> lt a adds\\<^sub>t lt b\n 2. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lt a adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt b", "unfolding \\<open>b = r\\<close> ltr"], ["proof (prove)\nusing this:\n  \\<not> lt a adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt p", "by simp"], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt b\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "assume \"b \\<in> B \\<and> b \\<noteq> p\""], ["proof (state)\nthis:\n  b \\<in> B \\<and> b \\<noteq> p\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "hence \"b \\<in> B\""], ["proof (prove)\nusing this:\n  b \\<in> B \\<and> b \\<noteq> p\n\ngoal (1 subgoal):\n 1. b \\<in> B", ".."], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. b \\<in> B \\<and> b \\<noteq> p \\<Longrightarrow>\n    \\<not> lt a adds\\<^sub>t lt b", "from major \\<open>a \\<in> B\\<close> \\<open>b \\<in> B\\<close> \\<open>a \\<noteq> b\\<close>"], ["proof (chain)\npicking this:\n  is_minimal_basis B\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b", "show ?thesis"], ["proof (prove)\nusing this:\n  is_minimal_basis B\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> lt a adds\\<^sub>t lt b", "by (rule is_minimal_basisD2)"], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt a adds\\<^sub>t lt b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Computing Minimal Bases\\<close>"], ["", "definition comp_min_basis :: \"('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::zero) list\" where\n  \"comp_min_basis xs = filter_min (\\<lambda>x y. lt x adds\\<^sub>t lt y) (filter (\\<lambda>x. x \\<noteq> 0) xs)\""], ["", "lemma comp_min_basis_subset': \"set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "have \"set (comp_min_basis xs) \\<subseteq> set (filter (\\<lambda>x. x \\<noteq> 0) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (comp_min_basis xs)\n    \\<subseteq> set (filter (\\<lambda>x. x \\<noteq> 0) xs)", "unfolding comp_min_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter_min (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n          (filter (\\<lambda>x. x \\<noteq> 0) xs))\n    \\<subseteq> set (filter (\\<lambda>x. x \\<noteq> 0) xs)", "by (rule filter_min_subset)"], ["proof (state)\nthis:\n  set (comp_min_basis xs)\n  \\<subseteq> set (filter (\\<lambda>x. x \\<noteq> 0) xs)\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "also"], ["proof (state)\nthis:\n  set (comp_min_basis xs)\n  \\<subseteq> set (filter (\\<lambda>x. x \\<noteq> 0) xs)\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "have \"\\<dots> = {x \\<in> set xs. x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>x. x \\<noteq> 0) xs) =\n    {x \\<in> set xs. x \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  set (filter (\\<lambda>x. x \\<noteq> 0) xs) =\n  {x \\<in> set xs. x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "finally"], ["proof (chain)\npicking this:\n  set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "."], ["proof (state)\nthis:\n  set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_min_basis_subset: \"set (comp_min_basis xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> set xs", "have \"set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}", "by (rule comp_min_basis_subset')"], ["proof (state)\nthis:\n  set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> set xs", "also"], ["proof (state)\nthis:\n  set (comp_min_basis xs) \\<subseteq> {x \\<in> set xs. x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> set xs", "have \"... \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> set xs. x \\<noteq> 0} \\<subseteq> set xs", "by simp"], ["proof (state)\nthis:\n  {x \\<in> set xs. x \\<noteq> 0} \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> set xs", "finally"], ["proof (chain)\npicking this:\n  set (comp_min_basis xs) \\<subseteq> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  set (comp_min_basis xs) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<subseteq> set xs", "."], ["proof (state)\nthis:\n  set (comp_min_basis xs) \\<subseteq> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_min_basis_nonzero: \"p \\<in> set (comp_min_basis xs) \\<Longrightarrow> p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set (comp_min_basis xs) \\<Longrightarrow> p \\<noteq> 0", "using comp_min_basis_subset'"], ["proof (prove)\nusing this:\n  set (comp_min_basis ?xs) \\<subseteq> {x \\<in> set ?xs. x \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_min_basis xs) \\<Longrightarrow> p \\<noteq> 0", "by blast"], ["", "lemma comp_min_basis_adds:\n  assumes \"p \\<in> set xs\" and \"p \\<noteq> 0\"\n  obtains q where \"q \\<in> set (comp_min_basis xs)\" and \"lt q adds\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?rel = \"(\\<lambda>x y. lt x adds\\<^sub>t lt y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"transp ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)", "by (auto intro!: transpI dest: adds_term_trans)"], ["proof (state)\nthis:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"reflp ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp (\\<lambda>x y. lt x adds\\<^sub>t lt y)", "by (simp add: reflp_def adds_term_refl)"], ["proof (state)\nthis:\n  reflp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  reflp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> set xs\n  p \\<noteq> 0", "have \"p \\<in> set (filter (\\<lambda>x. x \\<noteq> 0) xs)\""], ["proof (prove)\nusing this:\n  p \\<in> set xs\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<in> set (filter (\\<lambda>x. x \\<noteq> 0) xs)", "by simp"], ["proof (state)\nthis:\n  p \\<in> set (filter (\\<lambda>x. x \\<noteq> 0) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  reflp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  p \\<in> set (filter (\\<lambda>x. x \\<noteq> 0) xs)", "obtain q where \"q \\<in> set (comp_min_basis xs)\" and \"lt q adds\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  reflp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  p \\<in> set (filter (\\<lambda>x. x \\<noteq> 0) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding comp_min_basis_def"], ["proof (prove)\nusing this:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  reflp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  p \\<in> set (filter (\\<lambda>x. x \\<noteq> 0) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (filter_min\n                               (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n                               (filter (\\<lambda>x. x \\<noteq> 0) xs));\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule filter_min_relE)"], ["proof (state)\nthis:\n  q \\<in> set (comp_min_basis xs)\n  lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> set (comp_min_basis xs)\n  lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_min_basis_is_red:\n  assumes \"is_red (set xs) f\"\n  shows \"is_red (set (comp_min_basis xs)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red (set (comp_min_basis xs)) f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_red (set (comp_min_basis xs)) f", "from assms"], ["proof (chain)\npicking this:\n  is_red (set xs) f", "obtain x t where \"x \\<in> set xs\" and \"t \\<in> keys f\" and \"x \\<noteq> 0\" and \"lt x adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  is_red (set xs) f\n\ngoal (1 subgoal):\n 1. (\\<And>x t.\n        \\<lbrakk>x \\<in> set xs; t \\<in> keys f; x \\<noteq> 0;\n         lt x adds\\<^sub>t t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_red_addsE)"], ["proof (state)\nthis:\n  x \\<in> set xs\n  t \\<in> keys f\n  x \\<noteq> 0\n  lt x adds\\<^sub>t t\n\ngoal (1 subgoal):\n 1. is_red (set (comp_min_basis xs)) f", "from \\<open>x \\<in> set xs\\<close> \\<open>x \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  x \\<noteq> 0", "obtain y where yin: \"y \\<in> set (comp_min_basis xs)\" and \"lt y adds\\<^sub>t lt x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (comp_min_basis xs);\n         lt y adds\\<^sub>t lt x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule comp_min_basis_adds)"], ["proof (state)\nthis:\n  y \\<in> set (comp_min_basis xs)\n  lt y adds\\<^sub>t lt x\n\ngoal (1 subgoal):\n 1. is_red (set (comp_min_basis xs)) f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red (set (comp_min_basis xs)) f", "proof (rule is_red_addsI)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?f \\<in> set (comp_min_basis xs)\n 2. ?f \\<noteq> 0\n 3. ?v \\<in> keys f\n 4. lt ?f adds\\<^sub>t ?v", "from \\<open>lt y adds\\<^sub>t lt x\\<close> \\<open>lt x adds\\<^sub>t t\\<close>"], ["proof (chain)\npicking this:\n  lt y adds\\<^sub>t lt x\n  lt x adds\\<^sub>t t", "show \"lt y adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  lt y adds\\<^sub>t lt x\n  lt x adds\\<^sub>t t\n\ngoal (1 subgoal):\n 1. lt y adds\\<^sub>t t", "by (rule adds_term_trans)"], ["proof (state)\nthis:\n  lt y adds\\<^sub>t t\n\ngoal (3 subgoals):\n 1. y \\<in> set (comp_min_basis xs)\n 2. y \\<noteq> 0\n 3. t \\<in> keys f", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. y \\<in> set (comp_min_basis xs)\n 2. y \\<noteq> 0\n 3. t \\<in> keys f", "from yin"], ["proof (chain)\npicking this:\n  y \\<in> set (comp_min_basis xs)", "show \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<in> set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by (rule comp_min_basis_nonzero)"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y \\<in> set (comp_min_basis xs)\n 2. t \\<in> keys f", "qed fact+"], ["proof (state)\nthis:\n  is_red (set (comp_min_basis xs)) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_min_basis_nadds:\n  assumes \"p \\<in> set (comp_min_basis xs)\" and \"q \\<in> set (comp_min_basis xs)\" and \"p \\<noteq> q\"\n  shows \"\\<not> lt q adds\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lt q adds\\<^sub>t lt p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p \\<Longrightarrow> False", "have \"transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)", "by (auto intro!: transpI dest: adds_term_trans)"], ["proof (state)\nthis:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p \\<Longrightarrow> False", "note assms(2, 1)"], ["proof (state)\nthis:\n  q \\<in> set (comp_min_basis xs)\n  p \\<in> set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  q \\<in> set (comp_min_basis xs)\n  p \\<in> set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p \\<Longrightarrow> False", "assume \"lt q adds\\<^sub>t lt p\""], ["proof (state)\nthis:\n  lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  q \\<in> set (comp_min_basis xs)\n  p \\<in> set (comp_min_basis xs)\n  lt q adds\\<^sub>t lt p", "have \"q = p\""], ["proof (prove)\nusing this:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  q \\<in> set (comp_min_basis xs)\n  p \\<in> set (comp_min_basis xs)\n  lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. q = p", "unfolding comp_min_basis_def"], ["proof (prove)\nusing this:\n  transp (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n  q \\<in> set (filter_min (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n                (filter (\\<lambda>x. x \\<noteq> 0) xs))\n  p \\<in> set (filter_min (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n                (filter (\\<lambda>x. x \\<noteq> 0) xs))\n  lt q adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. q = p", "by (rule filter_min_minimal)"], ["proof (state)\nthis:\n  q = p\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p \\<Longrightarrow> False", "with assms(3)"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  q = p", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  q = p\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_min_basis_is_minimal_basis: \"is_minimal_basis (set (comp_min_basis xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_minimal_basis (set (comp_min_basis xs))", "by (rule is_minimal_basisI, rule comp_min_basis_nonzero, assumption, rule comp_min_basis_nadds,\n      assumption+, simp)"], ["", "lemma comp_min_basis_distinct: \"distinct (comp_min_basis xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (comp_min_basis xs)", "unfolding comp_min_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (filter_min (\\<lambda>x y. lt x adds\\<^sub>t lt y)\n       (filter (\\<lambda>x. x \\<noteq> 0) xs))", "by (rule filter_min_distinct) (simp add: reflp_def adds_term_refl)"], ["", "end"], ["", "(* ordered_term *)"], ["", "subsection \\<open>Auto-Reduction\\<close>"], ["", "context gd_term\nbegin"], ["", "lemma is_minimal_basis_trd_is_minimal_basis:\n  assumes \"is_minimal_basis (set (x # xs))\" and \"x \\<notin> set xs\"\n  shows \"is_minimal_basis (set ((trd xs x) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd xs x # xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd xs x # xs))", "from assms(1)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set (x # xs))", "have \"is_minimal_basis (insert (trd xs x) (set (x # xs) - {x}))\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set (x # xs))\n\ngoal (1 subgoal):\n 1. is_minimal_basis (insert (trd xs x) (set (x # xs) - {x}))", "proof (rule is_minimal_basis_replace, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)", "from assms(2)"], ["proof (chain)\npicking this:\n  x \\<notin> set xs", "have eq: \"set (x # xs) - {x} = set xs\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. set (x # xs) - {x} = set xs", "by simp"], ["proof (state)\nthis:\n  set (x # xs) - {x} = set xs\n\ngoal (1 subgoal):\n 1. (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)", "show \"(red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set xs))\\<^sup>*\\<^sup>* x (trd xs x)", "by (rule trd_red_rtrancl)"], ["proof (state)\nthis:\n  (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_minimal_basis (insert (trd xs x) (set (x # xs) - {x}))\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd xs x # xs))", "also"], ["proof (state)\nthis:\n  is_minimal_basis (insert (trd xs x) (set (x # xs) - {x}))\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd xs x # xs))", "from assms(2)"], ["proof (chain)\npicking this:\n  x \\<notin> set xs", "have \"... = set ((trd xs x) # xs)\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. insert (trd xs x) (set (x # xs) - {x}) = set (trd xs x # xs)", "by auto"], ["proof (state)\nthis:\n  insert (trd xs x) (set (x # xs) - {x}) = set (trd xs x # xs)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd xs x # xs))", "finally"], ["proof (chain)\npicking this:\n  is_minimal_basis (set (trd xs x # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (trd xs x # xs))\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd xs x # xs))", "."], ["proof (state)\nthis:\n  is_minimal_basis (set (trd xs x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_minimal_basis_trd_distinct:\n  assumes min: \"is_minimal_basis (set (x # xs))\" and dist: \"distinct (x # xs)\"\n  shows \"distinct ((trd xs x) # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "let ?y = \"trd xs x\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "from min"], ["proof (chain)\npicking this:\n  is_minimal_basis (set (x # xs))", "have lty: \"lt ?y = lt x\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set (x # xs))\n\ngoal (1 subgoal):\n 1. lt (trd xs x) = lt x", "proof (rule minimal_basis_red_rtrancl_lt, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)", "from dist"], ["proof (chain)\npicking this:\n  distinct (x # xs)", "have \"x \\<notin> set xs\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)", "hence eq: \"set (x # xs) - {x} = set xs\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. set (x # xs) - {x} = set xs", "by simp"], ["proof (state)\nthis:\n  set (x # xs) - {x} = set xs\n\ngoal (1 subgoal):\n 1. (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)", "show \"(red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set xs))\\<^sup>*\\<^sup>* x (trd xs x)", "by (rule trd_red_rtrancl)"], ["proof (state)\nthis:\n  (red (set (x # xs) - {x}))\\<^sup>*\\<^sup>* x (trd xs x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (trd xs x) = lt x\n\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "have \"?y \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd xs x \\<notin> set xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. trd xs x \\<in> set xs \\<Longrightarrow> False", "assume \"?y \\<in> set xs\""], ["proof (state)\nthis:\n  trd xs x \\<in> set xs\n\ngoal (1 subgoal):\n 1. trd xs x \\<in> set xs \\<Longrightarrow> False", "hence \"?y \\<in> set (x # xs)\""], ["proof (prove)\nusing this:\n  trd xs x \\<in> set xs\n\ngoal (1 subgoal):\n 1. trd xs x \\<in> set (x # xs)", "by simp"], ["proof (state)\nthis:\n  trd xs x \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. trd xs x \\<in> set xs \\<Longrightarrow> False", "with min"], ["proof (chain)\npicking this:\n  is_minimal_basis (set (x # xs))\n  trd xs x \\<in> set (x # xs)", "have \"\\<not> lt ?y adds\\<^sub>t lt x\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set (x # xs))\n  trd xs x \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<not> lt (trd xs x) adds\\<^sub>t lt x", "proof (rule is_minimal_basisD2, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. trd xs x \\<noteq> x", "show \"?y \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd xs x \\<noteq> x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. trd xs x = x \\<Longrightarrow> False", "assume \"?y = x\""], ["proof (state)\nthis:\n  trd xs x = x\n\ngoal (1 subgoal):\n 1. trd xs x = x \\<Longrightarrow> False", "from dist"], ["proof (chain)\npicking this:\n  distinct (x # xs)", "have \"x \\<notin> set xs\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs", "by simp"], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. trd xs x = x \\<Longrightarrow> False", "with \\<open>?y \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  trd xs x \\<in> set xs\n  x \\<notin> set xs", "show False"], ["proof (prove)\nusing this:\n  trd xs x \\<in> set xs\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<open>?y = x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trd xs x \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> lt (trd xs x) adds\\<^sub>t lt x\n\ngoal (1 subgoal):\n 1. trd xs x \\<in> set xs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> lt (trd xs x) adds\\<^sub>t lt x\n\ngoal (1 subgoal):\n 1. False", "unfolding lty"], ["proof (prove)\nusing this:\n  \\<not> lt x adds\\<^sub>t lt x\n\ngoal (1 subgoal):\n 1. False", "by (simp add: adds_term_refl)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trd xs x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "moreover"], ["proof (state)\nthis:\n  trd xs x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "from dist"], ["proof (chain)\npicking this:\n  distinct (x # xs)", "have \"distinct xs\""], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. distinct xs", "by simp"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "ultimately"], ["proof (chain)\npicking this:\n  trd xs x \\<notin> set xs\n  distinct xs", "show ?thesis"], ["proof (prove)\nusing this:\n  trd xs x \\<notin> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. distinct (trd xs x # xs)", "by simp"], ["proof (state)\nthis:\n  distinct (trd xs x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec comp_red_basis_aux :: \"('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::field) list\" where\n  comp_red_basis_aux_base: \"comp_red_basis_aux Nil ys = ys\"|\n  comp_red_basis_aux_rec: \"comp_red_basis_aux (x # xs) ys = comp_red_basis_aux xs ((trd (xs @ ys) x) # ys)\""], ["", "lemma subset_comp_red_basis_aux: \"set ys \\<subseteq> set (comp_red_basis_aux xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (comp_red_basis_aux xs ys)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. set ys \\<subseteq> set (comp_red_basis_aux [] ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys. set ys \\<subseteq> set (comp_red_basis_aux [] ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (comp_red_basis_aux [] ys)", "unfolding comp_red_basis_aux_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set ys", ".."], ["proof (state)\nthis:\n  set ys \\<subseteq> set (comp_red_basis_aux [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "case (Cons a xs)"], ["proof (state)\nthis:\n  set ?ys36 \\<subseteq> set (comp_red_basis_aux xs ?ys36)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "have \"set ys \\<subseteq> set ((trd (xs @ ys) a) # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (trd (xs @ ys) a # ys)", "by auto"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (trd (xs @ ys) a # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "also"], ["proof (state)\nthis:\n  set ys \\<subseteq> set (trd (xs @ ys) a # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "have \"... \\<subseteq> set (comp_red_basis_aux xs ((trd (xs @ ys) a) # ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (trd (xs @ ys) a # ys)\n    \\<subseteq> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "by (rule Cons.hyps)"], ["proof (state)\nthis:\n  set (trd (xs @ ys) a # ys)\n  \\<subseteq> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           set ys\n           \\<subseteq> set (comp_red_basis_aux xs ys)) \\<Longrightarrow>\n       set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "finally"], ["proof (chain)\npicking this:\n  set ys \\<subseteq> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "show ?case"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)", "unfolding comp_red_basis_aux_rec"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "."], ["proof (state)\nthis:\n  set ys \\<subseteq> set (comp_red_basis_aux (a # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_aux_nonzero:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\" and \"p \\<in> set (comp_red_basis_aux xs ys)\"\n  shows \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (xs @ ys))\n  distinct (xs @ ys)\n  p \\<in> set (comp_red_basis_aux xs ys)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys)); distinct ([] @ ys);\n        p \\<in> set (comp_red_basis_aux [] ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "case Nil"], ["proof (state)\nthis:\n  is_minimal_basis (set ([] @ ys))\n  distinct ([] @ ys)\n  p \\<in> set (comp_red_basis_aux [] ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys)); distinct ([] @ ys);\n        p \\<in> set (comp_red_basis_aux [] ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "proof (rule is_minimal_basisD1)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_minimal_basis ?B\n 2. p \\<in> ?B", "from Nil(1)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ([] @ ys))", "show \"is_minimal_basis (set ys)\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ([] @ ys))\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set ys)", "by simp"], ["proof (state)\nthis:\n  is_minimal_basis (set ys)\n\ngoal (1 subgoal):\n 1. p \\<in> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> set ys", "from Nil(3)"], ["proof (chain)\npicking this:\n  p \\<in> set (comp_red_basis_aux [] ys)", "show \"p \\<in> set ys\""], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis_aux [] ys)\n\ngoal (1 subgoal):\n 1. p \\<in> set ys", "unfolding comp_red_basis_aux_base"], ["proof (prove)\nusing this:\n  p \\<in> set ys\n\ngoal (1 subgoal):\n 1. p \\<in> set ys", "."], ["proof (state)\nthis:\n  p \\<in> set ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>is_minimal_basis (set (xs @ ?ys36)); distinct (xs @ ?ys36);\n   p \\<in> set (comp_red_basis_aux xs ?ys36)\\<rbrakk>\n  \\<Longrightarrow> p \\<noteq> 0\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)\n  p \\<in> set (comp_red_basis_aux (a # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "have eq: \"(a # xs) @ ys = a # (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # xs) @ ys = a # xs @ ys", "by simp"], ["proof (state)\nthis:\n  (a # xs) @ ys = a # xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "have \"a \\<in> set (a # xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (a # xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "have \"a \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "let ?ys = \"trd (xs @ ys) a # ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> p \\<noteq> 0;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (3 subgoals):\n 1. is_minimal_basis (set (xs @ ?ys36))\n 2. distinct (xs @ ?ys36)\n 3. p \\<in> set (comp_red_basis_aux xs ?ys36)", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "have \"a \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (xs @ ys)\n\ngoal (3 subgoals):\n 1. is_minimal_basis (set (xs @ ?ys36))\n 2. distinct (xs @ ?ys36)\n 3. p \\<in> set (comp_red_basis_aux xs ?ys36)", "with Cons(2)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)", "show \"is_minimal_basis (set (xs @ ?ys))\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))", "unfolding set_reorder eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd (xs @ ys) a # xs @ ys))", "by (rule is_minimal_basis_trd_is_minimal_basis)"], ["proof (state)\nthis:\n  is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n\ngoal (2 subgoals):\n 1. distinct (xs @ trd (xs @ ys) a # ys)\n 2. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (xs @ trd (xs @ ys) a # ys)\n 2. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "from Cons(2) Cons(3)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)", "show \"distinct (xs @ ?ys)\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "unfolding distinct_reorder eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. distinct (trd (xs @ ys) a # xs @ ys)", "by (rule is_minimal_basis_trd_distinct)"], ["proof (state)\nthis:\n  distinct (xs @ trd (xs @ ys) a # ys)\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "from Cons(4)"], ["proof (chain)\npicking this:\n  p \\<in> set (comp_red_basis_aux (a # xs) ys)", "show \"p \\<in> set (comp_red_basis_aux xs ?ys)\""], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis_aux (a # xs) ys)\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "unfolding comp_red_basis_aux_rec"], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "."], ["proof (state)\nthis:\n  p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_aux_lt:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\"\n  shows \"lt ` set (xs @ ys) = lt ` set (comp_red_basis_aux xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (xs @ ys) = lt ` set (comp_red_basis_aux xs ys)", "using assms"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (xs @ ys))\n  distinct (xs @ ys)\n\ngoal (1 subgoal):\n 1. lt ` set (xs @ ys) = lt ` set (comp_red_basis_aux xs ys)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys));\n        distinct ([] @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ([] @ ys) =\n                         lt ` set (comp_red_basis_aux [] ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "case Nil"], ["proof (state)\nthis:\n  is_minimal_basis (set ([] @ ys))\n  distinct ([] @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys));\n        distinct ([] @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ([] @ ys) =\n                         lt ` set (comp_red_basis_aux [] ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set ([] @ ys) = lt ` set (comp_red_basis_aux [] ys)", "unfolding comp_red_basis_aux_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set ([] @ ys) = lt ` set ys", "by simp"], ["proof (state)\nthis:\n  lt ` set ([] @ ys) = lt ` set (comp_red_basis_aux [] ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>is_minimal_basis (set (xs @ ?ys36));\n   distinct (xs @ ?ys36)\\<rbrakk>\n  \\<Longrightarrow> lt ` set (xs @ ?ys36) =\n                    lt ` set (comp_red_basis_aux xs ?ys36)\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "have eq: \"(a # xs) @ ys = a # (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # xs) @ ys = a # xs @ ys", "by simp"], ["proof (state)\nthis:\n  (a # xs) @ ys = a # xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "have a: \"a \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "let ?b = \"trd (xs @ ys) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "let ?ys = \"?b # ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "from Cons(2)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))", "have \"lt ?b = lt a\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n\ngoal (1 subgoal):\n 1. lt (trd (xs @ ys) a) = lt a", "unfolding eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. lt (trd (xs @ ys) a) = lt a", "proof (rule minimal_basis_red_rtrancl_lt, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "from a"], ["proof (chain)\npicking this:\n  a \\<notin> set (xs @ ys)", "have eq2: \"set (a # xs @ ys) - {a} = set (xs @ ys)\""], ["proof (prove)\nusing this:\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. set (a # xs @ ys) - {a} = set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  set (a # xs @ ys) - {a} = set (xs @ ys)\n\ngoal (1 subgoal):\n 1. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "show \"(red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "unfolding eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set (xs @ ys)))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "by (rule trd_red_rtrancl)"], ["proof (state)\nthis:\n  (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (trd (xs @ ys) a) = lt a\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "hence \"lt ` set ((a # xs) @ ys) = lt ` set ((?b # xs) @ ys)\""], ["proof (prove)\nusing this:\n  lt (trd (xs @ ys) a) = lt a\n\ngoal (1 subgoal):\n 1. lt ` set ((a # xs) @ ys) = lt ` set ((trd (xs @ ys) a # xs) @ ys)", "by simp"], ["proof (state)\nthis:\n  lt ` set ((a # xs) @ ys) = lt ` set ((trd (xs @ ys) a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "also"], ["proof (state)\nthis:\n  lt ` set ((a # xs) @ ys) = lt ` set ((trd (xs @ ys) a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "have \"... = lt ` set (xs @ (?b # ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set ((trd (xs @ ys) a # xs) @ ys) =\n    lt ` set (xs @ trd (xs @ ys) a # ys)", "by simp"], ["proof (state)\nthis:\n  lt ` set ((trd (xs @ ys) a # xs) @ ys) =\n  lt ` set (xs @ trd (xs @ ys) a # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "finally"], ["proof (chain)\npicking this:\n  lt ` set ((a # xs) @ ys) = lt ` set (xs @ trd (xs @ ys) a # ys)", "have eq2: \"lt ` set ((a # xs) @ ys) = lt ` set (xs @ (?b # ys))\""], ["proof (prove)\nusing this:\n  lt ` set ((a # xs) @ ys) = lt ` set (xs @ trd (xs @ ys) a # ys)\n\ngoal (1 subgoal):\n 1. lt ` set ((a # xs) @ ys) = lt ` set (xs @ trd (xs @ ys) a # ys)", "."], ["proof (state)\nthis:\n  lt ` set ((a # xs) @ ys) = lt ` set (xs @ trd (xs @ ys) a # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> lt ` set (xs @ ys) =\n                                     lt ` set (comp_red_basis_aux xs ys);\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> lt ` set ((a # xs) @ ys) =\n                         lt ` set (comp_red_basis_aux (a # xs) ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set ((a # xs) @ ys) = lt ` set (comp_red_basis_aux (a # xs) ys)", "unfolding comp_red_basis_aux_rec eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (xs @ trd (xs @ ys) a # ys) =\n    lt ` set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n 2. distinct (xs @ trd (xs @ ys) a # ys)", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "have \"a \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (xs @ ys)\n\ngoal (2 subgoals):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n 2. distinct (xs @ trd (xs @ ys) a # ys)", "with Cons(2)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)", "show \"is_minimal_basis (set (xs @ ?ys))\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))", "unfolding set_reorder eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd (xs @ ys) a # xs @ ys))", "by (rule is_minimal_basis_trd_is_minimal_basis)"], ["proof (state)\nthis:\n  is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "from Cons(2) Cons(3)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)", "show \"distinct (xs @ ?ys)\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "unfolding distinct_reorder eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. distinct (trd (xs @ ys) a # xs @ ys)", "by (rule is_minimal_basis_trd_distinct)"], ["proof (state)\nthis:\n  distinct (xs @ trd (xs @ ys) a # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt ` set ((a # xs) @ ys) = lt ` set (comp_red_basis_aux (a # xs) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_aux_pmdl:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\"\n  shows \"pmdl (set (comp_red_basis_aux xs ys)) \\<subseteq> pmdl (set (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux xs ys)) \\<subseteq> pmdl (set (xs @ ys))", "using assms"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (xs @ ys))\n  distinct (xs @ ys)\n\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux xs ys)) \\<subseteq> pmdl (set (xs @ ys))", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys));\n        distinct ([] @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux [] ys))\n                         \\<subseteq> pmdl (set ([] @ ys))\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "case Nil"], ["proof (state)\nthis:\n  is_minimal_basis (set ([] @ ys))\n  distinct ([] @ ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys));\n        distinct ([] @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux [] ys))\n                         \\<subseteq> pmdl (set ([] @ ys))\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux [] ys)) \\<subseteq> pmdl (set ([] @ ys))", "unfolding comp_red_basis_aux_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set ys) \\<subseteq> pmdl (set ([] @ ys))", "by simp"], ["proof (state)\nthis:\n  pmdl (set (comp_red_basis_aux [] ys)) \\<subseteq> pmdl (set ([] @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>is_minimal_basis (set (xs @ ?ys36));\n   distinct (xs @ ?ys36)\\<rbrakk>\n  \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ?ys36))\n                    \\<subseteq> pmdl (set (xs @ ?ys36))\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "have eq: \"(a # xs) @ ys = a # (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # xs) @ ys = a # xs @ ys", "by simp"], ["proof (state)\nthis:\n  (a # xs) @ ys = a # xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "have a: \"a \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "let ?b = \"trd (xs @ ys) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "let ?ys = \"?b # ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "have \"pmdl (set (comp_red_basis_aux xs ?ys)) \\<subseteq> pmdl (set (xs @ ?ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)))\n    \\<subseteq> pmdl (set (xs @ trd (xs @ ys) a # ys))", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n 2. distinct (xs @ trd (xs @ ys) a # ys)", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "have \"a \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (xs @ ys)\n\ngoal (2 subgoals):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n 2. distinct (xs @ trd (xs @ ys) a # ys)", "with Cons(2)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)", "show \"is_minimal_basis (set (xs @ ?ys))\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))", "unfolding set_reorder eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd (xs @ ys) a # xs @ ys))", "by (rule is_minimal_basis_trd_is_minimal_basis)"], ["proof (state)\nthis:\n  is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "from Cons(2) Cons(3)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)", "show \"distinct (xs @ ?ys)\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "unfolding distinct_reorder eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. distinct (trd (xs @ ys) a # xs @ ys)", "by (rule is_minimal_basis_trd_distinct)"], ["proof (state)\nthis:\n  distinct (xs @ trd (xs @ ys) a # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)))\n  \\<subseteq> pmdl (set (xs @ trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "also"], ["proof (state)\nthis:\n  pmdl (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)))\n  \\<subseteq> pmdl (set (xs @ trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "have \"... = pmdl (set (?b # xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (xs @ trd (xs @ ys) a # ys)) =\n    pmdl (set (trd (xs @ ys) a # xs @ ys))", "by simp"], ["proof (state)\nthis:\n  pmdl (set (xs @ trd (xs @ ys) a # ys)) =\n  pmdl (set (trd (xs @ ys) a # xs @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "also"], ["proof (state)\nthis:\n  pmdl (set (xs @ trd (xs @ ys) a # ys)) =\n  pmdl (set (trd (xs @ ys) a # xs @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "from a"], ["proof (chain)\npicking this:\n  a \\<notin> set (xs @ ys)", "have \"... = pmdl (insert ?b (set (a # xs @ ys) - {a}))\""], ["proof (prove)\nusing this:\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. pmdl (set (trd (xs @ ys) a # xs @ ys)) =\n    pmdl (insert (trd (xs @ ys) a) (set (a # xs @ ys) - {a}))", "by auto"], ["proof (state)\nthis:\n  pmdl (set (trd (xs @ ys) a # xs @ ys)) =\n  pmdl (insert (trd (xs @ ys) a) (set (a # xs @ ys) - {a}))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "also"], ["proof (state)\nthis:\n  pmdl (set (trd (xs @ ys) a # xs @ ys)) =\n  pmdl (insert (trd (xs @ ys) a) (set (a # xs @ ys) - {a}))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "have \"... \\<subseteq> pmdl (set (a # xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (insert (trd (xs @ ys) a) (set (a # xs @ ys) - {a}))\n    \\<subseteq> pmdl (set (a # xs @ ys))", "proof (rule pmdl.replace_span)"], ["proof (state)\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "have \"a - (trd (xs @ ys) a) \\<in> pmdl (set (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - trd (xs @ ys) a \\<in> pmdl (set (xs @ ys))", "by (rule trd_in_pmdl)"], ["proof (state)\nthis:\n  a - trd (xs @ ys) a \\<in> pmdl (set (xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "have \"a - (trd (xs @ ys) a) \\<in> pmdl (set (a # xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a - trd (xs @ ys) a \\<in> ?A\n 2. ?A \\<subseteq> pmdl (set (a # xs @ ys))", "show \"pmdl (set (xs @ ys)) \\<subseteq> pmdl (set (a # xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (xs @ ys)) \\<subseteq> pmdl (set (a # xs @ ys))", "by (rule pmdl.span_mono) auto"], ["proof (state)\nthis:\n  pmdl (set (xs @ ys)) \\<subseteq> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. a - trd (xs @ ys) a \\<in> pmdl (set (xs @ ys))", "qed fact"], ["proof (state)\nthis:\n  a - trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "hence \"- (a - (trd (xs @ ys) a)) \\<in> pmdl (set (a # xs @ ys))\""], ["proof (prove)\nusing this:\n  a - trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. - (a - trd (xs @ ys) a) \\<in> pmdl (set (a # xs @ ys))", "by (rule pmdl.span_neg)"], ["proof (state)\nthis:\n  - (a - trd (xs @ ys) a) \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "hence \"(trd (xs @ ys) a) - a \\<in> pmdl (set (a # xs @ ys))\""], ["proof (prove)\nusing this:\n  - (a - trd (xs @ ys) a) \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a - a \\<in> pmdl (set (a # xs @ ys))", "by simp"], ["proof (state)\nthis:\n  trd (xs @ ys) a - a \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "hence \"((trd (xs @ ys) a) - a) + a \\<in> pmdl (set (a # xs @ ys))\""], ["proof (prove)\nusing this:\n  trd (xs @ ys) a - a \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a - a + a \\<in> pmdl (set (a # xs @ ys))", "proof (rule pmdl.span_add)"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> pmdl (set (a # xs @ ys))", "show \"a \\<in> pmdl (set (a # xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> pmdl (set (a # xs @ ys))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> ?A\n 2. ?A \\<subseteq> pmdl (set (a # xs @ ys))", "show \"a \\<in> set (a # xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (a # xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. set (a # xs @ ys) \\<subseteq> pmdl (set (a # xs @ ys))", "qed (rule pmdl.span_superset)"], ["proof (state)\nthis:\n  a \\<in> pmdl (set (a # xs @ ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trd (xs @ ys) a - a + a \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "thus \"trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))\""], ["proof (prove)\nusing this:\n  trd (xs @ ys) a - a + a \\<in> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))", "by simp"], ["proof (state)\nthis:\n  trd (xs @ ys) a \\<in> pmdl (set (a # xs @ ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl (insert (trd (xs @ ys) a) (set (a # xs @ ys) - {a}))\n  \\<subseteq> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "also"], ["proof (state)\nthis:\n  pmdl (insert (trd (xs @ ys) a) (set (a # xs @ ys) - {a}))\n  \\<subseteq> pmdl (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "have \"... = pmdl (set ((a # xs) @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (a # xs @ ys)) = pmdl (set ((a # xs) @ ys))", "by simp"], ["proof (state)\nthis:\n  pmdl (set (a # xs @ ys)) = pmdl (set ((a # xs) @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys)\\<rbrakk>\n                   \\<Longrightarrow> pmdl (set (comp_red_basis_aux xs ys))\n                                     \\<subseteq> pmdl (set (xs @ ys));\n        is_minimal_basis (set ((a # xs) @ ys));\n        distinct ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> pmdl (set (comp_red_basis_aux (a # xs) ys))\n                         \\<subseteq> pmdl (set ((a # xs) @ ys))", "finally"], ["proof (chain)\npicking this:\n  pmdl (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)))\n  \\<subseteq> pmdl (set ((a # xs) @ ys))", "show ?case"], ["proof (prove)\nusing this:\n  pmdl (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)))\n  \\<subseteq> pmdl (set ((a # xs) @ ys))\n\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux (a # xs) ys))\n    \\<subseteq> pmdl (set ((a # xs) @ ys))", "unfolding comp_red_basis_aux_rec"], ["proof (prove)\nusing this:\n  pmdl (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)))\n  \\<subseteq> pmdl (set ((a # xs) @ ys))\n\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)))\n    \\<subseteq> pmdl (set ((a # xs) @ ys))", "."], ["proof (state)\nthis:\n  pmdl (set (comp_red_basis_aux (a # xs) ys))\n  \\<subseteq> pmdl (set ((a # xs) @ ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_aux_irred:\n  assumes \"is_minimal_basis (set (xs @ ys))\" and \"distinct (xs @ ys)\"\n    and \"\\<And>y. y \\<in> set ys \\<Longrightarrow> \\<not> is_red (set (xs @ ys) - {y}) y\"\n    and \"p \\<in> set (comp_red_basis_aux xs ys)\"\n  shows \"\\<not> is_red (set (comp_red_basis_aux xs ys) - {p}) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (comp_red_basis_aux xs ys) - {p}) p", "using assms"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (xs @ ys))\n  distinct (xs @ ys)\n  ?y36 \\<in> set ys \\<Longrightarrow>\n  \\<not> is_red (set (xs @ ys) - {?y36}) ?y36\n  p \\<in> set (comp_red_basis_aux xs ys)\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set (comp_red_basis_aux xs ys) - {p}) p", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys)); distinct ([] @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ([] @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux [] ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux [] ys) - {p}) p\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "case Nil"], ["proof (state)\nthis:\n  is_minimal_basis (set ([] @ ys))\n  distinct ([] @ ys)\n  ?y36 \\<in> set ys \\<Longrightarrow>\n  \\<not> is_red (set ([] @ ys) - {?y36}) ?y36\n  p \\<in> set (comp_red_basis_aux [] ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys)); distinct ([] @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ([] @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux [] ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux [] ys) - {p}) p\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "have \"\\<not> is_red (set ([] @ ys) - {p}) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set ([] @ ys) - {p}) p", "proof (rule Nil(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> set ys", "from Nil(4)"], ["proof (chain)\npicking this:\n  p \\<in> set (comp_red_basis_aux [] ys)", "show \"p \\<in> set ys\""], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis_aux [] ys)\n\ngoal (1 subgoal):\n 1. p \\<in> set ys", "unfolding comp_red_basis_aux_base"], ["proof (prove)\nusing this:\n  p \\<in> set ys\n\ngoal (1 subgoal):\n 1. p \\<in> set ys", "."], ["proof (state)\nthis:\n  p \\<in> set ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_red (set ([] @ ys) - {p}) p\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>is_minimal_basis (set ([] @ ys)); distinct ([] @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ([] @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux [] ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux [] ys) - {p}) p\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> is_red (set ([] @ ys) - {p}) p\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set (comp_red_basis_aux [] ys) - {p}) p", "unfolding comp_red_basis_aux_base"], ["proof (prove)\nusing this:\n  \\<not> is_red (set ([] @ ys) - {p}) p\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set ys - {p}) p", "by simp"], ["proof (state)\nthis:\n  \\<not> is_red (set (comp_red_basis_aux [] ys) - {p}) p\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>is_minimal_basis (set (xs @ ?ys36)); distinct (xs @ ?ys36);\n   \\<And>y.\n      y \\<in> set ?ys36 \\<Longrightarrow>\n      \\<not> is_red (set (xs @ ?ys36) - {y}) y;\n   p \\<in> set (comp_red_basis_aux xs ?ys36)\\<rbrakk>\n  \\<Longrightarrow> \\<not> is_red (set (comp_red_basis_aux xs ?ys36) - {p})\n                            p\n  is_minimal_basis (set ((a # xs) @ ys))\n  distinct ((a # xs) @ ys)\n  ?y36 \\<in> set ys \\<Longrightarrow>\n  \\<not> is_red (set ((a # xs) @ ys) - {?y36}) ?y36\n  p \\<in> set (comp_red_basis_aux (a # xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "have eq: \"(a # xs) @ ys = a # (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # xs) @ ys = a # xs @ ys", "by simp"], ["proof (state)\nthis:\n  (a # xs) @ ys = a # xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "have a_notin: \"a \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "from Cons(2)"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))", "have is_min: \"is_minimal_basis (set (a # xs @ ys))\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (a # xs @ ys))", "unfolding eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (a # xs @ ys))", "."], ["proof (state)\nthis:\n  is_minimal_basis (set (a # xs @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "let ?b = \"trd (xs @ ys) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "let ?ys = \"?b # ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "have dist: \"distinct (?b # (xs @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (trd (xs @ ys) a # xs @ ys)", "proof (rule is_minimal_basis_trd_distinct, fact is_min)"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (a # xs @ ys)", "from Cons(3)"], ["proof (chain)\npicking this:\n  distinct ((a # xs) @ ys)", "show \"distinct (a # xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct ((a # xs) @ ys)\n\ngoal (1 subgoal):\n 1. distinct (a # xs @ ys)", "unfolding eq"], ["proof (prove)\nusing this:\n  distinct (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. distinct (a # xs @ ys)", "."], ["proof (state)\nthis:\n  distinct (a # xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (trd (xs @ ys) a # xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>is_minimal_basis (set (xs @ ys));\n                    distinct (xs @ ys);\n                    \\<And>y.\n                       y \\<in> set ys \\<Longrightarrow>\n                       \\<not> is_red (set (xs @ ys) - {y}) y;\n                    p \\<in> set (comp_red_basis_aux xs ys)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> is_red\n       (set (comp_red_basis_aux xs ys) - {p}) p;\n        is_minimal_basis (set ((a # xs) @ ys)); distinct ((a # xs) @ ys);\n        \\<And>y.\n           y \\<in> set ys \\<Longrightarrow>\n           \\<not> is_red (set ((a # xs) @ ys) - {y}) y;\n        p \\<in> set (comp_red_basis_aux (a # xs) ys)\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_red\n                                 (set (comp_red_basis_aux (a # xs) ys) -\n                                  {p})\n                                 p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (comp_red_basis_aux (a # xs) ys) - {p}) p", "unfolding comp_red_basis_aux_rec"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (comp_red_basis_aux xs (trd (xs @ ys) a # ys)) - {p})\n            p", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (4 subgoals):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n 2. distinct (xs @ trd (xs @ ys) a # ys)\n 3. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 4. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "from Cons(2) a_notin"], ["proof (chain)\npicking this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)", "show \"is_minimal_basis (set (xs @ ?ys))\""], ["proof (prove)\nusing this:\n  is_minimal_basis (set ((a # xs) @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))", "unfolding set_reorder eq"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (a # xs @ ys))\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. is_minimal_basis (set (trd (xs @ ys) a # xs @ ys))", "by (rule is_minimal_basis_trd_is_minimal_basis)"], ["proof (state)\nthis:\n  is_minimal_basis (set (xs @ trd (xs @ ys) a # ys))\n\ngoal (3 subgoals):\n 1. distinct (xs @ trd (xs @ ys) a # ys)\n 2. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 3. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct (xs @ trd (xs @ ys) a # ys)\n 2. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 3. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "from dist"], ["proof (chain)\npicking this:\n  distinct (trd (xs @ ys) a # xs @ ys)", "show \"distinct (xs @ ?ys)\""], ["proof (prove)\nusing this:\n  distinct (trd (xs @ ys) a # xs @ ys)\n\ngoal (1 subgoal):\n 1. distinct (xs @ trd (xs @ ys) a # ys)", "unfolding distinct_reorder"], ["proof (prove)\nusing this:\n  distinct (trd (xs @ ys) a # xs @ ys)\n\ngoal (1 subgoal):\n 1. distinct (trd (xs @ ys) a # xs @ ys)", "."], ["proof (state)\nthis:\n  distinct (xs @ trd (xs @ ys) a # ys)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "assume \"y \\<in> set ?ys\""], ["proof (state)\nthis:\n  y \\<in> set (trd (xs @ ys) a # ys)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "hence \"y = ?b \\<or> y \\<in> set ys\""], ["proof (prove)\nusing this:\n  y \\<in> set (trd (xs @ ys) a # ys)\n\ngoal (1 subgoal):\n 1. y = trd (xs @ ys) a \\<or> y \\<in> set ys", "by simp"], ["proof (state)\nthis:\n  y = trd (xs @ ys) a \\<or> y \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (trd (xs @ ys) a # ys) \\<Longrightarrow>\n       \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "thus \"\\<not> is_red (set (xs @ ?ys) - {y}) y\""], ["proof (prove)\nusing this:\n  y = trd (xs @ ys) a \\<or> y \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y = trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "assume \"y = ?b\""], ["proof (state)\nthis:\n  y = trd (xs @ ys) a\n\ngoal (2 subgoals):\n 1. y = trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "from dist"], ["proof (chain)\npicking this:\n  distinct (trd (xs @ ys) a # xs @ ys)", "have \"?b \\<notin> set (xs @ ys)\""], ["proof (prove)\nusing this:\n  distinct (trd (xs @ ys) a # xs @ ys)\n\ngoal (1 subgoal):\n 1. trd (xs @ ys) a \\<notin> set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  trd (xs @ ys) a \\<notin> set (xs @ ys)\n\ngoal (2 subgoals):\n 1. y = trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "hence eq3: \"set (xs @ ?ys) - {?b} = set (xs @ ys)\""], ["proof (prove)\nusing this:\n  trd (xs @ ys) a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. set (xs @ trd (xs @ ys) a # ys) - {trd (xs @ ys) a} = set (xs @ ys)", "unfolding set_reorder"], ["proof (prove)\nusing this:\n  trd (xs @ ys) a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. set (trd (xs @ ys) a # xs @ ys) - {trd (xs @ ys) a} = set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  set (xs @ trd (xs @ ys) a # ys) - {trd (xs @ ys) a} = set (xs @ ys)\n\ngoal (2 subgoals):\n 1. y = trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "have \"\\<not> is_red (set (xs @ ys)) ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (xs @ ys)) (trd (xs @ ys) a)", "by (rule trd_irred)"], ["proof (state)\nthis:\n  \\<not> is_red (set (xs @ ys)) (trd (xs @ ys) a)\n\ngoal (2 subgoals):\n 1. y = trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n 2. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_red (set (xs @ ys)) (trd (xs @ ys) a)\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "unfolding \\<open>y = ?b\\<close> eq3"], ["proof (prove)\nusing this:\n  \\<not> is_red (set (xs @ ys)) (trd (xs @ ys) a)\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set (xs @ ys)) (trd (xs @ ys) a)", "."], ["proof (state)\nthis:\n  \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "assume \"y \\<in> set ys\""], ["proof (state)\nthis:\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "hence irred: \"\\<not> is_red (set ((a # xs) @ ys) - {y}) y\""], ["proof (prove)\nusing this:\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set ((a # xs) @ ys) - {y}) y", "by (rule Cons(4))"], ["proof (state)\nthis:\n  \\<not> is_red (set ((a # xs) @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "from \\<open>y \\<in> set ys\\<close> a_notin"], ["proof (chain)\npicking this:\n  y \\<in> set ys\n  a \\<notin> set (xs @ ys)", "have \"y \\<noteq> a\""], ["proof (prove)\nusing this:\n  y \\<in> set ys\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. y \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> a\n\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "hence eq3: \"set ((a # xs) @ ys) - {y} = {a} \\<union> (set (xs @ ys) - {y})\""], ["proof (prove)\nusing this:\n  y \\<noteq> a\n\ngoal (1 subgoal):\n 1. set ((a # xs) @ ys) - {y} = {a} \\<union> (set (xs @ ys) - {y})", "by auto"], ["proof (state)\nthis:\n  set ((a # xs) @ ys) - {y} = {a} \\<union> (set (xs @ ys) - {y})\n\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "from irred"], ["proof (chain)\npicking this:\n  \\<not> is_red (set ((a # xs) @ ys) - {y}) y", "have i1: \"\\<not> is_red {a} y\" and i2: \"\\<not> is_red (set (xs @ ys) - {y}) y\""], ["proof (prove)\nusing this:\n  \\<not> is_red (set ((a # xs) @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. \\<not> is_red {a} y &&& \\<not> is_red (set (xs @ ys) - {y}) y", "unfolding eq3 is_red_union"], ["proof (prove)\nusing this:\n  \\<not> (is_red {a} y \\<or> is_red (set (xs @ ys) - {y}) y)\n\ngoal (1 subgoal):\n 1. \\<not> is_red {a} y &&& \\<not> is_red (set (xs @ ys) - {y}) y", "by simp_all"], ["proof (state)\nthis:\n  \\<not> is_red {a} y\n  \\<not> is_red (set (xs @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<Longrightarrow>\n    \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y", "unfolding set_reorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "proof (cases \"y = ?b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y\n 2. y \\<noteq> trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "case True"], ["proof (state)\nthis:\n  y = trd (xs @ ys) a\n\ngoal (2 subgoals):\n 1. y = trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y\n 2. y \\<noteq> trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "from i2"], ["proof (chain)\npicking this:\n  \\<not> is_red (set (xs @ ys) - {y}) y", "show \"\\<not> is_red (set (?b # xs @ ys) - {y}) y\""], ["proof (prove)\nusing this:\n  \\<not> is_red (set (xs @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "by (simp add: True)"], ["proof (state)\nthis:\n  \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. y \\<noteq> trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> trd (xs @ ys) a\n\ngoal (1 subgoal):\n 1. y \\<noteq> trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "hence eq4: \"set (?b # xs @ ys) - {y} = {?b} \\<union> (set (xs @ ys) - {y})\""], ["proof (prove)\nusing this:\n  y \\<noteq> trd (xs @ ys) a\n\ngoal (1 subgoal):\n 1. set (trd (xs @ ys) a # xs @ ys) - {y} =\n    {trd (xs @ ys) a} \\<union> (set (xs @ ys) - {y})", "by auto"], ["proof (state)\nthis:\n  set (trd (xs @ ys) a # xs @ ys) - {y} =\n  {trd (xs @ ys) a} \\<union> (set (xs @ ys) - {y})\n\ngoal (1 subgoal):\n 1. y \\<noteq> trd (xs @ ys) a \\<Longrightarrow>\n    \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "show \"\\<not> is_red (set (?b # xs @ ys) - {y}) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y", "unfolding eq4"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red ({trd (xs @ ys) a} \\<union> (set (xs @ ys) - {y})) y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. is_red ({trd (xs @ ys) a} \\<union> (set (xs @ ys) - {y}))\n     y \\<Longrightarrow>\n    False", "assume \"is_red ({?b} \\<union> (set (xs @ ys) - {y})) y\""], ["proof (state)\nthis:\n  is_red ({trd (xs @ ys) a} \\<union> (set (xs @ ys) - {y})) y\n\ngoal (1 subgoal):\n 1. is_red ({trd (xs @ ys) a} \\<union> (set (xs @ ys) - {y}))\n     y \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  is_red ({trd (xs @ ys) a} \\<union> (set (xs @ ys) - {y})) y\n\ngoal (1 subgoal):\n 1. False", "unfolding is_red_union"], ["proof (prove)\nusing this:\n  is_red {trd (xs @ ys) a} y \\<or> is_red (set (xs @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_red {trd (xs @ ys) a} y \\<Longrightarrow> False\n 2. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "have ltb: \"lt ?b = lt a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (trd (xs @ ys) a) = lt a", "proof (rule minimal_basis_red_rtrancl_lt, fact is_min)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set (a # xs @ ys)\n 2. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "show \"a \\<in> set (a # xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set (a # xs @ ys)", "by simp"], ["proof (state)\nthis:\n  a \\<in> set (a # xs @ ys)\n\ngoal (1 subgoal):\n 1. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "from a_notin"], ["proof (chain)\npicking this:\n  a \\<notin> set (xs @ ys)", "have eq: \"set (a # xs @ ys) - {a} = set (xs @ ys)\""], ["proof (prove)\nusing this:\n  a \\<notin> set (xs @ ys)\n\ngoal (1 subgoal):\n 1. set (a # xs @ ys) - {a} = set (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  set (a # xs @ ys) - {a} = set (xs @ ys)\n\ngoal (1 subgoal):\n 1. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "show \"(red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set (xs @ ys)))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)", "by (rule trd_red_rtrancl)"], ["proof (state)\nthis:\n  (red (set (a # xs @ ys) - {a}))\\<^sup>*\\<^sup>* a (trd (xs @ ys) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (trd (xs @ ys) a) = lt a\n\ngoal (2 subgoals):\n 1. is_red {trd (xs @ ys) a} y \\<Longrightarrow> False\n 2. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "assume \"is_red {?b} y\""], ["proof (state)\nthis:\n  is_red {trd (xs @ ys) a} y\n\ngoal (2 subgoals):\n 1. is_red {trd (xs @ ys) a} y \\<Longrightarrow> False\n 2. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_red {trd (xs @ ys) a} y", "obtain t where \"t \\<in> keys y\" and \"lt ?b adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  is_red {trd (xs @ ys) a} y\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys y;\n         lt (trd (xs @ ys) a) adds\\<^sub>t t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_red_adds_iff"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>{trd (xs @ ys) a}.\n     \\<exists>v\\<in>keys y. f \\<noteq> 0 \\<and> lt f adds\\<^sub>t v\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> keys y;\n         lt (trd (xs @ ys) a) adds\\<^sub>t t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> keys y\n  lt (trd (xs @ ys) a) adds\\<^sub>t t\n\ngoal (2 subgoals):\n 1. is_red {trd (xs @ ys) a} y \\<Longrightarrow> False\n 2. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "with ltb"], ["proof (chain)\npicking this:\n  lt (trd (xs @ ys) a) = lt a\n  t \\<in> keys y\n  lt (trd (xs @ ys) a) adds\\<^sub>t t", "have \"lt a adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  lt (trd (xs @ ys) a) = lt a\n  t \\<in> keys y\n  lt (trd (xs @ ys) a) adds\\<^sub>t t\n\ngoal (1 subgoal):\n 1. lt a adds\\<^sub>t t", "by simp"], ["proof (state)\nthis:\n  lt a adds\\<^sub>t t\n\ngoal (2 subgoals):\n 1. is_red {trd (xs @ ys) a} y \\<Longrightarrow> False\n 2. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "have \"is_red {a} y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red {a} y", "by (rule is_red_addsI, rule, rule is_minimal_basisD1, fact is_min, simp, fact+)"], ["proof (state)\nthis:\n  is_red {a} y\n\ngoal (2 subgoals):\n 1. is_red {trd (xs @ ys) a} y \\<Longrightarrow> False\n 2. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "with i1"], ["proof (chain)\npicking this:\n  \\<not> is_red {a} y\n  is_red {a} y", "show False"], ["proof (prove)\nusing this:\n  \\<not> is_red {a} y\n  is_red {a} y\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "assume \"is_red (set (xs @ ys) - {y}) y\""], ["proof (state)\nthis:\n  is_red (set (xs @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. is_red (set (xs @ ys) - {y}) y \\<Longrightarrow> False", "with i2"], ["proof (chain)\npicking this:\n  \\<not> is_red (set (xs @ ys) - {y}) y\n  is_red (set (xs @ ys) - {y}) y", "show False"], ["proof (prove)\nusing this:\n  \\<not> is_red (set (xs @ ys) - {y}) y\n  is_red (set (xs @ ys) - {y}) y\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_red (set (trd (xs @ ys) a # xs @ ys) - {y}) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_red (set (xs @ trd (xs @ ys) a # ys) - {y}) y\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "from Cons(5)"], ["proof (chain)\npicking this:\n  p \\<in> set (comp_red_basis_aux (a # xs) ys)", "show \"p \\<in> set (comp_red_basis_aux xs ?ys)\""], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis_aux (a # xs) ys)\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "unfolding comp_red_basis_aux_rec"], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))", "."], ["proof (state)\nthis:\n  p \\<in> set (comp_red_basis_aux xs (trd (xs @ ys) a # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_red (set (comp_red_basis_aux (a # xs) ys) - {p}) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_aux_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (comp_red_basis_aux xs ys)) (set xs \\<union> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n     (set xs \\<union> set ys)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       dgrad_p_set_le d (set (comp_red_basis_aux [] ys))\n        (set [] \\<union> set ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       dgrad_p_set_le d (set (comp_red_basis_aux [] ys))\n        (set [] \\<union> set ys)\n 2. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis_aux [] ys))\n     (set [] \\<union> set ys)", "by (simp, rule dgrad_p_set_le_subset, fact subset_refl)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis_aux [] ys)) (set [] \\<union> set ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis_aux xs ?ys36))\n   (set xs \\<union> set ?ys36)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "let ?h = \"trd (xs @ ys) x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "have \"dgrad_p_set_le d (set (comp_red_basis_aux xs (?h # ys))) (set xs \\<union> set (?h # ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis_aux xs (trd (xs @ ys) x # ys)))\n     (set xs \\<union> set (trd (xs @ ys) x # ys))", "by (fact Cons)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis_aux xs (trd (xs @ ys) x # ys)))\n   (set xs \\<union> set (trd (xs @ ys) x # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "also"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis_aux xs (trd (xs @ ys) x # ys)))\n   (set xs \\<union> set (trd (xs @ ys) x # ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "have \"... = insert ?h (set xs \\<union> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<union> set (trd (xs @ ys) x # ys) =\n    insert (trd (xs @ ys) x) (set xs \\<union> set ys)", "by simp"], ["proof (state)\nthis:\n  set xs \\<union> set (trd (xs @ ys) x # ys) =\n  insert (trd (xs @ ys) x) (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "also"], ["proof (state)\nthis:\n  set xs \\<union> set (trd (xs @ ys) x # ys) =\n  insert (trd (xs @ ys) x) (set xs \\<union> set ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "have \"dgrad_p_set_le d ... (insert x (set xs \\<union> set ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (insert (trd (xs @ ys) x) (set xs \\<union> set ys))\n     (insert x (set xs \\<union> set ys))", "proof (rule dgrad_p_set_leI_insert)"], ["proof (state)\ngoal (2 subgoals):\n 1. dgrad_p_set_le d (set xs \\<union> set ys)\n     (insert x (set xs \\<union> set ys))\n 2. dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set xs \\<union> set ys))", "show \"dgrad_p_set_le d (set xs \\<union> set ys) (insert x (set xs \\<union> set ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set xs \\<union> set ys)\n     (insert x (set xs \\<union> set ys))", "by (rule dgrad_p_set_le_subset, blast)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set xs \\<union> set ys)\n   (insert x (set xs \\<union> set ys))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set xs \\<union> set ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set xs \\<union> set ys))", "have \"(red (set (xs @ ys)))\\<^sup>*\\<^sup>* x ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (red (set (xs @ ys)))\\<^sup>*\\<^sup>* x (trd (xs @ ys) x)", "by (rule trd_red_rtrancl)"], ["proof (state)\nthis:\n  (red (set (xs @ ys)))\\<^sup>*\\<^sup>* x (trd (xs @ ys) x)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set xs \\<union> set ys))", "with assms"], ["proof (chain)\npicking this:\n  dickson_grading d\n  (red (set (xs @ ys)))\\<^sup>*\\<^sup>* x (trd (xs @ ys) x)", "have \"dgrad_p_set_le d {?h} (insert x (set (xs @ ys)))\""], ["proof (prove)\nusing this:\n  dickson_grading d\n  (red (set (xs @ ys)))\\<^sup>*\\<^sup>* x (trd (xs @ ys) x)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set (xs @ ys)))", "by (rule dgrad_p_set_le_red_rtrancl)"], ["proof (state)\nthis:\n  dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set (xs @ ys)))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set xs \\<union> set ys))", "thus \"dgrad_p_set_le d {?h} (insert x (set xs \\<union> set ys))\""], ["proof (prove)\nusing this:\n  dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set (xs @ ys)))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set xs \\<union> set ys))", "by simp"], ["proof (state)\nthis:\n  dgrad_p_set_le d {trd (xs @ ys) x} (insert x (set xs \\<union> set ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dgrad_p_set_le d (insert (trd (xs @ ys) x) (set xs \\<union> set ys))\n   (insert x (set xs \\<union> set ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys.\n           dgrad_p_set_le d (set (comp_red_basis_aux xs ys))\n            (set xs \\<union> set ys)) \\<Longrightarrow>\n       dgrad_p_set_le d (set (comp_red_basis_aux (a # xs) ys))\n        (set (a # xs) \\<union> set ys)", "finally"], ["proof (chain)\npicking this:\n  dgrad_p_set_le d (set (comp_red_basis_aux xs (trd (xs @ ys) x # ys)))\n   (insert x (set xs \\<union> set ys))", "show ?case"], ["proof (prove)\nusing this:\n  dgrad_p_set_le d (set (comp_red_basis_aux xs (trd (xs @ ys) x # ys)))\n   (insert x (set xs \\<union> set ys))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis_aux (x # xs) ys))\n     (set (x # xs) \\<union> set ys)", "by simp"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis_aux (x # xs) ys))\n   (set (x # xs) \\<union> set ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition comp_red_basis :: \"('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::field) list\"\n  where \"comp_red_basis xs = comp_red_basis_aux (comp_min_basis xs) []\""], ["", "lemma comp_red_basis_nonzero:\n  assumes \"p \\<in> set (comp_red_basis xs)\"\n  shows \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "have \"is_minimal_basis (set ((comp_min_basis xs) @ []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_minimal_basis (set (comp_min_basis xs @ []))", "by (simp add: comp_min_basis_is_minimal_basis)"], ["proof (state)\nthis:\n  is_minimal_basis (set (comp_min_basis xs @ []))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  is_minimal_basis (set (comp_min_basis xs @ []))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "have \"distinct ((comp_min_basis xs) @ [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (comp_min_basis xs @ [])", "by (simp add: comp_min_basis_distinct)"], ["proof (state)\nthis:\n  distinct (comp_min_basis xs @ [])\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  distinct (comp_min_basis xs @ [])\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> set (comp_red_basis xs)", "have \"p \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\""], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])", "unfolding comp_red_basis_def"], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. p \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])", "."], ["proof (state)\nthis:\n  p \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  is_minimal_basis (set (comp_min_basis xs @ []))\n  distinct (comp_min_basis xs @ [])\n  p \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])", "show ?thesis"], ["proof (prove)\nusing this:\n  is_minimal_basis (set (comp_min_basis xs @ []))\n  distinct (comp_min_basis xs @ [])\n  p \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by (rule comp_red_basis_aux_nonzero)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmdl_comp_red_basis_subset: \"pmdl (set (comp_red_basis xs)) \\<subseteq> pmdl (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis xs)) \\<subseteq> pmdl (set xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (comp_red_basis xs)) \\<Longrightarrow>\n       x \\<in> pmdl (set xs)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (comp_red_basis xs)) \\<Longrightarrow>\n       x \\<in> pmdl (set xs)", "assume fin: \"f \\<in> pmdl (set (comp_red_basis xs))\""], ["proof (state)\nthis:\n  f \\<in> pmdl (set (comp_red_basis xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (comp_red_basis xs)) \\<Longrightarrow>\n       x \\<in> pmdl (set xs)", "have \"f \\<in> pmdl (set (comp_min_basis xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> pmdl (set (comp_min_basis xs))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f \\<in> ?A\n 2. ?A \\<subseteq> pmdl (set (comp_min_basis xs))", "from fin"], ["proof (chain)\npicking this:\n  f \\<in> pmdl (set (comp_red_basis xs))", "show  \"f \\<in> pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\""], ["proof (prove)\nusing this:\n  f \\<in> pmdl (set (comp_red_basis xs))\n\ngoal (1 subgoal):\n 1. f \\<in> pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))", "unfolding comp_red_basis_def"], ["proof (prove)\nusing this:\n  f \\<in> pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n\ngoal (1 subgoal):\n 1. f \\<in> pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))", "."], ["proof (state)\nthis:\n  f \\<in> pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n    \\<subseteq> pmdl (set (comp_min_basis xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n    \\<subseteq> pmdl (set (comp_min_basis xs))", "have \"pmdl (set (comp_red_basis_aux (comp_min_basis xs) [])) \\<subseteq> pmdl (set ((comp_min_basis xs) @ []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n    \\<subseteq> pmdl (set (comp_min_basis xs @ []))", "by (rule comp_red_basis_aux_pmdl, simp_all, rule comp_min_basis_is_minimal_basis, rule comp_min_basis_distinct)"], ["proof (state)\nthis:\n  pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n  \\<subseteq> pmdl (set (comp_min_basis xs @ []))\n\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n    \\<subseteq> pmdl (set (comp_min_basis xs))", "thus \"pmdl (set (comp_red_basis_aux (comp_min_basis xs) [])) \\<subseteq> pmdl (set (comp_min_basis xs))\""], ["proof (prove)\nusing this:\n  pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n  \\<subseteq> pmdl (set (comp_min_basis xs @ []))\n\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n    \\<subseteq> pmdl (set (comp_min_basis xs))", "by simp"], ["proof (state)\nthis:\n  pmdl (set (comp_red_basis_aux (comp_min_basis xs) []))\n  \\<subseteq> pmdl (set (comp_min_basis xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<in> pmdl (set (comp_min_basis xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (comp_red_basis xs)) \\<Longrightarrow>\n       x \\<in> pmdl (set xs)", "also"], ["proof (state)\nthis:\n  f \\<in> pmdl (set (comp_min_basis xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (comp_red_basis xs)) \\<Longrightarrow>\n       x \\<in> pmdl (set xs)", "from comp_min_basis_subset"], ["proof (chain)\npicking this:\n  set (comp_min_basis ?xs) \\<subseteq> set ?xs", "have \"... \\<subseteq> pmdl (set xs)\""], ["proof (prove)\nusing this:\n  set (comp_min_basis ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. pmdl (set (comp_min_basis xs)) \\<subseteq> pmdl (set xs)", "by (rule pmdl.span_mono)"], ["proof (state)\nthis:\n  pmdl (set (comp_min_basis xs)) \\<subseteq> pmdl (set xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> pmdl (set (comp_red_basis xs)) \\<Longrightarrow>\n       x \\<in> pmdl (set xs)", "finally"], ["proof (chain)\npicking this:\n  f \\<in> pmdl (set xs)", "show \"f \\<in> pmdl (set xs)\""], ["proof (prove)\nusing this:\n  f \\<in> pmdl (set xs)\n\ngoal (1 subgoal):\n 1. f \\<in> pmdl (set xs)", "."], ["proof (state)\nthis:\n  f \\<in> pmdl (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_adds:\n  assumes \"p \\<in> set xs\" and \"p \\<noteq> 0\"\n  obtains q where \"q \\<in> set (comp_red_basis xs)\" and \"lt q adds\\<^sub>t lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> set xs\n  p \\<noteq> 0", "obtain q1 where \"q1 \\<in> set (comp_min_basis xs)\" and \"lt q1 adds\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  p \\<in> set xs\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>q1.\n        \\<lbrakk>q1 \\<in> set (comp_min_basis xs);\n         lt q1 adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule comp_min_basis_adds)"], ["proof (state)\nthis:\n  q1 \\<in> set (comp_min_basis xs)\n  lt q1 adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>q1 \\<in> set (comp_min_basis xs)\\<close>"], ["proof (chain)\npicking this:\n  q1 \\<in> set (comp_min_basis xs)", "have \"lt q1 \\<in> lt ` set (comp_min_basis xs)\""], ["proof (prove)\nusing this:\n  q1 \\<in> set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. lt q1 \\<in> lt ` set (comp_min_basis xs)", "by simp"], ["proof (state)\nthis:\n  lt q1 \\<in> lt ` set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  lt q1 \\<in> lt ` set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"... = lt ` set ((comp_min_basis xs) @ [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (comp_min_basis xs) = lt ` set (comp_min_basis xs @ [])", "by simp"], ["proof (state)\nthis:\n  lt ` set (comp_min_basis xs) = lt ` set (comp_min_basis xs @ [])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  lt ` set (comp_min_basis xs) = lt ` set (comp_min_basis xs @ [])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"... = lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (comp_min_basis xs @ []) =\n    lt ` set (comp_red_basis_aux (comp_min_basis xs) [])", "by (rule comp_red_basis_aux_lt, simp_all, rule comp_min_basis_is_minimal_basis, rule comp_min_basis_distinct)"], ["proof (state)\nthis:\n  lt ` set (comp_min_basis xs @ []) =\n  lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  lt q1 \\<in> lt ` set (comp_red_basis_aux (comp_min_basis xs) [])", "obtain q where \"q \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\" and \"lt q = lt q1\""], ["proof (prove)\nusing this:\n  lt q1 \\<in> lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis_aux (comp_min_basis xs) []);\n         lt q = lt q1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\n  lt q = lt q1\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_red_basis xs);\n         lt q adds\\<^sub>t lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ?q37 \\<in> set (comp_red_basis xs)\n 2. lt ?q37 adds\\<^sub>t lt p", "show \"q \\<in> set (comp_red_basis xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (comp_red_basis xs)", "unfolding comp_red_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])", "by fact"], ["proof (state)\nthis:\n  q \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p", "from \\<open>lt q1 adds\\<^sub>t lt p\\<close>"], ["proof (chain)\npicking this:\n  lt q1 adds\\<^sub>t lt p", "show \"lt q adds\\<^sub>t lt p\""], ["proof (prove)\nusing this:\n  lt q1 adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. lt q adds\\<^sub>t lt p", "unfolding \\<open>lt q = lt q1\\<close>"], ["proof (prove)\nusing this:\n  lt q1 adds\\<^sub>t lt p\n\ngoal (1 subgoal):\n 1. lt q1 adds\\<^sub>t lt p", "."], ["proof (state)\nthis:\n  lt q adds\\<^sub>t lt p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_lt:\n  assumes \"p \\<in> set (comp_red_basis xs)\"\n  obtains q where \"q \\<in> set xs\" and \"q \\<noteq> 0\" and \"lt q = lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have eq: \"lt ` set ((comp_min_basis xs) @ []) = lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (comp_min_basis xs @ []) =\n    lt ` set (comp_red_basis_aux (comp_min_basis xs) [])", "by (rule comp_red_basis_aux_lt, simp_all, rule comp_min_basis_is_minimal_basis, rule comp_min_basis_distinct)"], ["proof (state)\nthis:\n  lt ` set (comp_min_basis xs @ []) =\n  lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> set (comp_red_basis xs)", "have \"lt p \\<in> lt ` set (comp_red_basis xs)\""], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. lt p \\<in> lt ` set (comp_red_basis xs)", "by simp"], ["proof (state)\nthis:\n  lt p \\<in> lt ` set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  lt p \\<in> lt ` set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"... = lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (comp_red_basis xs) =\n    lt ` set (comp_red_basis_aux (comp_min_basis xs) [])", "unfolding comp_red_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (comp_red_basis_aux (comp_min_basis xs) []) =\n    lt ` set (comp_red_basis_aux (comp_min_basis xs) [])", ".."], ["proof (state)\nthis:\n  lt ` set (comp_red_basis xs) =\n  lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  lt ` set (comp_red_basis xs) =\n  lt ` set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"... = lt ` set (comp_min_basis xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (comp_red_basis_aux (comp_min_basis xs) []) =\n    lt ` set (comp_min_basis xs)", "unfolding eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt ` set (comp_min_basis xs @ []) = lt ` set (comp_min_basis xs)", "by simp"], ["proof (state)\nthis:\n  lt ` set (comp_red_basis_aux (comp_min_basis xs) []) =\n  lt ` set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  lt p \\<in> lt ` set (comp_min_basis xs)", "obtain q where \"q \\<in> set (comp_min_basis xs)\" and \"lt q = lt p\""], ["proof (prove)\nusing this:\n  lt p \\<in> lt ` set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (comp_min_basis xs); lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (comp_min_basis xs)\n  lt q = lt p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set xs; q \\<noteq> 0; lt q = lt p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?q37 \\<in> set xs\n 2. ?q37 \\<noteq> 0\n 3. lt ?q37 = lt p", "show \"q \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set xs", "by (rule, fact, rule comp_min_basis_subset)"], ["proof (state)\nthis:\n  q \\<in> set xs\n\ngoal (2 subgoals):\n 1. q \\<noteq> 0\n 2. lt q = lt p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<noteq> 0\n 2. lt q = lt p", "show \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by (rule comp_min_basis_nonzero, fact)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt q = lt p", "qed fact"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_is_red: \"is_red (set (comp_red_basis xs)) f \\<longleftrightarrow> is_red (set xs) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red (set (comp_red_basis xs)) f = is_red (set xs) f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_red (set (comp_red_basis xs)) f \\<Longrightarrow> is_red (set xs) f\n 2. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "assume \"is_red (set (comp_red_basis xs)) f\""], ["proof (state)\nthis:\n  is_red (set (comp_red_basis xs)) f\n\ngoal (2 subgoals):\n 1. is_red (set (comp_red_basis xs)) f \\<Longrightarrow> is_red (set xs) f\n 2. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "then"], ["proof (chain)\npicking this:\n  is_red (set (comp_red_basis xs)) f", "obtain x t where \"x \\<in> set (comp_red_basis xs)\" and \"t \\<in> keys f\" and \"x \\<noteq> 0\" and \"lt x adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  is_red (set (comp_red_basis xs)) f\n\ngoal (1 subgoal):\n 1. (\\<And>x t.\n        \\<lbrakk>x \\<in> set (comp_red_basis xs); t \\<in> keys f;\n         x \\<noteq> 0; lt x adds\\<^sub>t t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_red_addsE)"], ["proof (state)\nthis:\n  x \\<in> set (comp_red_basis xs)\n  t \\<in> keys f\n  x \\<noteq> 0\n  lt x adds\\<^sub>t t\n\ngoal (2 subgoals):\n 1. is_red (set (comp_red_basis xs)) f \\<Longrightarrow> is_red (set xs) f\n 2. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "from \\<open>x \\<in> set (comp_red_basis xs)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set (comp_red_basis xs)", "obtain y where yin: \"y \\<in> set xs\" and \"y \\<noteq> 0\" and \"lt y = lt x\""], ["proof (prove)\nusing this:\n  x \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set xs; y \\<noteq> 0; lt y = lt x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule comp_red_basis_lt)"], ["proof (state)\nthis:\n  y \\<in> set xs\n  y \\<noteq> 0\n  lt y = lt x\n\ngoal (2 subgoals):\n 1. is_red (set (comp_red_basis xs)) f \\<Longrightarrow> is_red (set xs) f\n 2. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "show \"is_red (set xs) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red (set xs) f", "proof (rule is_red_addsI)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?f \\<in> set xs\n 2. ?f \\<noteq> 0\n 3. ?v \\<in> keys f\n 4. lt ?f adds\\<^sub>t ?v", "from \\<open>lt x adds\\<^sub>t t\\<close>"], ["proof (chain)\npicking this:\n  lt x adds\\<^sub>t t", "show \"lt y adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  lt x adds\\<^sub>t t\n\ngoal (1 subgoal):\n 1. lt y adds\\<^sub>t t", "unfolding \\<open>lt y = lt x\\<close>"], ["proof (prove)\nusing this:\n  lt x adds\\<^sub>t t\n\ngoal (1 subgoal):\n 1. lt x adds\\<^sub>t t", "."], ["proof (state)\nthis:\n  lt y adds\\<^sub>t t\n\ngoal (3 subgoals):\n 1. y \\<in> set xs\n 2. y \\<noteq> 0\n 3. t \\<in> keys f", "qed fact+"], ["proof (state)\nthis:\n  is_red (set xs) f\n\ngoal (1 subgoal):\n 1. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "assume \"is_red (set xs) f\""], ["proof (state)\nthis:\n  is_red (set xs) f\n\ngoal (1 subgoal):\n 1. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "then"], ["proof (chain)\npicking this:\n  is_red (set xs) f", "obtain x t where \"x \\<in> set xs\" and \"t \\<in> keys f\" and \"x \\<noteq> 0\" and \"lt x adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  is_red (set xs) f\n\ngoal (1 subgoal):\n 1. (\\<And>x t.\n        \\<lbrakk>x \\<in> set xs; t \\<in> keys f; x \\<noteq> 0;\n         lt x adds\\<^sub>t t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_red_addsE)"], ["proof (state)\nthis:\n  x \\<in> set xs\n  t \\<in> keys f\n  x \\<noteq> 0\n  lt x adds\\<^sub>t t\n\ngoal (1 subgoal):\n 1. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "from \\<open>x \\<in> set xs\\<close> \\<open>x \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  x \\<noteq> 0", "obtain y where yin: \"y \\<in> set (comp_red_basis xs)\" and \"lt y adds\\<^sub>t lt x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> set (comp_red_basis xs);\n         lt y adds\\<^sub>t lt x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule comp_red_basis_adds)"], ["proof (state)\nthis:\n  y \\<in> set (comp_red_basis xs)\n  lt y adds\\<^sub>t lt x\n\ngoal (1 subgoal):\n 1. is_red (set xs) f \\<Longrightarrow> is_red (set (comp_red_basis xs)) f", "show \"is_red (set (comp_red_basis xs)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_red (set (comp_red_basis xs)) f", "proof (rule is_red_addsI)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?f \\<in> set (comp_red_basis xs)\n 2. ?f \\<noteq> 0\n 3. ?v \\<in> keys f\n 4. lt ?f adds\\<^sub>t ?v", "from \\<open>lt y adds\\<^sub>t lt x\\<close> \\<open>lt x adds\\<^sub>t t\\<close>"], ["proof (chain)\npicking this:\n  lt y adds\\<^sub>t lt x\n  lt x adds\\<^sub>t t", "show \"lt y adds\\<^sub>t t\""], ["proof (prove)\nusing this:\n  lt y adds\\<^sub>t lt x\n  lt x adds\\<^sub>t t\n\ngoal (1 subgoal):\n 1. lt y adds\\<^sub>t t", "by (rule adds_term_trans)"], ["proof (state)\nthis:\n  lt y adds\\<^sub>t t\n\ngoal (3 subgoals):\n 1. y \\<in> set (comp_red_basis xs)\n 2. y \\<noteq> 0\n 3. t \\<in> keys f", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. y \\<in> set (comp_red_basis xs)\n 2. y \\<noteq> 0\n 3. t \\<in> keys f", "from yin"], ["proof (chain)\npicking this:\n  y \\<in> set (comp_red_basis xs)", "show \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by (rule comp_red_basis_nonzero)"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y \\<in> set (comp_red_basis xs)\n 2. t \\<in> keys f", "qed fact+"], ["proof (state)\nthis:\n  is_red (set (comp_red_basis xs)) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_is_auto_reduced: \"is_auto_reduced (set (comp_red_basis xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_auto_reduced (set (comp_red_basis xs))", "unfolding is_auto_reduced_def remove_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (comp_red_basis xs).\n       \\<not> is_red (set (comp_red_basis xs) - {b}) b", "proof (intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set (comp_red_basis xs) \\<Longrightarrow>\n       \\<not> is_red (set (comp_red_basis xs) - {b}) b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set (comp_red_basis xs) \\<Longrightarrow>\n       \\<not> is_red (set (comp_red_basis xs) - {b}) b", "assume xin: \"x \\<in> set (comp_red_basis xs)\""], ["proof (state)\nthis:\n  x \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> set (comp_red_basis xs) \\<Longrightarrow>\n       \\<not> is_red (set (comp_red_basis xs) - {b}) b", "show \"\\<not> is_red (set (comp_red_basis xs) - {x}) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (comp_red_basis xs) - {x}) x", "unfolding comp_red_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_red (set (comp_red_basis_aux (comp_min_basis xs) []) - {x}) x", "proof (rule comp_red_basis_aux_irred, simp_all, rule comp_min_basis_is_minimal_basis, rule comp_min_basis_distinct)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])", "from xin"], ["proof (chain)\npicking this:\n  x \\<in> set (comp_red_basis xs)", "show \"x \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\""], ["proof (prove)\nusing this:\n  x \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. x \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])", "unfolding comp_red_basis_def"], ["proof (prove)\nusing this:\n  x \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal (1 subgoal):\n 1. x \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])", "."], ["proof (state)\nthis:\n  x \\<in> set (comp_red_basis_aux (comp_min_basis xs) [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_red (set (comp_red_basis xs) - {x}) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_basis_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "have \"dgrad_p_set_le d (set (comp_red_basis xs)) (set (comp_min_basis xs) \\<union> set [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs))\n     (set (comp_min_basis xs) \\<union> set [])", "unfolding comp_red_basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis_aux (comp_min_basis xs) []))\n     (set (comp_min_basis xs) \\<union> set [])", "using assms"], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis_aux (comp_min_basis xs) []))\n     (set (comp_min_basis xs) \\<union> set [])", "by (rule comp_red_basis_aux_dgrad_p_set_le)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis xs))\n   (set (comp_min_basis xs) \\<union> set [])\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "also"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis xs))\n   (set (comp_min_basis xs) \\<union> set [])\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "have \"... = set (comp_min_basis xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (comp_min_basis xs) \\<union> set [] = set (comp_min_basis xs)", "by simp"], ["proof (state)\nthis:\n  set (comp_min_basis xs) \\<union> set [] = set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "also"], ["proof (state)\nthis:\n  set (comp_min_basis xs) \\<union> set [] = set (comp_min_basis xs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "from comp_min_basis_subset"], ["proof (chain)\npicking this:\n  set (comp_min_basis ?xs) \\<subseteq> set ?xs", "have \"dgrad_p_set_le d ... (set xs)\""], ["proof (prove)\nusing this:\n  set (comp_min_basis ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_min_basis xs)) (set xs)", "by (rule dgrad_p_set_le_subset)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_min_basis xs)) (set xs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "finally"], ["proof (chain)\npicking this:\n  dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "."], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Auto-Reduction and Monicity\\<close>"], ["", "definition comp_red_monic_basis :: \"('t \\<Rightarrow>\\<^sub>0 'b) list \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::field) list\" where\n  \"comp_red_monic_basis xs = map monic (comp_red_basis xs)\""], ["", "lemma set_comp_red_monic_basis: \"set (comp_red_monic_basis xs) = monic ` (set (comp_red_basis xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (comp_red_monic_basis xs) = monic ` set (comp_red_basis xs)", "by (simp add: comp_red_monic_basis_def)"], ["", "lemma comp_red_monic_basis_nonzero:\n  assumes \"p \\<in> set (comp_red_monic_basis xs)\"\n  shows \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  p \\<in> set (comp_red_monic_basis xs)", "obtain p' where p_def: \"p = monic p'\" and p': \"p' \\<in> set (comp_red_basis xs)\""], ["proof (prove)\nusing this:\n  p \\<in> set (comp_red_monic_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p = monic p'; p' \\<in> set (comp_red_basis xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_comp_red_monic_basis"], ["proof (prove)\nusing this:\n  p \\<in> monic ` set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p = monic p'; p' \\<in> set (comp_red_basis xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = monic p'\n  p' \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "from p'"], ["proof (chain)\npicking this:\n  p' \\<in> set (comp_red_basis xs)", "have \"p' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p' \\<in> set (comp_red_basis xs)\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "by (rule comp_red_basis_nonzero)"], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "unfolding p_def monic_0_iff"], ["proof (prove)\nusing this:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "."], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_red_monic_basis_is_monic_set: \"is_monic_set (set (comp_red_monic_basis xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monic_set (set (comp_red_monic_basis xs))", "unfolding set_comp_red_monic_basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monic_set (monic ` set (comp_red_basis xs))", "by (rule image_monic_is_monic_set)"], ["", "lemma pmdl_comp_red_monic_basis_subset: \"pmdl (set (comp_red_monic_basis xs)) \\<subseteq> pmdl (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_monic_basis xs)) \\<subseteq> pmdl (set xs)", "unfolding set_comp_red_monic_basis pmdl_image_monic"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (set (comp_red_basis xs)) \\<subseteq> pmdl (set xs)", "by (fact pmdl_comp_red_basis_subset)"], ["", "lemma comp_red_monic_basis_is_auto_reduced: \"is_auto_reduced (set (comp_red_monic_basis xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_auto_reduced (set (comp_red_monic_basis xs))", "unfolding set_comp_red_monic_basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_auto_reduced (monic ` set (comp_red_basis xs))", "by (rule image_monic_is_auto_reduced, rule comp_red_basis_is_auto_reduced)"], ["", "lemma comp_red_monic_basis_dgrad_p_set_le:\n  assumes \"dickson_grading d\"\n  shows \"dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)", "have \"dgrad_p_set_le d (monic ` (set (comp_red_basis xs))) (set (comp_red_basis xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (monic ` set (comp_red_basis xs))\n     (set (comp_red_basis xs))", "by (simp add: dgrad_p_set_le_def, fact dgrad_set_le_refl)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (monic ` set (comp_red_basis xs))\n   (set (comp_red_basis xs))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)", "also"], ["proof (state)\nthis:\n  dgrad_p_set_le d (monic ` set (comp_red_basis xs))\n   (set (comp_red_basis xs))\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)", "from assms"], ["proof (chain)\npicking this:\n  dickson_grading d", "have \"dgrad_p_set_le d ... (set xs)\""], ["proof (prove)\nusing this:\n  dickson_grading d\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)", "by (rule comp_red_basis_dgrad_p_set_le)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_basis xs)) (set xs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)", "finally"], ["proof (chain)\npicking this:\n  dgrad_p_set_le d (monic ` set (comp_red_basis xs)) (set xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  dgrad_p_set_le d (monic ` set (comp_red_basis xs)) (set xs)\n\ngoal (1 subgoal):\n 1. dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)", "by (simp add: set_comp_red_monic_basis)"], ["proof (state)\nthis:\n  dgrad_p_set_le d (set (comp_red_monic_basis xs)) (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* gd_term *)"], ["", "end"], ["", "(* theory *)"]]}