{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/Syzygy_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma (in gd_term) compute_trd_aux [code]:\n  \"trd_aux fs p r =\n    (if is_zero p then\n      r\n    else\n      case find_adds fs (lt p) of\n        None   \\<Rightarrow> trd_aux fs (tail p) (plus_monomial_less r (lc p) (lt p))\n      | Some f \\<Rightarrow> trd_aux fs (tail p - monom_mult (lc p / lc f) (lp p - lp f) (tail f)) r\n    )\"", "lemma list_of_oalist_lift_keys:\n  \"list_of_oalist_ntm (lift_keys i xs) = (map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) (list_of_oalist_ntm xs))\"", "lemma lookup_lift_keys_plus:\n  \"lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) = lookup (MP_oalist xs) (term_of_pair (t, k))\"\n    (is \"?l = ?r\")", "lemma keys_lift_keys_subset:\n  \"keys (MP_oalist (lift_keys i xs)) \\<subseteq> (map_component ((+) i)) ` keys (MP_oalist xs)\" (is \"?l \\<subseteq> ?r\")", "lemma compute_adds_term_pprod [code]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\"", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\"", "lemma compute_shift_map_keys_pprod [code abstract]:\n  \"list_of_oalist_ntm (shift_map_keys_pprod t f xs) = map_raw (\\<lambda>(k, v). (splus_pprod t k, f v)) (list_of_oalist_ntm xs)\"", "lemma compute_trd_pprod [code]: \"trd_pprod to fs p = trd_aux_pprod to fs p (change_ord to 0)\"", "lemmas [code] = conversep_iff", "lemma POT_is_pot_ord: \"pprod'.is_pot_ord (TYPE('a::nat)) (TYPE('b::nat)) (POT to)\"", "lemma lift_poly_syz_MP_oalist [code]:\n  \"lift_poly_syz_pprod n (MP_oalist xs) i = MP_oalist (OAlist_insert_ntm ((0, i), 1) (lift_keys_pprod n xs))\"", "lemma\n  \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y), Vec\\<^sub>0 0 (X * Y * Z + 2 * Y\\<^sup>2)] =\n  [Vec\\<^sub>0 0 (C\\<^sub>0 (1 / 3) * X * Y * Z + C\\<^sub>0 (2 / 3) * Y\\<^sup>2) + Vec\\<^sub>0 1 (C\\<^sub>0 (- 1 / 3) * X\\<^sup>2 * Z ^ 3 - X\\<^sup>2 * Y)]\"", "lemma\n  \"map fst (gb_pprod (POT DRLEX) (map (\\<lambda>p. (p, ())) (init_syzygy_list_pprod\n    [Vec\\<^sub>0 0 (X ^ 4 + 3 * X\\<^sup>2 * Y), Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z), Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y)])) ()) =\n  [\n    Vec\\<^sub>0 0 1 + Vec\\<^sub>0 3 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 1 1 + Vec\\<^sub>0 3 (Y ^ 3 + 2 * X * Z),\n    Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z) - Vec\\<^sub>0 1 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 2 1 + Vec\\<^sub>0 3 (Z\\<^sup>2 - X - Y),\n    Vec\\<^sub>0 1 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (Y ^ 3 + 2 * X * Z),\n    Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 0 (- (Y ^ 3 * Z\\<^sup>2) + Y ^ 4 + X * Y ^ 3 + 2 * X\\<^sup>2 * Z + 2 * X * Y * Z - 2 * X * Z ^ 3) +\n      Vec\\<^sub>0 1 (X ^ 4 * Z\\<^sup>2 - X ^ 5 - X ^ 4 * Y - 3 * X ^ 3 * Y - 3 * X\\<^sup>2 * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y * Z\\<^sup>2)\n  ]\"", "lemma\n  \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X ^ 4 + 3 * X\\<^sup>2 * Y), Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z), Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y)] =\n  [\n    Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z) - Vec\\<^sub>0 1 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 1 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (Y ^ 3 + 2 * X * Z),\n    Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 0 (- (Y ^ 3 * Z\\<^sup>2) + Y ^ 4 + X * Y ^ 3 + 2 * X\\<^sup>2 * Z + 2 * X * Y * Z - 2 * X * Z ^ 3) +\n      Vec\\<^sub>0 1 (X ^ 4 * Z\\<^sup>2 - X ^ 5 - X ^ 4 * Y - 3 * X ^ 3 * Y - 3 * X\\<^sup>2 * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y * Z\\<^sup>2)\n  ]\"", "lemma\n  \"map fst (gb_pprod (POT DRLEX) (map (\\<lambda>p. (p, ())) (init_syzygy_list_pprod\n    [Vec\\<^sub>0 0 (X * Y - Z), Vec\\<^sub>0 0 (X * Z - Y), Vec\\<^sub>0 0 (Y * Z - X)])) ()) =\n  [\n    Vec\\<^sub>0 0 1 + Vec\\<^sub>0 3 (X * Y - Z),\n    Vec\\<^sub>0 1 1 + Vec\\<^sub>0 3 (X * Z - Y),\n    Vec\\<^sub>0 2 1 + Vec\\<^sub>0 3 (Y * Z - X),\n    Vec\\<^sub>0 0 (- X * Z + Y) + Vec\\<^sub>0 1 (X * Y - Z),\n    Vec\\<^sub>0 0 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Y - Z),\n    Vec\\<^sub>0 1 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Z - Y),\n    Vec\\<^sub>0 1 (-Y) + Vec\\<^sub>0 2 (X) + Vec\\<^sub>0 3 (Y ^ 2 - X ^ 2),\n    Vec\\<^sub>0 0 (Z) + Vec\\<^sub>0 2 (-X) + Vec\\<^sub>0 3 (X ^ 2 - Z ^ 2),\n    Vec\\<^sub>0 0 (Y - Y * Z ^ 2) + Vec\\<^sub>0 1 (Y ^ 2 * Z - Z) + Vec\\<^sub>0 2 (Y ^ 2 - Z ^ 2),\n    Vec\\<^sub>0 0 (- Y) + Vec\\<^sub>0 1 (- (X * Y)) + Vec\\<^sub>0 2 (X ^ 2 - 1) + Vec\\<^sub>0 3 (X - X ^ 3)\n  ]\"", "lemma\n  \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X * Y - Z), Vec\\<^sub>0 0 (X * Z - Y), Vec\\<^sub>0 0 (Y * Z - X)] =\n  [\n    Vec\\<^sub>0 0 (- X * Z + Y) + Vec\\<^sub>0 1 (X * Y - Z),\n    Vec\\<^sub>0 0 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Y - Z),\n    Vec\\<^sub>0 1 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Z - Y),\n    Vec\\<^sub>0 0 (Y - Y * Z ^ 2) + Vec\\<^sub>0 1 (Y ^ 2 * Z - Z) + Vec\\<^sub>0 2 (Y ^ 2 - Z ^ 2)\n  ]\""], "translations": [["", "lemma (in gd_term) compute_trd_aux [code]:\n  \"trd_aux fs p r =\n    (if is_zero p then\n      r\n    else\n      case find_adds fs (lt p) of\n        None   \\<Rightarrow> trd_aux fs (tail p) (plus_monomial_less r (lc p) (lt p))\n      | Some f \\<Rightarrow> trd_aux fs (tail p - monom_mult (lc p / lc f) (lp p - lp f) (tail f)) r\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd_aux fs p r =\n    (if is_zero p then r\n     else case find_adds fs (lt p) of\n          None \\<Rightarrow>\n            trd_aux fs (tail p) (plus_monomial_less r (lc p) (lt p))\n          | Some f \\<Rightarrow>\n              trd_aux fs\n               (tail p - monom_mult (lc p / lc f) (lp p - lp f) (tail f)) r)", "by (simp only: trd_aux.simps[of fs p r] plus_monomial_less_def is_zero_def)"], ["", "locale gd_nat_inf_term = gd_nat_term pair_of_term term_of_pair cmp_term\n    for pair_of_term::\"'t::nat_term \\<Rightarrow> ('a::{nat_term,graded_dickson_powerprod} \\<times> nat)\"\n    and term_of_pair::\"('a \\<times> nat) \\<Rightarrow> 't\"\n    and cmp_term\nbegin"], ["", "sublocale aux: gd_inf_term pair_of_term term_of_pair\n        \"\\<lambda>s t. le_of_nat_term_order cmp_term (term_of_pair (s, the_min)) (term_of_pair (t, the_min))\"\n        \"\\<lambda>s t. lt_of_nat_term_order cmp_term (term_of_pair (s, the_min)) (term_of_pair (t, the_min))\"\n        \"le_of_nat_term_order cmp_term\"\n        \"lt_of_nat_term_order cmp_term\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_inf_term pair_of_term term_of_pair\n     (\\<lambda>s t.\n         le_of_nat_term_order cmp_term (term_of_pair (s, the_min))\n          (term_of_pair (t, the_min)))\n     (\\<lambda>s t.\n         lt_of_nat_term_order cmp_term (term_of_pair (s, the_min))\n          (term_of_pair (t, the_min)))\n     (le_of_nat_term_order cmp_term) (lt_of_nat_term_order cmp_term)", ".."], ["", "definition lift_keys :: \"nat \\<Rightarrow> ('t, 'b) oalist_ntm \\<Rightarrow> ('t, 'b::semiring_0) oalist_ntm\"\n  where \"lift_keys i xs = oalist_of_list_ntm (map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) (list_of_oalist_ntm xs))\""], ["", "lemma list_of_oalist_lift_keys:\n  \"list_of_oalist_ntm (lift_keys i xs) = (map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) (list_of_oalist_ntm xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_ntm (lift_keys i xs) =\n    map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n     (list_of_oalist_ntm xs)", "unfolding lift_keys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_ntm\n     (oalist_of_list_ntm\n       (map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n         (list_of_oalist_ntm xs))) =\n    map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n     (list_of_oalist_ntm xs)", "oops"], ["", "text \\<open>Regardless of whether the above lemma holds (which might be the case) or not, we can use\n  @{const lift_keys} in computations. Now, however, it is implemented rather inefficiently, because\n  the list resulting from the application of @{const map_raw} is sorted again. That should not be\n  a big problem though, since @{const lift_keys} is applied only once to every input polynomial\n  before computing syzygies.\\<close>"], ["", "lemma lookup_lift_keys_plus:\n  \"lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) = lookup (MP_oalist xs) (term_of_pair (t, k))\"\n    (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "let ?f = \"\\<lambda>kv::'t \\<times> 'b. (map_component ((+) i) (fst kv), snd kv)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "obtain xs' ox where xs: \"list_of_oalist_ntm xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        list_of_oalist_ntm xs = (xs', ox) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_of_oalist_ntm xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "from oalist_inv_list_of_oalist_ntm[of xs]"], ["proof (chain)\npicking this:\n  ko_ntm.oalist_inv (list_of_oalist_ntm xs)", "have inv: \"ko_ntm.oalist_inv_raw ox xs'\""], ["proof (prove)\nusing this:\n  ko_ntm.oalist_inv (list_of_oalist_ntm xs)\n\ngoal (1 subgoal):\n 1. ko_ntm.oalist_inv_raw ox xs'", "by (simp add: xs ko_ntm.oalist_inv_def nat_term_compare_inv_conv)"], ["proof (state)\nthis:\n  ko_ntm.oalist_inv_raw ox xs'\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "let ?rel = \"ko.lt (key_order_of_nat_term_order_inv ox)\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have \"irreflp ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflp (ko.lt (key_order_of_nat_term_order_inv ox))", "by (simp add: irreflp_def)"], ["proof (state)\nthis:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "moreover"], ["proof (state)\nthis:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have \"transp ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (ko.lt (key_order_of_nat_term_order_inv ox))", "by (simp add: lt_of_nat_term_order_alt)"], ["proof (state)\nthis:\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "moreover"], ["proof (state)\nthis:\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "from oa_ntm.list_of_oalist_sorted[of xs]"], ["proof (chain)\npicking this:\n  sorted_wrt\n   (ko.lt (key_order_of_nat_term_order_inv (snd (list_of_oalist_ntm xs))))\n   (map fst (fst (list_of_oalist_ntm xs)))", "have \"sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')\""], ["proof (prove)\nusing this:\n  sorted_wrt\n   (ko.lt (key_order_of_nat_term_order_inv (snd (list_of_oalist_ntm xs))))\n   (map fst (fst (list_of_oalist_ntm xs)))\n\ngoal (1 subgoal):\n 1. sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')", "by (simp add: xs)"], ["proof (state)\nthis:\n  sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "ultimately"], ["proof (chain)\npicking this:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n  sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')", "have dist1: \"distinct (map fst xs')\""], ["proof (prove)\nusing this:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n  sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')\n\ngoal (1 subgoal):\n 1. distinct (map fst xs')", "by (rule distinct_sorted_wrt_irrefl)"], ["proof (state)\nthis:\n  distinct (map fst xs')\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have 1: \"u = v\" if \"map_component ((+) i) u = map_component ((+) i) v\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v", "have \"inj ((+) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((+) i)", "by (simp add: inj_def)"], ["proof (state)\nthis:\n  inj ((+) i)\n\ngoal (1 subgoal):\n 1. u = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj ((+) i)\n\ngoal (1 subgoal):\n 1. u = v", "using that"], ["proof (prove)\nusing this:\n  inj ((+) i)\n  map_component ((+) i) u = map_component ((+) i) v\n\ngoal (1 subgoal):\n 1. u = v", "by (rule map_component_inj)"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_component ((+) i) ?u100 =\n  map_component ((+) i) ?v100 \\<Longrightarrow>\n  ?u100 = ?v100\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have dist2: \"distinct (map fst (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n         xs'))", "by (rule ko_ntm.distinct_map_pair, fact dist1, simp add: 1)"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs'))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have \"?l = lookup_dflt (map_pair ?f xs') (term_of_pair (t, i + k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup_dflt\n     (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n     (term_of_pair (t, i + k))", "by (simp add: oa_ntm.lookup_def lift_keys_def xs oalist_of_list_ntm_def list_of_oalist_OAlist_ntm\n        ko_ntm.lookup_pair_sort_oalist'[OF dist2])"], ["proof (state)\nthis:\n  lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (term_of_pair (t, i + k))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "also"], ["proof (state)\nthis:\n  lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (term_of_pair (t, i + k))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have \"... = lookup_dflt (map_pair ?f xs') (fst (?f (term_of_pair (t, k), b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_dflt\n     (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n     (term_of_pair (t, i + k)) =\n    lookup_dflt\n     (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n     (fst (map_component ((+) i) (fst (term_of_pair (t, k), b)),\n           snd (term_of_pair (t, k), b)))", "by (simp add: map_component_term_of_pair)"], ["proof (state)\nthis:\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (term_of_pair (t, i + k)) =\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (fst (map_component ((+) i) (fst (term_of_pair (t, k), b)),\n         snd (term_of_pair (t, k), b)))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "also"], ["proof (state)\nthis:\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (term_of_pair (t, i + k)) =\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (fst (map_component ((+) i) (fst (term_of_pair (t, k), b)),\n         snd (term_of_pair (t, k), b)))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have \"... = snd (?f (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_dflt\n     (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n     (fst (map_component ((+) i) (fst (term_of_pair (t, k), b)),\n           snd (term_of_pair (t, k), b))) =\n    snd (map_component ((+) i)\n          (fst (term_of_pair (t, k),\n                lookup_dflt xs' (term_of_pair (t, k)))),\n         snd (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k))))", "by (rule ko_ntm.lookup_dflt_map_pair, fact dist1, auto intro: 1)"], ["proof (state)\nthis:\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (fst (map_component ((+) i) (fst (term_of_pair (t, k), b)),\n         snd (term_of_pair (t, k), b))) =\n  snd (map_component ((+) i)\n        (fst (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k)))),\n       snd (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k))))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "also"], ["proof (state)\nthis:\n  lookup_dflt\n   (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs')\n   (fst (map_component ((+) i) (fst (term_of_pair (t, k), b)),\n         snd (term_of_pair (t, k), b))) =\n  snd (map_component ((+) i)\n        (fst (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k)))),\n       snd (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k))))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "have \"... = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (map_component ((+) i)\n          (fst (term_of_pair (t, k),\n                lookup_dflt xs' (term_of_pair (t, k)))),\n         snd (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k)))) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "by (simp add: oa_ntm.lookup_def xs ko_ntm.lookup_dflt_eq_lookup_pair[OF inv])"], ["proof (state)\nthis:\n  snd (map_component ((+) i)\n        (fst (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k)))),\n       snd (term_of_pair (t, k), lookup_dflt xs' (term_of_pair (t, k)))) =\n  lookup (MP_oalist xs) (term_of_pair (t, k))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "finally"], ["proof (chain)\npicking this:\n  lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n  lookup (MP_oalist xs) (term_of_pair (t, k))", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n  lookup (MP_oalist xs) (term_of_pair (t, k))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n    lookup (MP_oalist xs) (term_of_pair (t, k))", "."], ["proof (state)\nthis:\n  lookup (MP_oalist (lift_keys i xs)) (term_of_pair (t, i + k)) =\n  lookup (MP_oalist xs) (term_of_pair (t, k))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_lift_keys_subset:\n  \"keys (MP_oalist (lift_keys i xs)) \\<subseteq> (map_component ((+) i)) ` keys (MP_oalist xs)\" (is \"?l \\<subseteq> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "let ?f = \"\\<lambda>kv::'t \\<times> 'b. (map_component ((+) i) (fst kv), snd kv)\""], ["proof (state)\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "obtain xs' ox where xs: \"list_of_oalist_ntm xs = (xs', ox)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs' ox.\n        list_of_oalist_ntm xs = (xs', ox) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  list_of_oalist_ntm xs = (xs', ox)\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "let ?rel = \"ko.lt (key_order_of_nat_term_order_inv ox)\""], ["proof (state)\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "have \"irreflp ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflp (ko.lt (key_order_of_nat_term_order_inv ox))", "by (simp add: irreflp_def)"], ["proof (state)\nthis:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "moreover"], ["proof (state)\nthis:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "have \"transp ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (ko.lt (key_order_of_nat_term_order_inv ox))", "by (simp add: lt_of_nat_term_order_alt)"], ["proof (state)\nthis:\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "moreover"], ["proof (state)\nthis:\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "from oa_ntm.list_of_oalist_sorted[of xs]"], ["proof (chain)\npicking this:\n  sorted_wrt\n   (ko.lt (key_order_of_nat_term_order_inv (snd (list_of_oalist_ntm xs))))\n   (map fst (fst (list_of_oalist_ntm xs)))", "have \"sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')\""], ["proof (prove)\nusing this:\n  sorted_wrt\n   (ko.lt (key_order_of_nat_term_order_inv (snd (list_of_oalist_ntm xs))))\n   (map fst (fst (list_of_oalist_ntm xs)))\n\ngoal (1 subgoal):\n 1. sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')", "by (simp add: xs)"], ["proof (state)\nthis:\n  sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "ultimately"], ["proof (chain)\npicking this:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n  sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')", "have dist1: \"distinct (map fst xs')\""], ["proof (prove)\nusing this:\n  irreflp (ko.lt (key_order_of_nat_term_order_inv ox))\n  transp (ko.lt (key_order_of_nat_term_order_inv ox))\n  sorted_wrt (ko.lt (key_order_of_nat_term_order_inv ox)) (map fst xs')\n\ngoal (1 subgoal):\n 1. distinct (map fst xs')", "by (rule distinct_sorted_wrt_irrefl)"], ["proof (state)\nthis:\n  distinct (map fst xs')\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "have 1: \"u = v\" if \"map_component ((+) i) u = map_component ((+) i) v\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v", "have \"inj ((+) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((+) i)", "by (simp add: inj_def)"], ["proof (state)\nthis:\n  inj ((+) i)\n\ngoal (1 subgoal):\n 1. u = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj ((+) i)\n\ngoal (1 subgoal):\n 1. u = v", "using that"], ["proof (prove)\nusing this:\n  inj ((+) i)\n  map_component ((+) i) u = map_component ((+) i) v\n\ngoal (1 subgoal):\n 1. u = v", "by (rule map_component_inj)"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_component ((+) i) ?u100 =\n  map_component ((+) i) ?v100 \\<Longrightarrow>\n  ?u100 = ?v100\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "have dist2: \"distinct (map fst (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n         xs'))", "by (rule ko_ntm.distinct_map_pair, fact dist1, simp add: 1)"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (map_pair (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) xs'))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "have \"?l \\<subseteq> fst ` set (fst (map_raw ?f (list_of_oalist_ntm xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> fst `\n                set (fst (map_raw\n                           (\\<lambda>kv.\n                               (map_component ((+) i) (fst kv), snd kv))\n                           (list_of_oalist_ntm xs)))", "by (auto simp: keys_MP_oalist lift_keys_def oalist_of_list_ntm_def list_of_oalist_OAlist_ntm xs\n        ko_ntm.set_sort_oalist[OF dist2])"], ["proof (state)\nthis:\n  keys (MP_oalist (lift_keys i xs))\n  \\<subseteq> fst `\n              set (fst (map_raw\n                         (\\<lambda>kv.\n                             (map_component ((+) i) (fst kv), snd kv))\n                         (list_of_oalist_ntm xs)))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "also"], ["proof (state)\nthis:\n  keys (MP_oalist (lift_keys i xs))\n  \\<subseteq> fst `\n              set (fst (map_raw\n                         (\\<lambda>kv.\n                             (map_component ((+) i) (fst kv), snd kv))\n                         (list_of_oalist_ntm xs)))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "from ko_ntm.map_raw_subset"], ["proof (chain)\npicking this:\n  set (fst (map_raw ?f ?xs)) \\<subseteq> ?f ` set (fst ?xs)", "have \"... \\<subseteq> fst ` ?f ` set (fst (list_of_oalist_ntm xs))\""], ["proof (prove)\nusing this:\n  set (fst (map_raw ?f ?xs)) \\<subseteq> ?f ` set (fst ?xs)\n\ngoal (1 subgoal):\n 1. fst `\n    set (fst (map_raw\n               (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n               (list_of_oalist_ntm xs)))\n    \\<subseteq> fst `\n                (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) `\n                set (fst (list_of_oalist_ntm xs))", "by (rule image_mono)"], ["proof (state)\nthis:\n  fst `\n  set (fst (map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n             (list_of_oalist_ntm xs)))\n  \\<subseteq> fst `\n              (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) `\n              set (fst (list_of_oalist_ntm xs))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "also"], ["proof (state)\nthis:\n  fst `\n  set (fst (map_raw (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv))\n             (list_of_oalist_ntm xs)))\n  \\<subseteq> fst `\n              (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) `\n              set (fst (list_of_oalist_ntm xs))\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "have \"... \\<subseteq> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) `\n    set (fst (list_of_oalist_ntm xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "by (simp add: keys_MP_oalist image_image)"], ["proof (state)\nthis:\n  fst `\n  (\\<lambda>kv. (map_component ((+) i) (fst kv), snd kv)) `\n  set (fst (list_of_oalist_ntm xs))\n  \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "finally"], ["proof (chain)\npicking this:\n  keys (MP_oalist (lift_keys i xs))\n  \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  keys (MP_oalist (lift_keys i xs))\n  \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)\n\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys i xs))\n    \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)", "."], ["proof (state)\nthis:\n  keys (MP_oalist (lift_keys i xs))\n  \\<subseteq> map_component ((+) i) ` keys (MP_oalist xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "global_interpretation pprod': gd_nat_inf_term \"\\<lambda>x::('a, 'b) pp \\<times> nat. x\" \"\\<lambda>x. x\" cmp_term\n  rewrites \"pprod.pp_of_term = fst\"\n  and \"pprod.component_of_term = snd\"\n  and \"pprod.splus = splus_pprod\"\n  and \"pprod.monom_mult = monom_mult_pprod\"\n  and \"pprod.mult_scalar = mult_scalar_pprod\"\n  and \"pprod.adds_term = adds_term_pprod\"\n  for cmp_term :: \"(('a::nat, 'b::nat) pp \\<times> nat) nat_term_order\"\n  defines shift_map_keys_pprod = pprod'.shift_map_keys\n  and lift_keys_pprod = pprod'.lift_keys\n  and min_term_pprod = pprod'.min_term\n  and lt_pprod = pprod'.lt\n  and lc_pprod = pprod'.lc\n  and tail_pprod = pprod'.tail\n  and comp_opt_p_pprod = pprod'.comp_opt_p\n  and ord_p_pprod = pprod'.ord_p\n  and ord_strict_p_pprod = pprod'.ord_strict_p\n  and find_adds_pprod = pprod'.find_adds\n  and trd_aux_pprod= pprod'.trd_aux\n  and trd_pprod = pprod'.trd\n  and spoly_pprod = pprod'.spoly\n  and count_const_lt_components_pprod = pprod'.count_const_lt_components\n  and count_rem_components_pprod = pprod'.count_rem_components\n  and const_lt_component_pprod = pprod'.const_lt_component\n  and full_gb_pprod = pprod'.full_gb\n  and keys_to_list_pprod = pprod'.keys_to_list\n  and Keys_to_list_pprod = pprod'.Keys_to_list\n  and add_pairs_single_sorted_pprod = pprod'.add_pairs_single_sorted\n  and add_pairs_pprod = pprod'.add_pairs\n  and canon_pair_order_aux_pprod = pprod'.canon_pair_order_aux\n  and canon_basis_order_pprod = pprod'.canon_basis_order\n  and new_pairs_sorted_pprod = pprod'.new_pairs_sorted\n  and component_crit_pprod = pprod'.component_crit\n  and chain_ncrit_pprod = pprod'.chain_ncrit\n  and chain_ocrit_pprod = pprod'.chain_ocrit\n  and apply_icrit_pprod = pprod'.apply_icrit\n  and apply_ncrit_pprod = pprod'.apply_ncrit\n  and apply_ocrit_pprod = pprod'.apply_ocrit\n  and trdsp_pprod = pprod'.trdsp\n  and gb_sel_pprod = pprod'.gb_sel\n  and gb_red_aux_pprod = pprod'.gb_red_aux\n  and gb_red_pprod = pprod'.gb_red\n  and gb_aux_pprod = pprod'.gb_aux\n  and gb_pprod = pprod'.gb\n  and filter_syzygy_basis_pprod = pprod'.aux.filter_syzygy_basis\n  and init_syzygy_list_pprod = pprod'.aux.init_syzygy_list\n  and lift_poly_syz_pprod = pprod'.aux.lift_poly_syz\n  and map_component_pprod = pprod'.map_component"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gd_nat_inf_term (\\<lambda>x. x) (\\<lambda>x. x) cmp_term &&&\n     pprod.pp_of_term = fst &&& pprod.component_of_term = snd) &&&\n    (pprod.splus = splus_pprod &&& pprod.monom_mult = monom_mult_pprod) &&&\n    pprod.mult_scalar = mult_scalar_pprod &&&\n    pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. gd_nat_inf_term (\\<lambda>x. x) (\\<lambda>x. x) cmp_term", "by (rule gd_nat_inf_term.intro, fact gd_nat_term_id)"], ["proof (prove)\ngoal (6 subgoals):\n 1. pprod.pp_of_term = fst\n 2. pprod.component_of_term = snd\n 3. pprod.splus = splus_pprod\n 4. pprod.monom_mult = monom_mult_pprod\n 5. pprod.mult_scalar = mult_scalar_pprod\n 6. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.pp_of_term = fst", "by (fact pprod_pp_of_term)"], ["proof (prove)\ngoal (5 subgoals):\n 1. pprod.component_of_term = snd\n 2. pprod.splus = splus_pprod\n 3. pprod.monom_mult = monom_mult_pprod\n 4. pprod.mult_scalar = mult_scalar_pprod\n 5. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.component_of_term = snd", "by (fact pprod_component_of_term)"], ["proof (prove)\ngoal (4 subgoals):\n 1. pprod.splus = splus_pprod\n 2. pprod.monom_mult = monom_mult_pprod\n 3. pprod.mult_scalar = mult_scalar_pprod\n 4. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.splus = splus_pprod", "by (simp only: splus_pprod_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. pprod.monom_mult = monom_mult_pprod\n 2. pprod.mult_scalar = mult_scalar_pprod\n 3. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.monom_mult = monom_mult_pprod", "by (simp only: monom_mult_pprod_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pprod.mult_scalar = mult_scalar_pprod\n 2. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.mult_scalar = mult_scalar_pprod", "by (simp only: mult_scalar_pprod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.adds_term = adds_term_pprod", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pprod.adds_term = adds_term_pprod", "by (simp only: adds_term_pprod_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compute_adds_term_pprod [code]:\n  \"adds_term_pprod u v = (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adds_term_pprod u v =\n    (snd u = snd v \\<and> adds_pp_add_linorder (fst u) (fst v))", "by (simp add: adds_term_pprod_def pprod.adds_term_def adds_pp_add_linorder_def)"], ["", "lemma compute_splus_pprod [code]: \"splus_pprod t (s, i) = (t + s, i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splus_pprod t (s, i) = (t + s, i)", "by (simp add: splus_pprod_def pprod.splus_def)"], ["", "lemma compute_shift_map_keys_pprod [code abstract]:\n  \"list_of_oalist_ntm (shift_map_keys_pprod t f xs) = map_raw (\\<lambda>(k, v). (splus_pprod t k, f v)) (list_of_oalist_ntm xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_oalist_ntm (shift_map_keys_pprod t f xs) =\n    map_raw (\\<lambda>(k, v). (splus_pprod t k, f v))\n     (list_of_oalist_ntm xs)", "by (simp add: pprod'.list_of_oalist_shift_keys case_prod_beta')"], ["", "lemma compute_trd_pprod [code]: \"trd_pprod to fs p = trd_aux_pprod to fs p (change_ord to 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trd_pprod to fs p = trd_aux_pprod to fs p (change_ord to 0)", "by (simp only: pprod'.trd_def change_ord_def)"], ["", "lemmas [code] = conversep_iff"], ["", "lemma POT_is_pot_ord: \"pprod'.is_pot_ord (TYPE('a::nat)) (TYPE('b::nat)) (POT to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered_term.is_pot_ord (\\<lambda>x. x) (lt_of_nat_term_order (POT to))", "by (rule pprod'.is_pot_ordI, simp add: lt_of_nat_term_order nat_term_compare_POT pot_comp rep_nat_term_prod_def,\n      simp add: comparator_of_def)"], ["", "definition Vec\\<^sub>0 :: \"nat \\<Rightarrow> (('a, nat) pp \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> (('a::nat, nat) pp \\<times> nat) \\<Rightarrow>\\<^sub>0 'b::semiring_1\" where\n  \"Vec\\<^sub>0 i p = mult_scalar_pprod p (Poly_Mapping.single (0, i) 1)\""], ["", "definition \"syzygy_basis to bs =\n    filter_syzygy_basis_pprod (length bs) (map fst (gb_pprod (POT to) (map (\\<lambda>p. (p, ())) (init_syzygy_list_pprod bs)) ()))\""], ["", "thm pprod'.aux.filter_syzygy_basis_isGB[OF POT_is_pot_ord]"], ["", "lemma lift_poly_syz_MP_oalist [code]:\n  \"lift_poly_syz_pprod n (MP_oalist xs) i = MP_oalist (OAlist_insert_ntm ((0, i), 1) (lift_keys_pprod n xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_poly_syz_pprod n (MP_oalist xs) i =\n    MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs))", "proof (rule poly_mapping_eqI, simp add: pprod'.aux.lookup_lift_poly_syz del: MP_oalist.rep_eq, intro conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "fix v::\"('a, 'b) pp \\<times> nat\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "assume \"n \\<le> snd v\""], ["proof (state)\nthis:\n  n \\<le> snd v\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "moreover"], ["proof (state)\nthis:\n  n \\<le> snd v\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "obtain t k where \"v = (t, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t k. v = (t, k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v = (t, k)\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> snd v\n  v = (t, k)", "have k: \"n + (k - n) = k\""], ["proof (prove)\nusing this:\n  n \\<le> snd v\n  v = (t, k)\n\ngoal (1 subgoal):\n 1. n + (k - n) = k", "by simp"], ["proof (state)\nthis:\n  n + (k - n) = k\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "hence v: \"v = (t, n + (k - n))\""], ["proof (prove)\nusing this:\n  n + (k - n) = k\n\ngoal (1 subgoal):\n 1. v = (t, n + (k - n))", "by (simp only: \\<open>v = (t, k)\\<close>)"], ["proof (state)\nthis:\n  v = (t, n + (k - n))\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "assume \"v \\<noteq> (0, i)\""], ["proof (state)\nthis:\n  v \\<noteq> (0, i)\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "hence \"lookup (MP_oalist (OAlist_insert_ntm ((0, i), 1) (lift_keys_pprod n xs))) v =\n          lookup (MP_oalist (lift_keys_pprod n xs)) v\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0, i)\n\ngoal (1 subgoal):\n 1. lookup\n     (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n     v =\n    lookup (MP_oalist (lift_keys_pprod n xs)) v", "by (simp add: oa_ntm.lookup_insert)"], ["proof (state)\nthis:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  lookup (MP_oalist (lift_keys_pprod n xs)) v\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "also"], ["proof (state)\nthis:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  lookup (MP_oalist (lift_keys_pprod n xs)) v\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "have \"... = lookup (MP_oalist xs) (t, k - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v =\n    lookup (MP_oalist xs) (t, k - n)", "by (simp only: v pprod'.lookup_lift_keys_plus)"], ["proof (state)\nthis:\n  lookup (MP_oalist (lift_keys_pprod n xs)) v =\n  lookup (MP_oalist xs) (t, k - n)\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "also"], ["proof (state)\nthis:\n  lookup (MP_oalist (lift_keys_pprod n xs)) v =\n  lookup (MP_oalist xs) (t, k - n)\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "have \"... = lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (MP_oalist xs) (t, k - n) =\n    lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v)", "by (simp add: v pprod'.map_component_term_of_pair)"], ["proof (state)\nthis:\n  lookup (MP_oalist xs) (t, k - n) =\n  lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v)\n\ngoal (4 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup (MP_oalist xs)\n                          (map_component_pprod (\\<lambda>k. k - n) k) =\n                         lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 4. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "finally"], ["proof (chain)\npicking this:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v)", "show \"lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v) =\n                  lookup (MP_oalist (OAlist_insert_ntm ((0, i), 1) (lift_keys_pprod n xs))) v\""], ["proof (prove)\nusing this:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v)\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v) =\n    lookup\n     (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n     v", "by (rule HOL.sym)"], ["proof (state)\nthis:\n  lookup (MP_oalist xs) (map_component_pprod (\\<lambda>k. k - n) v) =\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs))) v\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "fix v::\"('a, 'b) pp \\<times> nat\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "assume \"\\<not> n \\<le> snd v\""], ["proof (state)\nthis:\n  \\<not> n \\<le> snd v\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "assume \"v \\<noteq> (0, i)\""], ["proof (state)\nthis:\n  v \\<noteq> (0, i)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "hence \"lookup (MP_oalist (OAlist_insert_ntm ((0, i), 1) (lift_keys_pprod n xs))) v =\n          lookup (MP_oalist (lift_keys_pprod n xs)) v\""], ["proof (prove)\nusing this:\n  v \\<noteq> (0, i)\n\ngoal (1 subgoal):\n 1. lookup\n     (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n     v =\n    lookup (MP_oalist (lift_keys_pprod n xs)) v", "by (simp add: add: oa_ntm.lookup_insert)"], ["proof (state)\nthis:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  lookup (MP_oalist (lift_keys_pprod n xs)) v\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "also"], ["proof (state)\nthis:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  lookup (MP_oalist (lift_keys_pprod n xs)) v\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v = (0::'c)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq>\n    (0::'c) \\<Longrightarrow>\n    False", "assume \"lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq> 0\""], ["proof (state)\nthis:\n  lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq>\n    (0::'c) \\<Longrightarrow>\n    False", "hence \"v \\<in> keys (MP_oalist (lift_keys_pprod n xs))\""], ["proof (prove)\nusing this:\n  lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. v \\<in> keys (MP_oalist (lift_keys_pprod n xs))", "by (simp add: in_keys_iff del: MP_oalist.rep_eq)"], ["proof (state)\nthis:\n  v \\<in> keys (MP_oalist (lift_keys_pprod n xs))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq>\n    (0::'c) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  v \\<in> keys (MP_oalist (lift_keys_pprod n xs))\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq>\n    (0::'c) \\<Longrightarrow>\n    False", "have \"... \\<subseteq> map_component_pprod ((+) n) ` keys (MP_oalist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (MP_oalist (lift_keys_pprod n xs))\n    \\<subseteq> map_component_pprod ((+) n) ` keys (MP_oalist xs)", "by (fact pprod'.keys_lift_keys_subset)"], ["proof (state)\nthis:\n  keys (MP_oalist (lift_keys_pprod n xs))\n  \\<subseteq> map_component_pprod ((+) n) ` keys (MP_oalist xs)\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq>\n    (0::'c) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  v \\<in> map_component_pprod ((+) n) ` keys (MP_oalist xs)", "obtain u where \"v = map_component_pprod ((+) n) u\""], ["proof (prove)\nusing this:\n  v \\<in> map_component_pprod ((+) n) ` keys (MP_oalist xs)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        v = map_component_pprod ((+) n) u \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v = map_component_pprod ((+) n) u\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq>\n    (0::'c) \\<Longrightarrow>\n    False", "hence \"snd v = n + snd u\""], ["proof (prove)\nusing this:\n  v = map_component_pprod ((+) n) u\n\ngoal (1 subgoal):\n 1. snd v = n + snd u", "by (simp add: pprod'.component_of_map_component)"], ["proof (state)\nthis:\n  snd v = n + snd u\n\ngoal (1 subgoal):\n 1. lookup (MP_oalist (lift_keys_pprod n xs)) v \\<noteq>\n    (0::'c) \\<Longrightarrow>\n    False", "with \\<open>\\<not> n \\<le> snd v\\<close>"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> snd v\n  snd v = n + snd u", "show False"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> snd v\n  snd v = n + snd u\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (MP_oalist (lift_keys_pprod n xs)) v = (0::'c)\n\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 3. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k \\<noteq> (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          k =\n                         (0::'c)", "finally"], ["proof (chain)\npicking this:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  (0::'c)", "show \"lookup (MP_oalist (OAlist_insert_ntm ((0, i), 1) (lift_keys_pprod n xs))) v = 0\""], ["proof (prove)\nusing this:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  (0::'c)\n\ngoal (1 subgoal):\n 1. lookup\n     (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n     v =\n    (0::'c)", "."], ["proof (state)\nthis:\n  lookup\n   (MP_oalist (OAlist_insert_ntm ((0, i), 1::'c) (lift_keys_pprod n xs)))\n   v =\n  (0::'c)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)\n 2. \\<And>k.\n       \\<lbrakk>\\<not> n \\<le> snd k; k = (0, i)\\<rbrakk>\n       \\<Longrightarrow> lookup\n                          (MP_oalist\n                            (OAlist_insert_ntm ((0, i), 1::'c)\n                              (lift_keys_pprod n xs)))\n                          (0, i) =\n                         (1::'c)", "qed (simp_all add: oa_ntm.lookup_insert)"], ["", "subsection \\<open>Computations\\<close>"], ["", "experiment begin"], ["", "interpretation trivariate\\<^sub>0_rat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma\n  \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y), Vec\\<^sub>0 0 (X * Y * Z + 2 * Y\\<^sup>2)] =\n  [Vec\\<^sub>0 0 (C\\<^sub>0 (1 / 3) * X * Y * Z + C\\<^sub>0 (2 / 3) * Y\\<^sup>2) + Vec\\<^sub>0 1 (C\\<^sub>0 (- 1 / 3) * X\\<^sup>2 * Z ^ 3 - X\\<^sup>2 * Y)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syzygy_basis DRLEX\n     [Vec\\<^sub>0 0\n       ((V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 +\n        3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n      Vec\\<^sub>0 0\n       (V\\<^sub>0 0 * V\\<^sub>0 1 * V\\<^sub>0 2 +\n        2 * (V\\<^sub>0 1)\\<^sup>2)] =\n    [Vec\\<^sub>0 0\n      (C\\<^sub>0 (1 / 3) * V\\<^sub>0 0 * V\\<^sub>0 1 * V\\<^sub>0 2 +\n       C\\<^sub>0 (2 / 3) * (V\\<^sub>0 1)\\<^sup>2) +\n     Vec\\<^sub>0 1\n      (C\\<^sub>0 (- 1 / 3) * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 ^ 3 -\n       (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1)]", "by eval"], ["", "value [code] \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X\\<^sup>2 * Z ^ 3 + 3 * X\\<^sup>2 * Y), Vec\\<^sub>0 0 (X * Y * Z + 2 * Y\\<^sup>2), Vec\\<^sub>0 0 (X - Y + 3 * Z)]\""], ["", "lemma\n  \"map fst (gb_pprod (POT DRLEX) (map (\\<lambda>p. (p, ())) (init_syzygy_list_pprod\n    [Vec\\<^sub>0 0 (X ^ 4 + 3 * X\\<^sup>2 * Y), Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z), Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y)])) ()) =\n  [\n    Vec\\<^sub>0 0 1 + Vec\\<^sub>0 3 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 1 1 + Vec\\<^sub>0 3 (Y ^ 3 + 2 * X * Z),\n    Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z) - Vec\\<^sub>0 1 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 2 1 + Vec\\<^sub>0 3 (Z\\<^sup>2 - X - Y),\n    Vec\\<^sub>0 1 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (Y ^ 3 + 2 * X * Z),\n    Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 0 (- (Y ^ 3 * Z\\<^sup>2) + Y ^ 4 + X * Y ^ 3 + 2 * X\\<^sup>2 * Z + 2 * X * Y * Z - 2 * X * Z ^ 3) +\n      Vec\\<^sub>0 1 (X ^ 4 * Z\\<^sup>2 - X ^ 5 - X ^ 4 * Y - 3 * X ^ 3 * Y - 3 * X\\<^sup>2 * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y * Z\\<^sup>2)\n  ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst\n     (gb_pprod (POT DRLEX)\n       (map (\\<lambda>p. (p, ()))\n         (init_syzygy_list_pprod\n           [Vec\\<^sub>0 0\n             (V\\<^sub>0 0 ^ 4 + 3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n            Vec\\<^sub>0 0 (V\\<^sub>0 1 ^ 3 + 2 * V\\<^sub>0 0 * V\\<^sub>0 2),\n            Vec\\<^sub>0 0\n             ((V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 - V\\<^sub>0 1)]))\n       ()) =\n    [Vec\\<^sub>0 0 1 +\n     Vec\\<^sub>0 3\n      (V\\<^sub>0 0 ^ 4 + 3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n     Vec\\<^sub>0 1 1 +\n     Vec\\<^sub>0 3 (V\\<^sub>0 1 ^ 3 + 2 * V\\<^sub>0 0 * V\\<^sub>0 2),\n     Vec\\<^sub>0 0 (V\\<^sub>0 1 ^ 3 + 2 * V\\<^sub>0 0 * V\\<^sub>0 2) -\n     Vec\\<^sub>0 1\n      (V\\<^sub>0 0 ^ 4 + 3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n     Vec\\<^sub>0 2 1 +\n     Vec\\<^sub>0 3 ((V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 - V\\<^sub>0 1),\n     Vec\\<^sub>0 1 ((V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 - V\\<^sub>0 1) -\n     Vec\\<^sub>0 2 (V\\<^sub>0 1 ^ 3 + 2 * V\\<^sub>0 0 * V\\<^sub>0 2),\n     Vec\\<^sub>0 0 ((V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 - V\\<^sub>0 1) -\n     Vec\\<^sub>0 2\n      (V\\<^sub>0 0 ^ 4 + 3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n     Vec\\<^sub>0 0\n      (- (V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2) + V\\<^sub>0 1 ^ 4 +\n       V\\<^sub>0 0 * V\\<^sub>0 1 ^ 3 +\n       2 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 +\n       2 * V\\<^sub>0 0 * V\\<^sub>0 1 * V\\<^sub>0 2 -\n       2 * V\\<^sub>0 0 * V\\<^sub>0 2 ^ 3) +\n     Vec\\<^sub>0 1\n      (V\\<^sub>0 0 ^ 4 * (V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 ^ 5 -\n       V\\<^sub>0 0 ^ 4 * V\\<^sub>0 1 -\n       3 * V\\<^sub>0 0 ^ 3 * V\\<^sub>0 1 -\n       3 * (V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 1)\\<^sup>2 +\n       3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1 * (V\\<^sub>0 2)\\<^sup>2)]", "by eval"], ["", "lemma\n  \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X ^ 4 + 3 * X\\<^sup>2 * Y), Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z), Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y)] =\n  [\n    Vec\\<^sub>0 0 (Y ^ 3 + 2 * X * Z) - Vec\\<^sub>0 1 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 1 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (Y ^ 3 + 2 * X * Z),\n    Vec\\<^sub>0 0 (Z\\<^sup>2 - X - Y) - Vec\\<^sub>0 2 (X ^ 4 + 3 * X\\<^sup>2 * Y),\n    Vec\\<^sub>0 0 (- (Y ^ 3 * Z\\<^sup>2) + Y ^ 4 + X * Y ^ 3 + 2 * X\\<^sup>2 * Z + 2 * X * Y * Z - 2 * X * Z ^ 3) +\n      Vec\\<^sub>0 1 (X ^ 4 * Z\\<^sup>2 - X ^ 5 - X ^ 4 * Y - 3 * X ^ 3 * Y - 3 * X\\<^sup>2 * Y\\<^sup>2 + 3 * X\\<^sup>2 * Y * Z\\<^sup>2)\n  ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syzygy_basis DRLEX\n     [Vec\\<^sub>0 0\n       (V\\<^sub>0 0 ^ 4 + 3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n      Vec\\<^sub>0 0 (V\\<^sub>0 1 ^ 3 + 2 * V\\<^sub>0 0 * V\\<^sub>0 2),\n      Vec\\<^sub>0 0 ((V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 - V\\<^sub>0 1)] =\n    [Vec\\<^sub>0 0 (V\\<^sub>0 1 ^ 3 + 2 * V\\<^sub>0 0 * V\\<^sub>0 2) -\n     Vec\\<^sub>0 1\n      (V\\<^sub>0 0 ^ 4 + 3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n     Vec\\<^sub>0 1 ((V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 - V\\<^sub>0 1) -\n     Vec\\<^sub>0 2 (V\\<^sub>0 1 ^ 3 + 2 * V\\<^sub>0 0 * V\\<^sub>0 2),\n     Vec\\<^sub>0 0 ((V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 - V\\<^sub>0 1) -\n     Vec\\<^sub>0 2\n      (V\\<^sub>0 0 ^ 4 + 3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1),\n     Vec\\<^sub>0 0\n      (- (V\\<^sub>0 1 ^ 3 * (V\\<^sub>0 2)\\<^sup>2) + V\\<^sub>0 1 ^ 4 +\n       V\\<^sub>0 0 * V\\<^sub>0 1 ^ 3 +\n       2 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 2 +\n       2 * V\\<^sub>0 0 * V\\<^sub>0 1 * V\\<^sub>0 2 -\n       2 * V\\<^sub>0 0 * V\\<^sub>0 2 ^ 3) +\n     Vec\\<^sub>0 1\n      (V\\<^sub>0 0 ^ 4 * (V\\<^sub>0 2)\\<^sup>2 - V\\<^sub>0 0 ^ 5 -\n       V\\<^sub>0 0 ^ 4 * V\\<^sub>0 1 -\n       3 * V\\<^sub>0 0 ^ 3 * V\\<^sub>0 1 -\n       3 * (V\\<^sub>0 0)\\<^sup>2 * (V\\<^sub>0 1)\\<^sup>2 +\n       3 * (V\\<^sub>0 0)\\<^sup>2 * V\\<^sub>0 1 * (V\\<^sub>0 2)\\<^sup>2)]", "by eval"], ["", "value [code] \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X * Y - Z), Vec\\<^sub>0 0 (X * Z - Y), Vec\\<^sub>0 0 (Y * Z - X)]\""], ["", "lemma\n  \"map fst (gb_pprod (POT DRLEX) (map (\\<lambda>p. (p, ())) (init_syzygy_list_pprod\n    [Vec\\<^sub>0 0 (X * Y - Z), Vec\\<^sub>0 0 (X * Z - Y), Vec\\<^sub>0 0 (Y * Z - X)])) ()) =\n  [\n    Vec\\<^sub>0 0 1 + Vec\\<^sub>0 3 (X * Y - Z),\n    Vec\\<^sub>0 1 1 + Vec\\<^sub>0 3 (X * Z - Y),\n    Vec\\<^sub>0 2 1 + Vec\\<^sub>0 3 (Y * Z - X),\n    Vec\\<^sub>0 0 (- X * Z + Y) + Vec\\<^sub>0 1 (X * Y - Z),\n    Vec\\<^sub>0 0 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Y - Z),\n    Vec\\<^sub>0 1 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Z - Y),\n    Vec\\<^sub>0 1 (-Y) + Vec\\<^sub>0 2 (X) + Vec\\<^sub>0 3 (Y ^ 2 - X ^ 2),\n    Vec\\<^sub>0 0 (Z) + Vec\\<^sub>0 2 (-X) + Vec\\<^sub>0 3 (X ^ 2 - Z ^ 2),\n    Vec\\<^sub>0 0 (Y - Y * Z ^ 2) + Vec\\<^sub>0 1 (Y ^ 2 * Z - Z) + Vec\\<^sub>0 2 (Y ^ 2 - Z ^ 2),\n    Vec\\<^sub>0 0 (- Y) + Vec\\<^sub>0 1 (- (X * Y)) + Vec\\<^sub>0 2 (X ^ 2 - 1) + Vec\\<^sub>0 3 (X - X ^ 3)\n  ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst\n     (gb_pprod (POT DRLEX)\n       (map (\\<lambda>p. (p, ()))\n         (init_syzygy_list_pprod\n           [Vec\\<^sub>0 0 (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2),\n            Vec\\<^sub>0 0 (V\\<^sub>0 0 * V\\<^sub>0 2 - V\\<^sub>0 1),\n            Vec\\<^sub>0 0 (V\\<^sub>0 1 * V\\<^sub>0 2 - V\\<^sub>0 0)]))\n       ()) =\n    [Vec\\<^sub>0 0 1 +\n     Vec\\<^sub>0 3 (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2),\n     Vec\\<^sub>0 1 1 +\n     Vec\\<^sub>0 3 (V\\<^sub>0 0 * V\\<^sub>0 2 - V\\<^sub>0 1),\n     Vec\\<^sub>0 2 1 +\n     Vec\\<^sub>0 3 (V\\<^sub>0 1 * V\\<^sub>0 2 - V\\<^sub>0 0),\n     Vec\\<^sub>0 0 (- V\\<^sub>0 0 * V\\<^sub>0 2 + V\\<^sub>0 1) +\n     Vec\\<^sub>0 1 (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2),\n     Vec\\<^sub>0 0 (- V\\<^sub>0 1 * V\\<^sub>0 2 + V\\<^sub>0 0) +\n     Vec\\<^sub>0 2 (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2),\n     Vec\\<^sub>0 1 (- V\\<^sub>0 1 * V\\<^sub>0 2 + V\\<^sub>0 0) +\n     Vec\\<^sub>0 2 (V\\<^sub>0 0 * V\\<^sub>0 2 - V\\<^sub>0 1),\n     Vec\\<^sub>0 1 (- V\\<^sub>0 1) + Vec\\<^sub>0 2 (V\\<^sub>0 0) +\n     Vec\\<^sub>0 3 ((V\\<^sub>0 1)\\<^sup>2 - (V\\<^sub>0 0)\\<^sup>2),\n     Vec\\<^sub>0 0 (V\\<^sub>0 2) + Vec\\<^sub>0 2 (- V\\<^sub>0 0) +\n     Vec\\<^sub>0 3 ((V\\<^sub>0 0)\\<^sup>2 - (V\\<^sub>0 2)\\<^sup>2),\n     Vec\\<^sub>0 0 (V\\<^sub>0 1 - V\\<^sub>0 1 * (V\\<^sub>0 2)\\<^sup>2) +\n     Vec\\<^sub>0 1 ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 - V\\<^sub>0 2) +\n     Vec\\<^sub>0 2 ((V\\<^sub>0 1)\\<^sup>2 - (V\\<^sub>0 2)\\<^sup>2),\n     Vec\\<^sub>0 0 (- V\\<^sub>0 1) +\n     Vec\\<^sub>0 1 (- (V\\<^sub>0 0 * V\\<^sub>0 1)) +\n     Vec\\<^sub>0 2 ((V\\<^sub>0 0)\\<^sup>2 - 1) +\n     Vec\\<^sub>0 3 (V\\<^sub>0 0 - V\\<^sub>0 0 ^ 3)]", "by eval"], ["", "lemma\n  \"syzygy_basis DRLEX [Vec\\<^sub>0 0 (X * Y - Z), Vec\\<^sub>0 0 (X * Z - Y), Vec\\<^sub>0 0 (Y * Z - X)] =\n  [\n    Vec\\<^sub>0 0 (- X * Z + Y) + Vec\\<^sub>0 1 (X * Y - Z),\n    Vec\\<^sub>0 0 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Y - Z),\n    Vec\\<^sub>0 1 (- Y * Z + X) + Vec\\<^sub>0 2 (X * Z - Y),\n    Vec\\<^sub>0 0 (Y - Y * Z ^ 2) + Vec\\<^sub>0 1 (Y ^ 2 * Z - Z) + Vec\\<^sub>0 2 (Y ^ 2 - Z ^ 2)\n  ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. syzygy_basis DRLEX\n     [Vec\\<^sub>0 0 (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2),\n      Vec\\<^sub>0 0 (V\\<^sub>0 0 * V\\<^sub>0 2 - V\\<^sub>0 1),\n      Vec\\<^sub>0 0 (V\\<^sub>0 1 * V\\<^sub>0 2 - V\\<^sub>0 0)] =\n    [Vec\\<^sub>0 0 (- V\\<^sub>0 0 * V\\<^sub>0 2 + V\\<^sub>0 1) +\n     Vec\\<^sub>0 1 (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2),\n     Vec\\<^sub>0 0 (- V\\<^sub>0 1 * V\\<^sub>0 2 + V\\<^sub>0 0) +\n     Vec\\<^sub>0 2 (V\\<^sub>0 0 * V\\<^sub>0 1 - V\\<^sub>0 2),\n     Vec\\<^sub>0 1 (- V\\<^sub>0 1 * V\\<^sub>0 2 + V\\<^sub>0 0) +\n     Vec\\<^sub>0 2 (V\\<^sub>0 0 * V\\<^sub>0 2 - V\\<^sub>0 1),\n     Vec\\<^sub>0 0 (V\\<^sub>0 1 - V\\<^sub>0 1 * (V\\<^sub>0 2)\\<^sup>2) +\n     Vec\\<^sub>0 1 ((V\\<^sub>0 1)\\<^sup>2 * V\\<^sub>0 2 - V\\<^sub>0 2) +\n     Vec\\<^sub>0 2 ((V\\<^sub>0 1)\\<^sup>2 - (V\\<^sub>0 2)\\<^sup>2)]", "by eval"], ["", "end"], ["", "end"], ["", "(* theory *)"]]}