{"file_name": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases/More_MPoly_Type_Class.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Groebner_Bases", "problem_names": ["lemma span_listE:\n  assumes \"p \\<in> span (set bs)\"\n  obtains qs where \"length qs = length bs\" and \"p = sum_list (map2 (*s) qs bs)\"", "lemma span_listI: \"sum_list (map2 (*s) qs bs) \\<in> span (set bs)\"", "lemma (in term_powerprod) monomial_1_in_pmdlI:\n  assumes \"(f::_ \\<Rightarrow>\\<^sub>0 'b::field) \\<in> pmdl F\" and \"keys f = {t}\"\n  shows \"monomial 1 t \\<in> pmdl F\"", "lemma lt_setI:\n  assumes \"f \\<in> F\" and \"f \\<noteq> 0\"\n  shows \"lt f \\<in> lt_set F\"", "lemma lt_setE:\n  assumes \"t \\<in> lt_set F\"\n  obtains f where \"f \\<in> F\" and \"f \\<noteq> 0\" and \"lt f = t\"", "lemma lt_set_iff:\n  shows \"t \\<in> lt_set F \\<longleftrightarrow> (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lt f = t)\"", "lemma lc_setI:\n  assumes \"f \\<in> F\" and \"f \\<noteq> 0\"\n  shows \"lc f \\<in> lc_set F\"", "lemma lc_setE:\n  assumes \"c \\<in> lc_set F\"\n  obtains f where \"f \\<in> F\" and \"f \\<noteq> 0\" and \"lc f = c\"", "lemma lc_set_iff:\n  shows \"c \\<in> lc_set F \\<longleftrightarrow> (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lc f = c)\"", "lemma lc_set_nonzero:\n  shows \"0 \\<notin> lc_set F\"", "lemma lt_sum_distinct_eq_Max:\n  assumes \"finite I\" and \"sum p I \\<noteq> 0\"\n    and \"\\<And>i1 i2. i1 \\<in> I \\<Longrightarrow> i2 \\<in> I \\<Longrightarrow> p i1 \\<noteq> 0 \\<Longrightarrow> p i2 \\<noteq> 0 \\<Longrightarrow> lt (p i1) = lt (p i2) \\<Longrightarrow> i1 = i2\"\n  shows \"lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\"", "lemma lt_sum_distinct_in_lt_set:\n  assumes \"finite I\" and \"sum p I \\<noteq> 0\"\n    and \"\\<And>i1 i2. i1 \\<in> I \\<Longrightarrow> i2 \\<in> I \\<Longrightarrow> p i1 \\<noteq> 0 \\<Longrightarrow> p i2 \\<noteq> 0 \\<Longrightarrow> lt (p i1) = lt (p i2) \\<Longrightarrow> i1 = i2\"\n  shows \"lt (sum p I) \\<in> lt_set (p ` I)\"", "lemma lookup_monic: \"lookup (monic p) v = (lookup p v) / lc p\"", "lemma lookup_monic_lt:\n  assumes \"p \\<noteq> 0\"\n  shows \"lookup (monic p) (lt p) = 1\"", "lemma monic_0 [simp]: \"monic 0 = 0\"", "lemma monic_0_iff: \"(monic p = 0) \\<longleftrightarrow> (p = 0)\"", "lemma keys_monic [simp]: \"keys (monic p) = keys p\"", "lemma lt_monic [simp]: \"lt (monic p) = lt p\"", "lemma lc_monic:\n  assumes \"p \\<noteq> 0\"\n  shows \"lc (monic p) = 1\"", "lemma mult_lc_monic:\n  assumes \"p \\<noteq> 0\"\n  shows \"monom_mult (lc p) 0 (monic p) = p\" (is \"?q = p\")", "lemma is_monic_setI:\n  assumes \"\\<And>b. b \\<in> B \\<Longrightarrow> b \\<noteq> 0 \\<Longrightarrow> lc b = 1\"\n  shows \"is_monic_set B\"", "lemma is_monic_setD:\n  assumes \"is_monic_set B\" and \"b \\<in> B\" and \"b \\<noteq> 0\"\n  shows \"lc b = 1\"", "lemma Keys_image_monic [simp]: \"Keys (monic ` A) = Keys A\"", "lemma image_monic_is_monic_set: \"is_monic_set (monic ` A)\"", "lemma pmdl_image_monic [simp]: \"pmdl (monic ` B) = pmdl B\""], "translations": [["", "lemma span_listE:\n  assumes \"p \\<in> span (set bs)\"\n  obtains qs where \"length qs = length bs\" and \"p = sum_list (map2 (*s) qs bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>length qs = length bs;\n         p = sum_list (map2 (*s) qs bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>length qs = length bs;\n         p = sum_list (map2 (*s) qs bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"finite (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set bs)", ".."], ["proof (state)\nthis:\n  finite (set bs)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>length qs = length bs;\n         p = sum_list (map2 (*s) qs bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this assms"], ["proof (chain)\npicking this:\n  finite (set bs)\n  p \\<in> local.span (set bs)", "obtain q where p: \"p = (\\<Sum>b\\<in>set bs. (q b) *s b)\""], ["proof (prove)\nusing this:\n  finite (set bs)\n  p \\<in> local.span (set bs)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = (\\<Sum>b\\<in>set bs. q b *s b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule span_finiteE)"], ["proof (state)\nthis:\n  p = (\\<Sum>b\\<in>set bs. q b *s b)\n\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>length qs = length bs;\n         p = sum_list (map2 (*s) qs bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?qs = \"map_dup q (\\<lambda>_. 0) bs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        \\<lbrakk>length qs = length bs;\n         p = sum_list (map2 (*s) qs bs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. length ?qs = length bs\n 2. p = sum_list (map2 (*s) ?qs bs)", "show \"length ?qs = length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map_dup q (\\<lambda>_. 0::'a) bs) = length bs", "by simp"], ["proof (state)\nthis:\n  length (map_dup q (\\<lambda>_. 0::'a) bs) = length bs\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "let ?zs = \"zip (map q (remdups bs)) (remdups bs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "have *: \"distinct ?zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (zip (map q (remdups bs)) (remdups bs))", "by (rule distinct_zipI2, rule distinct_remdups)"], ["proof (state)\nthis:\n  distinct (zip (map q (remdups bs)) (remdups bs))\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "have inj: \"inj_on (\\<lambda>b. (q b, b)) (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. (q b, b)) (set bs)", "by (rule, simp)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>b. (q b, b)) (set bs)\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "have \"p = (\\<Sum>(q, b)\\<leftarrow>?zs. q *s b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map q (remdups bs)) (remdups bs))", "by (simp add: sum_list_distinct_conv_sum_set[OF *] set_zip_map1 p comm_monoid_add_class.sum.reindex[OF inj])"], ["proof (state)\nthis:\n  p = sum_list (map2 (*s) (map q (remdups bs)) (remdups bs))\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "also"], ["proof (state)\nthis:\n  p = sum_list (map2 (*s) (map q (remdups bs)) (remdups bs))\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "have \"... = (\\<Sum>(q, b)\\<leftarrow>(filter (\\<lambda>(q, b). q \\<noteq> 0) ?zs). q *s b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (*s) (map q (remdups bs)) (remdups bs)) =\n    (\\<Sum>(q,\n        b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                       (zip (map q (remdups bs)) (remdups bs)). q *s b)", "by (rule monoid_add_class.sum_list_map_filter[symmetric], auto)"], ["proof (state)\nthis:\n  sum_list (map2 (*s) (map q (remdups bs)) (remdups bs)) =\n  (\\<Sum>(q,\n      b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                     (zip (map q (remdups bs)) (remdups bs)). q *s b)\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "also"], ["proof (state)\nthis:\n  sum_list (map2 (*s) (map q (remdups bs)) (remdups bs)) =\n  (\\<Sum>(q,\n      b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                     (zip (map q (remdups bs)) (remdups bs)). q *s b)\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "have \"... = (\\<Sum>(q, b)\\<leftarrow>(filter (\\<lambda>(q, b). q \\<noteq> 0) (zip ?qs bs)). q *s b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(q,\n        b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                       (zip (map q (remdups bs)) (remdups bs)). q *s b) =\n    (\\<Sum>(q,\n        b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                       (zip (map_dup q (\\<lambda>_. 0::'a) bs) bs). q *s b)", "by (simp only: filter_zip_map_dup_const)"], ["proof (state)\nthis:\n  (\\<Sum>(q,\n      b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                     (zip (map q (remdups bs)) (remdups bs)). q *s b) =\n  (\\<Sum>(q,\n      b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                     (zip (map_dup q (\\<lambda>_. 0::'a) bs) bs). q *s b)\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "also"], ["proof (state)\nthis:\n  (\\<Sum>(q,\n      b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                     (zip (map q (remdups bs)) (remdups bs)). q *s b) =\n  (\\<Sum>(q,\n      b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                     (zip (map_dup q (\\<lambda>_. 0::'a) bs) bs). q *s b)\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "have \"... = (\\<Sum>(q, b)\\<leftarrow>zip ?qs bs. q *s b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(q,\n        b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                       (zip (map_dup q (\\<lambda>_. 0::'a) bs)\n                         bs). q *s b) =\n    sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "by (rule monoid_add_class.sum_list_map_filter, auto)"], ["proof (state)\nthis:\n  (\\<Sum>(q,\n      b)\\<leftarrow>filter (\\<lambda>(q, b). q \\<noteq> (0::'a))\n                     (zip (map_dup q (\\<lambda>_. 0::'a) bs) bs). q *s b) =\n  sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "finally"], ["proof (chain)\npicking this:\n  p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "show \"p = (\\<Sum>(q, b)\\<leftarrow>zip ?qs bs. q *s b)\""], ["proof (prove)\nusing this:\n  p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)\n\ngoal (1 subgoal):\n 1. p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)", "."], ["proof (state)\nthis:\n  p = sum_list (map2 (*s) (map_dup q (\\<lambda>_. 0::'a) bs) bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_listI: \"sum_list (map2 (*s) qs bs) \\<in> span (set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (*s) qs bs) \\<in> local.span (set bs)", "proof (induct qs arbitrary: bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs. sum_list (map2 (*s) [] bs) \\<in> local.span (set bs)\n 2. \\<And>a qs bs.\n       (\\<And>bs.\n           sum_list (map2 (*s) qs bs)\n           \\<in> local.span (set bs)) \\<Longrightarrow>\n       sum_list (map2 (*s) (a # qs) bs) \\<in> local.span (set bs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>bs. sum_list (map2 (*s) [] bs) \\<in> local.span (set bs)\n 2. \\<And>a qs bs.\n       (\\<And>bs.\n           sum_list (map2 (*s) qs bs)\n           \\<in> local.span (set bs)) \\<Longrightarrow>\n       sum_list (map2 (*s) (a # qs) bs) \\<in> local.span (set bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (*s) [] bs) \\<in> local.span (set bs)", "by (simp add: span_zero)"], ["proof (state)\nthis:\n  sum_list (map2 (*s) [] bs) \\<in> local.span (set bs)\n\ngoal (1 subgoal):\n 1. \\<And>a qs bs.\n       (\\<And>bs.\n           sum_list (map2 (*s) qs bs)\n           \\<in> local.span (set bs)) \\<Longrightarrow>\n       sum_list (map2 (*s) (a # qs) bs) \\<in> local.span (set bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a qs bs.\n       (\\<And>bs.\n           sum_list (map2 (*s) qs bs)\n           \\<in> local.span (set bs)) \\<Longrightarrow>\n       sum_list (map2 (*s) (a # qs) bs) \\<in> local.span (set bs)", "case step: (Cons q qs)"], ["proof (state)\nthis:\n  sum_list (map2 (*s) qs ?bs) \\<in> local.span (set ?bs)\n\ngoal (1 subgoal):\n 1. \\<And>a qs bs.\n       (\\<And>bs.\n           sum_list (map2 (*s) qs bs)\n           \\<in> local.span (set bs)) \\<Longrightarrow>\n       sum_list (map2 (*s) (a # qs) bs) \\<in> local.span (set bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (*s) (q # qs) bs) \\<in> local.span (set bs)", "proof (simp add: zip_Cons1 span_zero split: list.split, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       bs = x21 # x22 \\<Longrightarrow>\n       q *s x21 + sum_list (map2 (*s) qs x22)\n       \\<in> local.span (insert x21 (set x22))", "fix a as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       bs = x21 # x22 \\<Longrightarrow>\n       q *s x21 + sum_list (map2 (*s) qs x22)\n       \\<in> local.span (insert x21 (set x22))", "have \"sum_list (map2 (*s) qs as) \\<in> span (insert a (set as))\" (is \"?x \\<in> ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map2 (*s) qs as) \\<in> local.span (insert a (set as))", "by (rule, fact step, rule span_mono, auto)"], ["proof (state)\nthis:\n  sum_list (map2 (*s) qs as) \\<in> local.span (insert a (set as))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       bs = x21 # x22 \\<Longrightarrow>\n       q *s x21 + sum_list (map2 (*s) qs x22)\n       \\<in> local.span (insert x21 (set x22))", "moreover"], ["proof (state)\nthis:\n  sum_list (map2 (*s) qs as) \\<in> local.span (insert a (set as))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       bs = x21 # x22 \\<Longrightarrow>\n       q *s x21 + sum_list (map2 (*s) qs x22)\n       \\<in> local.span (insert x21 (set x22))", "have \"a \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> local.span (insert a (set as))", "by (rule span_base) simp"], ["proof (state)\nthis:\n  a \\<in> local.span (insert a (set as))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       bs = x21 # x22 \\<Longrightarrow>\n       q *s x21 + sum_list (map2 (*s) qs x22)\n       \\<in> local.span (insert x21 (set x22))", "ultimately"], ["proof (chain)\npicking this:\n  sum_list (map2 (*s) qs as) \\<in> local.span (insert a (set as))\n  a \\<in> local.span (insert a (set as))", "show \"q *s a + ?x \\<in> ?A\""], ["proof (prove)\nusing this:\n  sum_list (map2 (*s) qs as) \\<in> local.span (insert a (set as))\n  a \\<in> local.span (insert a (set as))\n\ngoal (1 subgoal):\n 1. q *s a + sum_list (map2 (*s) qs as) \\<in> local.span (insert a (set as))", "by (intro span_add span_scale)"], ["proof (state)\nthis:\n  q *s a + sum_list (map2 (*s) qs as) \\<in> local.span (insert a (set as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map2 (*s) (q # qs) bs) \\<in> local.span (set bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in term_powerprod) monomial_1_in_pmdlI:\n  assumes \"(f::_ \\<Rightarrow>\\<^sub>0 'b::field) \\<in> pmdl F\" and \"keys f = {t}\"\n  shows \"monomial 1 t \\<in> pmdl F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "define c where \"c \\<equiv> lookup f t\""], ["proof (state)\nthis:\n  c \\<equiv> lookup f t\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "from assms(2)"], ["proof (chain)\npicking this:\n  keys f = {t}", "have f_eq: \"f = monomial c t\""], ["proof (prove)\nusing this:\n  keys f = {t}\n\ngoal (1 subgoal):\n 1. f = monomial c t", "unfolding c_def"], ["proof (prove)\nusing this:\n  keys f = {t}\n\ngoal (1 subgoal):\n 1. f = monomial (lookup f t) t", "by (metis (mono_tags, lifting) Diff_insert_absorb cancel_comm_monoid_add_class.add_cancel_right_right\n        plus_except insert_absorb insert_not_empty keys_eq_empty keys_except)"], ["proof (state)\nthis:\n  f = monomial c t\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "from assms(2)"], ["proof (chain)\npicking this:\n  keys f = {t}", "have \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  keys f = {t}\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'b)", "unfolding c_def"], ["proof (prove)\nusing this:\n  keys f = {t}\n\ngoal (1 subgoal):\n 1. lookup f t \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "hence \"monomial 1 t = monom_mult (1 / c) 0 f\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t = monom_mult ((1::'b) / c) (0::'a) f", "by (simp add: f_eq monom_mult_monomial term_simps)"], ["proof (state)\nthis:\n  monomial (1::'b) t = monom_mult ((1::'b) / c) (0::'a) f\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "also"], ["proof (state)\nthis:\n  monomial (1::'b) t = monom_mult ((1::'b) / c) (0::'a) f\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "from assms(1)"], ["proof (chain)\npicking this:\n  f \\<in> pmdl F", "have \"... \\<in> pmdl F\""], ["proof (prove)\nusing this:\n  f \\<in> pmdl F\n\ngoal (1 subgoal):\n 1. monom_mult ((1::'b) / c) (0::'a) f \\<in> pmdl F", "by (rule pmdl_closed_monom_mult)"], ["proof (state)\nthis:\n  monom_mult ((1::'b) / c) (0::'a) f \\<in> pmdl F\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "finally"], ["proof (chain)\npicking this:\n  monomial (1::'b) t \\<in> pmdl F", "show ?thesis"], ["proof (prove)\nusing this:\n  monomial (1::'b) t \\<in> pmdl F\n\ngoal (1 subgoal):\n 1. monomial (1::'b) t \\<in> pmdl F", "."], ["proof (state)\nthis:\n  monomial (1::'b) t \\<in> pmdl F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Ordered Polynomials\\<close>"], ["", "context ordered_term\nbegin"], ["", "subsubsection \\<open>Sets of Leading Terms and -Coefficients\\<close>"], ["", "definition lt_set :: \"('t, 'b::zero) poly_mapping set \\<Rightarrow> 't set\" where\n  \"lt_set F = lt ` (F - {0})\""], ["", "definition lc_set :: \"('t, 'b::zero) poly_mapping set \\<Rightarrow> 'b set\" where\n  \"lc_set F = lc ` (F - {0})\""], ["", "lemma lt_setI:\n  assumes \"f \\<in> F\" and \"f \\<noteq> 0\"\n  shows \"lt f \\<in> lt_set F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt f \\<in> lt_set F", "unfolding lt_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt f \\<in> lt ` (F - {0})", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> F\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt f \\<in> lt ` (F - {0})", "by simp"], ["", "lemma lt_setE:\n  assumes \"t \\<in> lt_set F\"\n  obtains f where \"f \\<in> F\" and \"f \\<noteq> 0\" and \"lt f = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f \\<noteq> 0; lt f = t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> lt_set F\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f \\<noteq> 0; lt f = t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lt_set_def"], ["proof (prove)\nusing this:\n  t \\<in> lt ` (F - {0})\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f \\<noteq> 0; lt f = t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma lt_set_iff:\n  shows \"t \\<in> lt_set F \\<longleftrightarrow> (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lt f = t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> lt_set F) = (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lt f = t)", "unfolding lt_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<in> lt ` (F - {0})) =\n    (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lt f = t)", "by auto"], ["", "lemma lc_setI:\n  assumes \"f \\<in> F\" and \"f \\<noteq> 0\"\n  shows \"lc f \\<in> lc_set F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc f \\<in> lc_set F", "unfolding lc_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lc f \\<in> lc ` (F - {0})", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> F\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc f \\<in> lc ` (F - {0})", "by simp"], ["", "lemma lc_setE:\n  assumes \"c \\<in> lc_set F\"\n  obtains f where \"f \\<in> F\" and \"f \\<noteq> 0\" and \"lc f = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f \\<noteq> 0; lc f = c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  c \\<in> lc_set F\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f \\<noteq> 0; lc f = c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lc_set_def"], ["proof (prove)\nusing this:\n  c \\<in> lc ` (F - {0})\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f \\<noteq> 0; lc f = c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma lc_set_iff:\n  shows \"c \\<in> lc_set F \\<longleftrightarrow> (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lc f = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<in> lc_set F) = (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lc f = c)", "unfolding lc_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<in> lc ` (F - {0})) =\n    (\\<exists>f\\<in>F. f \\<noteq> 0 \\<and> lc f = c)", "by auto"], ["", "lemma lc_set_nonzero:\n  shows \"0 \\<notin> lc_set F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<notin> lc_set F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'b) \\<in> lc_set F \\<Longrightarrow> False", "assume \"0 \\<in> lc_set F\""], ["proof (state)\nthis:\n  (0::'b) \\<in> lc_set F\n\ngoal (1 subgoal):\n 1. (0::'b) \\<in> lc_set F \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (0::'b) \\<in> lc_set F", "obtain f where \"f \\<in> F\" and \"f \\<noteq> 0\" and \"lc f = 0\""], ["proof (prove)\nusing this:\n  (0::'b) \\<in> lc_set F\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> F; f \\<noteq> 0; lc f = (0::'b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lc_setE)"], ["proof (state)\nthis:\n  f \\<in> F\n  f \\<noteq> 0\n  lc f = (0::'b)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<in> lc_set F \\<Longrightarrow> False", "from \\<open>f \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have \"lc f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc f \\<noteq> (0::'b)", "by (rule lc_not_0)"], ["proof (state)\nthis:\n  lc f \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (0::'b) \\<in> lc_set F \\<Longrightarrow> False", "from this \\<open>lc f = 0\\<close>"], ["proof (chain)\npicking this:\n  lc f \\<noteq> (0::'b)\n  lc f = (0::'b)", "show False"], ["proof (prove)\nusing this:\n  lc f \\<noteq> (0::'b)\n  lc f = (0::'b)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lt_sum_distinct_eq_Max:\n  assumes \"finite I\" and \"sum p I \\<noteq> 0\"\n    and \"\\<And>i1 i2. i1 \\<in> I \\<Longrightarrow> i2 \\<in> I \\<Longrightarrow> p i1 \\<noteq> 0 \\<Longrightarrow> p i2 \\<noteq> 0 \\<Longrightarrow> lt (p i1) = lt (p i2) \\<Longrightarrow> i1 = i2\"\n  shows \"lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))", "have \"\\<not> p ` I \\<subseteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p ` I \\<subseteq> {0}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow> False", "assume \"p ` I \\<subseteq> {0}\""], ["proof (state)\nthis:\n  p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow> False", "hence \"sum p I = 0\""], ["proof (prove)\nusing this:\n  p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. sum p I = 0", "by (rule sum_poly_mapping_eq_zeroI)"], ["proof (state)\nthis:\n  sum p I = 0\n\ngoal (1 subgoal):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  sum p I \\<noteq> 0\n  sum p I = 0", "show False"], ["proof (prove)\nusing this:\n  sum p I \\<noteq> 0\n  sum p I = 0\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))", "from assms(1) this assms(3)"], ["proof (chain)\npicking this:\n  finite I\n  \\<not> p ` I \\<subseteq> {0}\n  \\<lbrakk>?i1.26 \\<in> I; ?i2.26 \\<in> I; p ?i1.26 \\<noteq> 0;\n   p ?i2.26 \\<noteq> 0; lt (p ?i1.26) = lt (p ?i2.26)\\<rbrakk>\n  \\<Longrightarrow> ?i1.26 = ?i2.26", "show ?thesis"], ["proof (prove)\nusing this:\n  finite I\n  \\<not> p ` I \\<subseteq> {0}\n  \\<lbrakk>?i1.26 \\<in> I; ?i2.26 \\<in> I; p ?i1.26 \\<noteq> 0;\n   p ?i2.26 \\<noteq> 0; lt (p ?i1.26) = lt (p ?i2.26)\\<rbrakk>\n  \\<Longrightarrow> ?i1.26 = ?i2.26\n\ngoal (1 subgoal):\n 1. lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> p ` {} \\<subseteq> {0};\n     \\<And>i1 i2.\n        \\<lbrakk>i1 \\<in> {}; i2 \\<in> {}; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n         lt (p i1) = lt (p i2)\\<rbrakk>\n        \\<Longrightarrow> i1 = i2\\<rbrakk>\n    \\<Longrightarrow> lt (sum p {}) = ord_term_lin.Max (lt_set (p ` {}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<not> p ` F \\<subseteq> {0};\n         \\<And>i1 i2.\n            \\<lbrakk>i1 \\<in> F; i2 \\<in> F; p i1 \\<noteq> 0;\n             p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n            \\<Longrightarrow> i1 = i2\\<rbrakk>\n        \\<Longrightarrow> lt (sum p F) = ord_term_lin.Max (lt_set (p ` F));\n        \\<not> p ` insert x F \\<subseteq> {0};\n        \\<And>i1 i2.\n           \\<lbrakk>i1 \\<in> insert x F; i2 \\<in> insert x F;\n            p i1 \\<noteq> 0; p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n           \\<Longrightarrow> i1 = i2\\<rbrakk>\n       \\<Longrightarrow> lt (sum p (insert x F)) =\n                         ord_term_lin.Max (lt_set (p ` insert x F))", "case empty"], ["proof (state)\nthis:\n  \\<not> p ` {} \\<subseteq> {0}\n  \\<lbrakk>?i1.26 \\<in> {}; ?i2.26 \\<in> {}; p ?i1.26 \\<noteq> 0;\n   p ?i2.26 \\<noteq> 0; lt (p ?i1.26) = lt (p ?i2.26)\\<rbrakk>\n  \\<Longrightarrow> ?i1.26 = ?i2.26\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> p ` {} \\<subseteq> {0};\n     \\<And>i1 i2.\n        \\<lbrakk>i1 \\<in> {}; i2 \\<in> {}; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n         lt (p i1) = lt (p i2)\\<rbrakk>\n        \\<Longrightarrow> i1 = i2\\<rbrakk>\n    \\<Longrightarrow> lt (sum p {}) = ord_term_lin.Max (lt_set (p ` {}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<not> p ` F \\<subseteq> {0};\n         \\<And>i1 i2.\n            \\<lbrakk>i1 \\<in> F; i2 \\<in> F; p i1 \\<noteq> 0;\n             p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n            \\<Longrightarrow> i1 = i2\\<rbrakk>\n        \\<Longrightarrow> lt (sum p F) = ord_term_lin.Max (lt_set (p ` F));\n        \\<not> p ` insert x F \\<subseteq> {0};\n        \\<And>i1 i2.\n           \\<lbrakk>i1 \\<in> insert x F; i2 \\<in> insert x F;\n            p i1 \\<noteq> 0; p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n           \\<Longrightarrow> i1 = i2\\<rbrakk>\n       \\<Longrightarrow> lt (sum p (insert x F)) =\n                         ord_term_lin.Max (lt_set (p ` insert x F))", "from empty(1)"], ["proof (chain)\npicking this:\n  \\<not> p ` {} \\<subseteq> {0}", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> p ` {} \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. lt (sum p {}) = ord_term_lin.Max (lt_set (p ` {}))", "by simp"], ["proof (state)\nthis:\n  lt (sum p {}) = ord_term_lin.Max (lt_set (p ` {}))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<not> p ` F \\<subseteq> {0};\n         \\<And>i1 i2.\n            \\<lbrakk>i1 \\<in> F; i2 \\<in> F; p i1 \\<noteq> 0;\n             p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n            \\<Longrightarrow> i1 = i2\\<rbrakk>\n        \\<Longrightarrow> lt (sum p F) = ord_term_lin.Max (lt_set (p ` F));\n        \\<not> p ` insert x F \\<subseteq> {0};\n        \\<And>i1 i2.\n           \\<lbrakk>i1 \\<in> insert x F; i2 \\<in> insert x F;\n            p i1 \\<noteq> 0; p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n           \\<Longrightarrow> i1 = i2\\<rbrakk>\n       \\<Longrightarrow> lt (sum p (insert x F)) =\n                         ord_term_lin.Max (lt_set (p ` insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<not> p ` F \\<subseteq> {0};\n         \\<And>i1 i2.\n            \\<lbrakk>i1 \\<in> F; i2 \\<in> F; p i1 \\<noteq> 0;\n             p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n            \\<Longrightarrow> i1 = i2\\<rbrakk>\n        \\<Longrightarrow> lt (sum p F) = ord_term_lin.Max (lt_set (p ` F));\n        \\<not> p ` insert x F \\<subseteq> {0};\n        \\<And>i1 i2.\n           \\<lbrakk>i1 \\<in> insert x F; i2 \\<in> insert x F;\n            p i1 \\<noteq> 0; p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n           \\<Longrightarrow> i1 = i2\\<rbrakk>\n       \\<Longrightarrow> lt (sum p (insert x F)) =\n                         ord_term_lin.Max (lt_set (p ` insert x F))", "case (insert x I)"], ["proof (state)\nthis:\n  finite I\n  x \\<notin> I\n  \\<lbrakk>\\<not> p ` I \\<subseteq> {0};\n   \\<And>i1 i2.\n      \\<lbrakk>i1 \\<in> I; i2 \\<in> I; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n       lt (p i1) = lt (p i2)\\<rbrakk>\n      \\<Longrightarrow> i1 = i2\\<rbrakk>\n  \\<Longrightarrow> lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\n  \\<not> p ` insert x I \\<subseteq> {0}\n  \\<lbrakk>?i1.26 \\<in> insert x I; ?i2.26 \\<in> insert x I;\n   p ?i1.26 \\<noteq> 0; p ?i2.26 \\<noteq> 0;\n   lt (p ?i1.26) = lt (p ?i2.26)\\<rbrakk>\n  \\<Longrightarrow> ?i1.26 = ?i2.26\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>\\<not> p ` F \\<subseteq> {0};\n         \\<And>i1 i2.\n            \\<lbrakk>i1 \\<in> F; i2 \\<in> F; p i1 \\<noteq> 0;\n             p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n            \\<Longrightarrow> i1 = i2\\<rbrakk>\n        \\<Longrightarrow> lt (sum p F) = ord_term_lin.Max (lt_set (p ` F));\n        \\<not> p ` insert x F \\<subseteq> {0};\n        \\<And>i1 i2.\n           \\<lbrakk>i1 \\<in> insert x F; i2 \\<in> insert x F;\n            p i1 \\<noteq> 0; p i2 \\<noteq> 0; lt (p i1) = lt (p i2)\\<rbrakk>\n           \\<Longrightarrow> i1 = i2\\<rbrakk>\n       \\<Longrightarrow> lt (sum p (insert x F)) =\n                         ord_term_lin.Max (lt_set (p ` insert x F))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "proof (cases \"p ` I \\<subseteq> {0}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "case True"], ["proof (state)\nthis:\n  p ` I \\<subseteq> {0}\n\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "hence \"p ` I - {0} = {}\""], ["proof (prove)\nusing this:\n  p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. p ` I - {0} = {}", "by simp"], ["proof (state)\nthis:\n  p ` I - {0} = {}\n\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "have \"p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p x = 0 \\<Longrightarrow> False", "assume \"p x = 0\""], ["proof (state)\nthis:\n  p x = 0\n\ngoal (1 subgoal):\n 1. p x = 0 \\<Longrightarrow> False", "with True"], ["proof (chain)\npicking this:\n  p ` I \\<subseteq> {0}\n  p x = 0", "have \" p ` insert x I \\<subseteq> {0}\""], ["proof (prove)\nusing this:\n  p ` I \\<subseteq> {0}\n  p x = 0\n\ngoal (1 subgoal):\n 1. p ` insert x I \\<subseteq> {0}", "by simp"], ["proof (state)\nthis:\n  p ` insert x I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. p x = 0 \\<Longrightarrow> False", "with insert(4)"], ["proof (chain)\npicking this:\n  \\<not> p ` insert x I \\<subseteq> {0}\n  p ` insert x I \\<subseteq> {0}", "show False"], ["proof (prove)\nusing this:\n  \\<not> p ` insert x I \\<subseteq> {0}\n  p ` insert x I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "hence \"insert (p x) (p ` I) - {0} = insert (p x) (p ` I - {0})\""], ["proof (prove)\nusing this:\n  p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. insert (p x) (p ` I) - {0} = insert (p x) (p ` I - {0})", "by auto"], ["proof (state)\nthis:\n  insert (p x) (p ` I) - {0} = insert (p x) (p ` I - {0})\n\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "hence \"lt_set (p ` insert x I) = {lt (p x)}\""], ["proof (prove)\nusing this:\n  insert (p x) (p ` I) - {0} = insert (p x) (p ` I - {0})\n\ngoal (1 subgoal):\n 1. lt_set (p ` insert x I) = {lt (p x)}", "by (simp add: lt_set_def \\<open>p ` I - {0} = {}\\<close>)"], ["proof (state)\nthis:\n  lt_set (p ` insert x I) = {lt (p x)}\n\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "hence eq1: \"ord_term_lin.Max (lt_set (p ` insert x I)) = lt (p x)\""], ["proof (prove)\nusing this:\n  lt_set (p ` insert x I) = {lt (p x)}\n\ngoal (1 subgoal):\n 1. ord_term_lin.Max (lt_set (p ` insert x I)) = lt (p x)", "by simp"], ["proof (state)\nthis:\n  ord_term_lin.Max (lt_set (p ` insert x I)) = lt (p x)\n\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "have eq2: \"sum p I = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p I = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. sum p I \\<noteq> 0 \\<Longrightarrow> False", "assume \"sum p I \\<noteq> 0\""], ["proof (state)\nthis:\n  sum p I \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum p I \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  sum p I \\<noteq> 0", "obtain y where \"y \\<in> I\" and \"p y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  sum p I \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> I; p y \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule sum.not_neutral_contains_not_neutral)"], ["proof (state)\nthis:\n  y \\<in> I\n  p y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum p I \\<noteq> 0 \\<Longrightarrow> False", "with True"], ["proof (chain)\npicking this:\n  p ` I \\<subseteq> {0}\n  y \\<in> I\n  p y \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  p ` I \\<subseteq> {0}\n  y \\<in> I\n  p y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum p I = 0\n\ngoal (2 subgoals):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "by (simp only: eq1 sum.insert[OF insert(1) insert(2)], simp add: eq2)"], ["proof (state)\nthis:\n  lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n\ngoal (1 subgoal):\n 1. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "case False"], ["proof (state)\nthis:\n  \\<not> p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "hence IH: \"lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\""], ["proof (prove)\nusing this:\n  \\<not> p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))", "proof (rule insert(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 \\<in> I; i2 \\<in> I; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n        lt (p i1) = lt (p i2)\\<rbrakk>\n       \\<Longrightarrow> i1 = i2", "fix i1 i2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 \\<in> I; i2 \\<in> I; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n        lt (p i1) = lt (p i2)\\<rbrakk>\n       \\<Longrightarrow> i1 = i2", "assume \"i1 \\<in> I\" and \"i2 \\<in> I\""], ["proof (state)\nthis:\n  i1 \\<in> I\n  i2 \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 \\<in> I; i2 \\<in> I; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n        lt (p i1) = lt (p i2)\\<rbrakk>\n       \\<Longrightarrow> i1 = i2", "hence \"i1 \\<in> insert x I\" and \"i2 \\<in> insert x I\""], ["proof (prove)\nusing this:\n  i1 \\<in> I\n  i2 \\<in> I\n\ngoal (1 subgoal):\n 1. i1 \\<in> insert x I &&& i2 \\<in> insert x I", "by simp_all"], ["proof (state)\nthis:\n  i1 \\<in> insert x I\n  i2 \\<in> insert x I\n\ngoal (1 subgoal):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 \\<in> I; i2 \\<in> I; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n        lt (p i1) = lt (p i2)\\<rbrakk>\n       \\<Longrightarrow> i1 = i2", "moreover"], ["proof (state)\nthis:\n  i1 \\<in> insert x I\n  i2 \\<in> insert x I\n\ngoal (1 subgoal):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 \\<in> I; i2 \\<in> I; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n        lt (p i1) = lt (p i2)\\<rbrakk>\n       \\<Longrightarrow> i1 = i2", "assume \"p i1 \\<noteq> 0\" and \"p i2 \\<noteq> 0\" and \"lt (p i1) = lt (p i2)\""], ["proof (state)\nthis:\n  p i1 \\<noteq> 0\n  p i2 \\<noteq> 0\n  lt (p i1) = lt (p i2)\n\ngoal (1 subgoal):\n 1. \\<And>i1 i2.\n       \\<lbrakk>i1 \\<in> I; i2 \\<in> I; p i1 \\<noteq> 0; p i2 \\<noteq> 0;\n        lt (p i1) = lt (p i2)\\<rbrakk>\n       \\<Longrightarrow> i1 = i2", "ultimately"], ["proof (chain)\npicking this:\n  i1 \\<in> insert x I\n  i2 \\<in> insert x I\n  p i1 \\<noteq> 0\n  p i2 \\<noteq> 0\n  lt (p i1) = lt (p i2)", "show \"i1 = i2\""], ["proof (prove)\nusing this:\n  i1 \\<in> insert x I\n  i2 \\<in> insert x I\n  p i1 \\<noteq> 0\n  p i2 \\<noteq> 0\n  lt (p i1) = lt (p i2)\n\ngoal (1 subgoal):\n 1. i1 = i2", "by (rule insert(5))"], ["proof (state)\nthis:\n  i1 = i2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\n\ngoal (1 subgoal):\n 1. \\<not> p ` I \\<subseteq> {0} \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "proof (cases \"p x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p x = 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "case True"], ["proof (state)\nthis:\n  p x = 0\n\ngoal (2 subgoals):\n 1. p x = 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "hence eq: \"lt_set (p ` insert x I) = lt_set (p ` I)\""], ["proof (prove)\nusing this:\n  p x = 0\n\ngoal (1 subgoal):\n 1. lt_set (p ` insert x I) = lt_set (p ` I)", "by (simp add: lt_set_def)"], ["proof (state)\nthis:\n  lt_set (p ` insert x I) = lt_set (p ` I)\n\ngoal (2 subgoals):\n 1. p x = 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n 2. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "by (simp only: eq, simp add: sum.insert[OF insert(1) insert(2)] True, fact IH)"], ["proof (state)\nthis:\n  lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "case False"], ["proof (state)\nthis:\n  p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "hence eq1: \"lt_set (p ` insert x I) = insert (lt (p x)) (lt_set (p ` I))\""], ["proof (prove)\nusing this:\n  p x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lt_set (p ` insert x I) = insert (lt (p x)) (lt_set (p ` I))", "by (auto simp add: lt_set_def)"], ["proof (state)\nthis:\n  lt_set (p ` insert x I) = insert (lt (p x)) (lt_set (p ` I))\n\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "from insert(1)"], ["proof (chain)\npicking this:\n  finite I", "have \"finite (lt_set (p ` I))\""], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. finite (lt_set (p ` I))", "by (simp add: lt_set_def)"], ["proof (state)\nthis:\n  finite (lt_set (p ` I))\n\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "moreover"], ["proof (state)\nthis:\n  finite (lt_set (p ` I))\n\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "from \\<open>\\<not> p ` I \\<subseteq> {0}\\<close>"], ["proof (chain)\npicking this:\n  \\<not> p ` I \\<subseteq> {0}", "have \"lt_set (p ` I) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. lt_set (p ` I) \\<noteq> {}", "by (simp add: lt_set_def)"], ["proof (state)\nthis:\n  lt_set (p ` I) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "ultimately"], ["proof (chain)\npicking this:\n  finite (lt_set (p ` I))\n  lt_set (p ` I) \\<noteq> {}", "have eq2: \"ord_term_lin.Max (insert (lt (p x)) (lt_set (p ` I))) =\n                          ord_term_lin.max (lt (p x)) (ord_term_lin.Max (lt_set (p ` I)))\""], ["proof (prove)\nusing this:\n  finite (lt_set (p ` I))\n  lt_set (p ` I) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ord_term_lin.Max (insert (lt (p x)) (lt_set (p ` I))) =\n    ord_term_lin.max (lt (p x)) (ord_term_lin.Max (lt_set (p ` I)))", "by (rule ord_term_lin.Max_insert)"], ["proof (state)\nthis:\n  ord_term_lin.Max (insert (lt (p x)) (lt_set (p ` I))) =\n  ord_term_lin.max (lt (p x)) (ord_term_lin.Max (lt_set (p ` I)))\n\ngoal (1 subgoal):\n 1. p x \\<noteq> 0 \\<Longrightarrow>\n    lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))", "proof (simp only: eq1, simp add: sum.insert[OF insert(1) insert(2)] eq2 IH[symmetric],\n            rule lt_plus_distinct_eq_max, rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "assume *: \"lt (p x) = lt (sum p I)\""], ["proof (state)\nthis:\n  lt (p x) = lt (sum p I)\n\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "have \"lt (p x) \\<in> lt_set (p ` I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (p x) \\<in> lt_set (p ` I)", "by (simp only: * IH, rule ord_term_lin.Max_in, fact+)"], ["proof (state)\nthis:\n  lt (p x) \\<in> lt_set (p ` I)\n\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lt (p x) \\<in> lt_set (p ` I)", "obtain f where \"f \\<in> p ` I\" and \"f \\<noteq> 0\" and ltf: \"lt f = lt (p x)\""], ["proof (prove)\nusing this:\n  lt (p x) \\<in> lt_set (p ` I)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> p ` I; f \\<noteq> 0; lt f = lt (p x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule lt_setE)"], ["proof (state)\nthis:\n  f \\<in> p ` I\n  f \\<noteq> 0\n  lt f = lt (p x)\n\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "from this(1)"], ["proof (chain)\npicking this:\n  f \\<in> p ` I", "obtain y where \"y \\<in> I\" and \"f = p y\""], ["proof (prove)\nusing this:\n  f \\<in> p ` I\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> I; f = p y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  y \\<in> I\n  f = p y\n\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "from this(2) \\<open>f \\<noteq> 0\\<close> ltf"], ["proof (chain)\npicking this:\n  f = p y\n  f \\<noteq> 0\n  lt f = lt (p x)", "have \"p y \\<noteq> 0\" and lt_eq: \"lt (p y) = lt (p x)\""], ["proof (prove)\nusing this:\n  f = p y\n  f \\<noteq> 0\n  lt f = lt (p x)\n\ngoal (1 subgoal):\n 1. p y \\<noteq> 0 &&& lt (p y) = lt (p x)", "by simp_all"], ["proof (state)\nthis:\n  p y \\<noteq> 0\n  lt (p y) = lt (p x)\n\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "from _ _ this(1) \\<open>p x \\<noteq> 0\\<close> this(2)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  p y \\<noteq> 0\n  p x \\<noteq> 0\n  lt (p y) = lt (p x)", "have \"y = x\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  p y \\<noteq> 0\n  p x \\<noteq> 0\n  lt (p y) = lt (p x)\n\ngoal (1 subgoal):\n 1. y = x", "proof (rule insert(5))"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> insert x I\n 2. x \\<in> insert x I", "from \\<open>y \\<in> I\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> I", "show \"y \\<in> insert x I\""], ["proof (prove)\nusing this:\n  y \\<in> I\n\ngoal (1 subgoal):\n 1. y \\<in> insert x I", "by simp"], ["proof (state)\nthis:\n  y \\<in> insert x I\n\ngoal (1 subgoal):\n 1. x \\<in> insert x I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> insert x I", "show \"x \\<in> insert x I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> insert x I", "by simp"], ["proof (state)\nthis:\n  x \\<in> insert x I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y = x\n\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "with \\<open>y \\<in> I\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> I\n  y = x", "have \"x \\<in> I\""], ["proof (prove)\nusing this:\n  y \\<in> I\n  y = x\n\ngoal (1 subgoal):\n 1. x \\<in> I", "by simp"], ["proof (state)\nthis:\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. lt (p x) = lt (sum p I) \\<Longrightarrow> False", "with \\<open>x \\<notin> I\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> I\n  x \\<in> I", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> I\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (sum p (insert x I)) = ord_term_lin.Max (lt_set (p ` insert x I))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lt_sum_distinct_in_lt_set:\n  assumes \"finite I\" and \"sum p I \\<noteq> 0\"\n    and \"\\<And>i1 i2. i1 \\<in> I \\<Longrightarrow> i2 \\<in> I \\<Longrightarrow> p i1 \\<noteq> 0 \\<Longrightarrow> p i2 \\<noteq> 0 \\<Longrightarrow> lt (p i1) = lt (p i2) \\<Longrightarrow> i1 = i2\"\n  shows \"lt (sum p I) \\<in> lt_set (p ` I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p I) \\<in> lt_set (p ` I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lt (sum p I) \\<in> lt_set (p ` I)", "have \"\\<not> p ` I \\<subseteq> {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p ` I \\<subseteq> {0}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow> False", "assume \"p ` I \\<subseteq> {0}\""], ["proof (state)\nthis:\n  p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow> False", "hence \"sum p I = 0\""], ["proof (prove)\nusing this:\n  p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. sum p I = 0", "by (rule sum_poly_mapping_eq_zeroI)"], ["proof (state)\nthis:\n  sum p I = 0\n\ngoal (1 subgoal):\n 1. p ` I \\<subseteq> {0} \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  sum p I \\<noteq> 0\n  sum p I = 0", "show False"], ["proof (prove)\nusing this:\n  sum p I \\<noteq> 0\n  sum p I = 0\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. lt (sum p I) \\<in> lt_set (p ` I)", "have \"lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))", "by (rule lt_sum_distinct_eq_Max, fact+)"], ["proof (state)\nthis:\n  lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\n\ngoal (1 subgoal):\n 1. lt (sum p I) \\<in> lt_set (p ` I)", "also"], ["proof (state)\nthis:\n  lt (sum p I) = ord_term_lin.Max (lt_set (p ` I))\n\ngoal (1 subgoal):\n 1. lt (sum p I) \\<in> lt_set (p ` I)", "have \"... \\<in> lt_set (p ` I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_term_lin.Max (lt_set (p ` I)) \\<in> lt_set (p ` I)", "proof (rule ord_term_lin.Max_in)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (lt_set (p ` I))\n 2. lt_set (p ` I) \\<noteq> {}", "from assms(1)"], ["proof (chain)\npicking this:\n  finite I", "show \"finite (lt_set (p ` I))\""], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. finite (lt_set (p ` I))", "by (simp add: lt_set_def)"], ["proof (state)\nthis:\n  finite (lt_set (p ` I))\n\ngoal (1 subgoal):\n 1. lt_set (p ` I) \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lt_set (p ` I) \\<noteq> {}", "from \\<open>\\<not> p ` I \\<subseteq> {0}\\<close>"], ["proof (chain)\npicking this:\n  \\<not> p ` I \\<subseteq> {0}", "show \"lt_set (p ` I) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> p ` I \\<subseteq> {0}\n\ngoal (1 subgoal):\n 1. lt_set (p ` I) \\<noteq> {}", "by (simp add: lt_set_def)"], ["proof (state)\nthis:\n  lt_set (p ` I) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_term_lin.Max (lt_set (p ` I)) \\<in> lt_set (p ` I)\n\ngoal (1 subgoal):\n 1. lt (sum p I) \\<in> lt_set (p ` I)", "finally"], ["proof (chain)\npicking this:\n  lt (sum p I) \\<in> lt_set (p ` I)", "show ?thesis"], ["proof (prove)\nusing this:\n  lt (sum p I) \\<in> lt_set (p ` I)\n\ngoal (1 subgoal):\n 1. lt (sum p I) \\<in> lt_set (p ` I)", "."], ["proof (state)\nthis:\n  lt (sum p I) \\<in> lt_set (p ` I)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Monicity\\<close>"], ["", "definition monic :: \"('t \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('t \\<Rightarrow>\\<^sub>0 'b::field)\" where\n  \"monic p = monom_mult (1 / lc p) 0 p\""], ["", "definition is_monic_set :: \"('t \\<Rightarrow>\\<^sub>0 'b::field) set \\<Rightarrow> bool\" where\n  \"is_monic_set B \\<equiv> (\\<forall>b\\<in>B. b \\<noteq> 0 \\<longrightarrow> lc b = 1)\""], ["", "lemma lookup_monic: \"lookup (monic p) v = (lookup p v) / lc p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monic p) v = lookup p v / lc p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (monic p) v = lookup p v / lc p", "have \"lookup (monic p) (0 \\<oplus> v) = (1 / lc p) * (lookup p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monic p) ((0::'a) \\<oplus> v) = (1::'b) / lc p * lookup p v", "unfolding monic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> v) =\n    (1::'b) / lc p * lookup p v", "by (rule lookup_monom_mult_plus)"], ["proof (state)\nthis:\n  lookup (monic p) ((0::'a) \\<oplus> v) = (1::'b) / lc p * lookup p v\n\ngoal (1 subgoal):\n 1. lookup (monic p) v = lookup p v / lc p", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup (monic p) ((0::'a) \\<oplus> v) = (1::'b) / lc p * lookup p v\n\ngoal (1 subgoal):\n 1. lookup (monic p) v = lookup p v / lc p", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  lookup (monic p) v = lookup p v / lc p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_monic_lt:\n  assumes \"p \\<noteq> 0\"\n  shows \"lookup (monic p) (lt p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monic p) (lt p) = (1::'b)", "unfolding monic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"lc p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc p \\<noteq> (0::'b)", "by (rule lc_not_0)"], ["proof (state)\nthis:\n  lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "hence \"1 / lc p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (1::'b) / lc p \\<noteq> (0::'b)", "by simp"], ["proof (state)\nthis:\n  (1::'b) / lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "let ?q = \"monom_mult (1 / lc p) 0 p\""], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "have \"lookup ?q (0 \\<oplus> lt p) = (1 / lc p) * (lookup p (lt p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n    (1::'b) / lc p * lookup p (lt p)", "by (rule lookup_monom_mult_plus)"], ["proof (state)\nthis:\n  lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n  (1::'b) / lc p * lookup p (lt p)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "also"], ["proof (state)\nthis:\n  lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n  (1::'b) / lc p * lookup p (lt p)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "have \"... = (1 / lc p) * lc p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'b) / lc p * lookup p (lt p) = (1::'b) / lc p * lc p", "unfolding lc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'b) / lookup p (lt p) * lookup p (lt p) =\n    (1::'b) / lookup p (lt p) * lookup p (lt p)", ".."], ["proof (state)\nthis:\n  (1::'b) / lc p * lookup p (lt p) = (1::'b) / lc p * lc p\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "also"], ["proof (state)\nthis:\n  (1::'b) / lc p * lookup p (lt p) = (1::'b) / lc p * lc p\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'b) / lc p * lc p = (1::'b)", "using \\<open>lc p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (1::'b) / lc p * lc p = (1::'b)", "by simp"], ["proof (state)\nthis:\n  (1::'b) / lc p * lc p = (1::'b)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "finally"], ["proof (chain)\npicking this:\n  lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n  (1::'b)", "have \"lookup ?q (0 \\<oplus> lt p) = 1\""], ["proof (prove)\nusing this:\n  lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n    (1::'b)", "."], ["proof (state)\nthis:\n  lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "thus \"lookup ?q (lt p) = 1\""], ["proof (prove)\nusing this:\n  lookup (monom_mult ((1::'b) / lc p) (0::'a) p) ((0::'a) \\<oplus> lt p) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  lookup (monom_mult ((1::'b) / lc p) (0::'a) p) (lt p) = (1::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monic_0 [simp]: \"monic 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic 0 = 0", "unfolding monic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult ((1::'b) / lc 0) (0::'a) 0 = 0", "by (rule monom_mult_zero_right)"], ["", "lemma monic_0_iff: \"(monic p = 0) \\<longleftrightarrow> (p = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monic p = 0) = (p = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. monic p = 0 \\<Longrightarrow> p = 0\n 2. p = 0 \\<Longrightarrow> monic p = 0", "assume \"monic p = 0\""], ["proof (state)\nthis:\n  monic p = 0\n\ngoal (2 subgoals):\n 1. monic p = 0 \\<Longrightarrow> p = 0\n 2. p = 0 \\<Longrightarrow> monic p = 0", "show \"p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "assume \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "hence \"lookup (monic p) (lt p) = 1\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lookup (monic p) (lt p) = (1::'b)", "by (rule lookup_monic_lt)"], ["proof (state)\nthis:\n  lookup (monic p) (lt p) = (1::'b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>monic p = 0\\<close>"], ["proof (chain)\npicking this:\n  monic p = 0\n  lookup (monic p) (lt p) = (1::'b)", "have \"lookup 0 (lt p) = (1::'b)\""], ["proof (prove)\nusing this:\n  monic p = 0\n  lookup (monic p) (lt p) = (1::'b)\n\ngoal (1 subgoal):\n 1. lookup 0 (lt p) = (1::'b)", "by simp"], ["proof (state)\nthis:\n  lookup 0 (lt p) = (1::'b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  lookup 0 (lt p) = (1::'b)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> monic p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> monic p = 0", "assume p0: \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> monic p = 0", "show \"monic p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic p = 0", "unfolding p0"], ["proof (prove)\ngoal (1 subgoal):\n 1. monic 0 = 0", "by (fact monic_0)"], ["proof (state)\nthis:\n  monic p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma keys_monic [simp]: \"keys (monic p) = keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monic p) = keys p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> keys (monic p) = keys p\n 2. p \\<noteq> 0 \\<Longrightarrow> keys (monic p) = keys p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> keys (monic p) = keys p\n 2. p \\<noteq> 0 \\<Longrightarrow> keys (monic p) = keys p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monic p) = keys p", "unfolding True monic_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys 0 = keys 0", ".."], ["proof (state)\nthis:\n  keys (monic p) = keys p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> keys (monic p) = keys p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> keys (monic p) = keys p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> keys (monic p) = keys p", "hence \"lc p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc p \\<noteq> (0::'b)", "by (rule lc_not_0)"], ["proof (state)\nthis:\n  lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> keys (monic p) = keys p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monic p) = keys p", "by (rule set_eqI, simp add: in_keys_iff lookup_monic \\<open>lc p \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  keys (monic p) = keys p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lt_monic [simp]: \"lt (monic p) = lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (monic p) = lt p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> lt (monic p) = lt p\n 2. p \\<noteq> 0 \\<Longrightarrow> lt (monic p) = lt p", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> lt (monic p) = lt p\n 2. p \\<noteq> 0 \\<Longrightarrow> lt (monic p) = lt p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (monic p) = lt p", "unfolding True monic_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. lt 0 = lt 0", ".."], ["proof (state)\nthis:\n  lt (monic p) = lt p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lt (monic p) = lt p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lt (monic p) = lt p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lt (monic p) = lt p", "have \"lt (monom_mult (1 / lc p) 0 p) = 0 \\<oplus> lt p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt (monom_mult ((1::'b) / lc p) (0::'a) p) = (0::'a) \\<oplus> lt p", "proof (rule lt_monom_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. (1::'b) / lc p \\<noteq> (0::'b)\n 2. p \\<noteq> 0", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"lc p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc p \\<noteq> (0::'b)", "by (rule lc_not_0)"], ["proof (state)\nthis:\n  lc p \\<noteq> (0::'b)\n\ngoal (2 subgoals):\n 1. (1::'b) / lc p \\<noteq> (0::'b)\n 2. p \\<noteq> 0", "thus \"1 / lc p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. (1::'b) / lc p \\<noteq> (0::'b)", "by simp"], ["proof (state)\nthis:\n  (1::'b) / lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "qed fact"], ["proof (state)\nthis:\n  lt (monom_mult ((1::'b) / lc p) (0::'a) p) = (0::'a) \\<oplus> lt p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> lt (monic p) = lt p", "thus ?thesis"], ["proof (prove)\nusing this:\n  lt (monom_mult ((1::'b) / lc p) (0::'a) p) = (0::'a) \\<oplus> lt p\n\ngoal (1 subgoal):\n 1. lt (monic p) = lt p", "by (simp add: monic_def term_simps)"], ["proof (state)\nthis:\n  lt (monic p) = lt p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lc_monic:\n  assumes \"p \\<noteq> 0\"\n  shows \"lc (monic p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc (monic p) = (1::'b)", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc (monic p) = (1::'b)", "by (simp add: lc_def lookup_monic_lt)"], ["", "lemma mult_lc_monic:\n  assumes \"p \\<noteq> 0\"\n  shows \"monom_mult (lc p) 0 (monic p) = p\" (is \"?q = p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_mult (lc p) (0::'a) (monic p) = p", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"lc p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc p \\<noteq> (0::'b)", "by (rule lc_not_0)"], ["proof (state)\nthis:\n  lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "have \"lookup ?q (0 \\<oplus> v) = (lc p) * (lookup (monic p) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_mult (lc p) (0::'a) (monic p)) ((0::'a) \\<oplus> v) =\n    lc p * lookup (monic p) v", "by (rule lookup_monom_mult_plus)"], ["proof (state)\nthis:\n  lookup (monom_mult (lc p) (0::'a) (monic p)) ((0::'a) \\<oplus> v) =\n  lc p * lookup (monic p) v\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "also"], ["proof (state)\nthis:\n  lookup (monom_mult (lc p) (0::'a) (monic p)) ((0::'a) \\<oplus> v) =\n  lc p * lookup (monic p) v\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "have \"... = (lc p) * ((lookup p v) / lc p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc p * lookup (monic p) v = lc p * (lookup p v / lc p)", "by (simp add: lookup_monic)"], ["proof (state)\nthis:\n  lc p * lookup (monic p) v = lc p * (lookup p v / lc p)\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "also"], ["proof (state)\nthis:\n  lc p * lookup (monic p) v = lc p * (lookup p v / lc p)\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "have \"... = lookup p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc p * (lookup p v / lc p) = lookup p v", "using \\<open>lc p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  lc p \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. lc p * (lookup p v / lc p) = lookup p v", "by simp"], ["proof (state)\nthis:\n  lc p * (lookup p v / lc p) = lookup p v\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup (monom_mult (lc p) (0::'a) (monic p)) k = lookup p k", "finally"], ["proof (chain)\npicking this:\n  lookup (monom_mult (lc p) (0::'a) (monic p)) ((0::'a) \\<oplus> v) =\n  lookup p v", "show \"lookup ?q v = lookup p v\""], ["proof (prove)\nusing this:\n  lookup (monom_mult (lc p) (0::'a) (monic p)) ((0::'a) \\<oplus> v) =\n  lookup p v\n\ngoal (1 subgoal):\n 1. lookup (monom_mult (lc p) (0::'a) (monic p)) v = lookup p v", "by (simp add: term_simps)"], ["proof (state)\nthis:\n  lookup (monom_mult (lc p) (0::'a) (monic p)) v = lookup p v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_monic_setI:\n  assumes \"\\<And>b. b \\<in> B \\<Longrightarrow> b \\<noteq> 0 \\<Longrightarrow> lc b = 1\"\n  shows \"is_monic_set B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monic_set B", "unfolding is_monic_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>B. b \\<noteq> 0 \\<longrightarrow> lc b = (1::'b)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b28 \\<in> B; ?b28 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> lc ?b28 = (1::'b)\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>B. b \\<noteq> 0 \\<longrightarrow> lc b = (1::'b)", "by auto"], ["", "lemma is_monic_setD:\n  assumes \"is_monic_set B\" and \"b \\<in> B\" and \"b \\<noteq> 0\"\n  shows \"lc b = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc b = (1::'b)", "using assms"], ["proof (prove)\nusing this:\n  is_monic_set B\n  b \\<in> B\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc b = (1::'b)", "unfolding is_monic_set_def"], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>B. b \\<noteq> 0 \\<longrightarrow> lc b = (1::'b)\n  b \\<in> B\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc b = (1::'b)", "by auto"], ["", "lemma Keys_image_monic [simp]: \"Keys (monic ` A) = Keys A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Keys (monic ` A) = Keys A", "by (simp add: Keys_def)"], ["", "lemma image_monic_is_monic_set: \"is_monic_set (monic ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_monic_set (monic ` A)", "proof (rule is_monic_setI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> monic ` A; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> lc b = (1::'b)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> monic ` A; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> lc b = (1::'b)", "assume pin: \"p \\<in> monic ` A\" and \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<in> monic ` A\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> monic ` A; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> lc b = (1::'b)", "from pin"], ["proof (chain)\npicking this:\n  p \\<in> monic ` A", "obtain p' where p_def: \"p = monic p'\" and \"p' \\<in> A\""], ["proof (prove)\nusing this:\n  p \\<in> monic ` A\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p = monic p'; p' \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  p = monic p'\n  p' \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> monic ` A; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> lc b = (1::'b)", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"p' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "unfolding p_def monic_0_iff"], ["proof (prove)\nusing this:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p' \\<noteq> 0", "."], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b \\<in> monic ` A; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> lc b = (1::'b)", "thus \"lc p = 1\""], ["proof (prove)\nusing this:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc p = (1::'b)", "unfolding p_def"], ["proof (prove)\nusing this:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lc (monic p') = (1::'b)", "by (rule lc_monic)"], ["proof (state)\nthis:\n  lc p = (1::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmdl_image_monic [simp]: \"pmdl (monic ` B) = pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (monic ` B) = pmdl B", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pmdl (monic ` B) \\<subseteq> pmdl B\n 2. pmdl B \\<subseteq> pmdl (monic ` B)", "show \"pmdl (monic ` B) \\<subseteq> pmdl B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl (monic ` B) \\<subseteq> pmdl B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl (monic ` B) \\<Longrightarrow> x \\<in> pmdl B", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl (monic ` B) \\<Longrightarrow> x \\<in> pmdl B", "assume \"p \\<in> pmdl (monic ` B)\""], ["proof (state)\nthis:\n  p \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl (monic ` B) \\<Longrightarrow> x \\<in> pmdl B", "thus \"p \\<in> pmdl B\""], ["proof (prove)\nusing this:\n  p \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl B", "proof (induct p rule: pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> pmdl B\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (monic ` B); a \\<in> pmdl B; p \\<in> monic ` B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl B", "case base: module_0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<in> pmdl B\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (monic ` B); a \\<in> pmdl B; p \\<in> monic ` B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl B", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> pmdl B", "by (fact pmdl.span_zero)"], ["proof (state)\nthis:\n  0 \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (monic ` B); a \\<in> pmdl B; p \\<in> monic ` B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (monic ` B); a \\<in> pmdl B; p \\<in> monic ` B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl B", "case ind: (module_plus a b c t)"], ["proof (state)\nthis:\n  a \\<in> pmdl (monic ` B)\n  a \\<in> pmdl B\n  b \\<in> monic ` B\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (monic ` B); a \\<in> pmdl B; p \\<in> monic ` B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl B", "from ind(3)"], ["proof (chain)\npicking this:\n  b \\<in> monic ` B", "obtain b' where b_def: \"b = monic b'\" and \"b' \\<in> B\""], ["proof (prove)\nusing this:\n  b \\<in> monic ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>b = monic b'; b' \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  b = monic b'\n  b' \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (monic ` B); a \\<in> pmdl B; p \\<in> monic ` B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl B", "have eq: \"b = monom_mult (1 / lc b') 0 b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = monom_mult ((1::'b) / lc b') (0::'a) b'", "by (simp only: b_def monic_def)"], ["proof (state)\nthis:\n  b = monom_mult ((1::'b) / lc b') (0::'a) b'\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl (monic ` B); a \\<in> pmdl B; p \\<in> monic ` B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl B", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + monom_mult c t b \\<in> pmdl B", "unfolding eq monom_mult_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + monom_mult (c * ((1::'b) / lc b')) (t + (0::'a)) b' \\<in> pmdl B", "by (rule pmdl.span_add, fact, rule monom_mult_in_pmdl, fact)"], ["proof (state)\nthis:\n  a + monom_mult c t b \\<in> pmdl B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> pmdl B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl (monic ` B) \\<subseteq> pmdl B\n\ngoal (1 subgoal):\n 1. pmdl B \\<subseteq> pmdl (monic ` B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pmdl B \\<subseteq> pmdl (monic ` B)", "show \"pmdl B \\<subseteq> pmdl (monic ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmdl B \\<subseteq> pmdl (monic ` B)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B \\<Longrightarrow> x \\<in> pmdl (monic ` B)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B \\<Longrightarrow> x \\<in> pmdl (monic ` B)", "assume \"p \\<in> pmdl B\""], ["proof (state)\nthis:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> pmdl B \\<Longrightarrow> x \\<in> pmdl (monic ` B)", "thus \"p \\<in> pmdl (monic ` B)\""], ["proof (prove)\nusing this:\n  p \\<in> pmdl B\n\ngoal (1 subgoal):\n 1. p \\<in> pmdl (monic ` B)", "proof (induct p rule: pmdl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> pmdl (monic ` B)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> pmdl (monic ` B); p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl (monic ` B)", "case base: module_0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 \\<in> pmdl (monic ` B)\n 2. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> pmdl (monic ` B); p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl (monic ` B)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> pmdl (monic ` B)", "by (fact pmdl.span_zero)"], ["proof (state)\nthis:\n  0 \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> pmdl (monic ` B); p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl (monic ` B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> pmdl (monic ` B); p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl (monic ` B)", "case ind: (module_plus a b c t)"], ["proof (state)\nthis:\n  a \\<in> pmdl B\n  a \\<in> pmdl (monic ` B)\n  b \\<in> B\n  c \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>a p c t.\n       \\<lbrakk>a \\<in> pmdl B; a \\<in> pmdl (monic ` B); p \\<in> B;\n        c \\<noteq> (0::'b)\\<rbrakk>\n       \\<Longrightarrow> a + monom_mult c t p \\<in> pmdl (monic ` B)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + monom_mult c t b \\<in> pmdl (monic ` B)", "proof (cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> a + monom_mult c t b \\<in> pmdl (monic ` B)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "case True"], ["proof (state)\nthis:\n  b = 0\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> a + monom_mult c t b \\<in> pmdl (monic ` B)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "from ind(2)"], ["proof (chain)\npicking this:\n  a \\<in> pmdl (monic ` B)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. a + monom_mult c t b \\<in> pmdl (monic ` B)", "by (simp add: True)"], ["proof (state)\nthis:\n  a + monom_mult c t b \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "let ?b = \"monic b\""], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "from ind(3)"], ["proof (chain)\npicking this:\n  b \\<in> B", "have \"?b \\<in> monic ` B\""], ["proof (prove)\nusing this:\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. monic b \\<in> monic ` B", "by (rule imageI)"], ["proof (state)\nthis:\n  monic b \\<in> monic ` B\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "have \"a + monom_mult c t (monom_mult (lc b) 0 ?b) \\<in> pmdl (monic ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + monom_mult c t (monom_mult (lc b) (0::'a) (monic b))\n    \\<in> pmdl (monic ` B)", "unfolding monom_mult_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + monom_mult (c * lc b) (t + (0::'a)) (monic b) \\<in> pmdl (monic ` B)", "by (rule pmdl.span_add, fact, rule monom_mult_in_pmdl, fact)"], ["proof (state)\nthis:\n  a + monom_mult c t (monom_mult (lc b) (0::'a) (monic b))\n  \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    a + monom_mult c t b \\<in> pmdl (monic ` B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a + monom_mult c t (monom_mult (lc b) (0::'a) (monic b))\n  \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. a + monom_mult c t b \\<in> pmdl (monic ` B)", "unfolding mult_lc_monic[OF False]"], ["proof (prove)\nusing this:\n  a + monom_mult c t b \\<in> pmdl (monic ` B)\n\ngoal (1 subgoal):\n 1. a + monom_mult c t b \\<in> pmdl (monic ` B)", "."], ["proof (state)\nthis:\n  a + monom_mult c t b \\<in> pmdl (monic ` B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a + monom_mult c t b \\<in> pmdl (monic ` B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> pmdl (monic ` B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmdl B \\<subseteq> pmdl (monic ` B)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* ordered_term *)"], ["", "end"], ["", "(* theory *)"]]}