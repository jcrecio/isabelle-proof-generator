{"file_name": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort/Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort", "problem_names": ["lemma heap_top_geq:\n  assumes \"a \\<in># multiset t\" \"is_heap t\"\n  shows \"val t \\<ge> a\"", "lemma heap_top_max:\n  assumes \"t \\<noteq> E\" \"is_heap t\"\n  shows \"val t = Max_mset (multiset t)\"", "lemma is_heap_max:\n  assumes \"in_tree v t\" \"is_heap t\"\n  shows \"val t \\<ge> v\""], "translations": [["", "lemma heap_top_geq:\n  assumes \"a \\<in># multiset t\" \"is_heap t\"\n  shows \"val t \\<ge> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> val t", "using assms"], ["proof (prove)\nusing this:\n  a \\<in># Heap.multiset t\n  is_heap t\n\ngoal (1 subgoal):\n 1. a \\<le> val t", "by (induct t rule: is_heap.induct)  (auto split: if_split_asm)"], ["", "lemma heap_top_max:\n  assumes \"t \\<noteq> E\" \"is_heap t\"\n  shows \"val t = Max_mset (multiset t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t = Max_mset (Heap.multiset t)", "proof (rule Max_eqI[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (set_mset (Heap.multiset t))\n 2. \\<And>y. y \\<in># Heap.multiset t \\<Longrightarrow> y \\<le> val t\n 3. val t \\<in># Heap.multiset t", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (set_mset (Heap.multiset t))\n 2. \\<And>y. y \\<in># Heap.multiset t \\<Longrightarrow> y \\<le> val t\n 3. val t \\<in># Heap.multiset t", "assume \"y \\<in> set_mset (multiset t)\""], ["proof (state)\nthis:\n  y \\<in># Heap.multiset t\n\ngoal (3 subgoals):\n 1. finite (set_mset (Heap.multiset t))\n 2. \\<And>y. y \\<in># Heap.multiset t \\<Longrightarrow> y \\<le> val t\n 3. val t \\<in># Heap.multiset t", "thus \"y \\<le> val t\""], ["proof (prove)\nusing this:\n  y \\<in># Heap.multiset t\n\ngoal (1 subgoal):\n 1. y \\<le> val t", "using heap_top_geq [of y t] \\<open>is_heap t\\<close>"], ["proof (prove)\nusing this:\n  y \\<in># Heap.multiset t\n  \\<lbrakk>y \\<in># Heap.multiset t; is_heap t\\<rbrakk>\n  \\<Longrightarrow> y \\<le> val t\n  is_heap t\n\ngoal (1 subgoal):\n 1. y \\<le> val t", "by simp"], ["proof (state)\nthis:\n  y \\<le> val t\n\ngoal (2 subgoals):\n 1. finite (set_mset (Heap.multiset t))\n 2. val t \\<in># Heap.multiset t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (set_mset (Heap.multiset t))\n 2. val t \\<in># Heap.multiset t", "show \"val t \\<in> set_mset (multiset t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t \\<in># Heap.multiset t", "using \\<open>t \\<noteq> E\\<close>"], ["proof (prove)\nusing this:\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. val t \\<in># Heap.multiset t", "by (cases t) auto"], ["proof (state)\nthis:\n  val t \\<in># Heap.multiset t\n\ngoal (1 subgoal):\n 1. finite (set_mset (Heap.multiset t))", "qed simp"], ["", "text\\<open>The next step is to define function {\\em remove\\_max}, but the\nquestion is weather implementation of {\\em remove\\_max} depends on\nimplementation of the functions {\\em is\\_heap} and {\\em multiset}. The\nanswer is negative. This suggests that another step of refinement\ncould be added before definition of function {\\em\n  remove\\_max}. Additionally, there are other reasons why this should\nbe done, for example, function {\\em remove\\_max} could be implemented\nin functional or in imperative manner.\n\\<close>"], ["", "locale Heap =  Collection empty is_empty of_list  multiset for \n  empty :: \"'b\" and \n  is_empty :: \"'b \\<Rightarrow> bool\" and \n  of_list :: \"'a::linorder list \\<Rightarrow> 'b\" and \n  multiset :: \"'b \\<Rightarrow> 'a::linorder multiset\" + \n  fixes as_tree :: \"'b \\<Rightarrow> 'a::linorder Tree\"\n  \\<comment> \\<open>This function is not very important, but it is needed in order to avoide problems with types and to detect that observed object is a tree.\\<close>\n  fixes remove_max :: \"'b \\<Rightarrow> 'a \\<times> 'b\"\n  assumes multiset: \"multiset l = Heap.multiset (as_tree l)\"\n  assumes is_heap_of_list: \"is_heap (as_tree (of_list i))\"\n  assumes as_tree_empty: \"as_tree t = E \\<longleftrightarrow> is_empty t\"\n  assumes remove_max_multiset': \n  \"\\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> add_mset m (multiset l') = multiset l\"\n  assumes remove_max_is_heap: \n  \"\\<lbrakk>\\<not> is_empty l; is_heap (as_tree l); (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> \n  is_heap (as_tree l')\"\n  assumes remove_max_val: \n  \"\\<lbrakk> \\<not> is_empty t; (m, t') = remove_max t\\<rbrakk> \\<Longrightarrow> m = val (as_tree t)\""], ["", "text\\<open>It is very easy to prove that locale {\\em Heap} is sublocale of locale {\\em RemoveMax}\\<close>"], ["", "sublocale Heap < \n  RemoveMax empty is_empty of_list multiset remove_max \"\\<lambda> t. is_heap (as_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RemoveMax empty is_empty of_list multiset remove_max\n     (\\<lambda>t. is_heap (as_tree t))", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. is_heap (as_tree (of_list x))\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (multiset l') = multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. is_heap (as_tree (of_list x))\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (multiset l') = multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "show \"is_heap (as_tree (of_list x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (as_tree (of_list x))", "by (rule is_heap_of_list)"], ["proof (state)\nthis:\n  is_heap (as_tree (of_list x))\n\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (multiset l') = multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (multiset l') = multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "fix l m l'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (multiset l') = multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "assume \"\\<not> is_empty l\" \"(m, l') = remove_max l\""], ["proof (state)\nthis:\n  \\<not> is_empty l\n  (m, l') = remove_max l\n\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (multiset l') = multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "thus \"add_mset m (multiset l') = multiset l\""], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. add_mset m (multiset l') = multiset l", "by (rule remove_max_multiset')"], ["proof (state)\nthis:\n  add_mset m (multiset l') = multiset l\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "fix l m l'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "assume \"\\<not> is_empty l\" \"is_heap (as_tree l)\" \"(m, l') = remove_max l\""], ["proof (state)\nthis:\n  \\<not> is_empty l\n  is_heap (as_tree l)\n  (m, l') = remove_max l\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (as_tree l')", "thus \"is_heap (as_tree l')\""], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  is_heap (as_tree l)\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. is_heap (as_tree l')", "by (rule remove_max_is_heap)"], ["proof (state)\nthis:\n  is_heap (as_tree l')\n\ngoal (1 subgoal):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)", "fix l m l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)", "assume \"\\<not> is_empty l\" \"is_heap (as_tree l)\" \"(m, l') = remove_max l\""], ["proof (state)\nthis:\n  \\<not> is_empty l\n  is_heap (as_tree l)\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> is_empty l; is_heap (as_tree l);\n        (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> m = Max (local.set l)", "thus \"m = Max (set l)\""], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  is_heap (as_tree l)\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. m = Max (local.set l)", "unfolding set_def"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  is_heap (as_tree l)\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. m = Max_mset (multiset l)", "using heap_top_max[of \"as_tree l\"] remove_max_val[of l m l']"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  is_heap (as_tree l)\n  (m, l') = remove_max l\n  \\<lbrakk>as_tree l \\<noteq> E; is_heap (as_tree l)\\<rbrakk>\n  \\<Longrightarrow> val (as_tree l) = Max_mset (Heap.multiset (as_tree l))\n  \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> m = val (as_tree l)\n\ngoal (1 subgoal):\n 1. m = Max_mset (multiset l)", "using multiset is_empty_inj as_tree_empty"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  is_heap (as_tree l)\n  (m, l') = remove_max l\n  \\<lbrakk>as_tree l \\<noteq> E; is_heap (as_tree l)\\<rbrakk>\n  \\<Longrightarrow> val (as_tree l) = Max_mset (Heap.multiset (as_tree l))\n  \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> m = val (as_tree l)\n  multiset ?l = Heap.multiset (as_tree ?l)\n  is_empty ?e \\<Longrightarrow> ?e = empty\n  (as_tree ?t = E) = is_empty ?t\n\ngoal (1 subgoal):\n 1. m = Max_mset (multiset l)", "by auto"], ["proof (state)\nthis:\n  m = Max (local.set l)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec in_tree where\n  \"in_tree v E = False\"\n| \"in_tree v (T v' l r) \\<longleftrightarrow> v = v' \\<or> in_tree v l \\<or> in_tree v r\""], ["", "lemma is_heap_max:\n  assumes \"in_tree v t\" \"is_heap t\"\n  shows \"val t \\<ge> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le> val t", "using assms"], ["proof (prove)\nusing this:\n  in_tree v t\n  is_heap t\n\ngoal (1 subgoal):\n 1. v \\<le> val t", "apply (induct t rule:is_heap.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>in_tree v E; is_heap E\\<rbrakk> \\<Longrightarrow> v \\<le> val E\n 2. \\<And>va.\n       \\<lbrakk>in_tree v (T va E E); is_heap (T va E E)\\<rbrakk>\n       \\<Longrightarrow> v \\<le> val (T va E E)\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>in_tree v (T vaa vb vc);\n                 is_heap (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> v \\<le> val (T vaa vb vc);\n        in_tree v (T va E (T vaa vb vc));\n        is_heap (T va E (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> v \\<le> val (T va E (T vaa vb vc))\n 4. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>in_tree v (T vaa vb vc);\n                 is_heap (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> v \\<le> val (T vaa vb vc);\n        in_tree v (T va (T vaa vb vc) E);\n        is_heap (T va (T vaa vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> v \\<le> val (T va (T vaa vb vc) E)\n 5. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>in_tree v (T vd ve vf);\n                 is_heap (T vd ve vf)\\<rbrakk>\n                \\<Longrightarrow> v \\<le> val (T vd ve vf);\n        \\<lbrakk>in_tree v (T vaa vb vc); is_heap (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> v \\<le> val (T vaa vb vc);\n        in_tree v (T va (T vaa vb vc) (T vd ve vf));\n        is_heap (T va (T vaa vb vc) (T vd ve vf))\\<rbrakk>\n       \\<Longrightarrow> v \\<le> val (T va (T vaa vb vc) (T vd ve vf))\n 6. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>in_tree v (T vaa vb vc);\n                 is_heap (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> v \\<le> val (T vaa vb vc);\n        \\<lbrakk>in_tree v (T vd ve vf); is_heap (T vd ve vf)\\<rbrakk>\n        \\<Longrightarrow> v \\<le> val (T vd ve vf);\n        in_tree v (T va (T vd ve vf) (T vaa vb vc));\n        is_heap (T va (T vd ve vf) (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> v \\<le> val (T va (T vd ve vf) (T vaa vb vc))", "by auto"], ["", "end"]]}