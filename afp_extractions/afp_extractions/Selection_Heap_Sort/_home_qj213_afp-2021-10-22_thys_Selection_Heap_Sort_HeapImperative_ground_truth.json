{"file_name": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort/HeapImperative.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort", "problem_names": ["lemma siftDown_Node:\n  assumes \"t = T v l r\"\n  shows \"\\<exists> l' v' r'. siftDown t = T v' l' r' \\<and> v' \\<ge> v\"", "lemma siftDown_in_tree:\n  assumes \"t \\<noteq> E\"\n  shows \"in_tree (val (siftDown t)) t\"", "lemma siftDown_in_tree_set: \n  shows \"in_tree v t \\<longleftrightarrow> in_tree v (siftDown t)\"", "lemma siftDown_heap_is_heap:\n  assumes \"is_heap l\" \"is_heap r\" \"t = T v l r\"\n  shows \"is_heap (siftDown t)\"", "lemma heapify_heap_is_heap:\n  \"is_heap (heapify t)\"", "lemma siftDown_multiset:\n  \"multiset (siftDown t) = multiset t\"", "lemma mset_list_tree:\n \"multiset (of_list_tree l) = mset l\"", "lemma multiset_heapify:\n  \"multiset (heapify t) = multiset t\"", "lemma multiset_heapify_of_list_tree:\n  \"multiset (heapify (of_list_tree l)) = mset l\"", "lemma removeLeaf_val_val:\n  assumes \"snd (removeLeaf t) \\<noteq> E\" \"t \\<noteq> E\"\n  shows \"val t = val (snd (removeLeaf t))\"", "lemma removeLeaf_heap_is_heap: \n  assumes \"is_heap t\" \"t \\<noteq> E\"\n  shows \"is_heap (snd (removeLeaf t))\"", "lemma removeLeaf_multiset:\n  assumes \"(v', t') = removeLeaf t\" \"t \\<noteq> E\"\n  shows \"{#v'#} + multiset t' = multiset t\"", "lemma set_val_multiset:\n  assumes \"t \\<noteq> E\"\n  shows \"multiset (set_val t v') +  {#val t#} = {#v'#} + multiset t\"", "lemma hs_remove_max_multiset:\n  assumes \"(m, t') = hs_remove_max t\" \"t \\<noteq> E\"\n  shows \"{#m#} + multiset t' = multiset t\""], "translations": [["", "lemma siftDown_Node:\n  assumes \"t = T v l r\"\n  shows \"\\<exists> l' v' r'. siftDown t = T v' l' r' \\<and> v' \\<ge> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l' v' r'. siftDown t = T v' l' r' \\<and> v \\<le> v'", "using assms"], ["proof (prove)\nusing this:\n  t = T v l r\n\ngoal (1 subgoal):\n 1. \\<exists>l' v' r'. siftDown t = T v' l' r' \\<and> v \\<le> v'", "apply(induct t rule:siftDown.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. E = T v l r \\<Longrightarrow>\n    \\<exists>l' v' r'. siftDown E = T v' l' r' \\<and> v \\<le> v'\n 2. \\<And>va.\n       T va E E = T v l r \\<Longrightarrow>\n       \\<exists>l' v' r'. siftDown (T va E E) = T v' l' r' \\<and> v \\<le> v'\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 set_val (T vaa vb vc) va = T v l r\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l' v' r'.\n                                     siftDown (set_val (T vaa vb vc) va) =\n                                     T v' l' r' \\<and>\n                                     v \\<le> v';\n        T va (T vaa vb vc) E = T v l r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l' v' r'.\n                            siftDown (T va (T vaa vb vc) E) =\n                            T v' l' r' \\<and>\n                            v \\<le> v'\n 4. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 set_val (T vaa vb vc) va = T v l r\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l' v' r'.\n                                     siftDown (set_val (T vaa vb vc) va) =\n                                     T v' l' r' \\<and>\n                                     v \\<le> v';\n        T va E (T vaa vb vc) = T v l r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l' v' r'.\n                            siftDown (T va E (T vaa vb vc)) =\n                            T v' l' r' \\<and>\n                            v \\<le> v'\n 5. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 set_val (T vaa vb vc) va = T v l r\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l' v' r'.\n                                     siftDown (set_val (T vaa vb vc) va) =\n                                     T v' l' r' \\<and>\n                                     v \\<le> v';\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         set_val (T vd ve vf) va = T v l r\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l' v' r'.\n                             siftDown (set_val (T vd ve vf) va) =\n                             T v' l' r' \\<and>\n                             v \\<le> v';\n        T va (T vaa vb vc) (T vd ve vf) = T v l r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l' v' r'.\n                            siftDown (T va (T vaa vb vc) (T vd ve vf)) =\n                            T v' l' r' \\<and>\n                            v \\<le> v'\n 6. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 set_val (T vd ve vf) va = T v l r\\<rbrakk>\n                \\<Longrightarrow> \\<exists>l' v' r'.\n                                     siftDown (set_val (T vd ve vf) va) =\n                                     T v' l' r' \\<and>\n                                     v \\<le> v';\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         set_val (T vaa vb vc) va = T v l r\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l' v' r'.\n                             siftDown (set_val (T vaa vb vc) va) =\n                             T v' l' r' \\<and>\n                             v \\<le> v';\n        T va (T vd ve vf) (T vaa vb vc) = T v l r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l' v' r'.\n                            siftDown (T va (T vd ve vf) (T vaa vb vc)) =\n                            T v' l' r' \\<and>\n                            v \\<le> v'", "by auto"], ["", "lemma siftDown_in_tree:\n  assumes \"t \\<noteq> E\"\n  shows \"in_tree (val (siftDown t)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree (val (siftDown t)) t", "using assms"], ["proof (prove)\nusing this:\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. in_tree (val (siftDown t)) t", "apply(induct t rule:siftDown.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. E \\<noteq> E \\<Longrightarrow> in_tree (val (siftDown E)) E\n 2. \\<And>v.\n       T v E E \\<noteq> E \\<Longrightarrow>\n       in_tree (val (siftDown (T v E E))) (T v E E)\n 3. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T va vb vc) \\<le> v;\n                 set_val (T va vb vc) v \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> in_tree\n                                   (val (siftDown (set_val (T va vb vc) v)))\n                                   (set_val (T va vb vc) v);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> in_tree (val (siftDown (T v (T va vb vc) E)))\n                          (T v (T va vb vc) E)\n 4. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T va vb vc) \\<le> v;\n                 set_val (T va vb vc) v \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> in_tree\n                                   (val (siftDown (set_val (T va vb vc) v)))\n                                   (set_val (T va vb vc) v);\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> in_tree (val (siftDown (T v E (T va vb vc))))\n                          (T v E (T va vb vc))\n 5. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v;\n                 set_val (T va vb vc) v \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> in_tree\n                                   (val (siftDown (set_val (T va vb vc) v)))\n                                   (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v;\n         set_val (T vd ve vf) v \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> in_tree (val (siftDown (set_val (T vd ve vf) v)))\n                           (set_val (T vd ve vf) v);\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> in_tree\n                          (val (siftDown (T v (T va vb vc) (T vd ve vf))))\n                          (T v (T va vb vc) (T vd ve vf))\n 6. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v;\n                 set_val (T vd ve vf) v \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> in_tree\n                                   (val (siftDown (set_val (T vd ve vf) v)))\n                                   (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v;\n         set_val (T va vb vc) v \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> in_tree (val (siftDown (set_val (T va vb vc) v)))\n                           (set_val (T va vb vc) v);\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> in_tree\n                          (val (siftDown (T v (T vd ve vf) (T va vb vc))))\n                          (T v (T vd ve vf) (T va vb vc))", "by auto"], ["", "lemma siftDown_in_tree_set: \n  shows \"in_tree v t \\<longleftrightarrow> in_tree v (siftDown t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v t = in_tree v (siftDown t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. in_tree v t \\<Longrightarrow> in_tree v (siftDown t)\n 2. in_tree v (siftDown t) \\<Longrightarrow> in_tree v t", "assume \"in_tree v t\""], ["proof (state)\nthis:\n  in_tree v t\n\ngoal (2 subgoals):\n 1. in_tree v t \\<Longrightarrow> in_tree v (siftDown t)\n 2. in_tree v (siftDown t) \\<Longrightarrow> in_tree v t", "thus \"in_tree v (siftDown t)\""], ["proof (prove)\nusing this:\n  in_tree v t\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown t)", "apply (induct t rule:siftDown.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. in_tree v E \\<Longrightarrow> in_tree v (siftDown E)\n 2. \\<And>va.\n       in_tree v (T va E E) \\<Longrightarrow>\n       in_tree v (siftDown (T va E E))\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (set_val (T vaa vb vc) va)\\<rbrakk>\n                \\<Longrightarrow> in_tree v\n                                   (siftDown (set_val (T vaa vb vc) va));\n        in_tree v (T va (T vaa vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> in_tree v (siftDown (T va (T vaa vb vc) E))\n 4. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (set_val (T vaa vb vc) va)\\<rbrakk>\n                \\<Longrightarrow> in_tree v\n                                   (siftDown (set_val (T vaa vb vc) va));\n        in_tree v (T va E (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (siftDown (T va E (T vaa vb vc)))\n 5. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (set_val (T vaa vb vc) va)\\<rbrakk>\n                \\<Longrightarrow> in_tree v\n                                   (siftDown (set_val (T vaa vb vc) va));\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (set_val (T vd ve vf) va)\\<rbrakk>\n        \\<Longrightarrow> in_tree v (siftDown (set_val (T vd ve vf) va));\n        in_tree v (T va (T vaa vb vc) (T vd ve vf))\\<rbrakk>\n       \\<Longrightarrow> in_tree v\n                          (siftDown (T va (T vaa vb vc) (T vd ve vf)))\n 6. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (set_val (T vd ve vf) va)\\<rbrakk>\n                \\<Longrightarrow> in_tree v\n                                   (siftDown (set_val (T vd ve vf) va));\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (set_val (T vaa vb vc) va)\\<rbrakk>\n        \\<Longrightarrow> in_tree v (siftDown (set_val (T vaa vb vc) va));\n        in_tree v (T va (T vd ve vf) (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> in_tree v\n                          (siftDown (T va (T vd ve vf) (T vaa vb vc)))", "by auto"], ["proof (state)\nthis:\n  in_tree v (siftDown t)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown t) \\<Longrightarrow> in_tree v t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. in_tree v (siftDown t) \\<Longrightarrow> in_tree v t", "assume \" in_tree v (siftDown t)\""], ["proof (state)\nthis:\n  in_tree v (siftDown t)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown t) \\<Longrightarrow> in_tree v t", "thus \"in_tree v t\""], ["proof (prove)\nusing this:\n  in_tree v (siftDown t)\n\ngoal (1 subgoal):\n 1. in_tree v t", "proof (induct t rule:siftDown.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. in_tree v (siftDown E) \\<Longrightarrow> in_tree v E\n 2. \\<And>va.\n       in_tree v (siftDown (T va E E)) \\<Longrightarrow>\n       in_tree v (T va E E)\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 4. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 5. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 6. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "case 1"], ["proof (state)\nthis:\n  in_tree v (siftDown E)\n\ngoal (6 subgoals):\n 1. in_tree v (siftDown E) \\<Longrightarrow> in_tree v E\n 2. \\<And>va.\n       in_tree v (siftDown (T va E E)) \\<Longrightarrow>\n       in_tree v (T va E E)\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 4. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 5. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 6. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "thus ?case"], ["proof (prove)\nusing this:\n  in_tree v (siftDown E)\n\ngoal (1 subgoal):\n 1. in_tree v E", "by auto"], ["proof (state)\nthis:\n  in_tree v E\n\ngoal (5 subgoals):\n 1. \\<And>va.\n       in_tree v (siftDown (T va E E)) \\<Longrightarrow>\n       in_tree v (T va E E)\n 2. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 4. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 5. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>va.\n       in_tree v (siftDown (T va E E)) \\<Longrightarrow>\n       in_tree v (T va E E)\n 2. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 4. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 5. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "case (2 v1)"], ["proof (state)\nthis:\n  in_tree v (siftDown (T v1 E E))\n\ngoal (5 subgoals):\n 1. \\<And>va.\n       in_tree v (siftDown (T va E E)) \\<Longrightarrow>\n       in_tree v (T va E E)\n 2. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 3. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 4. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 5. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "thus ?case"], ["proof (prove)\nusing this:\n  in_tree v (siftDown (T v1 E E))\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 E E)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v1 E E)\n\ngoal (4 subgoals):\n 1. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 2. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 3. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 4. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 2. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 3. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 4. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "case (3 v2 v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  in_tree v (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal (4 subgoals):\n 1. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vaa vb vc) E))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) E)\n 2. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 3. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 4. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "proof(cases \"v2 \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v2\n\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "using 3"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  in_tree v (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 (T v1 l1 r1) E)\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "proof(cases \"v1 = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 = v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)\n 2. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "case True"], ["proof (state)\nthis:\n  v1 = v\n\ngoal (2 subgoals):\n 1. v1 = v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)\n 2. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 = v\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "using 3 False"], ["proof (prove)\nusing this:\n  v1 = v\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  in_tree v (siftDown (T v2 (T v1 l1 r1) E))\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 (T v1 l1 r1) E)\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "case False"], ["proof (state)\nthis:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "hence \"in_tree v (siftDown (set_val (T v1 l1 r1) v2))\""], ["proof (prove)\nusing this:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v2))", "using \\<open>\\<not> v2 \\<ge> v1\\<close> 3(2)"], ["proof (prove)\nusing this:\n  v1 \\<noteq> v\n  \\<not> v1 \\<le> v2\n  in_tree v (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v2))\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "hence \"in_tree v (T v2 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v2))\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l1 r1)", "using 3(1) \\<open>\\<not> v2 \\<ge> v1\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v2))\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "proof(cases \"v2 = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 = v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)\n 2. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "case True"], ["proof (state)\nthis:\n  v2 = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 = v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)\n 2. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 = v\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 (T v1 l1 r1) E)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "case False"], ["proof (state)\nthis:\n  v2 \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "hence \"in_tree v (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  v2 \\<noteq> v\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "using \\<open>in_tree v (T v2 l1 r1)\\<close>"], ["proof (prove)\nusing this:\n  v2 \\<noteq> v\n  in_tree v (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 (T v1 l1 r1) E)", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 (T v1 l1 r1) E)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 (T v1 l1 r1) E)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v2 (T v1 l1 r1) E)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v2 (T v1 l1 r1) E)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v2 (T v1 l1 r1) E)\n\ngoal (3 subgoals):\n 1. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 2. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 3. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 2. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 3. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "case (4 v2 v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  in_tree v (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal (3 subgoals):\n 1. \\<And>va vaa vb vc.\n       \\<lbrakk>\\<lbrakk>\\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va E (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va E (T vaa vb vc))\n 2. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 3. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "proof(cases \"v2 \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v2\n\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "using 4"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  in_tree v (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 E (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "proof(cases \"v1 = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 = v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))\n 2. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "case True"], ["proof (state)\nthis:\n  v1 = v\n\ngoal (2 subgoals):\n 1. v1 = v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))\n 2. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 = v\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "using 4 False"], ["proof (prove)\nusing this:\n  v1 = v\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  in_tree v (siftDown (T v2 E (T v1 l1 r1)))\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 E (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "case False"], ["proof (state)\nthis:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "hence \"in_tree v (siftDown (set_val (T v1 l1 r1) v2))\""], ["proof (prove)\nusing this:\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v2))", "using \\<open>\\<not> v2 \\<ge> v1\\<close> 4(2)"], ["proof (prove)\nusing this:\n  v1 \\<noteq> v\n  \\<not> v1 \\<le> v2\n  in_tree v (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v2))\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "hence \"in_tree v (T v2 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v2))\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l1 r1)", "using 4(1) \\<open>\\<not> v2 \\<ge> v1\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v2))\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2;\n   in_tree v (siftDown (set_val (T v1 l1 r1) v2))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v2)\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. v1 \\<noteq> v \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "proof(cases \"v2 = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 = v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))\n 2. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "case True"], ["proof (state)\nthis:\n  v2 = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 = v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))\n 2. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 = v\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 E (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "case False"], ["proof (state)\nthis:\n  v2 \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "hence \"in_tree v (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  v2 \\<noteq> v\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "using \\<open>in_tree v (T v2 l1 r1)\\<close>"], ["proof (prove)\nusing this:\n  v2 \\<noteq> v\n  in_tree v (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>in_tree v (T v2 l1 r1); v2 \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v2 E (T v1 l1 r1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 E (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 E (T v1 l1 r1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v2 E (T v1 l1 r1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v2 E (T v1 l1 r1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v2 E (T v1 l1 r1))\n\ngoal (2 subgoals):\n 1. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 2. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 2. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "case (\"5_1\" v' v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n\ngoal (2 subgoals):\n 1. \\<And>va vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T vaa vb vc);\n                 \\<not> val (T vaa vb vc) \\<le> va;\n                 in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T vaa vb vc);\n         \\<not> val (T vd ve vf) \\<le> va;\n         in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        in_tree v (siftDown (T va (T vaa vb vc) (T vd ve vf)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vaa vb vc) (T vd ve vf))\n 2. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v = v' \\<or> v= v1 \\<or> v = v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = v' \\<or> v = v1 \\<or> v = v2 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v = v' \\<or> v = v1 \\<or> v = v2\n\ngoal (2 subgoals):\n 1. v = v' \\<or> v = v1 \\<or> v = v2 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = v' \\<or> v = v1 \\<or> v = v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v1 \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v' \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v'\n\ngoal (2 subgoals):\n 1. v1 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>v1 \\<ge> v2\\<close> \"5_1\""], ["proof (prove)\nusing this:\n  v1 \\<le> v'\n  v2 \\<le> v1\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"in_tree v (T v2 l2 r2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  in_tree v (T v2 l2 r2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (siftDown (set_val (T v1 l1 r1) v'))\""], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v'))", "using \"5_1\"(3) \\<open>\\<not> in_tree v (T v2 l2 r2)\\<close> \\<open>v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v1\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v2 l2 r2)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v2 l2 r2)\n  v2 \\<le> v1\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v'))", "using \\<open> \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v2 l2 r2)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v2 l2 r2)\n  v2 \\<le> v1\n  \\<not> v1 \\<le> v'\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v'))", "by auto"], ["proof (state)\nthis:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v' l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v'))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l1 r1)", "using \"5_1\"(1) \\<open>v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v1\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v'))\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  v2 \\<le> v1\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v (T v' l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "using  \\<open>\\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (T v' l1 r1)\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v' \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v'\n\ngoal (2 subgoals):\n 1. v2 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>\\<not> v1 \\<ge> v2\\<close> \"5_1\""], ["proof (prove)\nusing this:\n  v2 \\<le> v'\n  \\<not> v2 \\<le> v1\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"in_tree v (T v1 l1 r1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  in_tree v (T v1 l1 r1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (siftDown (set_val (T v2 l2 r2) v'))\""], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v2 l2 r2) v'))", "using \"5_1\"(3) \\<open>\\<not> in_tree v (T v1 l1 r1)\\<close> \\<open>\\<not> v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v1 l1 r1)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v1 l1 r1)\n  \\<not> v2 \\<le> v1\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v2 l2 r2) v'))", "using \\<open> \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v1 l1 r1)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v1 l1 r1)\n  \\<not> v2 \\<le> v1\n  \\<not> v2 \\<le> v'\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v2 l2 r2) v'))", "by auto"], ["proof (state)\nthis:\n  in_tree v (siftDown (set_val (T v2 l2 r2) v'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v' l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v2 l2 r2) v'))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l2 r2)", "using \"5_1\"(2) \\<open>\\<not> v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v2 l2 r2) v'))\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  \\<not> v2 \\<le> v1\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v (T v' l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l2 r2)", "using  \\<open>\\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (T v' l2 r2)\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "case (\"5_2\" v' v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n\ngoal (1 subgoal):\n 1. \\<And>va vd ve vf vaa vb vc.\n       \\<lbrakk>\\<lbrakk>val (T vaa vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> va;\n                 in_tree v (siftDown (set_val (T vd ve vf) va))\\<rbrakk>\n                \\<Longrightarrow> in_tree v (set_val (T vd ve vf) va);\n        \\<lbrakk>\\<not> val (T vaa vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T vaa vb vc) \\<le> va;\n         in_tree v (siftDown (set_val (T vaa vb vc) va))\\<rbrakk>\n        \\<Longrightarrow> in_tree v (set_val (T vaa vb vc) va);\n        in_tree v (siftDown (T va (T vd ve vf) (T vaa vb vc)))\\<rbrakk>\n       \\<Longrightarrow> in_tree v (T va (T vd ve vf) (T vaa vb vc))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v = v' \\<or> v= v1 \\<or> v = v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = v' \\<or> v = v1 \\<or> v = v2 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v = v' \\<or> v = v1 \\<or> v = v2\n\ngoal (2 subgoals):\n 1. v = v' \\<or> v = v1 \\<or> v = v2 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = v' \\<or> v = v1 \\<or> v = v2\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. \\<not> (v = v' \\<or> v = v1 \\<or> v = v2) \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v1 \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v' \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v'\n\ngoal (2 subgoals):\n 1. v1 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>v1 \\<ge> v2\\<close> \"5_2\""], ["proof (prove)\nusing this:\n  v1 \\<le> v'\n  v2 \\<le> v1\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"in_tree v (T v2 l2 r2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  in_tree v (T v2 l2 r2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (siftDown (set_val (T v1 l1 r1) v'))\""], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v'))", "using \"5_2\"(3) \\<open>\\<not> in_tree v (T v2 l2 r2)\\<close> \\<open>v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v1\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v2 l2 r2)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v2 l2 r2)\n  v2 \\<le> v1\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v'))", "using \\<open> \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v2 l2 r2)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v2 l2 r2)\n  v2 \\<le> v1\n  \\<not> v1 \\<le> v'\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v1 l1 r1) v'))", "by auto"], ["proof (state)\nthis:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v' l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v'))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l1 r1)", "using \"5_2\"(1) \\<open>v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v1\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v1 l1 r1) v'))\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  v2 \\<le> v1\n  \\<not> v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v (T v' l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "using  \\<open>\\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (T v' l1 r1)\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v1 \\<le> v'; \\<not> in_tree v (T v2 l2 r2)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v' \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v'\n\ngoal (2 subgoals):\n 1. v2 \\<le> v' \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>\\<not> v1 \\<ge> v2\\<close> \"5_2\""], ["proof (prove)\nusing this:\n  v2 \\<le> v'\n  \\<not> v2 \\<le> v1\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v';\n   in_tree v (siftDown (set_val (T v1 l1 r1) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v1 l1 r1) v')\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v' \\<Longrightarrow>\n    in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"in_tree v (T v1 l1 r1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  in_tree v (T v1 l1 r1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (siftDown (set_val (T v2 l2 r2) v'))\""], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v2 l2 r2) v'))", "using \"5_2\"(3) \\<open>\\<not> in_tree v (T v1 l1 r1)\\<close> \\<open>\\<not> v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v1 l1 r1)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v1 l1 r1)\n  \\<not> v2 \\<le> v1\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v2 l2 r2) v'))", "using \\<open> \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> in_tree v (T v1 l1 r1)\n  in_tree v (siftDown (T v' (T v1 l1 r1) (T v2 l2 r2)))\n  \\<not> in_tree v (T v1 l1 r1)\n  \\<not> v2 \\<le> v1\n  \\<not> v2 \\<le> v'\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (siftDown (set_val (T v2 l2 r2) v'))", "by auto"], ["proof (state)\nthis:\n  in_tree v (siftDown (set_val (T v2 l2 r2) v'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v' l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v2 l2 r2) v'))\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l2 r2)", "using \"5_2\"(2) \\<open>\\<not> v1 \\<ge> v2\\<close> \\<open>\\<not> v' \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (siftDown (set_val (T v2 l2 r2) v'))\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v';\n   in_tree v (siftDown (set_val (T v2 l2 r2) v'))\\<rbrakk>\n  \\<Longrightarrow> in_tree v (set_val (T v2 l2 r2) v')\n  \\<not> v2 \\<le> v1\n  \\<not> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v (T v' l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "hence \"in_tree v (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v (T v' l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l2 r2)", "using  \\<open>\\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\\<close>"], ["proof (prove)\nusing this:\n  in_tree v (T v' l2 r2)\n  \\<not> (v = v' \\<or> v = v1 \\<or> v = v2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> v2 \\<le> v'; \\<not> in_tree v (T v1 l1 r1)\\<rbrakk>\n    \\<Longrightarrow> in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v (T v' (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_tree v t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma siftDown_heap_is_heap:\n  assumes \"is_heap l\" \"is_heap r\" \"t = T v l r\"\n  shows \"is_heap (siftDown t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown t)", "using assms"], ["proof (prove)\nusing this:\n  is_heap l\n  is_heap r\n  t = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown t)", "proof (induct t arbitrary: v l r  rule:siftDown.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v l r.\n       \\<lbrakk>is_heap l; is_heap r; E = T v l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown E)\n 2. \\<And>v va l r.\n       \\<lbrakk>is_heap l; is_heap r; T v E E = T va l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E E))\n 3. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 4. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 5. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 6. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "case 1"], ["proof (state)\nthis:\n  is_heap l\n  is_heap r\n  E = T v l r\n\ngoal (6 subgoals):\n 1. \\<And>v l r.\n       \\<lbrakk>is_heap l; is_heap r; E = T v l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown E)\n 2. \\<And>v va l r.\n       \\<lbrakk>is_heap l; is_heap r; T v E E = T va l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E E))\n 3. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 4. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 5. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 6. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "thus ?case"], ["proof (prove)\nusing this:\n  is_heap l\n  is_heap r\n  E = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown E)", "by simp"], ["proof (state)\nthis:\n  is_heap (siftDown E)\n\ngoal (5 subgoals):\n 1. \\<And>v va l r.\n       \\<lbrakk>is_heap l; is_heap r; T v E E = T va l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E E))\n 2. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 3. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 4. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 5. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v va l r.\n       \\<lbrakk>is_heap l; is_heap r; T v E E = T va l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E E))\n 2. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 3. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 4. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 5. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "case (2 v')"], ["proof (state)\nthis:\n  is_heap l\n  is_heap r\n  T v' E E = T v l r\n\ngoal (5 subgoals):\n 1. \\<And>v va l r.\n       \\<lbrakk>is_heap l; is_heap r; T v E E = T va l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E E))\n 2. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 3. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 4. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 5. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v' E E))", "by simp"], ["proof (state)\nthis:\n  is_heap (siftDown (T v' E E))\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 2. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 3. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 4. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 2. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 3. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 4. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "case (3 v2 v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap ?l; is_heap ?r;\n   set_val (T v1 l1 r1) v2 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n  is_heap l\n  is_heap r\n  T v2 (T v1 l1 r1) E = T v l r\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v (T va vb vc) E = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) E))\n 2. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 3. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 4. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "proof (cases \"v2 \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> is_heap (siftDown (T v2 (T v1 l1 r1) E))\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v2\n\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> is_heap (siftDown (T v2 (T v1 l1 r1) E))\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "using 3(2) 3(4)"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n  is_heap l\n  T v2 (T v1 l1 r1) E = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "let ?t = \"siftDown (T v2 l1 r1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "obtain l' v' r' where *: \"?t = T v' l' r'\" \"v' \\<ge> v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v2 l1 r1) = T v' l' r'; v2 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using siftDown_Node[of \"T v2 l1 r1\" v2 l1 r1]"], ["proof (prove)\nusing this:\n  T v2 l1 r1 = T v2 l1 r1 \\<Longrightarrow>\n  \\<exists>l' v' r'. siftDown (T v2 l1 r1) = T v' l' r' \\<and> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v2 l1 r1) = T v' l' r'; v2 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "have \"l = T v1 l1 r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = T v1 l1 r1", "using 3(4)"], ["proof (prove)\nusing this:\n  T v2 (T v1 l1 r1) E = T v l r\n\ngoal (1 subgoal):\n 1. l = T v1 l1 r1", "by auto"], ["proof (state)\nthis:\n  l = T v1 l1 r1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "hence \"is_heap l1\" \"is_heap r1\""], ["proof (prove)\nusing this:\n  l = T v1 l1 r1\n\ngoal (1 subgoal):\n 1. is_heap l1 &&& is_heap r1", "using 3(2)"], ["proof (prove)\nusing this:\n  l = T v1 l1 r1\n  is_heap l\n\ngoal (1 subgoal):\n 1. is_heap l1 &&& is_heap r1", "apply (induct l rule:is_heap.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>E = T v1 l1 r1; is_heap E\\<rbrakk> \\<Longrightarrow> is_heap l1\n 2. \\<lbrakk>E = T v1 l1 r1; is_heap E\\<rbrakk> \\<Longrightarrow> is_heap r1\n 3. \\<And>v.\n       \\<lbrakk>T v E E = T v1 l1 r1; is_heap (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 4. \\<And>v.\n       \\<lbrakk>T v E E = T v1 l1 r1; is_heap (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r1\n 5. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v E (T va vb vc) = T v1 l1 r1;\n        is_heap (T v E (T va vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 6. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v E (T va vb vc) = T v1 l1 r1;\n        is_heap (T v E (T va vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap r1\n 7. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v (T va vb vc) E = T v1 l1 r1;\n        is_heap (T v (T va vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 8. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v (T va vb vc) E = T v1 l1 r1;\n        is_heap (T v (T va vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r1\n 9. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>T vd ve vf = T v1 l1 r1;\n                 is_heap (T vd ve vf)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T vd ve vf = T v1 l1 r1; is_heap (T vd ve vf)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v (T va vb vc) (T vd ve vf) = T v1 l1 r1;\n        is_heap (T v (T va vb vc) (T vd ve vf))\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 10. \\<And>v va vb vc vd ve vf.\n        \\<lbrakk>\\<lbrakk>T vd ve vf = T v1 l1 r1;\n                  is_heap (T vd ve vf)\\<rbrakk>\n                 \\<Longrightarrow> is_heap l1;\n         \\<lbrakk>T vd ve vf = T v1 l1 r1; is_heap (T vd ve vf)\\<rbrakk>\n         \\<Longrightarrow> is_heap r1;\n         \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap l1;\n         \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap r1;\n         T v (T va vb vc) (T vd ve vf) = T v1 l1 r1;\n         is_heap (T v (T va vb vc) (T vd ve vf))\\<rbrakk>\n        \\<Longrightarrow> is_heap r1\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  is_heap l1\n  is_heap r1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "hence \"is_heap ?t\""], ["proof (prove)\nusing this:\n  is_heap l1\n  is_heap r1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 l1 r1))", "using 3(1)[of l1 r1 v2] False 3"], ["proof (prove)\nusing this:\n  is_heap l1\n  is_heap r1\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap l1; is_heap r1;\n   set_val (T v1 l1 r1) v2 = T v2 l1 r1\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n  \\<not> v1 \\<le> v2\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap ?l; is_heap ?r;\n   set_val (T v1 l1 r1) v2 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n  is_heap l\n  is_heap r\n  T v2 (T v1 l1 r1) E = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 l1 r1))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "proof (cases \"v' = v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v2 \\<Longrightarrow> is_heap (siftDown (T v2 (T v1 l1 r1) E))\n 2. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "case True"], ["proof (state)\nthis:\n  v' = v2\n\ngoal (2 subgoals):\n 1. v' = v2 \\<Longrightarrow> is_heap (siftDown (T v2 (T v1 l1 r1) E))\n 2. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' = v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "using False \\<open>is_heap ?t\\<close> *"], ["proof (prove)\nusing this:\n  v' = v2\n  \\<not> v1 \\<le> v2\n  is_heap (siftDown (T v2 l1 r1))\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> v2\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "have \"in_tree v' ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v2 l1 r1))", "using *"], ["proof (prove)\nusing this:\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v2 l1 r1))", "using siftDown_in_tree[of ?t]"], ["proof (prove)\nusing this:\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n  siftDown (T v2 l1 r1) \\<noteq> E \\<Longrightarrow>\n  in_tree (val (siftDown (siftDown (T v2 l1 r1)))) (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v2 l1 r1))", "by simp"], ["proof (state)\nthis:\n  in_tree v' (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "hence \"in_tree v' (T v2 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l1 r1)", "using siftDown_in_tree_set[symmetric, of v' \"T v2 l1 r1\"]"], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v2 l1 r1))\n  in_tree v' (siftDown (T v2 l1 r1)) = in_tree v' (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "hence \"in_tree v' (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l1 r1)", "using False"], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l1 r1)\n  v' \\<noteq> v2\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l1 r1)", "by simp"], ["proof (state)\nthis:\n  in_tree v' (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "hence \"v1 \\<ge> v'\""], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. v' \\<le> v1", "using 3"], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l1 r1)\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap ?l; is_heap ?r;\n   set_val (T v1 l1 r1) v2 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n  is_heap l\n  is_heap r\n  T v2 (T v1 l1 r1) E = T v l r\n\ngoal (1 subgoal):\n 1. v' \\<le> v1", "using is_heap_max[of v' \"T v1 l1 r1\"]"], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l1 r1)\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap ?l; is_heap ?r;\n   set_val (T v1 l1 r1) v2 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n  is_heap l\n  is_heap r\n  T v2 (T v1 l1 r1) E = T v l r\n  \\<lbrakk>in_tree v' (T v1 l1 r1); is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> v' \\<le> val (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. v' \\<le> v1", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v1\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 (T v1 l1 r1) E))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "using \\<open>is_heap ?t\\<close> * \\<open>\\<not> v2 \\<ge> v1\\<close>"], ["proof (prove)\nusing this:\n  v' \\<le> v1\n  is_heap (siftDown (T v2 l1 r1))\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 (T v1 l1 r1) E))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 (T v1 l1 r1) E))\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 2. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 3. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 2. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 3. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "case (4 v2 v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap ?l; is_heap ?r;\n   set_val (T v1 l1 r1) v2 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n  is_heap l\n  is_heap r\n  T v2 E (T v1 l1 r1) = T v l r\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd l r.\n       \\<lbrakk>\\<And>vd l r.\n                   \\<lbrakk>\\<not> val (T va vb vc) \\<le> v; is_heap l;\n                    is_heap r; set_val (T va vb vc) v = T vd l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r; T v E (T va vb vc) = T vd l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v E (T va vb vc)))\n 2. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 3. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "proof(cases \"v2 \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> is_heap (siftDown (T v2 E (T v1 l1 r1)))\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v2\n\ngoal (2 subgoals):\n 1. v1 \\<le> v2 \\<Longrightarrow> is_heap (siftDown (T v2 E (T v1 l1 r1)))\n 2. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "using 4(2-4)"], ["proof (prove)\nusing this:\n  v1 \\<le> v2\n  is_heap l\n  is_heap r\n  T v2 E (T v1 l1 r1) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "let ?t = \"siftDown (T v2 l1 r1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "obtain v' l' r' where *: \"?t = T v' l' r'\" \"v' \\<ge> v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v2 l1 r1) = T v' l' r'; v2 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using siftDown_Node[of \"T v2 l1 r1\" v2 l1 r1]"], ["proof (prove)\nusing this:\n  T v2 l1 r1 = T v2 l1 r1 \\<Longrightarrow>\n  \\<exists>l' v' r'. siftDown (T v2 l1 r1) = T v' l' r' \\<and> v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v2 l1 r1) = T v' l' r'; v2 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "have \"r = T v1 l1 r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = T v1 l1 r1", "using 4(4)"], ["proof (prove)\nusing this:\n  T v2 E (T v1 l1 r1) = T v l r\n\ngoal (1 subgoal):\n 1. r = T v1 l1 r1", "by auto"], ["proof (state)\nthis:\n  r = T v1 l1 r1\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "hence \"is_heap l1\" \"is_heap r1\""], ["proof (prove)\nusing this:\n  r = T v1 l1 r1\n\ngoal (1 subgoal):\n 1. is_heap l1 &&& is_heap r1", "using 4(3)"], ["proof (prove)\nusing this:\n  r = T v1 l1 r1\n  is_heap r\n\ngoal (1 subgoal):\n 1. is_heap l1 &&& is_heap r1", "apply (induct r rule:is_heap.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>E = T v1 l1 r1; is_heap E\\<rbrakk> \\<Longrightarrow> is_heap l1\n 2. \\<lbrakk>E = T v1 l1 r1; is_heap E\\<rbrakk> \\<Longrightarrow> is_heap r1\n 3. \\<And>v.\n       \\<lbrakk>T v E E = T v1 l1 r1; is_heap (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 4. \\<And>v.\n       \\<lbrakk>T v E E = T v1 l1 r1; is_heap (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r1\n 5. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v E (T va vb vc) = T v1 l1 r1;\n        is_heap (T v E (T va vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 6. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v E (T va vb vc) = T v1 l1 r1;\n        is_heap (T v E (T va vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap r1\n 7. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v (T va vb vc) E = T v1 l1 r1;\n        is_heap (T v (T va vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 8. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>T va vb vc = T v1 l1 r1;\n                 is_heap (T va vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v (T va vb vc) E = T v1 l1 r1;\n        is_heap (T v (T va vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r1\n 9. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>T vd ve vf = T v1 l1 r1;\n                 is_heap (T vd ve vf)\\<rbrakk>\n                \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T vd ve vf = T v1 l1 r1; is_heap (T vd ve vf)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap l1;\n        \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r1;\n        T v (T va vb vc) (T vd ve vf) = T v1 l1 r1;\n        is_heap (T v (T va vb vc) (T vd ve vf))\\<rbrakk>\n       \\<Longrightarrow> is_heap l1\n 10. \\<And>v va vb vc vd ve vf.\n        \\<lbrakk>\\<lbrakk>T vd ve vf = T v1 l1 r1;\n                  is_heap (T vd ve vf)\\<rbrakk>\n                 \\<Longrightarrow> is_heap l1;\n         \\<lbrakk>T vd ve vf = T v1 l1 r1; is_heap (T vd ve vf)\\<rbrakk>\n         \\<Longrightarrow> is_heap r1;\n         \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap l1;\n         \\<lbrakk>T va vb vc = T v1 l1 r1; is_heap (T va vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap r1;\n         T v (T va vb vc) (T vd ve vf) = T v1 l1 r1;\n         is_heap (T v (T va vb vc) (T vd ve vf))\\<rbrakk>\n        \\<Longrightarrow> is_heap r1\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  is_heap l1\n  is_heap r1\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "hence \"is_heap ?t\""], ["proof (prove)\nusing this:\n  is_heap l1\n  is_heap r1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 l1 r1))", "using False  4(1)[of l1 r1 v2]"], ["proof (prove)\nusing this:\n  is_heap l1\n  is_heap r1\n  \\<not> v1 \\<le> v2\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap l1; is_heap r1;\n   set_val (T v1 l1 r1) v2 = T v2 l1 r1\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 l1 r1))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. \\<not> v1 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "proof(cases \"v' = v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v2 \\<Longrightarrow> is_heap (siftDown (T v2 E (T v1 l1 r1)))\n 2. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "case True"], ["proof (state)\nthis:\n  v' = v2\n\ngoal (2 subgoals):\n 1. v' = v2 \\<Longrightarrow> is_heap (siftDown (T v2 E (T v1 l1 r1)))\n 2. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' = v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "using * \\<open>is_heap ?t\\<close> False"], ["proof (prove)\nusing this:\n  v' = v2\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n  is_heap (siftDown (T v2 l1 r1))\n  \\<not> v1 \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> v2\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "have \"in_tree v' ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v2 l1 r1))", "using *"], ["proof (prove)\nusing this:\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v2 l1 r1))", "using siftDown_in_tree[of ?t]"], ["proof (prove)\nusing this:\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n  siftDown (T v2 l1 r1) \\<noteq> E \\<Longrightarrow>\n  in_tree (val (siftDown (siftDown (T v2 l1 r1)))) (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v2 l1 r1))", "by auto"], ["proof (state)\nthis:\n  in_tree v' (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "hence \"in_tree v' (T v2 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l1 r1)", "using * siftDown_in_tree_set[of v' \"T v2 l1 r1\"]"], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v2 l1 r1))\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n  in_tree v' (T v2 l1 r1) = in_tree v' (siftDown (T v2 l1 r1))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "hence \"in_tree v' (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l1 r1)\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l1 r1)", "using False"], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l1 r1)\n  v' \\<noteq> v2\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "hence \"v1 \\<ge> v'\""], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. v' \\<le> v1", "using is_heap_max[of v' \"T v1 l1 r1\"] 4"], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l1 r1)\n  \\<lbrakk>in_tree v' (T v1 l1 r1); is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> v' \\<le> val (T v1 l1 r1)\n  \\<lbrakk>\\<not> val (T v1 l1 r1) \\<le> v2; is_heap ?l; is_heap ?r;\n   set_val (T v1 l1 r1) v2 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v1 l1 r1) v2))\n  is_heap l\n  is_heap r\n  T v2 E (T v1 l1 r1) = T v l r\n\ngoal (1 subgoal):\n 1. v' \\<le> v1", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v1\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v2 E (T v1 l1 r1)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "using \\<open>is_heap ?t\\<close> False *"], ["proof (prove)\nusing this:\n  v' \\<le> v1\n  is_heap (siftDown (T v2 l1 r1))\n  v' \\<noteq> v2\n  siftDown (T v2 l1 r1) = T v' l' r'\n  v2 \\<le> v'\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v2 E (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v2 E (T v1 l1 r1)))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 2. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 2. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "case (\"5_1\" v1 v2 l2 r2 v3 l3 r3)"], ["proof (state)\nthis:\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (2 subgoals):\n 1. \\<And>v va vb vc vd ve vf vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                    \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n                    set_val (T va vb vc) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T va vb vc) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n            \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n            set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T vd ve vf) v));\n        is_heap l; is_heap r;\n        T v (T va vb vc) (T vd ve vf) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T va vb vc) (T vd ve vf)))\n 2. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "proof(cases \"v2 \\<ge> v3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case True"], ["proof (state)\nthis:\n  v3 \\<le> v2\n\ngoal (2 subgoals):\n 1. v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "proof(cases \"v1 \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>v2 \\<ge> v3\\<close> \"5_1\""], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n  v3 \\<le> v2\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "let ?t = \"siftDown (T v1 l2 r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "obtain l' v' r' where *: \"?t = T v' l' r'\" \"v' \\<ge> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l2 r2) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using siftDown_Node"], ["proof (prove)\nusing this:\n  ?t = T ?v ?l ?r \\<Longrightarrow>\n  \\<exists>l' v' r'. siftDown ?t = T v' l' r' \\<and> ?v \\<le> v'\n\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l2 r2) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  siftDown (T v1 l2 r2) = T v' l' r'\n  v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"is_heap l2\" \"is_heap r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap l2 &&& is_heap r2", "using \"5_1\"(3, 5)"], ["proof (prove)\nusing this:\n  is_heap l\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap l2 &&& is_heap r2", "apply(induct l rule:is_heap.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v E r\\<rbrakk>\n    \\<Longrightarrow> is_heap l2\n 2. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v E r\\<rbrakk>\n    \\<Longrightarrow> is_heap r2\n 3. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T v E E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 4. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T v E E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap r2\n 5. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v E (T vaa vb vc)) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 6. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v E (T vaa vb vc)) r\\<rbrakk>\n       \\<Longrightarrow> is_heap r2\n 7. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v (T vaa vb vc) E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 8. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v (T vaa vb vc) E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap r2\n 9. \\<And>v vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vd ve vf) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vd ve vf);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vd ve vf) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v (T vaa vb vc) (T vd ve vf));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v (T vaa vb vc) (T vd ve vf)) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 10. \\<And>v vaa vb vc vd ve vf.\n        \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                  T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                  T v (T vd ve vf) r\\<rbrakk>\n                 \\<Longrightarrow> is_heap l2;\n         \\<lbrakk>is_heap (T vd ve vf);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vd ve vf) r\\<rbrakk>\n         \\<Longrightarrow> is_heap r2;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n         \\<Longrightarrow> is_heap l2;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n         \\<Longrightarrow> is_heap r2;\n         is_heap (T v (T vaa vb vc) (T vd ve vf));\n         T v1 (T v2 l2 r2) (T v3 l3 r3) =\n         T v (T v (T vaa vb vc) (T vd ve vf)) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  is_heap l2\n  is_heap r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "hence \"is_heap ?t\""], ["proof (prove)\nusing this:\n  is_heap l2\n  is_heap r2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l2 r2))", "using \"5_1\"(1)[of l2 r2 v1] \\<open>v2 \\<ge> v3\\<close> False"], ["proof (prove)\nusing this:\n  is_heap l2\n  is_heap r2\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap l2; is_heap r2;\n   set_val (T v2 l2 r2) v1 = T v1 l2 r2\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  v3 \\<le> v2\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l2 r2))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"v2 \\<ge> v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<le> v2", "proof(cases \"v' = v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v2\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "case True"], ["proof (state)\nthis:\n  v' = v1\n\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v2\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' = v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "using False"], ["proof (prove)\nusing this:\n  v' = v1\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v2\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "have \"in_tree v' ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l2 r2))", "using * siftDown_in_tree"], ["proof (prove)\nusing this:\n  siftDown (T v1 l2 r2) = T v' l' r'\n  v1 \\<le> v'\n  ?t \\<noteq> E \\<Longrightarrow> in_tree (val (siftDown ?t)) ?t\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v' (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "hence \"in_tree v' (T v1 l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l2 r2)", "using siftDown_in_tree_set[of v' \"T v1 l2 r2\"]"], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l2 r2))\n  in_tree v' (T v1 l2 r2) = in_tree v' (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v1 l2 r2)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "hence \"in_tree v' (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l2 r2)", "using False"], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l2 r2)\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "using is_heap_max[of v' \"T v2 l2 r2\"] \"5_1\""], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l2 r2)\n  \\<lbrakk>in_tree v' (T v2 l2 r2); is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> v' \\<le> val (T v2 l2 r2)\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>is_heap ?t\\<close> \\<open>v2 \\<ge> v3\\<close> * False \"5_1\""], ["proof (prove)\nusing this:\n  v' \\<le> v2\n  is_heap (siftDown (T v1 l2 r2))\n  v3 \\<le> v2\n  siftDown (T v1 l2 r2) = T v' l' r'\n  v1 \\<le> v'\n  \\<not> v2 \\<le> v1\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case False"], ["proof (state)\nthis:\n  \\<not> v3 \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "proof(cases \"v1 \\<ge> v3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case True"], ["proof (state)\nthis:\n  v3 \\<le> v1\n\ngoal (2 subgoals):\n 1. v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>\\<not> v2 \\<ge> v3\\<close> \"5_1\""], ["proof (prove)\nusing this:\n  v3 \\<le> v1\n  \\<not> v3 \\<le> v2\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case False"], ["proof (state)\nthis:\n  \\<not> v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "let ?t = \"siftDown (T v1 l3 r3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "obtain l' v' r' where *: \"?t = T v' l' r'\" \"v' \\<ge> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l3 r3) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using siftDown_Node"], ["proof (prove)\nusing this:\n  ?t = T ?v ?l ?r \\<Longrightarrow>\n  \\<exists>l' v' r'. siftDown ?t = T v' l' r' \\<and> ?v \\<le> v'\n\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l3 r3) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  siftDown (T v1 l3 r3) = T v' l' r'\n  v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"is_heap l3\" \"is_heap r3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap l3 &&& is_heap r3", "using \"5_1\"(4, 5)"], ["proof (prove)\nusing this:\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap l3 &&& is_heap r3", "apply(induct r rule:is_heap.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l E\\<rbrakk>\n    \\<Longrightarrow> is_heap l3\n 2. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l E\\<rbrakk>\n    \\<Longrightarrow> is_heap r3\n 3. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 4. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r3\n 5. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v E (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 6. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v E (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap r3\n 7. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v (T vaa vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 8. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v (T vaa vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r3\n 9. \\<And>v vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vd ve vf)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vd ve vf);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vd ve vf)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v (T vaa vb vc) (T vd ve vf));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v (T vaa vb vc) (T vd ve vf))\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 10. \\<And>v vaa vb vc vd ve vf.\n        \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                  T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                  T v l (T vd ve vf)\\<rbrakk>\n                 \\<Longrightarrow> is_heap l3;\n         \\<lbrakk>is_heap (T vd ve vf);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vd ve vf)\\<rbrakk>\n         \\<Longrightarrow> is_heap r3;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap l3;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap r3;\n         is_heap (T v (T vaa vb vc) (T vd ve vf));\n         T v1 (T v2 l2 r2) (T v3 l3 r3) =\n         T v l (T v (T vaa vb vc) (T vd ve vf))\\<rbrakk>\n        \\<Longrightarrow> is_heap r3\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  is_heap l3\n  is_heap r3\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "hence \"is_heap ?t\""], ["proof (prove)\nusing this:\n  is_heap l3\n  is_heap r3\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l3 r3))", "using \"5_1\"(2)[of l3 r3 v1] \\<open>\\<not> v2 \\<ge> v3\\<close> False"], ["proof (prove)\nusing this:\n  is_heap l3\n  is_heap r3\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap l3; is_heap r3;\n   set_val (T v3 l3 r3) v1 = T v1 l3 r3\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  \\<not> v3 \\<le> v2\n  \\<not> v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l3 r3))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"v3 \\<ge> v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<le> v3", "proof(cases \"v' = v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v3\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "case True"], ["proof (state)\nthis:\n  v' = v1\n\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v3\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' = v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "using False"], ["proof (prove)\nusing this:\n  v' = v1\n  \\<not> v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v3\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "have \"in_tree v' ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l3 r3))", "using * siftDown_in_tree"], ["proof (prove)\nusing this:\n  siftDown (T v1 l3 r3) = T v' l' r'\n  v1 \\<le> v'\n  ?t \\<noteq> E \\<Longrightarrow> in_tree (val (siftDown ?t)) ?t\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l3 r3))", "by auto"], ["proof (state)\nthis:\n  in_tree v' (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "hence \"in_tree v' (T v1 l3 r3)\""], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l3 r3)", "using siftDown_in_tree_set[of v' \"T v1 l3 r3\"]"], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l3 r3))\n  in_tree v' (T v1 l3 r3) = in_tree v' (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l3 r3)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v1 l3 r3)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "hence \"in_tree v' (T v3 l3 r3)\""], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l3 r3)\n\ngoal (1 subgoal):\n 1. in_tree v' (T v3 l3 r3)", "using False"], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l3 r3)\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. in_tree v' (T v3 l3 r3)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v3 l3 r3)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v' (T v3 l3 r3)\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "using is_heap_max[of v' \"T v3 l3 r3\"] \"5_1\""], ["proof (prove)\nusing this:\n  in_tree v' (T v3 l3 r3)\n  \\<lbrakk>in_tree v' (T v3 l3 r3); is_heap (T v3 l3 r3)\\<rbrakk>\n  \\<Longrightarrow> v' \\<le> val (T v3 l3 r3)\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<le> v3\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' \\<le> v3\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>is_heap ?t\\<close> \\<open>\\<not> v2 \\<ge> v3\\<close> * False \"5_1\""], ["proof (prove)\nusing this:\n  v' \\<le> v3\n  is_heap (siftDown (T v1 l3 r3))\n  \\<not> v3 \\<le> v2\n  siftDown (T v1 l3 r3) = T v' l' r'\n  v1 \\<le> v'\n  \\<not> v3 \\<le> v1\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal (1 subgoal):\n 1. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "case (\"5_2\" v1 v2 l2 r2 v3 l3 r3)"], ["proof (state)\nthis:\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. \\<And>v vd ve vf va vb vc vg l r.\n       \\<lbrakk>\\<And>vg l r.\n                   \\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                    \\<not> val (T vd ve vf) \\<le> v; is_heap l; is_heap r;\n                    set_val (T vd ve vf) v = T vg l r\\<rbrakk>\n                   \\<Longrightarrow> is_heap\n(siftDown (set_val (T vd ve vf) v));\n        \\<And>vg l r.\n           \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n            \\<not> val (T va vb vc) \\<le> v; is_heap l; is_heap r;\n            set_val (T va vb vc) v = T vg l r\\<rbrakk>\n           \\<Longrightarrow> is_heap (siftDown (set_val (T va vb vc) v));\n        is_heap l; is_heap r;\n        T v (T vd ve vf) (T va vb vc) = T vg l r\\<rbrakk>\n       \\<Longrightarrow> is_heap (siftDown (T v (T vd ve vf) (T va vb vc)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "proof(cases \"v2 \\<ge> v3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case True"], ["proof (state)\nthis:\n  v3 \\<le> v2\n\ngoal (2 subgoals):\n 1. v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "proof(cases \"v1 \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>v2 \\<ge> v3\\<close> \"5_2\""], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n  v3 \\<le> v2\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "let ?t = \"siftDown (T v1 l2 r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "obtain l' v' r' where *: \"?t = T v' l' r'\" \"v1 \\<le> v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l2 r2) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using siftDown_Node"], ["proof (prove)\nusing this:\n  ?t = T ?v ?l ?r \\<Longrightarrow>\n  \\<exists>l' v' r'. siftDown ?t = T v' l' r' \\<and> ?v \\<le> v'\n\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l2 r2) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  siftDown (T v1 l2 r2) = T v' l' r'\n  v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"is_heap l2\" \"is_heap r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap l2 &&& is_heap r2", "using \"5_2\"(3, 5)"], ["proof (prove)\nusing this:\n  is_heap l\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap l2 &&& is_heap r2", "apply(induct l rule:is_heap.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v E r\\<rbrakk>\n    \\<Longrightarrow> is_heap l2\n 2. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v E r\\<rbrakk>\n    \\<Longrightarrow> is_heap r2\n 3. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T v E E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 4. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T v E E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap r2\n 5. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v E (T vaa vb vc)) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 6. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v E (T vaa vb vc)) r\\<rbrakk>\n       \\<Longrightarrow> is_heap r2\n 7. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v (T vaa vb vc) E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 8. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vaa vb vc) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v (T vaa vb vc) E) r\\<rbrakk>\n       \\<Longrightarrow> is_heap r2\n 9. \\<And>v vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v (T vd ve vf) r\\<rbrakk>\n                \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vd ve vf);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vd ve vf) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap l2;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2;\n        is_heap (T v (T vaa vb vc) (T vd ve vf));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v (T v (T vaa vb vc) (T vd ve vf)) r\\<rbrakk>\n       \\<Longrightarrow> is_heap l2\n 10. \\<And>v vaa vb vc vd ve vf.\n        \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                  T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                  T v (T vd ve vf) r\\<rbrakk>\n                 \\<Longrightarrow> is_heap l2;\n         \\<lbrakk>is_heap (T vd ve vf);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vd ve vf) r\\<rbrakk>\n         \\<Longrightarrow> is_heap r2;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n         \\<Longrightarrow> is_heap l2;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v (T vaa vb vc) r\\<rbrakk>\n         \\<Longrightarrow> is_heap r2;\n         is_heap (T v (T vaa vb vc) (T vd ve vf));\n         T v1 (T v2 l2 r2) (T v3 l3 r3) =\n         T v (T v (T vaa vb vc) (T vd ve vf)) r\\<rbrakk>\n        \\<Longrightarrow> is_heap r2\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  is_heap l2\n  is_heap r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "hence \"is_heap ?t\""], ["proof (prove)\nusing this:\n  is_heap l2\n  is_heap r2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l2 r2))", "using \"5_2\"(1)[of l2 r2 v1] \\<open>v2 \\<ge> v3\\<close> False"], ["proof (prove)\nusing this:\n  is_heap l2\n  is_heap r2\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap l2; is_heap r2;\n   set_val (T v2 l2 r2) v1 = T v1 l2 r2\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  v3 \\<le> v2\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l2 r2))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"v2 \\<ge> v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<le> v2", "proof(cases \"v' = v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v2\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "case True"], ["proof (state)\nthis:\n  v' = v1\n\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v2\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' = v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "using False"], ["proof (prove)\nusing this:\n  v' = v1\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v2\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "have \"in_tree v' ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l2 r2))", "using * siftDown_in_tree"], ["proof (prove)\nusing this:\n  siftDown (T v1 l2 r2) = T v' l' r'\n  v1 \\<le> v'\n  ?t \\<noteq> E \\<Longrightarrow> in_tree (val (siftDown ?t)) ?t\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l2 r2))", "by auto"], ["proof (state)\nthis:\n  in_tree v' (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "hence \"in_tree v' (T v1 l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l2 r2)", "using siftDown_in_tree_set[of v' \"T v1 l2 r2\"]"], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l2 r2))\n  in_tree v' (T v1 l2 r2) = in_tree v' (siftDown (T v1 l2 r2))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v1 l2 r2)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "hence \"in_tree v' (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l2 r2)\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l2 r2)", "using False"], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l2 r2)\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. in_tree v' (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v2", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "using is_heap_max[of v' \"T v2 l2 r2\"] \"5_2\""], ["proof (prove)\nusing this:\n  in_tree v' (T v2 l2 r2)\n  \\<lbrakk>in_tree v' (T v2 l2 r2); is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> v' \\<le> val (T v2 l2 r2)\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. v' \\<le> v2", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>is_heap ?t\\<close> \\<open>v2 \\<ge> v3\\<close> * False \"5_2\""], ["proof (prove)\nusing this:\n  v' \\<le> v2\n  is_heap (siftDown (T v1 l2 r2))\n  v3 \\<le> v2\n  siftDown (T v1 l2 r2) = T v' l' r'\n  v1 \\<le> v'\n  \\<not> v2 \\<le> v1\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case False"], ["proof (state)\nthis:\n  \\<not> v3 \\<le> v2\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v2 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "proof(cases \"v1 \\<ge> v3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case True"], ["proof (state)\nthis:\n  v3 \\<le> v1\n\ngoal (2 subgoals):\n 1. v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n 2. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>\\<not> v2 \\<ge> v3\\<close> \"5_2\""], ["proof (prove)\nusing this:\n  v3 \\<le> v1\n  \\<not> v3 \\<le> v2\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "case False"], ["proof (state)\nthis:\n  \\<not> v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "let ?t = \"siftDown (T v1 l3 r3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "obtain l' v' r' where *: \"?t = T v' l' r'\" \"v' \\<ge> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l3 r3) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using siftDown_Node"], ["proof (prove)\nusing this:\n  ?t = T ?v ?l ?r \\<Longrightarrow>\n  \\<exists>l' v' r'. siftDown ?t = T v' l' r' \\<and> ?v \\<le> v'\n\ngoal (1 subgoal):\n 1. (\\<And>v' l' r'.\n        \\<lbrakk>siftDown (T v1 l3 r3) = T v' l' r'; v1 \\<le> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  siftDown (T v1 l3 r3) = T v' l' r'\n  v1 \\<le> v'\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"is_heap l3\" \"is_heap r3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap l3 &&& is_heap r3", "using \"5_2\"(4, 5)"], ["proof (prove)\nusing this:\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap l3 &&& is_heap r3", "apply(induct r rule:is_heap.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l E\\<rbrakk>\n    \\<Longrightarrow> is_heap l3\n 2. \\<lbrakk>is_heap E; T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l E\\<rbrakk>\n    \\<Longrightarrow> is_heap r3\n 3. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 4. \\<And>v.\n       \\<lbrakk>is_heap (T v E E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T v E E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r3\n 5. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v E (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 6. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v E (T vaa vb vc));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v E (T vaa vb vc))\\<rbrakk>\n       \\<Longrightarrow> is_heap r3\n 7. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v (T vaa vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 8. \\<And>v vaa vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vaa vb vc);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vaa vb vc)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v (T vaa vb vc) E);\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v (T vaa vb vc) E)\\<rbrakk>\n       \\<Longrightarrow> is_heap r3\n 9. \\<And>v vaa vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                 T v l (T vd ve vf)\\<rbrakk>\n                \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vd ve vf);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vd ve vf)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap l3;\n        \\<lbrakk>is_heap (T vaa vb vc);\n         T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n        \\<Longrightarrow> is_heap r3;\n        is_heap (T v (T vaa vb vc) (T vd ve vf));\n        T v1 (T v2 l2 r2) (T v3 l3 r3) =\n        T v l (T v (T vaa vb vc) (T vd ve vf))\\<rbrakk>\n       \\<Longrightarrow> is_heap l3\n 10. \\<And>v vaa vb vc vd ve vf.\n        \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                  T v1 (T v2 l2 r2) (T v3 l3 r3) =\n                  T v l (T vd ve vf)\\<rbrakk>\n                 \\<Longrightarrow> is_heap l3;\n         \\<lbrakk>is_heap (T vd ve vf);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vd ve vf)\\<rbrakk>\n         \\<Longrightarrow> is_heap r3;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap l3;\n         \\<lbrakk>is_heap (T vaa vb vc);\n          T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l (T vaa vb vc)\\<rbrakk>\n         \\<Longrightarrow> is_heap r3;\n         is_heap (T v (T vaa vb vc) (T vd ve vf));\n         T v1 (T v2 l2 r2) (T v3 l3 r3) =\n         T v l (T v (T vaa vb vc) (T vd ve vf))\\<rbrakk>\n        \\<Longrightarrow> is_heap r3\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  is_heap l3\n  is_heap r3\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "hence \"is_heap ?t\""], ["proof (prove)\nusing this:\n  is_heap l3\n  is_heap r3\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l3 r3))", "using \"5_2\"(2)[of l3 r3 v1] \\<open>\\<not> v2 \\<ge> v3\\<close> False"], ["proof (prove)\nusing this:\n  is_heap l3\n  is_heap r3\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap l3; is_heap r3;\n   set_val (T v3 l3 r3) v1 = T v1 l3 r3\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  \\<not> v3 \\<le> v2\n  \\<not> v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 l3 r3))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "have \"v3 \\<ge> v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<le> v3", "proof(cases \"v' = v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v3\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "case True"], ["proof (state)\nthis:\n  v' = v1\n\ngoal (2 subgoals):\n 1. v' = v1 \\<Longrightarrow> v' \\<le> v3\n 2. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' = v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "using False"], ["proof (prove)\nusing this:\n  v' = v1\n  \\<not> v3 \\<le> v1\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v3\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "case False"], ["proof (state)\nthis:\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "have \"in_tree v' ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l3 r3))", "using * siftDown_in_tree"], ["proof (prove)\nusing this:\n  siftDown (T v1 l3 r3) = T v' l' r'\n  v1 \\<le> v'\n  ?t \\<noteq> E \\<Longrightarrow> in_tree (val (siftDown ?t)) ?t\n\ngoal (1 subgoal):\n 1. in_tree v' (siftDown (T v1 l3 r3))", "by auto"], ["proof (state)\nthis:\n  in_tree v' (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "hence \"in_tree v' (T v1 l3 r3)\""], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l3 r3)", "using siftDown_in_tree_set[of v' \"T v1 l3 r3\"]"], ["proof (prove)\nusing this:\n  in_tree v' (siftDown (T v1 l3 r3))\n  in_tree v' (T v1 l3 r3) = in_tree v' (siftDown (T v1 l3 r3))\n\ngoal (1 subgoal):\n 1. in_tree v' (T v1 l3 r3)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v1 l3 r3)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "hence \"in_tree v' (T v3 l3 r3)\""], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l3 r3)\n\ngoal (1 subgoal):\n 1. in_tree v' (T v3 l3 r3)", "using False"], ["proof (prove)\nusing this:\n  in_tree v' (T v1 l3 r3)\n  v' \\<noteq> v1\n\ngoal (1 subgoal):\n 1. in_tree v' (T v3 l3 r3)", "by auto"], ["proof (state)\nthis:\n  in_tree v' (T v3 l3 r3)\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v1 \\<Longrightarrow> v' \\<le> v3", "thus ?thesis"], ["proof (prove)\nusing this:\n  in_tree v' (T v3 l3 r3)\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "using is_heap_max[of v' \"T v3 l3 r3\"] \"5_2\""], ["proof (prove)\nusing this:\n  in_tree v' (T v3 l3 r3)\n  \\<lbrakk>in_tree v' (T v3 l3 r3); is_heap (T v3 l3 r3)\\<rbrakk>\n  \\<Longrightarrow> v' \\<le> val (T v3 l3 r3)\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. v' \\<le> v3", "by auto"], ["proof (state)\nthis:\n  v' \\<le> v3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<le> v3\n\ngoal (1 subgoal):\n 1. \\<not> v3 \\<le> v1 \\<Longrightarrow>\n    is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v' \\<le> v3\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "using \\<open>is_heap ?t\\<close> \\<open>\\<not> v2 \\<ge> v3\\<close> * False \"5_2\""], ["proof (prove)\nusing this:\n  v' \\<le> v3\n  is_heap (siftDown (T v1 l3 r3))\n  \\<not> v3 \\<le> v2\n  siftDown (T v1 l3 r3) = T v' l' r'\n  v1 \\<le> v'\n  \\<not> v3 \\<le> v1\n  \\<lbrakk>val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v2 l2 r2) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v2 l2 r2) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v2 l2 r2) v1))\n  \\<lbrakk>\\<not> val (T v3 l3 r3) \\<le> val (T v2 l2 r2);\n   \\<not> val (T v3 l3 r3) \\<le> v1; is_heap ?l; is_heap ?r;\n   set_val (T v3 l3 r3) v1 = T ?v ?l ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (set_val (T v3 l3 r3) v1))\n  is_heap l\n  is_heap r\n  T v1 (T v2 l2 r2) (T v3 l3 r3) = T v l r\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (siftDown (T v1 (T v2 l2 r2) (T v3 l3 r3)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Definition of the function {\\em heapify} which\nmakes a heap from any given binary tree.\\<close>"], ["", "primrec heapify where\n   \"heapify E = E\"\n|  \"heapify (T v l r) = siftDown (T v (heapify l) (heapify r))\""], ["", "lemma heapify_heap_is_heap:\n  \"is_heap (heapify t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (heapify t)", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_heap (heapify E)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>is_heap (heapify t1); is_heap (heapify t2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (heapify (T x1 t1 t2))", "case E"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. is_heap (heapify E)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>is_heap (heapify t1); is_heap (heapify t2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (heapify (T x1 t1 t2))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (heapify E)", "by auto"], ["proof (state)\nthis:\n  is_heap (heapify E)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>is_heap (heapify t1); is_heap (heapify t2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (heapify (T x1 t1 t2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>is_heap (heapify t1); is_heap (heapify t2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (heapify (T x1 t1 t2))", "case (T v l r)"], ["proof (state)\nthis:\n  is_heap (heapify l)\n  is_heap (heapify r)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>is_heap (heapify t1); is_heap (heapify t2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (heapify (T x1 t1 t2))", "thus ?case"], ["proof (prove)\nusing this:\n  is_heap (heapify l)\n  is_heap (heapify r)\n\ngoal (1 subgoal):\n 1. is_heap (heapify (T v l r))", "using siftDown_heap_is_heap[of \"heapify l\" \"heapify r\" \"T v (heapify l) (heapify r)\" v]"], ["proof (prove)\nusing this:\n  is_heap (heapify l)\n  is_heap (heapify r)\n  \\<lbrakk>is_heap (heapify l); is_heap (heapify r);\n   T v (heapify l) (heapify r) = T v (heapify l) (heapify r)\\<rbrakk>\n  \\<Longrightarrow> is_heap (siftDown (T v (heapify l) (heapify r)))\n\ngoal (1 subgoal):\n 1. is_heap (heapify (T v l r))", "by auto"], ["proof (state)\nthis:\n  is_heap (heapify (T v l r))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Definition of {\\em removeLeaf} function.  Function returns two values. The first one\nis the value of romoved leaf element. The second returned value is tree without that leaf.\\<close>"], ["", "fun removeLeaf:: \"'a::linorder Tree \\<Rightarrow> 'a \\<times> 'a Tree\" where\n  \"removeLeaf (T v E E) = (v, E)\"\n| \"removeLeaf (T v l E) = (fst (removeLeaf l), T v (snd (removeLeaf l)) E)\"\n| \"removeLeaf (T v E r) = (fst (removeLeaf r), T v E (snd (removeLeaf r)))\"\n| \"removeLeaf (T v l r) = (fst (removeLeaf l), T v (snd (removeLeaf l)) r)\""], ["", "text\\<open>Function {\\em of\\_list\\_tree} makes a binary tree from any given\nlist.\\<close>"], ["", "primrec of_list_tree:: \"'a::linorder list \\<Rightarrow> 'a Tree\" where\n  \"of_list_tree [] = E\"\n| \"of_list_tree (v # tail) = T v (of_list_tree tail) E\""], ["", "text\\<open>By applying {\\em heapify} binary tree is transformed into\nheap.\\<close>"], ["", "definition hs_of_list where\n  \"hs_of_list l = heapify (of_list_tree l)\""], ["", "text\\<open>Definition of function {\\em hs\\_remove\\_max}. As it is already well\nestablished, finding maximum is not a problem, since it is in the root\nelement of the heap. The root element is replaced with leaf of the\nheap and that leaf is erased from its previous position. However, now\nthe new root element may not satisfy heap property and that is the\nreason to apply function {\\em siftDown}.\\<close>"], ["", "definition hs_remove_max :: \"'a::linorder Tree \\<Rightarrow> 'a \\<times> 'a Tree\" where\n  \"hs_remove_max t \\<equiv>\n     (let v' = fst (removeLeaf t);\n          t' = snd (removeLeaf t) in\n     (if t' = E then (val t, E)\n      else (val t, siftDown (set_val t' v'))))\""], ["", "definition hs_is_empty where\n[simp]: \"hs_is_empty t \\<longleftrightarrow>  t = E\""], ["", "lemma siftDown_multiset:\n  \"multiset (siftDown t) = multiset t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown t) = Heap.multiset t", "proof(induct t rule:siftDown.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. Heap.multiset (siftDown E) = Heap.multiset E\n 2. \\<And>v. Heap.multiset (siftDown (T v E E)) = Heap.multiset (T v E E)\n 3. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 4. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 5. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 6. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. Heap.multiset (siftDown E) = Heap.multiset E\n 2. \\<And>v. Heap.multiset (siftDown (T v E E)) = Heap.multiset (T v E E)\n 3. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 4. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 5. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 6. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown E) = Heap.multiset E", "by simp"], ["proof (state)\nthis:\n  Heap.multiset (siftDown E) = Heap.multiset E\n\ngoal (5 subgoals):\n 1. \\<And>v. Heap.multiset (siftDown (T v E E)) = Heap.multiset (T v E E)\n 2. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 3. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v. Heap.multiset (siftDown (T v E E)) = Heap.multiset (T v E E)\n 2. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 3. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "case (2 v)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>v. Heap.multiset (siftDown (T v E E)) = Heap.multiset (T v E E)\n 2. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 3. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v E E)) = Heap.multiset (T v E E)", "by simp"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v E E)) = Heap.multiset (T v E E)\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "case (3 v1 v l r)"], ["proof (state)\nthis:\n  \\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n  Heap.multiset (siftDown (set_val (T v l r) v1)) =\n  Heap.multiset (set_val (T v l r) v1)\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v (T va vb vc) E)) =\n       Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n  Heap.multiset (siftDown (set_val (T v l r) v1)) =\n  Heap.multiset (set_val (T v l r) v1)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 (T v l r) E)) =\n    Heap.multiset (T v1 (T v l r) E)", "proof(cases \"v \\<le> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)\n 2. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "case True"], ["proof (state)\nthis:\n  v \\<le> v1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)\n 2. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 (T v l r) E)) =\n    Heap.multiset (T v1 (T v l r) E)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 (T v l r) E)) =\n  Heap.multiset (T v1 (T v l r) E)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "case False"], ["proof (state)\nthis:\n  \\<not> v \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "hence \"multiset (siftDown (T v1 (T v l r) E)) = \n           multiset l + {#v1#} + multiset r + {#v#}\""], ["proof (prove)\nusing this:\n  \\<not> v \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 (T v l r) E)) =\n    Heap.multiset l + {#v1#} + Heap.multiset r + {#v#}", "using 3"], ["proof (prove)\nusing this:\n  \\<not> v \\<le> v1\n  \\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n  Heap.multiset (siftDown (set_val (T v l r) v1)) =\n  Heap.multiset (set_val (T v l r) v1)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 (T v l r) E)) =\n    Heap.multiset l + {#v1#} + Heap.multiset r + {#v#}", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 (T v l r) E)) =\n  Heap.multiset l + {#v1#} + Heap.multiset r + {#v#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 (T v l r) E)) =\n  Heap.multiset l + {#v1#} + Heap.multiset r + {#v#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "have \"multiset (T v1 (T v l r) E) = \n          multiset l + {#v#} + multiset r + {#v1#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v1 (T v l r) E) =\n    Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (T v1 (T v l r) E) =\n  Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (T v1 (T v l r) E) =\n  Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "have \"multiset l + {#v1#} + multiset r + {#v#} = \n          multiset l + {#v#} + multiset r + {#v1#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset l + {#v1#} + Heap.multiset r + {#v#} =\n    Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset l + {#v1#} + Heap.multiset r + {#v#} =\n  Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 (T v l r) E)) =\n                      Heap.multiset (T v1 (T v l r) E)", "ultimately"], ["proof (chain)\npicking this:\n  Heap.multiset (siftDown (T v1 (T v l r) E)) =\n  Heap.multiset l + {#v1#} + Heap.multiset r + {#v#}\n  Heap.multiset (T v1 (T v l r) E) =\n  Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}\n  Heap.multiset l + {#v1#} + Heap.multiset r + {#v#} =\n  Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}", "show ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v1 (T v l r) E)) =\n  Heap.multiset l + {#v1#} + Heap.multiset r + {#v#}\n  Heap.multiset (T v1 (T v l r) E) =\n  Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}\n  Heap.multiset l + {#v1#} + Heap.multiset r + {#v#} =\n  Heap.multiset l + {#v#} + Heap.multiset r + {#v1#}\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 (T v l r) E)) =\n    Heap.multiset (T v1 (T v l r) E)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 (T v l r) E)) =\n  Heap.multiset (T v1 (T v l r) E)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 (T v l r) E)) =\n  Heap.multiset (T v1 (T v l r) E)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "case (4 v1 v l r)"], ["proof (state)\nthis:\n  \\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n  Heap.multiset (siftDown (set_val (T v l r) v1)) =\n  Heap.multiset (set_val (T v l r) v1)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc.\n       (\\<not> val (T va vb vc) \\<le> v \\<Longrightarrow>\n        Heap.multiset (siftDown (set_val (T va vb vc) v)) =\n        Heap.multiset (set_val (T va vb vc) v)) \\<Longrightarrow>\n       Heap.multiset (siftDown (T v E (T va vb vc))) =\n       Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n  Heap.multiset (siftDown (set_val (T v l r) v1)) =\n  Heap.multiset (set_val (T v l r) v1)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 E (T v l r))) =\n    Heap.multiset (T v1 E (T v l r))", "proof(cases \"v \\<le> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))\n 2. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "case True"], ["proof (state)\nthis:\n  v \\<le> v1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))\n 2. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 E (T v l r))) =\n    Heap.multiset (T v1 E (T v l r))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  Heap.multiset (T v1 E (T v l r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "case False"], ["proof (state)\nthis:\n  \\<not> v \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "have \"multiset (set_val (T v l r) v1) = \n          multiset l + {#v1#} + multiset r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (set_val (T v l r) v1) =\n    Heap.multiset l + {#v1#} + Heap.multiset r", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (set_val (T v l r) v1) =\n  Heap.multiset l + {#v1#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "hence \"multiset (siftDown (T v1 E (T v l r))) = \n           {#v#} +  multiset (set_val (T v l r) v1)\""], ["proof (prove)\nusing this:\n  Heap.multiset (set_val (T v l r) v1) =\n  Heap.multiset l + {#v1#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 E (T v l r))) =\n    {#v#} + Heap.multiset (set_val (T v l r) v1)", "using 4 False"], ["proof (prove)\nusing this:\n  Heap.multiset (set_val (T v l r) v1) =\n  Heap.multiset l + {#v1#} + Heap.multiset r\n  \\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n  Heap.multiset (siftDown (set_val (T v l r) v1)) =\n  Heap.multiset (set_val (T v l r) v1)\n  \\<not> v \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 E (T v l r))) =\n    {#v#} + Heap.multiset (set_val (T v l r) v1)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  {#v#} + Heap.multiset (set_val (T v l r) v1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "hence \"multiset (siftDown (T v1 E (T v l r))) = \n           {#v#} + multiset l + {#v1#} + multiset r\""], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  {#v#} + Heap.multiset (set_val (T v l r) v1)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 E (T v l r))) =\n    {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r", "using \\<open>multiset (set_val (T v l r) v1) = \n             multiset l + {#v1#} + multiset r\\<close>"], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  {#v#} + Heap.multiset (set_val (T v l r) v1)\n  Heap.multiset (set_val (T v l r) v1) =\n  Heap.multiset l + {#v1#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 E (T v l r))) =\n    {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "have \"multiset (T v1 E (T v l r)) =  \n          {#v1#} + multiset l + {#v#} + multiset r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v1 E (T v l r)) =\n    {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r", "by (metis calculation monoid_add_class.add.left_neutral \n          multiset.simps(1) multiset.simps(2) union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset (T v1 E (T v l r)) =\n  {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (T v1 E (T v l r)) =\n  {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "have \"{#v#} + multiset l + {#v1#} + multiset r = \n          {#v1#} + multiset l + {#v#} + multiset r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r =\n    {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r =\n  {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> val (T v l r) \\<le> v1 \\<Longrightarrow>\n             Heap.multiset (siftDown (set_val (T v l r) v1)) =\n             Heap.multiset (set_val (T v l r) v1);\n     \\<not> v \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (siftDown (T v1 E (T v l r))) =\n                      Heap.multiset (T v1 E (T v l r))", "ultimately"], ["proof (chain)\npicking this:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r\n  Heap.multiset (T v1 E (T v l r)) =\n  {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r\n  {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r =\n  {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r", "show ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r\n  Heap.multiset (T v1 E (T v l r)) =\n  {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r\n  {#v#} + Heap.multiset l + {#v1#} + Heap.multiset r =\n  {#v1#} + Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v1 E (T v l r))) =\n    Heap.multiset (T v1 E (T v l r))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  Heap.multiset (T v1 E (T v l r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v1 E (T v l r))) =\n  Heap.multiset (T v1 E (T v l r))\n\ngoal (2 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "case (\"5_1\" v v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v1 l1 r1) v)) =\n                    Heap.multiset (set_val (T v1 l1 r1) v)\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                    Heap.multiset (set_val (T v2 l2 r2) v)\n\ngoal (2 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>val (T vd ve vf) \\<le> val (T va vb vc);\n                 \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T va vb vc) v)) =\n                                  Heap.multiset (set_val (T va vb vc) v);\n        \\<lbrakk>\\<not> val (T vd ve vf) \\<le> val (T va vb vc);\n         \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T vd ve vf) v)) =\n                          Heap.multiset (set_val (T vd ve vf) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T va vb vc) (T vd ve vf))) =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v1 l1 r1) v)) =\n                    Heap.multiset (set_val (T v1 l1 r1) v)\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                    Heap.multiset (set_val (T v2 l2 r2) v)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v1 \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1; v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1; v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>v1 \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) = \n             multiset l1 + {#v#} + multiset r1 + {#v1#} + \n             multiset (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  \\<not> v1 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n    Heap.multiset (T v2 l2 r2)", "using \\<open>v1 \\<ge> v2\\<close> \"5_1\"(1)"], ["proof (prove)\nusing this:\n  \\<not> v1 \\<le> v\n  v2 \\<le> v1\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v1 l1 r1) v)) =\n                    Heap.multiset (set_val (T v1 l1 r1) v)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n    Heap.multiset (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \"multiset (T v (T v1 l1 r1) (T v2 l2 r2)) = \n              multiset l1 + {#v1#} + multiset r1 + {#v#} +\n              multiset(T v2 l2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n    Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n    Heap.multiset (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \"multiset l1 + {#v1#} + multiset r1 + {#v#} + \n            multiset(T v2 l2 r2) = \n                multiset l1 + {#v#} + multiset r1 + {#v1#} + \n                multiset (T v2 l2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n    Heap.multiset (T v2 l2 r2) =\n    Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n    Heap.multiset (T v2 l2 r2)", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "ultimately"], ["proof (chain)\npicking this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v\n\ngoal (2 subgoals):\n 1. v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "using False"], ["proof (prove)\nusing this:\n  v2 \\<le> v\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) = \n             multiset (T v1 l1 r1) + {#v2#} + \n             multiset l2 + {#v#} + multiset r2\""], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n    Heap.multiset r2", "using \\<open>\\<not> v1 \\<ge> v2\\<close> \"5_1\"(2)"], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v\n  \\<not> v2 \\<le> v1\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                    Heap.multiset (set_val (T v2 l2 r2) v)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n    Heap.multiset r2", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \n        \"multiset (T v (T v1 l1 r1) (T v2 l2 r2)) = \n         multiset (T v1 l1 r1) + {#v#} + multiset l2 + \n         {#v2#} + multiset r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n    Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n    Heap.multiset r2", "by simp"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \n        \"multiset (T v1 l1 r1) + {#v#} + multiset l2 + {#v2#} + \n         multiset r2 = \n            multiset (T v1 l1 r1) + {#v2#} + multiset l2 + \n            {#v#} + multiset r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n    Heap.multiset r2 =\n    Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n    Heap.multiset r2", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2 =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "ultimately"], ["proof (chain)\npicking this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2 =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2", "show ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2 =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "case (\"5_2\" v v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v1 l1 r1) v)) =\n                    Heap.multiset (set_val (T v1 l1 r1) v)\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                    Heap.multiset (set_val (T v2 l2 r2) v)\n\ngoal (1 subgoal):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>val (T va vb vc) \\<le> val (T vd ve vf);\n                 \\<not> val (T vd ve vf) \\<le> v\\<rbrakk>\n                \\<Longrightarrow> Heap.multiset\n                                   (siftDown (set_val (T vd ve vf) v)) =\n                                  Heap.multiset (set_val (T vd ve vf) v);\n        \\<lbrakk>\\<not> val (T va vb vc) \\<le> val (T vd ve vf);\n         \\<not> val (T va vb vc) \\<le> v\\<rbrakk>\n        \\<Longrightarrow> Heap.multiset\n                           (siftDown (set_val (T va vb vc) v)) =\n                          Heap.multiset (set_val (T va vb vc) v)\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset\n                          (siftDown (T v (T vd ve vf) (T va vb vc))) =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v1 l1 r1) v)) =\n                    Heap.multiset (set_val (T v1 l1 r1) v)\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                    Heap.multiset (set_val (T v2 l2 r2) v)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v1 \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v \\<ge> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1; v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v1 \\<le> v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1; v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>v1 \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v1 \\<le> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) = \n               multiset l1 + {#v#} + multiset r1 + {#v1#} + \n               multiset (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  \\<not> v1 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n    Heap.multiset (T v2 l2 r2)", "using \\<open>v1 \\<ge> v2\\<close> \"5_2\"(1)"], ["proof (prove)\nusing this:\n  \\<not> v1 \\<le> v\n  v2 \\<le> v1\n  \\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v1 l1 r1) v)) =\n                    Heap.multiset (set_val (T v1 l1 r1) v)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n    Heap.multiset (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \"multiset (T v (T v1 l1 r1) (T v2 l2 r2)) = \n              multiset l1 + {#v1#} + multiset r1 + \n              {#v#} + multiset(T v2 l2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n    Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n    Heap.multiset (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \"multiset l1 + {#v1#} + multiset r1 + {#v#} + \n            multiset(T v2 l2 r2) = \n              multiset l1 + {#v#} + multiset r1 + {#v1#} + \n              multiset (T v2 l2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n    Heap.multiset (T v2 l2 r2) =\n    Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n    Heap.multiset (T v2 l2 r2)", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1; \\<not> v1 \\<le> v\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "ultimately"], ["proof (chain)\npicking this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2)\n  Heap.multiset l1 + {#v1#} + Heap.multiset r1 + {#v#} +\n  Heap.multiset (T v2 l2 r2) =\n  Heap.multiset l1 + {#v#} + Heap.multiset r1 + {#v1#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n              \\<not> val (T v1 l1 r1) \\<le> v\\<rbrakk>\n             \\<Longrightarrow> Heap.multiset\n                                (siftDown (set_val (T v1 l1 r1) v)) =\n                               Heap.multiset (set_val (T v1 l1 r1) v);\n     \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n      \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n     \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                       Heap.multiset (set_val (T v2 l2 r2) v);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset\n                       (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n                      Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v \\<ge> v2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v\n\ngoal (2 subgoals):\n 1. v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "using False"], ["proof (prove)\nusing this:\n  v2 \\<le> v\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) = \n               multiset (T v1 l1 r1) + {#v2#} + multiset l2 + {#v#} + \n               multiset r2\""], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n    Heap.multiset r2", "using \\<open>\\<not> v1 \\<ge> v2\\<close> \"5_2\"(2)"], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v\n  \\<not> v2 \\<le> v1\n  \\<lbrakk>\\<not> val (T v2 l2 r2) \\<le> val (T v1 l1 r1);\n   \\<not> val (T v2 l2 r2) \\<le> v\\<rbrakk>\n  \\<Longrightarrow> Heap.multiset (siftDown (set_val (T v2 l2 r2) v)) =\n                    Heap.multiset (set_val (T v2 l2 r2) v)\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n    Heap.multiset r2", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \"multiset (T v (T v1 l1 r1) (T v2 l2 r2)) = \n              multiset (T v1 l1 r1) + {#v#} + multiset l2 + {#v2#} + \n              multiset r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n    Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n    Heap.multiset r2", "by simp"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "moreover"], ["proof (state)\nthis:\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "have \"multiset (T v1 l1 r1) + {#v#} + multiset l2 + {#v2#} + \n            multiset r2 = \n              multiset (T v1 l1 r1) + {#v2#} + multiset l2 + {#v#} + \n              multiset r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n    Heap.multiset r2 =\n    Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n    Heap.multiset r2", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2 =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<not> v2 \\<le> v \\<Longrightarrow>\n    Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "ultimately"], ["proof (chain)\npicking this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2 =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2", "show ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2)) =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset l2 + {#v2#} +\n  Heap.multiset r2 =\n  Heap.multiset (T v1 l1 r1) + {#v2#} + Heap.multiset l2 + {#v#} +\n  Heap.multiset r2\n\ngoal (1 subgoal):\n 1. Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (siftDown (T v (T v1 l1 r1) (T v2 l2 r2))) =\n  Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_list_tree:\n \"multiset (of_list_tree l) = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (of_list_tree l) = mset l", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. Heap.multiset (of_list_tree []) = mset []\n 2. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Heap.multiset (of_list_tree []) = mset []\n 2. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (of_list_tree []) = mset []", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (of_list_tree []) = mset []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "case (Cons v tail)"], ["proof (state)\nthis:\n  Heap.multiset (of_list_tree tail) = mset tail\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "hence \"multiset (of_list_tree (v # tail)) = mset tail + {#v#}\""], ["proof (prove)\nusing this:\n  Heap.multiset (of_list_tree tail) = mset tail\n\ngoal (1 subgoal):\n 1. Heap.multiset (of_list_tree (v # tail)) = mset tail + {#v#}", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (of_list_tree (v # tail)) = mset tail + {#v#}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "also"], ["proof (state)\nthis:\n  Heap.multiset (of_list_tree (v # tail)) = mset tail + {#v#}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "have \"... = mset (v # tail)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset tail + {#v#} = mset (v # tail)", "by auto"], ["proof (state)\nthis:\n  mset tail + {#v#} = mset (v # tail)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (of_list_tree l) = mset l \\<Longrightarrow>\n       Heap.multiset (of_list_tree (a # l)) = mset (a # l)", "finally"], ["proof (chain)\npicking this:\n  Heap.multiset (of_list_tree (v # tail)) = mset (v # tail)", "show \"multiset (of_list_tree (v # tail)) = mset (v # tail)\""], ["proof (prove)\nusing this:\n  Heap.multiset (of_list_tree (v # tail)) = mset (v # tail)\n\ngoal (1 subgoal):\n 1. Heap.multiset (of_list_tree (v # tail)) = mset (v # tail)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (of_list_tree (v # tail)) = mset (v # tail)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiset_heapify:\n  \"multiset (heapify t) = multiset t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (heapify t) = Heap.multiset t", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. Heap.multiset (heapify E) = Heap.multiset E\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>Heap.multiset (heapify t1) = Heap.multiset t1;\n        Heap.multiset (heapify t2) = Heap.multiset t2\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (heapify (T x1 t1 t2)) =\n                         Heap.multiset (T x1 t1 t2)", "case E"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Heap.multiset (heapify E) = Heap.multiset E\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>Heap.multiset (heapify t1) = Heap.multiset t1;\n        Heap.multiset (heapify t2) = Heap.multiset t2\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (heapify (T x1 t1 t2)) =\n                         Heap.multiset (T x1 t1 t2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (heapify E) = Heap.multiset E", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (heapify E) = Heap.multiset E\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>Heap.multiset (heapify t1) = Heap.multiset t1;\n        Heap.multiset (heapify t2) = Heap.multiset t2\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (heapify (T x1 t1 t2)) =\n                         Heap.multiset (T x1 t1 t2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>Heap.multiset (heapify t1) = Heap.multiset t1;\n        Heap.multiset (heapify t2) = Heap.multiset t2\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (heapify (T x1 t1 t2)) =\n                         Heap.multiset (T x1 t1 t2)", "case (T v l r)"], ["proof (state)\nthis:\n  Heap.multiset (heapify l) = Heap.multiset l\n  Heap.multiset (heapify r) = Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>Heap.multiset (heapify t1) = Heap.multiset t1;\n        Heap.multiset (heapify t2) = Heap.multiset t2\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (heapify (T x1 t1 t2)) =\n                         Heap.multiset (T x1 t1 t2)", "hence \"multiset (heapify (T v l r)) = multiset l + {#v#} + multiset r\""], ["proof (prove)\nusing this:\n  Heap.multiset (heapify l) = Heap.multiset l\n  Heap.multiset (heapify r) = Heap.multiset r\n\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (T v l r)) =\n    Heap.multiset l + {#v#} + Heap.multiset r", "using siftDown_multiset[of \"T v (heapify l) (heapify r)\"]"], ["proof (prove)\nusing this:\n  Heap.multiset (heapify l) = Heap.multiset l\n  Heap.multiset (heapify r) = Heap.multiset r\n  Heap.multiset (siftDown (T v (heapify l) (heapify r))) =\n  Heap.multiset (T v (heapify l) (heapify r))\n\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (T v l r)) =\n    Heap.multiset l + {#v#} + Heap.multiset r", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (heapify (T v l r)) =\n  Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>Heap.multiset (heapify t1) = Heap.multiset t1;\n        Heap.multiset (heapify t2) = Heap.multiset t2\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (heapify (T x1 t1 t2)) =\n                         Heap.multiset (T x1 t1 t2)", "thus ?case"], ["proof (prove)\nusing this:\n  Heap.multiset (heapify (T v l r)) =\n  Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (T v l r)) = Heap.multiset (T v l r)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (heapify (T v l r)) = Heap.multiset (T v l r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma multiset_heapify_of_list_tree:\n  \"multiset (heapify (of_list_tree l)) = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (of_list_tree l)) = mset l", "using multiset_heapify[of \"of_list_tree l\"]"], ["proof (prove)\nusing this:\n  Heap.multiset (heapify (of_list_tree l)) = Heap.multiset (of_list_tree l)\n\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (of_list_tree l)) = mset l", "using mset_list_tree[of l]"], ["proof (prove)\nusing this:\n  Heap.multiset (heapify (of_list_tree l)) = Heap.multiset (of_list_tree l)\n  Heap.multiset (of_list_tree l) = mset l\n\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (of_list_tree l)) = mset l", "by auto"], ["", "lemma removeLeaf_val_val:\n  assumes \"snd (removeLeaf t) \\<noteq> E\" \"t \\<noteq> E\"\n  shows \"val t = val (snd (removeLeaf t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t = val (snd (removeLeaf t))", "using assms"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) \\<noteq> E\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. val t = val (snd (removeLeaf t))", "apply (induct t rule:removeLeaf.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>snd (removeLeaf (T v E E)) \\<noteq> E;\n        T v E E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (T v E E) = val (snd (removeLeaf (T v E E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (T va vb vc) =\n                                  val (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (T va vb vc) =\n                          val (snd (removeLeaf (T va vb vc)));\n        snd (removeLeaf (T v (T va vb vc) E)) \\<noteq> E;\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (T v (T va vb vc) E) =\n                         val (snd (removeLeaf (T v (T va vb vc) E)))\n 3. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (T va vb vc) =\n                                  val (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (T va vb vc) =\n                          val (snd (removeLeaf (T va vb vc)));\n        snd (removeLeaf (T v E (T va vb vc))) \\<noteq> E;\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (T v E (T va vb vc)) =\n                         val (snd (removeLeaf (T v E (T va vb vc))))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (T va vb vc) =\n                                  val (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (T va vb vc) =\n                          val (snd (removeLeaf (T va vb vc)));\n        snd (removeLeaf (T v (T va vb vc) (T vd ve vf))) \\<noteq> E;\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (T v (T va vb vc) (T vd ve vf)) =\n                         val (snd (removeLeaf\n                                    (T v (T va vb vc) (T vd ve vf))))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T vd ve vf)) \\<noteq> E;\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (T vd ve vf) =\n                                  val (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>snd (removeLeaf (T vd ve vf)) \\<noteq> E;\n         T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (T vd ve vf) =\n                          val (snd (removeLeaf (T vd ve vf)));\n        snd (removeLeaf (T v (T vd ve vf) (T va vb vc))) \\<noteq> E;\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (T v (T vd ve vf) (T va vb vc)) =\n                         val (snd (removeLeaf\n                                    (T v (T vd ve vf) (T va vb vc))))\n 6. \\<lbrakk>snd (removeLeaf E) \\<noteq> E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> val E = val (snd (removeLeaf E))", "by auto"], ["", "lemma removeLeaf_heap_is_heap: \n  assumes \"is_heap t\" \"t \\<noteq> E\"\n  shows \"is_heap (snd (removeLeaf t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf t))", "using assms"], ["proof (prove)\nusing this:\n  is_heap t\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf t))", "proof(induct t rule:removeLeaf.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>is_heap (T v E E); T v E E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 3. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 6. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "case (1 v)"], ["proof (state)\nthis:\n  is_heap (T v E E)\n  T v E E \\<noteq> E\n\ngoal (6 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>is_heap (T v E E); T v E E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 3. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 6. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "thus ?case"], ["proof (prove)\nusing this:\n  is_heap (T v E E)\n  T v E E \\<noteq> E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v E E)))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v E E)))\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 5. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 5. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "case (2 v v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v (T v1 l1 r1) E)\n  T v (T v1 l1 r1) E \\<noteq> E\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 5. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "have \"is_heap (T v1 l1 r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (T v1 l1 r1)", "using 2(3)"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1 l1 r1) E)\n\ngoal (1 subgoal):\n 1. is_heap (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  is_heap (T v1 l1 r1)\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 5. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "hence \"is_heap (snd (removeLeaf (T v1 l1 r1)))\""], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "using 2(1)"], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 5. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "let ?t = \"(snd (removeLeaf (T v1 l1 r1)))\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) E); T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v (T va vb vc) E)))\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 3. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 4. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 5. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "proof(cases \"?t = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "case True"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "case False"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "have \"v \\<ge> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<le> v", "using 2(3)"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1 l1 r1) E)\n\ngoal (1 subgoal):\n 1. v1 \\<le> v", "by auto"], ["proof (state)\nthis:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "hence \"v \\<ge> val ?t\""], ["proof (prove)\nusing this:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "using False removeLeaf_val_val[of \"T v1 l1 r1\"]"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n  \\<lbrakk>snd (removeLeaf (T v1 l1 r1)) \\<noteq> E;\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> val (T v1 l1 r1) = val (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "by auto"], ["proof (state)\nthis:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "hence \"is_heap (T v (snd (removeLeaf (T v1 l1 r1))) E)\""], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (T v (snd (removeLeaf (T v1 l1 r1))) E)", "using \\<open>is_heap (snd (removeLeaf (T v1 l1 r1)))\\<close>"], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (T v (snd (removeLeaf (T v1 l1 r1))) E)", "by (metis Tree.exhaust is_heap.simps(2) is_heap.simps(4))"], ["proof (state)\nthis:\n  is_heap (T v (snd (removeLeaf (T v1 l1 r1))) E)\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_heap (T v (snd (removeLeaf (T v1 l1 r1))) E)\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "using 2"], ["proof (prove)\nusing this:\n  is_heap (T v (snd (removeLeaf (T v1 l1 r1))) E)\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v (T v1 l1 r1) E)\n  T v (T v1 l1 r1) E \\<noteq> E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) E)))\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 4. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 4. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "case (3 v v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v E (T v1 l1 r1))\n  T v E (T v1 l1 r1) \\<noteq> E\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 4. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "have \"is_heap (T v1 l1 r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (T v1 l1 r1)", "using 3(3)"], ["proof (prove)\nusing this:\n  is_heap (T v E (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. is_heap (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  is_heap (T v1 l1 r1)\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 4. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "hence \"is_heap (snd (removeLeaf (T v1 l1 r1)))\""], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "using 3(1)"], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 4. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "let ?t = \"(snd (removeLeaf (T v1 l1 r1)))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v E (T va vb vc)); T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap (snd (removeLeaf (T v E (T va vb vc))))\n 2. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 3. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 4. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "proof(cases \"?t = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "case True"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "case False"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "have \"v \\<ge> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<le> v", "using 3(3)"], ["proof (prove)\nusing this:\n  is_heap (T v E (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. v1 \\<le> v", "by auto"], ["proof (state)\nthis:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "hence \"v \\<ge> val ?t\""], ["proof (prove)\nusing this:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "using False removeLeaf_val_val[of \"T v1 l1 r1\"]"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n  \\<lbrakk>snd (removeLeaf (T v1 l1 r1)) \\<noteq> E;\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> val (T v1 l1 r1) = val (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "by auto"], ["proof (state)\nthis:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "hence \"is_heap (T v E (snd (removeLeaf (T v1 l1 r1))))\""], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (T v E (snd (removeLeaf (T v1 l1 r1))))", "using \\<open>is_heap (snd (removeLeaf (T v1 l1 r1)))\\<close>"], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (T v E (snd (removeLeaf (T v1 l1 r1))))", "by (metis False Tree.exhaust is_heap.simps(3))"], ["proof (state)\nthis:\n  is_heap (T v E (snd (removeLeaf (T v1 l1 r1))))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_heap (T v E (snd (removeLeaf (T v1 l1 r1))))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "using 3"], ["proof (prove)\nusing this:\n  is_heap (T v E (snd (removeLeaf (T v1 l1 r1))))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v E (T v1 l1 r1))\n  T v E (T v1 l1 r1) \\<noteq> E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v E (T v1 l1 r1))))\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 3. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 3. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "case (\"4_1\" v v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n  T v (T v1 l1 r1) (T v2 l2 r2) \\<noteq> E\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 3. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "have \"is_heap (T v1 l1 r1)\" \"is_heap (T v2 l2 r2)\" \"v \\<ge> v1\" \"v \\<ge> v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_heap (T v1 l1 r1) &&& is_heap (T v2 l2 r2)) &&&\n    v1 \\<le> v &&& v2 \\<le> v", "using \"4_1\"(3)"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. (is_heap (T v1 l1 r1) &&& is_heap (T v2 l2 r2)) &&&\n    v1 \\<le> v &&& v2 \\<le> v", "by (simp add:is_heap.simps(5))+"], ["proof (state)\nthis:\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  v1 \\<le> v\n  v2 \\<le> v\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 3. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "hence \"is_heap (snd (removeLeaf (T v1 l1 r1)))\""], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  v1 \\<le> v\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "using \"4_1\"(1)"], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  v1 \\<le> v\n  v2 \\<le> v\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 3. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "let ?t = \"(snd (removeLeaf (T v1 l1 r1)))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>is_heap (T va vb vc);\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        \\<lbrakk>is_heap (T va vb vc); T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T va vb vc)));\n        is_heap (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T va vb vc) (T vd ve vf))))\n 2. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 3. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "proof(cases \"?t = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "case True"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "using \\<open>is_heap (T v2 l2 r2)\\<close> \\<open>v \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = E\n  is_heap (T v2 l2 r2)\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "case False"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "then"], ["proof (chain)\npicking this:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E", "obtain v1' l1' r1' where \"?t = T v1' l1' r1'\""], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>v1' l1' r1'.\n        snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"is_heap (T v1' l1' r1')\""], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. is_heap (T v1' l1' r1')", "using \\<open>is_heap (snd (removeLeaf (T v1 l1 r1)))\\<close>"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (T v1' l1' r1')", "by auto"], ["proof (state)\nthis:\n  is_heap (T v1' l1' r1')\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "have \"v \\<ge> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<le> v", "using \"4_1\"(3)"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. v1 \\<le> v", "by auto"], ["proof (state)\nthis:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"v \\<ge> val ?t\""], ["proof (prove)\nusing this:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "using False removeLeaf_val_val[of \"T v1 l1 r1\"]"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n  \\<lbrakk>snd (removeLeaf (T v1 l1 r1)) \\<noteq> E;\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> val (T v1 l1 r1) = val (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "by auto"], ["proof (state)\nthis:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"v \\<ge> v1'\""], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. v1' \\<le> v", "using \\<open>?t = T v1' l1' r1'\\<close>"], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. v1' \\<le> v", "by auto"], ["proof (state)\nthis:\n  v1' \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\""], ["proof (prove)\nusing this:\n  v1' \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (T v (T v1' l1' r1') (T v2 l2 r2))", "using \\<open>is_heap (T v1' l1' r1')\\<close>"], ["proof (prove)\nusing this:\n  v1' \\<le> v\n  is_heap (T v1' l1' r1')\n\ngoal (1 subgoal):\n 1. is_heap (T v (T v1' l1' r1') (T v2 l2 r2))", "using \\<open>is_heap (T v2 l2 r2)\\<close> \\<open>v \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  v1' \\<le> v\n  is_heap (T v1' l1' r1')\n  is_heap (T v2 l2 r2)\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (T v (T v1' l1' r1') (T v2 l2 r2))", "by (simp add: is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "using \"4_1\" \\<open>?t = T v1' l1' r1'\\<close>"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n  T v (T v1 l1 r1) (T v2 l2 r2) \\<noteq> E\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 2. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 2. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "case (\"4_2\" v v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n  T v (T v1 l1 r1) (T v2 l2 r2) \\<noteq> E\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 2. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "have \"is_heap (T v1 l1 r1)\" \"is_heap (T v2 l2 r2)\" \"v \\<ge> v1\" \"v \\<ge> v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_heap (T v1 l1 r1) &&& is_heap (T v2 l2 r2)) &&&\n    v1 \\<le> v &&& v2 \\<le> v", "using \"4_2\"(3)"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. (is_heap (T v1 l1 r1) &&& is_heap (T v2 l2 r2)) &&&\n    v1 \\<le> v &&& v2 \\<le> v", "by (simp add:is_heap.simps(5))+"], ["proof (state)\nthis:\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  v1 \\<le> v\n  v2 \\<le> v\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 2. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "hence \"is_heap (snd (removeLeaf (T v1 l1 r1)))\""], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  v1 \\<le> v\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "using \"4_2\"(1)"], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  v1 \\<le> v\n  v2 \\<le> v\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 2. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "let ?t = \"(snd (removeLeaf (T v1 l1 r1)))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>is_heap (T vd ve vf);\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        \\<lbrakk>is_heap (T vd ve vf); T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> is_heap (snd (removeLeaf (T vd ve vf)));\n        is_heap (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> is_heap\n                          (snd (removeLeaf (T v (T vd ve vf) (T va vb vc))))\n 2. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "proof(cases \"?t = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "case True"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (2 subgoals):\n 1. snd (removeLeaf (T v1 l1 r1)) = E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n 2. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "using \\<open>is_heap (T v2 l2 r2)\\<close> \\<open>v \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = E\n  is_heap (T v2 l2 r2)\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "case False"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "then"], ["proof (chain)\npicking this:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E", "obtain v1' l1' r1' where \"?t = T v1' l1' r1'\""], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>v1' l1' r1'.\n        snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"is_heap (T v1' l1' r1')\""], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. is_heap (T v1' l1' r1')", "using \\<open>is_heap (snd (removeLeaf (T v1 l1 r1)))\\<close>"], ["proof (prove)\nusing this:\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n  is_heap (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. is_heap (T v1' l1' r1')", "by auto"], ["proof (state)\nthis:\n  is_heap (T v1' l1' r1')\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "have \"v \\<ge> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<le> v", "using \"4_2\"(3)"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. v1 \\<le> v", "by auto"], ["proof (state)\nthis:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"v \\<ge> val ?t\""], ["proof (prove)\nusing this:\n  v1 \\<le> v\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "using False removeLeaf_val_val[of \"T v1 l1 r1\"]"], ["proof (prove)\nusing this:\n  v1 \\<le> v\n  snd (removeLeaf (T v1 l1 r1)) \\<noteq> E\n  \\<lbrakk>snd (removeLeaf (T v1 l1 r1)) \\<noteq> E;\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> val (T v1 l1 r1) = val (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf (T v1 l1 r1))) \\<le> v", "by auto"], ["proof (state)\nthis:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"v \\<ge> v1'\""], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n\ngoal (1 subgoal):\n 1. v1' \\<le> v", "using \\<open>?t = T v1' l1' r1'\\<close>"], ["proof (prove)\nusing this:\n  val (snd (removeLeaf (T v1 l1 r1))) \\<le> v\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. v1' \\<le> v", "by auto"], ["proof (state)\nthis:\n  v1' \\<le> v\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "hence \"is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\""], ["proof (prove)\nusing this:\n  v1' \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (T v (T v1' l1' r1') (T v2 l2 r2))", "using \\<open>is_heap (T v1' l1' r1')\\<close>"], ["proof (prove)\nusing this:\n  v1' \\<le> v\n  is_heap (T v1' l1' r1')\n\ngoal (1 subgoal):\n 1. is_heap (T v (T v1' l1' r1') (T v2 l2 r2))", "using \\<open>is_heap (T v2 l2 r2)\\<close> \\<open>v \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  v1' \\<le> v\n  is_heap (T v1' l1' r1')\n  is_heap (T v2 l2 r2)\n  v2 \\<le> v\n\ngoal (1 subgoal):\n 1. is_heap (T v (T v1' l1' r1') (T v2 l2 r2))", "by (simp add: is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf (T v1 l1 r1)) \\<noteq> E \\<Longrightarrow>\n    is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "using \"4_2\" \\<open>?t = T v1' l1' r1'\\<close>"], ["proof (prove)\nusing this:\n  is_heap (T v (T v1' l1' r1') (T v2 l2 r2))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  \\<lbrakk>is_heap (T v1 l1 r1); T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf (T v1 l1 r1)))\n  is_heap (T v (T v1 l1 r1) (T v2 l2 r2))\n  T v (T v1 l1 r1) (T v2 l2 r2) \\<noteq> E\n  snd (removeLeaf (T v1 l1 r1)) = T v1' l1' r1'\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "case 5"], ["proof (state)\nthis:\n  is_heap E\n  E \\<noteq> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> is_heap (snd (removeLeaf E))", "thus ?case"], ["proof (prove)\nusing this:\n  is_heap E\n  E \\<noteq> E\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf E))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf E))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Difined functions satisfy conditions of locale {\\em Collection} and thus represent \n       interpretation of this locale.\\<close>"], ["", "interpretation HS: Collection \"E\" hs_is_empty hs_of_list multiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collection E hs_is_empty hs_of_list Heap.multiset", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. hs_is_empty e \\<Longrightarrow> e = E\n 2. hs_is_empty E\n 3. Heap.multiset E = {#}\n 4. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "fix t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. hs_is_empty e \\<Longrightarrow> e = E\n 2. hs_is_empty E\n 3. Heap.multiset E = {#}\n 4. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "assume \"hs_is_empty t\""], ["proof (state)\nthis:\n  hs_is_empty t\n\ngoal (4 subgoals):\n 1. \\<And>e. hs_is_empty e \\<Longrightarrow> e = E\n 2. hs_is_empty E\n 3. Heap.multiset E = {#}\n 4. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "thus \"t = E\""], ["proof (prove)\nusing this:\n  hs_is_empty t\n\ngoal (1 subgoal):\n 1. t = E", "by auto"], ["proof (state)\nthis:\n  t = E\n\ngoal (3 subgoals):\n 1. hs_is_empty E\n 2. Heap.multiset E = {#}\n 3. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. hs_is_empty E\n 2. Heap.multiset E = {#}\n 3. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "show \"hs_is_empty E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs_is_empty E", "by auto"], ["proof (state)\nthis:\n  hs_is_empty E\n\ngoal (2 subgoals):\n 1. Heap.multiset E = {#}\n 2. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Heap.multiset E = {#}\n 2. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "show \"multiset E = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset E = {#}", "by auto"], ["proof (state)\nthis:\n  Heap.multiset E = {#}\n\ngoal (1 subgoal):\n 1. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "show \"multiset (hs_of_list l) = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (hs_of_list l) = mset l", "unfolding hs_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (of_list_tree l)) = mset l", "using multiset_heapify_of_list_tree[of l]"], ["proof (prove)\nusing this:\n  Heap.multiset (heapify (of_list_tree l)) = mset l\n\ngoal (1 subgoal):\n 1. Heap.multiset (heapify (of_list_tree l)) = mset l", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (hs_of_list l) = mset l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma removeLeaf_multiset:\n  assumes \"(v', t') = removeLeaf t\" \"t \\<noteq> E\"\n  shows \"{#v'#} + multiset t' = multiset t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset t", "using assms"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf t\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset t", "proof(induct t arbitrary: v' t' rule:removeLeaf.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v v' t'.\n       \\<lbrakk>(v', t') = removeLeaf (T v E E); T v E E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset (T v E E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 3. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 4. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 5. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 6. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "case 1"], ["proof (state)\nthis:\n  (v', t') = removeLeaf (T v_ E E)\n  T v_ E E \\<noteq> E\n\ngoal (6 subgoals):\n 1. \\<And>v v' t'.\n       \\<lbrakk>(v', t') = removeLeaf (T v E E); T v E E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset (T v E E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 3. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 4. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 5. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 6. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "thus ?case"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v_ E E)\n  T v_ E E \\<noteq> E\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset (T v_ E E)", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v_ E E)\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "case (2 v v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  (v', t') = removeLeaf (T v (T v1 l1 r1) E)\n  T v (T v1 l1 r1) E \\<noteq> E\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"t' = T v (snd (removeLeaf (T v1 l1 r1))) E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = T v (snd (removeLeaf (T v1 l1 r1))) E", "using 2(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v (T v1 l1 r1) E)\n\ngoal (1 subgoal):\n 1. t' = T v (snd (removeLeaf (T v1 l1 r1))) E", "by auto"], ["proof (state)\nthis:\n  t' = T v (snd (removeLeaf (T v1 l1 r1))) E\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"v' = fst (removeLeaf (T v1 l1 r1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "using 2(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v (T v1 l1 r1) E)\n\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = \n           {#fst (removeLeaf (T v1 l1 r1))#} + \n           multiset (snd (removeLeaf (T v1 l1 r1))) + \n           {#v#}\""], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#}", "using \\<open>t' = T v (snd (removeLeaf (T v1 l1 r1))) E\\<close>"], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n  t' = T v (snd (removeLeaf (T v1 l1 r1))) E\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#}", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#}\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"{#fst (removeLeaf (T v1 l1 r1))#} + \n        multiset (snd (removeLeaf (T v1 l1 r1))) = \n          multiset (T v1 l1 r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "using 2(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = multiset (T v1 l1 r1) + {#v#}\""], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}", "using \\<open>{#v'#} + multiset t' = \n           {#fst (removeLeaf (T v1 l1 r1))#} + \n           multiset (snd (removeLeaf (T v1 l1 r1))) + {#v#}\\<close>"], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#}\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}\n\ngoal (5 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) E);\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) E)\n 2. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 3. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 4. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 5. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "thus ?case"], ["proof (prove)\nusing this:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset (T v (T v1 l1 r1) E)", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v (T v1 l1 r1) E)\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "case (3 v v1 l1 r1)"], ["proof (state)\nthis:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  (v', t') = removeLeaf (T v E (T v1 l1 r1))\n  T v E (T v1 l1 r1) \\<noteq> E\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"t' = T v E (snd (removeLeaf (T v1 l1 r1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = T v E (snd (removeLeaf (T v1 l1 r1)))", "using 3(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v E (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. t' = T v E (snd (removeLeaf (T v1 l1 r1)))", "by auto"], ["proof (state)\nthis:\n  t' = T v E (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"v' = fst (removeLeaf (T v1 l1 r1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "using 3(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v E (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = \n          {#fst (removeLeaf (T v1 l1 r1))#} + \n          multiset (snd (removeLeaf (T v1 l1 r1))) + \n          {#v#}\""], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#}", "using \\<open>t' = T v E (snd (removeLeaf (T v1 l1 r1)))\\<close>"], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n  t' = T v E (snd (removeLeaf (T v1 l1 r1)))\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#}", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#}\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"{#fst (removeLeaf (T v1 l1 r1))#} + \n        multiset (snd (removeLeaf (T v1 l1 r1))) = \n          multiset (T v1 l1 r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "using 3(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = multiset (T v1 l1 r1) + {#v#}\""], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}", "using \\<open>{#v'#} + multiset t' = \n           {#fst (removeLeaf (T v1 l1 r1))#} + \n           multiset (snd (removeLeaf (T v1 l1 r1))) + {#v#}\\<close>"], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#}\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}\n\ngoal (4 subgoals):\n 1. \\<And>v va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v E (T va vb vc));\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v E (T va vb vc))\n 2. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 3. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 4. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "thus ?case"], ["proof (prove)\nusing this:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v1 l1 r1) + {#v#}\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset (T v E (T v1 l1 r1))", "by (metis monoid_add_class.add.right_neutral \n        multiset.simps(1) multiset.simps(2) union_commute)"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v E (T v1 l1 r1))\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "case (\"4_1\" v v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  (v', t') = removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))\n  T v (T v1 l1 r1) (T v2 l2 r2) \\<noteq> E\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)", "using \"4_1\"(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"v' = fst (removeLeaf (T v1 l1 r1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "using \"4_1\"(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = \n         {#fst (removeLeaf (T v1 l1 r1))#} + \n         multiset (snd (removeLeaf (T v1 l1 r1))) + \n         {#v#} + multiset (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#} +\n    Heap.multiset (T v2 l2 r2)", "using \\<open>t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\\<close>"], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n  t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#} +\n    Heap.multiset (T v2 l2 r2)", "by (metis multiset.simps(2) union_assoc)"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"{#fst (removeLeaf (T v1 l1 r1))#} + \n        multiset (snd (removeLeaf (T v1 l1 r1))) = \n          multiset (T v1 l1 r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "using \"4_1\"(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = \n           multiset (T v1 l1 r1) + {#v#} + multiset (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)", "using \\<open>{#v'#} + multiset t' = \n           {#fst (removeLeaf (T v1 l1 r1))#} + \n           multiset (snd (removeLeaf (T v1 l1 r1))) + \n           {#v#} + multiset (T v2 l2 r2)\\<close>"], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)\n\ngoal (3 subgoals):\n 1. \\<And>v va vb vc vd ve vf v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n                    T va vb vc \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T va vb vc);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T va vb vc);\n            T va vb vc \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T va vb vc);\n        (v', t') = removeLeaf (T v (T va vb vc) (T vd ve vf));\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T va vb vc) (T vd ve vf))\n 2. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 3. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "thus ?case"], ["proof (prove)\nusing this:\n  {#v'#} + Heap.multiset t' =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "case (\"4_2\" v v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n  (v', t') = removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))\n  T v (T v1 l1 r1) (T v2 l2 r2) \\<noteq> E\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)", "using \"4_2\"(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"v' = fst (removeLeaf (T v1 l1 r1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "using \"4_2\"(3)"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. v' = fst (removeLeaf (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = \n         {#fst (removeLeaf (T v1 l1 r1))#} + \n         multiset (snd (removeLeaf (T v1 l1 r1))) + \n         {#v#} + multiset (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#} +\n    Heap.multiset (T v2 l2 r2)", "using \\<open>t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\\<close>"], ["proof (prove)\nusing this:\n  v' = fst (removeLeaf (T v1 l1 r1))\n  t' = T v (snd (removeLeaf (T v1 l1 r1))) (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n    {#v#} +\n    Heap.multiset (T v2 l2 r2)", "by (metis multiset.simps(2) union_assoc)"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "have \"{#fst (removeLeaf (T v1 l1 r1))#} + \n        multiset (snd (removeLeaf (T v1 l1 r1))) = \n          multiset (T v1 l1 r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "using \"4_2\"(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?v', ?t') = removeLeaf (T v1 l1 r1);\n   T v1 l1 r1 \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#?v'#} + Heap.multiset ?t' = Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#fst (removeLeaf (T v1 l1 r1))#} +\n    Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n    Heap.multiset (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "hence \"{#v'#} + multiset t' = \n         multiset (T v1 l1 r1) + {#v#} + multiset (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)", "using \\<open>{#v'#} + multiset t' = \n           {#fst (removeLeaf (T v1 l1 r1))#} + \n           multiset (snd (removeLeaf (T v1 l1 r1))) + \n           {#v#} + multiset (T v2 l2 r2)\\<close>"], ["proof (prove)\nusing this:\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) =\n  Heap.multiset (T v1 l1 r1)\n  {#v'#} + Heap.multiset t' =\n  {#fst (removeLeaf (T v1 l1 r1))#} +\n  Heap.multiset (snd (removeLeaf (T v1 l1 r1))) +\n  {#v#} +\n  Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)\n\ngoal (2 subgoals):\n 1. \\<And>v vd ve vf va vb vc v' t'.\n       \\<lbrakk>\\<And>v' t'.\n                   \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n                    T vd ve vf \\<noteq> E\\<rbrakk>\n                   \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                                     Heap.multiset (T vd ve vf);\n        \\<And>v' t'.\n           \\<lbrakk>(v', t') = removeLeaf (T vd ve vf);\n            T vd ve vf \\<noteq> E\\<rbrakk>\n           \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                             Heap.multiset (T vd ve vf);\n        (v', t') = removeLeaf (T v (T vd ve vf) (T va vb vc));\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' =\n                         Heap.multiset (T v (T vd ve vf) (T va vb vc))\n 2. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "thus ?case"], ["proof (prove)\nusing this:\n  {#v'#} + Heap.multiset t' =\n  Heap.multiset (T v1 l1 r1) + {#v#} + Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' =\n    Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset (T v (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "case 5"], ["proof (state)\nthis:\n  (v', t') = removeLeaf E\n  E \\<noteq> E\n\ngoal (1 subgoal):\n 1. \\<And>v' t'.\n       \\<lbrakk>(v', t') = removeLeaf E; E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> {#v'#} + Heap.multiset t' = Heap.multiset E", "thus ?case"], ["proof (prove)\nusing this:\n  (v', t') = removeLeaf E\n  E \\<noteq> E\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t' = Heap.multiset E", "by auto"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t' = Heap.multiset E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_val_multiset:\n  assumes \"t \\<noteq> E\"\n  shows \"multiset (set_val t v') +  {#val t#} = {#v'#} + multiset t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "obtain v l r where \"t = T v l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v l r. t = T v l r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>v l r. t = T v l r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  t = T v l r\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "hence \"multiset (set_val t v') + {#val t#} = \n         multiset l + {#v'#} + multiset r + {#v#}\""], ["proof (prove)\nusing this:\n  t = T v l r\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} =\n    Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (set_val t v') + {#val t#} =\n  Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "have \"{#v'#} + multiset t = \n        {#v'#} + multiset l + {#v#} + multiset r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t =\n    {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r", "using \\<open>t = T v l r\\<close>"], ["proof (prove)\nusing this:\n  t = T v l r\n\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset t =\n    {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r", "by (metis multiset.simps(2) union_assoc)"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset t =\n  {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "have \"{#v'#} + multiset l + {#v#} + multiset r = \n        multiset l + {#v'#} + multiset r + {#v#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r =\n    Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r =\n  Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "thus ?thesis"], ["proof (prove)\nusing this:\n  {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r =\n  Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "using \\<open>multiset (set_val t v') + {#val t#} = \n           multiset l + {#v'#} + multiset r + {#v#}\\<close>"], ["proof (prove)\nusing this:\n  {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r =\n  Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}\n  Heap.multiset (set_val t v') + {#val t#} =\n  Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "using \\<open>{#v'#} + multiset t = \n           {#v'#} + multiset l + {#v#} + multiset r\\<close>"], ["proof (prove)\nusing this:\n  {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r =\n  Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}\n  Heap.multiset (set_val t v') + {#val t#} =\n  Heap.multiset l + {#v'#} + Heap.multiset r + {#v#}\n  {#v'#} + Heap.multiset t =\n  {#v'#} + Heap.multiset l + {#v#} + Heap.multiset r\n\ngoal (1 subgoal):\n 1. Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (set_val t v') + {#val t#} = {#v'#} + Heap.multiset t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hs_remove_max_multiset:\n  assumes \"(m, t') = hs_remove_max t\" \"t \\<noteq> E\"\n  shows \"{#m#} + multiset t' = multiset t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "let ?v1 = \"fst (removeLeaf t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "let ?t1 = \"snd (removeLeaf t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "proof(cases \"?t1 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "case True"], ["proof (state)\nthis:\n  snd (removeLeaf t) = E\n\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "hence \"{#m#} + multiset t' = {#m#}\""], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = E\n\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = {#m#}", "using assms"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = E\n  (m, t') = hs_remove_max t\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = {#m#}", "unfolding hs_remove_max_def"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = E\n  (m, t') =\n  (let v' = fst (removeLeaf t); t' = snd (removeLeaf t)\n   in if t' = E then (val t, E) else (val t, siftDown (set_val t' v')))\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = {#m#}", "by auto"], ["proof (state)\nthis:\n  {#m#} + Heap.multiset t' = {#m#}\n\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "have \"?v1 = val t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (removeLeaf t) = val t", "using True assms(2)"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = E\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. fst (removeLeaf t) = val t", "apply (induct t rule:removeLeaf.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>snd (removeLeaf (T v E E)) = E; T v E E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> fst (removeLeaf (T v E E)) = val (T v E E)\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) = E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> fst (removeLeaf (T va vb vc)) =\n                                  val (T va vb vc);\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) = E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> fst (removeLeaf (T va vb vc)) = val (T va vb vc);\n        snd (removeLeaf (T v (T va vb vc) E)) = E;\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> fst (removeLeaf (T v (T va vb vc) E)) =\n                         val (T v (T va vb vc) E)\n 3. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) = E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> fst (removeLeaf (T va vb vc)) =\n                                  val (T va vb vc);\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) = E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> fst (removeLeaf (T va vb vc)) = val (T va vb vc);\n        snd (removeLeaf (T v E (T va vb vc))) = E;\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> fst (removeLeaf (T v E (T va vb vc))) =\n                         val (T v E (T va vb vc))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) = E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> fst (removeLeaf (T va vb vc)) =\n                                  val (T va vb vc);\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) = E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> fst (removeLeaf (T va vb vc)) = val (T va vb vc);\n        snd (removeLeaf (T v (T va vb vc) (T vd ve vf))) = E;\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> fst (removeLeaf (T v (T va vb vc) (T vd ve vf))) =\n                         val (T v (T va vb vc) (T vd ve vf))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T vd ve vf)) = E;\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> fst (removeLeaf (T vd ve vf)) =\n                                  val (T vd ve vf);\n        \\<lbrakk>snd (removeLeaf (T vd ve vf)) = E;\n         T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> fst (removeLeaf (T vd ve vf)) = val (T vd ve vf);\n        snd (removeLeaf (T v (T vd ve vf) (T va vb vc))) = E;\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> fst (removeLeaf (T v (T vd ve vf) (T va vb vc))) =\n                         val (T v (T vd ve vf) (T va vb vc))\n 6. \\<lbrakk>snd (removeLeaf E) = E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> fst (removeLeaf E) = val E", "by auto"], ["proof (state)\nthis:\n  fst (removeLeaf t) = val t\n\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "hence \"?v1 = m\""], ["proof (prove)\nusing this:\n  fst (removeLeaf t) = val t\n\ngoal (1 subgoal):\n 1. fst (removeLeaf t) = m", "using assms(1) True"], ["proof (prove)\nusing this:\n  fst (removeLeaf t) = val t\n  (m, t') = hs_remove_max t\n  snd (removeLeaf t) = E\n\ngoal (1 subgoal):\n 1. fst (removeLeaf t) = m", "unfolding hs_remove_max_def"], ["proof (prove)\nusing this:\n  fst (removeLeaf t) = val t\n  (m, t') =\n  (let v' = fst (removeLeaf t); t' = snd (removeLeaf t)\n   in if t' = E then (val t, E) else (val t, siftDown (set_val t' v')))\n  snd (removeLeaf t) = E\n\ngoal (1 subgoal):\n 1. fst (removeLeaf t) = m", "by auto"], ["proof (state)\nthis:\n  fst (removeLeaf t) = m\n\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "hence \"multiset t = {#m#}\""], ["proof (prove)\nusing this:\n  fst (removeLeaf t) = m\n\ngoal (1 subgoal):\n 1. Heap.multiset t = {#m#}", "using removeLeaf_multiset[of ?v1 ?t1 t] True assms(2)"], ["proof (prove)\nusing this:\n  fst (removeLeaf t) = m\n  \\<lbrakk>(fst (removeLeaf t), snd (removeLeaf t)) = removeLeaf t;\n   t \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#fst (removeLeaf t)#} +\n                    Heap.multiset (snd (removeLeaf t)) =\n                    Heap.multiset t\n  snd (removeLeaf t) = E\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. Heap.multiset t = {#m#}", "by (metis empty_neutral(2) multiset.simps(1) prod.collapse)"], ["proof (state)\nthis:\n  Heap.multiset t = {#m#}\n\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "thus ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset t = {#m#}\n\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "using \\<open>{#m#} + multiset t' = {#m#}\\<close>"], ["proof (prove)\nusing this:\n  Heap.multiset t = {#m#}\n  {#m#} + Heap.multiset t' = {#m#}\n\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "by auto"], ["proof (state)\nthis:\n  {#m#} + Heap.multiset t' = Heap.multiset t\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "case False"], ["proof (state)\nthis:\n  snd (removeLeaf t) \\<noteq> E\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "hence \"t' = siftDown (set_val ?t1 ?v1)\""], ["proof (prove)\nusing this:\n  snd (removeLeaf t) \\<noteq> E\n\ngoal (1 subgoal):\n 1. t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))", "using assms(1)"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) \\<noteq> E\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))", "by (auto simp add: hs_remove_max_def) (metis prod.inject)"], ["proof (state)\nthis:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "hence \"multiset t' + {#val ?t1#} = multiset t\""], ["proof (prove)\nusing this:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n\ngoal (1 subgoal):\n 1. Heap.multiset t' + {#val (snd (removeLeaf t))#} = Heap.multiset t", "using siftDown_multiset[of \"set_val ?t1 ?v1\"]"], ["proof (prove)\nusing this:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n  Heap.multiset\n   (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))) =\n  Heap.multiset (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n\ngoal (1 subgoal):\n 1. Heap.multiset t' + {#val (snd (removeLeaf t))#} = Heap.multiset t", "using removeLeaf_multiset[of ?v1 ?t1 t] assms(2)"], ["proof (prove)\nusing this:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n  Heap.multiset\n   (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))) =\n  Heap.multiset (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n  \\<lbrakk>(fst (removeLeaf t), snd (removeLeaf t)) = removeLeaf t;\n   t \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#fst (removeLeaf t)#} +\n                    Heap.multiset (snd (removeLeaf t)) =\n                    Heap.multiset t\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. Heap.multiset t' + {#val (snd (removeLeaf t))#} = Heap.multiset t", "using set_val_multiset[of ?t1 ?v1] False"], ["proof (prove)\nusing this:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n  Heap.multiset\n   (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))) =\n  Heap.multiset (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n  \\<lbrakk>(fst (removeLeaf t), snd (removeLeaf t)) = removeLeaf t;\n   t \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#fst (removeLeaf t)#} +\n                    Heap.multiset (snd (removeLeaf t)) =\n                    Heap.multiset t\n  t \\<noteq> E\n  snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n  Heap.multiset (set_val (snd (removeLeaf t)) (fst (removeLeaf t))) +\n  {#val (snd (removeLeaf t))#} =\n  {#fst (removeLeaf t)#} + Heap.multiset (snd (removeLeaf t))\n  snd (removeLeaf t) \\<noteq> E\n\ngoal (1 subgoal):\n 1. Heap.multiset t' + {#val (snd (removeLeaf t))#} = Heap.multiset t", "by auto"], ["proof (state)\nthis:\n  Heap.multiset t' + {#val (snd (removeLeaf t))#} = Heap.multiset t\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "have \"val ?t1 = val t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (snd (removeLeaf t)) = val t", "using False assms(2)"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) \\<noteq> E\n  t \\<noteq> E\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf t)) = val t", "apply (induct t rule:removeLeaf.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>snd (removeLeaf (T v E E)) \\<noteq> E;\n        T v E E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (snd (removeLeaf (T v E E))) = val (T v E E)\n 2. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (snd (removeLeaf (T va vb vc))) =\n                                  val (T va vb vc);\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (snd (removeLeaf (T va vb vc))) =\n                          val (T va vb vc);\n        snd (removeLeaf (T v (T va vb vc) E)) \\<noteq> E;\n        T v (T va vb vc) E \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (snd (removeLeaf (T v (T va vb vc) E))) =\n                         val (T v (T va vb vc) E)\n 3. \\<And>v va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (snd (removeLeaf (T va vb vc))) =\n                                  val (T va vb vc);\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (snd (removeLeaf (T va vb vc))) =\n                          val (T va vb vc);\n        snd (removeLeaf (T v E (T va vb vc))) \\<noteq> E;\n        T v E (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (snd (removeLeaf (T v E (T va vb vc)))) =\n                         val (T v E (T va vb vc))\n 4. \\<And>v va vb vc vd ve vf.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n                 T va vb vc \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (snd (removeLeaf (T va vb vc))) =\n                                  val (T va vb vc);\n        \\<lbrakk>snd (removeLeaf (T va vb vc)) \\<noteq> E;\n         T va vb vc \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (snd (removeLeaf (T va vb vc))) =\n                          val (T va vb vc);\n        snd (removeLeaf (T v (T va vb vc) (T vd ve vf))) \\<noteq> E;\n        T v (T va vb vc) (T vd ve vf) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (snd (removeLeaf\n                                    (T v (T va vb vc) (T vd ve vf)))) =\n                         val (T v (T va vb vc) (T vd ve vf))\n 5. \\<And>v vd ve vf va vb vc.\n       \\<lbrakk>\\<lbrakk>snd (removeLeaf (T vd ve vf)) \\<noteq> E;\n                 T vd ve vf \\<noteq> E\\<rbrakk>\n                \\<Longrightarrow> val (snd (removeLeaf (T vd ve vf))) =\n                                  val (T vd ve vf);\n        \\<lbrakk>snd (removeLeaf (T vd ve vf)) \\<noteq> E;\n         T vd ve vf \\<noteq> E\\<rbrakk>\n        \\<Longrightarrow> val (snd (removeLeaf (T vd ve vf))) =\n                          val (T vd ve vf);\n        snd (removeLeaf (T v (T vd ve vf) (T va vb vc))) \\<noteq> E;\n        T v (T vd ve vf) (T va vb vc) \\<noteq> E\\<rbrakk>\n       \\<Longrightarrow> val (snd (removeLeaf\n                                    (T v (T vd ve vf) (T va vb vc)))) =\n                         val (T v (T vd ve vf) (T va vb vc))\n 6. \\<lbrakk>snd (removeLeaf E) \\<noteq> E; E \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> val (snd (removeLeaf E)) = val E", "by auto"], ["proof (state)\nthis:\n  val (snd (removeLeaf t)) = val t\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "have \"val t = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t = m", "using assms(1) False"], ["proof (prove)\nusing this:\n  (m, t') = hs_remove_max t\n  snd (removeLeaf t) \\<noteq> E\n\ngoal (1 subgoal):\n 1. val t = m", "using \\<open>t' = siftDown (set_val ?t1 ?v1)\\<close>"], ["proof (prove)\nusing this:\n  (m, t') = hs_remove_max t\n  snd (removeLeaf t) \\<noteq> E\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n\ngoal (1 subgoal):\n 1. val t = m", "unfolding hs_remove_max_def"], ["proof (prove)\nusing this:\n  (m, t') =\n  (let v' = fst (removeLeaf t); t' = snd (removeLeaf t)\n   in if t' = E then (val t, E) else (val t, siftDown (set_val t' v')))\n  snd (removeLeaf t) \\<noteq> E\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n\ngoal (1 subgoal):\n 1. val t = m", "by (metis (full_types) fst_conv removeLeaf.simps(1))"], ["proof (state)\nthis:\n  val t = m\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "hence \"val ?t1 = m\""], ["proof (prove)\nusing this:\n  val t = m\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf t)) = m", "using \\<open>val ?t1 = val t\\<close>"], ["proof (prove)\nusing this:\n  val t = m\n  val (snd (removeLeaf t)) = val t\n\ngoal (1 subgoal):\n 1. val (snd (removeLeaf t)) = m", "by auto"], ["proof (state)\nthis:\n  val (snd (removeLeaf t)) = m\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "hence \"multiset t' + {#m#} = multiset t\""], ["proof (prove)\nusing this:\n  val (snd (removeLeaf t)) = m\n\ngoal (1 subgoal):\n 1. Heap.multiset t' + {#m#} = Heap.multiset t", "using \\<open>multiset t' + {#val ?t1#} = multiset t\\<close>"], ["proof (prove)\nusing this:\n  val (snd (removeLeaf t)) = m\n  Heap.multiset t' + {#val (snd (removeLeaf t))#} = Heap.multiset t\n\ngoal (1 subgoal):\n 1. Heap.multiset t' + {#m#} = Heap.multiset t", "by metis"], ["proof (state)\nthis:\n  Heap.multiset t' + {#m#} = Heap.multiset t\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow>\n    {#m#} + Heap.multiset t' = Heap.multiset t", "thus ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset t' + {#m#} = Heap.multiset t\n\ngoal (1 subgoal):\n 1. {#m#} + Heap.multiset t' = Heap.multiset t", "by (metis union_commute)"], ["proof (state)\nthis:\n  {#m#} + Heap.multiset t' = Heap.multiset t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#m#} + Heap.multiset t' = Heap.multiset t\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Difined functions satisfy conditions of locale {\\em Heap} and thus represent \n       interpretation of this locale.\\<close>"], ["", "interpretation Heap \"E\" hs_is_empty hs_of_list multiset id hs_remove_max"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap E hs_is_empty hs_of_list Heap.multiset id hs_remove_max", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l. Heap.multiset l = Heap.multiset (id l)\n 2. \\<And>i. is_heap (id (hs_of_list i))\n 3. \\<And>t. (id t = E) = hs_is_empty t\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 5. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 6. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l. Heap.multiset l = Heap.multiset (id l)\n 2. \\<And>i. is_heap (id (hs_of_list i))\n 3. \\<And>t. (id t = E) = hs_is_empty t\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 5. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 6. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "show \"multiset t = multiset (id t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset t = Heap.multiset (id t)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset t = Heap.multiset (id t)\n\ngoal (5 subgoals):\n 1. \\<And>i. is_heap (id (hs_of_list i))\n 2. \\<And>t. (id t = E) = hs_is_empty t\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 5. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. is_heap (id (hs_of_list i))\n 2. \\<And>t. (id t = E) = hs_is_empty t\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 5. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. is_heap (id (hs_of_list i))\n 2. \\<And>t. (id t = E) = hs_is_empty t\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 5. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "show \" is_heap (id (hs_of_list t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (id (hs_of_list t))", "unfolding hs_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (id (heapify (of_list_tree t)))", "using heapify_heap_is_heap[of \"of_list_tree t\"]"], ["proof (prove)\nusing this:\n  is_heap (heapify (of_list_tree t))\n\ngoal (1 subgoal):\n 1. is_heap (id (heapify (of_list_tree t)))", "by auto"], ["proof (state)\nthis:\n  is_heap (id (hs_of_list t))\n\ngoal (4 subgoals):\n 1. \\<And>t. (id t = E) = hs_is_empty t\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 4. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t. (id t = E) = hs_is_empty t\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 4. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t. (id t = E) = hs_is_empty t\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 4. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "show \"(id t = E) = hs_is_empty t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id t = E) = hs_is_empty t", "by auto"], ["proof (state)\nthis:\n  (id t = E) = hs_is_empty t\n\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t m t'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "assume \"\\<not> hs_is_empty t\" \"(m, t') = hs_remove_max t\""], ["proof (state)\nthis:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "thus \"add_mset m (multiset t') = multiset t\""], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. add_mset m (Heap.multiset t') = Heap.multiset t", "using hs_remove_max_multiset[of m t' t]"], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n  \\<lbrakk>(m, t') = hs_remove_max t; t \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> {#m#} + Heap.multiset t' = Heap.multiset t\n\ngoal (1 subgoal):\n 1. add_mset m (Heap.multiset t') = Heap.multiset t", "by auto"], ["proof (state)\nthis:\n  add_mset m (Heap.multiset t') = Heap.multiset t\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t v' t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "assume \"\\<not> hs_is_empty t\" \"is_heap (id t)\" \"(v', t') = hs_remove_max t\""], ["proof (state)\nthis:\n  \\<not> hs_is_empty t\n  is_heap (id t)\n  (v', t') = hs_remove_max t\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "let ?v1 = \"fst (removeLeaf t)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "let ?t1 = \"snd (removeLeaf t)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "have \"is_heap ?t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf t))", "using \\<open>\\<not> hs_is_empty t\\<close> \\<open>is_heap (id t)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  is_heap (id t)\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf t))", "using removeLeaf_heap_is_heap[of t]"], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  is_heap (id t)\n  \\<lbrakk>is_heap t; t \\<noteq> E\\<rbrakk>\n  \\<Longrightarrow> is_heap (snd (removeLeaf t))\n\ngoal (1 subgoal):\n 1. is_heap (snd (removeLeaf t))", "by auto"], ["proof (state)\nthis:\n  is_heap (snd (removeLeaf t))\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "show \"is_heap (id t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (id t')", "proof(cases \"?t1 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow> is_heap (id t')\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "case True"], ["proof (state)\nthis:\n  snd (removeLeaf t) = E\n\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow> is_heap (id t')\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "hence \"t' = E\""], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = E\n\ngoal (1 subgoal):\n 1. t' = E", "using \\<open>(v', t') = hs_remove_max t\\<close>"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = E\n  (v', t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. t' = E", "unfolding hs_remove_max_def"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = E\n  (v', t') =\n  (let v' = fst (removeLeaf t); t' = snd (removeLeaf t)\n   in if t' = E then (val t, E) else (val t, siftDown (set_val t' v')))\n\ngoal (1 subgoal):\n 1. t' = E", "by auto"], ["proof (state)\nthis:\n  t' = E\n\ngoal (2 subgoals):\n 1. snd (removeLeaf t) = E \\<Longrightarrow> is_heap (id t')\n 2. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "thus ?thesis"], ["proof (prove)\nusing this:\n  t' = E\n\ngoal (1 subgoal):\n 1. is_heap (id t')", "by auto"], ["proof (state)\nthis:\n  is_heap (id t')\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "case False"], ["proof (state)\nthis:\n  snd (removeLeaf t) \\<noteq> E\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "then"], ["proof (chain)\npicking this:\n  snd (removeLeaf t) \\<noteq> E", "obtain v_t1 l_t1 r_t1 where \"?t1 = T v_t1 l_t1 r_t1\""], ["proof (prove)\nusing this:\n  snd (removeLeaf t) \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>v_t1 l_t1 r_t1.\n        snd (removeLeaf t) = T v_t1 l_t1 r_t1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  snd (removeLeaf t) = T v_t1 l_t1 r_t1\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "hence \"is_heap l_t1\" \"is_heap r_t1\""], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = T v_t1 l_t1 r_t1\n\ngoal (1 subgoal):\n 1. is_heap l_t1 &&& is_heap r_t1", "using \\<open>is_heap ?t1\\<close>"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = T v_t1 l_t1 r_t1\n  is_heap (snd (removeLeaf t))\n\ngoal (1 subgoal):\n 1. is_heap l_t1 &&& is_heap r_t1", "by (auto, metis (full_types) Tree.exhaust \n         is_heap.simps(1) is_heap.simps(4) is_heap.simps(5))\n         (metis (full_types) Tree.exhaust \n          is_heap.simps(1) is_heap.simps(3) is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap l_t1\n  is_heap r_t1\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "have \"set_val ?t1 ?v1 = T ?v1 l_t1 r_t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_val (snd (removeLeaf t)) (fst (removeLeaf t)) =\n    T (fst (removeLeaf t)) l_t1 r_t1", "using \\<open>?t1 = T v_t1 l_t1 r_t1\\<close>"], ["proof (prove)\nusing this:\n  snd (removeLeaf t) = T v_t1 l_t1 r_t1\n\ngoal (1 subgoal):\n 1. set_val (snd (removeLeaf t)) (fst (removeLeaf t)) =\n    T (fst (removeLeaf t)) l_t1 r_t1", "by auto"], ["proof (state)\nthis:\n  set_val (snd (removeLeaf t)) (fst (removeLeaf t)) =\n  T (fst (removeLeaf t)) l_t1 r_t1\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "hence \"is_heap (siftDown (set_val ?t1 ?v1))\""], ["proof (prove)\nusing this:\n  set_val (snd (removeLeaf t)) (fst (removeLeaf t)) =\n  T (fst (removeLeaf t)) l_t1 r_t1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t))))", "using \\<open>is_heap l_t1\\<close> \\<open>is_heap r_t1\\<close>"], ["proof (prove)\nusing this:\n  set_val (snd (removeLeaf t)) (fst (removeLeaf t)) =\n  T (fst (removeLeaf t)) l_t1 r_t1\n  is_heap l_t1\n  is_heap r_t1\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t))))", "using siftDown_heap_is_heap[of l_t1 r_t1 \"set_val ?t1 ?v1\" ?v1]"], ["proof (prove)\nusing this:\n  set_val (snd (removeLeaf t)) (fst (removeLeaf t)) =\n  T (fst (removeLeaf t)) l_t1 r_t1\n  is_heap l_t1\n  is_heap r_t1\n  \\<lbrakk>is_heap l_t1; is_heap r_t1;\n   set_val (snd (removeLeaf t)) (fst (removeLeaf t)) =\n   T (fst (removeLeaf t)) l_t1 r_t1\\<rbrakk>\n  \\<Longrightarrow> is_heap\n                     (siftDown\n                       (set_val (snd (removeLeaf t)) (fst (removeLeaf t))))\n\ngoal (1 subgoal):\n 1. is_heap (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t))))", "by auto"], ["proof (state)\nthis:\n  is_heap (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t))))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "have \"t' = siftDown (set_val ?t1 ?v1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))", "using \\<open>(v', t') = hs_remove_max t\\<close> False"], ["proof (prove)\nusing this:\n  (v', t') = hs_remove_max t\n  snd (removeLeaf t) \\<noteq> E\n\ngoal (1 subgoal):\n 1. t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))", "by (auto simp add: hs_remove_max_def) (metis prod.inject)"], ["proof (state)\nthis:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n\ngoal (1 subgoal):\n 1. snd (removeLeaf t) \\<noteq> E \\<Longrightarrow> is_heap (id t')", "thus ?thesis"], ["proof (prove)\nusing this:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n\ngoal (1 subgoal):\n 1. is_heap (id t')", "using \\<open>is_heap (siftDown (set_val ?t1 ?v1))\\<close>"], ["proof (prove)\nusing this:\n  t' = siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t)))\n  is_heap (siftDown (set_val (snd (removeLeaf t)) (fst (removeLeaf t))))\n\ngoal (1 subgoal):\n 1. is_heap (id t')", "by auto"], ["proof (state)\nthis:\n  is_heap (id t')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (id t')\n\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t m t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "let ?t1 = \"snd (removeLeaf t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "assume \"\\<not> hs_is_empty t\" \"(m, t') = hs_remove_max t\""], ["proof (state)\nthis:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "hence \"m = val t\""], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. m = val t", "apply (simp add: hs_remove_max_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> E;\n     (m, t') =\n     (let t' = snd (removeLeaf t)\n      in if t' = E then (val t, E)\n         else (val t, siftDown (set_val t' (fst (removeLeaf t)))))\\<rbrakk>\n    \\<Longrightarrow> m = val t", "apply (cases \"?t1 = E\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t \\<noteq> E;\n     (m, t') =\n     (let t' = snd (removeLeaf t)\n      in if t' = E then (val t, E)\n         else (val t, siftDown (set_val t' (fst (removeLeaf t)))));\n     snd (removeLeaf t) = E\\<rbrakk>\n    \\<Longrightarrow> m = val t\n 2. \\<lbrakk>t \\<noteq> E;\n     (m, t') =\n     (let t' = snd (removeLeaf t)\n      in if t' = E then (val t, E)\n         else (val t, siftDown (set_val t' (fst (removeLeaf t)))));\n     snd (removeLeaf t) \\<noteq> E\\<rbrakk>\n    \\<Longrightarrow> m = val t", "by (auto, metis prod.inject)"], ["proof (state)\nthis:\n  m = val t\n\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "thus \"m = val (id t)\""], ["proof (prove)\nusing this:\n  m = val t\n\ngoal (1 subgoal):\n 1. m = val (id t)", "by auto"], ["proof (state)\nthis:\n  m = val (id t)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}