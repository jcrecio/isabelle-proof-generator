{"file_name": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort/SelectionSort_Functional.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort", "problem_names": ["lemma max_Max_commute: \n  \"finite A \\<Longrightarrow> max (Max (insert m A)) x = max m (Max (insert x A))\"", "lemma remove_max_max_lemma:\n  shows \"fst (foldl f (m, t) l) =  Max (set (m # l))\"", "lemma remove_max_max:\n  assumes \"l \\<noteq> []\" \"(m, l') = remove_max l\"\n  shows \"m = Max (set l)\"", "lemma remove_max_mset_lemma:\n  assumes \"(m, l') = foldl f (m', t') l\"\n  shows \"mset (m # l') = mset (m' # t' @ l)\"", "lemma remove_max_mset:\n  assumes \"l \\<noteq> []\" \"(m, l') = remove_max l\" \n  shows \"add_mset m (mset l') = mset l\""], "translations": [["", "lemma max_Max_commute: \n  \"finite A \\<Longrightarrow> max (Max (insert m A)) x = max m (Max (insert x A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    max (Max (insert m A)) x = max m (Max (insert x A))", "apply (cases \"A = {}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> max (Max (insert m A)) x = max m (Max (insert x A))", "by (metis Max_insert max.commute max.left_commute)"], ["", "text\\<open>The function really returned the\nmaximum value.\\<close>"], ["", "lemma remove_max_max_lemma:\n  shows \"fst (foldl f (m, t) l) =  Max (set (m # l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl f (m, t) l) = Max (SelectionSort_Functional.set (m # l))", "proof (induct l arbitrary: m t rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m t.\n       fst (foldl f (m, t) []) = Max (SelectionSort_Functional.set [m])\n 2. \\<And>x xs m t.\n       (\\<And>m t.\n           fst (foldl f (m, t) xs) =\n           Max (SelectionSort_Functional.set (m # xs))) \\<Longrightarrow>\n       fst (foldl f (m, t) (xs @ [x])) =\n       Max (SelectionSort_Functional.set (m # xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  fst (foldl f (?m, ?t) xs) = Max (SelectionSort_Functional.set (?m # xs))\n\ngoal (2 subgoals):\n 1. \\<And>m t.\n       fst (foldl f (m, t) []) = Max (SelectionSort_Functional.set [m])\n 2. \\<And>x xs m t.\n       (\\<And>m t.\n           fst (foldl f (m, t) xs) =\n           Max (SelectionSort_Functional.set (m # xs))) \\<Longrightarrow>\n       fst (foldl f (m, t) (xs @ [x])) =\n       Max (SelectionSort_Functional.set (m # xs @ [x]))", "let ?a = \"foldl f (m, t) xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m t.\n       fst (foldl f (m, t) []) = Max (SelectionSort_Functional.set [m])\n 2. \\<And>x xs m t.\n       (\\<And>m t.\n           fst (foldl f (m, t) xs) =\n           Max (SelectionSort_Functional.set (m # xs))) \\<Longrightarrow>\n       fst (foldl f (m, t) (xs @ [x])) =\n       Max (SelectionSort_Functional.set (m # xs @ [x]))", "let ?m' = \"fst ?a\" and ?t' = \"snd ?a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m t.\n       fst (foldl f (m, t) []) = Max (SelectionSort_Functional.set [m])\n 2. \\<And>x xs m t.\n       (\\<And>m t.\n           fst (foldl f (m, t) xs) =\n           Max (SelectionSort_Functional.set (m # xs))) \\<Longrightarrow>\n       fst (foldl f (m, t) (xs @ [x])) =\n       Max (SelectionSort_Functional.set (m # xs @ [x]))", "have \"fst (foldl f (m, t) (xs @ [x])) = max ?m' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (foldl f (m, t) (xs @ [x])) = max (fst (foldl f (m, t) xs)) x", "by (cases ?a) (auto simp add: max_def)"], ["proof (state)\nthis:\n  fst (foldl f (m, t) (xs @ [x])) = max (fst (foldl f (m, t) xs)) x\n\ngoal (2 subgoals):\n 1. \\<And>m t.\n       fst (foldl f (m, t) []) = Max (SelectionSort_Functional.set [m])\n 2. \\<And>x xs m t.\n       (\\<And>m t.\n           fst (foldl f (m, t) xs) =\n           Max (SelectionSort_Functional.set (m # xs))) \\<Longrightarrow>\n       fst (foldl f (m, t) (xs @ [x])) =\n       Max (SelectionSort_Functional.set (m # xs @ [x]))", "thus ?case"], ["proof (prove)\nusing this:\n  fst (foldl f (m, t) (xs @ [x])) = max (fst (foldl f (m, t) xs)) x\n\ngoal (1 subgoal):\n 1. fst (foldl f (m, t) (xs @ [x])) =\n    Max (SelectionSort_Functional.set (m # xs @ [x]))", "using snoc"], ["proof (prove)\nusing this:\n  fst (foldl f (m, t) (xs @ [x])) = max (fst (foldl f (m, t) xs)) x\n  fst (foldl f (?m, ?t) xs) = Max (SelectionSort_Functional.set (?m # xs))\n\ngoal (1 subgoal):\n 1. fst (foldl f (m, t) (xs @ [x])) =\n    Max (SelectionSort_Functional.set (m # xs @ [x]))", "by (simp add: max_Max_commute)"], ["proof (state)\nthis:\n  fst (foldl f (m, t) (xs @ [x])) =\n  Max (SelectionSort_Functional.set (m # xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>m t.\n       fst (foldl f (m, t) []) = Max (SelectionSort_Functional.set [m])", "qed simp"], ["", "lemma remove_max_max:\n  assumes \"l \\<noteq> []\" \"(m, l') = remove_max l\"\n  shows \"m = Max (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = Max (SelectionSort_Functional.set l)", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. m = Max (SelectionSort_Functional.set l)", "unfolding remove_max_def"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (m, l') = foldl f (hd l, []) (tl l)\n\ngoal (1 subgoal):\n 1. m = Max (SelectionSort_Functional.set l)", "using remove_max_max_lemma[of \"hd l\" \"[]\" \"tl l\"]"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (m, l') = foldl f (hd l, []) (tl l)\n  fst (foldl f (hd l, []) (tl l)) =\n  Max (SelectionSort_Functional.set (hd l # tl l))\n\ngoal (1 subgoal):\n 1. m = Max (SelectionSort_Functional.set l)", "using fst_conv[of m l']"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (m, l') = foldl f (hd l, []) (tl l)\n  fst (foldl f (hd l, []) (tl l)) =\n  Max (SelectionSort_Functional.set (hd l # tl l))\n  fst (m, l') = m\n\ngoal (1 subgoal):\n 1. m = Max (SelectionSort_Functional.set l)", "by simp"], ["", "text\\<open>Nothing new is added in the list and noting is deleted\nfrom the list except the maximum element.\\<close>"], ["", "lemma remove_max_mset_lemma:\n  assumes \"(m, l') = foldl f (m', t') l\"\n  shows \"mset (m # l') = mset (m' # t' @ l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (m # l') = mset (m' # t' @ l)", "using assms"], ["proof (prove)\nusing this:\n  (m, l') = foldl f (m', t') l\n\ngoal (1 subgoal):\n 1. mset (m # l') = mset (m' # t' @ l)", "proof (induct l arbitrary: l' m m' t' rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l' m m' t'.\n       (m, l') = foldl f (m', t') [] \\<Longrightarrow>\n       mset (m # l') = mset (m' # t' @ [])\n 2. \\<And>x xs l' m m' t'.\n       \\<lbrakk>\\<And>l' m m' t'.\n                   (m, l') = foldl f (m', t') xs \\<Longrightarrow>\n                   mset (m # l') = mset (m' # t' @ xs);\n        (m, l') = foldl f (m', t') (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> mset (m # l') = mset (m' # t' @ xs @ [x])", "case (snoc x xs)"], ["proof (state)\nthis:\n  (?m, ?l') = foldl f (?m', ?t') xs \\<Longrightarrow>\n  mset (?m # ?l') = mset (?m' # ?t' @ xs)\n  (m, l') = foldl f (m', t') (xs @ [x])\n\ngoal (2 subgoals):\n 1. \\<And>l' m m' t'.\n       (m, l') = foldl f (m', t') [] \\<Longrightarrow>\n       mset (m # l') = mset (m' # t' @ [])\n 2. \\<And>x xs l' m m' t'.\n       \\<lbrakk>\\<And>l' m m' t'.\n                   (m, l') = foldl f (m', t') xs \\<Longrightarrow>\n                   mset (m # l') = mset (m' # t' @ xs);\n        (m, l') = foldl f (m', t') (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> mset (m # l') = mset (m' # t' @ xs @ [x])", "let ?a = \"foldl f (m', t') xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l' m m' t'.\n       (m, l') = foldl f (m', t') [] \\<Longrightarrow>\n       mset (m # l') = mset (m' # t' @ [])\n 2. \\<And>x xs l' m m' t'.\n       \\<lbrakk>\\<And>l' m m' t'.\n                   (m, l') = foldl f (m', t') xs \\<Longrightarrow>\n                   mset (m # l') = mset (m' # t' @ xs);\n        (m, l') = foldl f (m', t') (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> mset (m # l') = mset (m' # t' @ xs @ [x])", "let ?m' = \"fst ?a\" and ?t' = \"snd ?a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l' m m' t'.\n       (m, l') = foldl f (m', t') [] \\<Longrightarrow>\n       mset (m # l') = mset (m' # t' @ [])\n 2. \\<And>x xs l' m m' t'.\n       \\<lbrakk>\\<And>l' m m' t'.\n                   (m, l') = foldl f (m', t') xs \\<Longrightarrow>\n                   mset (m # l') = mset (m' # t' @ xs);\n        (m, l') = foldl f (m', t') (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> mset (m # l') = mset (m' # t' @ xs @ [x])", "have \"mset (?m' # ?t') = mset (m' # t' @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (fst (foldl f (m', t') xs) # snd (foldl f (m', t') xs)) =\n    mset (m' # t' @ xs)", "using snoc(1)[of ?m' ?t' m' t']"], ["proof (prove)\nusing this:\n  (fst (foldl f (m', t') xs), snd (foldl f (m', t') xs)) =\n  foldl f (m', t') xs \\<Longrightarrow>\n  mset (fst (foldl f (m', t') xs) # snd (foldl f (m', t') xs)) =\n  mset (m' # t' @ xs)\n\ngoal (1 subgoal):\n 1. mset (fst (foldl f (m', t') xs) # snd (foldl f (m', t') xs)) =\n    mset (m' # t' @ xs)", "by simp"], ["proof (state)\nthis:\n  mset (fst (foldl f (m', t') xs) # snd (foldl f (m', t') xs)) =\n  mset (m' # t' @ xs)\n\ngoal (2 subgoals):\n 1. \\<And>l' m m' t'.\n       (m, l') = foldl f (m', t') [] \\<Longrightarrow>\n       mset (m # l') = mset (m' # t' @ [])\n 2. \\<And>x xs l' m m' t'.\n       \\<lbrakk>\\<And>l' m m' t'.\n                   (m, l') = foldl f (m', t') xs \\<Longrightarrow>\n                   mset (m # l') = mset (m' # t' @ xs);\n        (m, l') = foldl f (m', t') (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> mset (m # l') = mset (m' # t' @ xs @ [x])", "thus ?case"], ["proof (prove)\nusing this:\n  mset (fst (foldl f (m', t') xs) # snd (foldl f (m', t') xs)) =\n  mset (m' # t' @ xs)\n\ngoal (1 subgoal):\n 1. mset (m # l') = mset (m' # t' @ xs @ [x])", "using snoc(2)"], ["proof (prove)\nusing this:\n  mset (fst (foldl f (m', t') xs) # snd (foldl f (m', t') xs)) =\n  mset (m' # t' @ xs)\n  (m, l') = foldl f (m', t') (xs @ [x])\n\ngoal (1 subgoal):\n 1. mset (m # l') = mset (m' # t' @ xs @ [x])", "apply (cases \"?a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>mset\n                 (fst (foldl f (m', t') xs) # snd (foldl f (m', t') xs)) =\n                mset (m' # t' @ xs);\n        (m, l') = foldl f (m', t') (xs @ [x]);\n        foldl f (m', t') xs = (a, b)\\<rbrakk>\n       \\<Longrightarrow> mset (m # l') = mset (m' # t' @ xs @ [x])", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  mset (m # l') = mset (m' # t' @ xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>l' m m' t'.\n       (m, l') = foldl f (m', t') [] \\<Longrightarrow>\n       mset (m # l') = mset (m' # t' @ [])", "qed simp"], ["", "lemma remove_max_mset:\n  assumes \"l \\<noteq> []\" \"(m, l') = remove_max l\" \n  shows \"add_mset m (mset l') = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset m (mset l') = mset l", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. add_mset m (mset l') = mset l", "unfolding remove_max_def"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (m, l') = foldl f (hd l, []) (tl l)\n\ngoal (1 subgoal):\n 1. add_mset m (mset l') = mset l", "using remove_max_mset_lemma[of m l' \"hd l\" \"[]\" \"tl l\"]"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  (m, l') = foldl f (hd l, []) (tl l)\n  (m, l') = foldl f (hd l, []) (tl l) \\<Longrightarrow>\n  mset (m # l') = mset (hd l # [] @ tl l)\n\ngoal (1 subgoal):\n 1. add_mset m (mset l') = mset l", "by auto"], ["", "definition ssf_ssort' where\n  [simp, code del]: \"ssf_ssort' = RemoveMax.ssort' (\\<lambda> l. l = []) remove_max\""], ["", "definition ssf_ssort where \n  [simp, code del]: \"ssf_ssort = RemoveMax.ssort (\\<lambda> l. l = []) id remove_max\""], ["", "interpretation SSRemoveMax: \n  RemoveMax \"[]\" \"\\<lambda> l. l = []\" id mset remove_max \"\\<lambda> _. True\" \n  rewrites\n \"RemoveMax.ssort' (\\<lambda> l. l = []) remove_max = ssf_ssort'\" and\n \"RemoveMax.ssort (\\<lambda> l. l = []) id remove_max = ssf_ssort\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RemoveMax [] (\\<lambda>l. l = []) id mset remove_max\n     (\\<lambda>_. True) &&&\n    RemoveMax.ssort' (\\<lambda>l. l = []) remove_max = ssf_ssort' &&&\n    RemoveMax.ssort (\\<lambda>l. l = []) id remove_max = ssf_ssort", "using remove_max_max"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<noteq> []; (?m, ?l') = remove_max ?l\\<rbrakk>\n  \\<Longrightarrow> ?m = Max (SelectionSort_Functional.set ?l)\n\ngoal (1 subgoal):\n 1. RemoveMax [] (\\<lambda>l. l = []) id mset remove_max\n     (\\<lambda>_. True) &&&\n    RemoveMax.ssort' (\\<lambda>l. l = []) remove_max = ssf_ssort' &&&\n    RemoveMax.ssort (\\<lambda>l. l = []) id remove_max = ssf_ssort", "by (unfold_locales, auto simp add: remove_max_mset)"], ["", "end"]]}