{"file_name": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort/RemoveMax.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort", "problem_names": ["lemma is_empty_as_list: \"is_empty e \\<Longrightarrow> multiset e = {#}\"", "lemma remove_max_multiset_size: \n  \"\\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> \n               size (multiset l) > size (multiset l')\"", "lemma remove_max_set: \n  \"\\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> \n                                 set l' \\<union> {m} = set l\"", "lemma ssort'_termination:\n  assumes \"inv (fst p)\"\n  shows \"ssort'_dom p\"", "lemma ssort'Induct:\n  assumes \"inv l\" \"P l sl\"\n   \"\\<And> l sl m l'. \n    \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l; P l sl\\<rbrakk> \\<Longrightarrow> P l' (m # sl)\"\n  shows \"P empty (ssort' l sl)\"", "lemma mset_ssort':\n  assumes \"inv l\"\n  shows \"mset (ssort' l sl) = multiset l + mset sl\"", "lemma sorted_ssort':\n  assumes \"inv l\" \"sorted sl \\<and> (\\<forall> x \\<in> set l. (\\<forall> y \\<in> List.set sl. x \\<le> y))\"\n  shows \"sorted (ssort' l sl)\"", "lemma sorted_ssort: \"sorted (ssort i)\"", "lemma permutation_ssort: \"ssort l <~~> l\""], "translations": [["", "lemma is_empty_as_list: \"is_empty e \\<Longrightarrow> multiset e = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_empty e \\<Longrightarrow> multiset e = {#}", "using is_empty_inj multiset_empty"], ["proof (prove)\nusing this:\n  is_empty ?e \\<Longrightarrow> ?e = empty\n  multiset empty = {#}\n\ngoal (1 subgoal):\n 1. is_empty e \\<Longrightarrow> multiset e = {#}", "by auto"], ["", "definition set :: \"'b \\<Rightarrow> 'a set\" where\n     [simp]: \"set l = set_mset (multiset l)\""], ["", "end"], ["", "subsection \\<open>Function remove\\_max\\<close>"], ["", "text\\<open>\nWe wanted to emphasize that algorithms are same. Due to\nthe complexity of the implementation it usually happens that simple\nproperties are omitted, such as the connection between these two\nsorting algorithms. This is a key feature that should be presented to\nstudents in order to understand these algorithms. It is not unknown\nthat students usually prefer selection sort for its simplicity whereas\navoid heap sort for its complexity. However, if we can present them as\nthe algorithms that are same they may hesitate less in using the heap\nsort. This is why the refinement is important. Using this technique we\nwere able to notice these characteristics. Separate verification would\nnot bring anything new. Being on the abstract level does not only\nsimplify the verifications, but also helps us to notice and to show\nstudents important features. Even further, we can prove them formally\nand completely justify our observation.\n\\<close>"], ["", "locale RemoveMax = Collection empty is_empty of_list  multiset for \n  empty :: \"'b\" and \n  is_empty :: \"'b \\<Rightarrow> bool\" and \n  of_list :: \"'a::linorder list \\<Rightarrow> 'b\" and \n  multiset :: \"'b \\<Rightarrow> 'a::linorder multiset\" + \n  fixes remove_max :: \"'b \\<Rightarrow> 'a \\<times> 'b\"\n  \\<comment> \\<open>--- Function that removes maximum element from the object of type $'b$. \n      It returns maximum element and the object without that maximum element.\\<close>\n  fixes inv :: \"'b \\<Rightarrow> bool\"\n  \\<comment> \\<open>--- It checks weather the object is in required condition.\n      For example, if we expect to work with heap it checks weather the object \n      is heap. This is called {\\em invariant condition}\\<close>\n  assumes of_list_inv: \"inv (of_list x)\"\n  \\<comment> \\<open>--- This condition assures that function {\\em of\\_list}\n      made a object with desired property.\\<close>\n  assumes remove_max_max: \n     \"\\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> m = Max (set l)\"\n  \\<comment> \\<open>--- First parameter of the return value of the \n      function {\\em remove\\_max} is the maximum element\\<close>\n  assumes remove_max_multiset: \n     \"\\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> \n      add_mset m (multiset l') = multiset l\"\n  \\<comment> \\<open>--- Condition for multiset, ensures that nothing new is added or nothing \n      is lost after applying {\\em remove\\_max} function.\\<close>\n  assumes remove_max_inv: \n     \"\\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> inv l'\"\n  \\<comment> \\<open>--- Ensures that invariant condition is true after removing maximum element. \n      Invariant condition must be true in each step of sorting algorithm, for example\n      if we are sorting using heap than in each iteration we must have heap and function\n      {\\em remove\\_max} must not change that.\\<close>\nbegin"], ["", "lemma remove_max_multiset_size: \n  \"\\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> \n               size (multiset l) > size (multiset l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n    \\<Longrightarrow> size (multiset l') < size (multiset l)", "using remove_max_multiset[of l m l']"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> add_mset m (multiset l') = multiset l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n    \\<Longrightarrow> size (multiset l') < size (multiset l)", "by (metis mset_subset_size multi_psub_of_add_self)"], ["", "lemma remove_max_set: \n  \"\\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> \n                                 set l' \\<union> {m} = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n    \\<Longrightarrow> local.set l' \\<union> {m} = local.set l", "using remove_max_multiset[of l m l']"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> add_mset m (multiset l') = multiset l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n    \\<Longrightarrow> local.set l' \\<union> {m} = local.set l", "by (metis Un_insert_right local.set_def set_mset_add_mset_insert sup_bot_right)"], ["", "text\\<open>As it is said before\nin each iteration invariant condition must be satisfied, so the {\\em\n  inv l} is always true, e.g. before and after execution of any\nfunction. This is also the reason why sort function must be defined as\npartial. This function parameters stay the same in each step of\niteration -- list stays list, and heap stays heap. As we said before,\nin Isabelle/HOL we can only define total function, but there is a\nmechanism that enables total function to appear as partial one:\\<close>"], ["", "partial_function (tailrec) ssort' where \n  \"ssort' l sl = \n      (if is_empty l then \n          sl\n       else \n          let \n            (m, l') = remove_max l \n          in\n            ssort' l' (m # sl))\""], ["", "declare ssort'.simps[code]"], ["", "definition ssort :: \"'a list \\<Rightarrow> 'a list\" where \n  \"ssort l = ssort' (of_list l) []\""], ["", "inductive ssort'_dom where\n   step: \"\\<lbrakk>\\<And>m l'. \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l\\<rbrakk> \\<Longrightarrow> \n                  ssort'_dom (l', m # sl)\\<rbrakk> \\<Longrightarrow> ssort'_dom (l, sl)\""], ["", "lemma ssort'_termination:\n  assumes \"inv (fst p)\"\n  shows \"ssort'_dom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssort'_dom p", "using assms"], ["proof (prove)\nusing this:\n  inv (fst p)\n\ngoal (1 subgoal):\n 1. ssort'_dom p", "proof (induct p rule: wf_induct[of \"measure (\\<lambda>(l, sl). size (multiset l))\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(l, sl). size (multiset l)))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measure\n                          (\\<lambda>(l, sl).\n                              size (multiset l)) \\<longrightarrow>\n                   inv (fst y) \\<longrightarrow> ssort'_dom y;\n        inv (fst x)\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom x", "let ?r = \"measure (\\<lambda>(l, sl). size (multiset l))\""], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(l, sl). size (multiset l)))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measure\n                          (\\<lambda>(l, sl).\n                              size (multiset l)) \\<longrightarrow>\n                   inv (fst y) \\<longrightarrow> ssort'_dom y;\n        inv (fst x)\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom x", "fix p :: \"'b \\<times> 'a list\""], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(l, sl). size (multiset l)))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measure\n                          (\\<lambda>(l, sl).\n                              size (multiset l)) \\<longrightarrow>\n                   inv (fst y) \\<longrightarrow> ssort'_dom y;\n        inv (fst x)\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom x", "assume \"inv (fst p)\" and *: \n         \"\\<forall>y. (y, p) \\<in> ?r \\<longrightarrow> inv (fst y) \\<longrightarrow> ssort'_dom y\""], ["proof (state)\nthis:\n  inv (fst p)\n  \\<forall>y.\n     (y, p)\n     \\<in> measure (\\<lambda>(l, sl). size (multiset l)) \\<longrightarrow>\n     inv (fst y) \\<longrightarrow> ssort'_dom y\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(l, sl). size (multiset l)))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measure\n                          (\\<lambda>(l, sl).\n                              size (multiset l)) \\<longrightarrow>\n                   inv (fst y) \\<longrightarrow> ssort'_dom y;\n        inv (fst x)\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom x", "obtain l sl where \"p = (l, sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l sl. p = (l, sl) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) auto"], ["proof (state)\nthis:\n  p = (l, sl)\n\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(l, sl). size (multiset l)))\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x)\n                   \\<in> measure\n                          (\\<lambda>(l, sl).\n                              size (multiset l)) \\<longrightarrow>\n                   inv (fst y) \\<longrightarrow> ssort'_dom y;\n        inv (fst x)\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom x", "show \"ssort'_dom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssort'_dom p", "proof (subst \\<open>p = (l, sl)\\<close>, rule ssort'_dom.step)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m l'.\n       \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom (l', m # sl)", "fix m l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m l'.\n       \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom (l', m # sl)", "assume \"\\<not> is_empty l\" \"(m, l') = remove_max l\""], ["proof (state)\nthis:\n  \\<not> is_empty l\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. \\<And>m l'.\n       \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l\\<rbrakk>\n       \\<Longrightarrow> ssort'_dom (l', m # sl)", "show \"ssort'_dom (l', m#sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssort'_dom (l', m # sl)", "proof (rule *[rule_format])"], ["proof (state)\ngoal (2 subgoals):\n 1. ((l', m # sl), p) \\<in> measure (\\<lambda>(l, sl). size (multiset l))\n 2. inv (fst (l', m # sl))", "show \"((l', m#sl), p) \\<in> ?r\" \"inv (fst (l', m#sl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((l', m # sl), p)\n    \\<in> measure (\\<lambda>(l, sl). size (multiset l)) &&&\n    inv (fst (l', m # sl))", "using \\<open>p = (l, sl)\\<close> \\<open>inv (fst p)\\<close> \\<open>\\<not> is_empty l\\<close>"], ["proof (prove)\nusing this:\n  p = (l, sl)\n  inv (fst p)\n  \\<not> is_empty l\n\ngoal (1 subgoal):\n 1. ((l', m # sl), p)\n    \\<in> measure (\\<lambda>(l, sl). size (multiset l)) &&&\n    inv (fst (l', m # sl))", "using \\<open>(m, l') = remove_max l\\<close>"], ["proof (prove)\nusing this:\n  p = (l, sl)\n  inv (fst p)\n  \\<not> is_empty l\n  (m, l') = remove_max l\n\ngoal (1 subgoal):\n 1. ((l', m # sl), p)\n    \\<in> measure (\\<lambda>(l, sl). size (multiset l)) &&&\n    inv (fst (l', m # sl))", "using remove_max_inv[of l m l']"], ["proof (prove)\nusing this:\n  p = (l, sl)\n  inv (fst p)\n  \\<not> is_empty l\n  (m, l') = remove_max l\n  \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> inv l'\n\ngoal (1 subgoal):\n 1. ((l', m # sl), p)\n    \\<in> measure (\\<lambda>(l, sl). size (multiset l)) &&&\n    inv (fst (l', m # sl))", "using remove_max_multiset_size[of l m l']"], ["proof (prove)\nusing this:\n  p = (l, sl)\n  inv (fst p)\n  \\<not> is_empty l\n  (m, l') = remove_max l\n  \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> inv l'\n  \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> size (multiset l') < size (multiset l)\n\ngoal (1 subgoal):\n 1. ((l', m # sl), p)\n    \\<in> measure (\\<lambda>(l, sl). size (multiset l)) &&&\n    inv (fst (l', m # sl))", "by auto"], ["proof (state)\nthis:\n  ((l', m # sl), p) \\<in> measure (\\<lambda>(l, sl). size (multiset l))\n  inv (fst (l', m # sl))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ssort'_dom (l', m # sl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ssort'_dom p\n\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(l, sl). size (multiset l)))", "qed simp"], ["", "lemma ssort'Induct:\n  assumes \"inv l\" \"P l sl\"\n   \"\\<And> l sl m l'. \n    \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l; P l sl\\<rbrakk> \\<Longrightarrow> P l' (m # sl)\"\n  shows \"P empty (ssort' l sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "from \\<open>inv l\\<close>"], ["proof (chain)\npicking this:\n  inv l", "have \"ssort'_dom (l, sl)\""], ["proof (prove)\nusing this:\n  inv l\n\ngoal (1 subgoal):\n 1. ssort'_dom (l, sl)", "using ssort'_termination"], ["proof (prove)\nusing this:\n  inv l\n  inv (fst ?p) \\<Longrightarrow> ssort'_dom ?p\n\ngoal (1 subgoal):\n 1. ssort'_dom (l, sl)", "by auto"], ["proof (state)\nthis:\n  ssort'_dom (l, sl)\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ssort'_dom (l, sl)\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "using assms"], ["proof (prove)\nusing this:\n  ssort'_dom (l, sl)\n  inv l\n  P l sl\n  \\<lbrakk>\\<not> is_empty ?l; inv ?l; (?m, ?l') = remove_max ?l;\n   P ?l ?sl\\<rbrakk>\n  \\<Longrightarrow> P ?l' (?m # ?sl)\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "proof (induct \"(l, sl)\" arbitrary: l sl rule: ssort'_dom.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l sl.\n       \\<lbrakk>\\<And>m l'.\n                   \\<lbrakk>\\<not> is_empty l;\n                    (m, l') = remove_max l\\<rbrakk>\n                   \\<Longrightarrow> ssort'_dom (l', m # sl);\n        \\<And>m l'.\n           \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l; inv l';\n            P l' (m # sl);\n            \\<And>l m l' sl.\n               \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n                P l sl\\<rbrakk>\n               \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n           \\<Longrightarrow> P empty (ssort' l' (m # sl));\n        inv l; P l sl;\n        \\<And>l m l' sl.\n           \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n            P l sl\\<rbrakk>\n           \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n       \\<Longrightarrow> P empty (ssort' l sl)", "case (step l sl)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> is_empty l; (?m, ?l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> ssort'_dom (?l', ?m # sl)\n  \\<lbrakk>\\<not> is_empty l; (?m, ?l') = remove_max l; inv ?l';\n   P ?l' (?m # sl);\n   \\<And>l m l' sl.\n      \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n       P l sl\\<rbrakk>\n      \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n  \\<Longrightarrow> P empty (ssort' ?l' (?m # sl))\n  inv l\n  P l sl\n  \\<lbrakk>\\<not> is_empty ?l; inv ?l; (?m, ?l') = remove_max ?l;\n   P ?l ?sl\\<rbrakk>\n  \\<Longrightarrow> P ?l' (?m # ?sl)\n\ngoal (1 subgoal):\n 1. \\<And>l sl.\n       \\<lbrakk>\\<And>m l'.\n                   \\<lbrakk>\\<not> is_empty l;\n                    (m, l') = remove_max l\\<rbrakk>\n                   \\<Longrightarrow> ssort'_dom (l', m # sl);\n        \\<And>m l'.\n           \\<lbrakk>\\<not> is_empty l; (m, l') = remove_max l; inv l';\n            P l' (m # sl);\n            \\<And>l m l' sl.\n               \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n                P l sl\\<rbrakk>\n               \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n           \\<Longrightarrow> P empty (ssort' l' (m # sl));\n        inv l; P l sl;\n        \\<And>l m l' sl.\n           \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n            P l sl\\<rbrakk>\n           \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n       \\<Longrightarrow> P empty (ssort' l sl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "proof (cases \"is_empty l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_empty l \\<Longrightarrow> P empty (ssort' l sl)\n 2. \\<not> is_empty l \\<Longrightarrow> P empty (ssort' l sl)", "case True"], ["proof (state)\nthis:\n  is_empty l\n\ngoal (2 subgoals):\n 1. is_empty l \\<Longrightarrow> P empty (ssort' l sl)\n 2. \\<not> is_empty l \\<Longrightarrow> P empty (ssort' l sl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_empty l\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "using step(4) step(5) ssort'.simps[of l sl] is_empty_inj[of l]"], ["proof (prove)\nusing this:\n  is_empty l\n  P l sl\n  \\<lbrakk>\\<not> is_empty ?l; inv ?l; (?m, ?l') = remove_max ?l;\n   P ?l ?sl\\<rbrakk>\n  \\<Longrightarrow> P ?l' (?m # ?sl)\n  ssort' l sl =\n  (if is_empty l then sl\n   else let (m, l') = remove_max l in ssort' l' (m # sl))\n  is_empty l \\<Longrightarrow> l = empty\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "by simp"], ["proof (state)\nthis:\n  P empty (ssort' l sl)\n\ngoal (1 subgoal):\n 1. \\<not> is_empty l \\<Longrightarrow> P empty (ssort' l sl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_empty l \\<Longrightarrow> P empty (ssort' l sl)", "case False"], ["proof (state)\nthis:\n  \\<not> is_empty l\n\ngoal (1 subgoal):\n 1. \\<not> is_empty l \\<Longrightarrow> P empty (ssort' l sl)", "let ?p = \"remove_max l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_empty l \\<Longrightarrow> P empty (ssort' l sl)", "let ?m = \"fst ?p\" and ?l' = \"snd ?p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_empty l \\<Longrightarrow> P empty (ssort' l sl)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "using False step(2)[of ?m ?l'] step(3)"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  \\<lbrakk>\\<not> is_empty l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l;\n   inv (snd (remove_max l));\n   P (snd (remove_max l)) (fst (remove_max l) # sl);\n   \\<And>l m l' sl.\n      \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n       P l sl\\<rbrakk>\n      \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n  \\<Longrightarrow> P empty\n                     (ssort' (snd (remove_max l)) (fst (remove_max l) # sl))\n  inv l\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "using step(4) step(5)[of l ?m ?l' sl] step(5)"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  \\<lbrakk>\\<not> is_empty l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l;\n   inv (snd (remove_max l));\n   P (snd (remove_max l)) (fst (remove_max l) # sl);\n   \\<And>l m l' sl.\n      \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n       P l sl\\<rbrakk>\n      \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n  \\<Longrightarrow> P empty\n                     (ssort' (snd (remove_max l)) (fst (remove_max l) # sl))\n  inv l\n  P l sl\n  \\<lbrakk>\\<not> is_empty l; inv l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l; P l sl\\<rbrakk>\n  \\<Longrightarrow> P (snd (remove_max l)) (fst (remove_max l) # sl)\n  \\<lbrakk>\\<not> is_empty ?l; inv ?l; (?m, ?l') = remove_max ?l;\n   P ?l ?sl\\<rbrakk>\n  \\<Longrightarrow> P ?l' (?m # ?sl)\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "using remove_max_inv[of l ?m ?l']"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  \\<lbrakk>\\<not> is_empty l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l;\n   inv (snd (remove_max l));\n   P (snd (remove_max l)) (fst (remove_max l) # sl);\n   \\<And>l m l' sl.\n      \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n       P l sl\\<rbrakk>\n      \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n  \\<Longrightarrow> P empty\n                     (ssort' (snd (remove_max l)) (fst (remove_max l) # sl))\n  inv l\n  P l sl\n  \\<lbrakk>\\<not> is_empty l; inv l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l; P l sl\\<rbrakk>\n  \\<Longrightarrow> P (snd (remove_max l)) (fst (remove_max l) # sl)\n  \\<lbrakk>\\<not> is_empty ?l; inv ?l; (?m, ?l') = remove_max ?l;\n   P ?l ?sl\\<rbrakk>\n  \\<Longrightarrow> P ?l' (?m # ?sl)\n  \\<lbrakk>\\<not> is_empty l; inv l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l\\<rbrakk>\n  \\<Longrightarrow> inv (snd (remove_max l))\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "using ssort'.simps[of l sl]"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  \\<lbrakk>\\<not> is_empty l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l;\n   inv (snd (remove_max l));\n   P (snd (remove_max l)) (fst (remove_max l) # sl);\n   \\<And>l m l' sl.\n      \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n       P l sl\\<rbrakk>\n      \\<Longrightarrow> P l' (m # sl)\\<rbrakk>\n  \\<Longrightarrow> P empty\n                     (ssort' (snd (remove_max l)) (fst (remove_max l) # sl))\n  inv l\n  P l sl\n  \\<lbrakk>\\<not> is_empty l; inv l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l; P l sl\\<rbrakk>\n  \\<Longrightarrow> P (snd (remove_max l)) (fst (remove_max l) # sl)\n  \\<lbrakk>\\<not> is_empty ?l; inv ?l; (?m, ?l') = remove_max ?l;\n   P ?l ?sl\\<rbrakk>\n  \\<Longrightarrow> P ?l' (?m # ?sl)\n  \\<lbrakk>\\<not> is_empty l; inv l;\n   (fst (remove_max l), snd (remove_max l)) = remove_max l\\<rbrakk>\n  \\<Longrightarrow> inv (snd (remove_max l))\n  ssort' l sl =\n  (if is_empty l then sl\n   else let (m, l') = remove_max l in ssort' l' (m # sl))\n\ngoal (1 subgoal):\n 1. P empty (ssort' l sl)", "by (cases ?p) auto"], ["proof (state)\nthis:\n  P empty (ssort' l sl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P empty (ssort' l sl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P empty (ssort' l sl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_ssort':\n  assumes \"inv l\"\n  shows \"mset (ssort' l sl) = multiset l + mset sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (ssort' l sl) = multiset l + mset sl", "using assms"], ["proof (prove)\nusing this:\n  inv l\n\ngoal (1 subgoal):\n 1. mset (ssort' l sl) = multiset l + mset sl", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inv l \\<Longrightarrow> mset (ssort' l sl) = multiset l + mset sl", "have \"multiset empty + mset (ssort' l sl) = multiset l + mset sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiset empty + mset (ssort' l sl) = multiset l + mset sl", "using assms"], ["proof (prove)\nusing this:\n  inv l\n\ngoal (1 subgoal):\n 1. multiset empty + mset (ssort' l sl) = multiset l + mset sl", "proof (rule ssort'Induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. multiset l + mset sl = multiset l + mset sl\n 2. \\<And>la sla m l'.\n       \\<lbrakk>\\<not> is_empty la; inv la; (m, l') = remove_max la;\n        multiset la + mset sla = multiset l + mset sl\\<rbrakk>\n       \\<Longrightarrow> multiset l' + mset (m # sla) = multiset l + mset sl", "fix l1 sl1 m l'"], ["proof (state)\ngoal (2 subgoals):\n 1. multiset l + mset sl = multiset l + mset sl\n 2. \\<And>la sla m l'.\n       \\<lbrakk>\\<not> is_empty la; inv la; (m, l') = remove_max la;\n        multiset la + mset sla = multiset l + mset sl\\<rbrakk>\n       \\<Longrightarrow> multiset l' + mset (m # sla) = multiset l + mset sl", "assume \"\\<not> is_empty l1\" \n             \"inv l1\" \n             \"(m, l') = remove_max l1\" \n             \"multiset l1 + mset sl1 = multiset l + mset sl\""], ["proof (state)\nthis:\n  \\<not> is_empty l1\n  inv l1\n  (m, l') = remove_max l1\n  multiset l1 + mset sl1 = multiset l + mset sl\n\ngoal (2 subgoals):\n 1. multiset l + mset sl = multiset l + mset sl\n 2. \\<And>la sla m l'.\n       \\<lbrakk>\\<not> is_empty la; inv la; (m, l') = remove_max la;\n        multiset la + mset sla = multiset l + mset sl\\<rbrakk>\n       \\<Longrightarrow> multiset l' + mset (m # sla) = multiset l + mset sl", "thus \"multiset l' + mset (m # sl1) = multiset l + mset sl\""], ["proof (prove)\nusing this:\n  \\<not> is_empty l1\n  inv l1\n  (m, l') = remove_max l1\n  multiset l1 + mset sl1 = multiset l + mset sl\n\ngoal (1 subgoal):\n 1. multiset l' + mset (m # sl1) = multiset l + mset sl", "using remove_max_multiset[of l1 m l']"], ["proof (prove)\nusing this:\n  \\<not> is_empty l1\n  inv l1\n  (m, l') = remove_max l1\n  multiset l1 + mset sl1 = multiset l + mset sl\n  \\<lbrakk>\\<not> is_empty l1; inv l1; (m, l') = remove_max l1\\<rbrakk>\n  \\<Longrightarrow> add_mset m (multiset l') = multiset l1\n\ngoal (1 subgoal):\n 1. multiset l' + mset (m # sl1) = multiset l + mset sl", "by (metis union_mset_add_mset_left union_mset_add_mset_right mset.simps(2))"], ["proof (state)\nthis:\n  multiset l' + mset (m # sl1) = multiset l + mset sl\n\ngoal (1 subgoal):\n 1. multiset l + mset sl = multiset l + mset sl", "qed simp"], ["proof (state)\nthis:\n  multiset empty + mset (ssort' l sl) = multiset l + mset sl\n\ngoal (1 subgoal):\n 1. inv l \\<Longrightarrow> mset (ssort' l sl) = multiset l + mset sl", "thus ?thesis"], ["proof (prove)\nusing this:\n  multiset empty + mset (ssort' l sl) = multiset l + mset sl\n\ngoal (1 subgoal):\n 1. mset (ssort' l sl) = multiset l + mset sl", "using multiset_empty"], ["proof (prove)\nusing this:\n  multiset empty + mset (ssort' l sl) = multiset l + mset sl\n  multiset empty = {#}\n\ngoal (1 subgoal):\n 1. mset (ssort' l sl) = multiset l + mset sl", "by simp"], ["proof (state)\nthis:\n  mset (ssort' l sl) = multiset l + mset sl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_ssort':\n  assumes \"inv l\" \"sorted sl \\<and> (\\<forall> x \\<in> set l. (\\<forall> y \\<in> List.set sl. x \\<le> y))\"\n  shows \"sorted (ssort' l sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (ssort' l sl)", "using assms"], ["proof (prove)\nusing this:\n  inv l\n  sorted sl \\<and>\n  (\\<forall>x\\<in>local.set l. \\<forall>y\\<in>list.set sl. x \\<le> y)\n\ngoal (1 subgoal):\n 1. sorted (ssort' l sl)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv l;\n     sorted sl \\<and>\n     (\\<forall>x\\<in>local.set l.\n         \\<forall>y\\<in>list.set sl. x \\<le> y)\\<rbrakk>\n    \\<Longrightarrow> sorted (ssort' l sl)", "have \"sorted (ssort' l sl) \\<and> \n        (\\<forall> x \\<in> set empty. (\\<forall> y \\<in> List.set (ssort' l sl). x \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (ssort' l sl) \\<and>\n    (\\<forall>x\\<in>local.set empty.\n        \\<forall>y\\<in>list.set (ssort' l sl). x \\<le> y)", "using assms"], ["proof (prove)\nusing this:\n  inv l\n  sorted sl \\<and>\n  (\\<forall>x\\<in>local.set l. \\<forall>y\\<in>list.set sl. x \\<le> y)\n\ngoal (1 subgoal):\n 1. sorted (ssort' l sl) \\<and>\n    (\\<forall>x\\<in>local.set empty.\n        \\<forall>y\\<in>list.set (ssort' l sl). x \\<le> y)", "proof (rule ssort'Induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l sl m l'.\n       \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n        sorted sl \\<and>\n        (\\<forall>x\\<in>local.set l.\n            \\<forall>y\\<in>list.set sl. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> sorted (m # sl) \\<and>\n                         (\\<forall>x\\<in>local.set l'.\n                             \\<forall>y\\<in>list.set (m # sl). x \\<le> y)", "fix l sl m l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l sl m l'.\n       \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n        sorted sl \\<and>\n        (\\<forall>x\\<in>local.set l.\n            \\<forall>y\\<in>list.set sl. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> sorted (m # sl) \\<and>\n                         (\\<forall>x\\<in>local.set l'.\n                             \\<forall>y\\<in>list.set (m # sl). x \\<le> y)", "assume \"\\<not> is_empty l\" \n           \"inv l\" \n           \"(m, l') = remove_max l\" \n           \"sorted sl \\<and> (\\<forall>x\\<in>set l. \\<forall>y\\<in>List.set sl. x \\<le> y)\""], ["proof (state)\nthis:\n  \\<not> is_empty l\n  inv l\n  (m, l') = remove_max l\n  sorted sl \\<and>\n  (\\<forall>x\\<in>local.set l. \\<forall>y\\<in>list.set sl. x \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<And>l sl m l'.\n       \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l;\n        sorted sl \\<and>\n        (\\<forall>x\\<in>local.set l.\n            \\<forall>y\\<in>list.set sl. x \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> sorted (m # sl) \\<and>\n                         (\\<forall>x\\<in>local.set l'.\n                             \\<forall>y\\<in>list.set (m # sl). x \\<le> y)", "thus \"sorted (m # sl) \\<and> (\\<forall>x\\<in>set l'. \\<forall>y\\<in>List.set (m # sl). x \\<le> y)\""], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  inv l\n  (m, l') = remove_max l\n  sorted sl \\<and>\n  (\\<forall>x\\<in>local.set l. \\<forall>y\\<in>list.set sl. x \\<le> y)\n\ngoal (1 subgoal):\n 1. sorted (m # sl) \\<and>\n    (\\<forall>x\\<in>local.set l'.\n        \\<forall>y\\<in>list.set (m # sl). x \\<le> y)", "using remove_max_set[of l m l'] remove_max_max[of l m l']"], ["proof (prove)\nusing this:\n  \\<not> is_empty l\n  inv l\n  (m, l') = remove_max l\n  sorted sl \\<and>\n  (\\<forall>x\\<in>local.set l. \\<forall>y\\<in>list.set sl. x \\<le> y)\n  \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> local.set l' \\<union> {m} = local.set l\n  \\<lbrakk>\\<not> is_empty l; inv l; (m, l') = remove_max l\\<rbrakk>\n  \\<Longrightarrow> m = Max (local.set l)\n\ngoal (1 subgoal):\n 1. sorted (m # sl) \\<and>\n    (\\<forall>x\\<in>local.set l'.\n        \\<forall>y\\<in>list.set (m # sl). x \\<le> y)", "by (auto intro: Max_ge)"], ["proof (state)\nthis:\n  sorted (m # sl) \\<and>\n  (\\<forall>x\\<in>local.set l'. \\<forall>y\\<in>list.set (m # sl). x \\<le> y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted (ssort' l sl) \\<and>\n  (\\<forall>x\\<in>local.set empty.\n      \\<forall>y\\<in>list.set (ssort' l sl). x \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inv l;\n     sorted sl \\<and>\n     (\\<forall>x\\<in>local.set l.\n         \\<forall>y\\<in>list.set sl. x \\<le> y)\\<rbrakk>\n    \\<Longrightarrow> sorted (ssort' l sl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sorted (ssort' l sl) \\<and>\n  (\\<forall>x\\<in>local.set empty.\n      \\<forall>y\\<in>list.set (ssort' l sl). x \\<le> y)\n\ngoal (1 subgoal):\n 1. sorted (ssort' l sl)", "by simp"], ["proof (state)\nthis:\n  sorted (ssort' l sl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_ssort: \"sorted (ssort i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (ssort i)", "unfolding ssort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (ssort' (of_list i) [])", "using sorted_ssort'[of \"of_list i\" \"[]\"] of_list_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>inv (of_list i);\n   sorted [] \\<and>\n   (\\<forall>x\\<in>local.set (of_list i).\n       \\<forall>y\\<in>list.set []. x \\<le> y)\\<rbrakk>\n  \\<Longrightarrow> sorted (ssort' (of_list i) [])\n  inv (of_list ?x)\n\ngoal (1 subgoal):\n 1. sorted (ssort' (of_list i) [])", "by auto"], ["", "lemma permutation_ssort: \"ssort l <~~> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssort l <~~> l", "proof (subst mset_eq_perm[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. mset (ssort l) = mset l", "show \"mset (ssort l) = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (ssort l) = mset l", "unfolding ssort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (ssort' (of_list l) []) = mset l", "using mset_ssort'[of \"of_list l\" \"[]\"]"], ["proof (prove)\nusing this:\n  inv (of_list l) \\<Longrightarrow>\n  mset (ssort' (of_list l) []) = multiset (of_list l) + mset []\n\ngoal (1 subgoal):\n 1. mset (ssort' (of_list l) []) = mset l", "using multiset_of_list of_list_inv"], ["proof (prove)\nusing this:\n  inv (of_list l) \\<Longrightarrow>\n  mset (ssort' (of_list l) []) = multiset (of_list l) + mset []\n  multiset (of_list ?i) = mset ?i\n  inv (of_list ?x)\n\ngoal (1 subgoal):\n 1. mset (ssort' (of_list l) []) = mset l", "by simp"], ["proof (state)\nthis:\n  mset (ssort l) = mset l\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>Using assumptions given in the definitions of the locales {\\em\n  Collection} and {\\em RemoveMax} for the functions {\\em multiset},\n{\\em is\\_empty}, {\\em of\\_list} and {\\em remove\\_max} it is no\ndifficulty to show:\\<close>"], ["", "sublocale RemoveMax < Sort ssort"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sort ssort", "by (unfold_locales) (auto simp add: sorted_ssort permutation_ssort)"], ["", "end"]]}