{"file_name": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort/HeapFunctional.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Selection_Heap_Sort", "problem_names": ["lemma merge_val:\n  \"val(merge l r) = val l \\<or> val(merge l r) = val r\"", "lemma merge_heap_is_heap:\n  assumes \"is_heap l\" \"is_heap r\"\n  shows \"is_heap (merge l r)\"", "lemma merge_multiset:\n  \"multiset l + multiset g = multiset (merge l g)\""], "translations": [["", "lemma merge_val:\n  \"val(merge l r) = val l \\<or> val(merge l r) = val r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (merge l r) = val l \\<or> val (merge l r) = val r", "proof(induct l r rule:merge.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t1. val (merge t1 E) = val t1 \\<or> val (merge t1 E) = val E\n 2. \\<And>t2. val (merge E t2) = val E \\<or> val (merge E t2) = val t2\n 3. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "case (1 l)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>t1. val (merge t1 E) = val t1 \\<or> val (merge t1 E) = val E\n 2. \\<And>t2. val (merge E t2) = val E \\<or> val (merge E t2) = val t2\n 3. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. val (merge l E) = val l \\<or> val (merge l E) = val E", "by auto"], ["proof (state)\nthis:\n  val (merge l E) = val l \\<or> val (merge l E) = val E\n\ngoal (2 subgoals):\n 1. \\<And>t2. val (merge E t2) = val E \\<or> val (merge E t2) = val t2\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t2. val (merge E t2) = val E \\<or> val (merge E t2) = val t2\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "case (2 r)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>t2. val (merge E t2) = val E \\<or> val (merge E t2) = val t2\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. val (merge E r) = val E \\<or> val (merge E r) = val r", "by auto"], ["proof (state)\nthis:\n  val (merge E r) = val E \\<or> val (merge E r) = val r\n\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "case (3 v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  v2 \\<le> v1 \\<Longrightarrow>\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2)\n  \\<not> v2 \\<le> v1 \\<Longrightarrow>\n  val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n  val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n                val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n        val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\\<rbrakk>\n       \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v1 l1 r1) \\<or>\n                         val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                         val (T v2 l2 r2)", "thus ?case"], ["proof (prove)\nusing this:\n  v2 \\<le> v1 \\<Longrightarrow>\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2)\n  \\<not> v2 \\<le> v1 \\<Longrightarrow>\n  val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n  val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1) \\<or>\n    val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)", "proof(cases \"v2 \\<le> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)", "hence \"val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1)", "by auto"], ["proof (state)\nthis:\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1) \\<or>\n    val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1) \\<or>\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)", "hence \"val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n             val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2);\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n     val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1);\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v1 l1 r1) \\<or>\n                      val (merge (T v1 l1 r1) (T v2 l2 r2)) =\n                      val (T v2 l2 r2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1) \\<or>\n    val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)", "by auto"], ["proof (state)\nthis:\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1) \\<or>\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v1 l1 r1) \\<or>\n  val (merge (T v1 l1 r1) (T v2 l2 r2)) = val (T v2 l2 r2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Function {\\em merge} merges two heaps into one:\\<close>"], ["", "lemma merge_heap_is_heap:\n  assumes \"is_heap l\" \"is_heap r\"\n  shows \"is_heap (merge l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (merge l r)", "using assms"], ["proof (prove)\nusing this:\n  is_heap l\n  is_heap r\n\ngoal (1 subgoal):\n 1. is_heap (merge l r)", "proof(induct l r rule:merge.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t1.\n       \\<lbrakk>is_heap t1; is_heap E\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge t1 E)\n 2. \\<And>t2.\n       \\<lbrakk>is_heap E; is_heap t2\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge E t2)\n 3. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case (1 l)"], ["proof (state)\nthis:\n  is_heap l\n  is_heap E\n\ngoal (3 subgoals):\n 1. \\<And>t1.\n       \\<lbrakk>is_heap t1; is_heap E\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge t1 E)\n 2. \\<And>t2.\n       \\<lbrakk>is_heap E; is_heap t2\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge E t2)\n 3. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?case"], ["proof (prove)\nusing this:\n  is_heap l\n  is_heap E\n\ngoal (1 subgoal):\n 1. is_heap (merge l E)", "by auto"], ["proof (state)\nthis:\n  is_heap (merge l E)\n\ngoal (2 subgoals):\n 1. \\<And>t2.\n       \\<lbrakk>is_heap E; is_heap t2\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge E t2)\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t2.\n       \\<lbrakk>is_heap E; is_heap t2\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge E t2)\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case (2 r)"], ["proof (state)\nthis:\n  is_heap E\n  is_heap r\n\ngoal (2 subgoals):\n 1. \\<And>t2.\n       \\<lbrakk>is_heap E; is_heap t2\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge E t2)\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?case"], ["proof (prove)\nusing this:\n  is_heap E\n  is_heap r\n\ngoal (1 subgoal):\n 1. is_heap (merge E r)", "by auto"], ["proof (state)\nthis:\n  is_heap (merge E r)\n\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case (3 v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1;\n                 is_heap (T v2 l2 r2)\\<rbrakk>\n                \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n        \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2;\n         is_heap (T v1 l1 r1)\\<rbrakk>\n        \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n        is_heap (T v1 l1 r1); is_heap (T v2 l2 r2)\\<rbrakk>\n       \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v2 \\<le> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"is_heap l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap l1", "using \\<open>is_heap (T v1 l1 r1)\\<close>"], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. is_heap l1", "by (metis Tree.exhaust is_heap.simps(1) is_heap.simps(4) is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap l1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"is_heap (merge l1 (T v2 l2 r2))\""], ["proof (prove)\nusing this:\n  is_heap l1\n\ngoal (1 subgoal):\n 1. is_heap (merge l1 (T v2 l2 r2))", "using True \\<open>is_heap (T v2 l2 r2)\\<close>  3"], ["proof (prove)\nusing this:\n  is_heap l1\n  v2 \\<le> v1\n  is_heap (T v2 l2 r2)\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. is_heap (merge l1 (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  is_heap (merge l1 (T v2 l2 r2))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"val (merge l1 (T v2 l2 r2)) = val l1 \\<or> val(merge l1 (T v2 l2 r2)) = v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n    val (merge l1 (T v2 l2 r2)) = v2", "using merge_val[of l1 \"T v2 l2 r2\"]"], ["proof (prove)\nusing this:\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = val (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n    val (merge l1 (T v2 l2 r2)) = v2", "by auto"], ["proof (state)\nthis:\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = v2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"r1 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. r1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  r1 = E\n\ngoal (2 subgoals):\n 1. r1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. r1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"l1 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  l1 = E\n\ngoal (2 subgoals):\n 1. l1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) E\""], ["proof (prove)\nusing this:\n  l1 = E\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) E", "using \\<open>r1 = E\\<close> \\<open>v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  l1 = E\n  r1 = E\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) E", "by auto"], ["proof (state)\nthis:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) E\n\ngoal (2 subgoals):\n 1. l1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) E\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using 3"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) E\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) E\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  l1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"v1 \\<ge> val l1\""], ["proof (prove)\nusing this:\n  l1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. val l1 \\<le> v1", "using 3(3)"], ["proof (prove)\nusing this:\n  l1 \\<noteq> E\n  is_heap (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. val l1 \\<le> v1", "by (metis Tree.exhaust in_tree.simps(2) is_heap_max val.simps)"], ["proof (state)\nthis:\n  val l1 \\<le> v1\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  val l1 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>r1 = E\\<close> \\<open>v1 \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  val l1 \\<le> v1\n  r1 = E\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>val (merge l1 (T v2 l2 r2)) = val l1 \n                     \\<or> val(merge l1 (T v2 l2 r2)) = v2\\<close>"], ["proof (prove)\nusing this:\n  val l1 \\<le> v1\n  r1 = E\n  v2 \\<le> v1\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = v2\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>is_heap (merge l1 (T v2 l2 r2))\\<close>"], ["proof (prove)\nusing this:\n  val l1 \\<le> v1\n  r1 = E\n  v2 \\<le> v1\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = v2\n  is_heap (merge l1 (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by (metis False Tree.exhaust is_heap.simps(2) \n              is_heap.simps(4) merge.simps(3) val.simps)"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. r1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  r1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. r1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"v1 \\<ge> val r1\""], ["proof (prove)\nusing this:\n  r1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. val r1 \\<le> v1", "using 3(3)"], ["proof (prove)\nusing this:\n  r1 \\<noteq> E\n  is_heap (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. val r1 \\<le> v1", "by (metis Tree.exhaust in_tree.simps(2) is_heap_max val.simps)"], ["proof (state)\nthis:\n  val r1 \\<le> v1\n\ngoal (1 subgoal):\n 1. r1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"l1 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  l1 = E\n\ngoal (2 subgoals):\n 1. l1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) r1\""], ["proof (prove)\nusing this:\n  l1 = E\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) r1", "using \\<open>v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  l1 = E\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) r1", "by auto"], ["proof (state)\nthis:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) r1\n\ngoal (2 subgoals):\n 1. l1 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) r1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using 3 \\<open>v1 \\<ge> val r1\\<close>"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) r1\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  val r1 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v1 (T v2 l2 r2) r1\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  val r1 \\<le> v1\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by (metis False Tree.exhaust Tree.inject Tree.simps(3) \n              True is_heap.simps(3) is_heap.simps(6) merge.simps(2) \n              merge.simps(3) order_eq_iff val.simps)"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  l1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"v1 \\<ge> val l1\""], ["proof (prove)\nusing this:\n  l1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. val l1 \\<le> v1", "using 3(3)"], ["proof (prove)\nusing this:\n  l1 \\<noteq> E\n  is_heap (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. val l1 \\<le> v1", "by (metis Tree.exhaust in_tree.simps(2) is_heap_max val.simps)"], ["proof (state)\nthis:\n  val l1 \\<le> v1\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"merge l1 (T v2 l2 r2) \\<noteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge l1 (T v2 l2 r2) \\<noteq> E", "using False"], ["proof (prove)\nusing this:\n  l1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. merge l1 (T v2 l2 r2) \\<noteq> E", "by (metis Tree.exhaust Tree.simps(2) merge.simps(3))"], ["proof (state)\nthis:\n  merge l1 (T v2 l2 r2) \\<noteq> E\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"is_heap r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap r1", "using 3(3)"], ["proof (prove)\nusing this:\n  is_heap (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. is_heap r1", "by (metis False Tree.exhaust \\<open>r1 \\<noteq> E\\<close> is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap r1\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "obtain ll1 lr1 lv1 where \"r1 = T lv1 ll1 lr1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lv1 ll1 lr1.\n        r1 = T lv1 ll1 lr1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>r1 \\<noteq> E\\<close>"], ["proof (prove)\nusing this:\n  r1 \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>lv1 ll1 lr1.\n        r1 = T lv1 ll1 lr1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  r1 = T lv1 ll1 lr1\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "obtain rl1 rr1 rv1 where \"merge l1 (T v2 l2 r2) = T rv1 rl1 rr1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rv1 rl1 rr1.\n        merge l1 (T v2 l2 r2) = T rv1 rl1 rr1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>merge l1 (T v2 l2 r2) \\<noteq> E\\<close>"], ["proof (prove)\nusing this:\n  merge l1 (T v2 l2 r2) \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>rv1 rl1 rr1.\n        merge l1 (T v2 l2 r2) = T rv1 rl1 rr1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  merge l1 (T v2 l2 r2) = T rv1 rl1 rr1\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"val (merge l1 (T v2 l2 r2)) \\<le> v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (merge l1 (T v2 l2 r2)) \\<le> v1", "using \\<open>val (merge l1 (T v2 l2 r2)) = val l1 \\<or> \n                 val(merge l1 (T v2 l2 r2)) = v2\\<close>"], ["proof (prove)\nusing this:\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = v2\n\ngoal (1 subgoal):\n 1. val (merge l1 (T v2 l2 r2)) \\<le> v1", "using \\<open>v1 \\<ge> v2\\<close> \\<open>v1 \\<ge> val l1\\<close>"], ["proof (prove)\nusing this:\n  val (merge l1 (T v2 l2 r2)) = val l1 \\<or>\n  val (merge l1 (T v2 l2 r2)) = v2\n  v2 \\<le> v1\n  val l1 \\<le> v1\n\ngoal (1 subgoal):\n 1. val (merge l1 (T v2 l2 r2)) \\<le> v1", "by auto"], ["proof (state)\nthis:\n  val (merge l1 (T v2 l2 r2)) \\<le> v1\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)\""], ["proof (prove)\nusing this:\n  val (merge l1 (T v2 l2 r2)) \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)", "using is_heap.simps(5)[of v1 lv1 ll1 lr1 rv1 rl1  rr1]"], ["proof (prove)\nusing this:\n  val (merge l1 (T v2 l2 r2)) \\<le> v1\n  is_heap (T v1 (T lv1 ll1 lr1) (T rv1 rl1 rr1)) =\n  (val (T rv1 rl1 rr1) \\<le> v1 \\<and>\n   is_heap (T rv1 rl1 rr1) \\<and>\n   val (T lv1 ll1 lr1) \\<le> v1 \\<and> is_heap (T lv1 ll1 lr1))\n\ngoal (1 subgoal):\n 1. is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)", "using \\<open>r1 = T lv1 ll1 lr1\\<close> \\<open>merge l1 (T v2 l2 r2) = T rv1 rl1 rr1\\<close>"], ["proof (prove)\nusing this:\n  val (merge l1 (T v2 l2 r2)) \\<le> v1\n  is_heap (T v1 (T lv1 ll1 lr1) (T rv1 rl1 rr1)) =\n  (val (T rv1 rl1 rr1) \\<le> v1 \\<and>\n   is_heap (T rv1 rl1 rr1) \\<and>\n   val (T lv1 ll1 lr1) \\<le> v1 \\<and> is_heap (T lv1 ll1 lr1))\n  r1 = T lv1 ll1 lr1\n  merge l1 (T v2 l2 r2) = T rv1 rl1 rr1\n\ngoal (1 subgoal):\n 1. is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)", "using \\<open>is_heap r1\\<close> \\<open>is_heap (merge l1 (T v2 l2 r2))\\<close> \\<open>v1 \\<ge> val r1\\<close>"], ["proof (prove)\nusing this:\n  val (merge l1 (T v2 l2 r2)) \\<le> v1\n  is_heap (T v1 (T lv1 ll1 lr1) (T rv1 rl1 rr1)) =\n  (val (T rv1 rl1 rr1) \\<le> v1 \\<and>\n   is_heap (T rv1 rl1 rr1) \\<and>\n   val (T lv1 ll1 lr1) \\<le> v1 \\<and> is_heap (T lv1 ll1 lr1))\n  r1 = T lv1 ll1 lr1\n  merge l1 (T v2 l2 r2) = T rv1 rl1 rr1\n  is_heap r1\n  is_heap (merge l1 (T v2 l2 r2))\n  val r1 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)", "by auto"], ["proof (state)\nthis:\n  is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  is_heap (T v1 (merge l1 (T v2 l2 r2)) r1)\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"is_heap l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap l2", "using 3(4)"], ["proof (prove)\nusing this:\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. is_heap l2", "by (metis Tree.exhaust is_heap.simps(1) \n          is_heap.simps(4) is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap l2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"is_heap (merge l2 (T v1 l1 r1))\""], ["proof (prove)\nusing this:\n  is_heap l2\n\ngoal (1 subgoal):\n 1. is_heap (merge l2 (T v1 l1 r1))", "using False \\<open>is_heap (T v1 l1 r1)\\<close>  3"], ["proof (prove)\nusing this:\n  is_heap l2\n  \\<not> v2 \\<le> v1\n  is_heap (T v1 l1 r1)\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. is_heap (merge l2 (T v1 l1 r1))", "by auto"], ["proof (state)\nthis:\n  is_heap (merge l2 (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"val (merge l2 (T v1 l1 r1)) = val l2 \\<or> \n          val(merge l2 (T v1 l1 r1)) = v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n    val (merge l2 (T v1 l1 r1)) = v1", "using merge_val[of l2 \"T v1 l1 r1\"]"], ["proof (prove)\nusing this:\n  val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n  val (merge l2 (T v1 l1 r1)) = val (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n    val (merge l2 (T v1 l1 r1)) = v1", "by auto"], ["proof (state)\nthis:\n  val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n  val (merge l2 (T v1 l1 r1)) = v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n             \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2));\n     \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n     \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1));\n     is_heap (T v1 l1 r1); is_heap (T v2 l2 r2); \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"r2 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. r2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  r2 = E\n\ngoal (2 subgoals):\n 1. r2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. r2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"l2 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  l2 = E\n\ngoal (2 subgoals):\n 1. l2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) E\""], ["proof (prove)\nusing this:\n  l2 = E\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) E", "using \\<open>r2 = E\\<close> \\<open>\\<not> v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  l2 = E\n  r2 = E\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) E", "by auto"], ["proof (state)\nthis:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) E\n\ngoal (2 subgoals):\n 1. l2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) E\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using 3"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) E\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>\\<not> v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) E\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  l2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"v2 \\<ge> val l2\""], ["proof (prove)\nusing this:\n  l2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. val l2 \\<le> v2", "using 3(4)"], ["proof (prove)\nusing this:\n  l2 \\<noteq> E\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. val l2 \\<le> v2", "by (metis Tree.exhaust in_tree.simps(2) is_heap_max val.simps)"], ["proof (state)\nthis:\n  val l2 \\<le> v2\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  val l2 \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>r2 = E\\<close> \\<open>\\<not> v1 \\<ge> v2\\<close>"], ["proof (prove)\nusing this:\n  val l2 \\<le> v2\n  r2 = E\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>is_heap (merge l2 (T v1 l1 r1))\\<close>"], ["proof (prove)\nusing this:\n  val l2 \\<le> v2\n  r2 = E\n  \\<not> v2 \\<le> v1\n  is_heap (merge l2 (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>val (merge l2 (T v1 l1 r1)) = val l2 \\<or> \n                 val(merge l2 (T v1 l1 r1)) = v1\\<close>"], ["proof (prove)\nusing this:\n  val l2 \\<le> v2\n  r2 = E\n  \\<not> v2 \\<le> v1\n  is_heap (merge l2 (T v1 l1 r1))\n  val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n  val (merge l2 (T v1 l1 r1)) = v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by (metis False Tree.exhaust is_heap.simps(2) \n              is_heap.simps(4) linorder_linear merge.simps(3) val.simps)"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  r2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"v2 \\<ge> val r2\""], ["proof (prove)\nusing this:\n  r2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. val r2 \\<le> v2", "using 3(4)"], ["proof (prove)\nusing this:\n  r2 \\<noteq> E\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. val r2 \\<le> v2", "by (metis Tree.exhaust in_tree.simps(2) is_heap_max val.simps)"], ["proof (state)\nthis:\n  val r2 \\<le> v2\n\ngoal (1 subgoal):\n 1. r2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"l2 = E\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case True"], ["proof (state)\nthis:\n  l2 = E\n\ngoal (2 subgoals):\n 1. l2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) r2\""], ["proof (prove)\nusing this:\n  l2 = E\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) r2", "using \\<open>\\<not> v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  l2 = E\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) r2", "by auto"], ["proof (state)\nthis:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) r2\n\ngoal (2 subgoals):\n 1. l2 = E \\<Longrightarrow> is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) r2\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using 3 \\<open>v2 \\<ge> val r2\\<close>"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) r2\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  val r2 \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>\\<not> v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  merge (T v1 l1 r1) (T v2 l2 r2) = T v2 (T v1 l1 r1) r2\n  \\<lbrakk>v2 \\<le> v1; is_heap l1; is_heap (T v2 l2 r2)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l1 (T v2 l2 r2))\n  \\<lbrakk>\\<not> v2 \\<le> v1; is_heap l2; is_heap (T v1 l1 r1)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge l2 (T v1 l1 r1))\n  is_heap (T v1 l1 r1)\n  is_heap (T v2 l2 r2)\n  val r2 \\<le> v2\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by (metis False Tree.exhaust Tree.simps(3) is_heap.simps(3) \n              is_heap.simps(5) linorder_linear val.simps)"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  l2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"v2 \\<ge> val l2\""], ["proof (prove)\nusing this:\n  l2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. val l2 \\<le> v2", "using 3(4)"], ["proof (prove)\nusing this:\n  l2 \\<noteq> E\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. val l2 \\<le> v2", "by (metis Tree.exhaust in_tree.simps(2) is_heap_max val.simps)"], ["proof (state)\nthis:\n  val l2 \\<le> v2\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"merge l2 (T v1 l1 r1) \\<noteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge l2 (T v1 l1 r1) \\<noteq> E", "using False"], ["proof (prove)\nusing this:\n  l2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. merge l2 (T v1 l1 r1) \\<noteq> E", "by (metis Tree.exhaust Tree.simps(2) merge.simps(3))"], ["proof (state)\nthis:\n  merge l2 (T v1 l1 r1) \\<noteq> E\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"is_heap r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap r2", "using 3(4)"], ["proof (prove)\nusing this:\n  is_heap (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. is_heap r2", "by (metis False Tree.exhaust \\<open>r2 \\<noteq> E\\<close> is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap r2\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "obtain ll1 lr1 lv1 where \"r2 = T lv1 ll1 lr1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lv1 ll1 lr1.\n        r2 = T lv1 ll1 lr1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>r2 \\<noteq> E\\<close>"], ["proof (prove)\nusing this:\n  r2 \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>lv1 ll1 lr1.\n        r2 = T lv1 ll1 lr1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  r2 = T lv1 ll1 lr1\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "obtain rl1 rr1 rv1 where \"merge l2 (T v1 l1 r1) = T rv1 rl1 rr1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rv1 rl1 rr1.\n        merge l2 (T v1 l1 r1) = T rv1 rl1 rr1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>merge l2 (T v1 l1 r1) \\<noteq> E\\<close>"], ["proof (prove)\nusing this:\n  merge l2 (T v1 l1 r1) \\<noteq> E\n\ngoal (1 subgoal):\n 1. (\\<And>rv1 rl1 rr1.\n        merge l2 (T v1 l1 r1) = T rv1 rl1 rr1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust)"], ["proof (state)\nthis:\n  merge l2 (T v1 l1 r1) = T rv1 rl1 rr1\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "have \"val (merge l2 (T v1 l1 r1)) \\<le> v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (merge l2 (T v1 l1 r1)) \\<le> v2", "using \\<open>val (merge l2 (T v1 l1 r1)) = val l2 \\<or> \n                 val(merge l2 (T v1 l1 r1)) = v1\\<close>"], ["proof (prove)\nusing this:\n  val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n  val (merge l2 (T v1 l1 r1)) = v1\n\ngoal (1 subgoal):\n 1. val (merge l2 (T v1 l1 r1)) \\<le> v2", "using \\<open>\\<not> v1 \\<ge> v2\\<close> \\<open>v2 \\<ge> val l2\\<close>"], ["proof (prove)\nusing this:\n  val (merge l2 (T v1 l1 r1)) = val l2 \\<or>\n  val (merge l2 (T v1 l1 r1)) = v1\n  \\<not> v2 \\<le> v1\n  val l2 \\<le> v2\n\ngoal (1 subgoal):\n 1. val (merge l2 (T v1 l1 r1)) \\<le> v2", "by auto"], ["proof (state)\nthis:\n  val (merge l2 (T v1 l1 r1)) \\<le> v2\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)\""], ["proof (prove)\nusing this:\n  val (merge l2 (T v1 l1 r1)) \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)", "using is_heap.simps(5)[of v1 lv1 ll1 lr1 rv1 rl1 rr1]"], ["proof (prove)\nusing this:\n  val (merge l2 (T v1 l1 r1)) \\<le> v2\n  is_heap (T v1 (T lv1 ll1 lr1) (T rv1 rl1 rr1)) =\n  (val (T rv1 rl1 rr1) \\<le> v1 \\<and>\n   is_heap (T rv1 rl1 rr1) \\<and>\n   val (T lv1 ll1 lr1) \\<le> v1 \\<and> is_heap (T lv1 ll1 lr1))\n\ngoal (1 subgoal):\n 1. is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)", "using \\<open>r2 = T lv1 ll1 lr1\\<close> \\<open>merge l2 (T v1 l1 r1) = T rv1 rl1 rr1\\<close>"], ["proof (prove)\nusing this:\n  val (merge l2 (T v1 l1 r1)) \\<le> v2\n  is_heap (T v1 (T lv1 ll1 lr1) (T rv1 rl1 rr1)) =\n  (val (T rv1 rl1 rr1) \\<le> v1 \\<and>\n   is_heap (T rv1 rl1 rr1) \\<and>\n   val (T lv1 ll1 lr1) \\<le> v1 \\<and> is_heap (T lv1 ll1 lr1))\n  r2 = T lv1 ll1 lr1\n  merge l2 (T v1 l1 r1) = T rv1 rl1 rr1\n\ngoal (1 subgoal):\n 1. is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)", "using \\<open>is_heap r2\\<close> \\<open>is_heap (merge l2 (T v1 l1 r1))\\<close> \\<open>v2 \\<ge> val r2\\<close>"], ["proof (prove)\nusing this:\n  val (merge l2 (T v1 l1 r1)) \\<le> v2\n  is_heap (T v1 (T lv1 ll1 lr1) (T rv1 rl1 rr1)) =\n  (val (T rv1 rl1 rr1) \\<le> v1 \\<and>\n   is_heap (T rv1 rl1 rr1) \\<and>\n   val (T lv1 ll1 lr1) \\<le> v1 \\<and> is_heap (T lv1 ll1 lr1))\n  r2 = T lv1 ll1 lr1\n  merge l2 (T v1 l1 r1) = T rv1 rl1 rr1\n  is_heap r2\n  is_heap (merge l2 (T v1 l1 r1))\n  val r2 \\<le> v2\n\ngoal (1 subgoal):\n 1. is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)", "by auto"], ["proof (state)\nthis:\n  is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> E \\<Longrightarrow>\n    is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "using \\<open>\\<not> v2 \\<le> v1\\<close>"], ["proof (prove)\nusing this:\n  is_heap (T v2 (merge l2 (T v1 l1 r1)) r2)\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. is_heap (merge (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition insert :: \"'a::linorder \\<Rightarrow> 'a Tree \\<Rightarrow> 'a Tree\" where\n  \"insert v t =  merge t (T v E E)\""], ["", "primrec hs_of_list where\n  \"hs_of_list [] = E\"\n| \"hs_of_list (v # l) = insert v (hs_of_list l)\""], ["", "definition hs_is_empty where\n[simp]: \"hs_is_empty t \\<longleftrightarrow>  t = E\""], ["", "text\\<open>Definition of function {\\em remove\\_max}:\\<close>"], ["", "fun hs_remove_max:: \"'a::linorder Tree \\<Rightarrow> 'a \\<times> 'a Tree\"  where\n  \"hs_remove_max (T v l r) = (v, merge l r)\""], ["", "lemma merge_multiset:\n  \"multiset l + multiset g = multiset (merge l g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset l + Heap.multiset g = Heap.multiset (merge l g)", "proof(induct l g rule:merge.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t1.\n       Heap.multiset t1 + Heap.multiset E = Heap.multiset (merge t1 E)\n 2. \\<And>t2.\n       Heap.multiset E + Heap.multiset t2 = Heap.multiset (merge E t2)\n 3. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "case (1 l)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>t1.\n       Heap.multiset t1 + Heap.multiset E = Heap.multiset (merge t1 E)\n 2. \\<And>t2.\n       Heap.multiset E + Heap.multiset t2 = Heap.multiset (merge E t2)\n 3. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset l + Heap.multiset E = Heap.multiset (merge l E)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset l + Heap.multiset E = Heap.multiset (merge l E)\n\ngoal (2 subgoals):\n 1. \\<And>t2.\n       Heap.multiset E + Heap.multiset t2 = Heap.multiset (merge E t2)\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t2.\n       Heap.multiset E + Heap.multiset t2 = Heap.multiset (merge E t2)\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "case (2 g)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>t2.\n       Heap.multiset E + Heap.multiset t2 = Heap.multiset (merge E t2)\n 2. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset E + Heap.multiset g = Heap.multiset (merge E g)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset E + Heap.multiset g = Heap.multiset (merge E g)\n\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "case (3 v1 l1 r1 v2 l2 r2)"], ["proof (state)\nthis:\n  v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n  Heap.multiset (merge l1 (T v2 l2 r2))\n  \\<not> v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n  Heap.multiset (merge l2 (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. \\<And>v1 l1 r1 v2 l2 r2.\n       \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n                Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n                Heap.multiset (merge l1 (T v2 l2 r2));\n        \\<not> v2 \\<le> v1 \\<Longrightarrow>\n        Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n        Heap.multiset (merge l2 (T v1 l1 r1))\\<rbrakk>\n       \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                         Heap.multiset (T v2 l2 r2) =\n                         Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?case"], ["proof (prove)\nusing this:\n  v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n  Heap.multiset (merge l1 (T v2 l2 r2))\n  \\<not> v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n  Heap.multiset (merge l2 (T v1 l1 r1))\n\ngoal (1 subgoal):\n 1. Heap.multiset (T v1 l1 r1) + Heap.multiset (T v2 l2 r2) =\n    Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "proof(cases \"v2 \\<le> v1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "case  True"], ["proof (state)\nthis:\n  v2 \\<le> v1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (merge (T v1 l1 r1) (T v2 l2 r2)) = \n           {#v1#} + multiset (merge l1 (T v2 l2 r2)) +  multiset r1\""], ["proof (prove)\nusing this:\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n    {#v1#} + Heap.multiset (merge l1 (T v2 l2 r2)) + Heap.multiset r1", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v1#} + Heap.multiset (merge l1 (T v2 l2 r2)) + Heap.multiset r1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (merge (T v1 l1 r1) (T v2 l2 r2)) = \n           {#v1#} + multiset l1 + multiset (T v2 l2 r2) + multiset r1\""], ["proof (prove)\nusing this:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v1#} + Heap.multiset (merge l1 (T v2 l2 r2)) + Heap.multiset r1\n\ngoal (1 subgoal):\n 1. Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n    {#v1#} + Heap.multiset l1 + Heap.multiset (T v2 l2 r2) +\n    Heap.multiset r1", "using 3 True"], ["proof (prove)\nusing this:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v1#} + Heap.multiset (merge l1 (T v2 l2 r2)) + Heap.multiset r1\n  v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n  Heap.multiset (merge l1 (T v2 l2 r2))\n  \\<not> v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n  Heap.multiset (merge l2 (T v1 l1 r1))\n  v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n    {#v1#} + Heap.multiset l1 + Heap.multiset (T v2 l2 r2) +\n    Heap.multiset r1", "by (metis union_assoc)"], ["proof (state)\nthis:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v1#} + Heap.multiset l1 + Heap.multiset (T v2 l2 r2) + Heap.multiset r1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (merge (T v1 l1 r1) (T v2 l2 r2)) = \n           {#v1#} + multiset l1 + multiset r1 + multiset (T v2 l2 r2)\""], ["proof (prove)\nusing this:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v1#} + Heap.multiset l1 + Heap.multiset (T v2 l2 r2) + Heap.multiset r1\n\ngoal (1 subgoal):\n 1. Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n    {#v1#} + Heap.multiset l1 + Heap.multiset r1 +\n    Heap.multiset (T v2 l2 r2)", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v1#} + Heap.multiset l1 + Heap.multiset r1 + Heap.multiset (T v2 l2 r2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n 2. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v1#} + Heap.multiset l1 + Heap.multiset r1 + Heap.multiset (T v2 l2 r2)\n\ngoal (1 subgoal):\n 1. Heap.multiset (T v1 l1 r1) + Heap.multiset (T v2 l2 r2) =\n    Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (T v1 l1 r1) + Heap.multiset (T v2 l2 r2) =\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "case False"], ["proof (state)\nthis:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (merge (T v1 l1 r1) (T v2 l2 r2)) = \n           {#v2#} + multiset (merge l2 (T v1 l1 r1)) + multiset r2\""], ["proof (prove)\nusing this:\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n    {#v2#} + Heap.multiset (merge l2 (T v1 l1 r1)) + Heap.multiset r2", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v2#} + Heap.multiset (merge l2 (T v1 l1 r1)) + Heap.multiset r2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "hence \"multiset (merge (T v1 l1 r1) (T v2 l2 r2)) = \n           {#v2#} + multiset l2 + multiset r2 +  multiset (T v1 l1 r1)\""], ["proof (prove)\nusing this:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v2#} + Heap.multiset (merge l2 (T v1 l1 r1)) + Heap.multiset r2\n\ngoal (1 subgoal):\n 1. Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n    {#v2#} + Heap.multiset l2 + Heap.multiset r2 +\n    Heap.multiset (T v1 l1 r1)", "using 3 False"], ["proof (prove)\nusing this:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v2#} + Heap.multiset (merge l2 (T v1 l1 r1)) + Heap.multiset r2\n  v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n  Heap.multiset (merge l1 (T v2 l2 r2))\n  \\<not> v2 \\<le> v1 \\<Longrightarrow>\n  Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n  Heap.multiset (merge l2 (T v1 l1 r1))\n  \\<not> v2 \\<le> v1\n\ngoal (1 subgoal):\n 1. Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n    {#v2#} + Heap.multiset l2 + Heap.multiset r2 +\n    Heap.multiset (T v1 l1 r1)", "by (metis union_commute union_lcomm)"], ["proof (state)\nthis:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v2#} + Heap.multiset l2 + Heap.multiset r2 + Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v2 \\<le> v1 \\<Longrightarrow>\n             Heap.multiset l1 + Heap.multiset (T v2 l2 r2) =\n             Heap.multiset (merge l1 (T v2 l2 r2));\n     \\<not> v2 \\<le> v1 \\<Longrightarrow>\n     Heap.multiset l2 + Heap.multiset (T v1 l1 r1) =\n     Heap.multiset (merge l2 (T v1 l1 r1));\n     \\<not> v2 \\<le> v1\\<rbrakk>\n    \\<Longrightarrow> Heap.multiset (T v1 l1 r1) +\n                      Heap.multiset (T v2 l2 r2) =\n                      Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2)) =\n  {#v2#} + Heap.multiset l2 + Heap.multiset r2 + Heap.multiset (T v1 l1 r1)\n\ngoal (1 subgoal):\n 1. Heap.multiset (T v1 l1 r1) + Heap.multiset (T v2 l2 r2) =\n    Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))", "by (metis multiset.simps(2) union_commute)"], ["proof (state)\nthis:\n  Heap.multiset (T v1 l1 r1) + Heap.multiset (T v2 l2 r2) =\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (T v1 l1 r1) + Heap.multiset (T v2 l2 r2) =\n  Heap.multiset (merge (T v1 l1 r1) (T v2 l2 r2))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Proof that defined functions are interpretation of abstract functions from locale {\\em Collection}:\\<close>"], ["", "interpretation HS: Collection \"E\" hs_is_empty hs_of_list multiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collection E hs_is_empty hs_of_list Heap.multiset", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. hs_is_empty e \\<Longrightarrow> e = E\n 2. hs_is_empty E\n 3. Heap.multiset E = {#}\n 4. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "fix t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>e. hs_is_empty e \\<Longrightarrow> e = E\n 2. hs_is_empty E\n 3. Heap.multiset E = {#}\n 4. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "assume \"hs_is_empty t\""], ["proof (state)\nthis:\n  hs_is_empty t\n\ngoal (4 subgoals):\n 1. \\<And>e. hs_is_empty e \\<Longrightarrow> e = E\n 2. hs_is_empty E\n 3. Heap.multiset E = {#}\n 4. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "thus \"t = E\""], ["proof (prove)\nusing this:\n  hs_is_empty t\n\ngoal (1 subgoal):\n 1. t = E", "by auto"], ["proof (state)\nthis:\n  t = E\n\ngoal (3 subgoals):\n 1. hs_is_empty E\n 2. Heap.multiset E = {#}\n 3. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. hs_is_empty E\n 2. Heap.multiset E = {#}\n 3. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "show \"hs_is_empty E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs_is_empty E", "by auto"], ["proof (state)\nthis:\n  hs_is_empty E\n\ngoal (2 subgoals):\n 1. Heap.multiset E = {#}\n 2. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Heap.multiset E = {#}\n 2. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "show \"multiset E = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset E = {#}", "by auto"], ["proof (state)\nthis:\n  Heap.multiset E = {#}\n\ngoal (1 subgoal):\n 1. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Heap.multiset (hs_of_list i) = mset i", "show \"multiset (hs_of_list l) = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (hs_of_list l) = mset l", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. Heap.multiset (hs_of_list []) = mset []\n 2. \\<And>a l.\n       Heap.multiset (hs_of_list l) = mset l \\<Longrightarrow>\n       Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Heap.multiset (hs_of_list []) = mset []\n 2. \\<And>a l.\n       Heap.multiset (hs_of_list l) = mset l \\<Longrightarrow>\n       Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (hs_of_list []) = mset []", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (hs_of_list []) = mset []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (hs_of_list l) = mset l \\<Longrightarrow>\n       Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (hs_of_list l) = mset l \\<Longrightarrow>\n       Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "case (Cons a l)"], ["proof (state)\nthis:\n  Heap.multiset (hs_of_list l) = mset l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (hs_of_list l) = mset l \\<Longrightarrow>\n       Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "have \"multiset (hs_of_list (a # l)) = multiset (hs_of_list l) + {#a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset (hs_of_list (a # l)) =\n    Heap.multiset (hs_of_list l) + {#a#}", "using merge_multiset[of \"hs_of_list l\" \"T a E E\"]"], ["proof (prove)\nusing this:\n  Heap.multiset (hs_of_list l) + Heap.multiset (T a E E) =\n  Heap.multiset (merge (hs_of_list l) (T a E E))\n\ngoal (1 subgoal):\n 1. Heap.multiset (hs_of_list (a # l)) =\n    Heap.multiset (hs_of_list l) + {#a#}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset a (Heap.multiset (hs_of_list l)) =\n    Heap.multiset (merge (hs_of_list l) (T a E E)) \\<Longrightarrow>\n    Heap.multiset (HeapFunctional.insert a (hs_of_list l)) =\n    Heap.multiset (merge (hs_of_list l) (T a E E))", "unfolding insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset a (Heap.multiset (hs_of_list l)) =\n    Heap.multiset (merge (hs_of_list l) (T a E E)) \\<Longrightarrow>\n    Heap.multiset (merge (hs_of_list l) (T a E E)) =\n    Heap.multiset (merge (hs_of_list l) (T a E E))", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (hs_of_list (a # l)) = Heap.multiset (hs_of_list l) + {#a#}\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       Heap.multiset (hs_of_list l) = mset l \\<Longrightarrow>\n       Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "thus ?case"], ["proof (prove)\nusing this:\n  Heap.multiset (hs_of_list (a # l)) = Heap.multiset (hs_of_list l) + {#a#}\n\ngoal (1 subgoal):\n 1. Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "using Cons"], ["proof (prove)\nusing this:\n  Heap.multiset (hs_of_list (a # l)) = Heap.multiset (hs_of_list l) + {#a#}\n  Heap.multiset (hs_of_list l) = mset l\n\ngoal (1 subgoal):\n 1. Heap.multiset (hs_of_list (a # l)) = mset (a # l)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset (hs_of_list (a # l)) = mset (a # l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Heap.multiset (hs_of_list l) = mset l\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Proof that defined functions are interpretation of abstract functions from locale {\\em Heap}:\\<close>"], ["", "interpretation Heap \"E\" hs_is_empty hs_of_list multiset id hs_remove_max"], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap E hs_is_empty hs_of_list Heap.multiset id hs_remove_max", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l. Heap.multiset l = Heap.multiset (id l)\n 2. \\<And>i. is_heap (id (hs_of_list i))\n 3. \\<And>t. (id t = E) = hs_is_empty t\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 5. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 6. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix l"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l. Heap.multiset l = Heap.multiset (id l)\n 2. \\<And>i. is_heap (id (hs_of_list i))\n 3. \\<And>t. (id t = E) = hs_is_empty t\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 5. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 6. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "show \"multiset l = Heap.multiset (id l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Heap.multiset l = Heap.multiset (id l)", "by auto"], ["proof (state)\nthis:\n  Heap.multiset l = Heap.multiset (id l)\n\ngoal (5 subgoals):\n 1. \\<And>i. is_heap (id (hs_of_list i))\n 2. \\<And>t. (id t = E) = hs_is_empty t\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 5. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. is_heap (id (hs_of_list i))\n 2. \\<And>t. (id t = E) = hs_is_empty t\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 5. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix l"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. is_heap (id (hs_of_list i))\n 2. \\<And>t. (id t = E) = hs_is_empty t\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 4. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 5. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "show \"is_heap (id (hs_of_list l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (id (hs_of_list l))", "proof(induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_heap (id (hs_of_list []))\n 2. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. is_heap (id (hs_of_list []))\n 2. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (id (hs_of_list []))", "by auto"], ["proof (state)\nthis:\n  is_heap (id (hs_of_list []))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "case (Cons a l)"], ["proof (state)\nthis:\n  is_heap (id (hs_of_list l))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "have \"hs_of_list (a # l) = merge (hs_of_list l) (T a E E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs_of_list (a # l) = merge (hs_of_list l) (T a E E)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. HeapFunctional.insert a (hs_of_list l) = merge (hs_of_list l) (T a E E)", "unfolding insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge (hs_of_list l) (T a E E) = merge (hs_of_list l) (T a E E)", "by auto"], ["proof (state)\nthis:\n  hs_of_list (a # l) = merge (hs_of_list l) (T a E E)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "have \"is_heap (T a E E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap (T a E E)", "by auto"], ["proof (state)\nthis:\n  is_heap (T a E E)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "hence \"is_heap (merge (hs_of_list l) (T a E E))\""], ["proof (prove)\nusing this:\n  is_heap (T a E E)\n\ngoal (1 subgoal):\n 1. is_heap (merge (hs_of_list l) (T a E E))", "using Cons merge_heap_is_heap[of \"hs_of_list l\" \"T a E E\"]"], ["proof (prove)\nusing this:\n  is_heap (T a E E)\n  is_heap (id (hs_of_list l))\n  \\<lbrakk>is_heap (hs_of_list l); is_heap (T a E E)\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge (hs_of_list l) (T a E E))\n\ngoal (1 subgoal):\n 1. is_heap (merge (hs_of_list l) (T a E E))", "by auto"], ["proof (state)\nthis:\n  is_heap (merge (hs_of_list l) (T a E E))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       is_heap (id (hs_of_list l)) \\<Longrightarrow>\n       is_heap (id (hs_of_list (a # l)))", "thus ?case"], ["proof (prove)\nusing this:\n  is_heap (merge (hs_of_list l) (T a E E))\n\ngoal (1 subgoal):\n 1. is_heap (id (hs_of_list (a # l)))", "using \\<open>hs_of_list (a # l) = merge (hs_of_list l) (T a E E)\\<close>"], ["proof (prove)\nusing this:\n  is_heap (merge (hs_of_list l) (T a E E))\n  hs_of_list (a # l) = merge (hs_of_list l) (T a E E)\n\ngoal (1 subgoal):\n 1. is_heap (id (hs_of_list (a # l)))", "by auto"], ["proof (state)\nthis:\n  is_heap (id (hs_of_list (a # l)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_heap (id (hs_of_list l))\n\ngoal (4 subgoals):\n 1. \\<And>t. (id t = E) = hs_is_empty t\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 4. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t. (id t = E) = hs_is_empty t\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 4. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t. (id t = E) = hs_is_empty t\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 3. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 4. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "show \" (id t = E) = hs_is_empty t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id t = E) = hs_is_empty t", "by auto"], ["proof (state)\nthis:\n  (id t = E) = hs_is_empty t\n\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t m t'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "assume \"\\<not> hs_is_empty t\" \"(m, t') = hs_remove_max t\""], ["proof (state)\nthis:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "then"], ["proof (chain)\npicking this:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t", "obtain l r where \"t = T m l r\""], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. (\\<And>l r. t = T m l r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Pair_inject Tree.exhaust hs_is_empty_def hs_remove_max.simps)"], ["proof (state)\nthis:\n  t = T m l r\n\ngoal (3 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> add_mset m (Heap.multiset l') = Heap.multiset l\n 2. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 3. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "thus \"add_mset m (multiset t') = multiset t\""], ["proof (prove)\nusing this:\n  t = T m l r\n\ngoal (1 subgoal):\n 1. add_mset m (Heap.multiset t') = Heap.multiset t", "using merge_multiset[of l r]"], ["proof (prove)\nusing this:\n  t = T m l r\n  Heap.multiset l + Heap.multiset r = Heap.multiset (merge l r)\n\ngoal (1 subgoal):\n 1. add_mset m (Heap.multiset t') = Heap.multiset t", "using \\<open>(m, t') = hs_remove_max t\\<close>"], ["proof (prove)\nusing this:\n  t = T m l r\n  Heap.multiset l + Heap.multiset r = Heap.multiset (merge l r)\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. add_mset m (Heap.multiset t') = Heap.multiset t", "by auto"], ["proof (state)\nthis:\n  add_mset m (Heap.multiset t') = Heap.multiset t\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t m t'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "assume \"\\<not> hs_is_empty t\" \"is_heap (id t)\" \"(m, t') = hs_remove_max t\""], ["proof (state)\nthis:\n  \\<not> hs_is_empty t\n  is_heap (id t)\n  (m, t') = hs_remove_max t\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "then"], ["proof (chain)\npicking this:\n  \\<not> hs_is_empty t\n  is_heap (id t)\n  (m, t') = hs_remove_max t", "obtain v l r where \"t = T v l r\""], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  is_heap (id t)\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. (\\<And>v l r. t = T v l r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Tree.exhaust hs_is_empty_def)"], ["proof (state)\nthis:\n  t = T v l r\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "hence \"t' = merge l r\""], ["proof (prove)\nusing this:\n  t = T v l r\n\ngoal (1 subgoal):\n 1. t' = merge l r", "using \\<open>(m, t') = hs_remove_max t\\<close>"], ["proof (prove)\nusing this:\n  t = T v l r\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. t' = merge l r", "by auto"], ["proof (state)\nthis:\n  t' = merge l r\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "have \"is_heap l \\<and> is_heap r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap l \\<and> is_heap r", "using \\<open>is_heap (id t)\\<close>"], ["proof (prove)\nusing this:\n  is_heap (id t)\n\ngoal (1 subgoal):\n 1. is_heap l \\<and> is_heap r", "using \\<open>t = T v l r\\<close>"], ["proof (prove)\nusing this:\n  is_heap (id t)\n  t = T v l r\n\ngoal (1 subgoal):\n 1. is_heap l \\<and> is_heap r", "by (metis Tree.exhaust id_apply is_heap.simps(1) \n        is_heap.simps(3) is_heap.simps(4) is_heap.simps(5))"], ["proof (state)\nthis:\n  is_heap l \\<and> is_heap r\n\ngoal (2 subgoals):\n 1. \\<And>l m l'.\n       \\<lbrakk>\\<not> hs_is_empty l; is_heap (id l);\n        (m, l') = hs_remove_max l\\<rbrakk>\n       \\<Longrightarrow> is_heap (id l')\n 2. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "thus \"is_heap (id t')\""], ["proof (prove)\nusing this:\n  is_heap l \\<and> is_heap r\n\ngoal (1 subgoal):\n 1. is_heap (id t')", "using \\<open>t' = merge l r\\<close>"], ["proof (prove)\nusing this:\n  is_heap l \\<and> is_heap r\n  t' = merge l r\n\ngoal (1 subgoal):\n 1. is_heap (id t')", "using merge_heap_is_heap"], ["proof (prove)\nusing this:\n  is_heap l \\<and> is_heap r\n  t' = merge l r\n  \\<lbrakk>is_heap ?l; is_heap ?r\\<rbrakk>\n  \\<Longrightarrow> is_heap (merge ?l ?r)\n\ngoal (1 subgoal):\n 1. is_heap (id t')", "by auto"], ["proof (state)\nthis:\n  is_heap (id t')\n\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "fix t m t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "assume \"\\<not> hs_is_empty t\" \"(m, t') = hs_remove_max t\""], ["proof (state)\nthis:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. \\<And>t m t'.\n       \\<lbrakk>\\<not> hs_is_empty t; (m, t') = hs_remove_max t\\<rbrakk>\n       \\<Longrightarrow> m = val (id t)", "thus \"m = val (id t)\""], ["proof (prove)\nusing this:\n  \\<not> hs_is_empty t\n  (m, t') = hs_remove_max t\n\ngoal (1 subgoal):\n 1. m = val (id t)", "by (metis Pair_inject Tree.exhaust hs_is_empty_def \n        hs_remove_max.simps id_apply val.simps)"], ["proof (state)\nthis:\n  m = val (id t)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}