{"file_name": "/home/qj213/afp-2021-10-22/thys/Median_Of_Medians_Selection/Median_Of_Medians_Selection.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Median_Of_Medians_Selection", "problem_names": ["lemma mset_concat: \"mset (concat xss) = sum_list (map mset xss)\"", "lemma set_mset_sum_list [simp]: \"set_mset (sum_list xs) = (\\<Union>x\\<in>set xs. set_mset x)\"", "lemma filter_mset_image_mset:\n  \"filter_mset P (image_mset f A) = image_mset f (filter_mset (\\<lambda>x. P (f x)) A)\"", "lemma filter_mset_sum_list: \"filter_mset P (sum_list xs) = sum_list (map (filter_mset P) xs)\"", "lemma sum_mset_mset_mono: \n  assumes \"(\\<And>x. x \\<in># A \\<Longrightarrow> f x \\<subseteq># g x)\"\n  shows   \"(\\<Sum>x\\<in>#A. f x) \\<subseteq># (\\<Sum>x\\<in>#A. g x)\"", "lemma mset_filter_mono:\n  assumes \"A \\<subseteq># B\" \"\\<And>x. x \\<in># A \\<Longrightarrow> P x \\<Longrightarrow> Q x\"\n  shows   \"filter_mset P A \\<subseteq># filter_mset Q B\"", "lemma size_mset_sum_mset_distrib: \"size (sum_mset A :: 'a multiset) = sum_mset (image_mset size A)\"", "lemma sum_mset_mono:\n  assumes \"\\<And>x. x \\<in># A \\<Longrightarrow> f x \\<le> (g x :: 'a :: {ordered_ab_semigroup_add,comm_monoid_add})\"\n  shows   \"(\\<Sum>x\\<in>#A. f x) \\<le> (\\<Sum>x\\<in>#A. g x)\"", "lemma filter_mset_is_empty_iff: \"filter_mset P A = {#} \\<longleftrightarrow> (\\<forall>x. x \\<in># A \\<longrightarrow> \\<not>P x)\"", "lemma sorted_filter_less_subset_take:\n  assumes \"sorted xs\" \"i < length xs\"\n  shows   \"{# x \\<in># mset xs. x < xs ! i #} \\<subseteq># mset (take i xs)\"", "lemma sorted_filter_greater_subset_drop:\n  assumes \"sorted xs\" \"i < length xs\"\n  shows   \"{# x \\<in># mset xs. x > xs ! i #} \\<subseteq># mset (drop (Suc i) xs)\"", "lemma chop_transfer [transfer_rule]: \n  \"((=) ===> list_all2 R ===> list_all2 (list_all2 R)) chop chop\"", "lemma chop_reduce: \"chop n xs = (if n = 0 \\<or> xs = [] then [] else take n xs # chop n (drop n xs))\"", "lemma concat_chop [simp]: \"n > 0 \\<Longrightarrow> concat (chop n xs) = xs\"", "lemma chop_elem_not_Nil [simp,dest]: \"ys \\<in> set (chop n xs) \\<Longrightarrow> ys \\<noteq> []\"", "lemma chop_eq_Nil_iff [simp]: \"chop n xs = [] \\<longleftrightarrow> n = 0 \\<or> xs = []\"", "lemma chop_ge_length_eq: \"n > 0 \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> n \\<ge> length xs \\<Longrightarrow> chop n xs = [xs]\"", "lemma length_chop_part_le: \"ys \\<in> set (chop n xs) \\<Longrightarrow> length ys \\<le> n\"", "lemma length_nth_chop:\n  assumes \"i < length (chop n xs)\"\n  shows   \"length (chop n xs ! i) = \n             (if i = length (chop n xs) - 1 \\<and> \\<not>n dvd length xs then length xs mod n else n)\"", "lemma length_chop:\n  assumes \"n > 0\"\n  shows   \"length (chop n xs) = nat \\<lceil>length xs / n\\<rceil>\"", "lemma sum_msets_chop: \"n > 0 \\<Longrightarrow> (\\<Sum>ys\\<leftarrow>chop n xs. mset ys) = mset xs\"", "lemma UN_sets_chop: \"n > 0 \\<Longrightarrow> (\\<Union>ys\\<in>set (chop n xs). set ys) = set xs\"", "lemma in_set_chopD [dest]:\n  assumes \"x \\<in> set ys\" \"ys \\<in> set (chop d xs)\"\n  shows   \"x \\<in> set xs\"", "lemma select_in_set [intro,simp]:\n  assumes \"k < length xs\"\n  shows   \"select k xs \\<in> set xs\"", "lemma median_in_set [intro, simp]: \n  assumes \"xs \\<noteq> []\"\n  shows   \"median xs \\<in> set xs\"", "lemma sort_cong: \"mset xs = mset ys \\<Longrightarrow> sort xs = sort ys\"", "lemma select_cong:\n  \"k = k' \\<Longrightarrow> mset xs = mset xs' \\<Longrightarrow> select k xs = select k' xs'\"", "lemma median_cong: \"mset xs = mset xs' \\<Longrightarrow> median xs = median xs'\"", "lemma sort_append:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> x \\<le> y\"\n  shows   \"sort (xs @ ys) = sort xs @ sort ys\"", "lemma select_append:\n  assumes \"\\<And>y z. y \\<in> set ys \\<Longrightarrow> z \\<in> set zs \\<Longrightarrow> y \\<le> z\"\n  shows   \"k < length ys \\<Longrightarrow> select k (ys @ zs) = select k ys\"\n          \"k \\<in> {length ys..<length ys + length zs} \\<Longrightarrow>\n             select k (ys @ zs) = select (k - length ys) zs\"", "lemma select_append':\n  assumes \"\\<And>y z. y \\<in> set ys \\<Longrightarrow> z \\<in> set zs \\<Longrightarrow> y \\<le> z\" \"k < length ys + length zs\"\n  shows   \"select k (ys @ zs) = (if k < length ys then select k ys else select (k - length ys) zs)\"", "lemma size_less_than_median:\n  \"size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\"", "lemma size_greater_than_median:\n  \"size {#y \\<in># mset xs. y > median xs#} \\<le> length xs div 2\"", "lemma transfer_is_median [transfer_rule]:\n  assumes [transfer_rule]: \"(r ===> r ===> (=)) (<) (<)\"\n  shows   \"(r ===> list_all2 r ===> (=)) is_median is_median\"", "lemma list_all2_eq_fun_conv_map: \"list_all2 (\\<lambda>x y. x = f y) xs ys \\<longleftrightarrow> xs = map f ys\"", "lemma transfer_is_median_dual_ord [transfer_rule]:\n  \"(pcr_dual_ord (=) ===> list_all2 (pcr_dual_ord (=)) ===> (=)) is_median is_median\"", "lemma is_median_to_dual_ord_iff [simp]:\n  \"is_median (to_dual_ord x) (map to_dual_ord xs) \\<longleftrightarrow> is_median x xs\"", "lemma is_median_altdef:\n  \"is_median x xs \\<longleftrightarrow> size (filter_mset (\\<lambda>y. y < x) (mset xs)) \\<le> length xs div 2 \\<and>\n                      size (filter_mset (\\<lambda>y. y > x) (mset xs)) \\<le> length xs div 2\"", "lemma is_median_cong:\n  assumes \"x = y\" \"mset xs = mset ys\"\n  shows   \"is_median x xs \\<longleftrightarrow> is_median y ys\"", "lemma is_median_Cons_odd:\n  assumes \"is_median x xs\" and \"odd (length xs)\"\n  shows   \"is_median x (y # xs)\"", "lemma is_median_median [simp,intro]: \"is_median (median xs) xs\"", "lemma size_less_than_median_of_medians_strong:\n  fixes xs :: \"'a :: linorder list\" and d :: nat\n  assumes d: \"d > 0\"\n  assumes median: \"\\<And>xs. xs \\<noteq> [] \\<Longrightarrow> length xs \\<le> d \\<Longrightarrow> is_median (med xs) xs\"\n  assumes median': \"is_median x (map med (chop d xs))\"\n  defines \"m \\<equiv> length (chop d xs)\"\n  shows   \"size {#y \\<in># mset xs. y < x#} \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)\"", "theorem size_less_than_median_of_medians:\n  fixes xs :: \"'a :: linorder list\" and d :: nat\n  assumes median: \"\\<And>xs. xs \\<noteq> [] \\<Longrightarrow> length xs \\<le> Suc (2 * d) \\<Longrightarrow> is_median (med xs) xs\"\n  assumes median': \"is_median x (map med (chop (Suc (2*d)) xs))\"\n  defines \"n \\<equiv> length xs\"\n  defines \"c \\<equiv> (3 * real d + 1) / (2 * (2 * d + 1))\"\n  shows   \"size {#y \\<in># mset xs. y < x#} \\<le> nat \\<lceil>c * n\\<rceil> + (5 * d) div 2 + 1\"", "theorem size_greater_than_median_of_medians:\n  fixes xs :: \"'a :: linorder list\" and d :: nat\n  assumes median: \"\\<And>xs. xs \\<noteq> [] \\<Longrightarrow> length xs \\<le> Suc (2 * d) \\<Longrightarrow> is_median (med xs) xs\"\n  assumes median': \"is_median x (map med (chop (Suc (2*d)) xs))\" \n  defines \"n \\<equiv> length xs\"\n  defines \"c \\<equiv> (3 * real d + 1) / (2 * (2 * d + 1))\"\n  shows   \"size {#y \\<in># mset xs. y > x#} \\<le> nat \\<lceil>c * n\\<rceil> + (5 * d) div 2 + 1\"", "theorem select_rec_partition:\n  assumes \"d > 0\" \"k < length xs\"\n  shows \"select k xs = (\n           let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n           in  if k < length ys then select k ys else select (k - length ys) zs\n          )\" (is \"_ = ?rhs\")", "lemma threeway_partition_code [code]:\n  \"threeway_partition x [] = ([], [], [])\"\n  \"threeway_partition x (y # ys) =\n     (case threeway_partition x ys of (ls, es, gs) \\<Rightarrow>\n        if y < x then (y # ls, es, gs) else if x = y then (ls, y # es, gs) else (ls, es, y # gs))\"", "theorem select_rec_threeway_partition:\n  assumes \"d > 0\" \"k < length xs\"\n  shows \"select k xs = (\n           let (ls, es, gs) = threeway_partition x xs;\n               nl = length ls; ne = length es\n           in\n             if k < nl then select k ls \n             else if k < nl + ne then x\n             else select (k - nl - ne) gs\n          )\" (is \"_ = ?rhs\")", "lemma median_3: \"median_3 a b c = median [a, b, c]\"", "lemma median_5_aux:\n  assumes \"x1 \\<le> x2\" \"x4 \\<le> x5\" \"x1 \\<le> x4\" \n  shows   \"median_5_aux x1 x2 x3 x4 x5 = median [x1,x2,x3,x4,x5]\"", "lemma median_5: \"median_5 a b c d e = median [a, b, c, d, e]\"", "lemma median_5_in_set: \"median_5 a b c d e \\<in> {a, b, c, d, e}\"", "lemma median_le_5_in_set:\n  assumes \"xs \\<noteq> []\" \"length xs \\<le> 5\"\n  shows   \"median_le_5 xs \\<in> set xs\"", "lemma median_le_5:\n  assumes \"xs \\<noteq> []\" \"length xs \\<le> 5\"\n  shows   \"is_median (median_le_5 xs) xs\"", "lemma fast_select_correct_aux:\n  assumes \"fast_select_dom (k, xs)\" \"k < length xs\"\n  shows   \"fast_select k xs = select k xs\"", "lemma fast_select_termination: \"All fast_select_dom\"", "theorem fast_select_correct: \"k < length xs \\<Longrightarrow> fast_select k xs = select k xs\"", "lemma fast_select_code [code]:\n  \"fast_select k xs = (\n     if length xs \\<le> 20 then\n       fold insort xs [] ! k\n     else\n       let x = fast_select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs));\n           (ls, es, gs) = threeway_partition x xs;\n           nl = length ls; ne = nl + length es\n       in\n         if k < nl then fast_select k ls \n         else if k < ne then x\n         else fast_select (k - ne) gs\n      )\"", "lemma select_code [code]: \n  \"select k xs = (if k < length xs then fast_select k xs \n                    else Code.abort (STR ''Selection index out of bounds.'') (\\<lambda>_. select k xs))\""], "translations": [["", "lemma mset_concat: \"mset (concat xss) = sum_list (map mset xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (concat xss) = sum_list (map mset xss)", "by (induction xss) simp_all"], ["", "lemma set_mset_sum_list [simp]: \"set_mset (sum_list xs) = (\\<Union>x\\<in>set xs. set_mset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (sum_list xs) = \\<Union> (set_mset ` set xs)", "by (induction xs) auto"], ["", "lemma filter_mset_image_mset:\n  \"filter_mset P (image_mset f A) = image_mset f (filter_mset (\\<lambda>x. P (f x)) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (image_mset f A) = image_mset f {#x \\<in># A. P (f x)#}", "by (induction A) auto"], ["", "lemma filter_mset_sum_list: \"filter_mset P (sum_list xs) = sum_list (map (filter_mset P) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (sum_list xs) = sum_list (map (filter_mset P) xs)", "by (induction xs) simp_all"], ["", "lemma sum_mset_mset_mono: \n  assumes \"(\\<And>x. x \\<in># A \\<Longrightarrow> f x \\<subseteq># g x)\"\n  shows   \"(\\<Sum>x\\<in>#A. f x) \\<subseteq># (\\<Sum>x\\<in>#A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f A) \\<subseteq>#\n    \\<Sum>\\<^sub># (image_mset g A)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow> f ?x \\<subseteq># g ?x\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f A) \\<subseteq>#\n    \\<Sum>\\<^sub># (image_mset g A)", "by (induction A) (auto intro!: subset_mset.add_mono)"], ["", "lemma mset_filter_mono:\n  assumes \"A \\<subseteq># B\" \"\\<And>x. x \\<in># A \\<Longrightarrow> P x \\<Longrightarrow> Q x\"\n  shows   \"filter_mset P A \\<subseteq># filter_mset Q B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P A \\<subseteq># filter_mset Q B", "by (rule mset_subset_eqI) (insert assms, auto simp: mset_subset_eq_count count_eq_zero_iff)"], ["", "lemma size_mset_sum_mset_distrib: \"size (sum_mset A :: 'a multiset) = sum_mset (image_mset size A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (\\<Sum>\\<^sub># A) = \\<Sum>\\<^sub># (image_mset size A)", "by (induction A) auto"], ["", "lemma sum_mset_mono:\n  assumes \"\\<And>x. x \\<in># A \\<Longrightarrow> f x \\<le> (g x :: 'a :: {ordered_ab_semigroup_add,comm_monoid_add})\"\n  shows   \"(\\<Sum>x\\<in>#A. f x) \\<le> (\\<Sum>x\\<in>#A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f A) \\<le> \\<Sum>\\<^sub># (image_mset g A)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in># A \\<Longrightarrow> f ?x \\<le> g ?x\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f A) \\<le> \\<Sum>\\<^sub># (image_mset g A)", "by (induction A) (auto intro!: add_mono)"], ["", "lemma filter_mset_is_empty_iff: \"filter_mset P A = {#} \\<longleftrightarrow> (\\<forall>x. x \\<in># A \\<longrightarrow> \\<not>P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (filter_mset P A = {#}) =\n    (\\<forall>x. x \\<in># A \\<longrightarrow> \\<not> P x)", "by (auto simp: multiset_eq_iff count_eq_zero_iff)"], ["", "lemma sorted_filter_less_subset_take:\n  assumes \"sorted xs\" \"i < length xs\"\n  shows   \"{# x \\<in># mset xs. x < xs ! i #} \\<subseteq># mset (take i xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<in># mset xs. x < xs ! i#} \\<subseteq># mset (take i xs)", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. {#x \\<in># mset xs. x < xs ! i#} \\<subseteq># mset (take i xs)", "proof (induction xs arbitrary: i rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>sorted []; i < length []\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset []. x < [] ! i#} \\<subseteq>#\n                         mset (take i [])\n 2. \\<And>x1 x2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>sorted x2; i < length x2\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset x2.\nx < x2 ! i#} \\<subseteq>#\n                                     mset (take i x2);\n        sorted (x1 # x2); i < length (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset (x1 # x2).\n                          x < (x1 # x2) ! i#} \\<subseteq>#\n                         mset (take i (x1 # x2))", "case (Cons x xs i)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted xs; ?i < length xs\\<rbrakk>\n  \\<Longrightarrow> {#x \\<in># mset xs. x < xs ! ?i#} \\<subseteq>#\n                    mset (take ?i xs)\n  sorted (x # xs)\n  i < length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>sorted []; i < length []\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset []. x < [] ! i#} \\<subseteq>#\n                         mset (take i [])\n 2. \\<And>x1 x2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>sorted x2; i < length x2\\<rbrakk>\n                   \\<Longrightarrow> {#x \\<in># mset x2.\nx < x2 ! i#} \\<subseteq>#\n                                     mset (take i x2);\n        sorted (x1 # x2); i < length (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset (x1 # x2).\n                          x < (x1 # x2) ! i#} \\<subseteq>#\n                         mset (take i (x1 # x2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n    mset (take i (x # xs))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n    mset (take i (x # xs))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n    mset (take i (x # xs))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n    mset (take i (x # xs))", "using Cons.prems"], ["proof (prove)\nusing this:\n  i = 0\n  sorted (x # xs)\n  i < length (x # xs)\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n    mset (take i (x # xs))", "by (auto simp: filter_mset_is_empty_iff)"], ["proof (state)\nthis:\n  {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n  mset (take i (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "have \"{#y \\<in># mset (x # xs). y < (x # xs) ! i#} \\<subseteq># add_mset x {#y \\<in># mset xs. y < xs ! i'#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#y \\<in># mset (x # xs). y < (x # xs) ! i#} \\<subseteq>#\n    add_mset x {#y \\<in># mset xs. y < xs ! i'#}", "using Suc Cons.prems"], ["proof (prove)\nusing this:\n  i = Suc i'\n  sorted (x # xs)\n  i < length (x # xs)\n\ngoal (1 subgoal):\n 1. {#y \\<in># mset (x # xs). y < (x # xs) ! i#} \\<subseteq>#\n    add_mset x {#y \\<in># mset xs. y < xs ! i'#}", "by (auto)"], ["proof (state)\nthis:\n  {#y \\<in># mset (x # xs). y < (x # xs) ! i#} \\<subseteq>#\n  add_mset x {#y \\<in># mset xs. y < xs ! i'#}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "also"], ["proof (state)\nthis:\n  {#y \\<in># mset (x # xs). y < (x # xs) ! i#} \\<subseteq>#\n  add_mset x {#y \\<in># mset xs. y < xs ! i'#}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "have \"\\<dots> \\<subseteq># add_mset x (mset (take i' xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x {#y \\<in># mset xs. y < xs ! i'#} \\<subseteq>#\n    add_mset x (mset (take i' xs))", "unfolding mset_subset_eq_add_mset_cancel"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#y \\<in># mset xs. y < xs ! i'#} \\<subseteq># mset (take i' xs)", "using Cons.prems Suc"], ["proof (prove)\nusing this:\n  sorted (x # xs)\n  i < length (x # xs)\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. {#y \\<in># mset xs. y < xs ! i'#} \\<subseteq># mset (take i' xs)", "by (intro Cons.IH) (auto)"], ["proof (state)\nthis:\n  add_mset x {#y \\<in># mset xs. y < xs ! i'#} \\<subseteq>#\n  add_mset x (mset (take i' xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "also"], ["proof (state)\nthis:\n  add_mset x {#y \\<in># mset xs. y < xs ! i'#} \\<subseteq>#\n  add_mset x (mset (take i' xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "have \"\\<dots> = mset (take i (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset x (mset (take i' xs)) = mset (take i (x # xs))", "by (simp add: Suc)"], ["proof (state)\nthis:\n  add_mset x (mset (take i' xs)) = mset (take i (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n       mset (take i (x # xs))", "finally"], ["proof (chain)\npicking this:\n  {#y \\<in># mset (x # xs). y < (x # xs) ! i#} \\<subseteq>#\n  mset (take i (x # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  {#y \\<in># mset (x # xs). y < (x # xs) ! i#} \\<subseteq>#\n  mset (take i (x # xs))\n\ngoal (1 subgoal):\n 1. {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n    mset (take i (x # xs))", "."], ["proof (state)\nthis:\n  {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n  mset (take i (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {#xa \\<in># mset (x # xs). xa < (x # xs) ! i#} \\<subseteq>#\n  mset (take i (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>sorted []; i < length []\\<rbrakk>\n       \\<Longrightarrow> {#x \\<in># mset []. x < [] ! i#} \\<subseteq>#\n                         mset (take i [])", "qed auto"], ["", "lemma sorted_filter_greater_subset_drop:\n  assumes \"sorted xs\" \"i < length xs\"\n  shows   \"{# x \\<in># mset xs. x > xs ! i #} \\<subseteq># mset (drop (Suc i) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((<) (xs ! i)) (mset xs) \\<subseteq># mset (drop (Suc i) xs)", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. filter_mset ((<) (xs ! i)) (mset xs) \\<subseteq># mset (drop (Suc i) xs)", "proof (induction xs arbitrary: i rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>sorted []; i < length []\\<rbrakk>\n       \\<Longrightarrow> filter_mset ((<) ([] ! i)) (mset []) \\<subseteq>#\n                         mset (drop (Suc i) [])\n 2. \\<And>x1 x2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>sorted x2; i < length x2\\<rbrakk>\n                   \\<Longrightarrow> filter_mset ((<) (x2 ! i))\n(mset x2) \\<subseteq>#\n                                     mset (drop (Suc i) x2);\n        sorted (x1 # x2); i < length (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> filter_mset ((<) ((x1 # x2) ! i))\n                          (mset (x1 # x2)) \\<subseteq>#\n                         mset (drop (Suc i) (x1 # x2))", "case (Cons x xs i)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted xs; ?i < length xs\\<rbrakk>\n  \\<Longrightarrow> filter_mset ((<) (xs ! ?i)) (mset xs) \\<subseteq>#\n                    mset (drop (Suc ?i) xs)\n  sorted (x # xs)\n  i < length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>sorted []; i < length []\\<rbrakk>\n       \\<Longrightarrow> filter_mset ((<) ([] ! i)) (mset []) \\<subseteq>#\n                         mset (drop (Suc i) [])\n 2. \\<And>x1 x2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>sorted x2; i < length x2\\<rbrakk>\n                   \\<Longrightarrow> filter_mset ((<) (x2 ! i))\n(mset x2) \\<subseteq>#\n                                     mset (drop (Suc i) x2);\n        sorted (x1 # x2); i < length (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> filter_mset ((<) ((x1 # x2) ! i))\n                          (mset (x1 # x2)) \\<subseteq>#\n                         mset (drop (Suc i) (x1 # x2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n    mset (drop (Suc i) (x # xs))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n    mset (drop (Suc i) (x # xs))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n    mset (drop (Suc i) (x # xs))\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n    mset (drop (Suc i) (x # xs))", "by (auto simp: sorted_append filter_mset_is_empty_iff)"], ["proof (state)\nthis:\n  filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n  mset (drop (Suc i) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "have \"{#y \\<in># mset (x # xs). y > (x # xs) ! i#} \\<subseteq># {#y \\<in># mset xs. y > xs ! i'#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n    filter_mset ((<) (xs ! i')) (mset xs)", "using Suc Cons.prems"], ["proof (prove)\nusing this:\n  i = Suc i'\n  sorted (x # xs)\n  i < length (x # xs)\n\ngoal (1 subgoal):\n 1. filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n    filter_mset ((<) (xs ! i')) (mset xs)", "by (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n  filter_mset ((<) (xs ! i')) (mset xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "also"], ["proof (state)\nthis:\n  filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n  filter_mset ((<) (xs ! i')) (mset xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "have \"\\<dots> \\<subseteq># mset (drop (Suc i') xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((<) (xs ! i')) (mset xs) \\<subseteq>#\n    mset (drop (Suc i') xs)", "using Cons.prems Suc"], ["proof (prove)\nusing this:\n  sorted (x # xs)\n  i < length (x # xs)\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. filter_mset ((<) (xs ! i')) (mset xs) \\<subseteq>#\n    mset (drop (Suc i') xs)", "by (intro Cons.IH) (auto)"], ["proof (state)\nthis:\n  filter_mset ((<) (xs ! i')) (mset xs) \\<subseteq># mset (drop (Suc i') xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "also"], ["proof (state)\nthis:\n  filter_mset ((<) (xs ! i')) (mset xs) \\<subseteq># mset (drop (Suc i') xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "have \"\\<dots> = mset (drop (Suc i) (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (drop (Suc i') xs) = mset (drop (Suc i) (x # xs))", "by (simp add: Suc)"], ["proof (state)\nthis:\n  mset (drop (Suc i') xs) = mset (drop (Suc i) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n       mset (drop (Suc i) (x # xs))", "finally"], ["proof (chain)\npicking this:\n  filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n  mset (drop (Suc i) (x # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n  mset (drop (Suc i) (x # xs))\n\ngoal (1 subgoal):\n 1. filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n    mset (drop (Suc i) (x # xs))", "."], ["proof (state)\nthis:\n  filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n  mset (drop (Suc i) (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter_mset ((<) ((x # xs) ! i)) (mset (x # xs)) \\<subseteq>#\n  mset (drop (Suc i) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>sorted []; i < length []\\<rbrakk>\n       \\<Longrightarrow> filter_mset ((<) ([] ! i)) (mset []) \\<subseteq>#\n                         mset (drop (Suc i) [])", "qed auto"], ["", "subsection \\<open>The dual order type\\<close>"], ["", "text \\<open>\n  The following type is a copy of a given ordered base type, but with the ordering reversed.\n  This will be useful later because we can do some of our reasoning simply by symmetry.\n\\<close>"], ["", "typedef 'a dual_ord = \"UNIV :: 'a set\" morphisms of_dual_ord to_dual_ord"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", "by auto"], ["", "setup_lifting type_definition_dual_ord"], ["", "instantiation dual_ord :: (ord) ord\nbegin"], ["", "lift_definition less_eq_dual_ord :: \"'a dual_ord \\<Rightarrow> 'a dual_ord \\<Rightarrow> bool\" is\n  \"\\<lambda>a b :: 'a. a \\<ge> b\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_dual_ord :: \"'a dual_ord \\<Rightarrow> 'a dual_ord \\<Rightarrow> bool\" is\n  \"\\<lambda>a b :: 'a. a > b\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual_ord, ord_class)", ".."], ["", "end"], ["", "instance dual_ord :: (preorder) preorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual_ord, preorder_class)", "by standard (transfer; force simp: less_le_not_le intro: order_trans)+"], ["", "instance dual_ord :: (linorder) linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual_ord, linorder_class)", "by standard (transfer; force simp: not_le)+"], ["", "subsection \\<open>Chopping a list into equal-sized sublists\\<close>"], ["", "(* TODO: Move to library? *)"], ["", "function chop :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\" where\n  \"chop n [] = []\"\n| \"chop 0 xs = []\"\n| \"n > 0 \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> chop n xs = take n xs # chop n (drop n xs)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>n. x = (n, []) \\<Longrightarrow> P;\n        \\<And>xs. x = (0, xs) \\<Longrightarrow> P;\n        \\<And>n xs.\n           \\<lbrakk>0 < n; xs \\<noteq> []; x = (n, xs)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>n na. (n, []) = (na, []) \\<Longrightarrow> [] = []\n 3. \\<And>n xs. (n, []) = (0, xs) \\<Longrightarrow> [] = []\n 4. \\<And>n na xs.\n       \\<lbrakk>0 < na; xs \\<noteq> []; (n, []) = (na, xs)\\<rbrakk>\n       \\<Longrightarrow> [] = take na xs # chop_sumC (na, drop na xs)\n 5. \\<And>xs xsa. (0, xs) = (0, xsa) \\<Longrightarrow> [] = []\n 6. \\<And>xs n xsa.\n       \\<lbrakk>0 < n; xsa \\<noteq> []; (0, xs) = (n, xsa)\\<rbrakk>\n       \\<Longrightarrow> [] = take n xsa # chop_sumC (n, drop n xsa)\n 7. \\<And>n xs na xsa.\n       \\<lbrakk>0 < n; xs \\<noteq> []; 0 < na; xsa \\<noteq> [];\n        (n, xs) = (na, xsa)\\<rbrakk>\n       \\<Longrightarrow> take n xs # chop_sumC (n, drop n xs) =\n                         take na xsa # chop_sumC (na, drop na xsa)", "by force+"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All chop_dom", "by lexicographic_order"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma chop_transfer [transfer_rule]: \n  \"((=) ===> list_all2 R ===> list_all2 (list_all2 R)) chop chop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> list_all2 R ===> list_all2 (list_all2 R)) chop chop", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; list_all2 R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 (list_all2 R) (chop x xa) (chop y ya)", "fix m n ::nat and xs :: \"'a list\" and ys :: \"'b list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; list_all2 R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 (list_all2 R) (chop x xa) (chop y ya)", "assume \"m = n\" \"list_all2 R xs ys\""], ["proof (state)\nthis:\n  m = n\n  list_all2 R xs ys\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; list_all2 R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 (list_all2 R) (chop x xa) (chop y ya)", "from this(2)"], ["proof (chain)\npicking this:\n  list_all2 R xs ys", "have \"list_all2 (list_all2 R) (chop n xs) (chop n ys)\""], ["proof (prove)\nusing this:\n  list_all2 R xs ys\n\ngoal (1 subgoal):\n 1. list_all2 (list_all2 R) (chop n xs) (chop n ys)", "proof (induction n xs arbitrary: ys rule: chop.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n ys.\n       list_all2 R [] ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop n []) (chop n ys)\n 2. \\<And>xs ys.\n       list_all2 R xs ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop 0 xs) (chop 0 ys)\n 3. \\<And>n xs ys.\n       \\<lbrakk>0 < n; xs \\<noteq> [];\n        \\<And>ys.\n           list_all2 R (drop n xs) ys \\<Longrightarrow>\n           list_all2 (list_all2 R) (chop n (drop n xs)) (chop n ys);\n        list_all2 R xs ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 (list_all2 R) (chop n xs) (chop n ys)", "case (3 n xs ys)"], ["proof (state)\nthis:\n  0 < n\n  xs \\<noteq> []\n  list_all2 R (drop n xs) ?ys \\<Longrightarrow>\n  list_all2 (list_all2 R) (chop n (drop n xs)) (chop n ?ys)\n  list_all2 R xs ys\n\ngoal (3 subgoals):\n 1. \\<And>n ys.\n       list_all2 R [] ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop n []) (chop n ys)\n 2. \\<And>xs ys.\n       list_all2 R xs ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop 0 xs) (chop 0 ys)\n 3. \\<And>n xs ys.\n       \\<lbrakk>0 < n; xs \\<noteq> [];\n        \\<And>ys.\n           list_all2 R (drop n xs) ys \\<Longrightarrow>\n           list_all2 (list_all2 R) (chop n (drop n xs)) (chop n ys);\n        list_all2 R xs ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 (list_all2 R) (chop n xs) (chop n ys)", "hence \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  0 < n\n  xs \\<noteq> []\n  list_all2 R (drop n xs) ?ys \\<Longrightarrow>\n  list_all2 (list_all2 R) (chop n (drop n xs)) (chop n ?ys)\n  list_all2 R xs ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>n ys.\n       list_all2 R [] ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop n []) (chop n ys)\n 2. \\<And>xs ys.\n       list_all2 R xs ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop 0 xs) (chop 0 ys)\n 3. \\<And>n xs ys.\n       \\<lbrakk>0 < n; xs \\<noteq> [];\n        \\<And>ys.\n           list_all2 R (drop n xs) ys \\<Longrightarrow>\n           list_all2 (list_all2 R) (chop n (drop n xs)) (chop n ys);\n        list_all2 R xs ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 (list_all2 R) (chop n xs) (chop n ys)", "with 3"], ["proof (chain)\npicking this:\n  0 < n\n  xs \\<noteq> []\n  list_all2 R (drop n xs) ?ys \\<Longrightarrow>\n  list_all2 (list_all2 R) (chop n (drop n xs)) (chop n ?ys)\n  list_all2 R xs ys\n  ys \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  0 < n\n  xs \\<noteq> []\n  list_all2 R (drop n xs) ?ys \\<Longrightarrow>\n  list_all2 (list_all2 R) (chop n (drop n xs)) (chop n ?ys)\n  list_all2 R xs ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_all2 (list_all2 R) (chop n xs) (chop n ys)", "by auto"], ["proof (state)\nthis:\n  list_all2 (list_all2 R) (chop n xs) (chop n ys)\n\ngoal (2 subgoals):\n 1. \\<And>n ys.\n       list_all2 R [] ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop n []) (chop n ys)\n 2. \\<And>xs ys.\n       list_all2 R xs ys \\<Longrightarrow>\n       list_all2 (list_all2 R) (chop 0 xs) (chop 0 ys)", "qed auto"], ["proof (state)\nthis:\n  list_all2 (list_all2 R) (chop n xs) (chop n ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x = y; list_all2 R xa ya\\<rbrakk>\n       \\<Longrightarrow> list_all2 (list_all2 R) (chop x xa) (chop y ya)", "with \\<open>m = n\\<close>"], ["proof (chain)\npicking this:\n  m = n\n  list_all2 (list_all2 R) (chop n xs) (chop n ys)", "show \"list_all2 (list_all2 R) (chop m xs) (chop n ys)\""], ["proof (prove)\nusing this:\n  m = n\n  list_all2 (list_all2 R) (chop n xs) (chop n ys)\n\ngoal (1 subgoal):\n 1. list_all2 (list_all2 R) (chop m xs) (chop n ys)", "by simp"], ["proof (state)\nthis:\n  list_all2 (list_all2 R) (chop m xs) (chop n ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma chop_reduce: \"chop n xs = (if n = 0 \\<or> xs = [] then [] else take n xs # chop n (drop n xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chop n xs =\n    (if n = 0 \\<or> xs = [] then [] else take n xs # chop n (drop n xs))", "by (cases \"n = 0\"; cases \"xs = []\") auto"], ["", "lemma concat_chop [simp]: \"n > 0 \\<Longrightarrow> concat (chop n xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> concat (chop n xs) = xs", "by (induction n xs rule: chop.induct) auto"], ["", "lemma chop_elem_not_Nil [simp,dest]: \"ys \\<in> set (chop n xs) \\<Longrightarrow> ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (chop n xs) \\<Longrightarrow> ys \\<noteq> []", "by (induction n xs rule: chop.induct) (auto simp: eq_commute[of \"[]\"])"], ["", "lemma chop_eq_Nil_iff [simp]: \"chop n xs = [] \\<longleftrightarrow> n = 0 \\<or> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (chop n xs = []) = (n = 0 \\<or> xs = [])", "by (induction n xs rule: chop.induct) auto"], ["", "lemma chop_ge_length_eq: \"n > 0 \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> n \\<ge> length xs \\<Longrightarrow> chop n xs = [xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; xs \\<noteq> []; length xs \\<le> n\\<rbrakk>\n    \\<Longrightarrow> chop n xs = [xs]", "by simp"], ["", "lemma length_chop_part_le: \"ys \\<in> set (chop n xs) \\<Longrightarrow> length ys \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> set (chop n xs) \\<Longrightarrow> length ys \\<le> n", "by (induction n xs rule: chop.induct) auto"], ["", "lemma length_nth_chop:\n  assumes \"i < length (chop n xs)\"\n  shows   \"length (chop n xs ! i) = \n             (if i = length (chop n xs) - 1 \\<and> \\<not>n dvd length xs then length xs mod n else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "using assms"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  i < length (chop n xs)\n\ngoal (1 subgoal):\n 1. length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "proof (induction n xs arbitrary: i rule: chop.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>n \\<noteq> 0; i < length (chop n [])\\<rbrakk>\n       \\<Longrightarrow> length (chop n [] ! i) =\n                         (if i = length (chop n []) - 1 \\<and>\n                             \\<not> n dvd length []\n                          then length [] mod n else n)\n 2. \\<And>xs i.\n       \\<lbrakk>0 \\<noteq> 0; i < length (chop 0 xs)\\<rbrakk>\n       \\<Longrightarrow> length (chop 0 xs ! i) =\n                         (if i = length (chop 0 xs) - 1 \\<and>\n                             \\<not> 0 dvd length xs\n                          then length xs mod 0 else 0)\n 3. \\<And>n xs i.\n       \\<lbrakk>0 < n; xs \\<noteq> [];\n        \\<And>i.\n           \\<lbrakk>n \\<noteq> 0; i < length (chop n (drop n xs))\\<rbrakk>\n           \\<Longrightarrow> length (chop n (drop n xs) ! i) =\n                             (if i = length (chop n (drop n xs)) - 1 \\<and>\n                                 \\<not> n dvd length (drop n xs)\n                              then length (drop n xs) mod n else n);\n        n \\<noteq> 0; i < length (chop n xs)\\<rbrakk>\n       \\<Longrightarrow> length (chop n xs ! i) =\n                         (if i = length (chop n xs) - 1 \\<and>\n                             \\<not> n dvd length xs\n                          then length xs mod n else n)", "case (3 n xs i)"], ["proof (state)\nthis:\n  0 < n\n  xs \\<noteq> []\n  \\<lbrakk>n \\<noteq> 0; ?i < length (chop n (drop n xs))\\<rbrakk>\n  \\<Longrightarrow> length (chop n (drop n xs) ! ?i) =\n                    (if ?i = length (chop n (drop n xs)) - 1 \\<and>\n                        \\<not> n dvd length (drop n xs)\n                     then length (drop n xs) mod n else n)\n  n \\<noteq> 0\n  i < length (chop n xs)\n\ngoal (3 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>n \\<noteq> 0; i < length (chop n [])\\<rbrakk>\n       \\<Longrightarrow> length (chop n [] ! i) =\n                         (if i = length (chop n []) - 1 \\<and>\n                             \\<not> n dvd length []\n                          then length [] mod n else n)\n 2. \\<And>xs i.\n       \\<lbrakk>0 \\<noteq> 0; i < length (chop 0 xs)\\<rbrakk>\n       \\<Longrightarrow> length (chop 0 xs ! i) =\n                         (if i = length (chop 0 xs) - 1 \\<and>\n                             \\<not> 0 dvd length xs\n                          then length xs mod 0 else 0)\n 3. \\<And>n xs i.\n       \\<lbrakk>0 < n; xs \\<noteq> [];\n        \\<And>i.\n           \\<lbrakk>n \\<noteq> 0; i < length (chop n (drop n xs))\\<rbrakk>\n           \\<Longrightarrow> length (chop n (drop n xs) ! i) =\n                             (if i = length (chop n (drop n xs)) - 1 \\<and>\n                                 \\<not> n dvd length (drop n xs)\n                              then length (drop n xs) mod n else n);\n        n \\<noteq> 0; i < length (chop n xs)\\<rbrakk>\n       \\<Longrightarrow> length (chop n xs ! i) =\n                         (if i = length (chop n xs) - 1 \\<and>\n                             \\<not> n dvd length xs\n                          then length xs mod n else n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "using \"3.prems\""], ["proof (prove)\nusing this:\n  i = 0\n  n \\<noteq> 0\n  i < length (chop n xs)\n\ngoal (1 subgoal):\n 1. length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "by (cases \"length xs < n\") (auto simp: le_Suc_eq dest: dvd_imp_le)"], ["proof (state)\nthis:\n  length (chop n xs ! i) =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n   then length xs mod n else n)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "case [simp]: (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "with \"3.prems\""], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  i < length (chop n xs)\n  i = Suc i'", "have [simp]: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  i < length (chop n xs)\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "with \"3.prems\""], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  i < length (chop n xs)\n  xs \\<noteq> []", "have *: \"length xs > n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  i < length (chop n xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. n < length xs", "by (cases \"length xs \\<le> n\") simp_all"], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "with \"3.prems\""], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  i < length (chop n xs)\n  n < length xs", "have \"chop n xs ! i = chop n (drop n xs) ! i'\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  i < length (chop n xs)\n  n < length xs\n\ngoal (1 subgoal):\n 1. chop n xs ! i = chop n (drop n xs) ! i'", "by simp"], ["proof (state)\nthis:\n  chop n xs ! i = chop n (drop n xs) ! i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "also"], ["proof (state)\nthis:\n  chop n xs ! i = chop n (drop n xs) ! i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "have \"length \\<dots> = (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd (length xs - n)\n                                then (length xs - n) mod n else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (chop n (drop n xs) ! i') =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs - n\n     then (length xs - n) mod n else n)", "by (subst \"3.IH\") (use Suc \"3.prems\" in auto)"], ["proof (state)\nthis:\n  length (chop n (drop n xs) ! i') =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs - n\n   then (length xs - n) mod n else n)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "also"], ["proof (state)\nthis:\n  length (chop n (drop n xs) ! i') =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs - n\n   then (length xs - n) mod n else n)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "have \"n dvd (length xs - n) \\<longleftrightarrow> n dvd length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n dvd length xs - n) = (n dvd length xs)", "using *"], ["proof (prove)\nusing this:\n  n < length xs\n\ngoal (1 subgoal):\n 1. (n dvd length xs - n) = (n dvd length xs)", "by (subst dvd_minus_self) auto"], ["proof (state)\nthis:\n  (n dvd length xs - n) = (n dvd length xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "also"], ["proof (state)\nthis:\n  (n dvd length xs - n) = (n dvd length xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "have \"(length xs - n) mod n = length xs mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs - n) mod n = length xs mod n", "using *"], ["proof (prove)\nusing this:\n  n < length xs\n\ngoal (1 subgoal):\n 1. (length xs - n) mod n = length xs mod n", "by (subst le_mod_geq [symmetric]) auto"], ["proof (state)\nthis:\n  (length xs - n) mod n = length xs mod n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       length (chop n xs ! i) =\n       (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n        then length xs mod n else n)", "finally"], ["proof (chain)\npicking this:\n  length (chop n xs ! i) =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n   then length xs mod n else n)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (chop n xs ! i) =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n   then length xs mod n else n)\n\ngoal (1 subgoal):\n 1. length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "."], ["proof (state)\nthis:\n  length (chop n xs ! i) =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n   then length xs mod n else n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (chop n xs ! i) =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n   then length xs mod n else n)\n\ngoal (2 subgoals):\n 1. \\<And>n i.\n       \\<lbrakk>n \\<noteq> 0; i < length (chop n [])\\<rbrakk>\n       \\<Longrightarrow> length (chop n [] ! i) =\n                         (if i = length (chop n []) - 1 \\<and>\n                             \\<not> n dvd length []\n                          then length [] mod n else n)\n 2. \\<And>xs i.\n       \\<lbrakk>0 \\<noteq> 0; i < length (chop 0 xs)\\<rbrakk>\n       \\<Longrightarrow> length (chop 0 xs ! i) =\n                         (if i = length (chop 0 xs) - 1 \\<and>\n                             \\<not> 0 dvd length xs\n                          then length xs mod 0 else 0)", "qed auto"], ["proof (state)\nthis:\n  length (chop n xs ! i) =\n  (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n   then length xs mod n else n)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    length (chop n xs ! i) =\n    (if i = length (chop n xs) - 1 \\<and> \\<not> n dvd length xs\n     then length xs mod n else n)", "qed (insert assms, auto)"], ["", "lemma length_chop:\n  assumes \"n > 0\"\n  shows   \"length (chop n xs) = nat \\<lceil>length xs / n\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "proof (induction n xs rule: chop.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       length (chop n []) = nat \\<lceil>real (length []) / real n\\<rceil>\n 2. \\<And>xs.\n       0 < 0 \\<Longrightarrow>\n       length (chop 0 xs) = nat \\<lceil>real (length xs) / real 0\\<rceil>\n 3. \\<And>n xs.\n       \\<lbrakk>0 < n; xs \\<noteq> [];\n        0 < n \\<Longrightarrow>\n        length (chop n (drop n xs)) =\n        nat \\<lceil>real (length (drop n xs)) / real n\\<rceil>;\n        0 < n\\<rbrakk>\n       \\<Longrightarrow> length (chop n xs) =\n                         nat \\<lceil>real (length xs) / real n\\<rceil>", "case (3 n xs)"], ["proof (state)\nthis:\n  0 < n\n  xs \\<noteq> []\n  0 < n \\<Longrightarrow>\n  length (chop n (drop n xs)) =\n  nat \\<lceil>real (length (drop n xs)) / real n\\<rceil>\n  0 < n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       length (chop n []) = nat \\<lceil>real (length []) / real n\\<rceil>\n 2. \\<And>xs.\n       0 < 0 \\<Longrightarrow>\n       length (chop 0 xs) = nat \\<lceil>real (length xs) / real 0\\<rceil>\n 3. \\<And>n xs.\n       \\<lbrakk>0 < n; xs \\<noteq> [];\n        0 < n \\<Longrightarrow>\n        length (chop n (drop n xs)) =\n        nat \\<lceil>real (length (drop n xs)) / real n\\<rceil>;\n        0 < n\\<rbrakk>\n       \\<Longrightarrow> length (chop n xs) =\n                         nat \\<lceil>real (length xs) / real n\\<rceil>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "proof (cases \"length xs \\<ge> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>\n 2. \\<not> n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> length xs\n\ngoal (2 subgoals):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>\n 2. \\<not> n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "hence \"\\<lceil>real (length xs) / real n\\<rceil> = 1\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<lceil>real (length xs) / real n\\<rceil> = 1", "using \"3.hyps\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> length xs\n  0 < n\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lceil>real (length xs) / real n\\<rceil> = 1", "by (intro ceiling_unique) auto"], ["proof (state)\nthis:\n  \\<lceil>real (length xs) / real n\\<rceil> = 1\n\ngoal (2 subgoals):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>\n 2. \\<not> n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "with False"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> length xs\n  \\<lceil>real (length xs) / real n\\<rceil> = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n \\<le> length xs\n  \\<lceil>real (length xs) / real n\\<rceil> = 1\n\ngoal (1 subgoal):\n 1. length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "using \"3.prems\" \"3.hyps\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> length xs\n  \\<lceil>real (length xs) / real n\\<rceil> = 1\n  0 < n\n  0 < n\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "by (auto simp: chop_ge_length_eq not_le)"], ["proof (state)\nthis:\n  length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "case True"], ["proof (state)\nthis:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "hence \"real (length xs) = real n + real (length (drop n xs))\""], ["proof (prove)\nusing this:\n  n \\<le> length xs\n\ngoal (1 subgoal):\n 1. real (length xs) = real n + real (length (drop n xs))", "by simp"], ["proof (state)\nthis:\n  real (length xs) = real n + real (length (drop n xs))\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "also"], ["proof (state)\nthis:\n  real (length xs) = real n + real (length (drop n xs))\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "have \"\\<dots> / real n = real (length (drop n xs)) / real n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n + real (length (drop n xs))) / real n =\n    real (length (drop n xs)) / real n + 1", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (real n + real (length (drop n xs))) / real n =\n    real (length (drop n xs)) / real n + 1", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  (real n + real (length (drop n xs))) / real n =\n  real (length (drop n xs)) / real n + 1\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "also"], ["proof (state)\nthis:\n  (real n + real (length (drop n xs))) / real n =\n  real (length (drop n xs)) / real n + 1\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "have \"ceiling \\<dots> = ceiling (real (length (drop n xs)) / real n) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>real (length (drop n xs)) / real n + 1\\<rceil> =\n    \\<lceil>real (length (drop n xs)) / real n\\<rceil> + 1", "by simp"], ["proof (state)\nthis:\n  \\<lceil>real (length (drop n xs)) / real n + 1\\<rceil> =\n  \\<lceil>real (length (drop n xs)) / real n\\<rceil> + 1\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "also"], ["proof (state)\nthis:\n  \\<lceil>real (length (drop n xs)) / real n + 1\\<rceil> =\n  \\<lceil>real (length (drop n xs)) / real n\\<rceil> + 1\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "have \"nat \\<dots> = nat (ceiling (real (length (drop n xs)) / real n)) + nat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (\\<lceil>real (length (drop n xs)) / real n\\<rceil> + 1) =\n    nat \\<lceil>real (length (drop n xs)) / real n\\<rceil> + nat 1", "by (intro nat_add_distrib[OF order.trans[OF _ ceiling_mono[of 0]]]) auto"], ["proof (state)\nthis:\n  nat (\\<lceil>real (length (drop n xs)) / real n\\<rceil> + 1) =\n  nat \\<lceil>real (length (drop n xs)) / real n\\<rceil> + nat 1\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "also"], ["proof (state)\nthis:\n  nat (\\<lceil>real (length (drop n xs)) / real n\\<rceil> + 1) =\n  nat \\<lceil>real (length (drop n xs)) / real n\\<rceil> + nat 1\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "have \"\\<dots> = length (chop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>real (length (drop n xs)) / real n\\<rceil> + nat 1 =\n    length (chop n xs)", "using \\<open>n > 0\\<close> \"3.hyps\""], ["proof (prove)\nusing this:\n  0 < n\n  0 < n\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. nat \\<lceil>real (length (drop n xs)) / real n\\<rceil> + nat 1 =\n    length (chop n xs)", "by (subst \"3.IH\" [symmetric]) auto"], ["proof (state)\nthis:\n  nat \\<lceil>real (length (drop n xs)) / real n\\<rceil> + nat 1 =\n  length (chop n xs)\n\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", "finally"], ["proof (chain)\npicking this:\n  nat \\<lceil>real (length xs) / real n\\<rceil> = length (chop n xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  nat \\<lceil>real (length xs) / real n\\<rceil> = length (chop n xs)\n\ngoal (1 subgoal):\n 1. length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>", ".."], ["proof (state)\nthis:\n  length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (chop n xs) = nat \\<lceil>real (length xs) / real n\\<rceil>\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       0 < n \\<Longrightarrow>\n       length (chop n []) = nat \\<lceil>real (length []) / real n\\<rceil>\n 2. \\<And>xs.\n       0 < 0 \\<Longrightarrow>\n       length (chop 0 xs) = nat \\<lceil>real (length xs) / real 0\\<rceil>", "qed auto"], ["", "lemma sum_msets_chop: \"n > 0 \\<Longrightarrow> (\\<Sum>ys\\<leftarrow>chop n xs. mset ys) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> sum_list (map mset (chop n xs)) = mset xs", "by (subst mset_concat [symmetric]) simp_all"], ["", "lemma UN_sets_chop: \"n > 0 \\<Longrightarrow> (\\<Union>ys\\<in>set (chop n xs). set ys) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> \\<Union> (set ` set (chop n xs)) = set xs", "by (simp only: set_concat [symmetric] concat_chop)"], ["", "lemma in_set_chopD [dest]:\n  assumes \"x \\<in> set ys\" \"ys \\<in> set (chop d xs)\"\n  shows   \"x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs", "proof (cases \"d > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow> x \\<in> set xs\n 2. \\<not> 0 < d \\<Longrightarrow> x \\<in> set xs", "case True"], ["proof (state)\nthis:\n  0 < d\n\ngoal (2 subgoals):\n 1. 0 < d \\<Longrightarrow> x \\<in> set xs\n 2. \\<not> 0 < d \\<Longrightarrow> x \\<in> set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "by (subst UN_sets_chop [symmetric]) (use assms in auto)"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<not> 0 < d \\<Longrightarrow> x \\<in> set xs", "qed (use assms in auto)"], ["", "subsection \\<open>$k$-th order statistics and medians\\<close>"], ["", "text \\<open>\n  This returns the $k$-th smallest element of a list. This is also known as the $k$-th order\n  statistic.\n\\<close>"], ["", "definition select :: \"nat \\<Rightarrow> 'a list \\<Rightarrow> ('a :: linorder)\" where\n  \"select k xs = sort xs ! k\""], ["", "text \\<open>\n  The median of a list, where, for lists of even lengths, the smaller one is favoured:\n\\<close>"], ["", "definition median where \"median xs = select ((length xs - 1) div 2) xs\""], ["", "lemma select_in_set [intro,simp]:\n  assumes \"k < length xs\"\n  shows   \"select k xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select k xs \\<in> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. select k xs \\<in> set xs", "from assms"], ["proof (chain)\npicking this:\n  k < length xs", "have \"sort xs ! k \\<in> set (sort xs)\""], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. sort xs ! k \\<in> set (sort xs)", "by (intro nth_mem) auto"], ["proof (state)\nthis:\n  sort xs ! k \\<in> set (sort xs)\n\ngoal (1 subgoal):\n 1. select k xs \\<in> set xs", "also"], ["proof (state)\nthis:\n  sort xs ! k \\<in> set (sort xs)\n\ngoal (1 subgoal):\n 1. select k xs \\<in> set xs", "have \"set (sort xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort xs) = set xs", "by simp"], ["proof (state)\nthis:\n  set (sort xs) = set xs\n\ngoal (1 subgoal):\n 1. select k xs \\<in> set xs", "finally"], ["proof (chain)\npicking this:\n  sort xs ! k \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sort xs ! k \\<in> set xs\n\ngoal (1 subgoal):\n 1. select k xs \\<in> set xs", "by (simp add: select_def)"], ["proof (state)\nthis:\n  select k xs \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma median_in_set [intro, simp]: \n  assumes \"xs \\<noteq> []\"\n  shows   \"median xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median xs \\<in> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. median xs \\<in> set xs", "from assms"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have \"length xs > 0\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. median xs \\<in> set xs", "hence \"(length xs - 1) div 2 < length xs\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. (length xs - 1) div 2 < length xs", "by linarith"], ["proof (state)\nthis:\n  (length xs - 1) div 2 < length xs\n\ngoal (1 subgoal):\n 1. median xs \\<in> set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  (length xs - 1) div 2 < length xs\n\ngoal (1 subgoal):\n 1. median xs \\<in> set xs", "by (simp add: median_def)"], ["proof (state)\nthis:\n  median xs \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We show that selection and medians does not depend on the order of the elements:\n\\<close>"], ["", "lemma sort_cong: \"mset xs = mset ys \\<Longrightarrow> sort xs = sort ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset ys \\<Longrightarrow> sort xs = sort ys", "by (rule properties_for_sort) simp_all"], ["", "lemma select_cong:\n  \"k = k' \\<Longrightarrow> mset xs = mset xs' \\<Longrightarrow> select k xs = select k' xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k = k'; mset xs = mset xs'\\<rbrakk>\n    \\<Longrightarrow> select k xs = select k' xs'", "by (auto simp: select_def dest: sort_cong)"], ["", "lemma median_cong: \"mset xs = mset xs' \\<Longrightarrow> median xs = median xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset xs' \\<Longrightarrow> median xs = median xs'", "unfolding median_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset xs' \\<Longrightarrow>\n    select ((length xs - 1) div 2) xs = select ((length xs' - 1) div 2) xs'", "by (intro select_cong) (auto dest: mset_eq_length)"], ["", "text \\<open>\n  Selection distributes over appending lists under certain conditions:\n\\<close>"], ["", "lemma sort_append:\n  assumes \"\\<And>x y. x \\<in> set xs \\<Longrightarrow> y \\<in> set ys \\<Longrightarrow> x \\<le> y\"\n  shows   \"sort (xs @ ys) = sort xs @ sort ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort (xs @ ys) = sort xs @ sort ys", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; ?y \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. sort (xs @ ys) = sort xs @ sort ys", "by (intro properties_for_sort) (auto simp: sorted_append)"], ["", "lemma select_append:\n  assumes \"\\<And>y z. y \\<in> set ys \\<Longrightarrow> z \\<in> set zs \\<Longrightarrow> y \\<le> z\"\n  shows   \"k < length ys \\<Longrightarrow> select k (ys @ zs) = select k ys\"\n          \"k \\<in> {length ys..<length ys + length zs} \\<Longrightarrow>\n             select k (ys @ zs) = select (k - length ys) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k < length ys \\<Longrightarrow> select k (ys @ zs) = select k ys) &&&\n    (k \\<in> {length ys..<length ys + length zs} \\<Longrightarrow>\n     select k (ys @ zs) = select (k - length ys) zs)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> set ys; ?z \\<in> set zs\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> ?z\n\ngoal (1 subgoal):\n 1. (k < length ys \\<Longrightarrow> select k (ys @ zs) = select k ys) &&&\n    (k \\<in> {length ys..<length ys + length zs} \\<Longrightarrow>\n     select k (ys @ zs) = select (k - length ys) zs)", "by (simp_all add: select_def sort_append nth_append)"], ["", "lemma select_append':\n  assumes \"\\<And>y z. y \\<in> set ys \\<Longrightarrow> z \\<in> set zs \\<Longrightarrow> y \\<le> z\" \"k < length ys + length zs\"\n  shows   \"select k (ys @ zs) = (if k < length ys then select k ys else select (k - length ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select k (ys @ zs) =\n    (if k < length ys then select k ys else select (k - length ys) zs)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> set ys; ?z \\<in> set zs\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> ?z\n  k < length ys + length zs\n\ngoal (1 subgoal):\n 1. select k (ys @ zs) =\n    (if k < length ys then select k ys else select (k - length ys) zs)", "by (auto intro!: select_append)"], ["", "text \\<open>\n  We can find simple upper bounds for the number of elements that are strictly less than (resp.\n  greater than) the median of a list.\n\\<close>"], ["", "lemma size_less_than_median:\n  \"size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "hence \"length xs > 0\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by simp"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "hence \"(length xs - 1) div 2 < length xs\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. (length xs - 1) div 2 < length xs", "by linarith"], ["proof (state)\nthis:\n  (length xs - 1) div 2 < length xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "hence \"size {#y \\<in># mset (sort xs). y < median xs#} \\<le> \n           size (mset (take ((length xs - 1) div 2) (sort xs)))\""], ["proof (prove)\nusing this:\n  (length xs - 1) div 2 < length xs\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (sort xs). y < median xs#}\n    \\<le> size (mset (take ((length xs - 1) div 2) (sort xs)))", "unfolding median_def select_def"], ["proof (prove)\nusing this:\n  (length xs - 1) div 2 < length xs\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (sort xs). y < sort xs ! ((length xs - 1) div 2)#}\n    \\<le> size (mset (take ((length xs - 1) div 2) (sort xs)))", "using False"], ["proof (prove)\nusing this:\n  (length xs - 1) div 2 < length xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (sort xs). y < sort xs ! ((length xs - 1) div 2)#}\n    \\<le> size (mset (take ((length xs - 1) div 2) (sort xs)))", "by (intro size_mset_mono sorted_filter_less_subset_take) auto"], ["proof (state)\nthis:\n  size {#y \\<in># mset (sort xs). y < median xs#}\n  \\<le> size (mset (take ((length xs - 1) div 2) (sort xs)))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  size {#y \\<in># mset (sort xs). y < median xs#}\n  \\<le> size (mset (take ((length xs - 1) div 2) (sort xs)))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "using False"], ["proof (prove)\nusing this:\n  size {#y \\<in># mset (sort xs). y < median xs#}\n  \\<le> size (mset (take ((length xs - 1) div 2) (sort xs)))\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "by simp"], ["proof (state)\nthis:\n  size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2", "qed auto"], ["", "lemma size_greater_than_median:\n  \"size {#y \\<in># mset xs. y > median xs#} \\<le> length xs div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "hence \"length xs > 0\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by simp"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "hence \"(length xs - 1) div 2 < length xs\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. (length xs - 1) div 2 < length xs", "by linarith"], ["proof (state)\nthis:\n  (length xs - 1) div 2 < length xs\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "hence \"size {#y \\<in># mset (sort xs). y > median xs#} \\<le> \n           size (mset (drop (Suc ((length xs - 1) div 2)) (sort xs)))\""], ["proof (prove)\nusing this:\n  (length xs - 1) div 2 < length xs\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) (median xs)) (mset (sort xs)))\n    \\<le> size (mset (drop (Suc ((length xs - 1) div 2)) (sort xs)))", "unfolding median_def select_def"], ["proof (prove)\nusing this:\n  (length xs - 1) div 2 < length xs\n\ngoal (1 subgoal):\n 1. size\n     (filter_mset ((<) (sort xs ! ((length xs - 1) div 2)))\n       (mset (sort xs)))\n    \\<le> size (mset (drop (Suc ((length xs - 1) div 2)) (sort xs)))", "using False"], ["proof (prove)\nusing this:\n  (length xs - 1) div 2 < length xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. size\n     (filter_mset ((<) (sort xs ! ((length xs - 1) div 2)))\n       (mset (sort xs)))\n    \\<le> size (mset (drop (Suc ((length xs - 1) div 2)) (sort xs)))", "by (intro size_mset_mono sorted_filter_greater_subset_drop) auto"], ["proof (state)\nthis:\n  size (filter_mset ((<) (median xs)) (mset (sort xs)))\n  \\<le> size (mset (drop (Suc ((length xs - 1) div 2)) (sort xs)))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "hence \"size (filter_mset (\\<lambda>y. y > median xs) (mset xs)) \\<le>\n           length xs - Suc ((length xs - 1) div 2)\""], ["proof (prove)\nusing this:\n  size (filter_mset ((<) (median xs)) (mset (sort xs)))\n  \\<le> size (mset (drop (Suc ((length xs - 1) div 2)) (sort xs)))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) (median xs)) (mset xs))\n    \\<le> length xs - Suc ((length xs - 1) div 2)", "by simp"], ["proof (state)\nthis:\n  size (filter_mset ((<) (median xs)) (mset xs))\n  \\<le> length xs - Suc ((length xs - 1) div 2)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "also"], ["proof (state)\nthis:\n  size (filter_mset ((<) (median xs)) (mset xs))\n  \\<le> length xs - Suc ((length xs - 1) div 2)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "have \"\\<dots> = length xs div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs - Suc ((length xs - 1) div 2) = length xs div 2", "by linarith"], ["proof (state)\nthis:\n  length xs - Suc ((length xs - 1) div 2) = length xs div 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "finally"], ["proof (chain)\npicking this:\n  size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "show ?thesis"], ["proof (prove)\nusing this:\n  size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "."], ["proof (state)\nthis:\n  size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2", "qed auto"], ["", "subsection \\<open>A more liberal notion of medians\\<close>"], ["", "text \\<open>\n  We now define a more relaxed version of being ``a median'' as opposed to being ``\\emph{the}\n  median''. A value is a median if at most half the values in the list are strictly smaller \n  than it and at most half are strictly greater. Note that, by this definition, the median does\n  not even have to be in the list itself.\n\\<close>"], ["", "definition is_median :: \"'a :: linorder \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"is_median x xs \\<longleftrightarrow> length (filter (\\<lambda>y. y < x) xs) \\<le> length xs div 2 \\<and>\n                      length (filter (\\<lambda>y. y > x) xs) \\<le> length xs div 2\""], ["", "text \\<open>\n  We set up some transfer rules for @{const is_median}. In particular, we have a rule that\n  shows that something is a median for a list iff it is a median on that list w.\\,r.\\,t.\\ \n  the dual order, which will later allow us to argue by symmetry.\n\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma transfer_is_median [transfer_rule]:\n  assumes [transfer_rule]: \"(r ===> r ===> (=)) (<) (<)\"\n  shows   \"(r ===> list_all2 r ===> (=)) is_median is_median\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r ===> list_all2 r ===> (=)) is_median is_median", "unfolding is_median_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r ===> list_all2 r ===> (=))\n     (\\<lambda>x xs.\n         length (filter (\\<lambda>y. y < x) xs) \\<le> length xs div 2 \\<and>\n         length (filter ((<) x) xs) \\<le> length xs div 2)\n     (\\<lambda>x xs.\n         length (filter (\\<lambda>y. y < x) xs) \\<le> length xs div 2 \\<and>\n         length (filter ((<) x) xs) \\<le> length xs div 2)", "by transfer_prover"], ["", "lemma list_all2_eq_fun_conv_map: \"list_all2 (\\<lambda>x y. x = f y) xs ys \\<longleftrightarrow> xs = map f ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. x = f y) xs ys = (xs = map f ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all2 (\\<lambda>x y. x = f y) xs ys \\<Longrightarrow> xs = map f ys\n 2. xs = map f ys \\<Longrightarrow> list_all2 (\\<lambda>x y. x = f y) xs ys", "assume \"list_all2 (\\<lambda>x y. x = f y) xs ys\""], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x y. x = f y) xs ys\n\ngoal (2 subgoals):\n 1. list_all2 (\\<lambda>x y. x = f y) xs ys \\<Longrightarrow> xs = map f ys\n 2. xs = map f ys \\<Longrightarrow> list_all2 (\\<lambda>x y. x = f y) xs ys", "thus \"xs = map f ys\""], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x y. x = f y) xs ys\n\ngoal (1 subgoal):\n 1. xs = map f ys", "by induction auto"], ["proof (state)\nthis:\n  xs = map f ys\n\ngoal (1 subgoal):\n 1. xs = map f ys \\<Longrightarrow> list_all2 (\\<lambda>x y. x = f y) xs ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = map f ys \\<Longrightarrow> list_all2 (\\<lambda>x y. x = f y) xs ys", "assume \"xs = map f ys\""], ["proof (state)\nthis:\n  xs = map f ys\n\ngoal (1 subgoal):\n 1. xs = map f ys \\<Longrightarrow> list_all2 (\\<lambda>x y. x = f y) xs ys", "moreover"], ["proof (state)\nthis:\n  xs = map f ys\n\ngoal (1 subgoal):\n 1. xs = map f ys \\<Longrightarrow> list_all2 (\\<lambda>x y. x = f y) xs ys", "have \"list_all2 (\\<lambda>x y. x = f y) (map f ys) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. x = f y) (map f ys) ys", "by (induction ys) auto"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x y. x = f y) (map f ys) ys\n\ngoal (1 subgoal):\n 1. xs = map f ys \\<Longrightarrow> list_all2 (\\<lambda>x y. x = f y) xs ys", "ultimately"], ["proof (chain)\npicking this:\n  xs = map f ys\n  list_all2 (\\<lambda>x y. x = f y) (map f ys) ys", "show \"list_all2 (\\<lambda>x y. x = f y) xs ys\""], ["proof (prove)\nusing this:\n  xs = map f ys\n  list_all2 (\\<lambda>x y. x = f y) (map f ys) ys\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. x = f y) xs ys", "by simp"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x y. x = f y) xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfer_is_median_dual_ord [transfer_rule]:\n  \"(pcr_dual_ord (=) ===> list_all2 (pcr_dual_ord (=)) ===> (=)) is_median is_median\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_dual_ord (=) ===> list_all2 (pcr_dual_ord (=)) ===> (=)) is_median\n     is_median", "by (auto simp: pcr_dual_ord_def cr_dual_ord_def OO_def rel_fun_def is_median_def \n        list_all2_eq_fun_conv_map o_def less_dual_ord.rep_eq)"], ["", "end"], ["", "lemma is_median_to_dual_ord_iff [simp]:\n  \"is_median (to_dual_ord x) (map to_dual_ord xs) \\<longleftrightarrow> is_median x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (to_dual_ord x) (map to_dual_ord xs) = is_median x xs", "unfolding is_median_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs))\n     \\<le> length (map to_dual_ord xs) div 2 \\<and>\n     length (filter ((<) (to_dual_ord x)) (map to_dual_ord xs))\n     \\<le> length (map to_dual_ord xs) div 2) =\n    (length (filter (\\<lambda>y. y < x) xs) \\<le> length xs div 2 \\<and>\n     length (filter ((<) x) xs) \\<le> length xs div 2)", "by transfer auto"], ["", "text \\<open>\n  The following is an obviously equivalent definition of @{const is_median} in terms of\n  multisets that is occasionally nicer to use.\n\\<close>"], ["", "lemma is_median_altdef:\n  \"is_median x xs \\<longleftrightarrow> size (filter_mset (\\<lambda>y. y < x) (mset xs)) \\<le> length xs div 2 \\<and>\n                      size (filter_mset (\\<lambda>y. y > x) (mset xs)) \\<le> length xs div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median x xs =\n    (size {#y \\<in># mset xs. y < x#} \\<le> length xs div 2 \\<and>\n     size (filter_mset ((<) x) (mset xs)) \\<le> length xs div 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_median x xs =\n    (size {#y \\<in># mset xs. y < x#} \\<le> length xs div 2 \\<and>\n     size (filter_mset ((<) x) (mset xs)) \\<le> length xs div 2)", "have *: \"length (filter P xs) = size (filter_mset P (mset xs))\" for P and xs :: \"'a list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P xs) = size (filter_mset P (mset xs))", "by (simp flip: mset_filter)"], ["proof (state)\nthis:\n  length (filter ?P ?xs) = size (filter_mset ?P (mset ?xs))\n\ngoal (1 subgoal):\n 1. is_median x xs =\n    (size {#y \\<in># mset xs. y < x#} \\<le> length xs div 2 \\<and>\n     size (filter_mset ((<) x) (mset xs)) \\<le> length xs div 2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median x xs =\n    (size {#y \\<in># mset xs. y < x#} \\<le> length xs div 2 \\<and>\n     size (filter_mset ((<) x) (mset xs)) \\<le> length xs div 2)", "by (simp only: is_median_def *)"], ["proof (state)\nthis:\n  is_median x xs =\n  (size {#y \\<in># mset xs. y < x#} \\<le> length xs div 2 \\<and>\n   size (filter_mset ((<) x) (mset xs)) \\<le> length xs div 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_median_cong:\n  assumes \"x = y\" \"mset xs = mset ys\"\n  shows   \"is_median x xs \\<longleftrightarrow> is_median y ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median x xs = is_median y ys", "unfolding is_median_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (size {#y \\<in># mset xs. y < x#} \\<le> length xs div 2 \\<and>\n     size (filter_mset ((<) x) (mset xs)) \\<le> length xs div 2) =\n    (size {#ya \\<in># mset ys. ya < y#} \\<le> length ys div 2 \\<and>\n     size (filter_mset ((<) y) (mset ys)) \\<le> length ys div 2)", "by (simp only: assms mset_eq_length[OF assms(2)])"], ["", "text \\<open>\n  If an element is the median of a list of odd length, we can add any element to the list\n  and the element is still a median. Conversely, if we want to compute a median of a list with\n  even length $n$, we can simply drop one element and reduce the problem to a median of a list\n  of size $n - 1$.\n\\<close>"], ["", "lemma is_median_Cons_odd:\n  assumes \"is_median x xs\" and \"odd (length xs)\"\n  shows   \"is_median x (y # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median x (y # xs)", "using assms"], ["proof (prove)\nusing this:\n  is_median x xs\n  odd (length xs)\n\ngoal (1 subgoal):\n 1. is_median x (y # xs)", "by (auto simp: is_median_def)"], ["", "text \\<open>\n  And, of course, \\emph{the} median is a median.\n\\<close>"], ["", "lemma is_median_median [simp,intro]: \"is_median (median xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (median xs) xs", "using size_less_than_median[of xs] size_greater_than_median[of xs]"], ["proof (prove)\nusing this:\n  size {#y \\<in># mset xs. y < median xs#} \\<le> (length xs - 1) div 2\n  size (filter_mset ((<) (median xs)) (mset xs)) \\<le> length xs div 2\n\ngoal (1 subgoal):\n 1. is_median (median xs) xs", "unfolding is_median_def size_mset [symmetric] mset_filter"], ["proof (prove)\nusing this:\n  size {#y \\<in># mset xs. y < median xs#} \\<le> (size (mset xs) - 1) div 2\n  size (filter_mset ((<) (median xs)) (mset xs)) \\<le> size (mset xs) div 2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < median xs#}\n    \\<le> size (mset xs) div 2 \\<and>\n    size (filter_mset ((<) (median xs)) (mset xs))\n    \\<le> size (mset xs) div 2", "by linarith+"], ["", "subsection \\<open>Properties of a median-of-medians\\<close>"], ["", "text \\<open>\n  We can now bound the number of list elements that can be strictly smaller than a \n  median-of-medians of a chopped-up list (where each part has length $d$ except for the last one,\n  which can also be shorter).\n\n  The core argument is that at least roughly half of the medians of the sublists are greater or \n  equal to the median-of-medians, and about $\\frac{d}{2}$ elements in each such sublist are greater\n  than or equal to their median and thereby also than the median-of-medians.\n\\<close>"], ["", "lemma size_less_than_median_of_medians_strong:\n  fixes xs :: \"'a :: linorder list\" and d :: nat\n  assumes d: \"d > 0\"\n  assumes median: \"\\<And>xs. xs \\<noteq> [] \\<Longrightarrow> length xs \\<le> d \\<Longrightarrow> is_median (med xs) xs\"\n  assumes median': \"is_median x (map med (chop d xs))\"\n  defines \"m \\<equiv> length (chop d xs)\"\n  shows   \"size {#y \\<in># mset xs. y < x#} \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "define n where [simp]: \"n = length xs\"\n  \\<comment> \\<open>The medians of the sublists\\<close>"], ["proof (state)\nthis:\n  n = length xs\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "define M where \"M = mset (map med (chop d xs))\""], ["proof (state)\nthis:\n  M = mset (map med (chop d xs))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "define YS where \"YS = mset (chop d xs)\"\n  \\<comment> \\<open>The sublists with a smaller median than the median-of-medians @{term x} and the rest.\\<close>"], ["proof (state)\nthis:\n  YS = mset (chop d xs)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "define YS1 where \"YS1 = filter_mset (\\<lambda>ys. med ys < x) (mset (chop d xs))\""], ["proof (state)\nthis:\n  YS1 = {#ys \\<in># mset (chop d xs). med ys < x#}\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "define YS2 where \"YS2 = filter_mset (\\<lambda>ys. \\<not>(med ys < x)) (mset (chop d xs))\"\n\n  \\<comment> \\<open>At most roughly half of the lists have a median that is smaller than @{term M}\\<close>"], ["proof (state)\nthis:\n  YS2 = {#ys \\<in># mset (chop d xs). \\<not> med ys < x#}\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"size YS1 = size (image_mset med YS1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size YS1 = size (image_mset med YS1)", "by simp"], ["proof (state)\nthis:\n  size YS1 = size (image_mset med YS1)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  size YS1 = size (image_mset med YS1)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"image_mset med YS1 = {#y \\<in># mset (map med (chop d xs)). y < x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset med YS1 = {#y \\<in># mset (map med (chop d xs)). y < x#}", "unfolding YS1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset med {#ys \\<in># mset (chop d xs). med ys < x#} =\n    {#y \\<in># mset (map med (chop d xs)). y < x#}", "by (subst filter_mset_image_mset [symmetric]) simp_all"], ["proof (state)\nthis:\n  image_mset med YS1 = {#y \\<in># mset (map med (chop d xs)). y < x#}\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  image_mset med YS1 = {#y \\<in># mset (map med (chop d xs)). y < x#}\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"size \\<dots> \\<le> (length (map med (chop d xs))) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (map med (chop d xs)). y < x#}\n    \\<le> length (map med (chop d xs)) div 2", "using median'"], ["proof (prove)\nusing this:\n  is_median x (map med (chop d xs))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (map med (chop d xs)). y < x#}\n    \\<le> length (map med (chop d xs)) div 2", "unfolding is_median_altdef"], ["proof (prove)\nusing this:\n  size {#y \\<in># mset (map med (chop d xs)). y < x#}\n  \\<le> length (map med (chop d xs)) div 2 \\<and>\n  size (filter_mset ((<) x) (mset (map med (chop d xs))))\n  \\<le> length (map med (chop d xs)) div 2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (map med (chop d xs)). y < x#}\n    \\<le> length (map med (chop d xs)) div 2", "by simp"], ["proof (state)\nthis:\n  size {#y \\<in># mset (map med (chop d xs)). y < x#}\n  \\<le> length (map med (chop d xs)) div 2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  size {#y \\<in># mset (map med (chop d xs)). y < x#}\n  \\<le> length (map med (chop d xs)) div 2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> = m div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map med (chop d xs)) div 2 = m div 2", "by (simp add: m_def)"], ["proof (state)\nthis:\n  length (map med (chop d xs)) div 2 = m div 2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "finally"], ["proof (chain)\npicking this:\n  size YS1 \\<le> m div 2", "have size_YS1: \"size YS1 \\<le> m div 2\""], ["proof (prove)\nusing this:\n  size YS1 \\<le> m div 2\n\ngoal (1 subgoal):\n 1. size YS1 \\<le> m div 2", "."], ["proof (state)\nthis:\n  size YS1 \\<le> m div 2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"m = size (mset (chop d xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = size (mset (chop d xs))", "by (simp add: m_def)"], ["proof (state)\nthis:\n  m = size (mset (chop d xs))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  m = size (mset (chop d xs))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"mset (chop d xs) = YS1 + YS2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (chop d xs) = YS1 + YS2", "unfolding YS1_def YS2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (chop d xs) =\n    {#ys \\<in># mset (chop d xs). med ys < x#} +\n    {#ys \\<in># mset (chop d xs). \\<not> med ys < x#}", "by (rule multiset_partition)"], ["proof (state)\nthis:\n  mset (chop d xs) = YS1 + YS2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "finally"], ["proof (chain)\npicking this:\n  m = size (YS1 + YS2)", "have m_eq: \"m = size YS1 + size YS2\""], ["proof (prove)\nusing this:\n  m = size (YS1 + YS2)\n\ngoal (1 subgoal):\n 1. m = size YS1 + size YS2", "by simp\n\n  \\<comment> \\<open>We estimate the number of elements less than @{term x} by grouping them into elements\n      coming from @{term YS1} and elements coming from @{term YS2}. In the first case, we \n      just note that no more than @{term d} elements can come from each sublist, whereas in\n      the second case, we make the analysis more precise and note that only elements that are\n      less than the median of their sublist can be less than @{term x}.\\<close>"], ["proof (state)\nthis:\n  m = size YS1 + size YS2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"{# y \\<in># mset xs. y < x#} = {# y \\<in># (\\<Sum>ys\\<leftarrow>chop d xs. mset ys). y < x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#y \\<in># mset xs. y < x#} =\n    {#y \\<in># sum_list (map mset (chop d xs)). y < x#}", "using d"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. {#y \\<in># mset xs. y < x#} =\n    {#y \\<in># sum_list (map mset (chop d xs)). y < x#}", "by (subst sum_msets_chop) simp_all"], ["proof (state)\nthis:\n  {#y \\<in># mset xs. y < x#} =\n  {#y \\<in># sum_list (map mset (chop d xs)). y < x#}\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  {#y \\<in># mset xs. y < x#} =\n  {#y \\<in># sum_list (map mset (chop d xs)). y < x#}\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> = (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#y \\<in># sum_list (map mset (chop d xs)). y < x#} =\n    (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#})", "by (subst filter_mset_sum_list) (simp add: o_def)"], ["proof (state)\nthis:\n  {#y \\<in># sum_list (map mset (chop d xs)). y < x#} =\n  (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  {#y \\<in># sum_list (map mset (chop d xs)). y < x#} =\n  (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> = (\\<Sum>ys\\<in>#YS. {#y \\<in># mset ys. y < x#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#}) =\n    (\\<Sum>ys\\<in>#YS. {#y \\<in># mset ys. y < x#})", "unfolding YS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#}) =\n    (\\<Sum>ys\\<in>#mset (chop d xs). {#y \\<in># mset ys. y < x#})", "by (subst sum_mset_sum_list [symmetric]) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#}) =\n  (\\<Sum>ys\\<in>#YS. {#y \\<in># mset ys. y < x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<leftarrow>chop d xs. {#y \\<in># mset ys. y < x#}) =\n  (\\<Sum>ys\\<in>#YS. {#y \\<in># mset ys. y < x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"YS = YS1 + YS2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. YS = YS1 + YS2", "by (simp add: YS_def YS1_def YS2_def not_le)"], ["proof (state)\nthis:\n  YS = YS1 + YS2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  YS = YS1 + YS2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"(\\<Sum>ys\\<in>#\\<dots>. {#y \\<in># mset ys. y < x#}) = \n               (\\<Sum>ys\\<in>#YS1. {#y \\<in># mset ys. y < x#}) + (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < x#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<in>#YS1 + YS2. {#y \\<in># mset ys. y < x#}) =\n    (\\<Sum>ys\\<in>#YS1. {#y \\<in># mset ys. y < x#}) +\n    (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < x#})", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS1 + YS2. {#y \\<in># mset ys. y < x#}) =\n  (\\<Sum>ys\\<in>#YS1. {#y \\<in># mset ys. y < x#}) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS1 + YS2. {#y \\<in># mset ys. y < x#}) =\n  (\\<Sum>ys\\<in>#YS1. {#y \\<in># mset ys. y < x#}) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> \\<subseteq># (\\<Sum>ys\\<in>#YS1. mset ys) + (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<in>#YS1. {#y \\<in># mset ys. y < x#}) +\n    (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < x#}) \\<subseteq>#\n    \\<Sum>\\<^sub># (image_mset mset YS1) +\n    (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})", "by (intro subset_mset.add_mono sum_mset_mset_mono mset_filter_mono) (auto simp: YS2_def)"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS1. {#y \\<in># mset ys. y < x#}) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < x#}) \\<subseteq>#\n  \\<Sum>\\<^sub># (image_mset mset YS1) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "finally"], ["proof (chain)\npicking this:\n  {#y \\<in># mset xs. y < x#} \\<subseteq>#\n  \\<Sum>\\<^sub># (image_mset mset YS1) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})", "have \"{# y \\<in># mset xs. y < x #} \\<subseteq># \\<dots>\""], ["proof (prove)\nusing this:\n  {#y \\<in># mset xs. y < x#} \\<subseteq>#\n  \\<Sum>\\<^sub># (image_mset mset YS1) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})\n\ngoal (1 subgoal):\n 1. {#y \\<in># mset xs. y < x#} \\<subseteq>#\n    \\<Sum>\\<^sub># (image_mset mset YS1) +\n    (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})", "."], ["proof (state)\nthis:\n  {#y \\<in># mset xs. y < x#} \\<subseteq>#\n  \\<Sum>\\<^sub># (image_mset mset YS1) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "hence \"size {# y \\<in># mset xs. y < x #} \\<le> size \\<dots>\""], ["proof (prove)\nusing this:\n  {#y \\<in># mset xs. y < x#} \\<subseteq>#\n  \\<Sum>\\<^sub># (image_mset mset YS1) +\n  (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> size\n           (\\<Sum>\\<^sub># (image_mset mset YS1) +\n            (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#}))", "by (rule size_mset_mono)\n\n  \\<comment> \\<open>We do some further straightforward estimations and arrive at our goal.\\<close>"], ["proof (state)\nthis:\n  size {#y \\<in># mset xs. y < x#}\n  \\<le> size\n         (\\<Sum>\\<^sub># (image_mset mset YS1) +\n          (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#}))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  size {#y \\<in># mset xs. y < x#}\n  \\<le> size\n         (\\<Sum>\\<^sub># (image_mset mset YS1) +\n          (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#}))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> = (\\<Sum>ys\\<in>#YS1. length ys) + (\\<Sum>x\\<in>#YS2. size {#y \\<in># mset x. y < med x#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size\n     (\\<Sum>\\<^sub># (image_mset mset YS1) +\n      (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})) =\n    \\<Sum>\\<^sub># (image_mset length YS1) +\n    (\\<Sum>x\\<in>#YS2. size {#y \\<in># mset x. y < med x#})", "by (simp add: size_mset_sum_mset_distrib multiset.map_comp o_def)"], ["proof (state)\nthis:\n  size\n   (\\<Sum>\\<^sub># (image_mset mset YS1) +\n    (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})) =\n  \\<Sum>\\<^sub># (image_mset length YS1) +\n  (\\<Sum>x\\<in>#YS2. size {#y \\<in># mset x. y < med x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  size\n   (\\<Sum>\\<^sub># (image_mset mset YS1) +\n    (\\<Sum>ys\\<in>#YS2. {#y \\<in># mset ys. y < med ys#})) =\n  \\<Sum>\\<^sub># (image_mset length YS1) +\n  (\\<Sum>x\\<in>#YS2. size {#y \\<in># mset x. y < med x#})\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"(\\<Sum>ys\\<in>#YS1. length ys) \\<le> (\\<Sum>ys\\<in>#YS1. d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset length YS1) \\<le> (\\<Sum>ys\\<in>#YS1. d)", "by (intro sum_mset_mono) (auto simp: YS1_def length_chop_part_le)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset length YS1) \\<le> (\\<Sum>ys\\<in>#YS1. d)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset length YS1) \\<le> (\\<Sum>ys\\<in>#YS1. d)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> = size YS1 * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<in>#YS1. d) = size YS1 * d", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS1. d) = size YS1 * d\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS1. d) = size YS1 * d\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have d: \"d = (d div 2) + ((d + 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = d div 2 + (d + 1) div 2", "using d"], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d = d div 2 + (d + 1) div 2", "by linarith"], ["proof (state)\nthis:\n  d = d div 2 + (d + 1) div 2\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"size YS1 * d = size YS1 * (d div 2) + size YS1 * ((d + 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size YS1 * d = size YS1 * (d div 2) + size YS1 * ((d + 1) div 2)", "by (subst d) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  size YS1 * d = size YS1 * (d div 2) + size YS1 * ((d + 1) div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  size YS1 * d = size YS1 * (d div 2) + size YS1 * ((d + 1) div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"(\\<Sum>ys\\<in>#YS2. size {#y \\<in># mset ys. y < med ys#}) \\<le>\n               (\\<Sum>ys\\<in>#YS2. length ys div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<in>#YS2. size {#y \\<in># mset ys. y < med ys#})\n    \\<le> (\\<Sum>ys\\<in>#YS2. length ys div 2)", "proof (intro sum_mset_mono size_less_than_median, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       ys \\<in># YS2 \\<Longrightarrow>\n       size {#y \\<in># mset ys. y < med ys#} \\<le> length ys div 2", "case (1 ys)"], ["proof (state)\nthis:\n  ys \\<in># YS2\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       ys \\<in># YS2 \\<Longrightarrow>\n       size {#y \\<in># mset ys. y < med ys#} \\<le> length ys div 2", "hence \"ys \\<noteq> []\" \"length ys \\<le> d\""], ["proof (prove)\nusing this:\n  ys \\<in># YS2\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] &&& length ys \\<le> d", "by (auto simp: YS2_def length_chop_part_le)"], ["proof (state)\nthis:\n  ys \\<noteq> []\n  length ys \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       ys \\<in># YS2 \\<Longrightarrow>\n       size {#y \\<in># mset ys. y < med ys#} \\<le> length ys div 2", "from median[OF this]"], ["proof (chain)\npicking this:\n  is_median (med ys) ys", "show ?case"], ["proof (prove)\nusing this:\n  is_median (med ys) ys\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset ys. y < med ys#} \\<le> length ys div 2", "by (auto simp: is_median_altdef)"], ["proof (state)\nthis:\n  size {#y \\<in># mset ys. y < med ys#} \\<le> length ys div 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS2. size {#y \\<in># mset ys. y < med ys#})\n  \\<le> (\\<Sum>ys\\<in>#YS2. length ys div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS2. size {#y \\<in># mset ys. y < med ys#})\n  \\<le> (\\<Sum>ys\\<in>#YS2. length ys div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> \\<le> (\\<Sum>ys\\<in>#YS2. d div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<in>#YS2. length ys div 2) \\<le> (\\<Sum>ys\\<in>#YS2. d div 2)", "by (intro sum_mset_mono div_le_mono diff_le_mono) (auto simp: YS2_def dest: length_chop_part_le)"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS2. length ys div 2) \\<le> (\\<Sum>ys\\<in>#YS2. d div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS2. length ys div 2) \\<le> (\\<Sum>ys\\<in>#YS2. d div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"\\<dots> = size YS2 * (d div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ys\\<in>#YS2. d div 2) = size YS2 * (d div 2)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS2. d div 2) = size YS2 * (d div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>ys\\<in>#YS2. d div 2) = size YS2 * (d div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + \\<dots> =\n               m * (d div 2) + size YS1 * ((d + 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) +\n    size YS2 * (d div 2) =\n    m * (d div 2) + size YS1 * ((d + 1) div 2)", "by (simp add: m_eq algebra_simps)"], ["proof (state)\nthis:\n  size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + size YS2 * (d div 2) =\n  m * (d div 2) + size YS1 * ((d + 1) div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "also"], ["proof (state)\nthis:\n  size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + size YS2 * (d div 2) =\n  m * (d div 2) + size YS1 * ((d + 1) div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "have \"size YS1 * ((d + 1) div 2) \\<le> (m div 2) * ((d + 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size YS1 * ((d + 1) div 2) \\<le> m div 2 * ((d + 1) div 2)", "by (intro mult_right_mono size_YS1) auto"], ["proof (state)\nthis:\n  size YS1 * ((d + 1) div 2) \\<le> m div 2 * ((d + 1) div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>ys y.\n              ys \\<le> y \\<Longrightarrow>\n              ys +\n              (\\<Sum>ys\\<in>#YS2. size {#y \\<in># mset ys. y < med ys#})\n              \\<le> y +\n                    (\\<Sum>ys\\<in>#YS2. size\n   {#y \\<in># mset ys. y < med ys#});\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + x\n      \\<le> size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + x\n      \\<le> size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      m * (d div 2) + x \\<le> m * (d div 2) + y\\<rbrakk>\n  \\<Longrightarrow> size {#y \\<in># mset xs. y < x#}\n                    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "show \"size {#y \\<in># mset xs. y < x#} \\<le>\n                  m * (d div 2) + m div 2 * ((d + 1) div 2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ys y.\n              ys \\<le> y \\<Longrightarrow>\n              ys +\n              (\\<Sum>ys\\<in>#YS2. size {#y \\<in># mset ys. y < med ys#})\n              \\<le> y +\n                    (\\<Sum>ys\\<in>#YS2. size\n   {#y \\<in># mset ys. y < med ys#});\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + x\n      \\<le> size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + x\n      \\<le> size YS1 * (d div 2) + size YS1 * ((d + 1) div 2) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      m * (d div 2) + x \\<le> m * (d div 2) + y\\<rbrakk>\n  \\<Longrightarrow> size {#y \\<in># mset xs. y < x#}\n                    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)", "by simp_all"], ["proof (state)\nthis:\n  size {#y \\<in># mset xs. y < x#}\n  \\<le> m * (d div 2) + m div 2 * ((d + 1) div 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now focus on the case of an odd chopping size and make some further estimations to \n  simplify the above result a little bit.\n\\<close>"], ["", "theorem size_less_than_median_of_medians:\n  fixes xs :: \"'a :: linorder list\" and d :: nat\n  assumes median: \"\\<And>xs. xs \\<noteq> [] \\<Longrightarrow> length xs \\<le> Suc (2 * d) \\<Longrightarrow> is_median (med xs) xs\"\n  assumes median': \"is_median x (map med (chop (Suc (2*d)) xs))\"\n  defines \"n \\<equiv> length xs\"\n  defines \"c \\<equiv> (3 * real d + 1) / (2 * (2 * d + 1))\"\n  shows   \"size {#y \\<in># mset xs. y < x#} \\<le> nat \\<lceil>c * n\\<rceil> + (5 * d) div 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "define m where \"m = length (chop (Suc (2*d)) xs)\""], ["proof (state)\nthis:\n  m = length (chop (Suc (2 * d)) xs)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"real (m div 2) \\<le> real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (m div 2)\n    \\<le> real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) / 2", "by (simp add: m_def length_chop n_def)"], ["proof (state)\nthis:\n  real (m div 2)\n  \\<le> real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  real (m div 2)\n  \\<le> real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) =\n               of_int \\<lceil>real n / (1 + 2 * real d)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) =\n    real_of_int \\<lceil>real n / (1 + 2 * real d)\\<rceil>", "by (intro of_nat_nat) (auto simp: divide_simps)"], ["proof (state)\nthis:\n  real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) =\n  real_of_int \\<lceil>real n / (1 + 2 * real d)\\<rceil>\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  real (nat \\<lceil>real n / (1 + 2 * real d)\\<rceil>) =\n  real_of_int \\<lceil>real n / (1 + 2 * real d)\\<rceil>\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> / 2 \\<le> (real n / (1 + 2 * real d) + 1) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<lceil>real n / (1 + 2 * real d)\\<rceil> / 2\n    \\<le> (real n / (1 + 2 * real d) + 1) / 2", "by (intro divide_right_mono) linarith+"], ["proof (state)\nthis:\n  real_of_int \\<lceil>real n / (1 + 2 * real d)\\<rceil> / 2\n  \\<le> (real n / (1 + 2 * real d) + 1) / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  real_of_int \\<lceil>real n / (1 + 2 * real d)\\<rceil> / 2\n  \\<le> (real n / (1 + 2 * real d) + 1) / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> = n / (2 * (2 * real d + 1)) + 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n / (1 + 2 * real d) + 1) / 2 =\n    real n / (2 * (2 * real d + 1)) + 1 / 2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (real n / (1 + 2 * real d) + 1) / 2 =\n  real n / (2 * (2 * real d + 1)) + 1 / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "finally"], ["proof (chain)\npicking this:\n  real (m div 2) \\<le> real n / (2 * (2 * real d + 1)) + 1 / 2", "have m: \"real (m div 2) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  real (m div 2) \\<le> real n / (2 * (2 * real d + 1)) + 1 / 2\n\ngoal (1 subgoal):\n 1. real (m div 2) \\<le> real n / (2 * (2 * real d + 1)) + 1 / 2", "."], ["proof (state)\nthis:\n  real (m div 2) \\<le> real n / (2 * (2 * real d + 1)) + 1 / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"size {#y \\<in># mset xs. y < x#} \\<le> d * m + Suc d * (m div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#} \\<le> d * m + Suc d * (m div 2)", "using size_less_than_median_of_medians_strong[of \"Suc (2 * d)\" med x xs] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < Suc (2 * d);\n   \\<And>xs.\n      \\<lbrakk>xs \\<noteq> []; length xs \\<le> Suc (2 * d)\\<rbrakk>\n      \\<Longrightarrow> is_median (med xs) xs;\n   is_median x (map med (chop (Suc (2 * d)) xs))\\<rbrakk>\n  \\<Longrightarrow> size {#y \\<in># mset xs. y < x#}\n                    \\<le> length (chop (Suc (2 * d)) xs) *\n                          (Suc (2 * d) div 2) +\n                          length (chop (Suc (2 * d)) xs) div 2 *\n                          ((Suc (2 * d) + 1) div 2)\n  \\<lbrakk>?xs \\<noteq> []; length ?xs \\<le> Suc (2 * d)\\<rbrakk>\n  \\<Longrightarrow> is_median (med ?xs) ?xs\n  is_median x (map med (chop (Suc (2 * d)) xs))\n  n \\<equiv> length xs\n  c \\<equiv> (3 * real d + 1) / real (2 * (2 * d + 1))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#} \\<le> d * m + Suc d * (m div 2)", "unfolding m_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < Suc (2 * d);\n   \\<And>xs.\n      \\<lbrakk>xs \\<noteq> []; length xs \\<le> Suc (2 * d)\\<rbrakk>\n      \\<Longrightarrow> is_median (med xs) xs;\n   is_median x (map med (chop (Suc (2 * d)) xs))\\<rbrakk>\n  \\<Longrightarrow> size {#y \\<in># mset xs. y < x#}\n                    \\<le> length (chop (Suc (2 * d)) xs) *\n                          (Suc (2 * d) div 2) +\n                          length (chop (Suc (2 * d)) xs) div 2 *\n                          ((Suc (2 * d) + 1) div 2)\n  \\<lbrakk>?xs \\<noteq> []; length ?xs \\<le> Suc (2 * d)\\<rbrakk>\n  \\<Longrightarrow> is_median (med ?xs) ?xs\n  is_median x (map med (chop (Suc (2 * d)) xs))\n  n \\<equiv> length xs\n  c \\<equiv> (3 * real d + 1) / real (2 * (2 * d + 1))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> d * length (chop (Suc (2 * d)) xs) +\n          Suc d * (length (chop (Suc (2 * d)) xs) div 2)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  size {#y \\<in># mset xs. y < x#} \\<le> d * m + Suc d * (m div 2)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  size {#y \\<in># mset xs. y < x#} \\<le> d * m + Suc d * (m div 2)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> \\<le> d * (2 * (m div 2) + 1) + Suc d * (m div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * m + Suc d * (m div 2)\n    \\<le> d * (2 * (m div 2) + 1) + Suc d * (m div 2)", "by (intro add_mono mult_left_mono) linarith+"], ["proof (state)\nthis:\n  d * m + Suc d * (m div 2)\n  \\<le> d * (2 * (m div 2) + 1) + Suc d * (m div 2)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  d * m + Suc d * (m div 2)\n  \\<le> d * (2 * (m div 2) + 1) + Suc d * (m div 2)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> = (3 * d + 1) * (m div 2) + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * (2 * (m div 2) + 1) + Suc d * (m div 2) =\n    (3 * d + 1) * (m div 2) + d", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  d * (2 * (m div 2) + 1) + Suc d * (m div 2) = (3 * d + 1) * (m div 2) + d\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "finally"], ["proof (chain)\npicking this:\n  size {#y \\<in># mset xs. y < x#} \\<le> (3 * d + 1) * (m div 2) + d", "have \"real (size {#y \\<in># mset xs. y < x#}) \\<le> real \\<dots>\""], ["proof (prove)\nusing this:\n  size {#y \\<in># mset xs. y < x#} \\<le> (3 * d + 1) * (m div 2) + d\n\ngoal (1 subgoal):\n 1. real (size {#y \\<in># mset xs. y < x#})\n    \\<le> real ((3 * d + 1) * (m div 2) + d)", "by (subst of_nat_le_iff)"], ["proof (state)\nthis:\n  real (size {#y \\<in># mset xs. y < x#})\n  \\<le> real ((3 * d + 1) * (m div 2) + d)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  real (size {#y \\<in># mset xs. y < x#})\n  \\<le> real ((3 * d + 1) * (m div 2) + d)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> \\<le> (3 * real d + 1) * (n / (2 * (2 * d + 1)) + 1/2) + real d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real ((3 * d + 1) * (m div 2) + d)\n    \\<le> (3 * real d + 1) * (real n / real (2 * (2 * d + 1)) + 1 / 2) +\n          real d", "unfolding of_nat_add of_nat_mult of_nat_1 of_nat_numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. (3 * real d + 1) * real (m div 2) + real d\n    \\<le> (3 * real d + 1) * (real n / (2 * (2 * real d + 1)) + 1 / 2) +\n          real d", "by (intro add_mono mult_mono order.refl m) (auto simp: m_def length_chop n_def add_ac)"], ["proof (state)\nthis:\n  real ((3 * d + 1) * (m div 2) + d)\n  \\<le> (3 * real d + 1) * (real n / real (2 * (2 * d + 1)) + 1 / 2) +\n        real d\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  real ((3 * d + 1) * (m div 2) + d)\n  \\<le> (3 * real d + 1) * (real n / real (2 * (2 * d + 1)) + 1 / 2) +\n        real d\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> = c * real n + (5 * real d + 1) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (3 * real d + 1) * (real n / real (2 * (2 * d + 1)) + 1 / 2) + real d =\n    c * real n + (5 * real d + 1) / 2", "by (simp add: field_simps c_def)"], ["proof (state)\nthis:\n  (3 * real d + 1) * (real n / real (2 * (2 * d + 1)) + 1 / 2) + real d =\n  c * real n + (5 * real d + 1) / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  (3 * real d + 1) * (real n / real (2 * (2 * d + 1)) + 1 / 2) + real d =\n  c * real n + (5 * real d + 1) / 2\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> \\<le> real (nat \\<lceil>c * n\\<rceil> + ((5 * d) div 2 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * real n + (5 * real d + 1) / 2\n    \\<le> real (nat \\<lceil>c * real n\\<rceil> + (5 * d div 2 + 1))", "unfolding of_nat_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. c * real n + (5 * real d + 1) / 2\n    \\<le> real (nat \\<lceil>c * real n\\<rceil>) +\n          (real (5 * d div 2) + real 1)", "by (intro add_mono) (linarith, simp add: field_simps)"], ["proof (state)\nthis:\n  c * real n + (5 * real d + 1) / 2\n  \\<le> real (nat \\<lceil>c * real n\\<rceil> + (5 * d div 2 + 1))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "finally"], ["proof (chain)\npicking this:\n  real (size {#y \\<in># mset xs. y < x#})\n  \\<le> real (nat \\<lceil>c * real n\\<rceil> + (5 * d div 2 + 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  real (size {#y \\<in># mset xs. y < x#})\n  \\<le> real (nat \\<lceil>c * real n\\<rceil> + (5 * d div 2 + 1))\n\ngoal (1 subgoal):\n 1. size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "by (subst (asm) of_nat_le_iff) (simp_all add: add_ac)"], ["proof (state)\nthis:\n  size {#y \\<in># mset xs. y < x#}\n  \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    size {#y \\<in># mset xs. y < x#}\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "qed auto"], ["", "text \\<open>\n  We get the analogous result for the number of elements that are greater than a median-of-medians\n  by looking at the dual order and using the \\emph{transfer} method.\n\\<close>"], ["", "theorem size_greater_than_median_of_medians:\n  fixes xs :: \"'a :: linorder list\" and d :: nat\n  assumes median: \"\\<And>xs. xs \\<noteq> [] \\<Longrightarrow> length xs \\<le> Suc (2 * d) \\<Longrightarrow> is_median (med xs) xs\"\n  assumes median': \"is_median x (map med (chop (Suc (2*d)) xs))\" \n  defines \"n \\<equiv> length xs\"\n  defines \"c \\<equiv> (3 * real d + 1) / (2 * (2 * d + 1))\"\n  shows   \"size {#y \\<in># mset xs. y > x#} \\<le> nat \\<lceil>c * n\\<rceil> + (5 * d) div 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "include lifting_syntax"], ["proof (state)\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "define med' where \"med' = (\\<lambda>xs. to_dual_ord (med (map of_dual_ord xs)))\""], ["proof (state)\nthis:\n  med' = (\\<lambda>xs. to_dual_ord (med (map of_dual_ord xs)))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"xs = map of_dual_ord ys\" if \"list_all2 cr_dual_ord xs ys\" for xs :: \"'a list\" and ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map of_dual_ord ys", "using that"], ["proof (prove)\nusing this:\n  list_all2 cr_dual_ord xs ys\n\ngoal (1 subgoal):\n 1. xs = map of_dual_ord ys", "by induction (auto simp: cr_dual_ord_def)"], ["proof (state)\nthis:\n  list_all2 cr_dual_ord ?xs ?ys \\<Longrightarrow> ?xs = map of_dual_ord ?ys\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "hence [transfer_rule]: \"(list_all2 (pcr_dual_ord (=)) ===> pcr_dual_ord (=)) med med'\""], ["proof (prove)\nusing this:\n  list_all2 cr_dual_ord ?xs ?ys \\<Longrightarrow> ?xs = map of_dual_ord ?ys\n\ngoal (1 subgoal):\n 1. (list_all2 (pcr_dual_ord (=)) ===> pcr_dual_ord (=)) med med'", "by (auto simp: rel_fun_def pcr_dual_ord_def OO_def med'_def cr_dual_ord_def \n                   dual_ord.to_dual_ord_inverse)"], ["proof (state)\nthis:\n  (list_all2 (pcr_dual_ord (=)) ===> pcr_dual_ord (=)) med med'\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"size {#y \\<in># mset xs. y > x#} = length (filter (\\<lambda>y. y > x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs)) = length (filter ((<) x) xs)", "by (subst size_mset [symmetric]) (simp only: mset_filter)"], ["proof (state)\nthis:\n  size (filter_mset ((<) x) (mset xs)) = length (filter ((<) x) xs)\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  size (filter_mset ((<) x) (mset xs)) = length (filter ((<) x) xs)\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> = length (map to_dual_ord (filter (\\<lambda>y. y > x) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((<) x) xs) =\n    length (map to_dual_ord (filter ((<) x) xs))", "by simp"], ["proof (state)\nthis:\n  length (filter ((<) x) xs) = length (map to_dual_ord (filter ((<) x) xs))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  length (filter ((<) x) xs) = length (map to_dual_ord (filter ((<) x) xs))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"(\\<lambda>y. y > x) = (\\<lambda>y. to_dual_ord y < to_dual_ord x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<) x = (\\<lambda>y. to_dual_ord y < to_dual_ord x)", "by transfer simp_all"], ["proof (state)\nthis:\n  (<) x = (\\<lambda>y. to_dual_ord y < to_dual_ord x)\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "hence \"length (map to_dual_ord (filter (\\<lambda>y. y > x) xs)) = length (map to_dual_ord (filter \\<dots> xs))\""], ["proof (prove)\nusing this:\n  (<) x = (\\<lambda>y. to_dual_ord y < to_dual_ord x)\n\ngoal (1 subgoal):\n 1. length (map to_dual_ord (filter ((<) x) xs)) =\n    length\n     (map to_dual_ord\n       (filter (\\<lambda>y. to_dual_ord y < to_dual_ord x) xs))", "by simp"], ["proof (state)\nthis:\n  length (map to_dual_ord (filter ((<) x) xs)) =\n  length\n   (map to_dual_ord (filter (\\<lambda>y. to_dual_ord y < to_dual_ord x) xs))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  length (map to_dual_ord (filter ((<) x) xs)) =\n  length\n   (map to_dual_ord (filter (\\<lambda>y. to_dual_ord y < to_dual_ord x) xs))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> = length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map to_dual_ord\n       (filter (\\<lambda>y. to_dual_ord y < to_dual_ord x) xs)) =\n    length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs))", "unfolding filter_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map to_dual_ord\n       (filter (\\<lambda>y. to_dual_ord y < to_dual_ord x) xs)) =\n    length\n     (map to_dual_ord\n       (filter (\\<lambda>xa. to_dual_ord xa < to_dual_ord x) xs))", "by simp"], ["proof (state)\nthis:\n  length\n   (map to_dual_ord\n     (filter (\\<lambda>y. to_dual_ord y < to_dual_ord x) xs)) =\n  length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  length\n   (map to_dual_ord\n     (filter (\\<lambda>y. to_dual_ord y < to_dual_ord x) xs)) =\n  length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs))\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> = size {#y \\<in># mset (map to_dual_ord xs). y < to_dual_ord x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs)) =\n    size {#y \\<in># mset (map to_dual_ord xs). y < to_dual_ord x#}", "by (subst size_mset [symmetric]) (simp only: mset_filter)"], ["proof (state)\nthis:\n  length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs)) =\n  size {#y \\<in># mset (map to_dual_ord xs). y < to_dual_ord x#}\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "also"], ["proof (state)\nthis:\n  length (filter (\\<lambda>y. y < to_dual_ord x) (map to_dual_ord xs)) =\n  size {#y \\<in># mset (map to_dual_ord xs). y < to_dual_ord x#}\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "have \"\\<dots> \\<le> nat \\<lceil>(3 * real d + 1) / real (2 * (2 * d + 1)) * length (map to_dual_ord xs)\\<rceil>\n                    + 5 * d div 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size {#y \\<in># mset (map to_dual_ord xs). y < to_dual_ord x#}\n    \\<le> nat \\<lceil>(3 * real d + 1) / real (2 * (2 * d + 1)) *\n                      real (length (map to_dual_ord xs))\\<rceil> +\n          5 * d div 2 +\n          1", "proof (intro size_less_than_median_of_medians)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; length xs \\<le> Suc (2 * d)\\<rbrakk>\n       \\<Longrightarrow> is_median (?med xs) xs\n 2. is_median (to_dual_ord x)\n     (map ?med (chop (Suc (2 * d)) (map to_dual_ord xs)))", "fix xs :: \"'a dual_ord list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; length xs \\<le> Suc (2 * d)\\<rbrakk>\n       \\<Longrightarrow> is_median (?med xs) xs\n 2. is_median (to_dual_ord x)\n     (map ?med (chop (Suc (2 * d)) (map to_dual_ord xs)))", "assume xs: \"xs \\<noteq> []\" \"length xs \\<le> Suc (2 * d)\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n  length xs \\<le> Suc (2 * d)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>xs \\<noteq> []; length xs \\<le> Suc (2 * d)\\<rbrakk>\n       \\<Longrightarrow> is_median (?med xs) xs\n 2. is_median (to_dual_ord x)\n     (map ?med (chop (Suc (2 * d)) (map to_dual_ord xs)))", "from xs"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  length xs \\<le> Suc (2 * d)", "show \"is_median (med' xs) xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  length xs \\<le> Suc (2 * d)\n\ngoal (1 subgoal):\n 1. is_median (med' xs) xs", "by (transfer fixing: d) (rule median)"], ["proof (state)\nthis:\n  is_median (med' xs) xs\n\ngoal (1 subgoal):\n 1. is_median (to_dual_ord x)\n     (map med' (chop (Suc (2 * d)) (map to_dual_ord xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_median (to_dual_ord x)\n     (map med' (chop (Suc (2 * d)) (map to_dual_ord xs)))", "show \"is_median (to_dual_ord x) (map med' (chop (Suc (2 * d)) (map to_dual_ord xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (to_dual_ord x)\n     (map med' (chop (Suc (2 * d)) (map to_dual_ord xs)))", "by (transfer fixing: d x xs) (use median' in simp_all)"], ["proof (state)\nthis:\n  is_median (to_dual_ord x)\n   (map med' (chop (Suc (2 * d)) (map to_dual_ord xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  size {#y \\<in># mset (map to_dual_ord xs). y < to_dual_ord x#}\n  \\<le> nat \\<lceil>(3 * real d + 1) / real (2 * (2 * d + 1)) *\n                    real (length (map to_dual_ord xs))\\<rceil> +\n        5 * d div 2 +\n        1\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "finally"], ["proof (chain)\npicking this:\n  size (filter_mset ((<) x) (mset xs))\n  \\<le> nat \\<lceil>(3 * real d + 1) / real (2 * (2 * d + 1)) *\n                    real (length (map to_dual_ord xs))\\<rceil> +\n        5 * d div 2 +\n        1", "show ?thesis"], ["proof (prove)\nusing this:\n  size (filter_mset ((<) x) (mset xs))\n  \\<le> nat \\<lceil>(3 * real d + 1) / real (2 * (2 * d + 1)) *\n                    real (length (map to_dual_ord xs))\\<rceil> +\n        5 * d div 2 +\n        1\n\ngoal (1 subgoal):\n 1. size (filter_mset ((<) x) (mset xs))\n    \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1", "by (simp add: n_def c_def)"], ["proof (state)\nthis:\n  size (filter_mset ((<) x) (mset xs))\n  \\<le> nat \\<lceil>c * real n\\<rceil> + 5 * d div 2 + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The most important case is that of chopping size 5, since that is the most practical one\n  for the median-of-medians selection algorithm. For it, we obtain the following nice\n  and simple bounds:\n\\<close>"], ["", "corollary size_less_greater_median_of_medians_5:\n  fixes xs :: \"'a :: linorder list\"\n  assumes \"\\<And>xs. xs \\<noteq> [] \\<Longrightarrow> length xs \\<le> 5 \\<Longrightarrow> is_median (med xs) xs\"\n  assumes \"is_median x (map med (chop 5 xs))\" \n  shows \"length (filter (\\<lambda>y. y < x) xs) \\<le> nat \\<lceil>0.7 * length xs\\<rceil> + 6\"\n    and \"length (filter (\\<lambda>y. y > x) xs) \\<le> nat \\<lceil>0.7 * length xs\\<rceil> + 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>y. y < x) xs)\n    \\<le> nat \\<lceil>7 / 10 * real (length xs)\\<rceil> + 6 &&&\n    length (filter ((<) x) xs)\n    \\<le> nat \\<lceil>7 / 10 * real (length xs)\\<rceil> + 6", "using size_less_than_median_of_medians[of 2 med x xs]\n        size_greater_than_median_of_medians[of 2 med x xs] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xs.\n              \\<lbrakk>xs \\<noteq> []; length xs \\<le> Suc (2 * 2)\\<rbrakk>\n              \\<Longrightarrow> is_median (med xs) xs;\n   is_median x (map med (chop (Suc (2 * 2)) xs))\\<rbrakk>\n  \\<Longrightarrow> size {#y \\<in># mset xs. y < x#}\n                    \\<le> nat \\<lceil>(3 * real 2 + 1) /\nreal (2 * (2 * 2 + 1)) *\nreal (length xs)\\<rceil> +\n                          5 * 2 div 2 +\n                          1\n  \\<lbrakk>\\<And>xs.\n              \\<lbrakk>xs \\<noteq> []; length xs \\<le> Suc (2 * 2)\\<rbrakk>\n              \\<Longrightarrow> is_median (med xs) xs;\n   is_median x (map med (chop (Suc (2 * 2)) xs))\\<rbrakk>\n  \\<Longrightarrow> size (filter_mset ((<) x) (mset xs))\n                    \\<le> nat \\<lceil>(3 * real 2 + 1) /\nreal (2 * (2 * 2 + 1)) *\nreal (length xs)\\<rceil> +\n                          5 * 2 div 2 +\n                          1\n  \\<lbrakk>?xs \\<noteq> []; length ?xs \\<le> 5\\<rbrakk>\n  \\<Longrightarrow> is_median (med ?xs) ?xs\n  is_median x (map med (chop 5 xs))\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>y. y < x) xs)\n    \\<le> nat \\<lceil>7 / 10 * real (length xs)\\<rceil> + 6 &&&\n    length (filter ((<) x) xs)\n    \\<le> nat \\<lceil>7 / 10 * real (length xs)\\<rceil> + 6", "by (simp_all add: size_mset [symmetric] mset_filter mult_ac add_ac del: size_mset)"], ["", "subsection \\<open>The recursive step\\<close>"], ["", "text \\<open>\n  We now turn to the actual selection algorithm itself. The following simple reduction lemma \n  illustrates the idea of the algorithm quite well already, but it has the disadvantage that,\n  if one were to use it as a recursive algorithm, it would only work for lists with distinct\n  elements. If the list contains repeated elements, this may not even terminate.\n\n  The basic idea is that we choose some pivot element, partition the list into elements that \n  are bigger than the pivot and those that are not, and then recurse into one of these (hopefully\n  smaller) lists.\n\\<close>"], ["", "theorem select_rec_partition:\n  assumes \"d > 0\" \"k < length xs\"\n  shows \"select k xs = (\n           let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n           in  if k < length ys then select k ys else select (k - length ys) zs\n          )\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n     in if k < length ys then select k ys else select (k - length ys) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n     in if k < length ys then select k ys else select (k - length ys) zs)", "define ys zs where \"ys = filter (\\<lambda>y. y \\<le> x) xs\" and \"zs = filter (\\<lambda>y. \\<not>(y \\<le> x)) xs\""], ["proof (state)\nthis:\n  ys = filter (\\<lambda>y. y \\<le> x) xs\n  zs = filter (\\<lambda>y. \\<not> y \\<le> x) xs\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n     in if k < length ys then select k ys else select (k - length ys) zs)", "have \"select k xs = select k (ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select k xs = select k (ys @ zs)", "by (intro select_cong) (simp_all add: ys_def zs_def)"], ["proof (state)\nthis:\n  select k xs = select k (ys @ zs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n     in if k < length ys then select k ys else select (k - length ys) zs)", "also"], ["proof (state)\nthis:\n  select k xs = select k (ys @ zs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n     in if k < length ys then select k ys else select (k - length ys) zs)", "have \"\\<dots> = (if k < length ys then select k ys else select (k - length ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select k (ys @ zs) =\n    (if k < length ys then select k ys else select (k - length ys) zs)", "using assms(2)"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. select k (ys @ zs) =\n    (if k < length ys then select k ys else select (k - length ys) zs)", "by (intro select_append') (auto simp: ys_def zs_def sum_length_filter_compl)"], ["proof (state)\nthis:\n  select k (ys @ zs) =\n  (if k < length ys then select k ys else select (k - length ys) zs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n     in if k < length ys then select k ys else select (k - length ys) zs)", "finally"], ["proof (chain)\npicking this:\n  select k xs =\n  (if k < length ys then select k ys else select (k - length ys) zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  select k xs =\n  (if k < length ys then select k ys else select (k - length ys) zs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n     in if k < length ys then select k ys else select (k - length ys) zs)", "by (simp add: ys_def zs_def Let_def o_def)"], ["proof (state)\nthis:\n  select k xs =\n  (let (ys, zs) = partition (\\<lambda>y. y \\<le> x) xs\n   in if k < length ys then select k ys else select (k - length ys) zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following variant uses a three-way partitioning function instead. This way, the size of\n  the list in the final recursive call decreases by a factor of at least $\\frac{3d'+1}{2(2d'+1)}$ \n  by the previous estimates, given that the chopping size is $d = 2d'+1$. For a chopping size of 5,\n  we get a factor of $0.7$. \n\\<close>"], ["", "definition threeway_partition :: \"'a \\<Rightarrow> 'a :: linorder list \\<Rightarrow> 'a list \\<times> 'a list \\<times> 'a list\" where\n  \"threeway_partition x xs = (filter (\\<lambda>y. y < x) xs, filter (\\<lambda>y. y = x) xs, filter (\\<lambda>y. y > x) xs)\""], ["", "lemma threeway_partition_code [code]:\n  \"threeway_partition x [] = ([], [], [])\"\n  \"threeway_partition x (y # ys) =\n     (case threeway_partition x ys of (ls, es, gs) \\<Rightarrow>\n        if y < x then (y # ls, es, gs) else if x = y then (ls, y # es, gs) else (ls, es, y # gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. threeway_partition x [] = ([], [], []) &&&\n    threeway_partition x (y # ys) =\n    (case threeway_partition x ys of\n     (ls, es, gs) \\<Rightarrow>\n       if y < x then (y # ls, es, gs)\n       else if x = y then (ls, y # es, gs) else (ls, es, y # gs))", "by (auto simp: threeway_partition_def)"], ["", "theorem select_rec_threeway_partition:\n  assumes \"d > 0\" \"k < length xs\"\n  shows \"select k xs = (\n           let (ls, es, gs) = threeway_partition x xs;\n               nl = length ls; ne = length es\n           in\n             if k < nl then select k ls \n             else if k < nl + ne then x\n             else select (k - nl - ne) gs\n          )\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "define ls es gs where \"ls = filter (\\<lambda>y. y < x) xs\" and \"es = filter (\\<lambda>y. y = x) xs\"\n                    and \"gs = filter (\\<lambda>y. y > x) xs\""], ["proof (state)\nthis:\n  ls = filter (\\<lambda>y. y < x) xs\n  es = filter (\\<lambda>y. y = x) xs\n  gs = filter ((<) x) xs\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "define nl ne where [simp]: \"nl = length ls\" \"ne = length es\""], ["proof (state)\nthis:\n  nl = length ls\n  ne = length es\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "have mset_eq: \"mset xs = mset ls + mset es + mset gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs = mset ls + mset es + mset gs", "unfolding ls_def es_def gs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset xs =\n    mset (filter (\\<lambda>y. y < x) xs) +\n    mset (filter (\\<lambda>y. y = x) xs) +\n    mset (filter ((<) x) xs)", "by (induction xs) auto"], ["proof (state)\nthis:\n  mset xs = mset ls + mset es + mset gs\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "have length_eq: \"length xs = length ls + length es + length gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ls + length es + length gs", "unfolding ls_def es_def gs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs =\n    length (filter (\\<lambda>y. y < x) xs) +\n    length (filter (\\<lambda>y. y = x) xs) +\n    length (filter ((<) x) xs)", "by (induction xs) auto"], ["proof (state)\nthis:\n  length xs = length ls + length es + length gs\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "have [simp]: \"select i es = x\" if \"i < length es\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. select i es = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. select i es = x", "have \"select i es \\<in> set (sort es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select i es \\<in> set (sort es)", "unfolding select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sort es ! i \\<in> set (sort es)", "using that"], ["proof (prove)\nusing this:\n  i < length es\n\ngoal (1 subgoal):\n 1. sort es ! i \\<in> set (sort es)", "by (intro nth_mem) auto"], ["proof (state)\nthis:\n  select i es \\<in> set (sort es)\n\ngoal (1 subgoal):\n 1. select i es = x", "hence \"select i es \\<in> set es\""], ["proof (prove)\nusing this:\n  select i es \\<in> set (sort es)\n\ngoal (1 subgoal):\n 1. select i es \\<in> set es", "using that"], ["proof (prove)\nusing this:\n  select i es \\<in> set (sort es)\n  i < length es\n\ngoal (1 subgoal):\n 1. select i es \\<in> set es", "by (auto simp: select_def)"], ["proof (state)\nthis:\n  select i es \\<in> set es\n\ngoal (1 subgoal):\n 1. select i es = x", "also"], ["proof (state)\nthis:\n  select i es \\<in> set es\n\ngoal (1 subgoal):\n 1. select i es = x", "have \"set es \\<subseteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set es \\<subseteq> {x}", "unfolding es_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>y. y = x) xs) \\<subseteq> {x}", "by (induction es) auto"], ["proof (state)\nthis:\n  set es \\<subseteq> {x}\n\ngoal (1 subgoal):\n 1. select i es = x", "finally"], ["proof (chain)\npicking this:\n  select i es \\<in> {x}", "show ?thesis"], ["proof (prove)\nusing this:\n  select i es \\<in> {x}\n\ngoal (1 subgoal):\n 1. select i es = x", "by simp"], ["proof (state)\nthis:\n  select i es = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length es \\<Longrightarrow> select ?i es = x\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "have \"select k xs = select k (ls @ (es @ gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select k xs = select k (ls @ es @ gs)", "by (intro select_cong) (simp_all add: mset_eq)"], ["proof (state)\nthis:\n  select k xs = select k (ls @ es @ gs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "also"], ["proof (state)\nthis:\n  select k xs = select k (ls @ es @ gs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "have \"\\<dots> = (if k < nl then select k ls else select (k - nl) (es @ gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select k (ls @ es @ gs) =\n    (if k < nl then select k ls else select (k - nl) (es @ gs))", "unfolding nl_ne_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. select k (ls @ es @ gs) =\n    (if k < length ls then select k ls\n     else select (k - length ls) (es @ gs))", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) < d\n  k < length xs\n\ngoal (1 subgoal):\n 1. select k (ls @ es @ gs) =\n    (if k < length ls then select k ls\n     else select (k - length ls) (es @ gs))", "by (intro select_append') (auto simp: ls_def es_def gs_def length_eq)"], ["proof (state)\nthis:\n  select k (ls @ es @ gs) =\n  (if k < nl then select k ls else select (k - nl) (es @ gs))\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "also"], ["proof (state)\nthis:\n  select k (ls @ es @ gs) =\n  (if k < nl then select k ls else select (k - nl) (es @ gs))\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "have \"\\<dots> = (if k < nl then select k ls else if k < nl + ne then x\n                    else select (k - nl - ne) gs)\" (is \"?lhs' = ?rhs'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "proof (cases \"k < nl\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "case False"], ["proof (state)\nthis:\n  \\<not> k < nl\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "hence \"?lhs' = select (k - nl) (es @ gs)\""], ["proof (prove)\nusing this:\n  \\<not> k < nl\n\ngoal (1 subgoal):\n 1. (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    select (k - nl) (es @ gs)", "by simp"], ["proof (state)\nthis:\n  (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n  select (k - nl) (es @ gs)\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "also"], ["proof (state)\nthis:\n  (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n  select (k - nl) (es @ gs)\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "have \"\\<dots> = (if k - nl < ne then select (k - nl) es else select (k - nl - ne) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select (k - nl) (es @ gs) =\n    (if k - nl < ne then select (k - nl) es else select (k - nl - ne) gs)", "unfolding nl_ne_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. select (k - length ls) (es @ gs) =\n    (if k - length ls < length es then select (k - length ls) es\n     else select (k - length ls - length es) gs)", "using assms False"], ["proof (prove)\nusing this:\n  (0::'a) < d\n  k < length xs\n  \\<not> k < nl\n\ngoal (1 subgoal):\n 1. select (k - length ls) (es @ gs) =\n    (if k - length ls < length es then select (k - length ls) es\n     else select (k - length ls - length es) gs)", "by (intro select_append') (auto simp: ls_def es_def gs_def length_eq)"], ["proof (state)\nthis:\n  select (k - nl) (es @ gs) =\n  (if k - nl < ne then select (k - nl) es else select (k - nl - ne) gs)\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "also"], ["proof (state)\nthis:\n  select (k - nl) (es @ gs) =\n  (if k - nl < ne then select (k - nl) es else select (k - nl - ne) gs)\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "have \"\\<dots> = (if k - nl < ne then x else select (k - nl - ne) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k - nl < ne then select (k - nl) es else select (k - nl - ne) gs) =\n    (if k - nl < ne then x else select (k - nl - ne) gs)", "by simp"], ["proof (state)\nthis:\n  (if k - nl < ne then select (k - nl) es else select (k - nl - ne) gs) =\n  (if k - nl < ne then x else select (k - nl - ne) gs)\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "also"], ["proof (state)\nthis:\n  (if k - nl < ne then select (k - nl) es else select (k - nl - ne) gs) =\n  (if k - nl < ne then x else select (k - nl - ne) gs)\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "from False"], ["proof (chain)\npicking this:\n  \\<not> k < nl", "have \"\\<dots> = ?rhs'\""], ["proof (prove)\nusing this:\n  \\<not> k < nl\n\ngoal (1 subgoal):\n 1. (if k - nl < ne then x else select (k - nl - ne) gs) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "by auto"], ["proof (state)\nthis:\n  (if k - nl < ne then x else select (k - nl - ne) gs) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)\n 2. \\<not> k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "finally"], ["proof (chain)\npicking this:\n  (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "."], ["proof (state)\nthis:\n  (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. k < nl \\<Longrightarrow>\n    (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "qed simp_all"], ["proof (state)\nthis:\n  (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "also"], ["proof (state)\nthis:\n  (if k < nl then select k ls else select (k - nl) (es @ gs)) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs) =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "by (simp add: threeway_partition_def Let_def ls_def es_def gs_def)"], ["proof (state)\nthis:\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs) =\n  (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n       ne = length es\n   in if k < nl then select k ls\n      else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "finally"], ["proof (chain)\npicking this:\n  select k xs =\n  (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n       ne = length es\n   in if k < nl then select k ls\n      else if k < nl + ne then x else select (k - nl - ne) gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  select k xs =\n  (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n       ne = length es\n   in if k < nl then select k ls\n      else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. select k xs =\n    (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n         ne = length es\n     in if k < nl then select k ls\n        else if k < nl + ne then x else select (k - nl - ne) gs)", "."], ["proof (state)\nthis:\n  select k xs =\n  (let (ls, es, gs) = threeway_partition x xs; nl = length ls;\n       ne = length es\n   in if k < nl then select k ls\n      else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  By the above results, it can be seen quite easily that, in each recursive step, the algorithm\n  takes a list of length $n$, does $O(n)$ work for the chopping, computing the medians of the\n  sublists, and partitioning, and it calls itself recursively with lists of size at most\n  $\\lceil 0.2n\\rceil$ and $\\lceil 0.7n\\rceil + 6$, respectively. This means that the runtime\n  of the algorithm is bounded above by the Akra--Bazzi-style recurrence\n    \\[T(n) = T(\\lceil 0.2n\\rceil) + T(\\lceil 0.7n\\rceil + 6) + O(n)\\]\n  which, by the Akra--Bazzi theorem, can be shown to fulfil $T\\in \\Theta(n)$.\n\n  However, a proper analysis of this would require an actual execution model and some way of \n  measuring the runtime of the algorithm, which is not what we aim to do here. Additionally, the\n  entire algorithm can be performed in-place in an imperative way, but this because quite tedious.\n\n  Instead of this, we will now focus on developing the above recursion into an executable \n  functional algorithm.\n\\<close>"], ["", "subsection \\<open>Medians of lists of length at most 5\\<close>"], ["", "text \\<open>\n  We now show some basic results about how to efficiently find a median of a list of size\n  at most 5. For length 1 or 2, this is trivial, since we can just pick any element. For length \n  3 and 4, we need at most three comparisons. For length 5, we need at most six comparisons.\n\n  This allows us to save some comparisons compared with the naive method of performing insertion\n  sort and then returning the element in the middle.\n\\<close>"], ["", "definition median_3 :: \"'a :: linorder \\<Rightarrow> _\" where\n  \"median_3 a b c =\n     (if a \\<le> b then\n        if b \\<le> c then b else max a c\n      else\n        if c \\<le> b then b else min a c)\""], ["", "lemma median_3: \"median_3 a b c = median [a, b, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median_3 a b c = median [a, b, c]", "by (auto simp: median_3_def median_def select_def min_def max_def)"], ["", "definition median_5_aux :: \"'a :: linorder \\<Rightarrow> _\" where\n  \"median_5_aux x1 x2 x3 x4 x5 = (\n     if x2 \\<le> x3 then if x2 \\<le> x4 then min x3 x4 else min x2 x5\n     else if x4 \\<le> x3 then min x3 x5 else min x2 x4)\""], ["", "lemma median_5_aux:\n  assumes \"x1 \\<le> x2\" \"x4 \\<le> x5\" \"x1 \\<le> x4\" \n  shows   \"median_5_aux x1 x2 x3 x4 x5 = median [x1,x2,x3,x4,x5]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median_5_aux x1 x2 x3 x4 x5 = median [x1, x2, x3, x4, x5]", "using assms"], ["proof (prove)\nusing this:\n  x1 \\<le> x2\n  x4 \\<le> x5\n  x1 \\<le> x4\n\ngoal (1 subgoal):\n 1. median_5_aux x1 x2 x3 x4 x5 = median [x1, x2, x3, x4, x5]", "by (auto simp: median_5_aux_def median_def select_def min_def)"], ["", "definition median_5 :: \"'a :: linorder \\<Rightarrow> _\" where\n  \"median_5 a b c d e = (\n     let (x1, x2) = (if a \\<le> b then (a, b) else (b, a));\n         (x4, x5) = (if d \\<le> e then (d, e) else (e, d))\n     in\n         if x1 \\<le> x4 then median_5_aux x1 x2 c x4 x5 else median_5_aux x4 x5 c x1 x2)\""], ["", "lemma median_5: \"median_5 a b c d e = median [a, b, c, d, e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median_5 a b c d e = median [a, b, c, d, e]", "by (auto simp: median_5_def Let_def median_5_aux intro: median_cong)"], ["", "fun median_le_5 where\n  \"median_le_5 [a] = a\"\n| \"median_le_5 [a,b] = a\"\n| \"median_le_5 [a,b,c] = median_3 a b c\"\n| \"median_le_5 [a,b,c,d] = median_3 a b c\"\n| \"median_le_5 [a,b,c,d,e] = median_5 a b c d e\"\n| \"median_le_5 _ = undefined\""], ["", "lemma median_5_in_set: \"median_5 a b c d e \\<in> {a, b, c, d, e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median_5 a b c d e \\<in> {a, b, c, d, e}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. median_5 a b c d e \\<in> {a, b, c, d, e}", "have \"median_5 a b c d e \\<in> set [a, b, c, d, e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median_5 a b c d e \\<in> set [a, b, c, d, e]", "unfolding median_5"], ["proof (prove)\ngoal (1 subgoal):\n 1. median [a, b, c, d, e] \\<in> set [a, b, c, d, e]", "by (rule median_in_set) auto"], ["proof (state)\nthis:\n  median_5 a b c d e \\<in> set [a, b, c, d, e]\n\ngoal (1 subgoal):\n 1. median_5 a b c d e \\<in> {a, b, c, d, e}", "thus ?thesis"], ["proof (prove)\nusing this:\n  median_5 a b c d e \\<in> set [a, b, c, d, e]\n\ngoal (1 subgoal):\n 1. median_5 a b c d e \\<in> {a, b, c, d, e}", "by simp"], ["proof (state)\nthis:\n  median_5 a b c d e \\<in> {a, b, c, d, e}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma median_le_5_in_set:\n  assumes \"xs \\<noteq> []\" \"length xs \\<le> 5\"\n  shows   \"median_le_5 xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median_le_5 xs \\<in> set xs", "proof (cases xs rule: median_le_5.cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 5. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 6. xs = [] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 7. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       median_le_5 xs \\<in> set xs", "case (5 a b c d e)"], ["proof (state)\nthis:\n  xs = [a, b, c, d, e]\n\ngoal (7 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 5. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 6. xs = [] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 7. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       median_le_5 xs \\<in> set xs", "with median_5_in_set[of a b c d e]"], ["proof (chain)\npicking this:\n  median_5 a b c d e \\<in> {a, b, c, d, e}\n  xs = [a, b, c, d, e]", "show ?thesis"], ["proof (prove)\nusing this:\n  median_5 a b c d e \\<in> {a, b, c, d, e}\n  xs = [a, b, c, d, e]\n\ngoal (1 subgoal):\n 1. median_le_5 xs \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  median_le_5 xs \\<in> set xs\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 5. xs = [] \\<Longrightarrow> median_le_5 xs \\<in> set xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       median_le_5 xs \\<in> set xs", "qed (insert assms, auto simp: median_3_def min_def max_def)"], ["", "lemma median_le_5:\n  assumes \"xs \\<noteq> []\" \"length xs \\<le> 5\"\n  shows   \"is_median (median_le_5 xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (median_le_5 xs) xs", "proof (cases xs rule: median_le_5.cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 7. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "case (3 a b c)"], ["proof (state)\nthis:\n  xs = [a, b, c]\n\ngoal (7 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 7. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "have \"is_median (median xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (median xs) xs", "by simp"], ["proof (state)\nthis:\n  is_median (median xs) xs\n\ngoal (7 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 7. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "also"], ["proof (state)\nthis:\n  is_median (median xs) xs\n\ngoal (7 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 7. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "have \"median xs = median_3 a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median xs = median_3 a b c", "by (simp add: median_3 3)"], ["proof (state)\nthis:\n  median xs = median_3 a b c\n\ngoal (7 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c.\n       xs = [a, b, c] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 7. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "finally"], ["proof (chain)\npicking this:\n  is_median (median_3 a b c) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  is_median (median_3 a b c) xs\n\ngoal (1 subgoal):\n 1. is_median (median_le_5 xs) xs", "using 3"], ["proof (prove)\nusing this:\n  is_median (median_3 a b c) xs\n  xs = [a, b, c]\n\ngoal (1 subgoal):\n 1. is_median (median_le_5 xs) xs", "by simp"], ["proof (state)\nthis:\n  is_median (median_le_5 xs) xs\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "case (4 a b c d)"], ["proof (state)\nthis:\n  xs = [a, b, c, d]\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "have \"is_median (median [a,b,c]) [a,b,c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (median [a, b, c]) [a, b, c]", "by simp"], ["proof (state)\nthis:\n  is_median (median [a, b, c]) [a, b, c]\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "also"], ["proof (state)\nthis:\n  is_median (median [a, b, c]) [a, b, c]\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "have \"median [a,b,c] = median_3 a b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median [a, b, c] = median_3 a b c", "by (simp add: median_3 4)"], ["proof (state)\nthis:\n  median [a, b, c] = median_3 a b c\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "finally"], ["proof (chain)\npicking this:\n  is_median (median_3 a b c) [a, b, c]", "have \"is_median (median_3 a b c) (d # [a,b,c])\""], ["proof (prove)\nusing this:\n  is_median (median_3 a b c) [a, b, c]\n\ngoal (1 subgoal):\n 1. is_median (median_3 a b c) [d, a, b, c]", "by (rule is_median_Cons_odd) auto"], ["proof (state)\nthis:\n  is_median (median_3 a b c) [d, a, b, c]\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "also"], ["proof (state)\nthis:\n  is_median (median_3 a b c) [d, a, b, c]\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "have \"?this \\<longleftrightarrow> is_median (median_3 a b c) [a,b,c,d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (median_3 a b c) [d, a, b, c] =\n    is_median (median_3 a b c) [a, b, c, d]", "by (intro is_median_cong) auto"], ["proof (state)\nthis:\n  is_median (median_3 a b c) [d, a, b, c] =\n  is_median (median_3 a b c) [a, b, c, d]\n\ngoal (6 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d.\n       xs = [a, b, c, d] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 6. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "finally"], ["proof (chain)\npicking this:\n  is_median (median_3 a b c) [a, b, c, d]", "show ?thesis"], ["proof (prove)\nusing this:\n  is_median (median_3 a b c) [a, b, c, d]\n\ngoal (1 subgoal):\n 1. is_median (median_le_5 xs) xs", "using 4"], ["proof (prove)\nusing this:\n  is_median (median_3 a b c) [a, b, c, d]\n  xs = [a, b, c, d]\n\ngoal (1 subgoal):\n 1. is_median (median_le_5 xs) xs", "by simp"], ["proof (state)\nthis:\n  is_median (median_le_5 xs) xs\n\ngoal (5 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "case (5 a b c d e)"], ["proof (state)\nthis:\n  xs = [a, b, c, d, e]\n\ngoal (5 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "have \"is_median (median xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_median (median xs) xs", "by simp"], ["proof (state)\nthis:\n  is_median (median xs) xs\n\ngoal (5 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "also"], ["proof (state)\nthis:\n  is_median (median xs) xs\n\ngoal (5 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "have \"median xs = median_5 a b c d e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. median xs = median_5 a b c d e", "by (simp add: median_5 5)"], ["proof (state)\nthis:\n  median xs = median_5 a b c d e\n\ngoal (5 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. \\<And>a b c d e.\n       xs = [a, b, c, d, e] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 5. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "finally"], ["proof (chain)\npicking this:\n  is_median (median_5 a b c d e) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  is_median (median_5 a b c d e) xs\n\ngoal (1 subgoal):\n 1. is_median (median_le_5 xs) xs", "using 5"], ["proof (prove)\nusing this:\n  is_median (median_5 a b c d e) xs\n  xs = [a, b, c, d, e]\n\ngoal (1 subgoal):\n 1. is_median (median_le_5 xs) xs", "by simp"], ["proof (state)\nthis:\n  is_median (median_le_5 xs) xs\n\ngoal (4 subgoals):\n 1. \\<And>a. xs = [a] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 2. \\<And>a b. xs = [a, b] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 3. xs = [] \\<Longrightarrow> is_median (median_le_5 xs) xs\n 4. \\<And>v vb va vc vd ve vg.\n       xs = v # vb # va # vc # vd # ve # vg \\<Longrightarrow>\n       is_median (median_le_5 xs) xs", "qed (insert assms, auto simp: is_median_def)"], ["", "subsection \\<open>Median-of-medians selection algorithm\\<close>"], ["", "text \\<open>\n  The fast selection function now simply computes the median-of-medians of the chopped-up list\n  as a pivot, partitions the list into with respect to that pivot, and recurses into one of \n  the resulting sublists.\n\\<close>"], ["", "function fast_select where\n  \"fast_select k xs = (\n     if length xs \\<le> 20 then\n       sort xs ! k\n     else\n       let x = fast_select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs));\n           (ls, es, gs) = threeway_partition x xs\n       in\n         if k < length ls then fast_select k ls \n         else if k < length ls + length es then x\n         else fast_select (k - length ls - length es) gs\n      )\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>k xs. x = (k, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>k xs ka xsa.\n       (k, xs) = (ka, xsa) \\<Longrightarrow>\n       (if length xs \\<le> 20 then sort xs ! k\n        else let x = fast_select_sumC\n                      (((length xs + 4) div 5 - 1) div 2,\n                       map median_le_5 (chop 5 xs));\n                 (ls, es, gs) = threeway_partition x xs\n             in if k < length ls then fast_select_sumC (k, ls)\n                else if k < length ls + length es then x\n                     else fast_select_sumC\n                           (k - length ls - length es, gs)) =\n       (if length xsa \\<le> 20 then sort xsa ! ka\n        else let x = fast_select_sumC\n                      (((length xsa + 4) div 5 - 1) div 2,\n                       map median_le_5 (chop 5 xsa));\n                 (ls, es, gs) = threeway_partition x xsa\n             in if ka < length ls then fast_select_sumC (ka, ls)\n                else if ka < length ls + length es then x\n                     else fast_select_sumC (ka - length ls - length es, gs))", "by auto"], ["", "text \\<open>\n  The correctness of this is obvious from the above theorems, but the proof is still\n  somewhat complicated by the fact that termination depends on the correctness of the\n  function.\n\\<close>"], ["", "lemma fast_select_correct_aux:\n  assumes \"fast_select_dom (k, xs)\" \"k < length xs\"\n  shows   \"fast_select k xs = select k xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select k xs = select k xs", "using assms"], ["proof (prove)\nusing this:\n  fast_select_dom (k, xs)\n  k < length xs\n\ngoal (1 subgoal):\n 1. fast_select k xs = select k xs", "proof induction"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k xs.\n       \\<lbrakk>fast_select_dom (k, xs);\n        \\<lbrakk>\\<not> length xs \\<le> 20;\n         ((length xs + 4) div 5 - 1) div 2\n         < length (map median_le_5 (chop 5 xs))\\<rbrakk>\n        \\<Longrightarrow> fast_select (((length xs + 4) div 5 - 1) div 2)\n                           (map median_le_5 (chop 5 xs)) =\n                          select (((length xs + 4) div 5 - 1) div 2)\n                           (map median_le_5 (chop 5 xs));\n        \\<And>x xa xb y xaa ya.\n           \\<lbrakk>\\<not> length xs \\<le> 20;\n            x =\n            fast_select (((length xs + 4) div 5 - 1) div 2)\n             (map median_le_5 (chop 5 xs));\n            xa = threeway_partition x xs; (xb, y) = xa; (xaa, ya) = y;\n            k < length xb; k < length xb\\<rbrakk>\n           \\<Longrightarrow> fast_select k xb = select k xb;\n        \\<And>x xa xb y xaa ya.\n           \\<lbrakk>\\<not> length xs \\<le> 20;\n            x =\n            fast_select (((length xs + 4) div 5 - 1) div 2)\n             (map median_le_5 (chop 5 xs));\n            xa = threeway_partition x xs; (xb, y) = xa; (xaa, ya) = y;\n            \\<not> k < length xb; \\<not> k < length xb + length xaa;\n            k - length xb - length xaa < length ya\\<rbrakk>\n           \\<Longrightarrow> fast_select (k - length xb - length xaa) ya =\n                             select (k - length xb - length xaa) ya;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> fast_select k xs = select k xs", "case (1 k xs)"], ["proof (state)\nthis:\n  fast_select_dom (k, xs)\n  \\<lbrakk>\\<not> length xs \\<le> 20;\n   ((length xs + 4) div 5 - 1) div 2\n   < length (map median_le_5 (chop 5 xs))\\<rbrakk>\n  \\<Longrightarrow> fast_select (((length xs + 4) div 5 - 1) div 2)\n                     (map median_le_5 (chop 5 xs)) =\n                    select (((length xs + 4) div 5 - 1) div 2)\n                     (map median_le_5 (chop 5 xs))\n  \\<lbrakk>\\<not> length xs \\<le> 20;\n   ?x =\n   fast_select (((length xs + 4) div 5 - 1) div 2)\n    (map median_le_5 (chop 5 xs));\n   ?xa = threeway_partition ?x xs; (?xb, ?y) = ?xa; (?xaa, ?ya) = ?y;\n   k < length ?xb; k < length ?xb\\<rbrakk>\n  \\<Longrightarrow> fast_select k ?xb = select k ?xb\n  \\<lbrakk>\\<not> length xs \\<le> 20;\n   ?x =\n   fast_select (((length xs + 4) div 5 - 1) div 2)\n    (map median_le_5 (chop 5 xs));\n   ?xa = threeway_partition ?x xs; (?xb, ?y) = ?xa; (?xaa, ?ya) = ?y;\n   \\<not> k < length ?xb; \\<not> k < length ?xb + length ?xaa;\n   k - length ?xb - length ?xaa < length ?ya\\<rbrakk>\n  \\<Longrightarrow> fast_select (k - length ?xb - length ?xaa) ?ya =\n                    select (k - length ?xb - length ?xaa) ?ya\n  k < length xs\n\ngoal (1 subgoal):\n 1. \\<And>k xs.\n       \\<lbrakk>fast_select_dom (k, xs);\n        \\<lbrakk>\\<not> length xs \\<le> 20;\n         ((length xs + 4) div 5 - 1) div 2\n         < length (map median_le_5 (chop 5 xs))\\<rbrakk>\n        \\<Longrightarrow> fast_select (((length xs + 4) div 5 - 1) div 2)\n                           (map median_le_5 (chop 5 xs)) =\n                          select (((length xs + 4) div 5 - 1) div 2)\n                           (map median_le_5 (chop 5 xs));\n        \\<And>x xa xb y xaa ya.\n           \\<lbrakk>\\<not> length xs \\<le> 20;\n            x =\n            fast_select (((length xs + 4) div 5 - 1) div 2)\n             (map median_le_5 (chop 5 xs));\n            xa = threeway_partition x xs; (xb, y) = xa; (xaa, ya) = y;\n            k < length xb; k < length xb\\<rbrakk>\n           \\<Longrightarrow> fast_select k xb = select k xb;\n        \\<And>x xa xb y xaa ya.\n           \\<lbrakk>\\<not> length xs \\<le> 20;\n            x =\n            fast_select (((length xs + 4) div 5 - 1) div 2)\n             (map median_le_5 (chop 5 xs));\n            xa = threeway_partition x xs; (xb, y) = xa; (xaa, ya) = y;\n            \\<not> k < length xb; \\<not> k < length xb + length xaa;\n            k - length xb - length xaa < length ya\\<rbrakk>\n           \\<Longrightarrow> fast_select (k - length xb - length xaa) ya =\n                             select (k - length xb - length xaa) ya;\n        k < length xs\\<rbrakk>\n       \\<Longrightarrow> fast_select k xs = select k xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select k xs = select k xs", "proof (cases \"length xs \\<le> 20\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs \\<le> 20 \\<Longrightarrow> fast_select k xs = select k xs\n 2. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "case True"], ["proof (state)\nthis:\n  length xs \\<le> 20\n\ngoal (2 subgoals):\n 1. length xs \\<le> 20 \\<Longrightarrow> fast_select k xs = select k xs\n 2. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. fast_select k xs = select k xs", "using \"1.prems\" \"1.hyps\""], ["proof (prove)\nusing this:\n  length xs \\<le> 20\n  k < length xs\n  fast_select_dom (k, xs)\n\ngoal (1 subgoal):\n 1. fast_select k xs = select k xs", "by (subst fast_select.psimps) (auto simp: select_def)"], ["proof (state)\nthis:\n  fast_select k xs = select k xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "case False"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "define x where\n      \"x = fast_select (((length xs + 4) div 5 - Suc 0) div 2) (map median_le_5 (chop 5 xs))\""], ["proof (state)\nthis:\n  x =\n  fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n   (map median_le_5 (chop 5 xs))\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "define ls where \"ls = filter (\\<lambda>y. y < x) xs\""], ["proof (state)\nthis:\n  ls = filter (\\<lambda>y. y < x) xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "define es where \"es = filter (\\<lambda>y. y = x) xs\""], ["proof (state)\nthis:\n  es = filter (\\<lambda>y. y = x) xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "define gs where \"gs = filter (\\<lambda>y. y > x) xs\""], ["proof (state)\nthis:\n  gs = filter ((<) x) xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "define nl ne where \"nl = length ls\" and \"ne = length es\""], ["proof (state)\nthis:\n  nl = length ls\n  ne = length es\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "note defs = nl_def ne_def x_def ls_def es_def gs_def"], ["proof (state)\nthis:\n  nl = length ls\n  ne = length es\n  x =\n  fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n   (map median_le_5 (chop 5 xs))\n  ls = filter (\\<lambda>y. y < x) xs\n  es = filter (\\<lambda>y. y = x) xs\n  gs = filter ((<) x) xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "have tw: \"(ls, es, gs) = threeway_partition (fast_select (((length xs + 4) div 5 - 1) div 2)\n                               (map median_le_5 (chop 5 xs))) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ls, es, gs) =\n    threeway_partition\n     (fast_select (((length xs + 4) div 5 - 1) div 2)\n       (map median_le_5 (chop 5 xs)))\n     xs", "unfolding threeway_partition_def defs One_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (filter\n      (\\<lambda>y.\n          y < fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n               (map median_le_5 (chop 5 xs)))\n      xs,\n     filter\n      (\\<lambda>y.\n          y =\n          fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n           (map median_le_5 (chop 5 xs)))\n      xs,\n     filter\n      ((<) (fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n             (map median_le_5 (chop 5 xs))))\n      xs) =\n    (filter\n      (\\<lambda>y.\n          y < fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n               (map median_le_5 (chop 5 xs)))\n      xs,\n     filter\n      (\\<lambda>y.\n          y =\n          fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n           (map median_le_5 (chop 5 xs)))\n      xs,\n     filter\n      ((<) (fast_select (((length xs + 4) div 5 - Suc 0) div 2)\n             (map median_le_5 (chop 5 xs))))\n      xs)", ".."], ["proof (state)\nthis:\n  (ls, es, gs) =\n  threeway_partition\n   (fast_select (((length xs + 4) div 5 - 1) div 2)\n     (map median_le_5 (chop 5 xs)))\n   xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "have tw': \"(ls, es, gs) = threeway_partition x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ls, es, gs) = threeway_partition x xs", "by (simp add: tw x_def)"], ["proof (state)\nthis:\n  (ls, es, gs) = threeway_partition x xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "have \"fast_select k xs = (if k < nl then fast_select k ls else if k < nl + ne then x\n                                else fast_select (k - nl - ne) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select k xs =\n    (if k < nl then fast_select k ls\n     else if k < nl + ne then x else fast_select (k - nl - ne) gs)", "using \"1.hyps\" False"], ["proof (prove)\nusing this:\n  fast_select_dom (k, xs)\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. fast_select k xs =\n    (if k < nl then fast_select k ls\n     else if k < nl + ne then x else fast_select (k - nl - ne) gs)", "by (subst fast_select.psimps) (simp_all add: threeway_partition_def defs [symmetric])"], ["proof (state)\nthis:\n  fast_select k xs =\n  (if k < nl then fast_select k ls\n   else if k < nl + ne then x else fast_select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "also"], ["proof (state)\nthis:\n  fast_select k xs =\n  (if k < nl then fast_select k ls\n   else if k < nl + ne then x else fast_select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "have \"\\<dots> = (if k < nl then select k ls else if k < nl + ne then x \n                       else select (k - nl - ne) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k < nl then fast_select k ls\n     else if k < nl + ne then x else fast_select (k - nl - ne) gs) =\n    (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs)", "proof (intro if_cong refl)"], ["proof (state)\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow> fast_select k ls = select k ls\n 2. \\<lbrakk>\\<not> k < nl; \\<not> k < nl + ne\\<rbrakk>\n    \\<Longrightarrow> fast_select (k - nl - ne) gs = select (k - nl - ne) gs", "assume *: \"k < nl\""], ["proof (state)\nthis:\n  k < nl\n\ngoal (2 subgoals):\n 1. k < nl \\<Longrightarrow> fast_select k ls = select k ls\n 2. \\<lbrakk>\\<not> k < nl; \\<not> k < nl + ne\\<rbrakk>\n    \\<Longrightarrow> fast_select (k - nl - ne) gs = select (k - nl - ne) gs", "show \"fast_select k ls = select k ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select k ls = select k ls", "by (rule 1; (rule refl tw)?) \n           (insert *, auto simp: False threeway_partition_def ls_def x_def nl_def)+"], ["proof (state)\nthis:\n  fast_select k ls = select k ls\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> k < nl; \\<not> k < nl + ne\\<rbrakk>\n    \\<Longrightarrow> fast_select (k - nl - ne) gs = select (k - nl - ne) gs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> k < nl; \\<not> k < nl + ne\\<rbrakk>\n    \\<Longrightarrow> fast_select (k - nl - ne) gs = select (k - nl - ne) gs", "assume *: \"\\<not>k < nl\" \"\\<not>k < nl + ne\""], ["proof (state)\nthis:\n  \\<not> k < nl\n  \\<not> k < nl + ne\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> k < nl; \\<not> k < nl + ne\\<rbrakk>\n    \\<Longrightarrow> fast_select (k - nl - ne) gs = select (k - nl - ne) gs", "have **: \"length xs = length ls + length es + length gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ls + length es + length gs", "unfolding ls_def es_def gs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs =\n    length (filter (\\<lambda>y. y < x) xs) +\n    length (filter (\\<lambda>y. y = x) xs) +\n    length (filter ((<) x) xs)", "by (induction xs) auto"], ["proof (state)\nthis:\n  length xs = length ls + length es + length gs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> k < nl; \\<not> k < nl + ne\\<rbrakk>\n    \\<Longrightarrow> fast_select (k - nl - ne) gs = select (k - nl - ne) gs", "show \"fast_select (k - nl - ne) gs = select (k - nl - ne) gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select (k - nl - ne) gs = select (k - nl - ne) gs", "unfolding nl_def ne_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select (k - length ls - length es) gs =\n    select (k - length ls - length es) gs", "by (rule 1; (rule refl tw)?) (insert False * ** \\<open>k < length xs\\<close>, auto simp: nl_def ne_def)"], ["proof (state)\nthis:\n  fast_select (k - nl - ne) gs = select (k - nl - ne) gs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if k < nl then fast_select k ls\n   else if k < nl + ne then x else fast_select (k - nl - ne) gs) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "also"], ["proof (state)\nthis:\n  (if k < nl then fast_select k ls\n   else if k < nl + ne then x else fast_select (k - nl - ne) gs) =\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs)\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "have \"\\<dots> = select k xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs) =\n    select k xs", "using \\<open>k < length xs\\<close>"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. (if k < nl then select k ls\n     else if k < nl + ne then x else select (k - nl - ne) gs) =\n    select k xs", "by (subst (3) select_rec_threeway_partition[of \"5::nat\" _ _ x])\n         (unfold Let_def nl_def ne_def ls_def gs_def es_def x_def threeway_partition_def, simp_all)"], ["proof (state)\nthis:\n  (if k < nl then select k ls\n   else if k < nl + ne then x else select (k - nl - ne) gs) =\n  select k xs\n\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> 20 \\<Longrightarrow>\n    fast_select k xs = select k xs", "finally"], ["proof (chain)\npicking this:\n  fast_select k xs = select k xs", "show ?thesis"], ["proof (prove)\nusing this:\n  fast_select k xs = select k xs\n\ngoal (1 subgoal):\n 1. fast_select k xs = select k xs", "."], ["proof (state)\nthis:\n  fast_select k xs = select k xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fast_select k xs = select k xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Termination of the algorithm is reasonably obvious because the lists that are recursed into\n  never contain the pivot (the median-of-medians), while the original list clearly does.\n  The proof is still somewhat technical though.\n\\<close>"], ["", "lemma fast_select_termination: \"All fast_select_dom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All fast_select_dom", "proof (relation \"measure (length \\<circ> snd)\"; (safe)?, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k xs.\n       \\<not> length xs \\<le> 20 \\<Longrightarrow>\n       ((((length xs + 4) div 5 - 1) div 2, map median_le_5 (chop 5 xs)), k,\n        xs)\n       \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 3. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "case (1 k xs)"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> 20\n\ngoal (3 subgoals):\n 1. \\<And>k xs.\n       \\<not> length xs \\<le> 20 \\<Longrightarrow>\n       ((((length xs + 4) div 5 - 1) div 2, map median_le_5 (chop 5 xs)), k,\n        xs)\n       \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 3. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. ((((length xs + 4) div 5 - 1) div 2, map median_le_5 (chop 5 xs)), k,\n     xs)\n    \\<in> measure (length \\<circ> snd)", "by (auto simp: length_chop nat_less_iff ceiling_less_iff)"], ["proof (state)\nthis:\n  ((((length xs + 4) div 5 - 1) div 2, map median_le_5 (chop 5 xs)), k, xs)\n  \\<in> measure (length \\<circ> snd)\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "fix k :: nat and xs ls es gs :: \"'a list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "define x where \"x = fast_select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs))\""], ["proof (state)\nthis:\n  x =\n  fast_select (((length xs + 4) div 5 - 1) div 2)\n   (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "assume A: \"\\<not> length xs \\<le> 20\" \n            \"(ls, es, gs) = threeway_partition x xs\"\n            \"fast_select_dom (((length xs + 4) div 5 - 1) div 2, \n                             map median_le_5 (chop 5 xs))\""], ["proof (state)\nthis:\n  \\<not> length xs \\<le> 20\n  (ls, es, gs) = threeway_partition x xs\n  fast_select_dom\n   (((length xs + 4) div 5 - 1) div 2, map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "from A"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> 20\n  (ls, es, gs) = threeway_partition x xs\n  fast_select_dom\n   (((length xs + 4) div 5 - 1) div 2, map median_le_5 (chop 5 xs))", "have eq: \"ls = filter (\\<lambda>y. y < x) xs\" \"gs = filter (\\<lambda>y. y > x) xs\""], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 20\n  (ls, es, gs) = threeway_partition x xs\n  fast_select_dom\n   (((length xs + 4) div 5 - 1) div 2, map median_le_5 (chop 5 xs))\n\ngoal (1 subgoal):\n 1. ls = filter (\\<lambda>y. y < x) xs &&& gs = filter ((<) x) xs", "by (simp_all add: x_def threeway_partition_def)"], ["proof (state)\nthis:\n  ls = filter (\\<lambda>y. y < x) xs\n  gs = filter ((<) x) xs\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have len: \"(length xs + 4) div 5 = nat \\<lceil>length xs / 5\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xs + 4) div 5 = nat \\<lceil>real (length xs) / 5\\<rceil>", "by linarith"], ["proof (state)\nthis:\n  (length xs + 4) div 5 = nat \\<lceil>real (length xs) / 5\\<rceil>\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have less: \"(nat \\<lceil>real (length xs) / 5\\<rceil> - Suc 0) div 2 < nat \\<lceil>real (length xs) / 5\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat \\<lceil>real (length xs) / 5\\<rceil> - Suc 0) div 2\n    < nat \\<lceil>real (length xs) / 5\\<rceil>", "using A(1)"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. (nat \\<lceil>real (length xs) / 5\\<rceil> - Suc 0) div 2\n    < nat \\<lceil>real (length xs) / 5\\<rceil>", "by linarith"], ["proof (state)\nthis:\n  (nat \\<lceil>real (length xs) / 5\\<rceil> - Suc 0) div 2\n  < nat \\<lceil>real (length xs) / 5\\<rceil>\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have \"x = select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs))", "using less"], ["proof (prove)\nusing this:\n  (nat \\<lceil>real (length xs) / 5\\<rceil> - Suc 0) div 2\n  < nat \\<lceil>real (length xs) / 5\\<rceil>\n\ngoal (1 subgoal):\n 1. x =\n    select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs))", "unfolding x_def"], ["proof (prove)\nusing this:\n  (nat \\<lceil>real (length xs) / 5\\<rceil> - Suc 0) div 2\n  < nat \\<lceil>real (length xs) / 5\\<rceil>\n\ngoal (1 subgoal):\n 1. fast_select (((length xs + 4) div 5 - 1) div 2)\n     (map median_le_5 (chop 5 xs)) =\n    select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs))", "by (intro fast_select_correct_aux A) (auto simp: length_chop len)"], ["proof (state)\nthis:\n  x =\n  select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "also"], ["proof (state)\nthis:\n  x =\n  select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have \"\\<dots> = median (map median_le_5 (chop 5 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select (((length xs + 4) div 5 - 1) div 2)\n     (map median_le_5 (chop 5 xs)) =\n    median (map median_le_5 (chop 5 xs))", "by (simp add: median_def len length_chop)"], ["proof (state)\nthis:\n  select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs)) =\n  median (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "finally"], ["proof (chain)\npicking this:\n  x = median (map median_le_5 (chop 5 xs))", "have x: \"x = \\<dots>\""], ["proof (prove)\nusing this:\n  x = median (map median_le_5 (chop 5 xs))\n\ngoal (1 subgoal):\n 1. x = median (map median_le_5 (chop 5 xs))", "."], ["proof (state)\nthis:\n  x = median (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "moreover"], ["proof (state)\nthis:\n  x = median (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "{"], ["proof (state)\nthis:\n  x = median (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have \"x \\<in> set (map median_le_5 (chop 5 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (map median_le_5 (chop 5 xs))", "using A(1)"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. x \\<in> set (map median_le_5 (chop 5 xs))", "unfolding x"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. median (map median_le_5 (chop 5 xs))\n    \\<in> set (map median_le_5 (chop 5 xs))", "by (intro median_in_set) auto"], ["proof (state)\nthis:\n  x \\<in> set (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "also"], ["proof (state)\nthis:\n  x \\<in> set (map median_le_5 (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have \"\\<dots> \\<subseteq> (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map median_le_5 (chop 5 xs))\n    \\<subseteq> (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})", "by auto"], ["proof (state)\nthis:\n  set (map median_le_5 (chop 5 xs))\n  \\<subseteq> (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "also"], ["proof (state)\nthis:\n  set (map median_le_5 (chop 5 xs))\n  \\<subseteq> (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have \"\\<dots> \\<subseteq> (\\<Union>ys\\<in>set (chop 5 xs). set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})\n    \\<subseteq> \\<Union> (set ` set (chop 5 xs))", "using A(1)"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})\n    \\<subseteq> \\<Union> (set ` set (chop 5 xs))", "by (intro UN_mono) (auto simp: median_le_5_in_set length_chop_part_le)"], ["proof (state)\nthis:\n  (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})\n  \\<subseteq> \\<Union> (set ` set (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "also"], ["proof (state)\nthis:\n  (\\<Union>ys\\<in>set (chop 5 xs). {median_le_5 ys})\n  \\<subseteq> \\<Union> (set ` set (chop 5 xs))\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "have \"\\<dots> = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set ` set (chop 5 xs)) = set xs", "by (subst UN_sets_chop) auto"], ["proof (state)\nthis:\n  \\<Union> (set ` set (chop 5 xs)) = set xs\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "finally"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "have \"x \\<in> set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs", "."], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "}"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        k < length a;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k, a), k, xs) \\<in> measure (length \\<circ> snd)\n 2. \\<And>k xs x a aa b xb ab ba xaa ya.\n       \\<lbrakk>\\<not> length xs \\<le> 20;\n        (a, aa, b) =\n        threeway_partition\n         (fast_select (((length xs + 4) div 5 - 1) div 2)\n           (map median_le_5 (chop 5 xs)))\n         xs;\n        \\<not> k < length a; \\<not> k < length a + length aa;\n        fast_select_dom\n         (((length xs + 4) div 5 - 1) div 2,\n          map median_le_5 (chop 5 xs))\\<rbrakk>\n       \\<Longrightarrow> ((k - length a - length aa, b), k, xs)\n                         \\<in> measure (length \\<circ> snd)", "ultimately"], ["proof (chain)\npicking this:\n  x = median (map median_le_5 (chop 5 xs))\n  x \\<in> set xs", "show \"((k, ls), k, xs) \\<in> measure (length \\<circ> snd)\"\n              and \"((k - length ls - length es, gs), k, xs) \\<in> measure (length \\<circ> snd)\""], ["proof (prove)\nusing this:\n  x = median (map median_le_5 (chop 5 xs))\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. ((k, ls), k, xs) \\<in> measure (length \\<circ> snd) &&&\n    ((k - length ls - length es, gs), k, xs)\n    \\<in> measure (length \\<circ> snd)", "using A(1)"], ["proof (prove)\nusing this:\n  x = median (map median_le_5 (chop 5 xs))\n  x \\<in> set xs\n  \\<not> length xs \\<le> 20\n\ngoal (1 subgoal):\n 1. ((k, ls), k, xs) \\<in> measure (length \\<circ> snd) &&&\n    ((k - length ls - length es, gs), k, xs)\n    \\<in> measure (length \\<circ> snd)", "by (auto simp: eq intro!: length_filter_less[of x])"], ["proof (state)\nthis:\n  ((k, ls), k, xs) \\<in> measure (length \\<circ> snd)\n  ((k - length ls - length es, gs), k, xs)\n  \\<in> measure (length \\<circ> snd)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now have all the ingredients to show that @{const fast_select} terminates and does,\n  indeed, compute the $k$-th order statistic.\n\\<close>"], ["", "termination fast_select"], ["proof (prove)\ngoal (1 subgoal):\n 1. All fast_select_dom", "by (rule fast_select_termination)"], ["", "theorem fast_select_correct: \"k < length xs \\<Longrightarrow> fast_select k xs = select k xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length xs \\<Longrightarrow> fast_select k xs = select k xs", "using fast_select_termination"], ["proof (prove)\nusing this:\n  All fast_select_dom\n\ngoal (1 subgoal):\n 1. k < length xs \\<Longrightarrow> fast_select k xs = select k xs", "by (intro fast_select_correct_aux) auto"], ["", "text \\<open>\n  The following version is then suitable for code export.\n\\<close>"], ["", "lemma fast_select_code [code]:\n  \"fast_select k xs = (\n     if length xs \\<le> 20 then\n       fold insort xs [] ! k\n     else\n       let x = fast_select (((length xs + 4) div 5 - 1) div 2) (map median_le_5 (chop 5 xs));\n           (ls, es, gs) = threeway_partition x xs;\n           nl = length ls; ne = nl + length es\n       in\n         if k < nl then fast_select k ls \n         else if k < ne then x\n         else fast_select (k - ne) gs\n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_select k xs =\n    (if length xs \\<le> 20 then fold insort xs [] ! k\n     else let x = fast_select (((length xs + 4) div 5 - 1) div 2)\n                   (map median_le_5 (chop 5 xs));\n              (ls, es, gs) = threeway_partition x xs; nl = length ls;\n              ne = nl + length es\n          in if k < nl then fast_select k ls\n             else if k < ne then x else fast_select (k - ne) gs)", "by (subst fast_select.simps) (simp_all only: Let_def algebra_simps sort_conv_fold)"], ["", "lemma select_code [code]: \n  \"select k xs = (if k < length xs then fast_select k xs \n                    else Code.abort (STR ''Selection index out of bounds.'') (\\<lambda>_. select k xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select k xs =\n    (if k < length xs then fast_select k xs\n     else Code.abort STR ''Selection index out of bounds.''\n           (\\<lambda>_. select k xs))", "proof (cases \"k < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < length xs \\<Longrightarrow>\n    select k xs =\n    (if k < length xs then fast_select k xs\n     else Code.abort STR ''Selection index out of bounds.''\n           (\\<lambda>_. select k xs))\n 2. \\<not> k < length xs \\<Longrightarrow>\n    select k xs =\n    (if k < length xs then fast_select k xs\n     else Code.abort STR ''Selection index out of bounds.''\n           (\\<lambda>_. select k xs))", "case True"], ["proof (state)\nthis:\n  k < length xs\n\ngoal (2 subgoals):\n 1. k < length xs \\<Longrightarrow>\n    select k xs =\n    (if k < length xs then fast_select k xs\n     else Code.abort STR ''Selection index out of bounds.''\n           (\\<lambda>_. select k xs))\n 2. \\<not> k < length xs \\<Longrightarrow>\n    select k xs =\n    (if k < length xs then fast_select k xs\n     else Code.abort STR ''Selection index out of bounds.''\n           (\\<lambda>_. select k xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < length xs\n\ngoal (1 subgoal):\n 1. select k xs =\n    (if k < length xs then fast_select k xs\n     else Code.abort STR ''Selection index out of bounds.''\n           (\\<lambda>_. select k xs))", "by (simp only: if_True fast_select_correct)"], ["proof (state)\nthis:\n  select k xs =\n  (if k < length xs then fast_select k xs\n   else Code.abort STR ''Selection index out of bounds.''\n         (\\<lambda>_. select k xs))\n\ngoal (1 subgoal):\n 1. \\<not> k < length xs \\<Longrightarrow>\n    select k xs =\n    (if k < length xs then fast_select k xs\n     else Code.abort STR ''Selection index out of bounds.''\n           (\\<lambda>_. select k xs))", "qed (simp_all only: Code.abort_def if_False)"], ["", "end"]]}