{"file_name": "/home/qj213/afp-2021-10-22/thys/AODV/variants/d_fwdrreqs/D_Aodv.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AODV", "problem_names": ["lemma some_neq_not_eq [simp]: \"\\<not>((SOME x :: nat. x \\<noteq> i) = i)\"", "lemma clear_locals_sip_not_ip [simp]: \"\\<not>(sip (clear_locals \\<xi>) = ip \\<xi>)\"", "lemma clear_locals_but_not_globals [simp]:\n  \"ip (clear_locals \\<xi>) = ip \\<xi>\"\n  \"sn (clear_locals \\<xi>) = sn \\<xi>\"\n  \"rt (clear_locals \\<xi>) = rt \\<xi>\"\n  \"rreqs (clear_locals \\<xi>) = rreqs \\<xi>\"\n  \"store (clear_locals \\<xi>) = store \\<xi>\"", "lemma is_rreq_asm [dest!]:\n  assumes \"\\<xi>' \\<in> is_rreq \\<xi>\"\n    shows \"(\\<exists>hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled'.\n               msg \\<xi> = Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled' \\<and>\n               \\<xi>' = \\<xi>\\<lparr> hops := hops', rreqid := rreqid', dip := dip', dsn := dsn',\n                       dsk := dsk', oip := oip', osn := osn', sip := sip', \n                       handled := handled' \\<rparr>)\"", "lemma is_rrep_asm [dest!]:\n  assumes \"\\<xi>' \\<in> is_rrep \\<xi>\"\n    shows \"(\\<exists>hops' dip' dsn' oip' sip'.\n               msg \\<xi> = Rrep hops' dip' dsn' oip' sip' \\<and>\n               \\<xi>' = \\<xi>\\<lparr> hops := hops', dip := dip', dsn := dsn', oip := oip', sip := sip' \\<rparr>)\"", "lemma is_rerr_asm [dest!]:\n  assumes \"\\<xi>' \\<in> is_rerr \\<xi>\"\n    shows \"(\\<exists>dests' sip'.\n               msg \\<xi> = Rerr dests' sip' \\<and>\n               \\<xi>' = \\<xi>\\<lparr> dests := dests', sip := sip' \\<rparr>)\"", "lemmas is_msg_defs =\n  is_rerr_def is_rrep_def is_rreq_def is_pkt_def is_newpkt_def", "lemma is_msg_inv_ip [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"", "lemma is_msg_inv_sn [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"", "lemma is_msg_inv_rt [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"", "lemma is_msg_inv_rreqs [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"", "lemma is_msg_inv_store [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> store \\<xi>' = store \\<xi>\"", "lemma is_msg_inv_sip [simp]:\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> sip \\<xi>' = sip \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> sip \\<xi>' = sip \\<xi>\"", "lemmas \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_simps [simp, code] = \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V.simps [simplified]", "lemma \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton_wf [simp]:\n  \"wellformed \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton\"", "lemmas \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton_simps [simp, code]\n           = \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton.simps [simplified \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_simps seqp_skeleton.simps]", "lemma aodv_proc_cases [dest]:\n  fixes p pn\n  shows \"p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn) \\<Longrightarrow>\n                                (p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv) \\<or> \n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PNewPkt)  \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PPkt)  \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRreq) \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRrep) \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRerr))\"", "lemma aodv_trans: \"trans (paodv i) = seqp_sos \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\"", "lemma aodv_control_within [simp]: \"control_within \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V (init (paodv i))\"", "lemma aodv_wf [simp]:\n  \"wellformed \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\"", "lemmas aodv_labels_not_empty [simp] = labels_not_empty [OF aodv_wf]", "lemma aodv_ex_label [intro]: \"\\<exists>l. l\\<in>labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p\"", "lemma aodv_ex_labelE [elim]:\n  assumes \"\\<forall>l\\<in>labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p. P l p\"\n      and \"\\<exists>p l. P l p \\<Longrightarrow> Q\"\n    shows \"Q\"", "lemma aodv_simple_labels [simp]: \"simple_labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\"", "lemma \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_labels [simp]: \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i \\<Longrightarrow>  labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {PAodv-:0}\"", "lemma aodv_init_kD_empty [simp]:\n  \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i \\<Longrightarrow> kD (rt \\<xi>) = {}\"", "lemma aodv_init_sip_not_ip [simp]: \"\\<not>(sip (aodv_init i) = i)\"", "lemma aodv_init_sip_not_ip' [simp]:\n  assumes \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i\"\n    shows \"sip \\<xi> \\<noteq> ip \\<xi>\"", "lemma aodv_init_sip_not_i [simp]:\n  assumes \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i\"\n    shows \"sip \\<xi> \\<noteq> i\"", "lemma clear_locals_sip_not_ip':\n  assumes \"ip \\<xi> = i\"\n    shows \"\\<not>(sip (clear_locals \\<xi>) = i)\""], "translations": [["", "lemma some_neq_not_eq [simp]: \"\\<not>((SOME x :: nat. x \\<noteq> i) = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. x \\<noteq> i) \\<noteq> i", "by (subst some_eq_ex) (metis zero_neq_numeral)"], ["", "definition clear_locals :: \"state \\<Rightarrow> state\"\nwhere \"clear_locals \\<xi> = \\<xi> \\<lparr>\n    msg    := (SOME x. True),\n    data   := (SOME x. True),\n    dests  := (SOME x. True),\n    pre    := (SOME x. True),\n    rreqid := (SOME x. True),\n    dip    := (SOME x. True),\n    oip    := (SOME x. True),\n    hops   := (SOME x. True),\n    dsn    := (SOME x. True),\n    dsk    := (SOME x. True),\n    osn    := (SOME x. True),\n    sip    := (SOME x. x \\<noteq> ip \\<xi>),\n    handled:= (SOME x. True)\n  \\<rparr>\""], ["", "lemma clear_locals_sip_not_ip [simp]: \"\\<not>(sip (clear_locals \\<xi>) = ip \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sip (clear_locals \\<xi>) \\<noteq> ip \\<xi>", "unfolding clear_locals_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sip (\\<xi>\n         \\<lparr>msg := SOME x. True, data := SOME x. True,\n            dests := SOME x. True, pre := SOME x. True,\n            rreqid := SOME x. True, dip := SOME x. True,\n            oip := SOME x. True, hops := SOME x. True, dsn := SOME x. True,\n            dsk := SOME x. True, osn := SOME x. True,\n            sip := SOME x. x \\<noteq> ip \\<xi>,\n            handled := SOME x. True\\<rparr>) \\<noteq>\n    ip \\<xi>", "by simp"], ["", "lemma clear_locals_but_not_globals [simp]:\n  \"ip (clear_locals \\<xi>) = ip \\<xi>\"\n  \"sn (clear_locals \\<xi>) = sn \\<xi>\"\n  \"rt (clear_locals \\<xi>) = rt \\<xi>\"\n  \"rreqs (clear_locals \\<xi>) = rreqs \\<xi>\"\n  \"store (clear_locals \\<xi>) = store \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ip (clear_locals \\<xi>) = ip \\<xi> &&&\n     sn (clear_locals \\<xi>) = sn \\<xi>) &&&\n    rt (clear_locals \\<xi>) = rt \\<xi> &&&\n    rreqs (clear_locals \\<xi>) = rreqs \\<xi> &&&\n    store (clear_locals \\<xi>) = store \\<xi>", "unfolding clear_locals_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ip (\\<xi>\n         \\<lparr>msg := SOME x. True, data := SOME x. True,\n            dests := SOME x. True, pre := SOME x. True,\n            rreqid := SOME x. True, dip := SOME x. True,\n            oip := SOME x. True, hops := SOME x. True, dsn := SOME x. True,\n            dsk := SOME x. True, osn := SOME x. True,\n            sip := SOME x. x \\<noteq> ip \\<xi>,\n            handled := SOME x. True\\<rparr>) =\n     ip \\<xi> &&&\n     sn (\\<xi>\n         \\<lparr>msg := SOME x. True, data := SOME x. True,\n            dests := SOME x. True, pre := SOME x. True,\n            rreqid := SOME x. True, dip := SOME x. True,\n            oip := SOME x. True, hops := SOME x. True, dsn := SOME x. True,\n            dsk := SOME x. True, osn := SOME x. True,\n            sip := SOME x. x \\<noteq> ip \\<xi>,\n            handled := SOME x. True\\<rparr>) =\n     sn \\<xi>) &&&\n    rt (\\<xi>\n        \\<lparr>msg := SOME x. True, data := SOME x. True,\n           dests := SOME x. True, pre := SOME x. True,\n           rreqid := SOME x. True, dip := SOME x. True, oip := SOME x. True,\n           hops := SOME x. True, dsn := SOME x. True, dsk := SOME x. True,\n           osn := SOME x. True, sip := SOME x. x \\<noteq> ip \\<xi>,\n           handled := SOME x. True\\<rparr>) =\n    rt \\<xi> &&&\n    rreqs\n     (\\<xi>\n      \\<lparr>msg := SOME x. True, data := SOME x. True,\n         dests := SOME x. True, pre := SOME x. True, rreqid := SOME x. True,\n         dip := SOME x. True, oip := SOME x. True, hops := SOME x. True,\n         dsn := SOME x. True, dsk := SOME x. True, osn := SOME x. True,\n         sip := SOME x. x \\<noteq> ip \\<xi>,\n         handled := SOME x. True\\<rparr>) =\n    rreqs \\<xi> &&&\n    store\n     (\\<xi>\n      \\<lparr>msg := SOME x. True, data := SOME x. True,\n         dests := SOME x. True, pre := SOME x. True, rreqid := SOME x. True,\n         dip := SOME x. True, oip := SOME x. True, hops := SOME x. True,\n         dsn := SOME x. True, dsk := SOME x. True, osn := SOME x. True,\n         sip := SOME x. x \\<noteq> ip \\<xi>,\n         handled := SOME x. True\\<rparr>) =\n    store \\<xi>", "by auto"], ["", "subsection \"Auxilliary message handling definitions\""], ["", "definition is_newpkt\nwhere \"is_newpkt \\<xi> \\<equiv> case msg \\<xi> of\n                       Newpkt data' dip' \\<Rightarrow> { \\<xi>\\<lparr>data := data', dip := dip'\\<rparr> }\n                     | _ \\<Rightarrow> {}\""], ["", "definition is_pkt\nwhere \"is_pkt \\<xi> \\<equiv> case msg \\<xi> of\n                    Pkt data' dip' oip' \\<Rightarrow> { \\<xi>\\<lparr> data := data', dip := dip', oip := oip' \\<rparr> }\n                  | _ \\<Rightarrow> {}\""], ["", "definition is_rreq\nwhere \"is_rreq \\<xi> \\<equiv> case msg \\<xi> of\n                     Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled' \\<Rightarrow>\n                       { \\<xi>\\<lparr> hops := hops', rreqid := rreqid', dip := dip', dsn := dsn',\n                            dsk := dsk', oip := oip', osn := osn', sip := sip', \n                            handled := handled' \\<rparr> }\n                   | _ \\<Rightarrow> {}\""], ["", "lemma is_rreq_asm [dest!]:\n  assumes \"\\<xi>' \\<in> is_rreq \\<xi>\"\n    shows \"(\\<exists>hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled'.\n               msg \\<xi> = Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled' \\<and>\n               \\<xi>' = \\<xi>\\<lparr> hops := hops', rreqid := rreqid', dip := dip', dsn := dsn',\n                       dsk := dsk', oip := oip', osn := osn', sip := sip', \n                       handled := handled' \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled'.\n       msg \\<xi> =\n       Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled' \\<and>\n       \\<xi>' = \\<xi>\n       \\<lparr>hops := hops', rreqid := rreqid', dip := dip', dsn := dsn',\n          dsk := dsk', oip := oip', osn := osn', sip := sip',\n          handled := handled'\\<rparr>", "using assms"], ["proof (prove)\nusing this:\n  \\<xi>' \\<in> is_rreq \\<xi>\n\ngoal (1 subgoal):\n 1. \\<exists>hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled'.\n       msg \\<xi> =\n       Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled' \\<and>\n       \\<xi>' = \\<xi>\n       \\<lparr>hops := hops', rreqid := rreqid', dip := dip', dsn := dsn',\n          dsk := dsk', oip := oip', osn := osn', sip := sip',\n          handled := handled'\\<rparr>", "unfolding is_rreq_def"], ["proof (prove)\nusing this:\n  \\<xi>'\n  \\<in> (case msg \\<xi> of\n         Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip'\n          handled' \\<Rightarrow>\n           {\\<xi>\n            \\<lparr>hops := hops', rreqid := rreqid', dip := dip',\n               dsn := dsn', dsk := dsk', oip := oip', osn := osn',\n               sip := sip', handled := handled'\\<rparr>}\n         | _ \\<Rightarrow> {})\n\ngoal (1 subgoal):\n 1. \\<exists>hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled'.\n       msg \\<xi> =\n       Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip' handled' \\<and>\n       \\<xi>' = \\<xi>\n       \\<lparr>hops := hops', rreqid := rreqid', dip := dip', dsn := dsn',\n          dsk := dsk', oip := oip', osn := osn', sip := sip',\n          handled := handled'\\<rparr>", "by (cases \"msg \\<xi>\") simp_all"], ["", "definition is_rrep\nwhere \"is_rrep \\<xi> \\<equiv> case msg \\<xi> of\n                     Rrep hops' dip' dsn' oip' sip' \\<Rightarrow>\n                       { \\<xi>\\<lparr> hops := hops', dip := dip', dsn := dsn', oip := oip', sip := sip' \\<rparr> }\n                   | _ \\<Rightarrow> {}\""], ["", "lemma is_rrep_asm [dest!]:\n  assumes \"\\<xi>' \\<in> is_rrep \\<xi>\"\n    shows \"(\\<exists>hops' dip' dsn' oip' sip'.\n               msg \\<xi> = Rrep hops' dip' dsn' oip' sip' \\<and>\n               \\<xi>' = \\<xi>\\<lparr> hops := hops', dip := dip', dsn := dsn', oip := oip', sip := sip' \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>hops' dip' dsn' oip' sip'.\n       msg \\<xi> = Rrep hops' dip' dsn' oip' sip' \\<and>\n       \\<xi>' = \\<xi>\n       \\<lparr>hops := hops', dip := dip', dsn := dsn', oip := oip',\n          sip := sip'\\<rparr>", "using assms"], ["proof (prove)\nusing this:\n  \\<xi>' \\<in> is_rrep \\<xi>\n\ngoal (1 subgoal):\n 1. \\<exists>hops' dip' dsn' oip' sip'.\n       msg \\<xi> = Rrep hops' dip' dsn' oip' sip' \\<and>\n       \\<xi>' = \\<xi>\n       \\<lparr>hops := hops', dip := dip', dsn := dsn', oip := oip',\n          sip := sip'\\<rparr>", "unfolding is_rrep_def"], ["proof (prove)\nusing this:\n  \\<xi>'\n  \\<in> (case msg \\<xi> of\n         Rrep hops' dip' dsn' oip' sip' \\<Rightarrow>\n           {\\<xi>\n            \\<lparr>hops := hops', dip := dip', dsn := dsn', oip := oip',\n               sip := sip'\\<rparr>}\n         | _ \\<Rightarrow> {})\n\ngoal (1 subgoal):\n 1. \\<exists>hops' dip' dsn' oip' sip'.\n       msg \\<xi> = Rrep hops' dip' dsn' oip' sip' \\<and>\n       \\<xi>' = \\<xi>\n       \\<lparr>hops := hops', dip := dip', dsn := dsn', oip := oip',\n          sip := sip'\\<rparr>", "by (cases \"msg \\<xi>\") simp_all"], ["", "definition is_rerr\nwhere \"is_rerr \\<xi> \\<equiv> case msg \\<xi> of\n                     Rerr dests' sip' \\<Rightarrow> { \\<xi>\\<lparr> dests := dests', sip := sip' \\<rparr> }\n                   | _ \\<Rightarrow> {}\""], ["", "lemma is_rerr_asm [dest!]:\n  assumes \"\\<xi>' \\<in> is_rerr \\<xi>\"\n    shows \"(\\<exists>dests' sip'.\n               msg \\<xi> = Rerr dests' sip' \\<and>\n               \\<xi>' = \\<xi>\\<lparr> dests := dests', sip := sip' \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>dests' sip'.\n       msg \\<xi> = Rerr dests' sip' \\<and>\n       \\<xi>' = \\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>", "using assms"], ["proof (prove)\nusing this:\n  \\<xi>' \\<in> is_rerr \\<xi>\n\ngoal (1 subgoal):\n 1. \\<exists>dests' sip'.\n       msg \\<xi> = Rerr dests' sip' \\<and>\n       \\<xi>' = \\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>", "unfolding is_rerr_def"], ["proof (prove)\nusing this:\n  \\<xi>'\n  \\<in> (case msg \\<xi> of\n         Rerr dests' sip' \\<Rightarrow>\n           {\\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>}\n         | _ \\<Rightarrow> {})\n\ngoal (1 subgoal):\n 1. \\<exists>dests' sip'.\n       msg \\<xi> = Rerr dests' sip' \\<and>\n       \\<xi>' = \\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>", "by (cases \"msg \\<xi>\") simp_all"], ["", "lemmas is_msg_defs =\n  is_rerr_def is_rrep_def is_rreq_def is_pkt_def is_newpkt_def"], ["", "lemma is_msg_inv_ip [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> ip \\<xi>' = ip \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>' \\<in> is_rerr \\<xi> \\<Longrightarrow> ip \\<xi>' = ip \\<xi>) &&&\n     (\\<xi>' \\<in> is_rrep \\<xi> \\<Longrightarrow>\n      ip \\<xi>' = ip \\<xi>)) &&&\n    (\\<xi>' \\<in> is_rreq \\<xi> \\<Longrightarrow> ip \\<xi>' = ip \\<xi>) &&&\n    (\\<xi>' \\<in> is_pkt \\<xi> \\<Longrightarrow> ip \\<xi>' = ip \\<xi>) &&&\n    (\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> ip \\<xi>' = ip \\<xi>)", "unfolding is_msg_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rerr dests' sip' \\<Rightarrow>\n               {\\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      ip \\<xi>' = ip \\<xi>) &&&\n     (\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rrep hops' dip' dsn' oip' sip' \\<Rightarrow>\n               {\\<xi>\n                \\<lparr>hops := hops', dip := dip', dsn := dsn',\n                   oip := oip', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      ip \\<xi>' = ip \\<xi>)) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip'\n             handled' \\<Rightarrow>\n              {\\<xi>\n               \\<lparr>hops := hops', rreqid := rreqid', dip := dip',\n                  dsn := dsn', dsk := dsk', oip := oip', osn := osn',\n                  sip := sip', handled := handled'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     ip \\<xi>' = ip \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Pkt data' dip' oip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip', oip := oip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     ip \\<xi>' = ip \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Newpkt data' dip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     ip \\<xi>' = ip \\<xi>)", "by (cases \"msg \\<xi>\", clarsimp+)+"], ["", "lemma is_msg_inv_sn [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> sn \\<xi>' = sn \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>' \\<in> is_rerr \\<xi> \\<Longrightarrow> sn \\<xi>' = sn \\<xi>) &&&\n     (\\<xi>' \\<in> is_rrep \\<xi> \\<Longrightarrow>\n      sn \\<xi>' = sn \\<xi>)) &&&\n    (\\<xi>' \\<in> is_rreq \\<xi> \\<Longrightarrow> sn \\<xi>' = sn \\<xi>) &&&\n    (\\<xi>' \\<in> is_pkt \\<xi> \\<Longrightarrow> sn \\<xi>' = sn \\<xi>) &&&\n    (\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> sn \\<xi>' = sn \\<xi>)", "unfolding is_msg_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rerr dests' sip' \\<Rightarrow>\n               {\\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      sn \\<xi>' = sn \\<xi>) &&&\n     (\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rrep hops' dip' dsn' oip' sip' \\<Rightarrow>\n               {\\<xi>\n                \\<lparr>hops := hops', dip := dip', dsn := dsn',\n                   oip := oip', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      sn \\<xi>' = sn \\<xi>)) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip'\n             handled' \\<Rightarrow>\n              {\\<xi>\n               \\<lparr>hops := hops', rreqid := rreqid', dip := dip',\n                  dsn := dsn', dsk := dsk', oip := oip', osn := osn',\n                  sip := sip', handled := handled'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     sn \\<xi>' = sn \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Pkt data' dip' oip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip', oip := oip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     sn \\<xi>' = sn \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Newpkt data' dip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     sn \\<xi>' = sn \\<xi>)", "by (cases \"msg \\<xi>\", clarsimp+)+"], ["", "lemma is_msg_inv_rt [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> rt \\<xi>' = rt \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>' \\<in> is_rerr \\<xi> \\<Longrightarrow> rt \\<xi>' = rt \\<xi>) &&&\n     (\\<xi>' \\<in> is_rrep \\<xi> \\<Longrightarrow>\n      rt \\<xi>' = rt \\<xi>)) &&&\n    (\\<xi>' \\<in> is_rreq \\<xi> \\<Longrightarrow> rt \\<xi>' = rt \\<xi>) &&&\n    (\\<xi>' \\<in> is_pkt \\<xi> \\<Longrightarrow> rt \\<xi>' = rt \\<xi>) &&&\n    (\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> rt \\<xi>' = rt \\<xi>)", "unfolding is_msg_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rerr dests' sip' \\<Rightarrow>\n               {\\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      rt \\<xi>' = rt \\<xi>) &&&\n     (\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rrep hops' dip' dsn' oip' sip' \\<Rightarrow>\n               {\\<xi>\n                \\<lparr>hops := hops', dip := dip', dsn := dsn',\n                   oip := oip', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      rt \\<xi>' = rt \\<xi>)) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip'\n             handled' \\<Rightarrow>\n              {\\<xi>\n               \\<lparr>hops := hops', rreqid := rreqid', dip := dip',\n                  dsn := dsn', dsk := dsk', oip := oip', osn := osn',\n                  sip := sip', handled := handled'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     rt \\<xi>' = rt \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Pkt data' dip' oip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip', oip := oip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     rt \\<xi>' = rt \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Newpkt data' dip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     rt \\<xi>' = rt \\<xi>)", "by (cases \"msg \\<xi>\", clarsimp+)+"], ["", "lemma is_msg_inv_rreqs [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> rreqs \\<xi>' = rreqs \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>' \\<in> is_rerr \\<xi> \\<Longrightarrow>\n      rreqs \\<xi>' = rreqs \\<xi>) &&&\n     (\\<xi>' \\<in> is_rrep \\<xi> \\<Longrightarrow>\n      rreqs \\<xi>' = rreqs \\<xi>)) &&&\n    (\\<xi>' \\<in> is_rreq \\<xi> \\<Longrightarrow>\n     rreqs \\<xi>' = rreqs \\<xi>) &&&\n    (\\<xi>' \\<in> is_pkt \\<xi> \\<Longrightarrow>\n     rreqs \\<xi>' = rreqs \\<xi>) &&&\n    (\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow>\n     rreqs \\<xi>' = rreqs \\<xi>)", "unfolding is_msg_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rerr dests' sip' \\<Rightarrow>\n               {\\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      rreqs \\<xi>' = rreqs \\<xi>) &&&\n     (\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rrep hops' dip' dsn' oip' sip' \\<Rightarrow>\n               {\\<xi>\n                \\<lparr>hops := hops', dip := dip', dsn := dsn',\n                   oip := oip', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      rreqs \\<xi>' = rreqs \\<xi>)) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip'\n             handled' \\<Rightarrow>\n              {\\<xi>\n               \\<lparr>hops := hops', rreqid := rreqid', dip := dip',\n                  dsn := dsn', dsk := dsk', oip := oip', osn := osn',\n                  sip := sip', handled := handled'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     rreqs \\<xi>' = rreqs \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Pkt data' dip' oip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip', oip := oip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     rreqs \\<xi>' = rreqs \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Newpkt data' dip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     rreqs \\<xi>' = rreqs \\<xi>)", "by (cases \"msg \\<xi>\", clarsimp+)+"], ["", "lemma is_msg_inv_store [simp]:\n  \"\\<xi>' \\<in> is_rerr \\<xi>   \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_rrep \\<xi>   \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_rreq \\<xi>   \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> store \\<xi>' = store \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> store \\<xi>' = store \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>' \\<in> is_rerr \\<xi> \\<Longrightarrow>\n      store \\<xi>' = store \\<xi>) &&&\n     (\\<xi>' \\<in> is_rrep \\<xi> \\<Longrightarrow>\n      store \\<xi>' = store \\<xi>)) &&&\n    (\\<xi>' \\<in> is_rreq \\<xi> \\<Longrightarrow>\n     store \\<xi>' = store \\<xi>) &&&\n    (\\<xi>' \\<in> is_pkt \\<xi> \\<Longrightarrow>\n     store \\<xi>' = store \\<xi>) &&&\n    (\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow>\n     store \\<xi>' = store \\<xi>)", "unfolding is_msg_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rerr dests' sip' \\<Rightarrow>\n               {\\<xi>\\<lparr>dests := dests', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      store \\<xi>' = store \\<xi>) &&&\n     (\\<xi>'\n      \\<in> (case msg \\<xi> of\n             Rrep hops' dip' dsn' oip' sip' \\<Rightarrow>\n               {\\<xi>\n                \\<lparr>hops := hops', dip := dip', dsn := dsn',\n                   oip := oip', sip := sip'\\<rparr>}\n             | _ \\<Rightarrow> {}) \\<Longrightarrow>\n      store \\<xi>' = store \\<xi>)) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Rreq hops' rreqid' dip' dsn' dsk' oip' osn' sip'\n             handled' \\<Rightarrow>\n              {\\<xi>\n               \\<lparr>hops := hops', rreqid := rreqid', dip := dip',\n                  dsn := dsn', dsk := dsk', oip := oip', osn := osn',\n                  sip := sip', handled := handled'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     store \\<xi>' = store \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Pkt data' dip' oip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip', oip := oip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     store \\<xi>' = store \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Newpkt data' dip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     store \\<xi>' = store \\<xi>)", "by (cases \"msg \\<xi>\", clarsimp+)+"], ["", "lemma is_msg_inv_sip [simp]:\n  \"\\<xi>' \\<in> is_pkt \\<xi>    \\<Longrightarrow> sip \\<xi>' = sip \\<xi>\"\n  \"\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> sip \\<xi>' = sip \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<xi>' \\<in> is_pkt \\<xi> \\<Longrightarrow> sip \\<xi>' = sip \\<xi>) &&&\n    (\\<xi>' \\<in> is_newpkt \\<xi> \\<Longrightarrow> sip \\<xi>' = sip \\<xi>)", "unfolding is_msg_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Pkt data' dip' oip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip', oip := oip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     sip \\<xi>' = sip \\<xi>) &&&\n    (\\<xi>'\n     \\<in> (case msg \\<xi> of\n            Newpkt data' dip' \\<Rightarrow>\n              {\\<xi>\\<lparr>data := data', dip := dip'\\<rparr>}\n            | _ \\<Rightarrow> {}) \\<Longrightarrow>\n     sip \\<xi>' = sip \\<xi>)", "by (cases \"msg \\<xi>\", clarsimp+)+"], ["", "subsection \"The protocol process\""], ["", "datatype pseqp =\n    PAodv\n  | PNewPkt\n  | PPkt\n  | PRreq\n  | PRrep\n  | PRerr"], ["", "fun nat_of_seqp :: \"pseqp \\<Rightarrow> nat\"\nwhere\n  \"nat_of_seqp PAodv  = 1\"\n| \"nat_of_seqp PPkt   = 2\"\n| \"nat_of_seqp PNewPkt   = 3\"\n| \"nat_of_seqp PRreq  = 4\"\n| \"nat_of_seqp PRrep  = 5\"\n| \"nat_of_seqp PRerr  = 6\""], ["", "instantiation \"pseqp\" :: ord\nbegin"], ["", "definition less_eq_seqp [iff]: \"l1 \\<le> l2 = (nat_of_seqp l1 \\<le> nat_of_seqp l2)\""], ["", "definition less_seqp [iff]:    \"l1 < l2 = (nat_of_seqp l1 < nat_of_seqp l2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(pseqp, ord_class)", ".."], ["", "end"], ["", "abbreviation AODV\nwhere\n  \"AODV \\<equiv> \\<lambda>_. \\<lbrakk>clear_locals\\<rbrakk> call(PAodv)\""], ["", "abbreviation PKT\nwhere\n  \"PKT args \\<equiv>\n\n     \\<lbrakk>\\<xi>. let (data, dip, oip) = args \\<xi> in\n         (clear_locals \\<xi>) \\<lparr> data := data, dip := dip, oip := oip \\<rparr>\\<rbrakk>\n     call(PPkt)\""], ["", "abbreviation NEWPKT\nwhere\n  \"NEWPKT args \\<equiv>\n     \\<lbrakk>\\<xi>. let (data, dip) = args \\<xi> in\n         (clear_locals \\<xi>) \\<lparr> data := data, dip := dip \\<rparr>\\<rbrakk>\n     call(PNewPkt)\""], ["", "abbreviation RREQ\nwhere\n  \"RREQ args \\<equiv>\n     \\<lbrakk>\\<xi>. let (hops, rreqid, dip, dsn, dsk, oip, osn, sip, handled) = args \\<xi> in\n         (clear_locals \\<xi>) \\<lparr> hops := hops, rreqid := rreqid, dip := dip,\n                            dsn := dsn, dsk := dsk, oip := oip,\n                            osn := osn, sip := sip, handled := handled \\<rparr>\\<rbrakk>\n     call(PRreq)\""], ["", "abbreviation RREP\nwhere\n  \"RREP args \\<equiv>\n     \\<lbrakk>\\<xi>. let (hops, dip, dsn, oip, sip) = args \\<xi> in\n         (clear_locals \\<xi>) \\<lparr> hops := hops, dip := dip, dsn := dsn,\n                            oip := oip, sip := sip \\<rparr>\\<rbrakk>\n     call(PRrep)\""], ["", "abbreviation RERR\nwhere\n  \"RERR args \\<equiv>\n     \\<lbrakk>\\<xi>. let (dests, sip) = args \\<xi> in\n         (clear_locals \\<xi>) \\<lparr> dests := dests, sip := sip \\<rparr>\\<rbrakk>\n     call(PRerr)\""], ["", "fun \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V :: \"(state, msg, pseqp, pseqp label) seqp_env\"\nwhere\n  \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv = labelled PAodv (\n     receive(\\<lambda>msg' \\<xi>. \\<xi> \\<lparr> msg := msg' \\<rparr>).\n     (    \\<langle>is_newpkt\\<rangle> NEWPKT(\\<lambda>\\<xi>. (data \\<xi>, ip \\<xi>))\n       \\<oplus> \\<langle>is_pkt\\<rangle> PKT(\\<lambda>\\<xi>. (data \\<xi>, dip \\<xi>, oip \\<xi>))\n       \\<oplus> \\<langle>is_rreq\\<rangle>\n            \\<lbrakk>\\<xi>. \\<xi> \\<lparr>rt := update (rt \\<xi>) (sip \\<xi>) (0, unk, val, 1, sip \\<xi>, {}) \\<rparr>\\<rbrakk>\n            RREQ(\\<lambda>\\<xi>. (hops \\<xi>, rreqid \\<xi>, dip \\<xi>, dsn \\<xi>, dsk \\<xi>, oip \\<xi>, osn \\<xi>, sip \\<xi>, handled \\<xi>))\n       \\<oplus> \\<langle>is_rrep\\<rangle>\n            \\<lbrakk>\\<xi>. \\<xi> \\<lparr>rt := update (rt \\<xi>) (sip \\<xi>) (0, unk, val, 1, sip \\<xi>, {}) \\<rparr>\\<rbrakk>\n            RREP(\\<lambda>\\<xi>. (hops \\<xi>, dip \\<xi>, dsn \\<xi>, oip \\<xi>, sip \\<xi>))\n       \\<oplus> \\<langle>is_rerr\\<rangle>\n            \\<lbrakk>\\<xi>. \\<xi> \\<lparr>rt := update (rt \\<xi>) (sip \\<xi>) (0, unk, val, 1, sip \\<xi>, {}) \\<rparr>\\<rbrakk>\n            RERR(\\<lambda>\\<xi>. (dests \\<xi>, sip \\<xi>))\n     )\n     \\<oplus> \\<langle>\\<lambda>\\<xi>. { \\<xi>\\<lparr> dip := dip \\<rparr> | dip. dip \\<in> qD(store \\<xi>) \\<inter> vD(rt \\<xi>) }\\<rangle>\n          \\<lbrakk>\\<xi>. \\<xi> \\<lparr> data := hd(\\<sigma>\\<^bsub>queue\\<^esub>(store \\<xi>, dip \\<xi>)) \\<rparr>\\<rbrakk>\n          unicast(\\<lambda>\\<xi>. the (nhop (rt \\<xi>) (dip \\<xi>)), \\<lambda>\\<xi>. pkt(data \\<xi>, dip \\<xi>, ip \\<xi>)).\n            \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := the (drop (dip \\<xi>) (store \\<xi>)) \\<rparr>\\<rbrakk>\n            AODV()\n          \\<triangleright> \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if (rip \\<in> vD (rt \\<xi>) \\<and> nhop (rt \\<xi>) rip = nhop (rt \\<xi>) (dip \\<xi>))\n                                     then Some (inc (sqn (rt \\<xi>) rip)) else None) \\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := invalidate (rt \\<xi>) (dests \\<xi>) \\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := setRRF (store \\<xi>) (dests \\<xi>)\\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> pre := \\<Union>{ the (precs (rt \\<xi>) rip) | rip. rip \\<in> dom (dests \\<xi>) } \\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if ((dests \\<xi>) rip \\<noteq> None \\<and> the (precs (rt \\<xi>) rip) \\<noteq> {})\n                                     then (dests \\<xi>) rip else None) \\<rparr>\\<rbrakk>\n             groupcast(\\<lambda>\\<xi>. pre \\<xi>, \\<lambda>\\<xi>. rerr(dests \\<xi>, ip \\<xi>)). AODV()\n     \\<oplus> \\<langle>\\<lambda>\\<xi>. { \\<xi>\\<lparr> dip := dip \\<rparr>\n             | dip. dip \\<in> qD(store \\<xi>) - vD(rt \\<xi>) \\<and> the (\\<sigma>\\<^bsub>p-flag\\<^esub>(store \\<xi>, dip)) = req }\\<rangle>\n         \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := unsetRRF (store \\<xi>) (dip \\<xi>) \\<rparr>\\<rbrakk>\n         \\<lbrakk>\\<xi>. \\<xi> \\<lparr> sn := inc (sn \\<xi>) \\<rparr>\\<rbrakk>\n         \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rreqid := nrreqid (rreqs \\<xi>) (ip \\<xi>) \\<rparr>\\<rbrakk>\n         \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rreqs := rreqs \\<xi> \\<union> {(ip \\<xi>, rreqid \\<xi>)} \\<rparr>\\<rbrakk>\n         broadcast(\\<lambda>\\<xi>. rreq(0, rreqid \\<xi>, dip \\<xi>, sqn (rt \\<xi>) (dip \\<xi>), sqnf (rt \\<xi>) (dip \\<xi>), ip \\<xi>, sn \\<xi>,\n                            ip \\<xi>, False)). AODV())\"\n\n|  \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PNewPkt = labelled PNewPkt (\n     \\<langle>\\<xi>. dip \\<xi> = ip \\<xi>\\<rangle>\n        deliver(\\<lambda>\\<xi>. data \\<xi>).AODV()\n     \\<oplus> \\<langle>\\<xi>. dip \\<xi> \\<noteq> ip \\<xi>\\<rangle>\n        \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := add (data \\<xi>) (dip \\<xi>) (store \\<xi>) \\<rparr>\\<rbrakk>\n        AODV())\"\n\n| \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PPkt = labelled PPkt (\n     \\<langle>\\<xi>. dip \\<xi> = ip \\<xi>\\<rangle>\n        deliver(\\<lambda>\\<xi>. data \\<xi>).AODV()\n     \\<oplus> \\<langle>\\<xi>. dip \\<xi> \\<noteq> ip \\<xi>\\<rangle>\n     (\n       \\<langle>\\<xi>. dip \\<xi> \\<in> vD (rt \\<xi>)\\<rangle>\n         unicast(\\<lambda>\\<xi>. the (nhop (rt \\<xi>) (dip \\<xi>)), \\<lambda>\\<xi>. pkt(data \\<xi>, dip \\<xi>, oip \\<xi>)).AODV()\n         \\<triangleright>\n           \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if (rip \\<in> vD (rt \\<xi>) \\<and> nhop (rt \\<xi>) rip = nhop (rt \\<xi>) (dip \\<xi>))\n                                   then Some (inc (sqn (rt \\<xi>) rip)) else None) \\<rparr>\\<rbrakk>\n           \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := invalidate (rt \\<xi>) (dests \\<xi>) \\<rparr>\\<rbrakk>\n           \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := setRRF (store \\<xi>) (dests \\<xi>)\\<rparr>\\<rbrakk>\n           \\<lbrakk>\\<xi>. \\<xi> \\<lparr> pre := \\<Union>{ the (precs (rt \\<xi>) rip) | rip. rip \\<in> dom (dests \\<xi>) } \\<rparr>\\<rbrakk>\n           \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if ((dests \\<xi>) rip \\<noteq> None \\<and> the (precs (rt \\<xi>) rip) \\<noteq> {})\n                                   then (dests \\<xi>) rip else None) \\<rparr>\\<rbrakk>\n           groupcast(\\<lambda>\\<xi>. pre \\<xi>, \\<lambda>\\<xi>. rerr(dests \\<xi>, ip \\<xi>)).AODV()\n       \\<oplus> \\<langle>\\<xi>. dip \\<xi> \\<notin> vD (rt \\<xi>)\\<rangle>\n       (\n           \\<langle>\\<xi>. dip \\<xi> \\<in> iD (rt \\<xi>)\\<rangle>\n             groupcast(\\<lambda>\\<xi>. the (precs (rt \\<xi>) (dip \\<xi>)), \\<lambda>\\<xi>. rerr([dip \\<xi> \\<mapsto> sqn (rt \\<xi>) (dip \\<xi>)],\n                                                                ip \\<xi>)).AODV()\n           \\<oplus> \\<langle>\\<xi>. dip \\<xi> \\<notin> iD (rt \\<xi>)\\<rangle>\n              AODV()\n       )\n     ))\"\n\n| \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRreq = labelled PRreq (\n     \\<langle>\\<xi>. (oip \\<xi>, rreqid \\<xi>) \\<in> rreqs \\<xi>\\<rangle>\n       AODV()\n     \\<oplus> \\<langle>\\<xi>. (oip \\<xi>, rreqid \\<xi>) \\<notin> rreqs \\<xi>\\<rangle>\n       \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := update (rt \\<xi>) (oip \\<xi>) (osn \\<xi>, kno, val, hops \\<xi> + 1, sip \\<xi>, {}) \\<rparr>\\<rbrakk>\n       \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rreqs := rreqs \\<xi> \\<union> {(oip \\<xi>, rreqid \\<xi>)} \\<rparr>\\<rbrakk>\n       (\n         \\<langle>\\<xi>. handled \\<xi> = False\\<rangle>\n         (\n           \\<langle>\\<xi>. dip \\<xi> = ip \\<xi>\\<rangle>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> sn := max (sn \\<xi>) (dsn \\<xi>) \\<rparr>\\<rbrakk>\n             unicast(\\<lambda>\\<xi>. the (nhop (rt \\<xi>) (oip \\<xi>)), \\<lambda>\\<xi>. rrep(0, dip \\<xi>, sn \\<xi>, oip \\<xi>, ip \\<xi>)).\n               broadcast(\\<lambda>\\<xi>. rreq(hops \\<xi> + 1, rreqid \\<xi>, dip \\<xi>, dsn \\<xi>, dsk \\<xi>, oip \\<xi>, osn \\<xi>, ip \\<xi>, True)).\n               AODV()\n             \\<triangleright>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if (rip \\<in> vD (rt \\<xi>) \\<and> nhop (rt \\<xi>) rip = nhop (rt \\<xi>) (oip \\<xi>))\n                                       then Some (inc (sqn (rt \\<xi>) rip)) else None) \\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := invalidate (rt \\<xi>) (dests \\<xi>) \\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := setRRF (store \\<xi>) (dests \\<xi>)\\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> pre := \\<Union>{ the (precs (rt \\<xi>) rip) | rip. rip \\<in> dom (dests \\<xi>) } \\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if ((dests \\<xi>) rip \\<noteq> None \\<and> the (precs (rt \\<xi>) rip) \\<noteq> {})\n                                       then (dests \\<xi>) rip else None) \\<rparr>\\<rbrakk>\n               groupcast(\\<lambda>\\<xi>. pre \\<xi>, \\<lambda>\\<xi>. rerr(dests \\<xi>, ip \\<xi>)).AODV()\n           \\<oplus> \\<langle>\\<xi>. dip \\<xi> \\<noteq> ip \\<xi>\\<rangle>\n           (\n             \\<langle>\\<xi>. dip \\<xi> \\<in> vD (rt \\<xi>) \\<and> dsn \\<xi> \\<le> sqn (rt \\<xi>) (dip \\<xi>) \\<and> sqnf (rt \\<xi>) (dip \\<xi>) = kno\\<rangle>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := the (addpreRT (rt \\<xi>) (dip \\<xi>) {sip \\<xi>}) \\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := the (addpreRT (rt \\<xi>) (oip \\<xi>) {the (nhop (rt \\<xi>) (dip \\<xi>))}) \\<rparr>\\<rbrakk> \n               unicast(\\<lambda>\\<xi>. the (nhop (rt \\<xi>) (oip \\<xi>)), \\<lambda>\\<xi>. rrep(the (dhops (rt \\<xi>) (dip \\<xi>)), dip \\<xi>,\n               sqn (rt \\<xi>) (dip \\<xi>), oip \\<xi>, ip \\<xi>)).\n                 broadcast(\\<lambda>\\<xi>. rreq(hops \\<xi> + 1, rreqid \\<xi>, dip \\<xi>, dsn \\<xi>,\n                                dsk \\<xi>, oip \\<xi>, osn \\<xi>, ip \\<xi>, True)).\n                 AODV()\n             \\<triangleright>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if (rip \\<in> vD (rt \\<xi>) \\<and> nhop (rt \\<xi>) rip = nhop (rt \\<xi>) (oip \\<xi>))\n                                       then Some (inc (sqn (rt \\<xi>) rip)) else None) \\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := invalidate (rt \\<xi>) (dests \\<xi>) \\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := setRRF (store \\<xi>) (dests \\<xi>)\\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> pre := \\<Union>{ the (precs (rt \\<xi>) rip) | rip. rip \\<in> dom (dests \\<xi>) } \\<rparr>\\<rbrakk>\n               \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if ((dests \\<xi>) rip \\<noteq> None \\<and> the (precs (rt \\<xi>) rip) \\<noteq> {})\n                                       then (dests \\<xi>) rip else None) \\<rparr>\\<rbrakk>\n               groupcast(\\<lambda>\\<xi>. pre \\<xi>, \\<lambda>\\<xi>. rerr(dests \\<xi>, ip \\<xi>)).AODV()\n             \\<oplus> \\<langle>\\<xi>. dip \\<xi> \\<notin> vD (rt \\<xi>) \\<or> sqn (rt \\<xi>) (dip \\<xi>) < dsn \\<xi> \\<or> sqnf (rt \\<xi>) (dip \\<xi>) = unk\\<rangle>\n               broadcast(\\<lambda>\\<xi>. rreq(hops \\<xi> + 1, rreqid \\<xi>, dip \\<xi>, max (sqn (rt \\<xi>) (dip \\<xi>)) (dsn \\<xi>),\n                                  dsk \\<xi>, oip \\<xi>, osn \\<xi>, ip \\<xi>, False)).\n               AODV()\n           )\n         )\n         \\<oplus> \\<langle>\\<xi>. handled \\<xi> = True\\<rangle>\n           broadcast(\\<lambda>\\<xi>. rreq(hops \\<xi> + 1, rreqid \\<xi>, dip \\<xi>, dsn \\<xi>, dsk \\<xi>, oip \\<xi>, osn \\<xi>, ip \\<xi>, True)).\n           AODV()\n       ))\"\n\n| \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRrep = labelled PRrep (\n     \\<langle>\\<xi>. rt \\<xi> \\<noteq> update (rt \\<xi>) (dip \\<xi>) (dsn \\<xi>, kno, val, hops \\<xi> + 1, sip \\<xi>, {}) \\<rangle>\n     (\n       \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := update (rt \\<xi>) (dip \\<xi>) (dsn \\<xi>, kno, val, hops \\<xi> + 1, sip \\<xi>, {}) \\<rparr> \\<rbrakk>\n       (\n         \\<langle>\\<xi>. oip \\<xi> = ip \\<xi> \\<rangle>\n            AODV()\n         \\<oplus> \\<langle>\\<xi>. oip \\<xi> \\<noteq> ip \\<xi> \\<rangle>\n         (\n           \\<langle>\\<xi>. oip \\<xi> \\<in> vD (rt \\<xi>)\\<rangle>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := the (addpreRT (rt \\<xi>) (dip \\<xi>) {the (nhop (rt \\<xi>) (oip \\<xi>))}) \\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := the (addpreRT (rt \\<xi>) (the (nhop (rt \\<xi>) (dip \\<xi>)))\n                                               {the (nhop (rt \\<xi>) (oip \\<xi>))}) \\<rparr>\\<rbrakk> \n             unicast(\\<lambda>\\<xi>. the (nhop (rt \\<xi>) (oip \\<xi>)), \\<lambda>\\<xi>. rrep(hops \\<xi> + 1, dip \\<xi>, dsn \\<xi>, oip \\<xi>, ip \\<xi>)).\n             AODV()\n           \\<triangleright>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if (rip \\<in> vD (rt \\<xi>) \\<and> nhop (rt \\<xi>) rip = nhop (rt \\<xi>) (oip \\<xi>))\n                                     then Some (inc (sqn (rt \\<xi>) rip)) else None) \\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := invalidate (rt \\<xi>) (dests \\<xi>) \\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := setRRF (store \\<xi>) (dests \\<xi>)\\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> pre := \\<Union>{ the (precs (rt \\<xi>) rip) | rip. rip \\<in> dom (dests \\<xi>) } \\<rparr>\\<rbrakk>\n             \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if ((dests \\<xi>) rip \\<noteq> None \\<and> the (precs (rt \\<xi>) rip) \\<noteq> {})\n                                     then (dests \\<xi>) rip else None) \\<rparr>\\<rbrakk>\n             groupcast(\\<lambda>\\<xi>. pre \\<xi>, \\<lambda>\\<xi>. rerr(dests \\<xi>, ip \\<xi>)).AODV()\n           \\<oplus> \\<langle>\\<xi>. oip \\<xi> \\<notin> vD (rt \\<xi>)\\<rangle>\n             AODV()\n         )\n       )\n     )\n     \\<oplus> \\<langle>\\<xi>. rt \\<xi> = update (rt \\<xi>) (dip \\<xi>) (dsn \\<xi>, kno, val, hops \\<xi> + 1, sip \\<xi>, {}) \\<rangle>\n         AODV()\n     )\"\n\n| \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRerr = labelled PRerr (\n     \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. case (dests \\<xi>) rip of None \\<Rightarrow> None\n                       | Some rsn \\<Rightarrow> if rip \\<in> vD (rt \\<xi>) \\<and> the (nhop (rt \\<xi>) rip) = sip \\<xi>\n                                       \\<and> sqn (rt \\<xi>) rip < rsn then Some rsn else None) \\<rparr>\\<rbrakk>\n     \\<lbrakk>\\<xi>. \\<xi> \\<lparr> rt := invalidate (rt \\<xi>) (dests \\<xi>) \\<rparr>\\<rbrakk>\n     \\<lbrakk>\\<xi>. \\<xi> \\<lparr> store := setRRF (store \\<xi>) (dests \\<xi>)\\<rparr>\\<rbrakk>\n     \\<lbrakk>\\<xi>. \\<xi> \\<lparr> pre := \\<Union>{ the (precs (rt \\<xi>) rip) | rip. rip \\<in> dom (dests \\<xi>) } \\<rparr>\\<rbrakk>\n     \\<lbrakk>\\<xi>. \\<xi> \\<lparr> dests := (\\<lambda>rip. if ((dests \\<xi>) rip \\<noteq> None \\<and> the (precs (rt \\<xi>) rip) \\<noteq> {})\n                             then (dests \\<xi>) rip else None) \\<rparr>\\<rbrakk>\n     groupcast(\\<lambda>\\<xi>. pre \\<xi>, \\<lambda>\\<xi>. rerr(dests \\<xi>, ip \\<xi>)). AODV())\""], ["", "declare \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V.simps [simp del, code del]"], ["", "lemmas \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_simps [simp, code] = \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V.simps [simplified]"], ["", "fun \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton\nwhere\n    \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton PAodv   = seqp_skeleton (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv)\"\n  | \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton PNewPkt = seqp_skeleton (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PNewPkt)\"\n  | \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton PPkt    = seqp_skeleton (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PPkt)\"\n  | \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton PRreq   = seqp_skeleton (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRreq)\"\n  | \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton PRrep   = seqp_skeleton (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRrep)\"\n  | \"\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton PRerr   = seqp_skeleton (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRerr)\""], ["", "lemma \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton_wf [simp]:\n  \"wellformed \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton", "proof (rule, intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pn pn'.\n       call(pn')\n       \\<notin> stermsl\n                 (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton pn)", "fix pn pn'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pn pn'.\n       call(pn')\n       \\<notin> stermsl\n                 (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton pn)", "show \"call(pn') \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton pn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. call(pn')\n    \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton pn)", "by (cases pn) simp_all"], ["proof (state)\nthis:\n  call(pn')\n  \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton pn)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton.simps [simp del, code del]"], ["", "lemmas \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton_simps [simp, code]\n           = \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_skeleton.simps [simplified \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_simps seqp_skeleton.simps]"], ["", "lemma aodv_proc_cases [dest]:\n  fixes p pn\n  shows \"p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn) \\<Longrightarrow>\n                                (p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv) \\<or> \n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PNewPkt)  \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PPkt)  \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRreq) \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRrep) \\<or>\n                                 p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRerr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> ctermsl\n             (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn) \\<Longrightarrow>\n    p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv) \\<or>\n    p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PNewPkt) \\<or>\n    p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PPkt) \\<or>\n    p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRreq) \\<or>\n    p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRrep) \\<or>\n    p \\<in> ctermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PRerr)", "by (cases pn) simp_all"], ["", "definition \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V :: \"ip \\<Rightarrow> (state \\<times> (state, msg, pseqp, pseqp label) seqp) set\"\nwhere \"\\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i \\<equiv> {(aodv_init i, \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv)}\""], ["", "abbreviation paodv\n  :: \"ip \\<Rightarrow> (state \\<times> (state, msg, pseqp, pseqp label) seqp, msg seq_action) automaton\"\nwhere\n  \"paodv i \\<equiv> \\<lparr> init = \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i, trans = seqp_sos \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V \\<rparr>\""], ["", "lemma aodv_trans: \"trans (paodv i) = seqp_sos \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. automaton.trans (paodv i) =\n    seqp_sos \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V", "by simp"], ["", "lemma aodv_control_within [simp]: \"control_within \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V (init (paodv i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. control_within \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V (init (paodv i))", "unfolding \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. control_within \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\n     (init\n       \\<lparr>init =\n                 {(aodv_init i,\n                   \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv)},\n          trans = seqp_sos \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\\<rparr>)", "by (rule control_withinI) (auto simp del: \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_simps)"], ["", "lemma aodv_wf [simp]:\n  \"wellformed \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V", "proof (rule, intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pn pn'.\n       call(pn')\n       \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)", "fix pn pn'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pn pn'.\n       call(pn')\n       \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)", "show \"call(pn') \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. call(pn') \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)", "by (cases pn) simp_all"], ["proof (state)\nthis:\n  call(pn') \\<notin> stermsl (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas aodv_labels_not_empty [simp] = labels_not_empty [OF aodv_wf]"], ["", "lemma aodv_ex_label [intro]: \"\\<exists>l. l\\<in>labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. l \\<in> labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p", "by (metis aodv_labels_not_empty all_not_in_conv)"], ["", "lemma aodv_ex_labelE [elim]:\n  assumes \"\\<forall>l\\<in>labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p. P l p\"\n      and \"\\<exists>p l. P l p \\<Longrightarrow> Q\"\n    shows \"Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>l\\<in>labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p. P l p\n  \\<exists>p l. P l p \\<Longrightarrow> Q\n\ngoal (1 subgoal):\n 1. Q", "by (metis aodv_ex_label)"], ["", "lemma aodv_simple_labels [simp]: \"simple_labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pn p.\n       p \\<in> subterms\n                (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\n                  pn) \\<Longrightarrow>\n       \\<exists>!l. labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {l}", "fix pn p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pn p.\n       p \\<in> subterms\n                (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\n                  pn) \\<Longrightarrow>\n       \\<exists>!l. labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {l}", "assume \"p\\<in>subterms(\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)\""], ["proof (state)\nthis:\n  p \\<in> subterms (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)\n\ngoal (1 subgoal):\n 1. \\<And>pn p.\n       p \\<in> subterms\n                (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\n                  pn) \\<Longrightarrow>\n       \\<exists>!l. labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {l}", "thus \"\\<exists>!l. labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {l}\""], ["proof (prove)\nusing this:\n  p \\<in> subterms (\\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V pn)\n\ngoal (1 subgoal):\n 1. \\<exists>!l. labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {l}", "by (cases pn) (simp_all cong: seqp_congs | elim disjE)+"], ["proof (state)\nthis:\n  \\<exists>!l. labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {l}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_labels [simp]: \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i \\<Longrightarrow>  labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {PAodv-:0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<xi>, p)\n    \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i \\<Longrightarrow>\n    labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {PAodv-:0}", "unfolding \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<xi>, p)\n    \\<in> {(aodv_init i,\n            \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\n             PAodv)} \\<Longrightarrow>\n    labels \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V p = {PAodv-:0}", "by simp"], ["", "lemma aodv_init_kD_empty [simp]:\n  \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i \\<Longrightarrow> kD (rt \\<xi>) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<xi>, p)\n    \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i \\<Longrightarrow>\n    kD (rt \\<xi>) = {}", "unfolding \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_def kD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<xi>, p)\n    \\<in> {(aodv_init i,\n            \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V\n             PAodv)} \\<Longrightarrow>\n    {dip. rt \\<xi> dip \\<noteq> None} = {}", "by simp"], ["", "lemma aodv_init_sip_not_ip [simp]: \"\\<not>(sip (aodv_init i) = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sip (aodv_init i) \\<noteq> i", "by simp"], ["", "lemma aodv_init_sip_not_ip' [simp]:\n  assumes \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i\"\n    shows \"sip \\<xi> \\<noteq> ip \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sip \\<xi> \\<noteq> ip \\<xi>", "using assms"], ["proof (prove)\nusing this:\n  (\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i\n\ngoal (1 subgoal):\n 1. sip \\<xi> \\<noteq> ip \\<xi>", "unfolding \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_def"], ["proof (prove)\nusing this:\n  (\\<xi>, p)\n  \\<in> {(aodv_init i, \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv)}\n\ngoal (1 subgoal):\n 1. sip \\<xi> \\<noteq> ip \\<xi>", "by simp"], ["", "lemma aodv_init_sip_not_i [simp]:\n  assumes \"(\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i\"\n    shows \"sip \\<xi> \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sip \\<xi> \\<noteq> i", "using assms"], ["proof (prove)\nusing this:\n  (\\<xi>, p) \\<in> \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V i\n\ngoal (1 subgoal):\n 1. sip \\<xi> \\<noteq> i", "unfolding \\<sigma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_def"], ["proof (prove)\nusing this:\n  (\\<xi>, p)\n  \\<in> {(aodv_init i, \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V PAodv)}\n\ngoal (1 subgoal):\n 1. sip \\<xi> \\<noteq> i", "by simp"], ["", "lemma clear_locals_sip_not_ip':\n  assumes \"ip \\<xi> = i\"\n    shows \"\\<not>(sip (clear_locals \\<xi>) = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sip (clear_locals \\<xi>) \\<noteq> i", "using assms"], ["proof (prove)\nusing this:\n  ip \\<xi> = i\n\ngoal (1 subgoal):\n 1. sip (clear_locals \\<xi>) \\<noteq> i", "by auto"], ["", "text \\<open>Stop the simplifier from descending into process terms.\\<close>"], ["", "declare seqp_congs [cong]"], ["", "text \\<open>Configure the main invariant tactic for AODV.\\<close>"], ["", "declare\n  \\<Gamma>\\<^sub>A\\<^sub>O\\<^sub>D\\<^sub>V_simps [cterms_env]\n  aodv_proc_cases [ctermsl_cases]\n  seq_invariant_ctermsI [OF aodv_wf aodv_control_within aodv_simple_labels aodv_trans,\n                            cterms_intros]\n  seq_step_invariant_ctermsI [OF aodv_wf aodv_control_within aodv_simple_labels aodv_trans,\n                                 cterms_intros]"], ["", "end"]]}