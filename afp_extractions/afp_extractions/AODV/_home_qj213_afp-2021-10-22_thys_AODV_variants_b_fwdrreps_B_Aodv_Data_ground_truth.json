{"file_name": "/home/qj213/afp-2021-10-22/thys/AODV/variants/b_fwdrreps/B_Aodv_Data.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AODV", "problem_names": ["lemma less_than_inc [simp]: \"x \\<le> inc x\"", "lemma inc_minus_suc_0 [simp]:\n  \"inc x - Suc 0 = x\"", "lemma inc_never_one' [simp, intro]: \"inc x \\<noteq> Suc 0\"", "lemma inc_never_one [simp, intro]: \"inc x \\<noteq> 1\"", "lemma projs [simp]:\n  \"\\<pi>\\<^sub>2(dsn, dsk, flag, hops, nhip, pre) = dsn\"\n  \"\\<pi>\\<^sub>3(dsn, dsk, flag, hops, nhip, pre) = dsk\"\n  \"\\<pi>\\<^sub>4(dsn, dsk, flag, hops, nhip, pre) = flag\"\n  \"\\<pi>\\<^sub>5(dsn, dsk, flag, hops, nhip, pre) = hops\"\n  \"\\<pi>\\<^sub>6(dsn, dsk, flag, hops, nhip, pre) = nhip\"\n  \"\\<pi>\\<^sub>7(dsn, dsk, flag, hops, nhip, pre) = pre\"", "lemma proj3_pred [intro]: \"\\<lbrakk> P kno; P unk \\<rbrakk> \\<Longrightarrow> P (\\<pi>\\<^sub>3 x)\"", "lemma proj4_pred [intro]: \"\\<lbrakk> P val; P inv \\<rbrakk> \\<Longrightarrow> P (\\<pi>\\<^sub>4 x)\"", "lemma proj6_pair_snd [simp]:\n  fixes dsn' r\n  shows \"\\<pi>\\<^sub>6 (dsn', snd (r)) = \\<pi>\\<^sub>6(r)\"", "lemma kD_is_vD_and_iD: \"kD rt = vD rt \\<union> iD rt\"", "lemma vD_iD_gives_kD [simp]:\n   \"\\<And>ip rt. ip \\<in> vD rt \\<Longrightarrow> ip \\<in> kD rt\"\n   \"\\<And>ip rt. ip \\<in> iD rt \\<Longrightarrow> ip \\<in> kD rt\"", "lemma kD_Some [dest]:\n    fixes dip rt\n  assumes \"dip \\<in> kD rt\"\n    shows \"\\<exists>dsn dsk flag hops nhip pre.\n           \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = Some (dsn, dsk, flag, hops, nhip, pre)\"", "lemma kD_None [dest]:\n    fixes dip rt\n  assumes \"dip \\<notin> kD rt\"\n    shows \"\\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = None\"", "lemma vD_Some [dest]:\n    fixes dip rt\n  assumes \"dip \\<in> vD rt\"\n    shows \"\\<exists>dsn dsk hops nhip pre.\n           \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = Some (dsn, dsk, val, hops, nhip, pre)\"", "lemma vD_empty [simp]: \"vD Map.empty = {}\"", "lemma iD_Some [dest]:\n    fixes dip rt\n  assumes \"dip \\<in> iD rt\"\n    shows \"\\<exists>dsn dsk hops nhip pre.\n           \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = Some (dsn, dsk, inv, hops, nhip, pre)\"", "lemma val_is_vD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"the (flag rt ip) = val\"\n    shows \"ip\\<in>vD(rt)\"", "lemma inv_is_iD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"the (flag rt ip) = inv\"\n    shows \"ip\\<in>iD(rt)\"", "lemma iD_flag_is_inv [elim, simp]:\n    fixes ip rt\n  assumes \"ip\\<in>iD(rt)\"\n    shows \"the (flag rt ip) = inv\"", "lemma kD_but_not_vD_is_iD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"ip\\<notin>vD(rt)\"\n    shows \"ip\\<in>iD(rt)\"", "lemma vD_or_iD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"ip\\<in>vD(rt) \\<Longrightarrow> P rt ip\"\n      and \"ip\\<in>iD(rt) \\<Longrightarrow> P rt ip\"\n    shows \"P rt ip\"", "lemma proj5_eq_dhops: \"\\<And>dip rt. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>5(the (rt dip)) = the (dhops rt dip)\"", "lemma proj4_eq_flag: \"\\<And>dip rt. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>4(the (rt dip)) = the (flag rt dip)\"", "lemma proj2_eq_sqn: \"\\<And>dip rt. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>2(the (rt dip)) = sqn rt dip\"", "lemma kD_sqnf_is_proj3 [simp]:\n  \"\\<And>ip rt. ip\\<in>kD(rt) \\<Longrightarrow> sqnf rt ip = \\<pi>\\<^sub>3(the (rt ip))\"", "lemma vD_flag_val [simp]:\n  \"\\<And>dip rt. dip \\<in> vD (rt) \\<Longrightarrow> the (flag rt dip) = val\"", "lemma kD_update [simp]:\n  \"\\<And>rt nip v. kD (rt(nip \\<mapsto> v)) = insert nip (kD rt)\"", "lemma kD_empty [simp]: \"kD Map.empty = {}\"", "lemma ip_equal_or_known [elim]:\n  fixes rt ip ip'\n  assumes \"ip = ip' \\<or> ip\\<in>kD(rt)\"\n      and \"ip = ip' \\<Longrightarrow> P rt ip ip'\"\n      and \"\\<lbrakk> ip \\<noteq> ip'; ip\\<in>kD(rt)\\<rbrakk> \\<Longrightarrow> P rt ip ip'\"\n    shows \"P rt ip ip'\"", "lemma proj2_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>2(addpre v pre) = \\<pi>\\<^sub>2(v)\"", "lemma proj3_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>3(addpre v pre) = \\<pi>\\<^sub>3(v)\"", "lemma proj4_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>4(addpre v pre) = \\<pi>\\<^sub>4(v)\"", "lemma proj5_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>5(addpre v pre) = \\<pi>\\<^sub>5(v)\"", "lemma proj6_addpre:\n  fixes dsn dsk flag hops nhip pre npre\n  shows \"\\<pi>\\<^sub>6(addpre v npre) = \\<pi>\\<^sub>6(v)\"", "lemma proj7_addpre:\n  fixes dsn dsk flag hops nhip pre npre\n  shows \"\\<pi>\\<^sub>7(addpre v npre) = \\<pi>\\<^sub>7(v) \\<union> npre\"", "lemma addpre_empty: \"addpre r {} = r\"", "lemma addpre_r:\n  \"addpre (dsn, dsk, fl, hops, nhip, pre) npre = (dsn, dsk, fl, hops, nhip, pre \\<union> npre)\"", "lemmas addpre_simps [simp] = proj2_addpre proj3_addpre proj4_addpre proj5_addpre\n                             proj6_addpre proj7_addpre addpre_empty addpre_r", "lemma snd_addpre [simp]:\n  \"\\<And>dsn dsn' v pre. (dsn, snd(addpre (dsn', v) pre)) = addpre (dsn, v) pre\"", "lemma proj2_addpreRT [simp]:\n    fixes ip rt ip' npre\n  assumes \"ip\\<in>kD rt\"\n      and \"ip'\\<in>kD rt\"\n    shows \"\\<pi>\\<^sub>2(the (the (addpreRT rt ip' npre) ip)) = \\<pi>\\<^sub>2(the (rt ip))\"", "lemma proj3_addpreRT [simp]:\n    fixes ip rt ip' npre\n  assumes \"ip\\<in>kD rt\"\n      and \"ip'\\<in>kD rt\"\n    shows \"\\<pi>\\<^sub>3(the (the (addpreRT rt ip' npre) ip)) = \\<pi>\\<^sub>3(the (rt ip))\"", "lemma proj5_addpreRT [simp]:\n  \"\\<And>rt dip ip npre. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>5(the (the (addpreRT rt dip npre) ip)) = \\<pi>\\<^sub>5(the (rt ip))\"", "lemma flag_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"flag (the (addpreRT rt dip pre)) ip = flag rt ip\"", "lemma kD_addpreRT [simp]:\n  fixes rt dip npre\n  assumes \"dip \\<in> kD rt\"\n  shows \"kD (the (addpreRT rt dip npre)) = kD rt\"", "lemma vD_addpreRT [simp]:\n  fixes rt dip npre\n  assumes \"dip \\<in> kD rt\"\n  shows \"vD (the (addpreRT rt dip npre)) = vD rt\"", "lemma iD_addpreRT [simp]:\n  fixes rt dip npre\n  assumes \"dip \\<in> kD rt\"\n  shows \"iD (the (addpreRT rt dip npre)) = iD rt\"", "lemma nhop_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"nhop (the (addpreRT rt dip pre)) ip = nhop rt ip\"", "lemma sqn_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"sqn (the (addpreRT rt dip pre)) ip = sqn rt ip\"", "lemma dhops_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"dhops (the (addpreRT rt dip pre)) ip = dhops rt ip\"", "lemma sqnf_addpreRT [simp]:\n  \"\\<And>ip dip. ip\\<in>kD(rt \\<xi>) \\<Longrightarrow> sqnf (the (addpreRT (rt \\<xi>) ip npre)) dip = sqnf (rt \\<xi>) dip\"", "lemma in_kD_case [simp]:\n    fixes dip rt\n  assumes \"dip \\<in> kD(rt)\"\n    shows \"(case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) = es (the (rt dip))\"", "lemma not_in_kD_case [simp]:\n    fixes dip rt\n  assumes \"dip \\<notin> kD(rt)\"\n    shows \"(case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) = en\"", "lemma rt_Some_sqn [dest]:\n    fixes rt and ip dsn dsk flag hops nhip pre\n  assumes \"rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\"\n    shows \"sqn rt ip = dsn\"", "lemma not_kD_sqn [simp]:\n    fixes dip rt\n  assumes \"dip \\<notin> kD(rt)\"\n    shows \"sqn rt dip = 0\"", "lemma update_arg_wf_gives_cases:\n  \"\\<And>r. update_arg_wf r \\<Longrightarrow> (\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\"", "lemma update_arg_wf_tuples [simp]:\n  \"\\<And>nhip pre. update_arg_wf (0, unk, val, Suc 0, nhip, pre)\"\n  \"\\<And>n hops nhip pre. update_arg_wf (Suc n, kno, val, hops,  nhip, pre)\"", "lemma update_arg_wf_tuples' [elim]:\n  \"\\<And>n hops nhip pre. Suc 0 \\<le> n \\<Longrightarrow> update_arg_wf (n, kno, val, hops,  nhip, pre)\"", "lemma wf_r_cases [intro]:\n    fixes P r\n  assumes \"update_arg_wf r\"\n      and c1: \"\\<And>nhip pre. P (0, unk, val, Suc 0, nhip, pre)\"\n      and c2: \"\\<And>dsn hops nhip pre. dsn > 0 \\<Longrightarrow> P (dsn, kno, val, hops, nhip, pre)\"\n    shows \"P r\"", "lemma update_simps [simp]:\n  fixes r s nrt nr nr' ns rt ip\n  defines \"s \\<equiv> the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)\"\n      and \"nr \\<equiv> addpre r (\\<pi>\\<^sub>7(s))\"\n      and \"nr' \\<equiv> (\\<pi>\\<^sub>2(s), \\<pi>\\<^sub>3(nr), \\<pi>\\<^sub>4(nr), \\<pi>\\<^sub>5(nr), \\<pi>\\<^sub>6(nr), \\<pi>\\<^sub>7(nr))\"\n      and \"ns \\<equiv> addpre s (\\<pi>\\<^sub>7(r))\"\n  shows\n  \"\\<lbrakk>ip \\<notin> kD(rt)\\<rbrakk>                            \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> r)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip < \\<pi>\\<^sub>2(r)\\<rbrakk>         \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r);\n                 the (dhops rt ip) > \\<pi>\\<^sub>5(r)\\<rbrakk> \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r);\n                 flag rt ip = Some inv\\<rbrakk>     \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); \\<pi>\\<^sub>3(r) = unk; (\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\\<rbrakk>  \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr')\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip \\<ge> \\<pi>\\<^sub>2(r); \\<pi>\\<^sub>3(r) = kno;\n    sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val \\<rbrakk>\n                                            \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> ns)\"", "lemma update_cases [elim]:\n  assumes \"(\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\"\n      and c1: \"\\<lbrakk>ip \\<notin> kD(rt)\\<rbrakk> \\<Longrightarrow> P (rt (ip \\<mapsto> r))\"\n\n      and c2: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip < \\<pi>\\<^sub>2(r)\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c3: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r); the (dhops rt ip) > \\<pi>\\<^sub>5(r)\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c4: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r); the (flag rt ip) = inv\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c5: \"\\<lbrakk>ip \\<in> kD(rt); \\<pi>\\<^sub>3(r) = unk\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> (\\<pi>\\<^sub>2(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)), \\<pi>\\<^sub>3(r),\n                                  \\<pi>\\<^sub>4(r), \\<pi>\\<^sub>5(r), \\<pi>\\<^sub>6(r), \\<pi>\\<^sub>7(addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))))\"\n      and c6: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip \\<ge> \\<pi>\\<^sub>2(r); \\<pi>\\<^sub>3(r) = kno;\n                sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre (the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)) (\\<pi>\\<^sub>7(r))))\"\n  shows \"(P (update rt ip r))\"", "lemma update_cases_kD:\n  assumes \"(\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\"\n      and \"ip \\<in> kD(rt)\"\n      and c2: \"sqn rt ip < \\<pi>\\<^sub>2(r) \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c3: \"\\<lbrakk>sqn rt ip = \\<pi>\\<^sub>2(r); the (dhops rt ip) > \\<pi>\\<^sub>5(r)\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c4: \"\\<lbrakk>sqn rt ip = \\<pi>\\<^sub>2(r); the (flag rt ip) = inv\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c5: \"\\<pi>\\<^sub>3(r) = unk \\<Longrightarrow> P (rt (ip \\<mapsto> (\\<pi>\\<^sub>2(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)), \\<pi>\\<^sub>3(r),\n                                            \\<pi>\\<^sub>4(r), \\<pi>\\<^sub>5(r), \\<pi>\\<^sub>6(r),\n                                            \\<pi>\\<^sub>7(addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))))\"\n      and c6: \"\\<lbrakk>sqn rt ip \\<ge> \\<pi>\\<^sub>2(r); \\<pi>\\<^sub>3(r) = kno;\n                sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre (the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)) (\\<pi>\\<^sub>7(r))))\"\n  shows \"(P (update rt ip r))\"", "lemma in_kD_after_update [simp]:\n  fixes rt nip dsn dsk flag hops nhip pre\n  shows \"kD (update rt nip (dsn, dsk, flag, hops, nhip, pre)) = insert nip (kD rt)\"", "lemma nhop_of_update [simp]:\n  fixes rt dip dsn dsk flag hops nhip\n  assumes \"rt \\<noteq> update rt dip (dsn, dsk, flag, hops, nhip, {})\"\n  shows \"the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip\"", "lemma sqn_if_updated:\n  fixes rip v rt ip\n  shows \"sqn (\\<lambda>x. if x = rip then Some v else rt x) ip\n         = (if ip = rip then \\<pi>\\<^sub>2(v) else sqn rt ip)\"", "lemma update_sqn [simp]:\n  fixes rt dip rip dsn dsk hops nhip pre\n  assumes \"(dsn = 0) = (dsk = unk)\"\n  shows \"sqn rt dip \\<le> sqn (update rt rip (dsn, dsk, val, hops, nhip, pre)) dip\"", "lemma sqn_update_bigger [simp]:\n    fixes rt ip ip' dsn dsk flag hops nhip pre\n  assumes \"1 \\<le> hops\"\n    shows \"sqn rt ip \\<le> sqn (update rt ip' (dsn, dsk, flag, hops, nhip, pre)) ip\"", "lemma dhops_update [intro]:\n    fixes rt dsn dsk flag hops ip rip nhip pre\n  assumes ex: \"\\<forall>ip\\<in>kD rt. the (dhops rt ip) \\<ge> 1\"\n      and ip: \"(ip = rip \\<and> Suc 0 \\<le> hops) \\<or> (ip \\<noteq> rip \\<and> ip\\<in>kD rt)\"\n    shows \"Suc 0 \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)\"", "lemma update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"(update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = rt ip\"", "lemma nhop_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"nhop (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = nhop rt ip\"", "lemma dhops_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"dhops (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = dhops rt ip\"", "lemma sqn_update_same [simp]:\n  \"\\<And>rt ip dsn dsk flag hops nhip pre. sqn (rt(ip \\<mapsto> v)) ip = \\<pi>\\<^sub>2(v)\"", "lemma dhops_update_changed [simp]:\n    fixes rt dip osn hops nhip\n  assumes \"rt \\<noteq> update rt dip (osn, kno, val, hops, nhip, {})\"\n    shows \"the (dhops (update rt dip (osn, kno, val, hops, nhip, {})) dip) = hops\"", "lemma nhop_update_unk_val [simp]:\n  \"\\<And>rt dip ip dsn hops npre.\n   the (nhop (update rt dip (dsn, unk, val, hops, ip, npre)) dip) = ip\"", "lemma nhop_update_changed [simp]:\n    fixes rt dip dsn dsk flg hops sip\n  assumes \"update rt dip (dsn, dsk, flg, hops, sip, {}) \\<noteq> rt\"\n    shows \"the (nhop (update rt dip (dsn, dsk, flg, hops, sip, {})) dip) = sip\"", "lemma update_rt_split_asm:\n  \"\\<And>rt ip dsn dsk flag hops sip.\n   P (update rt ip (dsn, dsk, flag, hops, sip, {}))\n   =\n   (\\<not>(rt = update rt ip (dsn, dsk, flag, hops, sip, {}) \\<and> \\<not>P rt\n      \\<or> rt \\<noteq> update rt ip (dsn, dsk, flag, hops, sip, {})\n         \\<and> \\<not>P (update rt ip (dsn, dsk, flag, hops, sip, {}))))\"", "lemma sqn_update [simp]: \"\\<And>rt dip dsn flg hops sip.\n  rt \\<noteq> update rt dip (dsn, kno, flg, hops, sip, {})\n  \\<Longrightarrow> sqn (update rt dip (dsn, kno, flg, hops, sip, {})) dip = dsn\"", "lemma sqnf_update [simp]: \"\\<And>rt dip dsn dsk flg hops sip.\n  rt \\<noteq> update rt dip (dsn, dsk, flg, hops, sip, {})\n  \\<Longrightarrow> sqnf (update rt dip (dsn, dsk, flg, hops, sip, {})) dip = dsk\"", "lemma update_kno_dsn_greater_zero:\n  \"\\<And>rt dip ip dsn hops npre. 1 \\<le> dsn \\<Longrightarrow> 1 \\<le> (sqn (update rt dip (dsn, kno, val, hops, ip, npre)) dip)\"", "lemma proj3_update [simp]: \"\\<And>rt dip dsn dsk flg hops sip.\n  rt \\<noteq> update rt dip (dsn, dsk, flg, hops, sip, {})\n  \\<Longrightarrow> \\<pi>\\<^sub>3(the (update rt dip (dsn, dsk, flg, hops, sip, {}) dip)) = dsk\"", "lemma nhop_update_changed_kno_val [simp]: \"\\<And>rt ip dsn dsk hops nhip.\n  rt \\<noteq> update rt ip (dsn, kno, val, hops, nhip, {})\n   \\<Longrightarrow> the (nhop (update rt ip (dsn, kno, val, hops, nhip, {})) ip) = nhip\"", "lemma flag_update [simp]: \"\\<And>rt dip dsn flg hops sip.\n  rt \\<noteq> update rt dip (dsn, kno, flg, hops, sip, {})\n  \\<Longrightarrow> the (flag (update rt dip (dsn, kno, flg, hops, sip, {})) dip) = flg\"", "lemma the_flag_Some [dest!]:\n    fixes ip rt\n  assumes \"the (flag rt ip) = x\"\n      and \"ip \\<in> kD rt\"\n    shows \"flag rt ip = Some x\"", "lemma kD_update_unchanged [dest]:\n    fixes rt dip dsn dsk flag hops nhip pre\n  assumes \"rt = update rt dip (dsn, dsk, flag, hops, nhip, pre)\"\n    shows \"dip\\<in>kD(rt)\"", "lemma nhop_update [simp]: \"\\<And>rt dip dsn dsk flg hops sip.\n  rt \\<noteq> update rt dip (dsn, dsk, flg, hops, sip, {})\n  \\<Longrightarrow> the (nhop (update rt dip (dsn, dsk, flg, hops, sip, {})) dip) = sip\"", "lemma sqn_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"sqn (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqn rt ip\"", "lemma sqnf_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"sqnf (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqnf rt ip\"", "lemma vD_update_val [dest]:\n  \"\\<And>dip rt dip' dsn dsk hops nhip pre.\n   dip \\<in> vD(update rt dip' (dsn, dsk, val, hops, nhip, pre)) \\<Longrightarrow> (dip\\<in>vD(rt) \\<or> dip=dip')\"", "lemma proj3_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>3(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>3(the (rt dip))\"", "lemma proj5_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>5(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>5(the (rt dip))\"", "lemma proj6_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>6(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>6(the (rt dip))\"", "lemma proj7_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>7(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>7(the (rt dip))\"", "lemma invalidate_kD_inv [simp]:\n  \"\\<And>rt dests. kD (invalidate rt dests) = kD rt\"", "lemma invalidate_sqn:\n  fixes rt dip dests\n  assumes \"\\<forall>rsn. dests dip = Some rsn \\<longrightarrow> sqn rt dip \\<le> rsn\"\n  shows \"sqn rt dip \\<le> sqn (invalidate rt dests) dip\"", "lemma sqn_invalidate_in_dests [simp]:\n    fixes dests ipa rsn rt\n  assumes \"dests ipa = Some rsn\"\n      and \"ipa\\<in>kD(rt)\"\n    shows \"sqn (invalidate rt dests) ipa = rsn\"", "lemma dhops_invalidate [simp]:\n  \"\\<And>dip. the (dhops (invalidate rt dests) dip) = the (dhops rt dip)\"", "lemma sqnf_invalidate [simp]:\n  \"\\<And>dip. sqnf (invalidate (rt \\<xi>) (dests \\<xi>)) dip = sqnf (rt \\<xi>) dip\"", "lemma nhop_invalidate [simp]:\n  \"\\<And>dip. the (nhop (invalidate (rt \\<xi>) (dests \\<xi>)) dip) = the (nhop (rt \\<xi>) dip)\"", "lemma invalidate_other [simp]:\n    fixes rt dests dip\n  assumes \"dip\\<notin>dom(dests)\"\n    shows \"invalidate rt dests dip = rt dip\"", "lemma invalidate_none [simp]:\n    fixes rt dests dip\n  assumes \"dip\\<notin>kD(rt)\"\n    shows \"invalidate rt dests dip = None\"", "lemma vD_invalidate_vD_not_dests:\n  \"\\<And>dip rt dests. dip\\<in>vD(invalidate rt dests) \\<Longrightarrow> dip\\<in>vD(rt) \\<and> dests dip = None\"", "lemma sqn_invalidate_not_in_dests [simp]:\n  fixes dests dip rt\n  assumes \"dip\\<notin>dom(dests)\"\n  shows \"sqn (invalidate rt dests) dip = sqn rt dip\"", "lemma invalidate_changes:\n    fixes rt dests dip dsn dsk flag hops nhip pre\n  assumes \"invalidate rt dests dip = Some (dsn, dsk, flag, hops, nhip, pre)\"\n    shows \"  dsn = (case dests dip of None \\<Rightarrow> \\<pi>\\<^sub>2(the (rt dip)) | Some rsn \\<Rightarrow> rsn)\n           \\<and> dsk = \\<pi>\\<^sub>3(the (rt dip))\n           \\<and> flag = (if dests dip = None then \\<pi>\\<^sub>4(the (rt dip)) else inv)\n           \\<and> hops = \\<pi>\\<^sub>5(the (rt dip))\n           \\<and> nhip = \\<pi>\\<^sub>6(the (rt dip))\n           \\<and> pre = \\<pi>\\<^sub>7(the (rt dip))\"", "lemma proj3_inv: \"\\<And>dip rt dests. dip\\<in>kD (rt)\n                      \\<Longrightarrow> \\<pi>\\<^sub>3(the (invalidate rt dests dip)) = \\<pi>\\<^sub>3(the (rt dip))\"", "lemma dests_iD_invalidate [simp]:\n  assumes \"dests ip = Some rsn\"\n      and \"ip\\<in>kD(rt)\"\n    shows \"ip\\<in>iD(invalidate rt dests)\"", "lemma qD_add [simp]:\n  fixes d dip store\n  shows \"qD(add d dip store) = insert dip (qD store)\""], "translations": [["", "lemma less_than_inc [simp]: \"x \\<le> inc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> inc x", "unfolding inc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (if x = 0 then x else x + 1)", "by simp"], ["", "lemma inc_minus_suc_0 [simp]:\n  \"inc x - Suc 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inc x - Suc 0 = x", "unfolding inc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = 0 then x else x + 1) - Suc 0 = x", "by simp"], ["", "lemma inc_never_one' [simp, intro]: \"inc x \\<noteq> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inc x \\<noteq> Suc 0", "unfolding inc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = 0 then x else x + 1) \\<noteq> Suc 0", "by simp"], ["", "lemma inc_never_one [simp, intro]: \"inc x \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inc x \\<noteq> 1", "by simp"], ["", "subsection \"Modelling Routes\""], ["", "text \\<open>\n  A route is a 6-tuple, @{term \"(dsn, dsk, flag, hops, nhip, pre)\"} where\n  @{term dsn} is the `destination sequence number', @{term dsk} is the\n  `destination-sequence-number status', @{term flag} is the route status,\n  @{term hops} is the number of hops to the destination, @{term nhip} is the\n  next hop toward the destination, and @{term pre} is the set of `precursor nodes'--those\n  interested in hearing about changes to the route.\n\\<close>"], ["", "type_synonym r = \"sqn \\<times> k \\<times> f \\<times> nat \\<times> ip \\<times> ip set\""], ["", "definition proj2 :: \"r \\<Rightarrow> sqn\" (\"\\<pi>\\<^sub>2\")\n  where \"\\<pi>\\<^sub>2 \\<equiv> \\<lambda>(dsn, _, _, _, _, _). dsn\""], ["", "definition proj3 :: \"r \\<Rightarrow> k\" (\"\\<pi>\\<^sub>3\")\n  where \"\\<pi>\\<^sub>3 \\<equiv> \\<lambda>(_, dsk, _, _, _, _). dsk\""], ["", "definition proj4 :: \"r \\<Rightarrow> f\" (\"\\<pi>\\<^sub>4\")\n  where \"\\<pi>\\<^sub>4 \\<equiv> \\<lambda>(_, _, flag, _, _, _). flag\""], ["", "definition proj5 :: \"r \\<Rightarrow> nat\" (\"\\<pi>\\<^sub>5\")\n  where \"\\<pi>\\<^sub>5 \\<equiv> \\<lambda>(_, _, _, hops, _, _). hops\""], ["", "definition proj6 :: \"r \\<Rightarrow> ip\" (\"\\<pi>\\<^sub>6\")\n  where \"\\<pi>\\<^sub>6 \\<equiv> \\<lambda>(_, _, _, _, nhip, _). nhip\""], ["", "definition proj7 :: \"r \\<Rightarrow> ip set\" (\"\\<pi>\\<^sub>7\")\n  where \"\\<pi>\\<^sub>7 \\<equiv> \\<lambda>(_, _, _, _, _, pre). pre\""], ["", "lemma projs [simp]:\n  \"\\<pi>\\<^sub>2(dsn, dsk, flag, hops, nhip, pre) = dsn\"\n  \"\\<pi>\\<^sub>3(dsn, dsk, flag, hops, nhip, pre) = dsk\"\n  \"\\<pi>\\<^sub>4(dsn, dsk, flag, hops, nhip, pre) = flag\"\n  \"\\<pi>\\<^sub>5(dsn, dsk, flag, hops, nhip, pre) = hops\"\n  \"\\<pi>\\<^sub>6(dsn, dsk, flag, hops, nhip, pre) = nhip\"\n  \"\\<pi>\\<^sub>7(dsn, dsk, flag, hops, nhip, pre) = pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre) = dsn &&&\n     \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, pre) = dsk &&&\n     \\<pi>\\<^sub>4 (dsn, dsk, flag, hops, nhip, pre) = flag) &&&\n    \\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre) = hops &&&\n    \\<pi>\\<^sub>6 (dsn, dsk, flag, hops, nhip, pre) = nhip &&&\n    \\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, pre) = pre", "by (clarsimp simp: proj2_def proj3_def proj4_def\n                     proj5_def proj6_def proj7_def)+"], ["", "lemma proj3_pred [intro]: \"\\<lbrakk> P kno; P unk \\<rbrakk> \\<Longrightarrow> P (\\<pi>\\<^sub>3 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P kno; P unk\\<rbrakk> \\<Longrightarrow> P (\\<pi>\\<^sub>3 x)", "by (rule k.induct)"], ["", "lemma proj4_pred [intro]: \"\\<lbrakk> P val; P inv \\<rbrakk> \\<Longrightarrow> P (\\<pi>\\<^sub>4 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P val; P Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (\\<pi>\\<^sub>4 x)", "by (rule f.induct)"], ["", "lemma proj6_pair_snd [simp]:\n  fixes dsn' r\n  shows \"\\<pi>\\<^sub>6 (dsn', snd (r)) = \\<pi>\\<^sub>6(r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>6 (dsn', snd r) = \\<pi>\\<^sub>6 r", "by (cases r) simp"], ["", "subsection \"Routing Tables\""], ["", "text \\<open>Routing tables map ip addresses to route entries.\\<close>"], ["", "type_synonym rt = \"ip \\<rightharpoonup> r\""], ["", "syntax\n  \"_Sigma_route\" :: \"rt \\<Rightarrow> ip \\<rightharpoonup> r\"  (\"\\<sigma>\\<^bsub>route\\<^esub>'(_, _')\")"], ["", "translations\n \"\\<sigma>\\<^bsub>route\\<^esub>(rt, dip)\" => \"rt dip\""], ["", "definition sqn :: \"rt \\<Rightarrow> ip \\<Rightarrow> sqn\"\n  where \"sqn rt dip \\<equiv> case \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) of Some r \\<Rightarrow> \\<pi>\\<^sub>2(r) | None \\<Rightarrow> 0\""], ["", "definition sqnf :: \"rt \\<Rightarrow> ip \\<Rightarrow> k\"\n  where \"sqnf rt dip \\<equiv> case \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) of Some r \\<Rightarrow> \\<pi>\\<^sub>3(r) | None \\<Rightarrow> unk\""], ["", "abbreviation flag :: \"rt \\<Rightarrow> ip \\<rightharpoonup> f\"\n  where \"flag rt dip \\<equiv> map_option \\<pi>\\<^sub>4 (\\<sigma>\\<^bsub>route\\<^esub>(rt, dip))\""], ["", "abbreviation dhops :: \"rt \\<Rightarrow> ip \\<rightharpoonup> nat\"\n   where \"dhops rt dip \\<equiv> map_option \\<pi>\\<^sub>5 (\\<sigma>\\<^bsub>route\\<^esub>(rt, dip))\""], ["", "abbreviation nhop :: \"rt \\<Rightarrow> ip \\<rightharpoonup> ip\"\n   where \"nhop rt dip \\<equiv> map_option \\<pi>\\<^sub>6 (\\<sigma>\\<^bsub>route\\<^esub>(rt, dip))\""], ["", "abbreviation precs :: \"rt \\<Rightarrow> ip \\<rightharpoonup> ip set\"\n   where \"precs rt dip \\<equiv> map_option \\<pi>\\<^sub>7 (\\<sigma>\\<^bsub>route\\<^esub>(rt, dip))\""], ["", "definition vD :: \"rt \\<Rightarrow> ip set\"\n  where \"vD rt \\<equiv> {dip. flag rt dip = Some val}\""], ["", "definition iD :: \"rt \\<Rightarrow> ip set\"\n  where \"iD rt \\<equiv> {dip. flag rt dip = Some inv}\""], ["", "definition kD :: \"rt \\<Rightarrow> ip set\"\n  where \"kD rt \\<equiv> {dip. rt dip \\<noteq> None}\""], ["", "lemma kD_is_vD_and_iD: \"kD rt = vD rt \\<union> iD rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kD rt = vD rt \\<union> iD rt", "unfolding kD_def vD_def iD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {dip. rt dip \\<noteq> None} =\n    {dip. flag rt dip = Some val} \\<union>\n    {dip. flag rt dip = Some Aodv_Basic.inv}", "by auto"], ["", "lemma vD_iD_gives_kD [simp]:\n   \"\\<And>ip rt. ip \\<in> vD rt \\<Longrightarrow> ip \\<in> kD rt\"\n   \"\\<And>ip rt. ip \\<in> iD rt \\<Longrightarrow> ip \\<in> kD rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ip rt. ip \\<in> vD rt \\<Longrightarrow> ip \\<in> kD rt) &&&\n    (\\<And>ip rt. ip \\<in> iD rt \\<Longrightarrow> ip \\<in> kD rt)", "unfolding kD_is_vD_and_iD"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ip rt.\n        ip \\<in> vD rt \\<Longrightarrow> ip \\<in> vD rt \\<union> iD rt) &&&\n    (\\<And>ip rt.\n        ip \\<in> iD rt \\<Longrightarrow> ip \\<in> vD rt \\<union> iD rt)", "by simp_all"], ["", "lemma kD_Some [dest]:\n    fixes dip rt\n  assumes \"dip \\<in> kD rt\"\n    shows \"\\<exists>dsn dsk flag hops nhip pre.\n           \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = Some (dsn, dsk, flag, hops, nhip, pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk flag hops nhip pre.\n       rt dip = Some (dsn, dsk, flag, hops, nhip, pre)", "using assms"], ["proof (prove)\nusing this:\n  dip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk flag hops nhip pre.\n       rt dip = Some (dsn, dsk, flag, hops, nhip, pre)", "unfolding kD_def"], ["proof (prove)\nusing this:\n  dip \\<in> {dip. rt dip \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk flag hops nhip pre.\n       rt dip = Some (dsn, dsk, flag, hops, nhip, pre)", "by simp"], ["", "lemma kD_None [dest]:\n    fixes dip rt\n  assumes \"dip \\<notin> kD rt\"\n    shows \"\\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rt dip = None", "using assms"], ["proof (prove)\nusing this:\n  dip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. rt dip = None", "unfolding kD_def"], ["proof (prove)\nusing this:\n  dip \\<notin> {dip. rt dip \\<noteq> None}\n\ngoal (1 subgoal):\n 1. rt dip = None", "by (metis (mono_tags) mem_Collect_eq)"], ["", "lemma vD_Some [dest]:\n    fixes dip rt\n  assumes \"dip \\<in> vD rt\"\n    shows \"\\<exists>dsn dsk hops nhip pre.\n           \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = Some (dsn, dsk, val, hops, nhip, pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk hops nhip pre.\n       rt dip = Some (dsn, dsk, val, hops, nhip, pre)", "using assms"], ["proof (prove)\nusing this:\n  dip \\<in> vD rt\n\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk hops nhip pre.\n       rt dip = Some (dsn, dsk, val, hops, nhip, pre)", "unfolding vD_def"], ["proof (prove)\nusing this:\n  dip \\<in> {dip. flag rt dip = Some val}\n\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk hops nhip pre.\n       rt dip = Some (dsn, dsk, val, hops, nhip, pre)", "by simp"], ["", "lemma vD_empty [simp]: \"vD Map.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vD Map.empty = {}", "unfolding vD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {dip. map_option \\<pi>\\<^sub>4 None = Some val} = {}", "by simp"], ["", "lemma iD_Some [dest]:\n    fixes dip rt\n  assumes \"dip \\<in> iD rt\"\n    shows \"\\<exists>dsn dsk hops nhip pre.\n           \\<sigma>\\<^bsub>route\\<^esub>(rt, dip) = Some (dsn, dsk, inv, hops, nhip, pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk hops nhip pre.\n       rt dip = Some (dsn, dsk, Aodv_Basic.inv, hops, nhip, pre)", "using assms"], ["proof (prove)\nusing this:\n  dip \\<in> iD rt\n\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk hops nhip pre.\n       rt dip = Some (dsn, dsk, Aodv_Basic.inv, hops, nhip, pre)", "unfolding iD_def"], ["proof (prove)\nusing this:\n  dip \\<in> {dip. flag rt dip = Some Aodv_Basic.inv}\n\ngoal (1 subgoal):\n 1. \\<exists>dsn dsk hops nhip pre.\n       rt dip = Some (dsn, dsk, Aodv_Basic.inv, hops, nhip, pre)", "by simp"], ["", "lemma val_is_vD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"the (flag rt ip) = val\"\n    shows \"ip\\<in>vD(rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip \\<in> vD rt", "using assms"], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  the (flag rt ip) = val\n\ngoal (1 subgoal):\n 1. ip \\<in> vD rt", "unfolding vD_def"], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  the (flag rt ip) = val\n\ngoal (1 subgoal):\n 1. ip \\<in> {dip. flag rt dip = Some val}", "by auto"], ["", "lemma inv_is_iD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"the (flag rt ip) = inv\"\n    shows \"ip\\<in>iD(rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", "using assms"], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  the (flag rt ip) = Aodv_Basic.inv\n\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", "unfolding iD_def"], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  the (flag rt ip) = Aodv_Basic.inv\n\ngoal (1 subgoal):\n 1. ip \\<in> {dip. flag rt dip = Some Aodv_Basic.inv}", "by auto"], ["", "lemma iD_flag_is_inv [elim, simp]:\n    fixes ip rt\n  assumes \"ip\\<in>iD(rt)\"\n    shows \"the (flag rt ip) = inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (flag rt ip) = Aodv_Basic.inv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the (flag rt ip) = Aodv_Basic.inv", "from \\<open>ip\\<in>iD(rt)\\<close>"], ["proof (chain)\npicking this:\n  ip \\<in> iD rt", "have \"ip\\<in>kD(rt)\""], ["proof (prove)\nusing this:\n  ip \\<in> iD rt\n\ngoal (1 subgoal):\n 1. ip \\<in> kD rt", "by auto"], ["proof (state)\nthis:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. the (flag rt ip) = Aodv_Basic.inv", "with assms"], ["proof (chain)\npicking this:\n  ip \\<in> iD rt\n  ip \\<in> kD rt", "show ?thesis"], ["proof (prove)\nusing this:\n  ip \\<in> iD rt\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. the (flag rt ip) = Aodv_Basic.inv", "unfolding iD_def"], ["proof (prove)\nusing this:\n  ip \\<in> {dip. flag rt dip = Some Aodv_Basic.inv}\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. the (flag rt ip) = Aodv_Basic.inv", "by auto"], ["proof (state)\nthis:\n  the (flag rt ip) = Aodv_Basic.inv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kD_but_not_vD_is_iD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"ip\\<notin>vD(rt)\"\n    shows \"ip\\<in>iD(rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", "from \\<open>ip\\<in>kD(rt)\\<close>"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "obtain dsn dsk f hops nhop pre\n      where rtip: \"rt ip = Some (dsn, dsk, f, hops, nhop, pre)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk f hops nhop pre.\n        rt ip = Some (dsn, dsk, f, hops, nhop, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, f, hops, nhop, pre)\n\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", "from \\<open>ip\\<notin>vD(rt)\\<close>"], ["proof (chain)\npicking this:\n  ip \\<notin> vD rt", "have \"f \\<noteq> val\""], ["proof (prove)\nusing this:\n  ip \\<notin> vD rt\n\ngoal (1 subgoal):\n 1. f \\<noteq> val", "proof (rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. f = val \\<Longrightarrow> ip \\<in> vD rt", "assume \"f = val\""], ["proof (state)\nthis:\n  f = val\n\ngoal (1 subgoal):\n 1. f = val \\<Longrightarrow> ip \\<in> vD rt", "with rtip"], ["proof (chain)\npicking this:\n  rt ip = Some (dsn, dsk, f, hops, nhop, pre)\n  f = val", "have \"the (flag rt ip) = val\""], ["proof (prove)\nusing this:\n  rt ip = Some (dsn, dsk, f, hops, nhop, pre)\n  f = val\n\ngoal (1 subgoal):\n 1. the (flag rt ip) = val", "by simp"], ["proof (state)\nthis:\n  the (flag rt ip) = val\n\ngoal (1 subgoal):\n 1. f = val \\<Longrightarrow> ip \\<in> vD rt", "with \\<open>ip\\<in>kD(rt)\\<close>"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt\n  the (flag rt ip) = val", "show \"ip\\<in>vD(rt)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  the (flag rt ip) = val\n\ngoal (1 subgoal):\n 1. ip \\<in> vD rt", ".."], ["proof (state)\nthis:\n  ip \\<in> vD rt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<noteq> val\n\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", "with rtip"], ["proof (chain)\npicking this:\n  rt ip = Some (dsn, dsk, f, hops, nhop, pre)\n  f \\<noteq> val", "have \"the (flag rt ip)= inv\""], ["proof (prove)\nusing this:\n  rt ip = Some (dsn, dsk, f, hops, nhop, pre)\n  f \\<noteq> val\n\ngoal (1 subgoal):\n 1. the (flag rt ip) = Aodv_Basic.inv", "by simp"], ["proof (state)\nthis:\n  the (flag rt ip) = Aodv_Basic.inv\n\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", "with \\<open>ip\\<in>kD(rt)\\<close>"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt\n  the (flag rt ip) = Aodv_Basic.inv", "show \"ip\\<in>iD(rt)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  the (flag rt ip) = Aodv_Basic.inv\n\ngoal (1 subgoal):\n 1. ip \\<in> iD rt", ".."], ["proof (state)\nthis:\n  ip \\<in> iD rt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vD_or_iD [elim]:\n    fixes ip rt\n  assumes \"ip\\<in>kD(rt)\"\n      and \"ip\\<in>vD(rt) \\<Longrightarrow> P rt ip\"\n      and \"ip\\<in>iD(rt) \\<Longrightarrow> P rt ip\"\n    shows \"P rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P rt ip", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P rt ip", "from \\<open>ip\\<in>kD(rt)\\<close>"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "have \"ip\\<in>vD(rt) \\<union> iD(rt)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. ip \\<in> vD rt \\<union> iD rt", "by (simp add: kD_is_vD_and_iD)"], ["proof (state)\nthis:\n  ip \\<in> vD rt \\<union> iD rt\n\ngoal (1 subgoal):\n 1. P rt ip", "thus ?thesis"], ["proof (prove)\nusing this:\n  ip \\<in> vD rt \\<union> iD rt\n\ngoal (1 subgoal):\n 1. P rt ip", "by (auto elim: assms(2-3))"], ["proof (state)\nthis:\n  P rt ip\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj5_eq_dhops: \"\\<And>dip rt. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>5(the (rt dip)) = the (dhops rt dip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>5 (the (rt dip)) = the (dhops rt dip)", "unfolding sqn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>5 (the (rt dip)) = the (dhops rt dip)", "by (drule kD_Some) clarsimp"], ["", "lemma proj4_eq_flag: \"\\<And>dip rt. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>4(the (rt dip)) = the (flag rt dip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>4 (the (rt dip)) = the (flag rt dip)", "unfolding sqn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>4 (the (rt dip)) = the (flag rt dip)", "by (drule kD_Some) clarsimp"], ["", "lemma proj2_eq_sqn: \"\\<And>dip rt. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>2(the (rt dip)) = sqn rt dip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>2 (the (rt dip)) = sqn rt dip", "unfolding sqn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>2 (the (rt dip)) =\n       (case rt dip of None \\<Rightarrow> 0\n        | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)", "by (drule kD_Some) clarsimp"], ["", "lemma kD_sqnf_is_proj3 [simp]:\n  \"\\<And>ip rt. ip\\<in>kD(rt) \\<Longrightarrow> sqnf rt ip = \\<pi>\\<^sub>3(the (rt ip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip rt.\n       ip \\<in> kD rt \\<Longrightarrow>\n       sqnf rt ip = \\<pi>\\<^sub>3 (the (rt ip))", "unfolding sqnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip rt.\n       ip \\<in> kD rt \\<Longrightarrow>\n       (case rt ip of None \\<Rightarrow> unk\n        | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r) =\n       \\<pi>\\<^sub>3 (the (rt ip))", "by auto"], ["", "lemma vD_flag_val [simp]:\n  \"\\<And>dip rt. dip \\<in> vD (rt) \\<Longrightarrow> the (flag rt dip) = val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt. dip \\<in> vD rt \\<Longrightarrow> the (flag rt dip) = val", "unfolding vD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt.\n       dip \\<in> {dip. flag rt dip = Some val} \\<Longrightarrow>\n       the (flag rt dip) = val", "by clarsimp"], ["", "lemma kD_update [simp]:\n  \"\\<And>rt nip v. kD (rt(nip \\<mapsto> v)) = insert nip (kD rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt nip v. kD (rt(nip \\<mapsto> v)) = insert nip (kD rt)", "unfolding kD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt nip v.\n       {dip. (rt(nip \\<mapsto> v)) dip \\<noteq> None} =\n       insert nip {dip. rt dip \\<noteq> None}", "by auto"], ["", "lemma kD_empty [simp]: \"kD Map.empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kD Map.empty = {}", "unfolding kD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {dip. None \\<noteq> None} = {}", "by simp"], ["", "lemma ip_equal_or_known [elim]:\n  fixes rt ip ip'\n  assumes \"ip = ip' \\<or> ip\\<in>kD(rt)\"\n      and \"ip = ip' \\<Longrightarrow> P rt ip ip'\"\n      and \"\\<lbrakk> ip \\<noteq> ip'; ip\\<in>kD(rt)\\<rbrakk> \\<Longrightarrow> P rt ip ip'\"\n    shows \"P rt ip ip'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P rt ip ip'", "using assms"], ["proof (prove)\nusing this:\n  ip = ip' \\<or> ip \\<in> kD rt\n  ip = ip' \\<Longrightarrow> P rt ip ip'\n  \\<lbrakk>ip \\<noteq> ip'; ip \\<in> kD rt\\<rbrakk>\n  \\<Longrightarrow> P rt ip ip'\n\ngoal (1 subgoal):\n 1. P rt ip ip'", "by auto"], ["", "subsection \"Updating Routing Tables\""], ["", "text \\<open>Routing table entries are modified through explicit functions.\n      The properties of these functions are important in invariant proofs.\\<close>"], ["", "subsubsection \"Updating Precursor Lists\""], ["", "definition addpre :: \"r \\<Rightarrow> ip set \\<Rightarrow> r\"\n  where \"addpre r npre \\<equiv> let (dsn, dsk, flag, hops, nhip, pre) = r in\n                          (dsn, dsk, flag, hops, nhip, pre \\<union> npre)\""], ["", "lemma proj2_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>2(addpre v pre) = \\<pi>\\<^sub>2(v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>2 (addpre v pre) = \\<pi>\\<^sub>2 v", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>2\n     (let (dsn, dsk, flag, hops, nhip, prea) = v\n      in (dsn, dsk, flag, hops, nhip, prea \\<union> pre)) =\n    \\<pi>\\<^sub>2 v", "by (cases v) simp"], ["", "lemma proj3_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>3(addpre v pre) = \\<pi>\\<^sub>3(v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>3 (addpre v pre) = \\<pi>\\<^sub>3 v", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>3\n     (let (dsn, dsk, flag, hops, nhip, prea) = v\n      in (dsn, dsk, flag, hops, nhip, prea \\<union> pre)) =\n    \\<pi>\\<^sub>3 v", "by (cases v) simp"], ["", "lemma proj4_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>4(addpre v pre) = \\<pi>\\<^sub>4(v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>4 (addpre v pre) = \\<pi>\\<^sub>4 v", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>4\n     (let (dsn, dsk, flag, hops, nhip, prea) = v\n      in (dsn, dsk, flag, hops, nhip, prea \\<union> pre)) =\n    \\<pi>\\<^sub>4 v", "by (cases v) simp"], ["", "lemma proj5_addpre:\n  fixes v pre\n  shows \"\\<pi>\\<^sub>5(addpre v pre) = \\<pi>\\<^sub>5(v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>5 (addpre v pre) = \\<pi>\\<^sub>5 v", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>5\n     (let (dsn, dsk, flag, hops, nhip, prea) = v\n      in (dsn, dsk, flag, hops, nhip, prea \\<union> pre)) =\n    \\<pi>\\<^sub>5 v", "by (cases v) simp"], ["", "lemma proj6_addpre:\n  fixes dsn dsk flag hops nhip pre npre\n  shows \"\\<pi>\\<^sub>6(addpre v npre) = \\<pi>\\<^sub>6(v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>6 (addpre v npre) = \\<pi>\\<^sub>6 v", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>6\n     (let (dsn, dsk, flag, hops, nhip, pre) = v\n      in (dsn, dsk, flag, hops, nhip, pre \\<union> npre)) =\n    \\<pi>\\<^sub>6 v", "by (cases v) simp"], ["", "lemma proj7_addpre:\n  fixes dsn dsk flag hops nhip pre npre\n  shows \"\\<pi>\\<^sub>7(addpre v npre) = \\<pi>\\<^sub>7(v) \\<union> npre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>7 (addpre v npre) = \\<pi>\\<^sub>7 v \\<union> npre", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>7\n     (let (dsn, dsk, flag, hops, nhip, pre) = v\n      in (dsn, dsk, flag, hops, nhip, pre \\<union> npre)) =\n    \\<pi>\\<^sub>7 v \\<union> npre", "by (cases v) simp"], ["", "lemma addpre_empty: \"addpre r {} = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addpre r {} = r", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (dsn, dsk, flag, hops, nhip, pre) = r\n     in (dsn, dsk, flag, hops, nhip, pre \\<union> {})) =\n    r", "by simp"], ["", "lemma addpre_r:\n  \"addpre (dsn, dsk, fl, hops, nhip, pre) npre = (dsn, dsk, fl, hops, nhip, pre \\<union> npre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. addpre (dsn, dsk, fl, hops, nhip, pre) npre =\n    (dsn, dsk, fl, hops, nhip, pre \\<union> npre)", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (dsn, dsk, flag, hops, nhip, pre) = (dsn, dsk, fl, hops, nhip, pre)\n     in (dsn, dsk, flag, hops, nhip, pre \\<union> npre)) =\n    (dsn, dsk, fl, hops, nhip, pre \\<union> npre)", "by simp"], ["", "lemmas addpre_simps [simp] = proj2_addpre proj3_addpre proj4_addpre proj5_addpre\n                             proj6_addpre proj7_addpre addpre_empty addpre_r"], ["", "definition addpreRT :: \"rt \\<Rightarrow> ip \\<Rightarrow> ip set \\<rightharpoonup> rt\"\n  where \"addpreRT rt dip npre \\<equiv>\n           map_option (\\<lambda>s. rt (dip \\<mapsto> addpre s npre)) (\\<sigma>\\<^bsub>route\\<^esub>(rt, dip))\""], ["", "lemma snd_addpre [simp]:\n  \"\\<And>dsn dsn' v pre. (dsn, snd(addpre (dsn', v) pre)) = addpre (dsn, v) pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dsn dsn' v pre.\n       (dsn, snd (addpre (dsn', v) pre)) = addpre (dsn, v) pre", "unfolding addpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dsn dsn' v pre.\n       (dsn,\n        snd (let (dsn, dsk, flag, hops, nhip, prea) = (dsn', v)\n             in (dsn, dsk, flag, hops, nhip, prea \\<union> pre))) =\n       (let (dsn, dsk, flag, hops, nhip, prea) = (dsn, v)\n        in (dsn, dsk, flag, hops, nhip, prea \\<union> pre))", "by clarsimp"], ["", "lemma proj2_addpreRT [simp]:\n    fixes ip rt ip' npre\n  assumes \"ip\\<in>kD rt\"\n      and \"ip'\\<in>kD rt\"\n    shows \"\\<pi>\\<^sub>2(the (the (addpreRT rt ip' npre) ip)) = \\<pi>\\<^sub>2(the (rt ip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>2 (the (the (addpreRT rt ip' npre) ip)) =\n    \\<pi>\\<^sub>2 (the (rt ip))", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip' = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>2 (the (the (addpreRT rt ip' npre) ip)) =\n    \\<pi>\\<^sub>2 (the (rt ip))", "unfolding addpreRT_def"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip' = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>2\n     (the (the (map_option (\\<lambda>s. rt(ip' \\<mapsto> addpre s npre))\n                 (rt ip'))\n            ip)) =\n    \\<pi>\\<^sub>2 (the (rt ip))", "by clarsimp"], ["", "lemma proj3_addpreRT [simp]:\n    fixes ip rt ip' npre\n  assumes \"ip\\<in>kD rt\"\n      and \"ip'\\<in>kD rt\"\n    shows \"\\<pi>\\<^sub>3(the (the (addpreRT rt ip' npre) ip)) = \\<pi>\\<^sub>3(the (rt ip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>3 (the (the (addpreRT rt ip' npre) ip)) =\n    \\<pi>\\<^sub>3 (the (rt ip))", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip' = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>3 (the (the (addpreRT rt ip' npre) ip)) =\n    \\<pi>\\<^sub>3 (the (rt ip))", "unfolding addpreRT_def"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip' = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>3\n     (the (the (map_option (\\<lambda>s. rt(ip' \\<mapsto> addpre s npre))\n                 (rt ip'))\n            ip)) =\n    \\<pi>\\<^sub>3 (the (rt ip))", "by clarsimp"], ["", "lemma proj5_addpreRT [simp]:\n  \"\\<And>rt dip ip npre. dip\\<in>kD(rt) \\<Longrightarrow> \\<pi>\\<^sub>5(the (the (addpreRT rt dip npre) ip)) = \\<pi>\\<^sub>5(the (rt ip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip ip npre.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>5 (the (the (addpreRT rt dip npre) ip)) =\n       \\<pi>\\<^sub>5 (the (rt ip))", "unfolding addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip ip npre.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>5\n        (the (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s npre))\n                    (rt dip))\n               ip)) =\n       \\<pi>\\<^sub>5 (the (rt ip))", "by auto"], ["", "lemma flag_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"flag (the (addpreRT rt dip pre)) ip = flag rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flag (the (addpreRT rt dip pre)) ip = flag rt ip", "unfolding addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. flag\n     (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n            (rt dip)))\n     ip =\n    flag rt ip", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. flag\n     (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n            (rt dip)))\n     ip =\n    flag rt ip", "by (clarsimp)"], ["", "lemma kD_addpreRT [simp]:\n  fixes rt dip npre\n  assumes \"dip \\<in> kD rt\"\n  shows \"kD (the (addpreRT rt dip npre)) = kD rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kD (the (addpreRT rt dip npre)) = kD rt", "unfolding kD_def addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {dipa.\n     the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s npre)) (rt dip))\n      dipa \\<noteq>\n     None} =\n    {dip. rt dip \\<noteq> None}", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. {dipa.\n     the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s npre)) (rt dip))\n      dipa \\<noteq>\n     None} =\n    {dip. rt dip \\<noteq> None}", "by clarsimp blast"], ["", "lemma vD_addpreRT [simp]:\n  fixes rt dip npre\n  assumes \"dip \\<in> kD rt\"\n  shows \"vD (the (addpreRT rt dip npre)) = vD rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vD (the (addpreRT rt dip npre)) = vD rt", "unfolding vD_def addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {dipa.\n     flag\n      (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s npre))\n             (rt dip)))\n      dipa =\n     Some val} =\n    {dip. flag rt dip = Some val}", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. {dipa.\n     flag\n      (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s npre))\n             (rt dip)))\n      dipa =\n     Some val} =\n    {dip. flag rt dip = Some val}", "by clarsimp auto"], ["", "lemma iD_addpreRT [simp]:\n  fixes rt dip npre\n  assumes \"dip \\<in> kD rt\"\n  shows \"iD (the (addpreRT rt dip npre)) = iD rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iD (the (addpreRT rt dip npre)) = iD rt", "unfolding iD_def addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {dipa.\n     flag\n      (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s npre))\n             (rt dip)))\n      dipa =\n     Some Aodv_Basic.inv} =\n    {dip. flag rt dip = Some Aodv_Basic.inv}", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. {dipa.\n     flag\n      (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s npre))\n             (rt dip)))\n      dipa =\n     Some Aodv_Basic.inv} =\n    {dip. flag rt dip = Some Aodv_Basic.inv}", "by clarsimp auto"], ["", "lemma nhop_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"nhop (the (addpreRT rt dip pre)) ip = nhop rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nhop (the (addpreRT rt dip pre)) ip = nhop rt ip", "unfolding sqn_def addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nhop\n     (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n            (rt dip)))\n     ip =\n    nhop rt ip", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. nhop\n     (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n            (rt dip)))\n     ip =\n    nhop rt ip", "by (clarsimp)"], ["", "lemma sqn_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"sqn (the (addpreRT rt dip pre)) ip = sqn rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn (the (addpreRT rt dip pre)) ip = sqn rt ip", "unfolding sqn_def addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n                (rt dip))\n           ip of\n     None \\<Rightarrow> 0 | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    (case rt ip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n                (rt dip))\n           ip of\n     None \\<Rightarrow> 0 | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    (case rt ip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)", "by (clarsimp)"], ["", "lemma dhops_addpreRT [simp]:\n    fixes rt pre ip dip\n  assumes \"dip \\<in> kD rt\"\n    shows \"dhops (the (addpreRT rt dip pre)) ip = dhops rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dhops (the (addpreRT rt dip pre)) ip = dhops rt ip", "unfolding addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dhops\n     (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n            (rt dip)))\n     ip =\n    dhops rt ip", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. dhops\n     (the (map_option (\\<lambda>s. rt(dip \\<mapsto> addpre s pre))\n            (rt dip)))\n     ip =\n    dhops rt ip", "by (clarsimp)"], ["", "lemma sqnf_addpreRT [simp]:\n  \"\\<And>ip dip. ip\\<in>kD(rt \\<xi>) \\<Longrightarrow> sqnf (the (addpreRT (rt \\<xi>) ip npre)) dip = sqnf (rt \\<xi>) dip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip dip.\n       ip \\<in> kD (rt \\<xi>) \\<Longrightarrow>\n       sqnf (the (addpreRT (rt \\<xi>) ip npre)) dip = sqnf (rt \\<xi>) dip", "unfolding sqnf_def addpreRT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip dip.\n       ip \\<in> kD (rt \\<xi>) \\<Longrightarrow>\n       (case the (map_option\n                   (\\<lambda>s. rt \\<xi>(ip \\<mapsto> addpre s npre))\n                   (rt \\<xi> ip))\n              dip of\n        None \\<Rightarrow> unk | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r) =\n       (case rt \\<xi> dip of None \\<Rightarrow> unk\n        | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r)", "by auto"], ["", "subsubsection \"Updating route entries\""], ["", "lemma in_kD_case [simp]:\n    fixes dip rt\n  assumes \"dip \\<in> kD(rt)\"\n    shows \"(case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) = es (the (rt dip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) =\n    es (the (rt dip))", "using assms [THEN kD_Some]"], ["proof (prove)\nusing this:\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) =\n    es (the (rt dip))", "by auto"], ["", "lemma not_in_kD_case [simp]:\n    fixes dip rt\n  assumes \"dip \\<notin> kD(rt)\"\n    shows \"(case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) = en\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) = en", "using assms [THEN kD_None]"], ["proof (prove)\nusing this:\n  rt dip = None\n\ngoal (1 subgoal):\n 1. (case rt dip of None \\<Rightarrow> en | Some r \\<Rightarrow> es r) = en", "by auto"], ["", "lemma rt_Some_sqn [dest]:\n    fixes rt and ip dsn dsk flag hops nhip pre\n  assumes \"rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\"\n    shows \"sqn rt ip = dsn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn rt ip = dsn", "unfolding sqn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    dsn", "using assms"], ["proof (prove)\nusing this:\n  rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    dsn", "by simp"], ["", "lemma not_kD_sqn [simp]:\n    fixes dip rt\n  assumes \"dip \\<notin> kD(rt)\"\n    shows \"sqn rt dip = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn rt dip = 0", "using assms"], ["proof (prove)\nusing this:\n  dip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. sqn rt dip = 0", "unfolding sqn_def"], ["proof (prove)\nusing this:\n  dip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. (case rt dip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    0", "by simp"], ["", "definition update_arg_wf :: \"r \\<Rightarrow> bool\"\nwhere \"update_arg_wf r \\<equiv> \\<pi>\\<^sub>4(r) = val \\<and>\n                         (\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk) \\<and>\n                         (\\<pi>\\<^sub>3(r) = unk \\<longrightarrow> \\<pi>\\<^sub>5(r) = 1)\""], ["", "lemma update_arg_wf_gives_cases:\n  \"\\<And>r. update_arg_wf r \\<Longrightarrow> (\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       update_arg_wf r \\<Longrightarrow>\n       (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)", "unfolding update_arg_wf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<pi>\\<^sub>4 r = val \\<and>\n       (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk) \\<and>\n       (\\<pi>\\<^sub>3 r = unk \\<longrightarrow>\n        \\<pi>\\<^sub>5 r = 1) \\<Longrightarrow>\n       (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)", "by simp"], ["", "lemma update_arg_wf_tuples [simp]:\n  \"\\<And>nhip pre. update_arg_wf (0, unk, val, Suc 0, nhip, pre)\"\n  \"\\<And>n hops nhip pre. update_arg_wf (Suc n, kno, val, hops,  nhip, pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nhip pre. update_arg_wf (0, unk, val, Suc 0, nhip, pre)) &&&\n    (\\<And>n hops nhip pre.\n        update_arg_wf (Suc n, kno, val, hops, nhip, pre))", "unfolding update_arg_wf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nhip pre.\n        \\<pi>\\<^sub>4 (0, unk, val, Suc 0, nhip, pre) = val \\<and>\n        (\\<pi>\\<^sub>2 (0, unk, val, Suc 0, nhip, pre) = 0) =\n        (\\<pi>\\<^sub>3 (0, unk, val, Suc 0, nhip, pre) = unk) \\<and>\n        (\\<pi>\\<^sub>3 (0, unk, val, Suc 0, nhip, pre) =\n         unk \\<longrightarrow>\n         \\<pi>\\<^sub>5 (0, unk, val, Suc 0, nhip, pre) = 1)) &&&\n    (\\<And>n hops nhip pre.\n        \\<pi>\\<^sub>4 (Suc n, kno, val, hops, nhip, pre) = val \\<and>\n        (\\<pi>\\<^sub>2 (Suc n, kno, val, hops, nhip, pre) = 0) =\n        (\\<pi>\\<^sub>3 (Suc n, kno, val, hops, nhip, pre) = unk) \\<and>\n        (\\<pi>\\<^sub>3 (Suc n, kno, val, hops, nhip, pre) =\n         unk \\<longrightarrow>\n         \\<pi>\\<^sub>5 (Suc n, kno, val, hops, nhip, pre) = 1))", "by auto"], ["", "lemma update_arg_wf_tuples' [elim]:\n  \"\\<And>n hops nhip pre. Suc 0 \\<le> n \\<Longrightarrow> update_arg_wf (n, kno, val, hops,  nhip, pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n hops nhip pre.\n       Suc 0 \\<le> n \\<Longrightarrow>\n       update_arg_wf (n, kno, val, hops, nhip, pre)", "unfolding update_arg_wf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n hops nhip pre.\n       Suc 0 \\<le> n \\<Longrightarrow>\n       \\<pi>\\<^sub>4 (n, kno, val, hops, nhip, pre) = val \\<and>\n       (\\<pi>\\<^sub>2 (n, kno, val, hops, nhip, pre) = 0) =\n       (\\<pi>\\<^sub>3 (n, kno, val, hops, nhip, pre) = unk) \\<and>\n       (\\<pi>\\<^sub>3 (n, kno, val, hops, nhip, pre) = unk \\<longrightarrow>\n        \\<pi>\\<^sub>5 (n, kno, val, hops, nhip, pre) = 1)", "by auto"], ["", "lemma wf_r_cases [intro]:\n    fixes P r\n  assumes \"update_arg_wf r\"\n      and c1: \"\\<And>nhip pre. P (0, unk, val, Suc 0, nhip, pre)\"\n      and c2: \"\\<And>dsn hops nhip pre. dsn > 0 \\<Longrightarrow> P (dsn, kno, val, hops, nhip, pre)\"\n    shows \"P r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P r", "obtain dsn dsk flag hops nhip pre\n    where *: \"r = (dsn, dsk, flag, hops, nhip, pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk flag hops nhip pre.\n        r = (dsn, dsk, flag, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases r)"], ["proof (state)\nthis:\n  r = (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. P r", "with \\<open>update_arg_wf r\\<close>"], ["proof (chain)\npicking this:\n  update_arg_wf r\n  r = (dsn, dsk, flag, hops, nhip, pre)", "have wf1: \"flag = val\"\n                            and wf2: \"(dsn = 0) = (dsk = unk)\"\n                            and wf3: \"dsk = unk \\<longrightarrow> (hops = 1)\""], ["proof (prove)\nusing this:\n  update_arg_wf r\n  r = (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. flag = val &&&\n    (dsn = 0) = (dsk = unk) &&& dsk = unk \\<longrightarrow> hops = 1", "unfolding update_arg_wf_def"], ["proof (prove)\nusing this:\n  \\<pi>\\<^sub>4 r = val \\<and>\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk) \\<and>\n  (\\<pi>\\<^sub>3 r = unk \\<longrightarrow> \\<pi>\\<^sub>5 r = 1)\n  r = (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. flag = val &&&\n    (dsn = 0) = (dsk = unk) &&& dsk = unk \\<longrightarrow> hops = 1", "by auto"], ["proof (state)\nthis:\n  flag = val\n  (dsn = 0) = (dsk = unk)\n  dsk = unk \\<longrightarrow> hops = 1\n\ngoal (1 subgoal):\n 1. P r", "have \"P (dsn, dsk, flag, hops, nhip, pre)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (dsn, dsk, flag, hops, nhip, pre)", "proof (cases dsk)"], ["proof (state)\ngoal (2 subgoals):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)\n 2. dsk = unk \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "assume \"dsk = unk\""], ["proof (state)\nthis:\n  dsk = unk\n\ngoal (2 subgoals):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)\n 2. dsk = unk \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "moreover"], ["proof (state)\nthis:\n  dsk = unk\n\ngoal (2 subgoals):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)\n 2. dsk = unk \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "with wf2 wf3"], ["proof (chain)\npicking this:\n  (dsn = 0) = (dsk = unk)\n  dsk = unk \\<longrightarrow> hops = 1\n  dsk = unk", "have \"dsn = 0\" and \"hops = Suc 0\""], ["proof (prove)\nusing this:\n  (dsn = 0) = (dsk = unk)\n  dsk = unk \\<longrightarrow> hops = 1\n  dsk = unk\n\ngoal (1 subgoal):\n 1. dsn = 0 &&& hops = Suc 0", "by auto"], ["proof (state)\nthis:\n  dsn = 0\n  hops = Suc 0\n\ngoal (2 subgoals):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)\n 2. dsk = unk \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "ultimately"], ["proof (chain)\npicking this:\n  dsk = unk\n  dsn = 0\n  hops = Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  dsk = unk\n  dsn = 0\n  hops = Suc 0\n\ngoal (1 subgoal):\n 1. P (dsn, dsk, flag, hops, nhip, pre)", "using \\<open>flag = val\\<close>"], ["proof (prove)\nusing this:\n  dsk = unk\n  dsn = 0\n  hops = Suc 0\n  flag = val\n\ngoal (1 subgoal):\n 1. P (dsn, dsk, flag, hops, nhip, pre)", "by simp (rule c1)"], ["proof (state)\nthis:\n  P (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "assume \"dsk = kno\""], ["proof (state)\nthis:\n  dsk = kno\n\ngoal (1 subgoal):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "moreover"], ["proof (state)\nthis:\n  dsk = kno\n\ngoal (1 subgoal):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "with wf2"], ["proof (chain)\npicking this:\n  (dsn = 0) = (dsk = unk)\n  dsk = kno", "have \"dsn > 0\""], ["proof (prove)\nusing this:\n  (dsn = 0) = (dsk = unk)\n  dsk = kno\n\ngoal (1 subgoal):\n 1. 0 < dsn", "by simp"], ["proof (state)\nthis:\n  0 < dsn\n\ngoal (1 subgoal):\n 1. dsk = kno \\<Longrightarrow> P (dsn, dsk, flag, hops, nhip, pre)", "ultimately"], ["proof (chain)\npicking this:\n  dsk = kno\n  0 < dsn", "show ?thesis"], ["proof (prove)\nusing this:\n  dsk = kno\n  0 < dsn\n\ngoal (1 subgoal):\n 1. P (dsn, dsk, flag, hops, nhip, pre)", "using \\<open>flag = val\\<close>"], ["proof (prove)\nusing this:\n  dsk = kno\n  0 < dsn\n  flag = val\n\ngoal (1 subgoal):\n 1. P (dsn, dsk, flag, hops, nhip, pre)", "by simp (rule c2)"], ["proof (state)\nthis:\n  P (dsn, dsk, flag, hops, nhip, pre)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. P r", "with *"], ["proof (chain)\npicking this:\n  r = (dsn, dsk, flag, hops, nhip, pre)\n  P (dsn, dsk, flag, hops, nhip, pre)", "show \"P r\""], ["proof (prove)\nusing this:\n  r = (dsn, dsk, flag, hops, nhip, pre)\n  P (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. P r", "by simp"], ["proof (state)\nthis:\n  P r\n\ngoal:\nNo subgoals!", "qed"], ["", "definition update :: \"rt \\<Rightarrow> ip \\<Rightarrow> r \\<Rightarrow> rt\"\n  where\n  \"update rt ip r \\<equiv>\n     case \\<sigma>\\<^bsub>route\\<^esub>(rt, ip) of\n       None \\<Rightarrow> rt (ip \\<mapsto> r)\n     | Some s \\<Rightarrow>\n          if \\<pi>\\<^sub>2(s) < \\<pi>\\<^sub>2(r) then rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(s)))\n          else if \\<pi>\\<^sub>2(s) = \\<pi>\\<^sub>2(r) \\<and> (\\<pi>\\<^sub>5(s) > \\<pi>\\<^sub>5(r) \\<or> \\<pi>\\<^sub>4(s) = inv)\n               then rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(s)))\n               else if \\<pi>\\<^sub>3(r) = unk\n                    then rt (ip \\<mapsto> (\\<pi>\\<^sub>2(s), snd (addpre r (\\<pi>\\<^sub>7(s)))))\n                    else rt (ip \\<mapsto> addpre s (\\<pi>\\<^sub>7(r)))\""], ["", "lemma update_simps [simp]:\n  fixes r s nrt nr nr' ns rt ip\n  defines \"s \\<equiv> the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)\"\n      and \"nr \\<equiv> addpre r (\\<pi>\\<^sub>7(s))\"\n      and \"nr' \\<equiv> (\\<pi>\\<^sub>2(s), \\<pi>\\<^sub>3(nr), \\<pi>\\<^sub>4(nr), \\<pi>\\<^sub>5(nr), \\<pi>\\<^sub>6(nr), \\<pi>\\<^sub>7(nr))\"\n      and \"ns \\<equiv> addpre s (\\<pi>\\<^sub>7(r))\"\n  shows\n  \"\\<lbrakk>ip \\<notin> kD(rt)\\<rbrakk>                            \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> r)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip < \\<pi>\\<^sub>2(r)\\<rbrakk>         \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r);\n                 the (dhops rt ip) > \\<pi>\\<^sub>5(r)\\<rbrakk> \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r);\n                 flag rt ip = Some inv\\<rbrakk>     \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr)\"\n  \"\\<lbrakk>ip \\<in> kD(rt); \\<pi>\\<^sub>3(r) = unk; (\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\\<rbrakk>  \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> nr')\"\n  \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip \\<ge> \\<pi>\\<^sub>2(r); \\<pi>\\<^sub>3(r) = kno;\n    sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val \\<rbrakk>\n                                            \\<Longrightarrow> update rt ip r = rt (ip \\<mapsto> ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ip \\<notin> kD rt \\<Longrightarrow>\n      update rt ip r = rt(ip \\<mapsto> r)) &&&\n     (\\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n      \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)) &&&\n     (\\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n       \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n      \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr))) &&&\n    (\\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n      flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n     \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)) &&&\n    (\\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n      (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n     \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')) &&&\n    (\\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n      \\<pi>\\<^sub>3 r = kno;\n      sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n      the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n      the (flag rt ip) = val\\<rbrakk>\n     \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns))", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> r)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 4. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 6. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "assume \"ip\\<notin>kD(rt)\""], ["proof (state)\nthis:\n  ip \\<notin> kD rt\n\ngoal (6 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> r)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 4. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 6. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "hence \"\\<sigma>\\<^bsub>route\\<^esub>(rt, ip) = None\""], ["proof (prove)\nusing this:\n  ip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. rt ip = None", ".."], ["proof (state)\nthis:\n  rt ip = None\n\ngoal (6 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> r)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 4. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 6. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "thus \"update rt ip r = rt (ip \\<mapsto> r)\""], ["proof (prove)\nusing this:\n  rt ip = None\n\ngoal (1 subgoal):\n 1. update rt ip r = rt(ip \\<mapsto> r)", "unfolding update_def"], ["proof (prove)\nusing this:\n  rt ip = None\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> rt(ip \\<mapsto> r)\n     | Some s \\<Rightarrow>\n         if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 r\n         then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n         else if \\<pi>\\<^sub>2 s = \\<pi>\\<^sub>2 r \\<and>\n                 (\\<pi>\\<^sub>5 r < \\<pi>\\<^sub>5 s \\<or>\n                  \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n              then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n              else if \\<pi>\\<^sub>3 r = unk\n                   then rt(ip \\<mapsto>\n                        (\\<pi>\\<^sub>2 s, snd (addpre r (\\<pi>\\<^sub>7 s))))\n                   else rt(ip \\<mapsto> addpre s (\\<pi>\\<^sub>7 r))) =\n    rt(ip \\<mapsto> r)", "by simp"], ["proof (state)\nthis:\n  update rt ip r = rt(ip \\<mapsto> r)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "assume \"ip \\<in> kD(rt)\"\n       and \"sqn rt ip < \\<pi>\\<^sub>2(r)\""], ["proof (state)\nthis:\n  ip \\<in> kD rt\n  sqn rt ip < \\<pi>\\<^sub>2 r\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "from this(1)"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "obtain dsn dsk fl hops nhip pre\n      where \"rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk fl hops nhip pre.\n        rt ip = Some (dsn, dsk, fl, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "with \\<open>sqn rt ip < \\<pi>\\<^sub>2(r)\\<close>"], ["proof (chain)\npicking this:\n  sqn rt ip < \\<pi>\\<^sub>2 r\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)", "show \"update rt ip r = rt (ip \\<mapsto> nr)\""], ["proof (prove)\nusing this:\n  sqn rt ip < \\<pi>\\<^sub>2 r\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. update rt ip r = rt(ip \\<mapsto> nr)", "unfolding update_def nr_def s_def"], ["proof (prove)\nusing this:\n  sqn rt ip < \\<pi>\\<^sub>2 r\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> rt(ip \\<mapsto> r)\n     | Some s \\<Rightarrow>\n         if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 r\n         then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n         else if \\<pi>\\<^sub>2 s = \\<pi>\\<^sub>2 r \\<and>\n                 (\\<pi>\\<^sub>5 r < \\<pi>\\<^sub>5 s \\<or>\n                  \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n              then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n              else if \\<pi>\\<^sub>3 r = unk\n                   then rt(ip \\<mapsto>\n                        (\\<pi>\\<^sub>2 s, snd (addpre r (\\<pi>\\<^sub>7 s))))\n                   else rt(ip \\<mapsto> addpre s (\\<pi>\\<^sub>7 r))) =\n    rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip))))", "by auto"], ["proof (state)\nthis:\n  update rt ip r = rt(ip \\<mapsto> nr)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "assume \"ip \\<in> kD(rt)\"\n       and \"sqn rt ip = \\<pi>\\<^sub>2(r)\"\n       and \"the (dhops rt ip) > \\<pi>\\<^sub>5(r)\""], ["proof (state)\nthis:\n  ip \\<in> kD rt\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  \\<pi>\\<^sub>5 r < the (dhops rt ip)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "from this(1)"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "obtain dsn dsk fl hops nhip pre\n      where \"rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk fl hops nhip pre.\n        rt ip = Some (dsn, dsk, fl, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "with \\<open>sqn rt ip = \\<pi>\\<^sub>2(r)\\<close> and \\<open>the (dhops rt ip) > \\<pi>\\<^sub>5(r)\\<close>"], ["proof (chain)\npicking this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  \\<pi>\\<^sub>5 r < the (dhops rt ip)\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)", "show \"update rt ip r = rt (ip \\<mapsto> nr)\""], ["proof (prove)\nusing this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  \\<pi>\\<^sub>5 r < the (dhops rt ip)\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. update rt ip r = rt(ip \\<mapsto> nr)", "unfolding update_def nr_def s_def"], ["proof (prove)\nusing this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  \\<pi>\\<^sub>5 r < the (dhops rt ip)\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> rt(ip \\<mapsto> r)\n     | Some s \\<Rightarrow>\n         if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 r\n         then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n         else if \\<pi>\\<^sub>2 s = \\<pi>\\<^sub>2 r \\<and>\n                 (\\<pi>\\<^sub>5 r < \\<pi>\\<^sub>5 s \\<or>\n                  \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n              then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n              else if \\<pi>\\<^sub>3 r = unk\n                   then rt(ip \\<mapsto>\n                        (\\<pi>\\<^sub>2 s, snd (addpre r (\\<pi>\\<^sub>7 s))))\n                   else rt(ip \\<mapsto> addpre s (\\<pi>\\<^sub>7 r))) =\n    rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip))))", "by auto"], ["proof (state)\nthis:\n  update rt ip r = rt(ip \\<mapsto> nr)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "assume \"ip \\<in> kD(rt)\"\n        and \"sqn rt ip = \\<pi>\\<^sub>2(r)\"\n        and \"flag rt ip = Some inv\""], ["proof (state)\nthis:\n  ip \\<in> kD rt\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  flag rt ip = Some Aodv_Basic.inv\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "from this(1)"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "obtain dsn dsk fl hops nhip pre\n      where \"rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk fl hops nhip pre.\n        rt ip = Some (dsn, dsk, fl, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     flag rt ip = Some Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr)\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "with \\<open>sqn rt ip = \\<pi>\\<^sub>2(r)\\<close> and \\<open>flag rt ip = Some inv\\<close>"], ["proof (chain)\npicking this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  flag rt ip = Some Aodv_Basic.inv\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)", "show \"update rt ip r = rt (ip \\<mapsto> nr)\""], ["proof (prove)\nusing this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  flag rt ip = Some Aodv_Basic.inv\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. update rt ip r = rt(ip \\<mapsto> nr)", "unfolding update_def nr_def s_def"], ["proof (prove)\nusing this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  flag rt ip = Some Aodv_Basic.inv\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> rt(ip \\<mapsto> r)\n     | Some s \\<Rightarrow>\n         if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 r\n         then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n         else if \\<pi>\\<^sub>2 s = \\<pi>\\<^sub>2 r \\<and>\n                 (\\<pi>\\<^sub>5 r < \\<pi>\\<^sub>5 s \\<or>\n                  \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n              then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n              else if \\<pi>\\<^sub>3 r = unk\n                   then rt(ip \\<mapsto>\n                        (\\<pi>\\<^sub>2 s, snd (addpre r (\\<pi>\\<^sub>7 s))))\n                   else rt(ip \\<mapsto> addpre s (\\<pi>\\<^sub>7 r))) =\n    rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip))))", "by auto"], ["proof (state)\nthis:\n  update rt ip r = rt(ip \\<mapsto> nr)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "assume \"ip \\<in> kD(rt)\"\n       and \"\\<pi>\\<^sub>3(r) = unk\"\n       and \"(\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\""], ["proof (state)\nthis:\n  ip \\<in> kD rt\n  \\<pi>\\<^sub>3 r = unk\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "from this(1)"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "obtain dsn dsk fl hops nhip pre\n      where \"rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk fl hops nhip pre.\n        rt ip = Some (dsn, dsk, fl, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk;\n     (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> nr')\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "with \\<open>(\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\\<close> and \\<open>\\<pi>\\<^sub>3(r) = unk\\<close>"], ["proof (chain)\npicking this:\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\n  \\<pi>\\<^sub>3 r = unk\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)", "show \"update rt ip r = rt (ip \\<mapsto> nr')\""], ["proof (prove)\nusing this:\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\n  \\<pi>\\<^sub>3 r = unk\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. update rt ip r = rt(ip \\<mapsto> nr')", "unfolding update_def nr'_def nr_def s_def"], ["proof (prove)\nusing this:\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\n  \\<pi>\\<^sub>3 r = unk\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> rt(ip \\<mapsto> r)\n     | Some s \\<Rightarrow>\n         if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 r\n         then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n         else if \\<pi>\\<^sub>2 s = \\<pi>\\<^sub>2 r \\<and>\n                 (\\<pi>\\<^sub>5 r < \\<pi>\\<^sub>5 s \\<or>\n                  \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n              then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n              else if \\<pi>\\<^sub>3 r = unk\n                   then rt(ip \\<mapsto>\n                        (\\<pi>\\<^sub>2 s, snd (addpre r (\\<pi>\\<^sub>7 s))))\n                   else rt(ip \\<mapsto> addpre s (\\<pi>\\<^sub>7 r))) =\n    rt(ip \\<mapsto>\n    (\\<pi>\\<^sub>2 (the (rt ip)),\n     \\<pi>\\<^sub>3 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))),\n     \\<pi>\\<^sub>4 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))),\n     \\<pi>\\<^sub>5 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))),\n     \\<pi>\\<^sub>6 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))),\n     \\<pi>\\<^sub>7 (addpre r (\\<pi>\\<^sub>7 (the (rt ip))))))", "by (cases r) simp"], ["proof (state)\nthis:\n  update rt ip r = rt(ip \\<mapsto> nr')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "assume \"ip \\<in> kD(rt)\"\n       and otherassms: \"sqn rt ip \\<ge> \\<pi>\\<^sub>2(r)\"\n           \"\\<pi>\\<^sub>3(r) = kno\"\n           \"sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val\""], ["proof (state)\nthis:\n  ip \\<in> kD rt\n  \\<pi>\\<^sub>2 r \\<le> sqn rt ip\n  \\<pi>\\<^sub>3 r = kno\n  sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and> the (flag rt ip) = val\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "from this(1)"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "obtain dsn dsk fl hops nhip pre\n      where \"rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk fl hops nhip pre.\n        rt ip = Some (dsn, dsk, fl, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> update rt ip r = rt(ip \\<mapsto> ns)", "with otherassms"], ["proof (chain)\npicking this:\n  \\<pi>\\<^sub>2 r \\<le> sqn rt ip\n  \\<pi>\\<^sub>3 r = kno\n  sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and> the (flag rt ip) = val\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)", "show \"update rt ip r = rt (ip \\<mapsto> ns)\""], ["proof (prove)\nusing this:\n  \\<pi>\\<^sub>2 r \\<le> sqn rt ip\n  \\<pi>\\<^sub>3 r = kno\n  sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and> the (flag rt ip) = val\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. update rt ip r = rt(ip \\<mapsto> ns)", "unfolding update_def ns_def s_def"], ["proof (prove)\nusing this:\n  \\<pi>\\<^sub>2 r \\<le> sqn rt ip\n  \\<pi>\\<^sub>3 r = kno\n  sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and> the (flag rt ip) = val\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> rt(ip \\<mapsto> r)\n     | Some s \\<Rightarrow>\n         if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 r\n         then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n         else if \\<pi>\\<^sub>2 s = \\<pi>\\<^sub>2 r \\<and>\n                 (\\<pi>\\<^sub>5 r < \\<pi>\\<^sub>5 s \\<or>\n                  \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n              then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n              else if \\<pi>\\<^sub>3 r = unk\n                   then rt(ip \\<mapsto>\n                        (\\<pi>\\<^sub>2 s, snd (addpre r (\\<pi>\\<^sub>7 s))))\n                   else rt(ip \\<mapsto> addpre s (\\<pi>\\<^sub>7 r))) =\n    rt(ip \\<mapsto> addpre (the (rt ip)) (\\<pi>\\<^sub>7 r))", "by auto"], ["proof (state)\nthis:\n  update rt ip r = rt(ip \\<mapsto> ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_cases [elim]:\n  assumes \"(\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\"\n      and c1: \"\\<lbrakk>ip \\<notin> kD(rt)\\<rbrakk> \\<Longrightarrow> P (rt (ip \\<mapsto> r))\"\n\n      and c2: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip < \\<pi>\\<^sub>2(r)\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c3: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r); the (dhops rt ip) > \\<pi>\\<^sub>5(r)\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c4: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip = \\<pi>\\<^sub>2(r); the (flag rt ip) = inv\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c5: \"\\<lbrakk>ip \\<in> kD(rt); \\<pi>\\<^sub>3(r) = unk\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> (\\<pi>\\<^sub>2(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)), \\<pi>\\<^sub>3(r),\n                                  \\<pi>\\<^sub>4(r), \\<pi>\\<^sub>5(r), \\<pi>\\<^sub>6(r), \\<pi>\\<^sub>7(addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))))\"\n      and c6: \"\\<lbrakk>ip \\<in> kD(rt); sqn rt ip \\<ge> \\<pi>\\<^sub>2(r); \\<pi>\\<^sub>3(r) = kno;\n                sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre (the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)) (\\<pi>\\<^sub>7(r))))\"\n  shows \"(P (update rt ip r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (update rt ip r)", "proof (cases \"ip \\<in> kD(rt)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)\n 2. ip \\<notin> kD rt \\<Longrightarrow> P (update rt ip r)", "assume \"ip \\<notin> kD(rt)\""], ["proof (state)\nthis:\n  ip \\<notin> kD rt\n\ngoal (2 subgoals):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)\n 2. ip \\<notin> kD rt \\<Longrightarrow> P (update rt ip r)", "with c1"], ["proof (chain)\npicking this:\n  ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n  ip \\<notin> kD rt", "show ?thesis"], ["proof (prove)\nusing this:\n  ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n  ip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. P (update rt ip r)", "by simp"], ["proof (state)\nthis:\n  P (update rt ip r)\n\ngoal (1 subgoal):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)", "assume \"ip \\<in> kD(rt)\""], ["proof (state)\nthis:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)", "moreover"], ["proof (state)\nthis:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)", "then"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt", "obtain dsn dsk fl hops nhip pre\n      where rteq: \"rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\""], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk fl hops nhip pre.\n        rt ip = Some (dsn, dsk, fl, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)", "moreover"], ["proof (state)\nthis:\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)", "obtain dsn' dsk' fl' hops' nhip' pre'\n      where req: \"r = (dsn', dsk', fl', hops', nhip', pre')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dsn' dsk' fl' hops' nhip' pre'.\n        r = (dsn', dsk', fl', hops', nhip', pre') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases r) metis"], ["proof (state)\nthis:\n  r = (dsn', dsk', fl', hops', nhip', pre')\n\ngoal (1 subgoal):\n 1. ip \\<in> kD rt \\<Longrightarrow> P (update rt ip r)", "ultimately"], ["proof (chain)\npicking this:\n  ip \\<in> kD rt\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n  r = (dsn', dsk', fl', hops', nhip', pre')", "show ?thesis"], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n  r = (dsn', dsk', fl', hops', nhip', pre')\n\ngoal (1 subgoal):\n 1. P (update rt ip r)", "using \\<open>(\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\\<close>\n            c2 [OF \\<open>ip\\<in>kD(rt)\\<close>]\n            c3 [OF \\<open>ip\\<in>kD(rt)\\<close>]\n            c4 [OF \\<open>ip\\<in>kD(rt)\\<close>]\n            c5 [OF \\<open>ip\\<in>kD(rt)\\<close>]\n            c6 [OF \\<open>ip\\<in>kD(rt)\\<close>]"], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n  r = (dsn', dsk', fl', hops', nhip', pre')\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\n  sqn rt ip < \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n  \\<lbrakk>sqn rt ip = \\<pi>\\<^sub>2 r;\n   \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n  \\<Longrightarrow> P (rt(ip \\<mapsto>\n                       addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n  \\<lbrakk>sqn rt ip = \\<pi>\\<^sub>2 r;\n   the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n  \\<Longrightarrow> P (rt(ip \\<mapsto>\n                       addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n  \\<pi>\\<^sub>3 r = unk \\<Longrightarrow>\n  P (rt(ip \\<mapsto>\n     (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r, \\<pi>\\<^sub>4 r,\n      \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n      \\<pi>\\<^sub>7 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n  \\<lbrakk>\\<pi>\\<^sub>2 r \\<le> sqn rt ip; \\<pi>\\<^sub>3 r = kno;\n   sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n   the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n   the (flag rt ip) = val\\<rbrakk>\n  \\<Longrightarrow> P (rt(ip \\<mapsto>\n                       addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))\n\ngoal (1 subgoal):\n 1. P (update rt ip r)", "unfolding update_def sqn_def"], ["proof (prove)\nusing this:\n  ip \\<in> kD rt\n  rt ip = Some (dsn, dsk, fl, hops, nhip, pre)\n  r = (dsn', dsk', fl', hops', nhip', pre')\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\n  (case rt ip of None \\<Rightarrow> 0\n   | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)\n  < \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n  \\<lbrakk>(case rt ip of None \\<Rightarrow> 0\n            | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n           \\<pi>\\<^sub>2 r;\n   \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n  \\<Longrightarrow> P (rt(ip \\<mapsto>\n                       addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n  \\<lbrakk>(case rt ip of None \\<Rightarrow> 0\n            | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n           \\<pi>\\<^sub>2 r;\n   the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n  \\<Longrightarrow> P (rt(ip \\<mapsto>\n                       addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n  \\<pi>\\<^sub>3 r = unk \\<Longrightarrow>\n  P (rt(ip \\<mapsto>\n     (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r, \\<pi>\\<^sub>4 r,\n      \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n      \\<pi>\\<^sub>7 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n  \\<lbrakk>\\<pi>\\<^sub>2 r\n           \\<le> (case rt ip of None \\<Rightarrow> 0\n                  | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r);\n   \\<pi>\\<^sub>3 r = kno;\n   (case rt ip of None \\<Rightarrow> 0\n    | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n   \\<pi>\\<^sub>2 r \\<Longrightarrow>\n   the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n   the (flag rt ip) = val\\<rbrakk>\n  \\<Longrightarrow> P (rt(ip \\<mapsto>\n                       addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))\n\ngoal (1 subgoal):\n 1. P (case rt ip of None \\<Rightarrow> rt(ip \\<mapsto> r)\n       | Some s \\<Rightarrow>\n           if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 r\n           then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n           else if \\<pi>\\<^sub>2 s = \\<pi>\\<^sub>2 r \\<and>\n                   (\\<pi>\\<^sub>5 r < \\<pi>\\<^sub>5 s \\<or>\n                    \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                then rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 s))\n                else if \\<pi>\\<^sub>3 r = unk\n                     then rt(ip \\<mapsto>\n                          (\\<pi>\\<^sub>2 s,\n                           snd (addpre r (\\<pi>\\<^sub>7 s))))\n                     else rt(ip \\<mapsto> addpre s (\\<pi>\\<^sub>7 r)))", "by auto"], ["proof (state)\nthis:\n  P (update rt ip r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_cases_kD:\n  assumes \"(\\<pi>\\<^sub>2(r) = 0) = (\\<pi>\\<^sub>3(r) = unk)\"\n      and \"ip \\<in> kD(rt)\"\n      and c2: \"sqn rt ip < \\<pi>\\<^sub>2(r) \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c3: \"\\<lbrakk>sqn rt ip = \\<pi>\\<^sub>2(r); the (dhops rt ip) > \\<pi>\\<^sub>5(r)\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c4: \"\\<lbrakk>sqn rt ip = \\<pi>\\<^sub>2(r); the (flag rt ip) = inv\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))\"\n      and c5: \"\\<pi>\\<^sub>3(r) = unk \\<Longrightarrow> P (rt (ip \\<mapsto> (\\<pi>\\<^sub>2(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)), \\<pi>\\<^sub>3(r),\n                                            \\<pi>\\<^sub>4(r), \\<pi>\\<^sub>5(r), \\<pi>\\<^sub>6(r),\n                                            \\<pi>\\<^sub>7(addpre r (\\<pi>\\<^sub>7(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)))))))\"\n      and c6: \"\\<lbrakk>sqn rt ip \\<ge> \\<pi>\\<^sub>2(r); \\<pi>\\<^sub>3(r) = kno;\n                sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val\\<rbrakk>\n                \\<Longrightarrow> P (rt (ip \\<mapsto> addpre (the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)) (\\<pi>\\<^sub>7(r))))\"\n  shows \"(P (update rt ip r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (update rt ip r)", "using assms(1)"], ["proof (prove)\nusing this:\n  (\\<pi>\\<^sub>2 r = 0) = (\\<pi>\\<^sub>3 r = unk)\n\ngoal (1 subgoal):\n 1. P (update rt ip r)", "proof (rule update_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 4. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 6. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "assume \"sqn rt ip < \\<pi>\\<^sub>2(r)\""], ["proof (state)\nthis:\n  sqn rt ip < \\<pi>\\<^sub>2 r\n\ngoal (6 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip < \\<pi>\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 4. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 6. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "thus \"P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7(the (rt ip)))))\""], ["proof (prove)\nusing this:\n  sqn rt ip < \\<pi>\\<^sub>2 r\n\ngoal (1 subgoal):\n 1. P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))", "by (rule c2)"], ["proof (state)\nthis:\n  P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n\ngoal (5 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "assume \"sqn rt ip = \\<pi>\\<^sub>2(r)\"\n       and \"the (dhops rt ip) > \\<pi>\\<^sub>5(r)\""], ["proof (state)\nthis:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  \\<pi>\\<^sub>5 r < the (dhops rt ip)\n\ngoal (5 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     \\<pi>\\<^sub>5 r < the (dhops rt ip)\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 5. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "thus \"P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\""], ["proof (prove)\nusing this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  \\<pi>\\<^sub>5 r < the (dhops rt ip)\n\ngoal (1 subgoal):\n 1. P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))", "by (rule c3)"], ["proof (state)\nthis:\n  P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n\ngoal (4 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "assume \"sqn rt ip = \\<pi>\\<^sub>2(r)\"\n       and \"the (flag rt ip) = inv\""], ["proof (state)\nthis:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  the (flag rt ip) = Aodv_Basic.inv\n\ngoal (4 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; sqn rt ip = \\<pi>\\<^sub>2 r;\n     the (flag rt ip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 4. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "thus \"P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\""], ["proof (prove)\nusing this:\n  sqn rt ip = \\<pi>\\<^sub>2 r\n  the (flag rt ip) = Aodv_Basic.inv\n\ngoal (1 subgoal):\n 1. P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))", "by (rule c4)"], ["proof (state)\nthis:\n  P (rt(ip \\<mapsto> addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))\n\ngoal (3 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "assume \"\\<pi>\\<^sub>3(r) = unk\""], ["proof (state)\nthis:\n  \\<pi>\\<^sub>3 r = unk\n\ngoal (3 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>3 r = unk\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r,\n                          \\<pi>\\<^sub>4 r, \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n                          \\<pi>\\<^sub>7\n                           (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n 3. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "thus \"P (rt (ip \\<mapsto> (\\<pi>\\<^sub>2(the \\<sigma>\\<^bsub>route\\<^esub>(rt, ip)), \\<pi>\\<^sub>3(r), \\<pi>\\<^sub>4(r), \\<pi>\\<^sub>5(r), \\<pi>\\<^sub>6(r),\n                        \\<pi>\\<^sub>7(addpre r (\\<pi>\\<^sub>7(the (rt ip)))))))\""], ["proof (prove)\nusing this:\n  \\<pi>\\<^sub>3 r = unk\n\ngoal (1 subgoal):\n 1. P (rt(ip \\<mapsto>\n       (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r, \\<pi>\\<^sub>4 r,\n        \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n        \\<pi>\\<^sub>7 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))", "by (rule c5)"], ["proof (state)\nthis:\n  P (rt(ip \\<mapsto>\n     (\\<pi>\\<^sub>2 (the (rt ip)), \\<pi>\\<^sub>3 r, \\<pi>\\<^sub>4 r,\n      \\<pi>\\<^sub>5 r, \\<pi>\\<^sub>6 r,\n      \\<pi>\\<^sub>7 (addpre r (\\<pi>\\<^sub>7 (the (rt ip)))))))\n\ngoal (2 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "assume \"sqn rt ip \\<ge> \\<pi>\\<^sub>2(r)\"\n       and \"\\<pi>\\<^sub>3(r) = kno\"\n       and \"sqn rt ip = \\<pi>\\<^sub>2(r) \\<Longrightarrow> the (dhops rt ip) \\<le> \\<pi>\\<^sub>5(r) \\<and> the (flag rt ip) = val\""], ["proof (state)\nthis:\n  \\<pi>\\<^sub>2 r \\<le> sqn rt ip\n  \\<pi>\\<^sub>3 r = kno\n  sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and> the (flag rt ip) = val\n\ngoal (2 subgoals):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))\n 2. \\<lbrakk>ip \\<in> kD rt; \\<pi>\\<^sub>2 r \\<le> sqn rt ip;\n     \\<pi>\\<^sub>3 r = kno;\n     sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n     the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and>\n     the (flag rt ip) = val\\<rbrakk>\n    \\<Longrightarrow> P (rt(ip \\<mapsto>\n                         addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "thus \"P (rt (ip \\<mapsto> addpre (the (rt ip)) (\\<pi>\\<^sub>7(r))))\""], ["proof (prove)\nusing this:\n  \\<pi>\\<^sub>2 r \\<le> sqn rt ip\n  \\<pi>\\<^sub>3 r = kno\n  sqn rt ip = \\<pi>\\<^sub>2 r \\<Longrightarrow>\n  the (dhops rt ip) \\<le> \\<pi>\\<^sub>5 r \\<and> the (flag rt ip) = val\n\ngoal (1 subgoal):\n 1. P (rt(ip \\<mapsto> addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))", "by (rule c6)"], ["proof (state)\nthis:\n  P (rt(ip \\<mapsto> addpre (the (rt ip)) (\\<pi>\\<^sub>7 r)))\n\ngoal (1 subgoal):\n 1. ip \\<notin> kD rt \\<Longrightarrow> P (rt(ip \\<mapsto> r))", "qed (simp add: \\<open>ip \\<in> kD(rt)\\<close>)"], ["", "lemma in_kD_after_update [simp]:\n  fixes rt nip dsn dsk flag hops nhip pre\n  shows \"kD (update rt nip (dsn, dsk, flag, hops, nhip, pre)) = insert nip (kD rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kD (update rt nip (dsn, dsk, flag, hops, nhip, pre)) =\n    insert nip (kD rt)", "unfolding update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. kD (case rt nip of\n        None \\<Rightarrow> rt(nip \\<mapsto>\n          (dsn, dsk, flag, hops, nhip, pre))\n        | Some s \\<Rightarrow>\n            if \\<pi>\\<^sub>2 s\n               < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n            then rt(nip \\<mapsto>\n                 addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>2 s =\n                    \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                    (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre)\n                     < \\<pi>\\<^sub>5 s \\<or>\n                     \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                 then rt(nip \\<mapsto>\n                      addpre (dsn, dsk, flag, hops, nhip, pre)\n                       (\\<pi>\\<^sub>7 s))\n                 else if \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, pre) =\n                         unk\n                      then rt(nip \\<mapsto>\n                           (\\<pi>\\<^sub>2 s,\n                            snd (addpre (dsn, dsk, flag, hops, nhip, pre)\n                                  (\\<pi>\\<^sub>7 s))))\n                      else rt(nip \\<mapsto>\n                           addpre s\n                            (\\<pi>\\<^sub>7\n                              (dsn, dsk, flag, hops, nhip, pre)))) =\n    insert nip (kD rt)", "by (cases \"rt nip\") auto"], ["", "lemma nhop_of_update [simp]:\n  fixes rt dip dsn dsk flag hops nhip\n  assumes \"rt \\<noteq> update rt dip (dsn, dsk, flag, hops, nhip, {})\"\n  shows \"the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "from assms"], ["proof (chain)\npicking this:\n  rt \\<noteq> update rt dip (dsn, dsk, flag, hops, nhip, {})", "have update_neq: \"\\<And>v. rt dip = Some v \\<Longrightarrow>\n          update rt dip (dsn, dsk, flag, hops, nhip, {})\n             \\<noteq> rt(dip \\<mapsto> addpre (the (rt dip)) (\\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, {})))\""], ["proof (prove)\nusing this:\n  rt \\<noteq> update rt dip (dsn, dsk, flag, hops, nhip, {})\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       rt dip = Some v \\<Longrightarrow>\n       update rt dip (dsn, dsk, flag, hops, nhip, {}) \\<noteq> rt(dip \n       \\<mapsto>\n       addpre (the (rt dip))\n        (\\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, {})))", "by auto"], ["proof (state)\nthis:\n  rt dip = Some ?v \\<Longrightarrow>\n  update rt dip (dsn, dsk, flag, hops, nhip, {}) \\<noteq> rt(dip \\<mapsto>\n  addpre (the (rt dip)) (\\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, {})))\n\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "proof (cases \"rt dip = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rt dip = None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip\n 2. rt dip \\<noteq> None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "assume \"rt dip = None\""], ["proof (state)\nthis:\n  rt dip = None\n\ngoal (2 subgoals):\n 1. rt dip = None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip\n 2. rt dip \\<noteq> None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  rt dip = None\n\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "unfolding update_def"], ["proof (prove)\nusing this:\n  rt dip = None\n\ngoal (1 subgoal):\n 1. the (nhop\n          (case rt dip of\n           None \\<Rightarrow> rt(dip \\<mapsto>\n             (dsn, dsk, flag, hops, nhip, {}))\n           | Some s \\<Rightarrow>\n               if \\<pi>\\<^sub>2 s\n                  < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, {})\n               then rt(dip \\<mapsto>\n                    addpre (dsn, dsk, flag, hops, nhip, {})\n                     (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>2 s =\n                       \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, {}) \\<and>\n                       (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, {})\n                        < \\<pi>\\<^sub>5 s \\<or>\n                        \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                    then rt(dip \\<mapsto>\n                         addpre (dsn, dsk, flag, hops, nhip, {})\n                          (\\<pi>\\<^sub>7 s))\n                    else if \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, {}) =\n                            unk\n                         then rt(dip \\<mapsto>\n                              (\\<pi>\\<^sub>2 s,\n                               snd (addpre (dsn, dsk, flag, hops, nhip, {})\n                                     (\\<pi>\\<^sub>7 s))))\n                         else rt(dip \\<mapsto>\n                              addpre s\n                               (\\<pi>\\<^sub>7\n                                 (dsn, dsk, flag, hops, nhip, {}))))\n          dip) =\n    nhip", "by clarsimp"], ["proof (state)\nthis:\n  the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip\n\ngoal (1 subgoal):\n 1. rt dip \\<noteq> None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rt dip \\<noteq> None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "assume \"rt dip \\<noteq> None\""], ["proof (state)\nthis:\n  rt dip \\<noteq> None\n\ngoal (1 subgoal):\n 1. rt dip \\<noteq> None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "then"], ["proof (chain)\npicking this:\n  rt dip \\<noteq> None", "obtain v where \"rt dip = Some v\""], ["proof (prove)\nusing this:\n  rt dip \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>v. rt dip = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis not_None_eq)"], ["proof (state)\nthis:\n  rt dip = Some v\n\ngoal (1 subgoal):\n 1. rt dip \\<noteq> None \\<Longrightarrow>\n    the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "with update_neq [OF this]"], ["proof (chain)\npicking this:\n  update rt dip (dsn, dsk, flag, hops, nhip, {}) \\<noteq> rt(dip \\<mapsto>\n  addpre (the (rt dip)) (\\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, {})))\n  rt dip = Some v", "show ?thesis"], ["proof (prove)\nusing this:\n  update rt dip (dsn, dsk, flag, hops, nhip, {}) \\<noteq> rt(dip \\<mapsto>\n  addpre (the (rt dip)) (\\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, {})))\n  rt dip = Some v\n\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip", "unfolding update_def"], ["proof (prove)\nusing this:\n  (case rt dip of\n   None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flag, hops, nhip, {}))\n   | Some s \\<Rightarrow>\n       if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, {})\n       then rt(dip \\<mapsto>\n            addpre (dsn, dsk, flag, hops, nhip, {}) (\\<pi>\\<^sub>7 s))\n       else if \\<pi>\\<^sub>2 s =\n               \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, {}) \\<and>\n               (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, {})\n                < \\<pi>\\<^sub>5 s \\<or>\n                \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n            then rt(dip \\<mapsto>\n                 addpre (dsn, dsk, flag, hops, nhip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, {}) = unk\n                 then rt(dip \\<mapsto>\n                      (\\<pi>\\<^sub>2 s,\n                       snd (addpre (dsn, dsk, flag, hops, nhip, {})\n                             (\\<pi>\\<^sub>7 s))))\n                 else rt(dip \\<mapsto>\n                      addpre s\n                       (\\<pi>\\<^sub>7\n                         (dsn, dsk, flag, hops, nhip, {})))) \\<noteq>\n  rt(dip \\<mapsto>\n  addpre (the (rt dip)) (\\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, {})))\n  rt dip = Some v\n\ngoal (1 subgoal):\n 1. the (nhop\n          (case rt dip of\n           None \\<Rightarrow> rt(dip \\<mapsto>\n             (dsn, dsk, flag, hops, nhip, {}))\n           | Some s \\<Rightarrow>\n               if \\<pi>\\<^sub>2 s\n                  < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, {})\n               then rt(dip \\<mapsto>\n                    addpre (dsn, dsk, flag, hops, nhip, {})\n                     (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>2 s =\n                       \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, {}) \\<and>\n                       (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, {})\n                        < \\<pi>\\<^sub>5 s \\<or>\n                        \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                    then rt(dip \\<mapsto>\n                         addpre (dsn, dsk, flag, hops, nhip, {})\n                          (\\<pi>\\<^sub>7 s))\n                    else if \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, {}) =\n                            unk\n                         then rt(dip \\<mapsto>\n                              (\\<pi>\\<^sub>2 s,\n                               snd (addpre (dsn, dsk, flag, hops, nhip, {})\n                                     (\\<pi>\\<^sub>7 s))))\n                         else rt(dip \\<mapsto>\n                              addpre s\n                               (\\<pi>\\<^sub>7\n                                 (dsn, dsk, flag, hops, nhip, {}))))\n          dip) =\n    nhip", "by auto"], ["proof (state)\nthis:\n  the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  the (nhop (update rt dip (dsn, dsk, flag, hops, nhip, {})) dip) = nhip\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sqn_if_updated:\n  fixes rip v rt ip\n  shows \"sqn (\\<lambda>x. if x = rip then Some v else rt x) ip\n         = (if ip = rip then \\<pi>\\<^sub>2(v) else sqn rt ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn (\\<lambda>x. if x = rip then Some v else rt x) ip =\n    (if ip = rip then \\<pi>\\<^sub>2 v else sqn rt ip)", "unfolding sqn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case if ip = rip then Some v else rt ip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    (if ip = rip then \\<pi>\\<^sub>2 v\n     else case rt ip of None \\<Rightarrow> 0\n          | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)", "by simp"], ["", "lemma update_sqn [simp]:\n  fixes rt dip rip dsn dsk hops nhip pre\n  assumes \"(dsn = 0) = (dsk = unk)\"\n  shows \"sqn rt dip \\<le> sqn (update rt rip (dsn, dsk, val, hops, nhip, pre)) dip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn rt dip\n    \\<le> sqn (update rt rip (dsn, dsk, val, hops, nhip, pre)) dip", "proof (rule update_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. (\\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) = 0) =\n    (\\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = unk)\n 2. rip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip\n    \\<le> sqn (rt(rip \\<mapsto> (dsn, dsk, val, hops, nhip, pre))) dip\n 3. \\<lbrakk>rip \\<in> kD rt;\n     sqn rt rip < \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre)\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (dsn, dsk, val, hops, nhip, pre)\n                                  (\\<pi>\\<^sub>7 (the (rt rip)))))\n                             dip\n 4. \\<lbrakk>rip \\<in> kD rt;\n     sqn rt rip = \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre);\n     \\<pi>\\<^sub>5 (dsn, dsk, val, hops, nhip, pre)\n     < the (dhops rt rip)\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (dsn, dsk, val, hops, nhip, pre)\n                                  (\\<pi>\\<^sub>7 (the (rt rip)))))\n                             dip\n 5. \\<lbrakk>rip \\<in> kD rt;\n     sqn rt rip = \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre);\n     the (flag rt rip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (dsn, dsk, val, hops, nhip, pre)\n                                  (\\<pi>\\<^sub>7 (the (rt rip)))))\n                             dip\n 6. \\<lbrakk>rip \\<in> kD rt;\n     \\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = unk\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 (\\<pi>\\<^sub>2 (the (rt rip)),\n                                  \\<pi>\\<^sub>3\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>4\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>5\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>6\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>7\n                                   (addpre (dsn, dsk, val, hops, nhip, pre)\n                                     (\\<pi>\\<^sub>7 (the (rt rip)))))))\n                             dip\n 7. \\<lbrakk>rip \\<in> kD rt;\n     \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) \\<le> sqn rt rip;\n     \\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = kno;\n     sqn rt rip =\n     \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) \\<Longrightarrow>\n     the (dhops rt rip)\n     \\<le> \\<pi>\\<^sub>5 (dsn, dsk, val, hops, nhip, pre) \\<and>\n     the (flag rt rip) = val\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (the (rt rip))\n                                  (\\<pi>\\<^sub>7\n                                    (dsn, dsk, val, hops, nhip, pre))))\n                             dip", "show \"(\\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) = 0) = (\\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = unk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) = 0) =\n    (\\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = unk)", "by simp (rule assms)"], ["proof (state)\nthis:\n  (\\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) = 0) =\n  (\\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = unk)\n\ngoal (6 subgoals):\n 1. rip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip\n    \\<le> sqn (rt(rip \\<mapsto> (dsn, dsk, val, hops, nhip, pre))) dip\n 2. \\<lbrakk>rip \\<in> kD rt;\n     sqn rt rip < \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre)\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (dsn, dsk, val, hops, nhip, pre)\n                                  (\\<pi>\\<^sub>7 (the (rt rip)))))\n                             dip\n 3. \\<lbrakk>rip \\<in> kD rt;\n     sqn rt rip = \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre);\n     \\<pi>\\<^sub>5 (dsn, dsk, val, hops, nhip, pre)\n     < the (dhops rt rip)\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (dsn, dsk, val, hops, nhip, pre)\n                                  (\\<pi>\\<^sub>7 (the (rt rip)))))\n                             dip\n 4. \\<lbrakk>rip \\<in> kD rt;\n     sqn rt rip = \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre);\n     the (flag rt rip) = Aodv_Basic.inv\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (dsn, dsk, val, hops, nhip, pre)\n                                  (\\<pi>\\<^sub>7 (the (rt rip)))))\n                             dip\n 5. \\<lbrakk>rip \\<in> kD rt;\n     \\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = unk\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 (\\<pi>\\<^sub>2 (the (rt rip)),\n                                  \\<pi>\\<^sub>3\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>4\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>5\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>6\n                                   (dsn, dsk, val, hops, nhip, pre),\n                                  \\<pi>\\<^sub>7\n                                   (addpre (dsn, dsk, val, hops, nhip, pre)\n                                     (\\<pi>\\<^sub>7 (the (rt rip)))))))\n                             dip\n 6. \\<lbrakk>rip \\<in> kD rt;\n     \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) \\<le> sqn rt rip;\n     \\<pi>\\<^sub>3 (dsn, dsk, val, hops, nhip, pre) = kno;\n     sqn rt rip =\n     \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre) \\<Longrightarrow>\n     the (dhops rt rip)\n     \\<le> \\<pi>\\<^sub>5 (dsn, dsk, val, hops, nhip, pre) \\<and>\n     the (flag rt rip) = val\\<rbrakk>\n    \\<Longrightarrow> sqn rt dip\n                      \\<le> sqn (rt(rip \\<mapsto>\n                                 addpre (the (rt rip))\n                                  (\\<pi>\\<^sub>7\n                                    (dsn, dsk, val, hops, nhip, pre))))\n                             dip", "qed (clarsimp simp: sqn_if_updated sqn_def)+"], ["", "lemma sqn_update_bigger [simp]:\n    fixes rt ip ip' dsn dsk flag hops nhip pre\n  assumes \"1 \\<le> hops\"\n    shows \"sqn rt ip \\<le> sqn (update rt ip' (dsn, dsk, flag, hops, nhip, pre)) ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn rt ip \\<le> sqn (update rt ip' (dsn, dsk, flag, hops, nhip, pre)) ip", "using assms"], ["proof (prove)\nusing this:\n  1 \\<le> hops\n\ngoal (1 subgoal):\n 1. sqn rt ip \\<le> sqn (update rt ip' (dsn, dsk, flag, hops, nhip, pre)) ip", "unfolding update_def sqn_def"], ["proof (prove)\nusing this:\n  1 \\<le> hops\n\ngoal (1 subgoal):\n 1. (case rt ip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)\n    \\<le> (case (case rt ip' of\n                 None \\<Rightarrow> rt(ip' \\<mapsto>\n                   (dsn, dsk, flag, hops, nhip, pre))\n                 | Some s \\<Rightarrow>\n                     if \\<pi>\\<^sub>2 s\n                        < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n                     then rt(ip' \\<mapsto>\n                          addpre (dsn, dsk, flag, hops, nhip, pre)\n                           (\\<pi>\\<^sub>7 s))\n                     else if \\<pi>\\<^sub>2 s =\n                             \\<pi>\\<^sub>2\n                              (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                             (\\<pi>\\<^sub>5\n                               (dsn, dsk, flag, hops, nhip, pre)\n                              < \\<pi>\\<^sub>5 s \\<or>\n                              \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                          then rt(ip' \\<mapsto>\n                               addpre (dsn, dsk, flag, hops, nhip, pre)\n                                (\\<pi>\\<^sub>7 s))\n                          else if \\<pi>\\<^sub>3\n                                   (dsn, dsk, flag, hops, nhip, pre) =\n                                  unk\n                               then rt(ip' \\<mapsto>\n                                    (\\<pi>\\<^sub>2 s,\n                                     snd\n(addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))))\n                               else rt(ip' \\<mapsto>\n                                    addpre s\n                                     (\\<pi>\\<^sub>7\n (dsn, dsk, flag, hops, nhip, pre))))\n                 ip of\n           None \\<Rightarrow> 0 | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)", "by (clarsimp split: option.split) auto"], ["", "lemma dhops_update [intro]:\n    fixes rt dsn dsk flag hops ip rip nhip pre\n  assumes ex: \"\\<forall>ip\\<in>kD rt. the (dhops rt ip) \\<ge> 1\"\n      and ip: \"(ip = rip \\<and> Suc 0 \\<le> hops) \\<or> (ip \\<noteq> rip \\<and> ip\\<in>kD rt)\"\n    shows \"Suc 0 \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "using ip"], ["proof (prove)\nusing this:\n  ip = rip \\<and> Suc 0 \\<le> hops \\<or>\n  ip \\<noteq> rip \\<and> ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ip = rip \\<and> Suc 0 \\<le> hops \\<Longrightarrow>\n    Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)\n 2. ip \\<noteq> rip \\<and> ip \\<in> kD rt \\<Longrightarrow>\n    Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "assume \"ip = rip \\<and> Suc 0 \\<le> hops\""], ["proof (state)\nthis:\n  ip = rip \\<and> Suc 0 \\<le> hops\n\ngoal (2 subgoals):\n 1. ip = rip \\<and> Suc 0 \\<le> hops \\<Longrightarrow>\n    Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)\n 2. ip \\<noteq> rip \\<and> ip \\<in> kD rt \\<Longrightarrow>\n    Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ip = rip \\<and> Suc 0 \\<le> hops\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "unfolding update_def"], ["proof (prove)\nusing this:\n  ip = rip \\<and> Suc 0 \\<le> hops\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops\n                (case rt rip of\n                 None \\<Rightarrow> rt(rip \\<mapsto>\n                   (dsn, dsk, flag, hops, nhip, pre))\n                 | Some s \\<Rightarrow>\n                     if \\<pi>\\<^sub>2 s\n                        < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n                     then rt(rip \\<mapsto>\n                          addpre (dsn, dsk, flag, hops, nhip, pre)\n                           (\\<pi>\\<^sub>7 s))\n                     else if \\<pi>\\<^sub>2 s =\n                             \\<pi>\\<^sub>2\n                              (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                             (\\<pi>\\<^sub>5\n                               (dsn, dsk, flag, hops, nhip, pre)\n                              < \\<pi>\\<^sub>5 s \\<or>\n                              \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                          then rt(rip \\<mapsto>\n                               addpre (dsn, dsk, flag, hops, nhip, pre)\n                                (\\<pi>\\<^sub>7 s))\n                          else if \\<pi>\\<^sub>3\n                                   (dsn, dsk, flag, hops, nhip, pre) =\n                                  unk\n                               then rt(rip \\<mapsto>\n                                    (\\<pi>\\<^sub>2 s,\n                                     snd\n(addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))))\n                               else rt(rip \\<mapsto>\n                                    addpre s\n                                     (\\<pi>\\<^sub>7\n (dsn, dsk, flag, hops, nhip, pre))))\n                ip)", "using ex"], ["proof (prove)\nusing this:\n  ip = rip \\<and> Suc 0 \\<le> hops\n  \\<forall>ip\\<in>kD rt. 1 \\<le> the (dhops rt ip)\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops\n                (case rt rip of\n                 None \\<Rightarrow> rt(rip \\<mapsto>\n                   (dsn, dsk, flag, hops, nhip, pre))\n                 | Some s \\<Rightarrow>\n                     if \\<pi>\\<^sub>2 s\n                        < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n                     then rt(rip \\<mapsto>\n                          addpre (dsn, dsk, flag, hops, nhip, pre)\n                           (\\<pi>\\<^sub>7 s))\n                     else if \\<pi>\\<^sub>2 s =\n                             \\<pi>\\<^sub>2\n                              (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                             (\\<pi>\\<^sub>5\n                               (dsn, dsk, flag, hops, nhip, pre)\n                              < \\<pi>\\<^sub>5 s \\<or>\n                              \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                          then rt(rip \\<mapsto>\n                               addpre (dsn, dsk, flag, hops, nhip, pre)\n                                (\\<pi>\\<^sub>7 s))\n                          else if \\<pi>\\<^sub>3\n                                   (dsn, dsk, flag, hops, nhip, pre) =\n                                  unk\n                               then rt(rip \\<mapsto>\n                                    (\\<pi>\\<^sub>2 s,\n                                     snd\n(addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))))\n                               else rt(rip \\<mapsto>\n                                    addpre s\n                                     (\\<pi>\\<^sub>7\n (dsn, dsk, flag, hops, nhip, pre))))\n                ip)", "by (cases \"rip \\<in> kD rt\") (drule(1) bspec, auto)"], ["proof (state)\nthis:\n  Suc 0\n  \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)\n\ngoal (1 subgoal):\n 1. ip \\<noteq> rip \\<and> ip \\<in> kD rt \\<Longrightarrow>\n    Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ip \\<noteq> rip \\<and> ip \\<in> kD rt \\<Longrightarrow>\n    Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "assume \"ip \\<noteq> rip \\<and> ip\\<in>kD rt\""], ["proof (state)\nthis:\n  ip \\<noteq> rip \\<and> ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. ip \\<noteq> rip \\<and> ip \\<in> kD rt \\<Longrightarrow>\n    Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ip \\<noteq> rip \\<and> ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "using ex"], ["proof (prove)\nusing this:\n  ip \\<noteq> rip \\<and> ip \\<in> kD rt\n  \\<forall>ip\\<in>kD rt. 1 \\<le> the (dhops rt ip)\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)", "unfolding update_def"], ["proof (prove)\nusing this:\n  ip \\<noteq> rip \\<and> ip \\<in> kD rt\n  \\<forall>ip\\<in>kD rt. 1 \\<le> the (dhops rt ip)\n\ngoal (1 subgoal):\n 1. Suc 0\n    \\<le> the (dhops\n                (case rt rip of\n                 None \\<Rightarrow> rt(rip \\<mapsto>\n                   (dsn, dsk, flag, hops, nhip, pre))\n                 | Some s \\<Rightarrow>\n                     if \\<pi>\\<^sub>2 s\n                        < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n                     then rt(rip \\<mapsto>\n                          addpre (dsn, dsk, flag, hops, nhip, pre)\n                           (\\<pi>\\<^sub>7 s))\n                     else if \\<pi>\\<^sub>2 s =\n                             \\<pi>\\<^sub>2\n                              (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                             (\\<pi>\\<^sub>5\n                               (dsn, dsk, flag, hops, nhip, pre)\n                              < \\<pi>\\<^sub>5 s \\<or>\n                              \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                          then rt(rip \\<mapsto>\n                               addpre (dsn, dsk, flag, hops, nhip, pre)\n                                (\\<pi>\\<^sub>7 s))\n                          else if \\<pi>\\<^sub>3\n                                   (dsn, dsk, flag, hops, nhip, pre) =\n                                  unk\n                               then rt(rip \\<mapsto>\n                                    (\\<pi>\\<^sub>2 s,\n                                     snd\n(addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))))\n                               else rt(rip \\<mapsto>\n                                    addpre s\n                                     (\\<pi>\\<^sub>7\n (dsn, dsk, flag, hops, nhip, pre))))\n                ip)", "by (cases \"rip\\<in>kD rt\") auto"], ["proof (state)\nthis:\n  Suc 0\n  \\<le> the (dhops (update rt rip (dsn, dsk, flag, hops, nhip, pre)) ip)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"(update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update rt dip (dsn, dsk, flag, hops, nhip, pre) ip = rt ip", "using assms"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. update rt dip (dsn, dsk, flag, hops, nhip, pre) ip = rt ip", "unfolding update_def"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. (case rt dip of\n     None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flag, hops, nhip, pre))\n     | Some s \\<Rightarrow>\n         if \\<pi>\\<^sub>2 s\n            < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n         then rt(dip \\<mapsto>\n              addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))\n         else if \\<pi>\\<^sub>2 s =\n                 \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                 (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre)\n                  < \\<pi>\\<^sub>5 s \\<or>\n                  \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n              then rt(dip \\<mapsto>\n                   addpre (dsn, dsk, flag, hops, nhip, pre)\n                    (\\<pi>\\<^sub>7 s))\n              else if \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, pre) = unk\n                   then rt(dip \\<mapsto>\n                        (\\<pi>\\<^sub>2 s,\n                         snd (addpre (dsn, dsk, flag, hops, nhip, pre)\n                               (\\<pi>\\<^sub>7 s))))\n                   else rt(dip \\<mapsto>\n                        addpre s\n                         (\\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, pre))))\n     ip =\n    rt ip", "by (clarsimp split: option.split)"], ["", "lemma nhop_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"nhop (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = nhop rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nhop (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = nhop rt ip", "using assms"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. nhop (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = nhop rt ip", "unfolding update_def"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. nhop\n     (case rt dip of\n      None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flag, hops, nhip, pre))\n      | Some s \\<Rightarrow>\n          if \\<pi>\\<^sub>2 s\n             < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n          then rt(dip \\<mapsto>\n               addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))\n          else if \\<pi>\\<^sub>2 s =\n                  \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                  (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre)\n                   < \\<pi>\\<^sub>5 s \\<or>\n                   \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n               then rt(dip \\<mapsto>\n                    addpre (dsn, dsk, flag, hops, nhip, pre)\n                     (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, pre) = unk\n                    then rt(dip \\<mapsto>\n                         (\\<pi>\\<^sub>2 s,\n                          snd (addpre (dsn, dsk, flag, hops, nhip, pre)\n                                (\\<pi>\\<^sub>7 s))))\n                    else rt(dip \\<mapsto>\n                         addpre s\n                          (\\<pi>\\<^sub>7\n                            (dsn, dsk, flag, hops, nhip, pre))))\n     ip =\n    nhop rt ip", "by (clarsimp split: option.split)"], ["", "lemma dhops_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"dhops (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = dhops rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dhops (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = dhops rt ip", "using assms"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. dhops (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = dhops rt ip", "unfolding update_def"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. dhops\n     (case rt dip of\n      None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flag, hops, nhip, pre))\n      | Some s \\<Rightarrow>\n          if \\<pi>\\<^sub>2 s\n             < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n          then rt(dip \\<mapsto>\n               addpre (dsn, dsk, flag, hops, nhip, pre) (\\<pi>\\<^sub>7 s))\n          else if \\<pi>\\<^sub>2 s =\n                  \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                  (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre)\n                   < \\<pi>\\<^sub>5 s \\<or>\n                   \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n               then rt(dip \\<mapsto>\n                    addpre (dsn, dsk, flag, hops, nhip, pre)\n                     (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, pre) = unk\n                    then rt(dip \\<mapsto>\n                         (\\<pi>\\<^sub>2 s,\n                          snd (addpre (dsn, dsk, flag, hops, nhip, pre)\n                                (\\<pi>\\<^sub>7 s))))\n                    else rt(dip \\<mapsto>\n                         addpre s\n                          (\\<pi>\\<^sub>7\n                            (dsn, dsk, flag, hops, nhip, pre))))\n     ip =\n    dhops rt ip", "by (clarsimp split: option.split)"], ["", "lemma sqn_update_same [simp]:\n  \"\\<And>rt ip dsn dsk flag hops nhip pre. sqn (rt(ip \\<mapsto> v)) ip = \\<pi>\\<^sub>2(v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt ip dsn dsk flag hops nhip pre.\n       sqn (rt(ip \\<mapsto> v)) ip = \\<pi>\\<^sub>2 v", "unfolding sqn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt ip dsn dsk flag hops nhip pre.\n       (case (rt(ip \\<mapsto> v)) ip of None \\<Rightarrow> 0\n        | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n       \\<pi>\\<^sub>2 v", "by simp"], ["", "lemma dhops_update_changed [simp]:\n    fixes rt dip osn hops nhip\n  assumes \"rt \\<noteq> update rt dip (osn, kno, val, hops, nhip, {})\"\n    shows \"the (dhops (update rt dip (osn, kno, val, hops, nhip, {})) dip) = hops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (dhops (update rt dip (osn, kno, val, hops, nhip, {})) dip) = hops", "using assms"], ["proof (prove)\nusing this:\n  rt \\<noteq> update rt dip (osn, kno, val, hops, nhip, {})\n\ngoal (1 subgoal):\n 1. the (dhops (update rt dip (osn, kno, val, hops, nhip, {})) dip) = hops", "unfolding update_def"], ["proof (prove)\nusing this:\n  rt \\<noteq>\n  (case rt dip of\n   None \\<Rightarrow> rt(dip \\<mapsto> (osn, kno, val, hops, nhip, {}))\n   | Some s \\<Rightarrow>\n       if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 (osn, kno, val, hops, nhip, {})\n       then rt(dip \\<mapsto>\n            addpre (osn, kno, val, hops, nhip, {}) (\\<pi>\\<^sub>7 s))\n       else if \\<pi>\\<^sub>2 s =\n               \\<pi>\\<^sub>2 (osn, kno, val, hops, nhip, {}) \\<and>\n               (\\<pi>\\<^sub>5 (osn, kno, val, hops, nhip, {})\n                < \\<pi>\\<^sub>5 s \\<or>\n                \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n            then rt(dip \\<mapsto>\n                 addpre (osn, kno, val, hops, nhip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>3 (osn, kno, val, hops, nhip, {}) = unk\n                 then rt(dip \\<mapsto>\n                      (\\<pi>\\<^sub>2 s,\n                       snd (addpre (osn, kno, val, hops, nhip, {})\n                             (\\<pi>\\<^sub>7 s))))\n                 else rt(dip \\<mapsto>\n                      addpre s\n                       (\\<pi>\\<^sub>7 (osn, kno, val, hops, nhip, {}))))\n\ngoal (1 subgoal):\n 1. the (dhops\n          (case rt dip of\n           None \\<Rightarrow> rt(dip \\<mapsto>\n             (osn, kno, val, hops, nhip, {}))\n           | Some s \\<Rightarrow>\n               if \\<pi>\\<^sub>2 s\n                  < \\<pi>\\<^sub>2 (osn, kno, val, hops, nhip, {})\n               then rt(dip \\<mapsto>\n                    addpre (osn, kno, val, hops, nhip, {})\n                     (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>2 s =\n                       \\<pi>\\<^sub>2 (osn, kno, val, hops, nhip, {}) \\<and>\n                       (\\<pi>\\<^sub>5 (osn, kno, val, hops, nhip, {})\n                        < \\<pi>\\<^sub>5 s \\<or>\n                        \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                    then rt(dip \\<mapsto>\n                         addpre (osn, kno, val, hops, nhip, {})\n                          (\\<pi>\\<^sub>7 s))\n                    else if \\<pi>\\<^sub>3 (osn, kno, val, hops, nhip, {}) =\n                            unk\n                         then rt(dip \\<mapsto>\n                              (\\<pi>\\<^sub>2 s,\n                               snd (addpre (osn, kno, val, hops, nhip, {})\n                                     (\\<pi>\\<^sub>7 s))))\n                         else rt(dip \\<mapsto>\n                              addpre s\n                               (\\<pi>\\<^sub>7\n                                 (osn, kno, val, hops, nhip, {}))))\n          dip) =\n    hops", "by (clarsimp split: option.split_asm option.split if_split_asm) auto"], ["", "lemma nhop_update_unk_val [simp]:\n  \"\\<And>rt dip ip dsn hops npre.\n   the (nhop (update rt dip (dsn, unk, val, hops, ip, npre)) dip) = ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip ip dsn hops npre.\n       the (nhop (update rt dip (dsn, unk, val, hops, ip, npre)) dip) = ip", "unfolding update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip ip dsn hops npre.\n       the (nhop\n             (case rt dip of\n              None \\<Rightarrow> rt(dip \\<mapsto>\n                (dsn, unk, val, hops, ip, npre))\n              | Some s \\<Rightarrow>\n                  if \\<pi>\\<^sub>2 s\n                     < \\<pi>\\<^sub>2 (dsn, unk, val, hops, ip, npre)\n                  then rt(dip \\<mapsto>\n                       addpre (dsn, unk, val, hops, ip, npre)\n                        (\\<pi>\\<^sub>7 s))\n                  else if \\<pi>\\<^sub>2 s =\n                          \\<pi>\\<^sub>2\n                           (dsn, unk, val, hops, ip, npre) \\<and>\n                          (\\<pi>\\<^sub>5 (dsn, unk, val, hops, ip, npre)\n                           < \\<pi>\\<^sub>5 s \\<or>\n                           \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                       then rt(dip \\<mapsto>\n                            addpre (dsn, unk, val, hops, ip, npre)\n                             (\\<pi>\\<^sub>7 s))\n                       else if \\<pi>\\<^sub>3\n                                (dsn, unk, val, hops, ip, npre) =\n                               unk\n                            then rt(dip \\<mapsto>\n                                 (\\<pi>\\<^sub>2 s,\n                                  snd (addpre\n  (dsn, unk, val, hops, ip, npre) (\\<pi>\\<^sub>7 s))))\n                            else rt(dip \\<mapsto>\n                                 addpre s\n                                  (\\<pi>\\<^sub>7\n                                    (dsn, unk, val, hops, ip, npre))))\n             dip) =\n       ip", "by (clarsimp split: option.split)"], ["", "lemma nhop_update_changed [simp]:\n    fixes rt dip dsn dsk flg hops sip\n  assumes \"update rt dip (dsn, dsk, flg, hops, sip, {}) \\<noteq> rt\"\n    shows \"the (nhop (update rt dip (dsn, dsk, flg, hops, sip, {})) dip) = sip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flg, hops, sip, {})) dip) = sip", "using assms"], ["proof (prove)\nusing this:\n  update rt dip (dsn, dsk, flg, hops, sip, {}) \\<noteq> rt\n\ngoal (1 subgoal):\n 1. the (nhop (update rt dip (dsn, dsk, flg, hops, sip, {})) dip) = sip", "unfolding update_def"], ["proof (prove)\nusing this:\n  (case rt dip of\n   None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flg, hops, sip, {}))\n   | Some s \\<Rightarrow>\n       if \\<pi>\\<^sub>2 s < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n       then rt(dip \\<mapsto>\n            addpre (dsn, dsk, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n       else if \\<pi>\\<^sub>2 s =\n               \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {}) \\<and>\n               (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                < \\<pi>\\<^sub>5 s \\<or>\n                \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n            then rt(dip \\<mapsto>\n                 addpre (dsn, dsk, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>3 (dsn, dsk, flg, hops, sip, {}) = unk\n                 then rt(dip \\<mapsto>\n                      (\\<pi>\\<^sub>2 s,\n                       snd (addpre (dsn, dsk, flg, hops, sip, {})\n                             (\\<pi>\\<^sub>7 s))))\n                 else rt(dip \\<mapsto>\n                      addpre s\n                       (\\<pi>\\<^sub>7\n                         (dsn, dsk, flg, hops, sip, {})))) \\<noteq>\n  rt\n\ngoal (1 subgoal):\n 1. the (nhop\n          (case rt dip of\n           None \\<Rightarrow> rt(dip \\<mapsto>\n             (dsn, dsk, flg, hops, sip, {}))\n           | Some s \\<Rightarrow>\n               if \\<pi>\\<^sub>2 s\n                  < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n               then rt(dip \\<mapsto>\n                    addpre (dsn, dsk, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>2 s =\n                       \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {}) \\<and>\n                       (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                        < \\<pi>\\<^sub>5 s \\<or>\n                        \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                    then rt(dip \\<mapsto>\n                         addpre (dsn, dsk, flg, hops, sip, {})\n                          (\\<pi>\\<^sub>7 s))\n                    else if \\<pi>\\<^sub>3 (dsn, dsk, flg, hops, sip, {}) =\n                            unk\n                         then rt(dip \\<mapsto>\n                              (\\<pi>\\<^sub>2 s,\n                               snd (addpre (dsn, dsk, flg, hops, sip, {})\n                                     (\\<pi>\\<^sub>7 s))))\n                         else rt(dip \\<mapsto>\n                              addpre s\n                               (\\<pi>\\<^sub>7\n                                 (dsn, dsk, flg, hops, sip, {}))))\n          dip) =\n    sip", "by (clarsimp split: option.splits if_split_asm) auto"], ["", "lemma update_rt_split_asm:\n  \"\\<And>rt ip dsn dsk flag hops sip.\n   P (update rt ip (dsn, dsk, flag, hops, sip, {}))\n   =\n   (\\<not>(rt = update rt ip (dsn, dsk, flag, hops, sip, {}) \\<and> \\<not>P rt\n      \\<or> rt \\<noteq> update rt ip (dsn, dsk, flag, hops, sip, {})\n         \\<and> \\<not>P (update rt ip (dsn, dsk, flag, hops, sip, {}))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt ip dsn dsk flag hops sip.\n       P (update rt ip (dsn, dsk, flag, hops, sip, {})) =\n       (\\<not> (rt = update rt ip (dsn, dsk, flag, hops, sip, {}) \\<and>\n                \\<not> P rt \\<or>\n                rt \\<noteq>\n                update rt ip (dsn, dsk, flag, hops, sip, {}) \\<and>\n                \\<not> P (update rt ip (dsn, dsk, flag, hops, sip, {}))))", "by auto"], ["", "lemma sqn_update [simp]: \"\\<And>rt dip dsn flg hops sip.\n  rt \\<noteq> update rt dip (dsn, kno, flg, hops, sip, {})\n  \\<Longrightarrow> sqn (update rt dip (dsn, kno, flg, hops, sip, {})) dip = dsn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn flg hops sip.\n       rt \\<noteq>\n       update rt dip (dsn, kno, flg, hops, sip, {}) \\<Longrightarrow>\n       sqn (update rt dip (dsn, kno, flg, hops, sip, {})) dip = dsn", "unfolding update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn flg hops sip.\n       rt \\<noteq>\n       (case rt dip of\n        None \\<Rightarrow> rt(dip \\<mapsto> (dsn, kno, flg, hops, sip, {}))\n        | Some s \\<Rightarrow>\n            if \\<pi>\\<^sub>2 s\n               < \\<pi>\\<^sub>2 (dsn, kno, flg, hops, sip, {})\n            then rt(dip \\<mapsto>\n                 addpre (dsn, kno, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>2 s =\n                    \\<pi>\\<^sub>2 (dsn, kno, flg, hops, sip, {}) \\<and>\n                    (\\<pi>\\<^sub>5 (dsn, kno, flg, hops, sip, {})\n                     < \\<pi>\\<^sub>5 s \\<or>\n                     \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                 then rt(dip \\<mapsto>\n                      addpre (dsn, kno, flg, hops, sip, {})\n                       (\\<pi>\\<^sub>7 s))\n                 else if \\<pi>\\<^sub>3 (dsn, kno, flg, hops, sip, {}) = unk\n                      then rt(dip \\<mapsto>\n                           (\\<pi>\\<^sub>2 s,\n                            snd (addpre (dsn, kno, flg, hops, sip, {})\n                                  (\\<pi>\\<^sub>7 s))))\n                      else rt(dip \\<mapsto>\n                           addpre s\n                            (\\<pi>\\<^sub>7\n                              (dsn, kno, flg, hops, sip,\n                               {})))) \\<Longrightarrow>\n       sqn (case rt dip of\n            None \\<Rightarrow> rt(dip \\<mapsto>\n              (dsn, kno, flg, hops, sip, {}))\n            | Some s \\<Rightarrow>\n                if \\<pi>\\<^sub>2 s\n                   < \\<pi>\\<^sub>2 (dsn, kno, flg, hops, sip, {})\n                then rt(dip \\<mapsto>\n                     addpre (dsn, kno, flg, hops, sip, {})\n                      (\\<pi>\\<^sub>7 s))\n                else if \\<pi>\\<^sub>2 s =\n                        \\<pi>\\<^sub>2 (dsn, kno, flg, hops, sip, {}) \\<and>\n                        (\\<pi>\\<^sub>5 (dsn, kno, flg, hops, sip, {})\n                         < \\<pi>\\<^sub>5 s \\<or>\n                         \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                     then rt(dip \\<mapsto>\n                          addpre (dsn, kno, flg, hops, sip, {})\n                           (\\<pi>\\<^sub>7 s))\n                     else if \\<pi>\\<^sub>3 (dsn, kno, flg, hops, sip, {}) =\n                             unk\n                          then rt(dip \\<mapsto>\n                               (\\<pi>\\<^sub>2 s,\n                                snd (addpre (dsn, kno, flg, hops, sip, {})\n(\\<pi>\\<^sub>7 s))))\n                          else rt(dip \\<mapsto>\n                               addpre s\n                                (\\<pi>\\<^sub>7\n                                  (dsn, kno, flg, hops, sip, {}))))\n        dip =\n       dsn", "by (clarsimp split: option.split if_split_asm) auto"], ["", "lemma sqnf_update [simp]: \"\\<And>rt dip dsn dsk flg hops sip.\n  rt \\<noteq> update rt dip (dsn, dsk, flg, hops, sip, {})\n  \\<Longrightarrow> sqnf (update rt dip (dsn, dsk, flg, hops, sip, {})) dip = dsk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn dsk flg hops sip.\n       rt \\<noteq>\n       update rt dip (dsn, dsk, flg, hops, sip, {}) \\<Longrightarrow>\n       sqnf (update rt dip (dsn, dsk, flg, hops, sip, {})) dip = dsk", "unfolding update_def sqnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn dsk flg hops sip.\n       rt \\<noteq>\n       (case rt dip of\n        None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flg, hops, sip, {}))\n        | Some s \\<Rightarrow>\n            if \\<pi>\\<^sub>2 s\n               < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n            then rt(dip \\<mapsto>\n                 addpre (dsn, dsk, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>2 s =\n                    \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {}) \\<and>\n                    (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                     < \\<pi>\\<^sub>5 s \\<or>\n                     \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                 then rt(dip \\<mapsto>\n                      addpre (dsn, dsk, flg, hops, sip, {})\n                       (\\<pi>\\<^sub>7 s))\n                 else if \\<pi>\\<^sub>3 (dsn, dsk, flg, hops, sip, {}) = unk\n                      then rt(dip \\<mapsto>\n                           (\\<pi>\\<^sub>2 s,\n                            snd (addpre (dsn, dsk, flg, hops, sip, {})\n                                  (\\<pi>\\<^sub>7 s))))\n                      else rt(dip \\<mapsto>\n                           addpre s\n                            (\\<pi>\\<^sub>7\n                              (dsn, dsk, flg, hops, sip,\n                               {})))) \\<Longrightarrow>\n       (case (case rt dip of\n              None \\<Rightarrow> rt(dip \\<mapsto>\n                (dsn, dsk, flg, hops, sip, {}))\n              | Some s \\<Rightarrow>\n                  if \\<pi>\\<^sub>2 s\n                     < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n                  then rt(dip \\<mapsto>\n                       addpre (dsn, dsk, flg, hops, sip, {})\n                        (\\<pi>\\<^sub>7 s))\n                  else if \\<pi>\\<^sub>2 s =\n                          \\<pi>\\<^sub>2\n                           (dsn, dsk, flg, hops, sip, {}) \\<and>\n                          (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                           < \\<pi>\\<^sub>5 s \\<or>\n                           \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                       then rt(dip \\<mapsto>\n                            addpre (dsn, dsk, flg, hops, sip, {})\n                             (\\<pi>\\<^sub>7 s))\n                       else if \\<pi>\\<^sub>3\n                                (dsn, dsk, flg, hops, sip, {}) =\n                               unk\n                            then rt(dip \\<mapsto>\n                                 (\\<pi>\\<^sub>2 s,\n                                  snd (addpre (dsn, dsk, flg, hops, sip, {})\n  (\\<pi>\\<^sub>7 s))))\n                            else rt(dip \\<mapsto>\n                                 addpre s\n                                  (\\<pi>\\<^sub>7\n                                    (dsn, dsk, flg, hops, sip, {}))))\n              dip of\n        None \\<Rightarrow> unk | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r) =\n       dsk", "by (clarsimp split: option.splits if_split_asm) auto"], ["", "lemma update_kno_dsn_greater_zero:\n  \"\\<And>rt dip ip dsn hops npre. 1 \\<le> dsn \\<Longrightarrow> 1 \\<le> (sqn (update rt dip (dsn, kno, val, hops, ip, npre)) dip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip ip dsn hops npre.\n       1 \\<le> dsn \\<Longrightarrow>\n       1 \\<le> sqn (update rt dip (dsn, kno, val, hops, ip, npre)) dip", "unfolding update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip ip dsn hops npre.\n       1 \\<le> dsn \\<Longrightarrow>\n       1 \\<le> sqn (case rt dip of\n                    None \\<Rightarrow> rt(dip \\<mapsto>\n                      (dsn, kno, val, hops, ip, npre))\n                    | Some s \\<Rightarrow>\n                        if \\<pi>\\<^sub>2 s\n                           < \\<pi>\\<^sub>2 (dsn, kno, val, hops, ip, npre)\n                        then rt(dip \\<mapsto>\n                             addpre (dsn, kno, val, hops, ip, npre)\n                              (\\<pi>\\<^sub>7 s))\n                        else if \\<pi>\\<^sub>2 s =\n                                \\<pi>\\<^sub>2\n                                 (dsn, kno, val, hops, ip, npre) \\<and>\n                                (\\<pi>\\<^sub>5\n                                  (dsn, kno, val, hops, ip, npre)\n                                 < \\<pi>\\<^sub>5 s \\<or>\n                                 \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                             then rt(dip \\<mapsto>\n                                  addpre (dsn, kno, val, hops, ip, npre)\n                                   (\\<pi>\\<^sub>7 s))\n                             else if \\<pi>\\<^sub>3\n(dsn, kno, val, hops, ip, npre) =\n                                     unk\n                                  then rt(dip \\<mapsto>\n (\\<pi>\\<^sub>2 s,\n  snd (addpre (dsn, kno, val, hops, ip, npre) (\\<pi>\\<^sub>7 s))))\n                                  else rt(dip \\<mapsto>\n addpre s (\\<pi>\\<^sub>7 (dsn, kno, val, hops, ip, npre))))\n                dip", "by (clarsimp split: option.splits)"], ["", "lemma proj3_update [simp]: \"\\<And>rt dip dsn dsk flg hops sip.\n  rt \\<noteq> update rt dip (dsn, dsk, flg, hops, sip, {})\n  \\<Longrightarrow> \\<pi>\\<^sub>3(the (update rt dip (dsn, dsk, flg, hops, sip, {}) dip)) = dsk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn dsk flg hops sip.\n       rt \\<noteq>\n       update rt dip (dsn, dsk, flg, hops, sip, {}) \\<Longrightarrow>\n       \\<pi>\\<^sub>3\n        (the (update rt dip (dsn, dsk, flg, hops, sip, {}) dip)) =\n       dsk", "unfolding update_def sqnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn dsk flg hops sip.\n       rt \\<noteq>\n       (case rt dip of\n        None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flg, hops, sip, {}))\n        | Some s \\<Rightarrow>\n            if \\<pi>\\<^sub>2 s\n               < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n            then rt(dip \\<mapsto>\n                 addpre (dsn, dsk, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>2 s =\n                    \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {}) \\<and>\n                    (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                     < \\<pi>\\<^sub>5 s \\<or>\n                     \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                 then rt(dip \\<mapsto>\n                      addpre (dsn, dsk, flg, hops, sip, {})\n                       (\\<pi>\\<^sub>7 s))\n                 else if \\<pi>\\<^sub>3 (dsn, dsk, flg, hops, sip, {}) = unk\n                      then rt(dip \\<mapsto>\n                           (\\<pi>\\<^sub>2 s,\n                            snd (addpre (dsn, dsk, flg, hops, sip, {})\n                                  (\\<pi>\\<^sub>7 s))))\n                      else rt(dip \\<mapsto>\n                           addpre s\n                            (\\<pi>\\<^sub>7\n                              (dsn, dsk, flg, hops, sip,\n                               {})))) \\<Longrightarrow>\n       \\<pi>\\<^sub>3\n        (the ((case rt dip of\n               None \\<Rightarrow> rt(dip \\<mapsto>\n                 (dsn, dsk, flg, hops, sip, {}))\n               | Some s \\<Rightarrow>\n                   if \\<pi>\\<^sub>2 s\n                      < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n                   then rt(dip \\<mapsto>\n                        addpre (dsn, dsk, flg, hops, sip, {})\n                         (\\<pi>\\<^sub>7 s))\n                   else if \\<pi>\\<^sub>2 s =\n                           \\<pi>\\<^sub>2\n                            (dsn, dsk, flg, hops, sip, {}) \\<and>\n                           (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                            < \\<pi>\\<^sub>5 s \\<or>\n                            \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                        then rt(dip \\<mapsto>\n                             addpre (dsn, dsk, flg, hops, sip, {})\n                              (\\<pi>\\<^sub>7 s))\n                        else if \\<pi>\\<^sub>3\n                                 (dsn, dsk, flg, hops, sip, {}) =\n                                unk\n                             then rt(dip \\<mapsto>\n                                  (\\<pi>\\<^sub>2 s,\n                                   snd (addpre\n   (dsn, dsk, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))))\n                             else rt(dip \\<mapsto>\n                                  addpre s\n                                   (\\<pi>\\<^sub>7\n                                     (dsn, dsk, flg, hops, sip, {}))))\n               dip)) =\n       dsk", "by (clarsimp split: option.splits if_split_asm) auto"], ["", "lemma nhop_update_changed_kno_val [simp]: \"\\<And>rt ip dsn dsk hops nhip.\n  rt \\<noteq> update rt ip (dsn, kno, val, hops, nhip, {})\n   \\<Longrightarrow> the (nhop (update rt ip (dsn, kno, val, hops, nhip, {})) ip) = nhip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt ip dsn dsk hops nhip.\n       rt \\<noteq>\n       update rt ip (dsn, kno, val, hops, nhip, {}) \\<Longrightarrow>\n       the (nhop (update rt ip (dsn, kno, val, hops, nhip, {})) ip) = nhip", "unfolding update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt ip dsn dsk hops nhip.\n       rt \\<noteq>\n       (case rt ip of\n        None \\<Rightarrow> rt(ip \\<mapsto> (dsn, kno, val, hops, nhip, {}))\n        | Some s \\<Rightarrow>\n            if \\<pi>\\<^sub>2 s\n               < \\<pi>\\<^sub>2 (dsn, kno, val, hops, nhip, {})\n            then rt(ip \\<mapsto>\n                 addpre (dsn, kno, val, hops, nhip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>2 s =\n                    \\<pi>\\<^sub>2 (dsn, kno, val, hops, nhip, {}) \\<and>\n                    (\\<pi>\\<^sub>5 (dsn, kno, val, hops, nhip, {})\n                     < \\<pi>\\<^sub>5 s \\<or>\n                     \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                 then rt(ip \\<mapsto>\n                      addpre (dsn, kno, val, hops, nhip, {})\n                       (\\<pi>\\<^sub>7 s))\n                 else if \\<pi>\\<^sub>3 (dsn, kno, val, hops, nhip, {}) = unk\n                      then rt(ip \\<mapsto>\n                           (\\<pi>\\<^sub>2 s,\n                            snd (addpre (dsn, kno, val, hops, nhip, {})\n                                  (\\<pi>\\<^sub>7 s))))\n                      else rt(ip \\<mapsto>\n                           addpre s\n                            (\\<pi>\\<^sub>7\n                              (dsn, kno, val, hops, nhip,\n                               {})))) \\<Longrightarrow>\n       the (nhop\n             (case rt ip of\n              None \\<Rightarrow> rt(ip \\<mapsto>\n                (dsn, kno, val, hops, nhip, {}))\n              | Some s \\<Rightarrow>\n                  if \\<pi>\\<^sub>2 s\n                     < \\<pi>\\<^sub>2 (dsn, kno, val, hops, nhip, {})\n                  then rt(ip \\<mapsto>\n                       addpre (dsn, kno, val, hops, nhip, {})\n                        (\\<pi>\\<^sub>7 s))\n                  else if \\<pi>\\<^sub>2 s =\n                          \\<pi>\\<^sub>2\n                           (dsn, kno, val, hops, nhip, {}) \\<and>\n                          (\\<pi>\\<^sub>5 (dsn, kno, val, hops, nhip, {})\n                           < \\<pi>\\<^sub>5 s \\<or>\n                           \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                       then rt(ip \\<mapsto>\n                            addpre (dsn, kno, val, hops, nhip, {})\n                             (\\<pi>\\<^sub>7 s))\n                       else if \\<pi>\\<^sub>3\n                                (dsn, kno, val, hops, nhip, {}) =\n                               unk\n                            then rt(ip \\<mapsto>\n                                 (\\<pi>\\<^sub>2 s,\n                                  snd (addpre\n  (dsn, kno, val, hops, nhip, {}) (\\<pi>\\<^sub>7 s))))\n                            else rt(ip \\<mapsto>\n                                 addpre s\n                                  (\\<pi>\\<^sub>7\n                                    (dsn, kno, val, hops, nhip, {}))))\n             ip) =\n       nhip", "by (clarsimp split: option.split_asm option.split if_split_asm) auto"], ["", "lemma flag_update [simp]: \"\\<And>rt dip dsn flg hops sip.\n  rt \\<noteq> update rt dip (dsn, kno, flg, hops, sip, {})\n  \\<Longrightarrow> the (flag (update rt dip (dsn, kno, flg, hops, sip, {})) dip) = flg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn flg hops sip.\n       rt \\<noteq>\n       update rt dip (dsn, kno, flg, hops, sip, {}) \\<Longrightarrow>\n       the (flag (update rt dip (dsn, kno, flg, hops, sip, {})) dip) = flg", "unfolding update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn flg hops sip.\n       rt \\<noteq>\n       (case rt dip of\n        None \\<Rightarrow> rt(dip \\<mapsto> (dsn, kno, flg, hops, sip, {}))\n        | Some s \\<Rightarrow>\n            if \\<pi>\\<^sub>2 s\n               < \\<pi>\\<^sub>2 (dsn, kno, flg, hops, sip, {})\n            then rt(dip \\<mapsto>\n                 addpre (dsn, kno, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>2 s =\n                    \\<pi>\\<^sub>2 (dsn, kno, flg, hops, sip, {}) \\<and>\n                    (\\<pi>\\<^sub>5 (dsn, kno, flg, hops, sip, {})\n                     < \\<pi>\\<^sub>5 s \\<or>\n                     \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                 then rt(dip \\<mapsto>\n                      addpre (dsn, kno, flg, hops, sip, {})\n                       (\\<pi>\\<^sub>7 s))\n                 else if \\<pi>\\<^sub>3 (dsn, kno, flg, hops, sip, {}) = unk\n                      then rt(dip \\<mapsto>\n                           (\\<pi>\\<^sub>2 s,\n                            snd (addpre (dsn, kno, flg, hops, sip, {})\n                                  (\\<pi>\\<^sub>7 s))))\n                      else rt(dip \\<mapsto>\n                           addpre s\n                            (\\<pi>\\<^sub>7\n                              (dsn, kno, flg, hops, sip,\n                               {})))) \\<Longrightarrow>\n       the (flag\n             (case rt dip of\n              None \\<Rightarrow> rt(dip \\<mapsto>\n                (dsn, kno, flg, hops, sip, {}))\n              | Some s \\<Rightarrow>\n                  if \\<pi>\\<^sub>2 s\n                     < \\<pi>\\<^sub>2 (dsn, kno, flg, hops, sip, {})\n                  then rt(dip \\<mapsto>\n                       addpre (dsn, kno, flg, hops, sip, {})\n                        (\\<pi>\\<^sub>7 s))\n                  else if \\<pi>\\<^sub>2 s =\n                          \\<pi>\\<^sub>2\n                           (dsn, kno, flg, hops, sip, {}) \\<and>\n                          (\\<pi>\\<^sub>5 (dsn, kno, flg, hops, sip, {})\n                           < \\<pi>\\<^sub>5 s \\<or>\n                           \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                       then rt(dip \\<mapsto>\n                            addpre (dsn, kno, flg, hops, sip, {})\n                             (\\<pi>\\<^sub>7 s))\n                       else if \\<pi>\\<^sub>3\n                                (dsn, kno, flg, hops, sip, {}) =\n                               unk\n                            then rt(dip \\<mapsto>\n                                 (\\<pi>\\<^sub>2 s,\n                                  snd (addpre (dsn, kno, flg, hops, sip, {})\n  (\\<pi>\\<^sub>7 s))))\n                            else rt(dip \\<mapsto>\n                                 addpre s\n                                  (\\<pi>\\<^sub>7\n                                    (dsn, kno, flg, hops, sip, {}))))\n             dip) =\n       flg", "by (clarsimp split: option.split if_split_asm) auto"], ["", "lemma the_flag_Some [dest!]:\n    fixes ip rt\n  assumes \"the (flag rt ip) = x\"\n      and \"ip \\<in> kD rt\"\n    shows \"flag rt ip = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flag rt ip = Some x", "using assms"], ["proof (prove)\nusing this:\n  the (flag rt ip) = x\n  ip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. flag rt ip = Some x", "by auto"], ["", "lemma kD_update_unchanged [dest]:\n    fixes rt dip dsn dsk flag hops nhip pre\n  assumes \"rt = update rt dip (dsn, dsk, flag, hops, nhip, pre)\"\n    shows \"dip\\<in>kD(rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dip \\<in> kD rt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dip \\<in> kD rt", "have \"dip\\<in>kD(update rt dip (dsn, dsk, flag, hops, nhip, pre))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dip \\<in> kD (update rt dip (dsn, dsk, flag, hops, nhip, pre))", "by simp"], ["proof (state)\nthis:\n  dip \\<in> kD (update rt dip (dsn, dsk, flag, hops, nhip, pre))\n\ngoal (1 subgoal):\n 1. dip \\<in> kD rt", "with assms"], ["proof (chain)\npicking this:\n  rt = update rt dip (dsn, dsk, flag, hops, nhip, pre)\n  dip \\<in> kD (update rt dip (dsn, dsk, flag, hops, nhip, pre))", "show ?thesis"], ["proof (prove)\nusing this:\n  rt = update rt dip (dsn, dsk, flag, hops, nhip, pre)\n  dip \\<in> kD (update rt dip (dsn, dsk, flag, hops, nhip, pre))\n\ngoal (1 subgoal):\n 1. dip \\<in> kD rt", "by simp"], ["proof (state)\nthis:\n  dip \\<in> kD rt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nhop_update [simp]: \"\\<And>rt dip dsn dsk flg hops sip.\n  rt \\<noteq> update rt dip (dsn, dsk, flg, hops, sip, {})\n  \\<Longrightarrow> the (nhop (update rt dip (dsn, dsk, flg, hops, sip, {})) dip) = sip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn dsk flg hops sip.\n       rt \\<noteq>\n       update rt dip (dsn, dsk, flg, hops, sip, {}) \\<Longrightarrow>\n       the (nhop (update rt dip (dsn, dsk, flg, hops, sip, {})) dip) = sip", "unfolding update_def sqnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dip dsn dsk flg hops sip.\n       rt \\<noteq>\n       (case rt dip of\n        None \\<Rightarrow> rt(dip \\<mapsto> (dsn, dsk, flg, hops, sip, {}))\n        | Some s \\<Rightarrow>\n            if \\<pi>\\<^sub>2 s\n               < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n            then rt(dip \\<mapsto>\n                 addpre (dsn, dsk, flg, hops, sip, {}) (\\<pi>\\<^sub>7 s))\n            else if \\<pi>\\<^sub>2 s =\n                    \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {}) \\<and>\n                    (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                     < \\<pi>\\<^sub>5 s \\<or>\n                     \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                 then rt(dip \\<mapsto>\n                      addpre (dsn, dsk, flg, hops, sip, {})\n                       (\\<pi>\\<^sub>7 s))\n                 else if \\<pi>\\<^sub>3 (dsn, dsk, flg, hops, sip, {}) = unk\n                      then rt(dip \\<mapsto>\n                           (\\<pi>\\<^sub>2 s,\n                            snd (addpre (dsn, dsk, flg, hops, sip, {})\n                                  (\\<pi>\\<^sub>7 s))))\n                      else rt(dip \\<mapsto>\n                           addpre s\n                            (\\<pi>\\<^sub>7\n                              (dsn, dsk, flg, hops, sip,\n                               {})))) \\<Longrightarrow>\n       the (nhop\n             (case rt dip of\n              None \\<Rightarrow> rt(dip \\<mapsto>\n                (dsn, dsk, flg, hops, sip, {}))\n              | Some s \\<Rightarrow>\n                  if \\<pi>\\<^sub>2 s\n                     < \\<pi>\\<^sub>2 (dsn, dsk, flg, hops, sip, {})\n                  then rt(dip \\<mapsto>\n                       addpre (dsn, dsk, flg, hops, sip, {})\n                        (\\<pi>\\<^sub>7 s))\n                  else if \\<pi>\\<^sub>2 s =\n                          \\<pi>\\<^sub>2\n                           (dsn, dsk, flg, hops, sip, {}) \\<and>\n                          (\\<pi>\\<^sub>5 (dsn, dsk, flg, hops, sip, {})\n                           < \\<pi>\\<^sub>5 s \\<or>\n                           \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                       then rt(dip \\<mapsto>\n                            addpre (dsn, dsk, flg, hops, sip, {})\n                             (\\<pi>\\<^sub>7 s))\n                       else if \\<pi>\\<^sub>3\n                                (dsn, dsk, flg, hops, sip, {}) =\n                               unk\n                            then rt(dip \\<mapsto>\n                                 (\\<pi>\\<^sub>2 s,\n                                  snd (addpre (dsn, dsk, flg, hops, sip, {})\n  (\\<pi>\\<^sub>7 s))))\n                            else rt(dip \\<mapsto>\n                                 addpre s\n                                  (\\<pi>\\<^sub>7\n                                    (dsn, dsk, flg, hops, sip, {}))))\n             dip) =\n       sip", "by (clarsimp split: option.splits if_split_asm) auto"], ["", "lemma sqn_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"sqn (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqn rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqn rt ip", "using assms"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. sqn (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqn rt ip", "unfolding update_def sqn_def"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. (case (case rt dip of\n           None \\<Rightarrow> rt(dip \\<mapsto>\n             (dsn, dsk, flag, hops, nhip, pre))\n           | Some s \\<Rightarrow>\n               if \\<pi>\\<^sub>2 s\n                  < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n               then rt(dip \\<mapsto>\n                    addpre (dsn, dsk, flag, hops, nhip, pre)\n                     (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>2 s =\n                       \\<pi>\\<^sub>2\n                        (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                       (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre)\n                        < \\<pi>\\<^sub>5 s \\<or>\n                        \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                    then rt(dip \\<mapsto>\n                         addpre (dsn, dsk, flag, hops, nhip, pre)\n                          (\\<pi>\\<^sub>7 s))\n                    else if \\<pi>\\<^sub>3\n                             (dsn, dsk, flag, hops, nhip, pre) =\n                            unk\n                         then rt(dip \\<mapsto>\n                              (\\<pi>\\<^sub>2 s,\n                               snd (addpre (dsn, dsk, flag, hops, nhip, pre)\n                                     (\\<pi>\\<^sub>7 s))))\n                         else rt(dip \\<mapsto>\n                              addpre s\n                               (\\<pi>\\<^sub>7\n                                 (dsn, dsk, flag, hops, nhip, pre))))\n           ip of\n     None \\<Rightarrow> 0 | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    (case rt ip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)", "by (clarsimp split: option.splits) auto"], ["", "lemma sqnf_update_another [simp]:\n    fixes dip ip rt dsn dsk flag hops nhip pre\n  assumes \"ip \\<noteq> dip\"\n    shows \"sqnf (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqnf rt ip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqnf (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqnf rt ip", "using assms"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. sqnf (update rt dip (dsn, dsk, flag, hops, nhip, pre)) ip = sqnf rt ip", "unfolding update_def sqnf_def"], ["proof (prove)\nusing this:\n  ip \\<noteq> dip\n\ngoal (1 subgoal):\n 1. (case (case rt dip of\n           None \\<Rightarrow> rt(dip \\<mapsto>\n             (dsn, dsk, flag, hops, nhip, pre))\n           | Some s \\<Rightarrow>\n               if \\<pi>\\<^sub>2 s\n                  < \\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre)\n               then rt(dip \\<mapsto>\n                    addpre (dsn, dsk, flag, hops, nhip, pre)\n                     (\\<pi>\\<^sub>7 s))\n               else if \\<pi>\\<^sub>2 s =\n                       \\<pi>\\<^sub>2\n                        (dsn, dsk, flag, hops, nhip, pre) \\<and>\n                       (\\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre)\n                        < \\<pi>\\<^sub>5 s \\<or>\n                        \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                    then rt(dip \\<mapsto>\n                         addpre (dsn, dsk, flag, hops, nhip, pre)\n                          (\\<pi>\\<^sub>7 s))\n                    else if \\<pi>\\<^sub>3\n                             (dsn, dsk, flag, hops, nhip, pre) =\n                            unk\n                         then rt(dip \\<mapsto>\n                              (\\<pi>\\<^sub>2 s,\n                               snd (addpre (dsn, dsk, flag, hops, nhip, pre)\n                                     (\\<pi>\\<^sub>7 s))))\n                         else rt(dip \\<mapsto>\n                              addpre s\n                               (\\<pi>\\<^sub>7\n                                 (dsn, dsk, flag, hops, nhip, pre))))\n           ip of\n     None \\<Rightarrow> unk | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r) =\n    (case rt ip of None \\<Rightarrow> unk\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r)", "by (clarsimp split: option.splits) auto"], ["", "lemma vD_update_val [dest]:\n  \"\\<And>dip rt dip' dsn dsk hops nhip pre.\n   dip \\<in> vD(update rt dip' (dsn, dsk, val, hops, nhip, pre)) \\<Longrightarrow> (dip\\<in>vD(rt) \\<or> dip=dip')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt dip' dsn dsk hops nhip pre.\n       dip\n       \\<in> vD (update rt dip'\n                  (dsn, dsk, val, hops, nhip, pre)) \\<Longrightarrow>\n       dip \\<in> vD rt \\<or> dip = dip'", "unfolding update_def vD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt dip' dsn dsk hops nhip pre.\n       dip\n       \\<in> {dip.\n              flag\n               (case rt dip' of\n                None \\<Rightarrow> rt(dip' \\<mapsto>\n                  (dsn, dsk, val, hops, nhip, pre))\n                | Some s \\<Rightarrow>\n                    if \\<pi>\\<^sub>2 s\n                       < \\<pi>\\<^sub>2 (dsn, dsk, val, hops, nhip, pre)\n                    then rt(dip' \\<mapsto>\n                         addpre (dsn, dsk, val, hops, nhip, pre)\n                          (\\<pi>\\<^sub>7 s))\n                    else if \\<pi>\\<^sub>2 s =\n                            \\<pi>\\<^sub>2\n                             (dsn, dsk, val, hops, nhip, pre) \\<and>\n                            (\\<pi>\\<^sub>5 (dsn, dsk, val, hops, nhip, pre)\n                             < \\<pi>\\<^sub>5 s \\<or>\n                             \\<pi>\\<^sub>4 s = Aodv_Basic.inv)\n                         then rt(dip' \\<mapsto>\n                              addpre (dsn, dsk, val, hops, nhip, pre)\n                               (\\<pi>\\<^sub>7 s))\n                         else if \\<pi>\\<^sub>3\n                                  (dsn, dsk, val, hops, nhip, pre) =\n                                 unk\n                              then rt(dip' \\<mapsto>\n                                   (\\<pi>\\<^sub>2 s,\n                                    snd (addpre\n    (dsn, dsk, val, hops, nhip, pre) (\\<pi>\\<^sub>7 s))))\n                              else rt(dip' \\<mapsto>\n                                   addpre s\n                                    (\\<pi>\\<^sub>7\n(dsn, dsk, val, hops, nhip, pre))))\n               dip =\n              Some val} \\<Longrightarrow>\n       dip \\<in> {dip. flag rt dip = Some val} \\<or> dip = dip'", "by (clarsimp split: option.split_asm if_split_asm)"], ["", "subsubsection \"Invalidating route entries\""], ["", "definition invalidate :: \"rt \\<Rightarrow> (ip \\<rightharpoonup> sqn) \\<Rightarrow> rt\"\nwhere \"invalidate rt dests \\<equiv>\n  \\<lambda>ip. case (rt ip, dests ip) of\n    (None, _) \\<Rightarrow> None\n  | (Some s, None) \\<Rightarrow> Some s\n  | (Some (_, dsk, _, hops, nhip, pre), Some rsn) \\<Rightarrow>\n                      Some (rsn, dsk, inv, hops, nhip, pre)\""], ["", "lemma proj3_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>3(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>3(the (rt dip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>3 (the (invalidate rt dests dip)) =\n       \\<pi>\\<^sub>3 (the (rt dip))", "unfolding invalidate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>3\n        (the (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n              | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                  Some (a, ab, ad, af, ah, ba)\n              | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                  Some (rsn, ab, Aodv_Basic.inv, af, ah, ba))) =\n       \\<pi>\\<^sub>3 (the (rt dip))", "by (clarsimp split: option.split)"], ["", "lemma proj5_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>5(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>5(the (rt dip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>5 (the (invalidate rt dests dip)) =\n       \\<pi>\\<^sub>5 (the (rt dip))", "unfolding invalidate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>5\n        (the (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n              | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                  Some (a, ab, ad, af, ah, ba)\n              | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                  Some (rsn, ab, Aodv_Basic.inv, af, ah, ba))) =\n       \\<pi>\\<^sub>5 (the (rt dip))", "by (clarsimp split: option.split)"], ["", "lemma proj6_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>6(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>6(the (rt dip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>6 (the (invalidate rt dests dip)) =\n       \\<pi>\\<^sub>6 (the (rt dip))", "unfolding invalidate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>6\n        (the (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n              | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                  Some (a, ab, ad, af, ah, ba)\n              | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                  Some (rsn, ab, Aodv_Basic.inv, af, ah, ba))) =\n       \\<pi>\\<^sub>6 (the (rt dip))", "by (clarsimp split: option.split)"], ["", "lemma proj7_invalidate [simp]:\n  \"\\<And>dip. \\<pi>\\<^sub>7(the ((invalidate rt dests) dip)) = \\<pi>\\<^sub>7(the (rt dip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>7 (the (invalidate rt dests dip)) =\n       \\<pi>\\<^sub>7 (the (rt dip))", "unfolding invalidate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       \\<pi>\\<^sub>7\n        (the (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n              | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                  Some (a, ab, ad, af, ah, ba)\n              | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                  Some (rsn, ab, Aodv_Basic.inv, af, ah, ba))) =\n       \\<pi>\\<^sub>7 (the (rt dip))", "by (clarsimp split: option.split)"], ["", "lemma invalidate_kD_inv [simp]:\n  \"\\<And>rt dests. kD (invalidate rt dests) = kD rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dests. kD (invalidate rt dests) = kD rt", "unfolding invalidate_def kD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rt dests.\n       {dip.\n        (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n         | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n             Some (a, ab, ad, af, ah, ba)\n         | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n             Some (rsn, ab, Aodv_Basic.inv, af, ah, ba)) \\<noteq>\n        None} =\n       {dip. rt dip \\<noteq> None}", "by (simp split: option.split)"], ["", "lemma invalidate_sqn:\n  fixes rt dip dests\n  assumes \"\\<forall>rsn. dests dip = Some rsn \\<longrightarrow> sqn rt dip \\<le> rsn\"\n  shows \"sqn rt dip \\<le> sqn (invalidate rt dests) dip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn rt dip \\<le> sqn (invalidate rt dests) dip", "proof (cases \"dip \\<notin> kD(rt)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip\n 2. \\<not> dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip", "assume \"\\<not> dip \\<notin> kD(rt)\""], ["proof (state)\nthis:\n  \\<not> dip \\<notin> kD rt\n\ngoal (2 subgoals):\n 1. dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip\n 2. \\<not> dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip", "hence \"dip\\<in>kD(rt)\""], ["proof (prove)\nusing this:\n  \\<not> dip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. dip \\<in> kD rt", "by simp"], ["proof (state)\nthis:\n  dip \\<in> kD rt\n\ngoal (2 subgoals):\n 1. dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip\n 2. \\<not> dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip", "then"], ["proof (chain)\npicking this:\n  dip \\<in> kD rt", "obtain dsn dsk flag hops nhip pre where \"rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\""], ["proof (prove)\nusing this:\n  dip \\<in> kD rt\n\ngoal (1 subgoal):\n 1. (\\<And>dsn dsk flag hops nhip pre.\n        rt dip = Some (dsn, dsk, flag, hops, nhip, pre) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis kD_Some)"], ["proof (state)\nthis:\n  rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (2 subgoals):\n 1. dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip\n 2. \\<not> dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>rsn. dests dip = Some rsn \\<longrightarrow> sqn rt dip \\<le> rsn\n  rt dip = Some (dsn, dsk, flag, hops, nhip, pre)", "show \"sqn rt dip \\<le> sqn (invalidate rt dests) dip\""], ["proof (prove)\nusing this:\n  \\<forall>rsn. dests dip = Some rsn \\<longrightarrow> sqn rt dip \\<le> rsn\n  rt dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. sqn rt dip \\<le> sqn (invalidate rt dests) dip", "by (cases \"dests dip\") (auto simp add: invalidate_def sqn_def)"], ["proof (state)\nthis:\n  sqn rt dip \\<le> sqn (invalidate rt dests) dip\n\ngoal (1 subgoal):\n 1. dip \\<notin> kD rt \\<Longrightarrow>\n    sqn rt dip \\<le> sqn (invalidate rt dests) dip", "qed simp"], ["", "lemma sqn_invalidate_in_dests [simp]:\n    fixes dests ipa rsn rt\n  assumes \"dests ipa = Some rsn\"\n      and \"ipa\\<in>kD(rt)\"\n    shows \"sqn (invalidate rt dests) ipa = rsn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn (invalidate rt dests) ipa = rsn", "unfolding invalidate_def sqn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case (rt ipa, dests ipa) of (None, x) \\<Rightarrow> None\n          | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n              Some (a, ab, ad, af, ah, ba)\n          | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n              Some (rsn, ab, Aodv_Basic.inv, af, ah, ba) of\n     None \\<Rightarrow> 0 | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    rsn", "using assms(1) assms(2) [THEN kD_Some]"], ["proof (prove)\nusing this:\n  dests ipa = Some rsn\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ipa = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. (case case (rt ipa, dests ipa) of (None, x) \\<Rightarrow> None\n          | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n              Some (a, ab, ad, af, ah, ba)\n          | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n              Some (rsn, ab, Aodv_Basic.inv, af, ah, ba) of\n     None \\<Rightarrow> 0 | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    rsn", "by clarsimp"], ["", "lemma dhops_invalidate [simp]:\n  \"\\<And>dip. the (dhops (invalidate rt dests) dip) = the (dhops rt dip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip. the (dhops (invalidate rt dests) dip) = the (dhops rt dip)", "unfolding invalidate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       the (map_option \\<pi>\\<^sub>5\n             (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n              | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                  Some (a, ab, ad, af, ah, ba)\n              | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                  Some (rsn, ab, Aodv_Basic.inv, af, ah, ba))) =\n       the (dhops rt dip)", "by (clarsimp split: option.split)"], ["", "lemma sqnf_invalidate [simp]:\n  \"\\<And>dip. sqnf (invalidate (rt \\<xi>) (dests \\<xi>)) dip = sqnf (rt \\<xi>) dip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       sqnf (invalidate (rt \\<xi>) (dests \\<xi>)) dip = sqnf (rt \\<xi>) dip", "unfolding sqnf_def invalidate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       (case case (rt \\<xi> dip, dests \\<xi> dip) of\n             (None, x) \\<Rightarrow> None\n             | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                 Some (a, ab, ad, af, ah, ba)\n             | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                 Some (rsn, ab, Aodv_Basic.inv, af, ah, ba) of\n        None \\<Rightarrow> unk | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r) =\n       (case rt \\<xi> dip of None \\<Rightarrow> unk\n        | Some r \\<Rightarrow> \\<pi>\\<^sub>3 r)", "by (clarsimp split: option.split)"], ["", "lemma nhop_invalidate [simp]:\n  \"\\<And>dip. the (nhop (invalidate (rt \\<xi>) (dests \\<xi>)) dip) = the (nhop (rt \\<xi>) dip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       the (nhop (invalidate (rt \\<xi>) (dests \\<xi>)) dip) =\n       the (nhop (rt \\<xi>) dip)", "unfolding invalidate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip.\n       the (map_option \\<pi>\\<^sub>6\n             (case (rt \\<xi> dip, dests \\<xi> dip) of\n              (None, x) \\<Rightarrow> None\n              | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                  Some (a, ab, ad, af, ah, ba)\n              | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                  Some (rsn, ab, Aodv_Basic.inv, af, ah, ba))) =\n       the (nhop (rt \\<xi>) dip)", "by (clarsimp split: option.split)"], ["", "lemma invalidate_other [simp]:\n    fixes rt dests dip\n  assumes \"dip\\<notin>dom(dests)\"\n    shows \"invalidate rt dests dip = rt dip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalidate rt dests dip = rt dip", "using assms"], ["proof (prove)\nusing this:\n  dip \\<notin> dom dests\n\ngoal (1 subgoal):\n 1. invalidate rt dests dip = rt dip", "unfolding invalidate_def"], ["proof (prove)\nusing this:\n  dip \\<notin> dom dests\n\ngoal (1 subgoal):\n 1. (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n     | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n         Some (a, ab, ad, af, ah, ba)\n     | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n         Some (rsn, ab, Aodv_Basic.inv, af, ah, ba)) =\n    rt dip", "by (clarsimp split: option.split_asm)"], ["", "lemma invalidate_none [simp]:\n    fixes rt dests dip\n  assumes \"dip\\<notin>kD(rt)\"\n    shows \"invalidate rt dests dip = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalidate rt dests dip = None", "using assms"], ["proof (prove)\nusing this:\n  dip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. invalidate rt dests dip = None", "unfolding invalidate_def"], ["proof (prove)\nusing this:\n  dip \\<notin> kD rt\n\ngoal (1 subgoal):\n 1. (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n     | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n         Some (a, ab, ad, af, ah, ba)\n     | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n         Some (rsn, ab, Aodv_Basic.inv, af, ah, ba)) =\n    None", "by clarsimp"], ["", "lemma vD_invalidate_vD_not_dests:\n  \"\\<And>dip rt dests. dip\\<in>vD(invalidate rt dests) \\<Longrightarrow> dip\\<in>vD(rt) \\<and> dests dip = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt dests.\n       dip \\<in> vD (invalidate rt dests) \\<Longrightarrow>\n       dip \\<in> vD rt \\<and> dests dip = None", "unfolding invalidate_def vD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt dests.\n       dip\n       \\<in> {dip.\n              map_option \\<pi>\\<^sub>4\n               (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n                | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                    Some (a, ab, ad, af, ah, ba)\n                | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                    Some (rsn, ab, Aodv_Basic.inv, af, ah, ba)) =\n              Some val} \\<Longrightarrow>\n       dip \\<in> {dip. flag rt dip = Some val} \\<and> dests dip = None", "by (clarsimp split: option.split_asm)"], ["", "lemma sqn_invalidate_not_in_dests [simp]:\n  fixes dests dip rt\n  assumes \"dip\\<notin>dom(dests)\"\n  shows \"sqn (invalidate rt dests) dip = sqn rt dip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqn (invalidate rt dests) dip = sqn rt dip", "using assms"], ["proof (prove)\nusing this:\n  dip \\<notin> dom dests\n\ngoal (1 subgoal):\n 1. sqn (invalidate rt dests) dip = sqn rt dip", "unfolding sqn_def"], ["proof (prove)\nusing this:\n  dip \\<notin> dom dests\n\ngoal (1 subgoal):\n 1. (case invalidate rt dests dip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r) =\n    (case rt dip of None \\<Rightarrow> 0\n     | Some r \\<Rightarrow> \\<pi>\\<^sub>2 r)", "by simp"], ["", "lemma invalidate_changes:\n    fixes rt dests dip dsn dsk flag hops nhip pre\n  assumes \"invalidate rt dests dip = Some (dsn, dsk, flag, hops, nhip, pre)\"\n    shows \"  dsn = (case dests dip of None \\<Rightarrow> \\<pi>\\<^sub>2(the (rt dip)) | Some rsn \\<Rightarrow> rsn)\n           \\<and> dsk = \\<pi>\\<^sub>3(the (rt dip))\n           \\<and> flag = (if dests dip = None then \\<pi>\\<^sub>4(the (rt dip)) else inv)\n           \\<and> hops = \\<pi>\\<^sub>5(the (rt dip))\n           \\<and> nhip = \\<pi>\\<^sub>6(the (rt dip))\n           \\<and> pre = \\<pi>\\<^sub>7(the (rt dip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dsn =\n    (case dests dip of None \\<Rightarrow> \\<pi>\\<^sub>2 (the (rt dip))\n     | Some rsn \\<Rightarrow> rsn) \\<and>\n    dsk = \\<pi>\\<^sub>3 (the (rt dip)) \\<and>\n    flag =\n    (if dests dip = None then \\<pi>\\<^sub>4 (the (rt dip))\n     else Aodv_Basic.inv) \\<and>\n    hops = \\<pi>\\<^sub>5 (the (rt dip)) \\<and>\n    nhip = \\<pi>\\<^sub>6 (the (rt dip)) \\<and>\n    pre = \\<pi>\\<^sub>7 (the (rt dip))", "using assms"], ["proof (prove)\nusing this:\n  invalidate rt dests dip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. dsn =\n    (case dests dip of None \\<Rightarrow> \\<pi>\\<^sub>2 (the (rt dip))\n     | Some rsn \\<Rightarrow> rsn) \\<and>\n    dsk = \\<pi>\\<^sub>3 (the (rt dip)) \\<and>\n    flag =\n    (if dests dip = None then \\<pi>\\<^sub>4 (the (rt dip))\n     else Aodv_Basic.inv) \\<and>\n    hops = \\<pi>\\<^sub>5 (the (rt dip)) \\<and>\n    nhip = \\<pi>\\<^sub>6 (the (rt dip)) \\<and>\n    pre = \\<pi>\\<^sub>7 (the (rt dip))", "unfolding invalidate_def"], ["proof (prove)\nusing this:\n  (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n   | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n       Some (a, ab, ad, af, ah, ba)\n   | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n       Some (rsn, ab, Aodv_Basic.inv, af, ah, ba)) =\n  Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. dsn =\n    (case dests dip of None \\<Rightarrow> \\<pi>\\<^sub>2 (the (rt dip))\n     | Some rsn \\<Rightarrow> rsn) \\<and>\n    dsk = \\<pi>\\<^sub>3 (the (rt dip)) \\<and>\n    flag =\n    (if dests dip = None then \\<pi>\\<^sub>4 (the (rt dip))\n     else Aodv_Basic.inv) \\<and>\n    hops = \\<pi>\\<^sub>5 (the (rt dip)) \\<and>\n    nhip = \\<pi>\\<^sub>6 (the (rt dip)) \\<and>\n    pre = \\<pi>\\<^sub>7 (the (rt dip))", "by (cases \"rt dip\", clarsimp, cases \"dests dip\") auto"], ["", "lemma proj3_inv: \"\\<And>dip rt dests. dip\\<in>kD (rt)\n                      \\<Longrightarrow> \\<pi>\\<^sub>3(the (invalidate rt dests dip)) = \\<pi>\\<^sub>3(the (rt dip))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>dip rt dests.\n       dip \\<in> kD rt \\<Longrightarrow>\n       \\<pi>\\<^sub>3 (the (invalidate rt dests dip)) =\n       \\<pi>\\<^sub>3 (the (rt dip))", "by (clarsimp simp: invalidate_def kD_def split: option.split)"], ["", "lemma dests_iD_invalidate [simp]:\n  assumes \"dests ip = Some rsn\"\n      and \"ip\\<in>kD(rt)\"\n    shows \"ip\\<in>iD(invalidate rt dests)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ip \\<in> iD (invalidate rt dests)", "using assms(1) assms(2) [THEN kD_Some]"], ["proof (prove)\nusing this:\n  dests ip = Some rsn\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. ip \\<in> iD (invalidate rt dests)", "unfolding invalidate_def iD_def"], ["proof (prove)\nusing this:\n  dests ip = Some rsn\n  \\<exists>dsn dsk flag hops nhip pre.\n     rt ip = Some (dsn, dsk, flag, hops, nhip, pre)\n\ngoal (1 subgoal):\n 1. ip \\<in> {dip.\n              map_option \\<pi>\\<^sub>4\n               (case (rt dip, dests dip) of (None, x) \\<Rightarrow> None\n                | (Some (a, ab, ad, af, ah, ba), None) \\<Rightarrow>\n                    Some (a, ab, ad, af, ah, ba)\n                | (Some (a, ab, ad, af, ah, ba), Some rsn) \\<Rightarrow>\n                    Some (rsn, ab, Aodv_Basic.inv, af, ah, ba)) =\n              Some Aodv_Basic.inv}", "by (clarsimp split: option.split)"], ["", "subsection \"Route Requests\""], ["", "text \\<open>Generate a fresh route request identifier.\\<close>"], ["", "definition nrreqid :: \"(ip \\<times> rreqid) set \\<Rightarrow> ip \\<Rightarrow> rreqid\"\n  where \"nrreqid rreqs ip \\<equiv> Max ({n. (ip, n) \\<in> rreqs} \\<union> {0}) + 1\""], ["", "subsection \"Queued Packets\""], ["", "text \\<open>Functions for sending data packets.\\<close>"], ["", "type_synonym store = \"ip \\<rightharpoonup> (p \\<times> data list)\""], ["", "definition sigma_queue :: \"store \\<Rightarrow> ip \\<Rightarrow> data list\"    (\"\\<sigma>\\<^bsub>queue\\<^esub>'(_, _')\")\n  where \"\\<sigma>\\<^bsub>queue\\<^esub>(store, dip) \\<equiv> case store dip of None \\<Rightarrow> [] | Some (p, q) \\<Rightarrow> q\""], ["", "definition qD :: \"store \\<Rightarrow> ip set\"\n  where \"qD \\<equiv> dom\""], ["", "definition add :: \"data \\<Rightarrow> ip \\<Rightarrow> store \\<Rightarrow> store\"\n  where \"add d dip store \\<equiv> case store dip of\n                              None \\<Rightarrow> store (dip \\<mapsto> (req, [d]))\n                            | Some (p, q) \\<Rightarrow> store (dip \\<mapsto> (p, q @ [d]))\""], ["", "lemma qD_add [simp]:\n  fixes d dip store\n  shows \"qD(add d dip store) = insert dip (qD store)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qD (add d dip store) = insert dip (qD store)", "unfolding add_def Let_def qD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (case store dip of\n         None \\<Rightarrow> store(dip \\<mapsto> (req, [d]))\n         | Some (p, q) \\<Rightarrow> store(dip \\<mapsto> (p, q @ [d]))) =\n    insert dip (dom store)", "by (clarsimp split: option.split)"], ["", "definition drop :: \"ip \\<Rightarrow> store \\<rightharpoonup> store\"\n  where \"drop dip store \\<equiv>\n    map_option (\\<lambda>(p, q). if tl q = [] then store (dip := None)\n                                      else store (dip \\<mapsto> (p, tl q))) (store dip)\""], ["", "definition sigma_p_flag :: \"store \\<Rightarrow> ip \\<rightharpoonup> p\" (\"\\<sigma>\\<^bsub>p-flag\\<^esub>'(_, _')\")\n  where \"\\<sigma>\\<^bsub>p-flag\\<^esub>(store, dip) \\<equiv> map_option fst (store dip)\""], ["", "definition unsetRRF :: \"store \\<Rightarrow> ip \\<Rightarrow> store\"\n  where \"unsetRRF store dip \\<equiv> case store dip of\n                                None \\<Rightarrow> store\n                              | Some (p, q) \\<Rightarrow> store (dip \\<mapsto> (noreq, q))\""], ["", "definition setRRF :: \"store \\<Rightarrow> (ip \\<rightharpoonup> sqn) \\<Rightarrow> store\"\n  where \"setRRF store dests \\<equiv> \\<lambda>dip. if dests dip = None then store dip\n                                    else map_option (\\<lambda>(_, q). (req, q)) (store dip)\""], ["", "subsection \"Comparison with the original technical report\""], ["", "text \\<open>\n  The major differences with the AODV technical report of Fehnker et al are:\n  \\begin{enumerate}\n  \\item @{term nhop} is partial, thus a `@{term the}' is needed, similarly for @{term dhops}\n        and @{term addpreRT}.\n  \\item @{term precs} is partial.\n  \\item @{term \"\\<sigma>\\<^bsub>p-flag\\<^esub>(store, dip)\"} is partial.\n  \\item The routing table (@{typ rt}) is modelled as a map (@{typ \"ip \\<Rightarrow> r option\"})\n        rather than a set of 7-tuples, likewise, the @{typ r} is a 6-tuple rather than\n        a 7-tuple, i.e., the destination ip-address (@{term \"dip\"}) is taken from the\n        argument to the function, rather than a part of the result. Well-definedness then\n        follows from the structure of the type and more related facts are available\n        automatically, rather than having to be acquired through tedious proofs.\n  \\item Similar remarks hold for the dests mapping passed to @{term \"invalidate\"},\n        and @{term \"store\"}.\n  \\end{enumerate}\n\\<close>"], ["", "end"]]}