{"file_name": "/home/qj213/afp-2021-10-22/thys/Cayley_Hamilton/Cayley_Hamilton.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Cayley_Hamilton", "problem_names": ["lemma degree_C[simp]: \"degree (C a) = 0\"", "lemma coeff_C_0[simp]: \"coeff (C x) 0 = x\"", "lemma coeff_C_gt0[simp]: \"0 < n \\<Longrightarrow> coeff (C x) n = 0\"", "lemma coeff_C_eq: \"coeff (C x) n = (if n = 0 then x else 0)\"", "lemma coeff_mult_C[simp]: \"coeff (a * C x) n = coeff a n * x\"", "lemma coeff_C_mult[simp]: \"coeff (C x * a) n = x * coeff a n\"", "lemma C_0[simp]: \"C 0 = 0\"", "lemma C_1[simp]: \"C 1 = 1\"", "lemma C_linear:\n  shows C_mult: \"C (a * b) = C b * C a\"\n    and C_add: \"C (a + b) = C a + C b\"\n    and C_minus: \"C (- a) = - C a\"\n    and C_diff: \"C (a - b) = C a - C b\"", "lemma degree_X[simp]: \"degree X = 1\"", "lemma coeff_X_Suc_0[simp]: \"coeff X (Suc 0) = 1\"", "lemma coeff_X_mult[simp]: \"coeff (X * p) (Suc i) = coeff p i\"", "lemma coeff_mult_X[simp]: \"coeff (p * X) (Suc i) = coeff p i\"", "lemma coeff_X_mult_0[simp]: \"coeff (X * p) 0 = 0\"", "lemma coeff_mult_X_0[simp]: \"coeff (p * X) 0 = 0\"", "lemma coeff_X: \"coeff X i = (if i = 1 then 1 else 0)\"", "lemma coeff_pow_X: \"coeff (X ^ i) n = (if i = n then 1 else 0)\"", "lemma coeff_pow_X_eq[simp]: \"coeff (X^i) i = 1\"", "lemma (in monoid_mult) power_ac: \"a * (a^n * x) = a^n * (a * x)\"", "lemma degree_prod_le: \"degree (\\<Prod>i\\<in>S. f i) \\<le> (\\<Sum>i\\<in>S. degree (f i))\"", "lemma coeff_mult_sum:\n  \"degree p \\<le> m \\<Longrightarrow> degree q \\<le> n \\<Longrightarrow> coeff (p * q) (m + n) = coeff p m * coeff q n\"", "lemma coeff_mult_prod_sum:\n  \"coeff (\\<Prod>i\\<in>S. f i) (\\<Sum>i\\<in>S. degree (f i)) = (\\<Prod>i\\<in>S. coeff (f i) (degree (f i)))\"", "lemma degree_sum_less:\n  \"0 < n \\<Longrightarrow> (\\<And>x. x \\<in> A \\<Longrightarrow> degree (f x) < n) \\<Longrightarrow> degree (\\<Sum>x\\<in>A. f x) < n\"", "lemma degree_sum_le:\n  shows \"(\\<And>x. x \\<in> A \\<Longrightarrow> degree (f x) \\<le> n) \\<Longrightarrow> degree (\\<Sum>x\\<in>A. f x) \\<le> n\"", "lemma degree_sum_le_Max:\n  \"finite F \\<Longrightarrow> degree (sum f F) \\<le> Max ((\\<lambda>x. degree (f x))`F)\"", "lemma poly_as_sum_of_monoms': assumes n: \"degree p \\<le> n\" shows \"(\\<Sum>i\\<le>n. X^i * C (coeff p i)) = p\"", "lemma poly_as_sum_of_monoms: \"(\\<Sum>i\\<le>degree p. X^i * C (coeff p i)) = p\"", "lemma degree_sum_unique':\n  assumes I: \"finite I\" \"i \\<notin> I\" \"\\<And>j. j \\<in> I \\<Longrightarrow> degree (p j) < degree (p i)\"\n  shows \"degree (\\<Sum>i\\<in>insert i I. p i) = degree (p i)\"", "lemma degree_sum_unique:\n  \"finite I \\<Longrightarrow> i \\<in> I \\<Longrightarrow> (\\<And>j. j \\<in> I \\<Longrightarrow> j \\<noteq> i \\<Longrightarrow> degree (p j) < degree (p i)) \\<Longrightarrow>\n    degree (\\<Sum>i\\<in>I. p i) = degree (p i)\"", "lemma coeff_sum_unique:\n  fixes p :: \"'a \\<Rightarrow> 'b::semiring_0 poly\"\n  assumes I: \"finite I\" \"i \\<in> I\" \"\\<And>j. j \\<in> I \\<Longrightarrow> j \\<noteq> i \\<Longrightarrow> degree (p j) < degree (p i)\"\n  shows \"coeff (\\<Sum>i\\<in>I. p i) (degree (p i)) = coeff (p i) (degree (p i))\"", "lemma diag_coeff: \"diag (coeff x i) = map_sq_matrix (\\<lambda>x. coeff x i) (diag x)\"", "lemma smult_one: \"x *\\<^sub>S 1 = diag x\"", "lemma sum_telescope_Ico: \"a \\<le> b \\<Longrightarrow> (\\<Sum>i=a ..< b. f i - f (Suc i) ::_::ab_group_add) = f a - f b\"", "lemmas map_sq_matrix = map_sq_matrix_diff map_sq_matrix_add map_sq_matrix_smult map_sq_matrix_sum", "lemma sign_permut: \"degree (of_int (sign p) * q) = degree q\"", "lemma degree_det:\n  assumes \"\\<And>j. j permutes UNIV \\<Longrightarrow> j \\<noteq> id \\<Longrightarrow> degree (\\<Prod>i\\<in>UNIV. to_fun A i (j i)) < degree (\\<Prod>i\\<in>UNIV. to_fun A i i)\"\n  shows \"degree (det A) = degree (\\<Prod>i\\<in>UNIV. to_fun A i i)\"", "lemma degree_le_max_degree: \"degree (to_fun A i j) \\<le> max_degree A\"", "lemma degree_diff_cancel: \"degree q < degree p \\<Longrightarrow> degree (p - q::_::ab_group_add poly) = degree p\"", "lemma\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  shows degree_charpoly: \"degree (charpoly A) = CARD('n)\"\n    and coeff_charpoly: \"coeff (charpoly A) (degree (charpoly A)) = 1\"", "lemma max_perm_degree_eqI:\n  \"(\\<And>p. p permutes (UNIV::'a::finite set) \\<Longrightarrow> (\\<Sum>i\\<in>UNIV. degree (to_fun A i (p i))) \\<le> x) \\<Longrightarrow>\n    (\\<exists>p. p permutes UNIV \\<and> (\\<Sum>i\\<in>UNIV. degree (to_fun A i (p i))) = x) \\<Longrightarrow>\n    max_perm_degree A = x\"", "lemma degree_prod_le_max_perm_degree:\n  \"j permutes (UNIV::'a::finite set) \\<Longrightarrow> degree (\\<Prod>i\\<in>UNIV. to_fun A i (j i)) \\<le> max_perm_degree A\"", "lemma degree_le_max_perm_degree: \"degree (det A) \\<le> max_perm_degree A\"", "lemma max_degree_adjugate:\n  fixes A :: \"_^^'n\"\n  shows \"max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1\"\n    (is \"?R = _\")", "lemma zero_smult[simp]: \"0 *\\<^sub>S M = (0::'a::semiring_1^^'n)\"", "lemma smult_smult: \"a *\\<^sub>S b *\\<^sub>S M = (a * b::'a::monoid_mult) *\\<^sub>S M\"", "lemma map_sq_matrix_mult_eq_smult[simp]: \"map_sq_matrix ((*) a) M = a *\\<^sub>S M\"", "lemma coeff_smult_1: \"coeff p i *\\<^sub>S m = m * map_sq_matrix (\\<lambda>p. coeff p i) (p *\\<^sub>S 1::_::comm_ring_1 ^^ 'n)\"", "lemma map_sq_matrix_if_distrib[simp]:\n  \"map_sq_matrix (\\<lambda>x. if P then f x else g x) = (if P then map_sq_matrix f else map_sq_matrix g)\"", "theorem Cayley_Hamilton:\n  fixes A :: \"'a::comm_ring_1 ^^ 'n\"\n  shows \"poly_mat (charpoly A) A = 0\""], "translations": [["", "lemma degree_C[simp]: \"degree (C a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (C a) = 0", "by (simp add: C_def)"], ["", "lemma coeff_C_0[simp]: \"coeff (C x) 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (C x) 0 = x", "by (simp add: C_def)"], ["", "lemma coeff_C_gt0[simp]: \"0 < n \\<Longrightarrow> coeff (C x) n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> coeff (C x) n = (0::'a)", "by (cases n) (simp_all add: C_def)"], ["", "lemma coeff_C_eq: \"coeff (C x) n = (if n = 0 then x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (C x) n = (if n = 0 then x else (0::'a))", "by simp"], ["", "lemma coeff_mult_C[simp]: \"coeff (a * C x) n = coeff a n * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (a * C x) n = coeff a n * x", "by (simp add: coeff_mult coeff_C_eq if_distrib[where f=\"\\<lambda>x. a * x\" for a] sum.If_cases)"], ["", "lemma coeff_C_mult[simp]: \"coeff (C x * a) n = x * coeff a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (C x * a) n = x * coeff a n", "by (simp add: coeff_mult coeff_C_eq if_distrib[where f=\"\\<lambda>x. x * a\" for a] sum.If_cases)"], ["", "lemma C_0[simp]: \"C 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (0::'a) = 0", "by (simp add: C_def)"], ["", "lemma C_1[simp]: \"C 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C (1::'a) = 1", "by (simp add: C_def)"], ["", "lemma C_linear:\n  shows C_mult: \"C (a * b) = C b * C a\"\n    and C_add: \"C (a + b) = C a + C b\"\n    and C_minus: \"C (- a) = - C a\"\n    and C_diff: \"C (a - b) = C a - C b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C (a * b) = C b * C a &&& C (a + b) = C a + C b) &&&\n    C (- a) = - C a &&& C (a - b) = C a - C b", "by (simp_all add: C_def)"], ["", "definition X :: \"'a::ring_1 poly\" where \"X = [:0, 1:]\""], ["", "abbreviation XX (\"\\<^bold>X\") where \"\\<^bold>X \\<equiv> diag X\""], ["", "lemma degree_X[simp]: \"degree X = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree X = 1", "by (simp add: X_def)"], ["", "lemma coeff_X_Suc_0[simp]: \"coeff X (Suc 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff X (Suc 0) = (1::'a)", "by (auto simp: X_def)"], ["", "lemma coeff_X_mult[simp]: \"coeff (X * p) (Suc i) = coeff p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (X * p) (Suc i) = coeff p i", "by (auto simp: X_def)"], ["", "lemma coeff_mult_X[simp]: \"coeff (p * X) (Suc i) = coeff p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * X) (Suc i) = coeff p i", "by (auto simp: X_def)"], ["", "lemma coeff_X_mult_0[simp]: \"coeff (X * p) 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (X * p) 0 = (0::'a)", "by (auto simp: X_def)"], ["", "lemma coeff_mult_X_0[simp]: \"coeff (p * X) 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * X) 0 = (0::'a)", "by (auto simp: X_def)"], ["", "lemma coeff_X: \"coeff X i = (if i = 1 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff X i = (if i = 1 then 1::'a else (0::'a))", "by (cases i) (auto simp: X_def gr0_conv_Suc)"], ["", "lemma coeff_pow_X: \"coeff (X ^ i) n = (if i = n then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (X ^ i) n = (if i = n then 1::'a else (0::'a))", "proof (induction i arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. coeff (X ^ 0) n = (if 0 = n then 1::'a else (0::'a))\n 2. \\<And>i n.\n       (\\<And>n.\n           coeff (X ^ i) n =\n           (if i = n then 1::'a else (0::'a))) \\<Longrightarrow>\n       coeff (X ^ Suc i) n = (if Suc i = n then 1::'a else (0::'a))", "case (Suc i)"], ["proof (state)\nthis:\n  coeff (X ^ i) ?n = (if i = ?n then 1::'a else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>n. coeff (X ^ 0) n = (if 0 = n then 1::'a else (0::'a))\n 2. \\<And>i n.\n       (\\<And>n.\n           coeff (X ^ i) n =\n           (if i = n then 1::'a else (0::'a))) \\<Longrightarrow>\n       coeff (X ^ Suc i) n = (if Suc i = n then 1::'a else (0::'a))", "then"], ["proof (chain)\npicking this:\n  coeff (X ^ i) ?n = (if i = ?n then 1::'a else (0::'a))", "show ?case"], ["proof (prove)\nusing this:\n  coeff (X ^ i) ?n = (if i = ?n then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. coeff (X ^ Suc i) n = (if Suc i = n then 1::'a else (0::'a))", "by (cases n) simp_all"], ["proof (state)\nthis:\n  coeff (X ^ Suc i) n = (if Suc i = n then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>n. coeff (X ^ 0) n = (if 0 = n then 1::'a else (0::'a))", "qed auto"], ["", "lemma coeff_pow_X_eq[simp]: \"coeff (X^i) i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (X ^ i) i = (1::'a)", "by (simp add: coeff_pow_X)"], ["", "lemma (in monoid_mult) power_ac: \"a * (a^n * x) = a^n * (a * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (a ^ n * x) = a ^ n * (a * x)", "by (metis power_Suc2 power_Suc mult.assoc)"], ["", "text\\<open>This theory contains auxiliary lemmas on polynomials.\\<close>"], ["", "lemma degree_prod_le: \"degree (\\<Prod>i\\<in>S. f i) \\<le> (\\<Sum>i\\<in>S. degree (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (prod f S) \\<le> (\\<Sum>i\\<in>S. degree (f i))", "by (induction S rule: infinite_finite_induct)\n     (simp_all, metis (lifting) degree_mult_le dual_order.trans nat_add_left_cancel_le)"], ["", "lemma coeff_mult_sum:\n  \"degree p \\<le> m \\<Longrightarrow> degree q \\<le> n \\<Longrightarrow> coeff (p * q) (m + n) = coeff p m * coeff q n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>degree p \\<le> m; degree q \\<le> n\\<rbrakk>\n    \\<Longrightarrow> coeff (p * q) (m + n) = coeff p m * coeff q n", "using degree_mult_le[of p q]"], ["proof (prove)\nusing this:\n  degree (p * q) \\<le> degree p + degree q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree p \\<le> m; degree q \\<le> n\\<rbrakk>\n    \\<Longrightarrow> coeff (p * q) (m + n) = coeff p m * coeff q n", "by (auto simp add: le_less coeff_eq_0 coeff_mult_degree_sum)"], ["", "lemma coeff_mult_prod_sum:\n  \"coeff (\\<Prod>i\\<in>S. f i) (\\<Sum>i\\<in>S. degree (f i)) = (\\<Prod>i\\<in>S. coeff (f i) (degree (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (prod f S) (\\<Sum>i\\<in>S. degree (f i)) =\n    (\\<Prod>i\\<in>S. lead_coeff (f i))", "by (induct rule: infinite_finite_induct)(simp_all add: coeff_mult_sum degree_prod_le)"], ["", "lemma degree_sum_less:\n  \"0 < n \\<Longrightarrow> (\\<And>x. x \\<in> A \\<Longrightarrow> degree (f x) < n) \\<Longrightarrow> degree (\\<Sum>x\\<in>A. f x) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n;\n     \\<And>x. x \\<in> A \\<Longrightarrow> degree (f x) < n\\<rbrakk>\n    \\<Longrightarrow> degree (sum f A) < n", "by (induct rule: infinite_finite_induct) (simp_all add: degree_add_less)"], ["", "lemma degree_sum_le:\n  shows \"(\\<And>x. x \\<in> A \\<Longrightarrow> degree (f x) \\<le> n) \\<Longrightarrow> degree (\\<Sum>x\\<in>A. f x) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> degree (f x) \\<le> n) \\<Longrightarrow>\n    degree (sum f A) \\<le> n", "by (induct rule: infinite_finite_induct) (auto intro!: degree_add_le)"], ["", "lemma degree_sum_le_Max:\n  \"finite F \\<Longrightarrow> degree (sum f F) \\<le> Max ((\\<lambda>x. degree (f x))`F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F \\<Longrightarrow>\n    degree (sum f F) \\<le> (MAX x\\<in>F. degree (f x))", "by (intro degree_sum_le) (auto intro!: Max.coboundedI)"], ["", "lemma poly_as_sum_of_monoms': assumes n: \"degree p \\<le> n\" shows \"(\\<Sum>i\\<le>n. X^i * C (coeff p i)) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. X ^ i * C (coeff p i)) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. X ^ i * C (coeff p i)) = p", "have eq: \"\\<And>i. {..n} \\<inter> {i} = (if i \\<le> n then {i} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. {..n} \\<inter> {i} = (if i \\<le> n then {i} else {})", "by auto"], ["proof (state)\nthis:\n  {..n} \\<inter> {?i} = (if ?i \\<le> n then {?i} else {})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. X ^ i * C (coeff p i)) = p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. X ^ i * C (coeff p i)) = p", "using n"], ["proof (prove)\nusing this:\n  degree p \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. X ^ i * C (coeff p i)) = p", "by (simp add: poly_eq_iff coeff_sum coeff_eq_0 sum.If_cases eq coeff_pow_X\n                  if_distrib[where f=\"\\<lambda>x. x * a\" for a])"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. X ^ i * C (coeff p i)) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_as_sum_of_monoms: \"(\\<Sum>i\\<le>degree p. X^i * C (coeff p i)) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. X ^ i * C (coeff p i)) = p", "by (intro poly_as_sum_of_monoms' order_refl)"], ["", "lemma degree_sum_unique':\n  assumes I: \"finite I\" \"i \\<notin> I\" \"\\<And>j. j \\<in> I \\<Longrightarrow> degree (p j) < degree (p i)\"\n  shows \"degree (\\<Sum>i\\<in>insert i I. p i) = degree (p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (sum p (insert i I)) = degree (p i)", "using I"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  ?j \\<in> I \\<Longrightarrow> degree (p ?j) < degree (p i)\n\ngoal (1 subgoal):\n 1. degree (sum p (insert i I)) = degree (p i)", "proof (induction I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> {};\n     \\<And>j.\n        j \\<in> {} \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n    \\<Longrightarrow> degree (sum p {i}) = degree (p i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i \\<notin> F;\n         \\<And>j.\n            j \\<in> F \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n        \\<Longrightarrow> degree (sum p (insert i F)) = degree (p i);\n        i \\<notin> insert x F;\n        \\<And>j.\n           j \\<in> insert x F \\<Longrightarrow>\n           degree (p j) < degree (p i)\\<rbrakk>\n       \\<Longrightarrow> degree (sum p (insert i (insert x F))) =\n                         degree (p i)", "case (insert j I)"], ["proof (state)\nthis:\n  finite I\n  j \\<notin> I\n  \\<lbrakk>i \\<notin> I;\n   \\<And>j. j \\<in> I \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n  \\<Longrightarrow> degree (sum p (insert i I)) = degree (p i)\n  i \\<notin> insert j I\n  ?j \\<in> insert j I \\<Longrightarrow> degree (p ?j) < degree (p i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> {};\n     \\<And>j.\n        j \\<in> {} \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n    \\<Longrightarrow> degree (sum p {i}) = degree (p i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>i \\<notin> F;\n         \\<And>j.\n            j \\<in> F \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n        \\<Longrightarrow> degree (sum p (insert i F)) = degree (p i);\n        i \\<notin> insert x F;\n        \\<And>j.\n           j \\<in> insert x F \\<Longrightarrow>\n           degree (p j) < degree (p i)\\<rbrakk>\n       \\<Longrightarrow> degree (sum p (insert i (insert x F))) =\n                         degree (p i)", "then"], ["proof (chain)\npicking this:\n  finite I\n  j \\<notin> I\n  \\<lbrakk>i \\<notin> I;\n   \\<And>j. j \\<in> I \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n  \\<Longrightarrow> degree (sum p (insert i I)) = degree (p i)\n  i \\<notin> insert j I\n  ?j \\<in> insert j I \\<Longrightarrow> degree (p ?j) < degree (p i)", "show ?case"], ["proof (prove)\nusing this:\n  finite I\n  j \\<notin> I\n  \\<lbrakk>i \\<notin> I;\n   \\<And>j. j \\<in> I \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n  \\<Longrightarrow> degree (sum p (insert i I)) = degree (p i)\n  i \\<notin> insert j I\n  ?j \\<in> insert j I \\<Longrightarrow> degree (p ?j) < degree (p i)\n\ngoal (1 subgoal):\n 1. degree (sum p (insert i (insert j I))) = degree (p i)", "by (subst insert_commute) (auto simp: degree_add_eq_right)"], ["proof (state)\nthis:\n  degree (sum p (insert i (insert j I))) = degree (p i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> {};\n     \\<And>j.\n        j \\<in> {} \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n    \\<Longrightarrow> degree (sum p {i}) = degree (p i)", "qed simp"], ["", "lemma degree_sum_unique:\n  \"finite I \\<Longrightarrow> i \\<in> I \\<Longrightarrow> (\\<And>j. j \\<in> I \\<Longrightarrow> j \\<noteq> i \\<Longrightarrow> degree (p j) < degree (p i)) \\<Longrightarrow>\n    degree (\\<Sum>i\\<in>I. p i) = degree (p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; i \\<in> I;\n     \\<And>j.\n        \\<lbrakk>j \\<in> I; j \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n    \\<Longrightarrow> degree (sum p I) = degree (p i)", "using degree_sum_unique'[of \"I - {i}\" i p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (I - {i}); i \\<notin> I - {i};\n   \\<And>j.\n      j \\<in> I - {i} \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n  \\<Longrightarrow> degree (sum p (insert i (I - {i}))) = degree (p i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I; i \\<in> I;\n     \\<And>j.\n        \\<lbrakk>j \\<in> I; j \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> degree (p j) < degree (p i)\\<rbrakk>\n    \\<Longrightarrow> degree (sum p I) = degree (p i)", "by (auto simp: insert_absorb)"], ["", "lemma coeff_sum_unique:\n  fixes p :: \"'a \\<Rightarrow> 'b::semiring_0 poly\"\n  assumes I: \"finite I\" \"i \\<in> I\" \"\\<And>j. j \\<in> I \\<Longrightarrow> j \\<noteq> i \\<Longrightarrow> degree (p j) < degree (p i)\"\n  shows \"coeff (\\<Sum>i\\<in>I. p i) (degree (p i)) = coeff (p i) (degree (p i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (sum p I) (degree (p i)) = lead_coeff (p i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (sum p I) (degree (p i)) = lead_coeff (p i)", "have \"(\\<Sum>j\\<in>I. coeff (p j) (degree (p i))) = (\\<Sum>i\\<in>{i}. coeff (p i) (degree (p i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>I. coeff (p j) (degree (p i))) =\n    (\\<Sum>i\\<in>{i}. lead_coeff (p i))", "using I"], ["proof (prove)\nusing this:\n  finite I\n  i \\<in> I\n  \\<lbrakk>?j \\<in> I; ?j \\<noteq> i\\<rbrakk>\n  \\<Longrightarrow> degree (p ?j) < degree (p i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>I. coeff (p j) (degree (p i))) =\n    (\\<Sum>i\\<in>{i}. lead_coeff (p i))", "by (intro sum.mono_neutral_cong_right) (auto intro!: coeff_eq_0)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>I. coeff (p j) (degree (p i))) =\n  (\\<Sum>i\\<in>{i}. lead_coeff (p i))\n\ngoal (1 subgoal):\n 1. coeff (sum p I) (degree (p i)) = lead_coeff (p i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<in>I. coeff (p j) (degree (p i))) =\n  (\\<Sum>i\\<in>{i}. lead_coeff (p i))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<in>I. coeff (p j) (degree (p i))) =\n  (\\<Sum>i\\<in>{i}. lead_coeff (p i))\n\ngoal (1 subgoal):\n 1. coeff (sum p I) (degree (p i)) = lead_coeff (p i)", "by (simp add: coeff_sum)"], ["proof (state)\nthis:\n  coeff (sum p I) (degree (p i)) = lead_coeff (p i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diag_coeff: \"diag (coeff x i) = map_sq_matrix (\\<lambda>x. coeff x i) (diag x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag (coeff x i) = map_sq_matrix (\\<lambda>x. coeff x i) (diag x)", "by transfer' (simp add: vec_eq_iff)"], ["", "lemma smult_one: \"x *\\<^sub>S 1 = diag x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>S 1 = diag x", "by transfer (simp add: fun_eq_iff)"], ["", "lemma sum_telescope_Ico: \"a \\<le> b \\<Longrightarrow> (\\<Sum>i=a ..< b. f i - f (Suc i) ::_::ab_group_add) = f a - f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    (\\<Sum>i = a..<b. f i - f (Suc i)) = f a - f b", "by (induction b rule: dec_induct) auto"], ["", "lemmas map_sq_matrix = map_sq_matrix_diff map_sq_matrix_add map_sq_matrix_smult map_sq_matrix_sum"], ["", "lemma sign_permut: \"degree (of_int (sign p) * q) = degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (of_int (sign p) * q) = degree q", "by (simp add: sign_def)"], ["", "lemma degree_det:\n  assumes \"\\<And>j. j permutes UNIV \\<Longrightarrow> j \\<noteq> id \\<Longrightarrow> degree (\\<Prod>i\\<in>UNIV. to_fun A i (j i)) < degree (\\<Prod>i\\<in>UNIV. to_fun A i i)\"\n  shows \"degree (det A) = degree (\\<Prod>i\\<in>UNIV. to_fun A i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Square_Matrix.det A) = degree (\\<Prod>i\\<in>UNIV. to_fun A i i)", "unfolding det_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Sum>p | p permutes UNIV.\n        of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i))) =\n    degree (\\<Prod>i\\<in>UNIV. to_fun A i i)", "by (subst degree_sum_unique[where i=id])\n     (simp_all add: sign_permut permutes_id assms)"], ["", "definition max_degree :: \"'a::zero poly^^'n \\<Rightarrow> nat\" where\n  \"max_degree A = Max (range (\\<lambda>(i, j). degree (to_fun A i j)))\""], ["", "lemma degree_le_max_degree: \"degree (to_fun A i j) \\<le> max_degree A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (to_fun A i j) \\<le> max_degree A", "unfolding max_degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (to_fun A i j) \\<le> (MAX (i, j). degree (to_fun A i j))", "by (auto simp add: Max_ge_iff)"], ["", "definition \"charpoly A = det (\\<^bold>X - \\<^bold>C A)\""], ["", "lemma degree_diff_cancel: \"degree q < degree p \\<Longrightarrow> degree (p - q::_::ab_group_add poly) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q < degree p \\<Longrightarrow> degree (p - q) = degree p", "by (metis add_uminus_conv_diff degree_add_eq_left degree_minus)"], ["", "lemma\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  shows degree_charpoly: \"degree (charpoly A) = CARD('n)\"\n    and coeff_charpoly: \"coeff (charpoly A) (degree (charpoly A)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (charpoly A) = CARD('n) &&& lead_coeff (charpoly A) = (1::'a)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "let ?B = \"diag X - map_sq_matrix C A\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "let ?f = \"\\<lambda>p. \\<Prod>i\\<in>UNIV. to_fun ?B i (p i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "let ?g = \"\\<lambda>p. of_int (sign p) * ?f p\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "have dB: \"\\<And>i j. degree (to_fun ?B i j) = (if i = j then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       degree (to_fun (\\<^bold>X - \\<^bold>C A) i j) =\n       (if i = j then 1 else 0)", "by transfer' (simp add: degree_diff_cancel)"], ["proof (state)\nthis:\n  degree (to_fun (\\<^bold>X - \\<^bold>C A) ?i ?j) =\n  (if ?i = ?j then 1 else 0)\n\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "have cB: \"\\<And>i j. coeff (to_fun ?B i j) (Suc 0) = (if i = j then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       coeff (to_fun (\\<^bold>X - \\<^bold>C A) i j) (Suc 0) =\n       (if i = j then 1::'a else (0::'a))", "by transfer' simp"], ["proof (state)\nthis:\n  coeff (to_fun (\\<^bold>X - \\<^bold>C A) ?i ?j) (Suc 0) =\n  (if ?i = ?j then 1::'a else (0::'a))\n\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "have degree_f_id: \"degree (?f (\\<lambda>i. i)) = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i) =\n    CARD('n)", "using coeff_mult_prod_sum[of \"\\<lambda>i. to_fun ?B i i\" UNIV]"], ["proof (prove)\nusing this:\n  coeff (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)\n   (\\<Sum>i\\<in>UNIV. degree (to_fun (\\<^bold>X - \\<^bold>C A) i i)) =\n  (\\<Prod>i\\<in>UNIV. lead_coeff (to_fun (\\<^bold>X - \\<^bold>C A) i i))\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i) =\n    CARD('n)", "by (intro antisym degree_prod_le[THEN order_trans] le_degree)\n       (simp_all add: dB cB)"], ["proof (state)\nthis:\n  degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i) =\n  CARD('n)\n\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "have degree_less: \"\\<And>p. p \\<noteq> id \\<Longrightarrow> degree (?f p) < degree (?f (\\<lambda>i. i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<noteq> id \\<Longrightarrow>\n       degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (p i))\n       < degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)", "unfolding degree_f_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<noteq> id \\<Longrightarrow>\n       degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (p i))\n       < CARD('n)", "by (rule le_less_trans[OF degree_prod_le])\n       (auto simp add: dB sum.If_cases set_eq_iff intro!: psubset_card_mono)"], ["proof (state)\nthis:\n  ?p \\<noteq> id \\<Longrightarrow>\n  degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (?p i))\n  < degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)\n\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "have degree_charpoly: \"degree (charpoly A) = degree (?f (\\<lambda>i. i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (charpoly A) =\n    degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)", "using degree_less"], ["proof (prove)\nusing this:\n  ?p \\<noteq> id \\<Longrightarrow>\n  degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (?p i))\n  < degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)\n\ngoal (1 subgoal):\n 1. degree (charpoly A) =\n    degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)", "unfolding charpoly_def"], ["proof (prove)\nusing this:\n  ?p \\<noteq> id \\<Longrightarrow>\n  degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (?p i))\n  < degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)\n\ngoal (1 subgoal):\n 1. degree (Square_Matrix.det (\\<^bold>X - \\<^bold>C A)) =\n    degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)", "by (rule degree_det)"], ["proof (state)\nthis:\n  degree (charpoly A) =\n  degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)\n\ngoal (2 subgoals):\n 1. degree (charpoly A) = CARD('n)\n 2. lead_coeff (charpoly A) = (1::'a)", "show degree_eq: \"degree (charpoly A) = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (charpoly A) = CARD('n)", "using degree_charpoly degree_f_id"], ["proof (prove)\nusing this:\n  degree (charpoly A) =\n  degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)\n  degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i) =\n  CARD('n)\n\ngoal (1 subgoal):\n 1. degree (charpoly A) = CARD('n)", "by simp"], ["proof (state)\nthis:\n  degree (charpoly A) = CARD('n)\n\ngoal (1 subgoal):\n 1. lead_coeff (charpoly A) = (1::'a)", "have \"coeff (\\<Sum>p | p permutes UNIV. ?g p) (degree (?g id)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff\n     (\\<Sum>p | p permutes UNIV.\n        of_int (sign p) *\n        (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (p i)))\n     (degree\n       (of_int (sign id) *\n        (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i)))) =\n    (1::'a)", "proof (subst coeff_sum_unique)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {p. p permutes UNIV}\n 2. id \\<in> {p. p permutes UNIV}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> {p. p permutes UNIV}; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (of_int (sign j) *\n                           (\\<Prod>i\\<in>UNIV.\n                              to_fun (\\<^bold>X - \\<^bold>C A) i (j i)))\n                         < degree\n                            (of_int (sign id) *\n                             (\\<Prod>i\\<in>UNIV.\n                                to_fun (\\<^bold>X - \\<^bold>C A) i (id i)))\n 4. lead_coeff\n     (of_int (sign id) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i))) =\n    (1::'a)", "show \"coeff (?g id) (degree (?g id)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff\n     (of_int (sign id) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i))) =\n    (1::'a)", "using coeff_mult_prod_sum[of \"\\<lambda>i. to_fun ?B i i\" UNIV]"], ["proof (prove)\nusing this:\n  coeff (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)\n   (\\<Sum>i\\<in>UNIV. degree (to_fun (\\<^bold>X - \\<^bold>C A) i i)) =\n  (\\<Prod>i\\<in>UNIV. lead_coeff (to_fun (\\<^bold>X - \\<^bold>C A) i i))\n\ngoal (1 subgoal):\n 1. lead_coeff\n     (of_int (sign id) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i))) =\n    (1::'a)", "by (simp add: dB cB sign_id degree_f_id)"], ["proof (state)\nthis:\n  lead_coeff\n   (of_int (sign id) *\n    (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i))) =\n  (1::'a)\n\ngoal (3 subgoals):\n 1. finite {p. p permutes UNIV}\n 2. id \\<in> {p. p permutes UNIV}\n 3. \\<And>j.\n       \\<lbrakk>j \\<in> {p. p permutes UNIV}; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (of_int (sign j) *\n                           (\\<Prod>i\\<in>UNIV.\n                              to_fun (\\<^bold>X - \\<^bold>C A) i (j i)))\n                         < degree\n                            (of_int (sign id) *\n                             (\\<Prod>i\\<in>UNIV.\n                                to_fun (\\<^bold>X - \\<^bold>C A) i (id i)))", "qed (auto simp: degree_less sign_permut permutes_id)"], ["proof (state)\nthis:\n  coeff\n   (\\<Sum>p | p permutes UNIV.\n      of_int (sign p) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (p i)))\n   (degree\n     (of_int (sign id) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i)))) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff (charpoly A) = (1::'a)", "then"], ["proof (chain)\npicking this:\n  coeff\n   (\\<Sum>p | p permutes UNIV.\n      of_int (sign p) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (p i)))\n   (degree\n     (of_int (sign id) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i)))) =\n  (1::'a)", "show \"coeff (charpoly A) (degree (charpoly A)) = 1\""], ["proof (prove)\nusing this:\n  coeff\n   (\\<Sum>p | p permutes UNIV.\n      of_int (sign p) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (p i)))\n   (degree\n     (of_int (sign id) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i)))) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. lead_coeff (charpoly A) = (1::'a)", "unfolding degree_charpoly"], ["proof (prove)\nusing this:\n  coeff\n   (\\<Sum>p | p permutes UNIV.\n      of_int (sign p) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (p i)))\n   (degree\n     (of_int (sign id) *\n      (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i (id i)))) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. coeff (charpoly A)\n     (degree (\\<Prod>i\\<in>UNIV. to_fun (\\<^bold>X - \\<^bold>C A) i i)) =\n    (1::'a)", "by (simp add: sign_permut charpoly_def det_eq)"], ["proof (state)\nthis:\n  lead_coeff (charpoly A) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"max_perm_degree A = Max ((\\<lambda>p. \\<Sum>i\\<in>UNIV. degree (to_fun A i (p i)))`{p. p permutes UNIV})\""], ["", "lemma max_perm_degree_eqI:\n  \"(\\<And>p. p permutes (UNIV::'a::finite set) \\<Longrightarrow> (\\<Sum>i\\<in>UNIV. degree (to_fun A i (p i))) \\<le> x) \\<Longrightarrow>\n    (\\<exists>p. p permutes UNIV \\<and> (\\<Sum>i\\<in>UNIV. degree (to_fun A i (p i))) = x) \\<Longrightarrow>\n    max_perm_degree A = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                p permutes UNIV \\<Longrightarrow>\n                (\\<Sum>i\\<in>UNIV. degree (to_fun A i (p i))) \\<le> x;\n     \\<exists>p.\n        p permutes UNIV \\<and>\n        (\\<Sum>i\\<in>UNIV. degree (to_fun A i (p i))) = x\\<rbrakk>\n    \\<Longrightarrow> max_perm_degree A = x", "by (auto intro!: Max_eqI  simp: max_perm_degree_def)"], ["", "lemma degree_prod_le_max_perm_degree:\n  \"j permutes (UNIV::'a::finite set) \\<Longrightarrow> degree (\\<Prod>i\\<in>UNIV. to_fun A i (j i)) \\<le> max_perm_degree A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j permutes UNIV \\<Longrightarrow>\n    degree (\\<Prod>i\\<in>UNIV. to_fun A i (j i)) \\<le> max_perm_degree A", "unfolding max_perm_degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j permutes UNIV \\<Longrightarrow>\n    degree (\\<Prod>i\\<in>UNIV. to_fun A i (j i))\n    \\<le> (MAX p\\<in>{p. p permutes UNIV}.\n              \\<Sum>i\\<in>UNIV. degree (to_fun A i (p i)))", "by (rule order_trans[OF degree_prod_le]) auto"], ["", "lemma degree_le_max_perm_degree: \"degree (det A) \\<le> max_perm_degree A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Square_Matrix.det A) \\<le> max_perm_degree A", "unfolding det_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Sum>p | p permutes UNIV.\n        of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))\n    \\<le> max_perm_degree A", "by (rule order_trans[OF degree_sum_le_Max])\n     (auto intro!: degree_prod_le_max_perm_degree Max_le_iff[THEN iffD2] permutes_id simp: sign_permut)"], ["", "lemma max_degree_adjugate:\n  fixes A :: \"_^^'n\"\n  shows \"max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1\"\n    (is \"?R = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "let ?M = \"minor (\\<^bold>X - \\<^bold>C A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "let ?D = \"\\<lambda>i j k l. degree (to_fun (?M i j) k l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "have M: \"\\<And>i j k l. to_fun (?M i j) k l = (if k = i \\<and> l = j then 1\n    else if k = i \\<or> l = j then 0\n    else if k = l then [: - to_fun A k l, 1 :] else [: - to_fun A k l :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k l.\n       to_fun (minor (\\<^bold>X - \\<^bold>C A) i j) k l =\n       (if k = i \\<and> l = j then 1\n        else if k = i \\<or> l = j then 0\n             else if k = l then [:- to_fun A k l, 1::'b:]\n                  else [:- to_fun A k l:])", "by transfer' (simp add: vec_eq_iff C_def X_def)"], ["proof (state)\nthis:\n  to_fun (minor (\\<^bold>X - \\<^bold>C A) ?i ?j) ?k ?l =\n  (if ?k = ?i \\<and> ?l = ?j then 1\n   else if ?k = ?i \\<or> ?l = ?j then 0\n        else if ?k = ?l then [:- to_fun A ?k ?l, 1::'b:]\n             else [:- to_fun A ?k ?l:])\n\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "have \"?R = Max (range (\\<lambda>(i, j). degree (det (?M j i))))\" (is \"_ = Max ?Max\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) =\n    (MAX (i, j).\n        degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "unfolding max_degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX (i, j). degree (to_fun (adjugate (\\<^bold>X - \\<^bold>C A)) i j)) =\n    (MAX (i, j).\n        degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "by (simp add: transpose.rep_eq cofactor_def adjugate_def of_fun_inverse)"], ["proof (state)\nthis:\n  max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) =\n  (MAX (i, j).\n      degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))\n\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "also"], ["proof (state)\nthis:\n  max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) =\n  (MAX (i, j).\n      degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))\n\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "have \"\\<dots> = CARD('n) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX (i, j).\n        degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))) =\n    CARD('n) - 1", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (MAX (i, j).\n        degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))\n    \\<le> CARD('n) - 1\n 2. CARD('n) - 1\n    \\<le> (MAX (i, j).\n              degree\n               (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "show \"Max ?Max \\<le> CARD('n) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (MAX (i, j).\n        degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))\n    \\<le> CARD('n) - 1", "proof (safe intro!: Max.boundedI)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     (range\n       (\\<lambda>(i, j).\n           degree\n            (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))))\n 2. \\<And>a aa b.\n       (aa, b) \\<in> UNIV \\<Longrightarrow>\n       degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) b aa))\n       \\<le> CARD('n) - 1", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     (range\n       (\\<lambda>(i, j).\n           degree\n            (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))))\n 2. \\<And>a aa b.\n       (aa, b) \\<in> UNIV \\<Longrightarrow>\n       degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) b aa))\n       \\<le> CARD('n) - 1", "have \"max_perm_degree (?M j i) = card (UNIV - {i, j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_perm_degree (minor (\\<^bold>X - \\<^bold>C A) j i) =\n    card (UNIV - {i, j})", "by (intro max_perm_degree_eqI)\n           (auto simp: M sum.If_cases if_distrib[of degree] simp del: card_Diff_insert\n                 intro!: card_mono permutes_id arg_cong[where f=card])"], ["proof (state)\nthis:\n  max_perm_degree (minor (\\<^bold>X - \\<^bold>C A) j i) =\n  card (UNIV - {i, j})\n\ngoal (2 subgoals):\n 1. finite\n     (range\n       (\\<lambda>(i, j).\n           degree\n            (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))))\n 2. \\<And>a aa b.\n       (aa, b) \\<in> UNIV \\<Longrightarrow>\n       degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) b aa))\n       \\<le> CARD('n) - 1", "then"], ["proof (chain)\npicking this:\n  max_perm_degree (minor (\\<^bold>X - \\<^bold>C A) j i) =\n  card (UNIV - {i, j})", "show \"degree (det (?M j i)) \\<le> CARD('n) - 1\""], ["proof (prove)\nusing this:\n  max_perm_degree (minor (\\<^bold>X - \\<^bold>C A) j i) =\n  card (UNIV - {i, j})\n\ngoal (1 subgoal):\n 1. degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))\n    \\<le> CARD('n) - 1", "using degree_le_max_perm_degree[of \"?M j i\"]"], ["proof (prove)\nusing this:\n  max_perm_degree (minor (\\<^bold>X - \\<^bold>C A) j i) =\n  card (UNIV - {i, j})\n  degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))\n  \\<le> max_perm_degree (minor (\\<^bold>X - \\<^bold>C A) j i)\n\ngoal (1 subgoal):\n 1. degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))\n    \\<le> CARD('n) - 1", "by (cases \"i = j\") auto"], ["proof (state)\nthis:\n  degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))\n  \\<le> CARD('n) - 1\n\ngoal (1 subgoal):\n 1. finite\n     (range\n       (\\<lambda>(i, j).\n           degree\n            (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))))", "qed auto"], ["proof (state)\nthis:\n  (MAX (i, j).\n      degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))\n  \\<le> CARD('n) - 1\n\ngoal (1 subgoal):\n 1. CARD('n) - 1\n    \\<le> (MAX (i, j).\n              degree\n               (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. CARD('n) - 1\n    \\<le> (MAX (i, j).\n              degree\n               (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "obtain x :: 'n where True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (True \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  True\n\ngoal (1 subgoal):\n 1. CARD('n) - 1\n    \\<le> (MAX (i, j).\n              degree\n               (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "let ?P = \"\\<lambda>j k p. \\<Prod>i\\<in>UNIV. to_fun (?M j k) i (p i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. CARD('n) - 1\n    \\<le> (MAX (i, j).\n              degree\n               (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "have \"degree (det (?M x x)) = CARD('n) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) x x)) =\n    CARD('n) - 1", "proof (subst degree_det)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)\n 2. degree\n     (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i) =\n    CARD('n) - 1", "have \"CARD('n) - 1 = (\\<Sum>i\\<in>UNIV. ?D x x i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) - 1 =\n    (\\<Sum>i\\<in>UNIV.\n       degree (to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i))", "by (simp add: M if_distrib[where f=\"degree\"] sum.If_cases Collect_neg_eq Compl_eq_Diff_UNIV)"], ["proof (state)\nthis:\n  CARD('n) - 1 =\n  (\\<Sum>i\\<in>UNIV.\n     degree (to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i))\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)\n 2. degree\n     (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i) =\n    CARD('n) - 1", "also"], ["proof (state)\nthis:\n  CARD('n) - 1 =\n  (\\<Sum>i\\<in>UNIV.\n     degree (to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i))\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)\n 2. degree\n     (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i) =\n    CARD('n) - 1", "have \"\\<dots> = degree (?P x x id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV.\n       degree (to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i)) =\n    degree\n     (\\<Prod>i\\<in>UNIV.\n        to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (id i))", "by (auto intro!: antisym degree_prod_le le_degree simp add: coeff_mult_prod_sum)\n           (simp add: M if_distrib[where f=\"\\<lambda>x. coeff x b\" for b] prod.If_cases)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV.\n     degree (to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i)) =\n  degree\n   (\\<Prod>i\\<in>UNIV.\n      to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (id i))\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)\n 2. degree\n     (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i) =\n    CARD('n) - 1", "finally"], ["proof (chain)\npicking this:\n  CARD('n) - 1 =\n  degree\n   (\\<Prod>i\\<in>UNIV.\n      to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (id i))", "show *: \"degree (?P x x (\\<lambda>x. x)) = CARD('n) - 1\""], ["proof (prove)\nusing this:\n  CARD('n) - 1 =\n  degree\n   (\\<Prod>i\\<in>UNIV.\n      to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (id i))\n\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i) =\n    CARD('n) - 1", "by simp"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i) =\n  CARD('n) - 1\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "fix p :: \"'n \\<Rightarrow> 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "assume \"p permutes UNIV\" \"p \\<noteq> id\""], ["proof (state)\nthis:\n  p permutes UNIV\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "then"], ["proof (chain)\npicking this:\n  p permutes UNIV\n  p \\<noteq> id", "obtain i j where ij: \"i \\<noteq> j\" \"p i = j\"  and p: \"i \\<noteq> p i\" \"j \\<noteq> p j\""], ["proof (prove)\nusing this:\n  p permutes UNIV\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; p i = j; i \\<noteq> p i;\n         j \\<noteq> p j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding id_def"], ["proof (prove)\nusing this:\n  p permutes UNIV\n  p \\<noteq> (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; p i = j; i \\<noteq> p i;\n         j \\<noteq> p j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (metis permutes_univ)"], ["proof (state)\nthis:\n  i \\<noteq> j\n  p i = j\n  i \\<noteq> p i\n  j \\<noteq> p j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  p i = j\n  i \\<noteq> p i\n  j \\<noteq> p j", "have \"card {i,j} \\<le> CARD('n)\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  p i = j\n  i \\<noteq> p i\n  j \\<noteq> p j\n\ngoal (1 subgoal):\n 1. card {i, j} \\<le> CARD('n)", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card {i, j} \\<le> CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "have \"degree (?P x x p) \\<le> card (UNIV - {i, j})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<in>UNIV.\n        to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n    \\<le> card (UNIV - {i, j})", "using degree_prod_le"], ["proof (prove)\nusing this:\n  degree (prod ?f ?S) \\<le> (\\<Sum>i\\<in>?S. degree (?f i))\n\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<in>UNIV.\n        to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n    \\<le> card (UNIV - {i, j})", "by (rule order_trans)\n           (auto simp: M if_distrib[where f=\"degree\"] sum.If_cases Collect_neg_eq Compl_eq_Diff_UNIV p intro!: card_mono)"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n  \\<le> card (UNIV - {i, j})\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "also"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n  \\<le> card (UNIV - {i, j})\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "have \"\\<dots> < CARD('n) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV - {i, j}) < CARD('n) - 1", "using \\<open>card {i, j} \\<le> CARD('n)\\<close> ij"], ["proof (prove)\nusing this:\n  card {i, j} \\<le> CARD('n)\n  i \\<noteq> j\n  p i = j\n\ngoal (1 subgoal):\n 1. card (UNIV - {i, j}) < CARD('n) - 1", "by auto"], ["proof (state)\nthis:\n  card (UNIV - {i, j}) < CARD('n) - 1\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j permutes UNIV; j \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> degree\n                          (\\<Prod>i\\<in>UNIV.\n                             to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i\n                              (j i))\n                         < degree\n                            (\\<Prod>i\\<in>UNIV.\n                               to_fun (minor (\\<^bold>X - \\<^bold>C A) x x)\n                                i i)", "finally"], ["proof (chain)\npicking this:\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n  < CARD('n) - 1", "show \"degree (?P x x p) < degree (?P x x (\\<lambda>x. x))\""], ["proof (prove)\nusing this:\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n  < CARD('n) - 1\n\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<in>UNIV.\n        to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n    < degree\n       (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i)", "using *"], ["proof (prove)\nusing this:\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n  < CARD('n) - 1\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i) =\n  CARD('n) - 1\n\ngoal (1 subgoal):\n 1. degree\n     (\\<Prod>i\\<in>UNIV.\n        to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n    < degree\n       (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i)", "by simp"], ["proof (state)\nthis:\n  degree\n   (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i (p i))\n  < degree\n     (\\<Prod>i\\<in>UNIV. to_fun (minor (\\<^bold>X - \\<^bold>C A) x x) i i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) x x)) =\n  CARD('n) - 1\n\ngoal (1 subgoal):\n 1. CARD('n) - 1\n    \\<le> (MAX (i, j).\n              degree\n               (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "then"], ["proof (chain)\npicking this:\n  degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) x x)) =\n  CARD('n) - 1", "show \"CARD('n) - 1 \\<le> Max ?Max\""], ["proof (prove)\nusing this:\n  degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) x x)) =\n  CARD('n) - 1\n\ngoal (1 subgoal):\n 1. CARD('n) - 1\n    \\<le> (MAX (i, j).\n              degree\n               (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))", "by (auto simp add: Max_ge_iff intro!: exI[of _ x])"], ["proof (state)\nthis:\n  CARD('n) - 1\n  \\<le> (MAX (i, j).\n            degree\n             (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (MAX (i, j).\n      degree (Square_Matrix.det (minor (\\<^bold>X - \\<^bold>C A) j i))) =\n  CARD('n) - 1\n\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "finally"], ["proof (chain)\npicking this:\n  max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1\n\ngoal (1 subgoal):\n 1. max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1", "."], ["proof (state)\nthis:\n  max_degree (adjugate (\\<^bold>X - \\<^bold>C A)) = CARD('n) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poly_mat :: \"'a::ring_1 poly \\<Rightarrow> 'a^^'n \\<Rightarrow> 'a^^'n\" where\n  \"poly_mat p A = (\\<Sum>i\\<le>degree p. coeff p i *\\<^sub>S A^i)\""], ["", "lemma zero_smult[simp]: \"0 *\\<^sub>S M = (0::'a::semiring_1^^'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) *\\<^sub>S M = 0", "by transfer (simp add: vec_eq_iff)"], ["", "lemma smult_smult: \"a *\\<^sub>S b *\\<^sub>S M = (a * b::'a::monoid_mult) *\\<^sub>S M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>S b *\\<^sub>S M = (a * b) *\\<^sub>S M", "by transfer (simp add: mult_ac)"], ["", "lemma map_sq_matrix_mult_eq_smult[simp]: \"map_sq_matrix ((*) a) M = a *\\<^sub>S M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sq_matrix ((*) a) M = a *\\<^sub>S M", "by transfer rule"], ["", "lemma coeff_smult_1: \"coeff p i *\\<^sub>S m = m * map_sq_matrix (\\<lambda>p. coeff p i) (p *\\<^sub>S 1::_::comm_ring_1 ^^ 'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p i *\\<^sub>S m =\n    m * map_sq_matrix (\\<lambda>p. coeff p i) (p *\\<^sub>S 1)", "by (simp add: smult_one mult_diag)"], ["", "lemma map_sq_matrix_if_distrib[simp]:\n  \"map_sq_matrix (\\<lambda>x. if P then f x else g x) = (if P then map_sq_matrix f else map_sq_matrix g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sq_matrix (\\<lambda>x. if P then f x else g x) =\n    (if P then map_sq_matrix f else map_sq_matrix g)", "by simp"], ["", "(*>*)"], ["", "theorem Cayley_Hamilton:\n  fixes A :: \"'a::comm_ring_1 ^^ 'n\"\n  shows \"poly_mat (charpoly A) A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "text %visible \\<open>\\hrulefill ~~ Part 1 ~~ \\hrulefill\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "define n where \"n = CARD('n) - 1\""], ["proof (state)\nthis:\n  n = CARD('n) - 1\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "then"], ["proof (chain)\npicking this:\n  n = CARD('n) - 1", "have d_charpoly: \"n + 1 = degree (charpoly A)\" and \n      d_adj: \"n = max_degree (adjugate (\\<^bold>X - \\<^bold>C A))\""], ["proof (prove)\nusing this:\n  n = CARD('n) - 1\n\ngoal (1 subgoal):\n 1. n + 1 = degree (charpoly A) &&&\n    n = max_degree (adjugate (\\<^bold>X - \\<^bold>C A))", "by %invisible (simp_all add: degree_charpoly n_def max_degree_adjugate monom_0 diag_1[symmetric])"], ["proof (state)\nthis:\n  n + 1 = degree (charpoly A)\n  n = max_degree (adjugate (\\<^bold>X - \\<^bold>C A))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "define B where \"B i = map_sq_matrix (\\<lambda>p. coeff p i) (adjugate (\\<^bold>X - \\<^bold>C A))\" for i"], ["proof (state)\nthis:\n  B ?i =\n  map_sq_matrix (\\<lambda>p. coeff p ?i)\n   (adjugate (\\<^bold>X - \\<^bold>C A))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have A_eq_B: \"adjugate (\\<^bold>X - \\<^bold>C A) = (\\<Sum>i\\<le>n. X^i *\\<^sub>S \\<^bold>C (B i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjugate (\\<^bold>X - \\<^bold>C A) =\n    (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (B i))", "by %invisible (simp add: map_sq_matrix_smult sum_map_sq_matrix B_def d_adj\n                        degree_le_max_degree poly_as_sum_of_monoms' cong: map_sq_matrix_cong)"], ["proof (state)\nthis:\n  adjugate (\\<^bold>X - \\<^bold>C A) =\n  (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (B i))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "text %visible \\<open>\\hrulefill ~~ Part 2 ~~ \\hrulefill\\<close>"], ["proof (state)\nthis:\n  adjugate (\\<^bold>X - \\<^bold>C A) =\n  (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (B i))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"charpoly A *\\<^sub>S 1 = X *\\<^sub>S adjugate (\\<^bold>X - \\<^bold>C A) - \\<^bold>C A * adjugate (\\<^bold>X - \\<^bold>C A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. charpoly A *\\<^sub>S 1 =\n    X *\\<^sub>S adjugate (\\<^bold>X - \\<^bold>C A) -\n    \\<^bold>C A * adjugate (\\<^bold>X - \\<^bold>C A)", "by %invisible (simp add: smult_one charpoly_def mult_adjugate_det[symmetric] field_simps diag_mult)"], ["proof (state)\nthis:\n  charpoly A *\\<^sub>S 1 =\n  X *\\<^sub>S adjugate (\\<^bold>X - \\<^bold>C A) -\n  \\<^bold>C A * adjugate (\\<^bold>X - \\<^bold>C A)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  charpoly A *\\<^sub>S 1 =\n  X *\\<^sub>S adjugate (\\<^bold>X - \\<^bold>C A) -\n  \\<^bold>C A * adjugate (\\<^bold>X - \\<^bold>C A)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"\\<dots> = (\\<Sum>i\\<le>n. X^(i + 1) *\\<^sub>S \\<^bold>C (B i)) - (\\<Sum>i\\<le>n. X^i *\\<^sub>S \\<^bold>C (A * B i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X *\\<^sub>S adjugate (\\<^bold>X - \\<^bold>C A) -\n    \\<^bold>C A * adjugate (\\<^bold>X - \\<^bold>C A) =\n    (\\<Sum>i\\<le>n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) -\n    (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (A * B i))", "unfolding %invisible A_eq_B"], ["proof (prove)\ngoal (1 subgoal):\n 1. X *\\<^sub>S (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (B i)) -\n    \\<^bold>C A * (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (B i)) =\n    (\\<Sum>i\\<le>n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) -\n    (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (A * B i))", "by %invisible (simp add: sum_distrib_left smult_mult2[symmetric]\n      map_sq_matrix_mult[symmetric] C_linear smult_sum[symmetric] smult_smult)"], ["proof (state)\nthis:\n  X *\\<^sub>S adjugate (\\<^bold>X - \\<^bold>C A) -\n  \\<^bold>C A * adjugate (\\<^bold>X - \\<^bold>C A) =\n  (\\<Sum>i\\<le>n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) -\n  (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (A * B i))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  X *\\<^sub>S adjugate (\\<^bold>X - \\<^bold>C A) -\n  \\<^bold>C A * adjugate (\\<^bold>X - \\<^bold>C A) =\n  (\\<Sum>i\\<le>n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) -\n  (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (A * B i))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"(\\<Sum>i\\<le>n. X^(i + 1) *\\<^sub>S \\<^bold>C (B i)) =\n      (\\<Sum>i<n. X^(i + 1) *\\<^sub>S \\<^bold>C (B i)) + X^(n + 1) *\\<^sub>S \\<^bold>C (B n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) =\n    (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) +\n    X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n)", "by %invisible (simp add: lessThan_Suc_atMost[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) =\n  (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) +\n  X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) =\n  (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) +\n  X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"(\\<Sum>i\\<le>n. X^i *\\<^sub>S \\<^bold>C (A * B i)) =\n      (\\<Sum>i<n. X^(i + 1) *\\<^sub>S \\<^bold>C (A * B (i + 1))) + \\<^bold>C (A * B 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (A * B i)) =\n    (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (A * B (i + 1))) +\n    \\<^bold>C (A * B 0)", "unfolding %invisible lessThan_Suc_atMost[symmetric] lessThan_Suc_eq_insert_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert 0 (Suc ` {..<n}).\n       X ^ i *\\<^sub>S \\<^bold>C (A * B i)) =\n    (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (A * B (i + 1))) +\n    \\<^bold>C (A * B 0)", "by %invisible (simp add: zero_notin_Suc_image monom_0 sum.reindex one_poly_def[symmetric] diag_mult)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. X ^ i *\\<^sub>S \\<^bold>C (A * B i)) =\n  (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (A * B (i + 1))) +\n  \\<^bold>C (A * B 0)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "finally"], ["proof (chain)\npicking this:\n  charpoly A *\\<^sub>S 1 =\n  (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) +\n  X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n) -\n  ((\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (A * B (i + 1))) +\n   \\<^bold>C (A * B 0))", "have diag_charpoly:\n    \"charpoly A *\\<^sub>S 1 = X^(n + 1) *\\<^sub>S \\<^bold>C (B n) +\n      (\\<Sum>i<n. X^(i + 1) *\\<^sub>S \\<^bold>C (B i - A * B (i + 1))) - \\<^bold>C (A * B 0)\""], ["proof (prove)\nusing this:\n  charpoly A *\\<^sub>S 1 =\n  (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i)) +\n  X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n) -\n  ((\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (A * B (i + 1))) +\n   \\<^bold>C (A * B 0))\n\ngoal (1 subgoal):\n 1. charpoly A *\\<^sub>S 1 =\n    X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n) +\n    (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i - A * B (i + 1))) -\n    \\<^bold>C (A * B 0)", "by %invisible (simp add: map_sq_matrix_diff C_linear sum_subtractf smult_diff)"], ["proof (state)\nthis:\n  charpoly A *\\<^sub>S 1 =\n  X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n) +\n  (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i - A * B (i + 1))) -\n  \\<^bold>C (A * B 0)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "text %visible \\<open>\\hrulefill ~~ Part 3 ~~ \\hrulefill\\<close>"], ["proof (state)\nthis:\n  charpoly A *\\<^sub>S 1 =\n  X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n) +\n  (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i - A * B (i + 1))) -\n  \\<^bold>C (A * B 0)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "let ?p = \"\\<lambda>i. coeff (charpoly A) i *\\<^sub>S A^i\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "let ?AB = \"\\<lambda>i. A^(i + 1) * B i\""], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"(\\<Sum>i\\<le>n+1. ?p i) = ?p 0 + (\\<Sum>i<n. ?p (i + 1)) + ?p (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n + 1. coeff (charpoly A) i *\\<^sub>S A ^ i) =\n    coeff (charpoly A) 0 *\\<^sub>S A ^ 0 +\n    (\\<Sum>i<n. coeff (charpoly A) (i + 1) *\\<^sub>S A ^ (i + 1)) +\n    coeff (charpoly A) (n + 1) *\\<^sub>S A ^ (n + 1)", "unfolding %invisible sum.atMost_Suc_shift Suc_eq_plus1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (charpoly A) 0 *\\<^sub>S A ^ 0 +\n    (\\<Sum>i\\<le>n. coeff (charpoly A) (Suc i) *\\<^sub>S A ^ Suc i) =\n    coeff (charpoly A) 0 *\\<^sub>S A ^ 0 +\n    (\\<Sum>i<n. coeff (charpoly A) (Suc i) *\\<^sub>S A ^ Suc i) +\n    coeff (charpoly A) (Suc n) *\\<^sub>S A ^ Suc n", "by %invisible (simp add: lessThan_Suc_atMost[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n + 1. coeff (charpoly A) i *\\<^sub>S A ^ i) =\n  coeff (charpoly A) 0 *\\<^sub>S A ^ 0 +\n  (\\<Sum>i<n. coeff (charpoly A) (i + 1) *\\<^sub>S A ^ (i + 1)) +\n  coeff (charpoly A) (n + 1) *\\<^sub>S A ^ (n + 1)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n + 1. coeff (charpoly A) i *\\<^sub>S A ^ i) =\n  coeff (charpoly A) 0 *\\<^sub>S A ^ 0 +\n  (\\<Sum>i<n. coeff (charpoly A) (i + 1) *\\<^sub>S A ^ (i + 1)) +\n  coeff (charpoly A) (n + 1) *\\<^sub>S A ^ (n + 1)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"?p 0 = - ?AB 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (charpoly A) 0 *\\<^sub>S A ^ 0 = - (A ^ (0 + 1) * B 0)", "by %invisible (simp add: coeff_smult_1 diag_charpoly map_sq_matrix)"], ["proof (state)\nthis:\n  coeff (charpoly A) 0 *\\<^sub>S A ^ 0 = - (A ^ (0 + 1) * B 0)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  coeff (charpoly A) 0 *\\<^sub>S A ^ 0 = - (A ^ (0 + 1) * B 0)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"(\\<Sum>i<n. ?p (i + 1)) = (\\<Sum>i=0..<n. ?AB i - ?AB (i + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. coeff (charpoly A) (i + 1) *\\<^sub>S A ^ (i + 1)) =\n    (\\<Sum>i = 0..<n. A ^ (i + 1) * B i - A ^ (i + 1 + 1) * B (i + 1))", "by %invisible (rule sum.cong)\n         (auto simp: coeff_smult_1 coeff_pow_X diag_charpoly map_sq_matrix sum_subtractf\n                     if_distrib[where f=\"\\<lambda>x. x a\" for a] if_distrib[where f=\"\\<lambda>x. a * x\" for a]\n                     field_simps sum.If_cases power_Suc2\n               simp del: power_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. coeff (charpoly A) (i + 1) *\\<^sub>S A ^ (i + 1)) =\n  (\\<Sum>i = 0..<n. A ^ (i + 1) * B i - A ^ (i + 1 + 1) * B (i + 1))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. coeff (charpoly A) (i + 1) *\\<^sub>S A ^ (i + 1)) =\n  (\\<Sum>i = 0..<n. A ^ (i + 1) * B i - A ^ (i + 1 + 1) * B (i + 1))\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"\\<dots> = ?AB 0 - ?AB n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. A ^ (i + 1) * B i - A ^ (i + 1 + 1) * B (i + 1)) =\n    A ^ (0 + 1) * B 0 - A ^ (n + 1) * B n", "unfolding %invisible Suc_eq_plus1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. A ^ Suc i * B i - A ^ Suc (Suc i) * B (Suc i)) =\n    A ^ Suc 0 * B 0 - A ^ Suc n * B n", "by %invisible (subst sum_telescope_Ico) auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. A ^ (i + 1) * B i - A ^ (i + 1 + 1) * B (i + 1)) =\n  A ^ (0 + 1) * B 0 - A ^ (n + 1) * B n\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. A ^ (i + 1) * B i - A ^ (i + 1 + 1) * B (i + 1)) =\n  A ^ (0 + 1) * B 0 - A ^ (n + 1) * B n\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"?AB n = ?p (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^ (n + 1) * B n = coeff (charpoly A) (n + 1) *\\<^sub>S A ^ (n + 1)", "unfolding %invisible coeff_smult_1 diag_charpoly"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^ (n + 1) * B n =\n    A ^ (n + 1) *\n    map_sq_matrix (\\<lambda>p. coeff p (n + 1))\n     (X ^ (n + 1) *\\<^sub>S \\<^bold>C (B n) +\n      (\\<Sum>i<n. X ^ (i + 1) *\\<^sub>S \\<^bold>C (B i - A * B (i + 1))) -\n      \\<^bold>C (A * B 0))", "by %invisible (simp add: mult_diag map_sq_matrix coeff_pow_X)"], ["proof (state)\nthis:\n  A ^ (n + 1) * B n = coeff (charpoly A) (n + 1) *\\<^sub>S A ^ (n + 1)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "also"], ["proof (state)\nthis:\n  A ^ (n + 1) * B n = coeff (charpoly A) (n + 1) *\\<^sub>S A ^ (n + 1)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "have \"coeff (charpoly A) (n + 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (charpoly A) (n + 1) = (1::'a)", "by %invisible (simp add: coeff_charpoly d_charpoly[simplified])"], ["proof (state)\nthis:\n  coeff (charpoly A) (n + 1) = (1::'a)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>n + 1. coeff (charpoly A) i *\\<^sub>S A ^ i) =\n  - (A ^ (0 + 1) * B 0) +\n  (A ^ (0 + 1) * B 0 - (1::'a) *\\<^sub>S A ^ (n + 1)) +\n  (1::'a) *\\<^sub>S A ^ (n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>n + 1. coeff (charpoly A) i *\\<^sub>S A ^ i) =\n  - (A ^ (0 + 1) * B 0) +\n  (A ^ (0 + 1) * B 0 - (1::'a) *\\<^sub>S A ^ (n + 1)) +\n  (1::'a) *\\<^sub>S A ^ (n + 1)\n\ngoal (1 subgoal):\n 1. poly_mat (charpoly A) A = 0", "by %invisible (simp add: poly_mat_def d_charpoly[simplified] diag_0_eq mult_diag)"], ["proof (state)\nthis:\n  poly_mat (charpoly A) A = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}