{"file_name": "/home/qj213/afp-2021-10-22/thys/Cayley_Hamilton/Square_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Cayley_Hamilton", "problem_names": ["lemma smult_axis: \"x *s axis i y = axis i (x * y::_::mult_zero)\"", "lemma from_vec_eq_iff: \"from_vec M = from_vec N \\<longleftrightarrow> M = N\"", "lemma to_vec_from_vec[simp]: \"to_vec (from_vec M) = M\"", "lemma from_vec_to_vec[simp]: \"from_vec (to_vec M) = M\"", "lemma map_sq_matrix_compose[simp]: \"map_sq_matrix f (map_sq_matrix g M) = map_sq_matrix (\\<lambda>x. f (g x)) M\"", "lemma map_sq_matrix_ident[simp]: \"map_sq_matrix (\\<lambda>x. x) M = M\"", "lemma map_sq_matrix_cong:\n  \"M = N \\<Longrightarrow> (\\<And>i j. f (to_fun N i j) = g (to_fun N i j)) \\<Longrightarrow> map_sq_matrix f M = map_sq_matrix g N\"", "lemma diag_eq_iff: \"diag x = diag y \\<longleftrightarrow>  x = y\"", "lemma map_sq_matrix_diag[simp]: \"f 0 = 0 \\<Longrightarrow> map_sq_matrix f (diag c) = diag (f c)\"", "lemma smult_map_sq_matrix:\n  \"(\\<And>y. f (x * y) = z * f y) \\<Longrightarrow> map_sq_matrix f (x *\\<^sub>S A) = z *\\<^sub>S map_sq_matrix f A\"", "lemma map_sq_matrix_smult: \"c *\\<^sub>S map_sq_matrix f A = map_sq_matrix (\\<lambda>x. c * f x) A\"", "lemma one_smult[simp]: \"(1::_::monoid_mult) *\\<^sub>S x = x\"", "lemma smult_diag: \"x *\\<^sub>S diag y = diag (x * y::_::mult_zero)\"", "lemma map_sq_matrix_add:\n  \"(\\<And>a b. f (a + b) = f a + f b) \\<Longrightarrow> map_sq_matrix f (A + B) = map_sq_matrix f A + map_sq_matrix f B\"", "lemma add_map_sq_matrix: \"map_sq_matrix f A + map_sq_matrix g A = map_sq_matrix (\\<lambda>x. f x + g x) A\"", "lemma diag_0: \"diag 0 = 0\"", "lemma diag_0_eq: \"diag x = 0 \\<longleftrightarrow> x = 0\"", "lemma zero_map_sq_matrix: \"f 0 = 0 \\<Longrightarrow> map_sq_matrix f 0 = 0\"", "lemma map_sq_matrix_0[simp]: \"map_sq_matrix (\\<lambda>x. 0) A = 0\"", "lemma map_sq_matrix_diff:\n  \"(\\<And>a b. f (a - b) = f a - f b) \\<Longrightarrow> map_sq_matrix f (A - B) = map_sq_matrix f A - map_sq_matrix f B\"", "lemma smult_diff: fixes a :: \"'a::comm_ring_1\" shows \"a *\\<^sub>S (A - B) = a *\\<^sub>S A - a *\\<^sub>S B\"", "lemma map_sq_matrix_sum:\n  \"f 0 = 0 \\<Longrightarrow> (\\<And>a b. f (a + b) = f a + f b) \\<Longrightarrow>\n  map_sq_matrix f (\\<Sum>i\\<in>I. A i) = (\\<Sum>i\\<in>I. map_sq_matrix f (A i))\"", "lemma sum_map_sq_matrix: \"(\\<Sum>i\\<in>I. map_sq_matrix (f i) A) = map_sq_matrix (\\<lambda>x. \\<Sum>i\\<in>I. f i x) A\"", "lemma smult_zero[simp]: fixes a :: \"'a::ring_1\" shows \"a *\\<^sub>S 0 = 0\"", "lemma smult_right_add: fixes a :: \"'a::ring_1\" shows \"a *\\<^sub>S (x + y) = a *\\<^sub>S x + a *\\<^sub>S y\"", "lemma smult_sum: fixes a :: \"'a::ring_1\" shows \"(\\<Sum>i\\<in>I. a *\\<^sub>S f i) = a *\\<^sub>S (sum f I)\"", "lemma diag_mult: \"diag x * A = x *\\<^sub>S A\"", "lemma mult_diag:\n  fixes x :: \"'a::comm_ring_1\"\n  shows \"A * diag x = x *\\<^sub>S A\"", "lemma smult_mult1: fixes a :: \"'a::comm_ring_1\" shows \"a *\\<^sub>S (A * B) = (a *\\<^sub>S A) * B\"", "lemma smult_mult2: fixes a :: \"'a::comm_ring_1\" shows \"a *\\<^sub>S (A * B) = A * (a *\\<^sub>S B)\"", "lemma map_sq_matrix_mult:\n  fixes f :: \"'a::semiring_1 \\<Rightarrow> 'b::semiring_1\"\n  assumes f: \"\\<And>a b. f (a + b) = f a + f b\" \"\\<And>a b. f (a * b) = f a * f b\" \"f 0 = 0\"\n  shows \"map_sq_matrix f (A * B) = map_sq_matrix f A * map_sq_matrix f B\"", "lemma from_vec_mult[simp]: \"from_vec (M ** N) = from_vec M * from_vec N\"", "lemma diag_1: \"diag 1 = 1\"", "lemma diag_1_eq: \"diag x = 1 \\<longleftrightarrow> x = 1\"", "lemma transpose_transpose[simp]: \"transpose (transpose A) = A\"", "lemma transpose_diag[simp]: \"transpose (diag c) = diag c\"", "lemma transpose_zero[simp]: \"transpose 0 = 0\"", "lemma transpose_one[simp]: \"transpose 1 = 1\"", "lemma transpose_add[simp]: \"transpose (A + B) = transpose A + transpose B\"", "lemma transpose_minus[simp]: \"transpose (A - B) = transpose A - transpose B\"", "lemma transpose_uminus[simp]: \"transpose (- A) = - transpose A\"", "lemma transpose_mult[simp]:\n  \"transpose (A * B :: 'a::comm_semiring_0^^'n) = transpose B * transpose A\"", "lemma trace_diag[simp]: \"trace (diag c::'a::semiring_1^^'n) = of_nat CARD('n) * c\"", "lemma trace_0[simp]: \"trace 0 = 0\"", "lemma trace_1[simp]: \"trace (1::'a::semiring_1^^'n) = of_nat CARD('n)\"", "lemma trace_plus[simp]: \"trace (A + B) = trace A + trace B\"", "lemma trace_minus[simp]: \"trace (A - B) = (trace A - trace B::_::ab_group_add)\"", "lemma trace_uminus[simp]: \"trace (- A) = - (trace A::_::ab_group_add)\"", "lemma trace_smult[simp]: \"trace (s *\\<^sub>S A) = (s * trace A::_::semiring_0)\"", "lemma trace_transpose[simp]: \"trace (transpose A) = trace A\"", "lemma trace_mult_symm:\n  fixes A B :: \"'a::comm_semiring_0^^'n\"\n  shows \"trace (A * B) = trace (B * A)\"", "lemma det_eq: \"det A = (\\<Sum>p|p permutes UNIV. of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))\"", "lemma permutes_UNIV_permutation: \"permutation p \\<longleftrightarrow> p permutes (UNIV::_::finite)\"", "lemma det_0[simp]: \"det 0 = 0\"", "lemma det_transpose: \"det (transpose A) = det A\"", "lemma det_diagonal:\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  shows \"(\\<And>i j. i \\<noteq> j \\<Longrightarrow> to_fun A i j = 0) \\<Longrightarrow> det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)\"", "lemma det_1[simp]: \"det (1::'a::comm_ring_1^^'n) = 1\"", "lemma det_lowerdiagonal:\n  fixes A :: \"'a::comm_ring_1^^'n::{finite,wellorder}\"\n  shows \"(\\<And>i j. i < j \\<Longrightarrow> to_fun A i j = 0) \\<Longrightarrow> det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)\"", "lemma det_upperdiagonal:\n  fixes A :: \"'a::comm_ring_1^^'n::{finite, wellorder}\"\n  shows \"(\\<And>i j. j < i \\<Longrightarrow> to_fun A i j = 0) \\<Longrightarrow> det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)\"", "lemma perm_rows_transpose: \"perm_rows (transpose M) p = transpose (perm_cols M p)\"", "lemma perm_cols_transpose: \"perm_cols (transpose M) p = transpose (perm_rows M p)\"", "lemma upd_row_transpose: \"upd_row (transpose M) i p = transpose (upd_col M i p)\"", "lemma upd_col_transpose: \"upd_col (transpose M) i p = transpose (upd_row M i p)\"", "lemma upd_rows_transpose: \"upd_rows (transpose M) i p = transpose (upd_cols M i p)\"", "lemma upd_cols_transpose: \"upd_cols (transpose M) i p = transpose (upd_rows M i p)\"", "lemma upd_rows_empty[simp]: \"upd_rows M {} f = M\"", "lemma upd_cols_empty[simp]: \"upd_cols M {} f = M\"", "lemma upd_rows_single[simp]: \"upd_rows M {i} f = upd_row M i (f i)\"", "lemma upd_cols_single[simp]: \"upd_cols M {i} f = upd_col M i (f i)\"", "lemma upd_rows_insert: \"upd_rows M (insert i I) f = upd_row (upd_rows M I f) i (f i)\"", "lemma upd_rows_insert_rev: \"upd_rows M (insert i I) f = upd_rows (upd_row M i (f i)) I f\"", "lemma upd_rows_upd_row_swap: \"i \\<notin> I \\<Longrightarrow> upd_rows (upd_row M i x) I f = upd_row (upd_rows M I f) i x\"", "lemma upd_cols_insert: \"upd_cols M (insert i I) f = upd_col (upd_cols M I f) i (f i)\"", "lemma upd_cols_insert_rev: \"upd_cols M (insert i I) f = upd_cols (upd_col M i (f i)) I f\"", "lemma upd_cols_upd_col_swap: \"i \\<notin> I \\<Longrightarrow> upd_cols (upd_col M i x) I f = upd_col (upd_cols M I f) i x\"", "lemma upd_rows_cong[cong]:\n  \"M = N \\<Longrightarrow> T = S \\<Longrightarrow> (\\<And>s. s \\<in> S =simp=> f s = g s) \\<Longrightarrow> upd_rows M T f = upd_rows N S g\"", "lemma upd_cols_cong[cong]:\n  \"M = N \\<Longrightarrow> T = S \\<Longrightarrow> (\\<And>s. s \\<in> S =simp=> f s = g s) \\<Longrightarrow> upd_cols M T f = upd_cols N S g\"", "lemma row_upd_row_If: \"row (upd_row M i x) j = (if i = j then x else row M j)\"", "lemma row_upd_row[simp]: \"row (upd_row M i x) i = x\"", "lemma col_upd_col_If: \"col (upd_col M i x) j = (if i = j then x else col M j)\"", "lemma col_upd_col[simp]: \"col (upd_col M i x) i = x\"", "lemma upd_row_row[simp]: \"upd_row M i (row M i) = M\"", "lemma upd_row_upd_row_cancel[simp]: \"upd_row (upd_row M i x) i y = upd_row M i y\"", "lemma upd_col_upd_col_cancel[simp]: \"upd_col (upd_col M i x) i y = upd_col M i y\"", "lemma upd_col_col[simp]: \"upd_col M i (col M i) = M\"", "lemma row_transpose: \"row (transpose M) i = col M i\"", "lemma col_transpose: \"col (transpose M) i = row M i\"", "lemma det_perm_cols:\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  assumes p: \"p permutes UNIV\"\n  shows \"det (perm_cols A p) = of_int (sign p) * det A\"", "lemma det_perm_rows:\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  assumes p: \"p permutes UNIV\"\n  shows \"det (perm_rows A p) = of_int (sign p) * det A\"", "lemma det_row_add: \"det (upd_row M i (a + b)) = det (upd_row M i a) + det (upd_row M i b)\"", "lemma det_row_mul: \"det (upd_row M i (c *s a)) = c * det (upd_row M i a)\"", "lemma det_row_uminus: \"det (upd_row M i (- a)) = - det (upd_row M i a)\"", "lemma det_row_minus: \"det (upd_row M i (a - b)) = det (upd_row M i a) - det (upd_row M i b)\"", "lemma det_row_0: \"det (upd_row M i 0) = 0\"", "lemma det_row_sum: \"det (upd_row M i (\\<Sum>s\\<in>S. a s)) = (\\<Sum>s\\<in>S. det (upd_row M i (a s)))\"", "lemma det_col_add: \"det (upd_col M i (a + b)) = det (upd_col M i a) + det (upd_col M i b)\"", "lemma det_col_mul: \"det (upd_col M i (c *s a)) = c * det (upd_col M i a)\"", "lemma det_col_uminus: \"det (upd_col M i (- a)) = - det (upd_col M i a)\"", "lemma det_col_minus: \"det (upd_col M i (a - b)) = det (upd_col M i a) - det (upd_col M i b)\"", "lemma det_col_0: \"det (upd_col M i 0) = 0\"", "lemma det_col_sum: \"det (upd_col M i (\\<Sum>s\\<in>S. a s)) = (\\<Sum>s\\<in>S. det (upd_col M i (a s)))\"", "lemma det_identical_cols:\n  assumes \"i \\<noteq> i'\" shows \"col A i = col A i' \\<Longrightarrow> det A = 0\"", "lemma det_identical_rows: \"i \\<noteq> i' \\<Longrightarrow> row A i = row A i' \\<Longrightarrow> det A = 0\"", "lemma det_cols_sum:\n  \"det (upd_cols M T (\\<lambda>i. \\<Sum>s\\<in>S. a i s)) = (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S. det (upd_cols M T (\\<lambda>i. a i (f i))))\"", "lemma det_rows_sum:\n  \"det (upd_rows M T (\\<lambda>i. \\<Sum>s\\<in>S. a i s)) = (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S. det (upd_rows M T (\\<lambda>i. a i (f i))))\"", "lemma det_rows_mult: \"det (upd_rows M T (\\<lambda>i. c i *s a i)) = (\\<Prod>i\\<in>T. c i) * det (upd_rows M T a)\"", "lemma det_cols_mult: \"det (upd_cols M T (\\<lambda>i. c i *s a i)) = (\\<Prod>i\\<in>T. c i) * det (upd_cols M T a)\"", "lemma det_perm_rows_If: \"det (perm_rows B f) = (if f permutes UNIV then of_int (sign f) * det B else 0)\"", "lemma det_mult: \"det (A * B) = det A * det B\"", "lemma minor_transpose: \"minor (transpose A) i j = transpose (minor A j i)\"", "lemma minor_eq_row_col: \"minor M i j = upd_row (upd_col M j (axis i 1)) i (axis j 1)\"", "lemma minor_eq_col_row: \"minor M i j = upd_col (upd_row M i (axis j 1)) j (axis i 1)\"", "lemma row_minor: \"row (minor M i j) i = axis j 1\"", "lemma col_minor: \"col (minor M i j) j = axis i 1\"", "lemma det_minor_row':\n  \"row B i = axis j 1 \\<Longrightarrow> det (minor B i j) = det B\"", "lemma det_minor_row: \"det (minor B i j) = det (upd_row B i (axis j 1))\"", "lemma det_minor_col: \"det (minor B i j) = det (upd_col B j (axis i 1))\"", "lemma cofactor_transpose: \"cofactor (transpose A) = transpose (cofactor A)\"", "lemma adjugate_transpose: \"adjugate (transpose A) = transpose (adjugate A)\"", "theorem adjugate_mult_det: \"adjugate A * A = diag (det A)\"", "lemma mult_adjugate_det: \"A * adjugate A = diag (det A)\""], "translations": [["", "lemma smult_axis: \"x *s axis i y = axis i (x * y::_::mult_zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *s axis i y = axis i (x * y)", "by (simp add: axis_def vec_eq_iff)"], ["", "typedef ('a, 'n) sq_matrix = \"UNIV :: ('n \\<Rightarrow> 'n \\<Rightarrow> 'a) set\"\n  morphisms to_fun of_fun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", "by (rule UNIV_witness)"], ["", "syntax \"_sq_matrix\" :: \"type \\<Rightarrow> type \\<Rightarrow> type\" (\"(_ ^^/ _)\" [15, 16] 15)"], ["", "parse_translation \\<open>\n  let\n    fun vec t u = Syntax.const @{type_syntax sq_matrix} $ t $ u;\n    fun sq_matrix_tr [t, u] =\n      (case Term_Position.strip_positions u of\n        v as Free (x, _) =>\n          if Lexicon.is_tid x then\n            vec t (Syntax.const @{syntax_const \"_ofsort\"} $ v $\n              Syntax.const @{class_syntax finite})\n          else vec t u\n      | _ => vec t u)\n  in\n    [(@{syntax_const \"_sq_matrix\"}, K sq_matrix_tr)]\n  end\n\\<close>"], ["", "setup_lifting type_definition_sq_matrix"], ["", "lift_definition map_sq_matrix :: \"('a \\<Rightarrow> 'c) \\<Rightarrow> 'a^^'b \\<Rightarrow> 'c^^'b\" is\n  \"\\<lambda>f M i j. f (M i j)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition from_vec :: \"'a^'n^'n \\<Rightarrow> 'a^^'n\" is\n  \"\\<lambda>M i j. M $ i $ j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition to_vec :: \"'a^^'n \\<Rightarrow> 'a^'n^'n\" is\n  \"\\<lambda>M. \\<chi> i j. M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma from_vec_eq_iff: \"from_vec M = from_vec N \\<longleftrightarrow> M = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (from_vec M = from_vec N) = (M = N)", "by transfer (auto simp: vec_eq_iff fun_eq_iff)"], ["", "lemma to_vec_from_vec[simp]: \"to_vec (from_vec M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_vec (from_vec M) = M", "by transfer (simp add: vec_eq_iff)"], ["", "lemma from_vec_to_vec[simp]: \"from_vec (to_vec M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_vec (to_vec M) = M", "by transfer (simp add: vec_eq_iff fun_eq_iff)"], ["", "lemma map_sq_matrix_compose[simp]: \"map_sq_matrix f (map_sq_matrix g M) = map_sq_matrix (\\<lambda>x. f (g x)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sq_matrix f (map_sq_matrix g M) =\n    map_sq_matrix (\\<lambda>x. f (g x)) M", "by transfer simp"], ["", "lemma map_sq_matrix_ident[simp]: \"map_sq_matrix (\\<lambda>x. x) M = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sq_matrix (\\<lambda>x. x) M = M", "by transfer (simp add: vec_eq_iff)"], ["", "lemma map_sq_matrix_cong:\n  \"M = N \\<Longrightarrow> (\\<And>i j. f (to_fun N i j) = g (to_fun N i j)) \\<Longrightarrow> map_sq_matrix f M = map_sq_matrix g N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = N; \\<And>i j. f (to_fun N i j) = g (to_fun N i j)\\<rbrakk>\n    \\<Longrightarrow> map_sq_matrix f M = map_sq_matrix g N", "by transfer simp"], ["", "lift_definition diag :: \"'a::zero \\<Rightarrow> 'a^^'n\" is\n  \"\\<lambda>k i j. if i = j then k else 0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma diag_eq_iff: \"diag x = diag y \\<longleftrightarrow>  x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (diag x = diag y) = (x = y)", "by transfer (simp add: fun_eq_iff)"], ["", "lemma map_sq_matrix_diag[simp]: \"f 0 = 0 \\<Longrightarrow> map_sq_matrix f (diag c) = diag (f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'b) = (0::'a) \\<Longrightarrow>\n    map_sq_matrix f (diag c) = diag (f c)", "by transfer (simp add: fun_eq_iff)"], ["", "lift_definition smult_sq_matrix :: \"'a::times \\<Rightarrow> 'a^^'n \\<Rightarrow> 'a^^'n\" (infixr \"*\\<^sub>S\" 75) is\n  \"\\<lambda>c M i j. c * M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma smult_map_sq_matrix:\n  \"(\\<And>y. f (x * y) = z * f y) \\<Longrightarrow> map_sq_matrix f (x *\\<^sub>S A) = z *\\<^sub>S map_sq_matrix f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. f (x * y) = z * f y) \\<Longrightarrow>\n    map_sq_matrix f (x *\\<^sub>S A) = z *\\<^sub>S map_sq_matrix f A", "by transfer simp"], ["", "lemma map_sq_matrix_smult: \"c *\\<^sub>S map_sq_matrix f A = map_sq_matrix (\\<lambda>x. c * f x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>S map_sq_matrix f A = map_sq_matrix (\\<lambda>x. c * f x) A", "by transfer simp"], ["", "lemma one_smult[simp]: \"(1::_::monoid_mult) *\\<^sub>S x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) *\\<^sub>S x = x", "by transfer simp"], ["", "lemma smult_diag: \"x *\\<^sub>S diag y = diag (x * y::_::mult_zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>S diag y = diag (x * y)", "by transfer (simp add: fun_eq_iff)"], ["", "instantiation sq_matrix :: (semigroup_add, finite) semigroup_add\nbegin"], ["", "lift_definition plus_sq_matrix :: \"'a^^'b \\<Rightarrow> 'a^^'b \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>A B i j. A i j + B i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, semigroup_add_class)", "by standard (transfer, simp add: field_simps)"], ["", "end"], ["", "lemma map_sq_matrix_add:\n  \"(\\<And>a b. f (a + b) = f a + f b) \\<Longrightarrow> map_sq_matrix f (A + B) = map_sq_matrix f A + map_sq_matrix f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. f (a + b) = f a + f b) \\<Longrightarrow>\n    map_sq_matrix f (A + B) = map_sq_matrix f A + map_sq_matrix f B", "by transfer simp"], ["", "lemma add_map_sq_matrix: \"map_sq_matrix f A + map_sq_matrix g A = map_sq_matrix (\\<lambda>x. f x + g x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sq_matrix f A + map_sq_matrix g A =\n    map_sq_matrix (\\<lambda>x. f x + g x) A", "by transfer simp"], ["", "instantiation sq_matrix :: (monoid_add, finite) monoid_add\nbegin"], ["", "lift_definition zero_sq_matrix :: \"'a^^'b\" is \"\\<lambda>i j. 0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, monoid_add_class)", "by standard (transfer, simp)+"], ["", "end"], ["", "lemma diag_0: \"diag 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag (0::'a) = 0", "by transfer simp"], ["", "lemma diag_0_eq: \"diag x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (diag x = 0) = (x = (0::'a))", "by transfer (simp add: fun_eq_iff)"], ["", "lemma zero_map_sq_matrix: \"f 0 = 0 \\<Longrightarrow> map_sq_matrix f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'b) = (0::'a) \\<Longrightarrow> map_sq_matrix f 0 = 0", "by transfer simp"], ["", "lemma map_sq_matrix_0[simp]: \"map_sq_matrix (\\<lambda>x. 0) A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sq_matrix (\\<lambda>x. 0::'a) A = 0", "by transfer simp"], ["", "instance sq_matrix :: (ab_semigroup_add, finite) ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, ab_semigroup_add_class)", "by standard (transfer, simp add: field_simps)+"], ["", "instantiation sq_matrix :: (minus, finite) minus\nbegin"], ["", "lift_definition minus_sq_matrix :: \"'a^^'b \\<Rightarrow> 'a^^'b \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>A B i j. A i j - B i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, minus_class)", ".."], ["", "end"], ["", "instantiation sq_matrix :: (group_add, finite) group_add\nbegin"], ["", "lift_definition uminus_sq_matrix :: \"'a^^'b \\<Rightarrow> 'a^^'b\" is\n  \"uminus\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, group_add_class)", "by standard (transfer, simp)+"], ["", "end"], ["", "lemma map_sq_matrix_diff:\n  \"(\\<And>a b. f (a - b) = f a - f b) \\<Longrightarrow> map_sq_matrix f (A - B) = map_sq_matrix f A - map_sq_matrix f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. f (a - b) = f a - f b) \\<Longrightarrow>\n    map_sq_matrix f (A - B) = map_sq_matrix f A - map_sq_matrix f B", "by transfer (simp add: vec_eq_iff)"], ["", "lemma smult_diff: fixes a :: \"'a::comm_ring_1\" shows \"a *\\<^sub>S (A - B) = a *\\<^sub>S A - a *\\<^sub>S B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>S (A - B) = a *\\<^sub>S A - a *\\<^sub>S B", "by transfer (simp add: field_simps)"], ["", "instance sq_matrix :: (cancel_semigroup_add, finite) cancel_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, cancel_semigroup_add_class)", "by (standard; transfer, simp add: field_simps fun_eq_iff)"], ["", "instance sq_matrix :: (cancel_ab_semigroup_add, finite) cancel_ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, cancel_ab_semigroup_add_class)", "by (standard; transfer, simp add: field_simps)"], ["", "instance sq_matrix :: (comm_monoid_add, finite) comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, comm_monoid_add_class)", "by (standard; transfer, simp add: field_simps)"], ["", "lemma map_sq_matrix_sum:\n  \"f 0 = 0 \\<Longrightarrow> (\\<And>a b. f (a + b) = f a + f b) \\<Longrightarrow>\n  map_sq_matrix f (\\<Sum>i\\<in>I. A i) = (\\<Sum>i\\<in>I. map_sq_matrix f (A i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f (0::'b) = (0::'a); \\<And>a b. f (a + b) = f a + f b\\<rbrakk>\n    \\<Longrightarrow> map_sq_matrix f (sum A I) =\n                      (\\<Sum>i\\<in>I. map_sq_matrix f (A i))", "by (induction I rule: infinite_finite_induct)\n     (auto simp: zero_map_sq_matrix map_sq_matrix_add)"], ["", "lemma sum_map_sq_matrix: \"(\\<Sum>i\\<in>I. map_sq_matrix (f i) A) = map_sq_matrix (\\<lambda>x. \\<Sum>i\\<in>I. f i x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. map_sq_matrix (f i) A) =\n    map_sq_matrix (\\<lambda>x. \\<Sum>i\\<in>I. f i x) A", "by (induction I rule: infinite_finite_induct) (simp_all add: add_map_sq_matrix)"], ["", "lemma smult_zero[simp]: fixes a :: \"'a::ring_1\" shows \"a *\\<^sub>S 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>S 0 = 0", "by transfer (simp add: vec_eq_iff)"], ["", "lemma smult_right_add: fixes a :: \"'a::ring_1\" shows \"a *\\<^sub>S (x + y) = a *\\<^sub>S x + a *\\<^sub>S y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>S (x + y) = a *\\<^sub>S x + a *\\<^sub>S y", "by transfer (simp add: vec_eq_iff field_simps)"], ["", "lemma smult_sum: fixes a :: \"'a::ring_1\" shows \"(\\<Sum>i\\<in>I. a *\\<^sub>S f i) = a *\\<^sub>S (sum f I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. a *\\<^sub>S f i) = a *\\<^sub>S sum f I", "by (induction I rule: infinite_finite_induct)\n     (simp_all add: smult_right_add vec_eq_iff)"], ["", "instance sq_matrix :: (ab_group_add, finite) ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, ab_group_add_class)", "by standard (transfer, simp add: field_simps)+"], ["", "instantiation sq_matrix :: (\"semiring_0\", finite) semiring_0\nbegin"], ["", "lift_definition times_sq_matrix :: \"'a^^'b \\<Rightarrow> 'a^^'b \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>M N i j. \\<Sum>k\\<in>UNIV. M i k * N k j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, semiring_0_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. 0 * a = 0\n 2. \\<And>a. a * 0 = 0\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>a b c. (a + b) * c = a * c + b * c\n 5. \\<And>a b c. a * (b + c) = a * b + a * c", "fix a b c :: \"'a^^'b\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. 0 * a = 0\n 2. \\<And>a. a * 0 = 0\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>a b c. (a + b) * c = a * c + b * c\n 5. \\<And>a b c. a * (b + c) = a * b + a * c", "show \"a * b * c = a * (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)", "by transfer\n       (auto simp: fun_eq_iff sum_distrib_left sum_distrib_right field_simps intro: sum.swap)"], ["proof (state)\nthis:\n  a * b * c = a * (b * c)\n\ngoal (4 subgoals):\n 1. \\<And>a. 0 * a = 0\n 2. \\<And>a. a * 0 = 0\n 3. \\<And>a b c. (a + b) * c = a * c + b * c\n 4. \\<And>a b c. a * (b + c) = a * b + a * c", "qed (transfer, simp add: vec_eq_iff sum.distrib field_simps)+"], ["", "end"], ["", "lemma diag_mult: \"diag x * A = x *\\<^sub>S A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag x * A = x *\\<^sub>S A", "by transfer  (simp add: if_distrib[where f=\"\\<lambda>x. x * a\" for a] sum.If_cases)"], ["", "lemma mult_diag:\n  fixes x :: \"'a::comm_ring_1\"\n  shows \"A * diag x = x *\\<^sub>S A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * diag x = x *\\<^sub>S A", "by transfer (simp add: if_distrib[where f=\"\\<lambda>x. a * x\" for a] mult.commute sum.If_cases)"], ["", "lemma smult_mult1: fixes a :: \"'a::comm_ring_1\" shows \"a *\\<^sub>S (A * B) = (a *\\<^sub>S A) * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>S (A * B) = a *\\<^sub>S A * B", "by transfer (simp add: sum_distrib_left field_simps)"], ["", "lemma smult_mult2: fixes a :: \"'a::comm_ring_1\" shows \"a *\\<^sub>S (A * B) = A * (a *\\<^sub>S B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>S (A * B) = A * a *\\<^sub>S B", "by transfer (simp add: sum_distrib_left field_simps)"], ["", "lemma map_sq_matrix_mult:\n  fixes f :: \"'a::semiring_1 \\<Rightarrow> 'b::semiring_1\"\n  assumes f: \"\\<And>a b. f (a + b) = f a + f b\" \"\\<And>a b. f (a * b) = f a * f b\" \"f 0 = 0\"\n  shows \"map_sq_matrix f (A * B) = map_sq_matrix f A * map_sq_matrix f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sq_matrix f (A * B) = map_sq_matrix f A * map_sq_matrix f B", "proof (transfer fixing: f)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n       (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))", "fix A B :: \"'c \\<Rightarrow> 'c \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n       (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n       (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))", "fix I i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n       (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))", "have \"f (\\<Sum>k\\<in>I. A i k * B k j) = (\\<Sum>k\\<in>I. f (A i k) * f (B k j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Sum>k\\<in>I. A i k * B k j) =\n    (\\<Sum>k\\<in>I. f (A i k) * f (B k j))", "by (induction I rule: infinite_finite_induct) (auto simp add: f)"], ["proof (state)\nthis:\n  f (\\<Sum>k\\<in>I. A i k * B k j) = (\\<Sum>k\\<in>I. f (A i k) * f (B k j))\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n       (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))", "}"], ["proof (state)\nthis:\n  f (\\<Sum>k\\<in>?I2. A ?i2 k * B k ?j2) =\n  (\\<Sum>k\\<in>?I2. f (A ?i2 k) * f (B k ?j2))\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n       (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))", "then"], ["proof (chain)\npicking this:\n  f (\\<Sum>k\\<in>?I2. A ?i2 k * B k ?j2) =\n  (\\<Sum>k\\<in>?I2. f (A ?i2 k) * f (B k ?j2))", "show \"(\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) = (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))\""], ["proof (prove)\nusing this:\n  f (\\<Sum>k\\<in>?I2. A ?i2 k * B k ?j2) =\n  (\\<Sum>k\\<in>?I2. f (A ?i2 k) * f (B k ?j2))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n    (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i j. f (\\<Sum>k\\<in>UNIV. A i k * B k j)) =\n  (\\<lambda>i j. \\<Sum>k\\<in>UNIV. f (A i k) * f (B k j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_vec_mult[simp]: \"from_vec (M ** N) = from_vec M * from_vec N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_vec (M ** N) = from_vec M * from_vec N", "by transfer (simp add: matrix_matrix_mult_def fun_eq_iff vec_eq_iff)"], ["", "instantiation sq_matrix :: (\"semiring_1\", finite) semiring_1\nbegin"], ["", "lift_definition one_sq_matrix :: \"'a^^'b\" is\n  \"\\<lambda>i j. if i = j then 1 else 0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, semiring_1_class)", "by standard (transfer, simp add: fun_eq_iff sum.If_cases\n       if_distrib[where f=\"\\<lambda>x. x * b\" for b] if_distrib[where f=\"\\<lambda>x. b * x\" for b])+"], ["", "end"], ["", "instance sq_matrix :: (\"semiring_1\", finite) numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, numeral_class)", ".."], ["", "lemma diag_1: \"diag 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag (1::'a) = 1", "by transfer simp"], ["", "lemma diag_1_eq: \"diag x = 1 \\<longleftrightarrow> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (diag x = 1) = (x = (1::'a))", "by transfer (simp add: fun_eq_iff)"], ["", "instance sq_matrix :: (\"ring_1\", finite) ring_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, ring_1_class)", "by standard simp_all"], ["", "interpretation sq_matrix: vector_space smult_sq_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space (*\\<^sub>S)", "by standard (transfer, simp add: vec_eq_iff field_simps)+"], ["", "instantiation sq_matrix :: (real_vector, finite) real_vector\nbegin"], ["", "lift_definition scaleR_sq_matrix :: \"real \\<Rightarrow> 'a^^'b \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>r A i j. r *\\<^sub>R A i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, real_vector_class)", "by standard (transfer, simp add: scaleR_add_right scaleR_add_left)+"], ["", "end"], ["", "instance sq_matrix :: (\"semiring_1\", finite) Rings.dvd"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) sq_matrix, dvd_class)", ".."], ["", "lift_definition transpose :: \"'a^^'n \\<Rightarrow> 'a^^'n\" is\n  \"\\<lambda>M i j. M j i\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma transpose_transpose[simp]: \"transpose (transpose A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (Square_Matrix.transpose A) = A", "by transfer simp"], ["", "lemma transpose_diag[simp]: \"transpose (diag c) = diag c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (diag c) = diag c", "by transfer (simp add: fun_eq_iff)"], ["", "lemma transpose_zero[simp]: \"transpose 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose 0 = 0", "by transfer simp"], ["", "lemma transpose_one[simp]: \"transpose 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose 1 = 1", "by transfer (simp add: fun_eq_iff)"], ["", "lemma transpose_add[simp]: \"transpose (A + B) = transpose A + transpose B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (A + B) =\n    Square_Matrix.transpose A + Square_Matrix.transpose B", "by transfer simp"], ["", "lemma transpose_minus[simp]: \"transpose (A - B) = transpose A - transpose B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (A - B) =\n    Square_Matrix.transpose A - Square_Matrix.transpose B", "by transfer simp"], ["", "lemma transpose_uminus[simp]: \"transpose (- A) = - transpose A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (- A) = - Square_Matrix.transpose A", "by transfer (simp add: fun_eq_iff)"], ["", "lemma transpose_mult[simp]:\n  \"transpose (A * B :: 'a::comm_semiring_0^^'n) = transpose B * transpose A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (A * B) =\n    Square_Matrix.transpose B * Square_Matrix.transpose A", "by transfer (simp add: field_simps)"], ["", "lift_definition trace :: \"'a::comm_monoid_add^^'n \\<Rightarrow> 'a\" is\n  \"\\<lambda>M. \\<Sum>i\\<in>UNIV. M i i\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma trace_diag[simp]: \"trace (diag c::'a::semiring_1^^'n) = of_nat CARD('n) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace (diag c) = of_nat CARD('n) * c", "by transfer simp"], ["", "lemma trace_0[simp]: \"trace 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace 0 = (0::'a)", "by transfer simp"], ["", "lemma trace_1[simp]: \"trace (1::'a::semiring_1^^'n) = of_nat CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace 1 = of_nat CARD('n)", "by transfer simp"], ["", "lemma trace_plus[simp]: \"trace (A + B) = trace A + trace B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace (A + B) =\n    Square_Matrix.trace A + Square_Matrix.trace B", "by transfer (simp add: sum.distrib)"], ["", "lemma trace_minus[simp]: \"trace (A - B) = (trace A - trace B::_::ab_group_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace (A - B) =\n    Square_Matrix.trace A - Square_Matrix.trace B", "by transfer (simp add: sum_subtractf)"], ["", "lemma trace_uminus[simp]: \"trace (- A) = - (trace A::_::ab_group_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace (- A) = - Square_Matrix.trace A", "by transfer (simp add: sum_negf)"], ["", "lemma trace_smult[simp]: \"trace (s *\\<^sub>S A) = (s * trace A::_::semiring_0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace (s *\\<^sub>S A) = s * Square_Matrix.trace A", "by transfer (simp add: sum_distrib_left)"], ["", "lemma trace_transpose[simp]: \"trace (transpose A) = trace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace (Square_Matrix.transpose A) = Square_Matrix.trace A", "by transfer simp"], ["", "lemma trace_mult_symm:\n  fixes A B :: \"'a::comm_semiring_0^^'n\"\n  shows \"trace (A * B) = trace (B * A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.trace (A * B) = Square_Matrix.trace (B * A)", "by transfer (auto intro: sum.swap simp: mult.commute)"], ["", "lift_definition det :: \"'a::comm_ring_1^^'n \\<Rightarrow> 'a\" is\n  \"\\<lambda>A. (\\<Sum>p|p permutes UNIV. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma det_eq: \"det A = (\\<Sum>p|p permutes UNIV. of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det A =\n    (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))", "by transfer rule"], ["", "lemma permutes_UNIV_permutation: \"permutation p \\<longleftrightarrow> p permutes (UNIV::_::finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation p = (p permutes UNIV)", "by (auto simp: permutation_permutes permutes_def)"], ["", "lemma det_0[simp]: \"det 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det 0 = (0::'a)", "by transfer (simp add: zero_power)"], ["", "lemma det_transpose: \"det (transpose A) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (Square_Matrix.transpose A) = Square_Matrix.det A", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A (p i) i)) =\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "apply (subst sum_permutations_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign (inv p)) * (\\<Prod>i\\<in>UNIV. A (inv p i) i)) =\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       x \\<in> {p. p permutes UNIV} \\<Longrightarrow>\n       of_int (sign (inv x)) * (\\<Prod>i\\<in>UNIV. A (inv x i) i) =\n       of_int (sign x) * (\\<Prod>i\\<in>UNIV. A i (x i))", "apply (simp add: sign_inverse permutes_UNIV_permutation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       x permutes UNIV \\<Longrightarrow>\n       of_int (sign x) * (\\<Prod>i\\<in>UNIV. A (inv x i) i) =\n       of_int (sign x) * (\\<Prod>i\\<in>UNIV. A i (x i))", "apply (subst prod.reindex_bij_betw[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x.\n       x permutes UNIV \\<Longrightarrow> bij_betw (?h36 A x) (?S36 A x) UNIV\n 2. \\<And>A x.\n       x permutes UNIV \\<Longrightarrow>\n       of_int (sign x) *\n       (\\<Prod>xa\\<in>?S36 A x. A (inv x (?h36 A x xa)) (?h36 A x xa)) =\n       of_int (sign x) * (\\<Prod>i\\<in>UNIV. A i (x i))", "apply (rule permutes_imp_bij)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A x. x permutes UNIV \\<Longrightarrow> ?h36 A x permutes UNIV\n 2. \\<And>A x.\n       x permutes UNIV \\<Longrightarrow>\n       of_int (sign x) *\n       (\\<Prod>xa\\<in>UNIV. A (inv x (?h36 A x xa)) (?h36 A x xa)) =\n       of_int (sign x) * (\\<Prod>i\\<in>UNIV. A i (x i))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       x permutes UNIV \\<Longrightarrow>\n       of_int (sign x) * (\\<Prod>xa\\<in>UNIV. A (inv x (x xa)) (x xa)) =\n       of_int (sign x) * (\\<Prod>i\\<in>UNIV. A i (x i))", "apply (simp add: permutes_inverses)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma det_diagonal:\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  shows \"(\\<And>i j. i \\<noteq> j \\<Longrightarrow> to_fun A i j = 0) \\<Longrightarrow> det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        i \\<noteq> j \\<Longrightarrow>\n        to_fun A i j = (0::'a)) \\<Longrightarrow>\n    Square_Matrix.det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "fix A :: \"'n \\<Rightarrow> 'n \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "assume neq: \"\\<And>i j. i \\<noteq> j \\<Longrightarrow> A i j = 0\""], ["proof (state)\nthis:\n  ?i \\<noteq> ?j \\<Longrightarrow> A ?i ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "let ?pp = \"\\<lambda>p. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "fix p :: \"'n \\<Rightarrow> 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "assume p: \"p permutes UNIV\" \"p \\<noteq> id\""], ["proof (state)\nthis:\n  p permutes UNIV\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "then"], ["proof (chain)\npicking this:\n  p permutes UNIV\n  p \\<noteq> id", "obtain i where i: \"i \\<noteq> p i\""], ["proof (prove)\nusing this:\n  p permutes UNIV\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<noteq> p i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding id_def"], ["proof (prove)\nusing this:\n  p permutes UNIV\n  p \\<noteq> (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<noteq> p i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  i \\<noteq> p i\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "with neq[OF i]"], ["proof (chain)\npicking this:\n  A i (p i) = (0::'a)\n  i \\<noteq> p i", "have \"(\\<Prod>i\\<in>UNIV. A i (p i)) = 0\""], ["proof (prove)\nusing this:\n  A i (p i) = (0::'a)\n  i \\<noteq> p i\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. A i (p i)) = (0::'a)", "by (intro prod_zero) auto"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>UNIV. A i (p i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?p2 permutes UNIV; ?p2 \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>i\\<in>UNIV. A i (?p2 i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?p2 permutes UNIV; ?p2 \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>i\\<in>UNIV. A i (?p2 i)) = (0::'a)", "have \"(\\<Sum>p | p permutes UNIV. ?pp p) = (\\<Sum>p\\<in>{id}. ?pp p)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?p2 permutes UNIV; ?p2 \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>i\\<in>UNIV. A i (?p2 i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "by (intro sum.mono_neutral_cong_right) (auto intro: permutes_id)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i \\<noteq> j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "show \"(\\<Sum>p | p permutes UNIV. ?pp p) = (\\<Prod>i\\<in>UNIV. A i i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Prod>i\\<in>UNIV. A i i)", "by (simp add: sign_id)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Prod>i\\<in>UNIV. A i i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_1[simp]: \"det (1::'a::comm_ring_1^^'n) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det 1 = (1::'a)", "by (subst det_diagonal) (transfer, simp)+"], ["", "lemma det_lowerdiagonal:\n  fixes A :: \"'a::comm_ring_1^^'n::{finite,wellorder}\"\n  shows \"(\\<And>i j. i < j \\<Longrightarrow> to_fun A i j = 0) \\<Longrightarrow> det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        i < j \\<Longrightarrow> to_fun A i j = (0::'a)) \\<Longrightarrow>\n    Square_Matrix.det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "fix A :: \"'n \\<Rightarrow> 'n \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "assume ld: \"\\<And>i j. i < j \\<Longrightarrow> A i j = 0\""], ["proof (state)\nthis:\n  ?i < ?j \\<Longrightarrow> A ?i ?j = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "let ?pp = \"\\<lambda>p. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "fix p :: \"'n \\<Rightarrow> 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "assume p: \"p permutes UNIV\" \"p \\<noteq> id\""], ["proof (state)\nthis:\n  p permutes UNIV\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "with permutes_natset_le[OF p(1)]"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>UNIV. p i \\<le> i \\<Longrightarrow> p = id\n  p permutes UNIV\n  p \\<noteq> id", "obtain i where i: \"p i > i\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>UNIV. p i \\<le> i \\<Longrightarrow> p = id\n  p permutes UNIV\n  p \\<noteq> id\n\ngoal (1 subgoal):\n 1. (\\<And>i. i < p i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis not_le)"], ["proof (state)\nthis:\n  i < p i\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "with ld[OF i]"], ["proof (chain)\npicking this:\n  A i (p i) = (0::'a)\n  i < p i", "have \"(\\<Prod>i\\<in>UNIV. A i (p i)) = 0\""], ["proof (prove)\nusing this:\n  A i (p i) = (0::'a)\n  i < p i\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV. A i (p i)) = (0::'a)", "by (intro prod_zero) auto"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>UNIV. A i (p i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?p2 permutes UNIV; ?p2 \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>i\\<in>UNIV. A i (?p2 i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?p2 permutes UNIV; ?p2 \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>i\\<in>UNIV. A i (?p2 i)) = (0::'a)", "have \"(\\<Sum>p | p permutes UNIV. ?pp p) = (\\<Sum>p\\<in>{id}. ?pp p)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?p2 permutes UNIV; ?p2 \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>i\\<in>UNIV. A i (?p2 i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "by (intro sum.mono_neutral_cong_right) (auto intro: permutes_id)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<And>i j.\n           i < j \\<Longrightarrow> A i j = (0::'a)) \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (\\<Prod>i\\<in>UNIV. A i i)", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "show \"(\\<Sum>p | p permutes UNIV. ?pp p) = (\\<Prod>i\\<in>UNIV. A i i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{id}. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Prod>i\\<in>UNIV. A i i)", "by (simp add: sign_id)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Prod>i\\<in>UNIV. A i i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_upperdiagonal:\n  fixes A :: \"'a::comm_ring_1^^'n::{finite, wellorder}\"\n  shows \"(\\<And>i j. j < i \\<Longrightarrow> to_fun A i j = 0) \\<Longrightarrow> det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        j < i \\<Longrightarrow> to_fun A i j = (0::'a)) \\<Longrightarrow>\n    Square_Matrix.det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)", "using det_lowerdiagonal[of \"transpose A\"]"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      i < j \\<Longrightarrow>\n      to_fun (Square_Matrix.transpose A) i j = (0::'a)) \\<Longrightarrow>\n  Square_Matrix.det (Square_Matrix.transpose A) =\n  (\\<Prod>i\\<in>UNIV. to_fun (Square_Matrix.transpose A) i i)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        j < i \\<Longrightarrow> to_fun A i j = (0::'a)) \\<Longrightarrow>\n    Square_Matrix.det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)", "unfolding det_transpose transpose.rep_eq"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      i < j \\<Longrightarrow> to_fun A j i = (0::'a)) \\<Longrightarrow>\n  Square_Matrix.det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        j < i \\<Longrightarrow> to_fun A i j = (0::'a)) \\<Longrightarrow>\n    Square_Matrix.det A = (\\<Prod>i\\<in>UNIV. to_fun A i i)", "."], ["", "lift_definition perm_rows :: \"'a^^'b \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>M p i j. M (p i) j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition perm_cols :: \"'a^^'b \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>M p i j. M i (p j)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition upd_rows :: \"'a^^'b \\<Rightarrow> 'b set \\<Rightarrow> ('b \\<Rightarrow> 'a^'b) \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>M S v i j. if i \\<in> S then v i $ j else M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition upd_cols :: \"'a^^'b \\<Rightarrow> 'b set \\<Rightarrow> ('b \\<Rightarrow> 'a^'b) \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>M S v i j. if j \\<in> S then v j $ i else M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition upd_row :: \"'a^^'b \\<Rightarrow> 'b \\<Rightarrow> 'a^'b \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>M i' v i j. if i = i' then v $ j else M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition upd_col :: \"'a^^'b \\<Rightarrow> 'b \\<Rightarrow> 'a^'b \\<Rightarrow> 'a^^'b\" is\n  \"\\<lambda>M j' v i j. if j = j' then v $ i else M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition row :: \"'a^^'b \\<Rightarrow> 'b \\<Rightarrow> 'a^'b\" is\n  \"\\<lambda>M i. \\<chi> j. M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition col :: \"'a^^'b \\<Rightarrow> 'b \\<Rightarrow> 'a^'b\" is\n  \"\\<lambda>M j. \\<chi> i. M i j\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma perm_rows_transpose: \"perm_rows (transpose M) p = transpose (perm_cols M p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_rows (Square_Matrix.transpose M) p =\n    Square_Matrix.transpose (perm_cols M p)", "by transfer simp"], ["", "lemma perm_cols_transpose: \"perm_cols (transpose M) p = transpose (perm_rows M p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_cols (Square_Matrix.transpose M) p =\n    Square_Matrix.transpose (perm_rows M p)", "by transfer simp"], ["", "lemma upd_row_transpose: \"upd_row (transpose M) i p = transpose (upd_col M i p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_row (Square_Matrix.transpose M) i p =\n    Square_Matrix.transpose (upd_col M i p)", "by transfer simp"], ["", "lemma upd_col_transpose: \"upd_col (transpose M) i p = transpose (upd_row M i p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_col (Square_Matrix.transpose M) i p =\n    Square_Matrix.transpose (upd_row M i p)", "by transfer simp"], ["", "lemma upd_rows_transpose: \"upd_rows (transpose M) i p = transpose (upd_cols M i p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rows (Square_Matrix.transpose M) i p =\n    Square_Matrix.transpose (upd_cols M i p)", "by transfer simp"], ["", "lemma upd_cols_transpose: \"upd_cols (transpose M) i p = transpose (upd_rows M i p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cols (Square_Matrix.transpose M) i p =\n    Square_Matrix.transpose (upd_rows M i p)", "by transfer simp"], ["", "lemma upd_rows_empty[simp]: \"upd_rows M {} f = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rows M {} f = M", "by transfer simp"], ["", "lemma upd_cols_empty[simp]: \"upd_cols M {} f = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cols M {} f = M", "by transfer simp"], ["", "lemma upd_rows_single[simp]: \"upd_rows M {i} f = upd_row M i (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rows M {i} f = upd_row M i (f i)", "by transfer (simp add: fun_eq_iff)"], ["", "lemma upd_cols_single[simp]: \"upd_cols M {i} f = upd_col M i (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cols M {i} f = upd_col M i (f i)", "by transfer (simp add: fun_eq_iff)"], ["", "lemma upd_rows_insert: \"upd_rows M (insert i I) f = upd_row (upd_rows M I f) i (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rows M (insert i I) f = upd_row (upd_rows M I f) i (f i)", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma upd_rows_insert_rev: \"upd_rows M (insert i I) f = upd_rows (upd_row M i (f i)) I f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_rows M (insert i I) f = upd_rows (upd_row M i (f i)) I f", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma upd_rows_upd_row_swap: \"i \\<notin> I \\<Longrightarrow> upd_rows (upd_row M i x) I f = upd_row (upd_rows M I f) i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow>\n    upd_rows (upd_row M i x) I f = upd_row (upd_rows M I f) i x", "by transfer (simp add: fun_eq_iff)"], ["", "lemma upd_cols_insert: \"upd_cols M (insert i I) f = upd_col (upd_cols M I f) i (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cols M (insert i I) f = upd_col (upd_cols M I f) i (f i)", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma upd_cols_insert_rev: \"upd_cols M (insert i I) f = upd_cols (upd_col M i (f i)) I f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_cols M (insert i I) f = upd_cols (upd_col M i (f i)) I f", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma upd_cols_upd_col_swap: \"i \\<notin> I \\<Longrightarrow> upd_cols (upd_col M i x) I f = upd_col (upd_cols M I f) i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow>\n    upd_cols (upd_col M i x) I f = upd_col (upd_cols M I f) i x", "by transfer (simp add: fun_eq_iff)"], ["", "lemma upd_rows_cong[cong]:\n  \"M = N \\<Longrightarrow> T = S \\<Longrightarrow> (\\<And>s. s \\<in> S =simp=> f s = g s) \\<Longrightarrow> upd_rows M T f = upd_rows N S g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = N; T = S; \\<And>s. s \\<in> S =simp=> f s = g s\\<rbrakk>\n    \\<Longrightarrow> upd_rows M T f = upd_rows N S g", "unfolding simp_implies_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = N; T = S;\n     \\<And>s. s \\<in> S \\<Longrightarrow> f s = g s\\<rbrakk>\n    \\<Longrightarrow> upd_rows M T f = upd_rows N S g", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma upd_cols_cong[cong]:\n  \"M = N \\<Longrightarrow> T = S \\<Longrightarrow> (\\<And>s. s \\<in> S =simp=> f s = g s) \\<Longrightarrow> upd_cols M T f = upd_cols N S g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = N; T = S; \\<And>s. s \\<in> S =simp=> f s = g s\\<rbrakk>\n    \\<Longrightarrow> upd_cols M T f = upd_cols N S g", "unfolding simp_implies_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M = N; T = S;\n     \\<And>s. s \\<in> S \\<Longrightarrow> f s = g s\\<rbrakk>\n    \\<Longrightarrow> upd_cols M T f = upd_cols N S g", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma row_upd_row_If: \"row (upd_row M i x) j = (if i = j then x else row M j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.row (upd_row M i x) j =\n    (if i = j then x else Square_Matrix.row M j)", "by transfer (simp add: vec_eq_iff fun_eq_iff)"], ["", "lemma row_upd_row[simp]: \"row (upd_row M i x) i = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.row (upd_row M i x) i = x", "by (simp add: row_upd_row_If)"], ["", "lemma col_upd_col_If: \"col (upd_col M i x) j = (if i = j then x else col M j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (upd_col M i x) j = (if i = j then x else col M j)", "by transfer (simp add: vec_eq_iff)"], ["", "lemma col_upd_col[simp]: \"col (upd_col M i x) i = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (upd_col M i x) i = x", "by (simp add: col_upd_col_If)"], ["", "lemma upd_row_row[simp]: \"upd_row M i (row M i) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_row M i (Square_Matrix.row M i) = M", "by transfer (simp add: fun_eq_iff)"], ["", "lemma upd_row_upd_row_cancel[simp]: \"upd_row (upd_row M i x) i y = upd_row M i y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_row (upd_row M i x) i y = upd_row M i y", "by transfer (simp add: fun_eq_iff)"], ["", "lemma upd_col_upd_col_cancel[simp]: \"upd_col (upd_col M i x) i y = upd_col M i y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_col (upd_col M i x) i y = upd_col M i y", "by transfer (simp add: fun_eq_iff)"], ["", "lemma upd_col_col[simp]: \"upd_col M i (col M i) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_col M i (col M i) = M", "by transfer (simp add: fun_eq_iff)"], ["", "lemma row_transpose: \"row (transpose M) i = col M i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.row (Square_Matrix.transpose M) i = col M i", "by transfer simp"], ["", "lemma col_transpose: \"col (transpose M) i = row M i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (Square_Matrix.transpose M) i = Square_Matrix.row M i", "by transfer simp"], ["", "lemma det_perm_cols:\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  assumes p: \"p permutes UNIV\"\n  shows \"det (perm_cols A p) = of_int (sign p) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (perm_cols A p) =\n    of_int (sign p) * Square_Matrix.det A", "proof (transfer fixing: p)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p (p i)))) =\n       of_int (sign p) *\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "fix A :: \"'n \\<Rightarrow> 'n \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p (p i)))) =\n       of_int (sign p) *\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "from p"], ["proof (chain)\npicking this:\n  p permutes UNIV", "have \"(\\<Sum>q | q permutes UNIV. of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n    (\\<Sum>q | q permutes UNIV. of_int (sign (inv p \\<circ> q)) * (\\<Prod>i\\<in>UNIV. A i (q i)))\""], ["proof (prove)\nusing this:\n  p permutes UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>q | q permutes UNIV.\n       of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n    (\\<Sum>q | q permutes UNIV.\n       of_int (sign (inv p \\<circ> q)) * (\\<Prod>i\\<in>UNIV. A i (q i)))", "by (intro sum.reindex_bij_witness[where j=\"\\<lambda>q. p \\<circ> q\" and i=\"\\<lambda>q. inv p \\<circ> q\"])\n       (auto simp: comp_assoc[symmetric] permutes_inv_o permutes_compose permutes_inv)"], ["proof (state)\nthis:\n  (\\<Sum>q | q permutes UNIV.\n     of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n  (\\<Sum>q | q permutes UNIV.\n     of_int (sign (inv p \\<circ> q)) * (\\<Prod>i\\<in>UNIV. A i (q i)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p (p i)))) =\n       of_int (sign p) *\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "with p"], ["proof (chain)\npicking this:\n  p permutes UNIV\n  (\\<Sum>q | q permutes UNIV.\n     of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n  (\\<Sum>q | q permutes UNIV.\n     of_int (sign (inv p \\<circ> q)) * (\\<Prod>i\\<in>UNIV. A i (q i)))", "show \"(\\<Sum>q | q permutes UNIV. of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n      of_int (sign p) * (\\<Sum>p | p permutes UNIV. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\""], ["proof (prove)\nusing this:\n  p permutes UNIV\n  (\\<Sum>q | q permutes UNIV.\n     of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n  (\\<Sum>q | q permutes UNIV.\n     of_int (sign (inv p \\<circ> q)) * (\\<Prod>i\\<in>UNIV. A i (q i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>q | q permutes UNIV.\n       of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n    of_int (sign p) *\n    (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "by (auto intro!: sum.cong simp: sum_distrib_left sign_compose permutes_inv sign_inverse permutes_UNIV_permutation)"], ["proof (state)\nthis:\n  (\\<Sum>q | q permutes UNIV.\n     of_int (sign q) * (\\<Prod>i\\<in>UNIV. A i (p (q i)))) =\n  of_int (sign p) *\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_perm_rows:\n  fixes A :: \"'a::comm_ring_1^^'n\"\n  assumes p: \"p permutes UNIV\"\n  shows \"det (perm_rows A p) = of_int (sign p) * det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (perm_rows A p) =\n    of_int (sign p) * Square_Matrix.det A", "using det_perm_cols[OF p, of \"transpose A\"]"], ["proof (prove)\nusing this:\n  Square_Matrix.det (perm_cols (Square_Matrix.transpose A) p) =\n  of_int (sign p) * Square_Matrix.det (Square_Matrix.transpose A)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (perm_rows A p) =\n    of_int (sign p) * Square_Matrix.det A", "by (simp add: det_transpose perm_cols_transpose)"], ["", "lemma det_row_add: \"det (upd_row M i (a + b)) = det (upd_row M i a) + det (upd_row M i b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i (a + b)) =\n    Square_Matrix.det (upd_row M i a) + Square_Matrix.det (upd_row M i b)", "by transfer (simp add: prod.If_cases sum.distrib[symmetric] field_simps)"], ["", "lemma det_row_mul: \"det (upd_row M i (c *s a)) = c * det (upd_row M i a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i (c *s a)) =\n    c * Square_Matrix.det (upd_row M i a)", "by transfer (simp add: prod.If_cases sum_distrib_left field_simps)"], ["", "lemma det_row_uminus: \"det (upd_row M i (- a)) = - det (upd_row M i a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i (- a)) =\n    - Square_Matrix.det (upd_row M i a)", "by (simp add: vector_sneg_minus1 det_row_mul)"], ["", "lemma det_row_minus: \"det (upd_row M i (a - b)) = det (upd_row M i a) - det (upd_row M i b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i (a - b)) =\n    Square_Matrix.det (upd_row M i a) - Square_Matrix.det (upd_row M i b)", "unfolding diff_conv_add_uminus det_row_add det_row_uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i a) +\n    - Square_Matrix.det (upd_row M i b) =\n    Square_Matrix.det (upd_row M i a) + - Square_Matrix.det (upd_row M i b)", ".."], ["", "lemma det_row_0: \"det (upd_row M i 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i 0) = (0::'a)", "using det_row_mul[of M i 0]"], ["proof (prove)\nusing this:\n  Square_Matrix.det (upd_row M i ((0::'a) *s ?a)) =\n  (0::'a) * Square_Matrix.det (upd_row M i ?a)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i 0) = (0::'a)", "by simp"], ["", "lemma det_row_sum: \"det (upd_row M i (\\<Sum>s\\<in>S. a s)) = (\\<Sum>s\\<in>S. det (upd_row M i (a s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_row M i (sum a S)) =\n    (\\<Sum>s\\<in>S. Square_Matrix.det (upd_row M i (a s)))", "by (induction S rule: infinite_finite_induct) (simp_all add: det_row_0 det_row_add)"], ["", "lemma det_col_add: \"det (upd_col M i (a + b)) = det (upd_col M i a) + det (upd_col M i b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i (a + b)) =\n    Square_Matrix.det (upd_col M i a) + Square_Matrix.det (upd_col M i b)", "using det_row_add[of \"transpose M\" i a b]"], ["proof (prove)\nusing this:\n  Square_Matrix.det (upd_row (Square_Matrix.transpose M) i (a + b)) =\n  Square_Matrix.det (upd_row (Square_Matrix.transpose M) i a) +\n  Square_Matrix.det (upd_row (Square_Matrix.transpose M) i b)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i (a + b)) =\n    Square_Matrix.det (upd_col M i a) + Square_Matrix.det (upd_col M i b)", "by (simp add: upd_row_transpose det_transpose)"], ["", "lemma det_col_mul: \"det (upd_col M i (c *s a)) = c * det (upd_col M i a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i (c *s a)) =\n    c * Square_Matrix.det (upd_col M i a)", "using det_row_mul[of \"transpose M\" i c a]"], ["proof (prove)\nusing this:\n  Square_Matrix.det (upd_row (Square_Matrix.transpose M) i (c *s a)) =\n  c * Square_Matrix.det (upd_row (Square_Matrix.transpose M) i a)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i (c *s a)) =\n    c * Square_Matrix.det (upd_col M i a)", "by (simp add: upd_row_transpose det_transpose)"], ["", "lemma det_col_uminus: \"det (upd_col M i (- a)) = - det (upd_col M i a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i (- a)) =\n    - Square_Matrix.det (upd_col M i a)", "by (simp add: vector_sneg_minus1 det_col_mul)"], ["", "lemma det_col_minus: \"det (upd_col M i (a - b)) = det (upd_col M i a) - det (upd_col M i b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i (a - b)) =\n    Square_Matrix.det (upd_col M i a) - Square_Matrix.det (upd_col M i b)", "unfolding diff_conv_add_uminus det_col_add det_col_uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i a) +\n    - Square_Matrix.det (upd_col M i b) =\n    Square_Matrix.det (upd_col M i a) + - Square_Matrix.det (upd_col M i b)", ".."], ["", "lemma det_col_0: \"det (upd_col M i 0) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i 0) = (0::'a)", "using det_col_mul[of M i 0]"], ["proof (prove)\nusing this:\n  Square_Matrix.det (upd_col M i ((0::'a) *s ?a)) =\n  (0::'a) * Square_Matrix.det (upd_col M i ?a)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i 0) = (0::'a)", "by simp"], ["", "lemma det_col_sum: \"det (upd_col M i (\\<Sum>s\\<in>S. a s)) = (\\<Sum>s\\<in>S. det (upd_col M i (a s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col M i (sum a S)) =\n    (\\<Sum>s\\<in>S. Square_Matrix.det (upd_col M i (a s)))", "by (induction S rule: infinite_finite_induct) (simp_all add: det_col_0 det_col_add)"], ["", "(* Proof by Jose Divason *)"], ["", "lemma det_identical_cols:\n  assumes \"i \\<noteq> i'\" shows \"col A i = col A i' \\<Longrightarrow> det A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col A i = col A i' \\<Longrightarrow> Square_Matrix.det A = (0::'b)", "proof (transfer fixing: i i')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "fix A :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "assume \"(\\<chi> j. A j i) = (\\<chi> i. A i i')\""], ["proof (state)\nthis:\n  (\\<chi>j. A j i) = (\\<chi>i. A i i')\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "then"], ["proof (chain)\npicking this:\n  (\\<chi>j. A j i) = (\\<chi>i. A i i')", "have [simp]: \"\\<And>j q. A j (Fun.swap i i' id (q j)) = A j (q j)\""], ["proof (prove)\nusing this:\n  (\\<chi>j. A j i) = (\\<chi>i. A i i')\n\ngoal (1 subgoal):\n 1. \\<And>j q. A j (Fun.swap i i' id (q j)) = A j (q j)", "by (auto simp: vec_eq_iff swap_def)"], ["proof (state)\nthis:\n  A ?j (Fun.swap i i' id (?q ?j)) = A ?j (?q ?j)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "let ?p = \"\\<lambda>p. of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "let ?s = \"\\<lambda>q. Fun.swap i i' id \\<circ> q\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "let ?E = \"{p. p permutes UNIV \\<and> evenperm p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "have [simp]: \"inj_on ?s ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((\\<circ>) (Fun.swap i i' id))\n     {p. p permutes UNIV \\<and> evenperm p}", "by (auto simp: inj_on_def fun_eq_iff swap_def)"], ["proof (state)\nthis:\n  inj_on ((\\<circ>) (Fun.swap i i' id))\n   {p. p permutes UNIV \\<and> evenperm p}\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "note p = permutes_UNIV_permutation evenperm_comp permutes_swap_id evenperm_swap permutes_compose\n    sign_compose sign_swap_id"], ["proof (state)\nthis:\n  permutation ?p = (?p permutes UNIV)\n  \\<lbrakk>permutation ?p; permutation ?q\\<rbrakk>\n  \\<Longrightarrow> evenperm (?p \\<circ> ?q) = (evenperm ?p = evenperm ?q)\n  \\<lbrakk>?a \\<in> ?S; ?b \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> Fun.swap ?a ?b id permutes ?S\n  evenperm (Fun.swap ?a ?b id) = (?a = ?b)\n  \\<lbrakk>?p permutes ?S; ?q permutes ?S\\<rbrakk>\n  \\<Longrightarrow> ?q \\<circ> ?p permutes ?S\n  \\<lbrakk>permutation ?p; permutation ?q\\<rbrakk>\n  \\<Longrightarrow> sign (?p \\<circ> ?q) = sign ?p * sign ?q\n  sign (Fun.swap ?a ?b id) = (if ?a = ?b then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "from \\<open>i \\<noteq> i'\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> i'", "have *: \"evenperm q\" if \"q \\<notin> ?s`?E\" \"q permutes UNIV\" for q"], ["proof (prove)\nusing this:\n  i \\<noteq> i'\n\ngoal (1 subgoal):\n 1. evenperm q", "using that"], ["proof (prove)\nusing this:\n  i \\<noteq> i'\n  q \\<notin> (\\<circ>) (Fun.swap i i' id) `\n             {p. p permutes UNIV \\<and> evenperm p}\n  q permutes UNIV\n\ngoal (1 subgoal):\n 1. evenperm q", "by (auto simp add: comp_assoc[symmetric] image_iff p elim!: allE[of _ \"?s q\"])"], ["proof (state)\nthis:\n  \\<lbrakk>?q2\n           \\<notin> (\\<circ>) (Fun.swap i i' id) `\n                    {p. p permutes UNIV \\<and> evenperm p};\n   ?q2 permutes UNIV\\<rbrakk>\n  \\<Longrightarrow> evenperm ?q2\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "have \"(\\<Sum>p | p permutes UNIV. ?p p) = (\\<Sum>p \\<in> ?E \\<union> ?s`?E. ?p p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Sum>p\\<in>{p. p permutes UNIV \\<and> evenperm p} \\<union>\n                 (\\<circ>) (Fun.swap i i' id) `\n                 {p. p permutes UNIV \\<and> evenperm p}.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "by (auto simp add: permutes_compose permutes_swap_id intro: * sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{p. p permutes UNIV \\<and> evenperm p} \\<union>\n               (\\<circ>) (Fun.swap i i' id) `\n               {p. p permutes UNIV \\<and> evenperm p}.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "also"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p\\<in>{p. p permutes UNIV \\<and> evenperm p} \\<union>\n               (\\<circ>) (Fun.swap i i' id) `\n               {p. p permutes UNIV \\<and> evenperm p}.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "have \"\\<dots> = (\\<Sum>p\\<in>?E. ?p p) + (\\<Sum>p\\<in>?s`?E. ?p p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>{p. p permutes UNIV \\<and> evenperm p} \\<union>\n                 (\\<circ>) (Fun.swap i i' id) `\n                 {p. p permutes UNIV \\<and> evenperm p}.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) +\n    (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i i' id) `\n                 {p. p permutes UNIV \\<and> evenperm p}.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))", "by (intro sum.union_disjoint) (auto simp: p \\<open>i \\<noteq> i'\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>{p. p permutes UNIV \\<and> evenperm p} \\<union>\n               (\\<circ>) (Fun.swap i i' id) `\n               {p. p permutes UNIV \\<and> evenperm p}.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) +\n  (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i i' id) `\n               {p. p permutes UNIV \\<and> evenperm p}.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>{p. p permutes UNIV \\<and> evenperm p} \\<union>\n               (\\<circ>) (Fun.swap i i' id) `\n               {p. p permutes UNIV \\<and> evenperm p}.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) +\n  (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i i' id) `\n               {p. p permutes UNIV \\<and> evenperm p}.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i)))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "have \"(\\<Sum>p\\<in>?s`?E. ?p p) = (\\<Sum>p\\<in>?E. - ?p p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i i' id) `\n                 {p. p permutes UNIV \\<and> evenperm p}.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n       - (of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))))", "using \\<open>i \\<noteq> i'\\<close>"], ["proof (prove)\nusing this:\n  i \\<noteq> i'\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i i' id) `\n                 {p. p permutes UNIV \\<and> evenperm p}.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n       - (of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))))", "by (subst sum.reindex) (auto intro!: sum.cong simp: p)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>(\\<circ>) (Fun.swap i i' id) `\n               {p. p permutes UNIV \\<and> evenperm p}.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n     - (of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       (\\<chi>ia. A ia i) = (\\<chi>i. A i i') \\<Longrightarrow>\n       (\\<Sum>p | p permutes UNIV.\n          of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n       (0::'b)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) +\n  (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n     - (of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))))", "show \"(\\<Sum>p | p permutes UNIV. ?p p) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) +\n  (\\<Sum>p | p permutes UNIV \\<and> evenperm p.\n     - (of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n    (0::'b)", "by (simp add: sum_negf)"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. A i (p i))) =\n  (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_identical_rows: \"i \\<noteq> i' \\<Longrightarrow> row A i = row A i' \\<Longrightarrow> det A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> i';\n     Square_Matrix.row A i = Square_Matrix.row A i'\\<rbrakk>\n    \\<Longrightarrow> Square_Matrix.det A = (0::'b)", "using det_identical_cols[of i i' \"transpose A\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<noteq> i';\n   col (Square_Matrix.transpose A) i =\n   col (Square_Matrix.transpose A) i'\\<rbrakk>\n  \\<Longrightarrow> Square_Matrix.det (Square_Matrix.transpose A) = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> i';\n     Square_Matrix.row A i = Square_Matrix.row A i'\\<rbrakk>\n    \\<Longrightarrow> Square_Matrix.det A = (0::'b)", "by (simp add: det_transpose col_transpose)"], ["", "lemma det_cols_sum:\n  \"det (upd_cols M T (\\<lambda>i. \\<Sum>s\\<in>S. a i s)) = (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S. det (upd_cols M T (\\<lambda>i. a i (f i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_cols M T (\\<lambda>i. sum (a i) S)) =\n    (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det (upd_cols M T (\\<lambda>i. a i (f i))))", "proof (induct T arbitrary: M rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A M.\n       infinite A \\<Longrightarrow>\n       Square_Matrix.det (upd_cols M A (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>A \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M A (\\<lambda>i. a i (f i))))\n 2. \\<And>M.\n       Square_Matrix.det (upd_cols M {} (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>{} \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M {} (\\<lambda>i. a i (f i))))\n 3. \\<And>x F M.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>M.\n           Square_Matrix.det (upd_cols M F (\\<lambda>i. sum (a i) S)) =\n           (\\<Sum>f\\<in>F \\<rightarrow>\\<^sub>E S.\n              Square_Matrix.det\n               (upd_cols M F (\\<lambda>i. a i (f i))))\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det\n                          (upd_cols M (insert x F)\n                            (\\<lambda>i. sum (a i) S)) =\n                         (\\<Sum>f\\<in>insert x F \\<rightarrow>\\<^sub>E S.\n                            Square_Matrix.det\n                             (upd_cols M (insert x F)\n                               (\\<lambda>i. a i (f i))))", "case (insert i T)"], ["proof (state)\nthis:\n  finite T\n  i \\<notin> T\n  Square_Matrix.det (upd_cols ?M T (\\<lambda>i. sum (a i) S)) =\n  (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n     Square_Matrix.det (upd_cols ?M T (\\<lambda>i. a i (f i))))\n\ngoal (3 subgoals):\n 1. \\<And>A M.\n       infinite A \\<Longrightarrow>\n       Square_Matrix.det (upd_cols M A (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>A \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M A (\\<lambda>i. a i (f i))))\n 2. \\<And>M.\n       Square_Matrix.det (upd_cols M {} (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>{} \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M {} (\\<lambda>i. a i (f i))))\n 3. \\<And>x F M.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>M.\n           Square_Matrix.det (upd_cols M F (\\<lambda>i. sum (a i) S)) =\n           (\\<Sum>f\\<in>F \\<rightarrow>\\<^sub>E S.\n              Square_Matrix.det\n               (upd_cols M F (\\<lambda>i. a i (f i))))\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det\n                          (upd_cols M (insert x F)\n                            (\\<lambda>i. sum (a i) S)) =\n                         (\\<Sum>f\\<in>insert x F \\<rightarrow>\\<^sub>E S.\n                            Square_Matrix.det\n                             (upd_cols M (insert x F)\n                               (\\<lambda>i. a i (f i))))", "have \"(\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S. det (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n    (\\<Sum>s\\<in>S. \\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S. det (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det\n        (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n    (\\<Sum>s\\<in>S.\n       \\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n         Square_Matrix.det\n          (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i))))", "unfolding sum.cartesian_product PiE_insert_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>(\\<lambda>(y, g). g(i := y)) `\n                 (S \\<times> (T \\<rightarrow>\\<^sub>E S)).\n       Square_Matrix.det\n        (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n    (\\<Sum>(s, f)\\<in>S \\<times> (T \\<rightarrow>\\<^sub>E S).\n       Square_Matrix.det\n        (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i))))", "using \\<open>i \\<notin> T\\<close>"], ["proof (prove)\nusing this:\n  i \\<notin> T\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>(\\<lambda>(y, g). g(i := y)) `\n                 (S \\<times> (T \\<rightarrow>\\<^sub>E S)).\n       Square_Matrix.det\n        (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n    (\\<Sum>(s, f)\\<in>S \\<times> (T \\<rightarrow>\\<^sub>E S).\n       Square_Matrix.det\n        (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i))))", "by (subst sum.reindex[OF inj_combinator[OF \\<open>i \\<notin> T\\<close>]])\n       (auto intro!: sum.cong arg_cong[where f=det] upd_cols_cong\n             simp: upd_cols_insert_rev simp_implies_def)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S.\n     Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n  (\\<Sum>s\\<in>S.\n     \\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det\n        (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i))))\n\ngoal (3 subgoals):\n 1. \\<And>A M.\n       infinite A \\<Longrightarrow>\n       Square_Matrix.det (upd_cols M A (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>A \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M A (\\<lambda>i. a i (f i))))\n 2. \\<And>M.\n       Square_Matrix.det (upd_cols M {} (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>{} \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M {} (\\<lambda>i. a i (f i))))\n 3. \\<And>x F M.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>M.\n           Square_Matrix.det (upd_cols M F (\\<lambda>i. sum (a i) S)) =\n           (\\<Sum>f\\<in>F \\<rightarrow>\\<^sub>E S.\n              Square_Matrix.det\n               (upd_cols M F (\\<lambda>i. a i (f i))))\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det\n                          (upd_cols M (insert x F)\n                            (\\<lambda>i. sum (a i) S)) =\n                         (\\<Sum>f\\<in>insert x F \\<rightarrow>\\<^sub>E S.\n                            Square_Matrix.det\n                             (upd_cols M (insert x F)\n                               (\\<lambda>i. a i (f i))))", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S.\n     Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n  (\\<Sum>s\\<in>S.\n     \\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det\n        (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i))))\n\ngoal (3 subgoals):\n 1. \\<And>A M.\n       infinite A \\<Longrightarrow>\n       Square_Matrix.det (upd_cols M A (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>A \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M A (\\<lambda>i. a i (f i))))\n 2. \\<And>M.\n       Square_Matrix.det (upd_cols M {} (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>{} \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M {} (\\<lambda>i. a i (f i))))\n 3. \\<And>x F M.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>M.\n           Square_Matrix.det (upd_cols M F (\\<lambda>i. sum (a i) S)) =\n           (\\<Sum>f\\<in>F \\<rightarrow>\\<^sub>E S.\n              Square_Matrix.det\n               (upd_cols M F (\\<lambda>i. a i (f i))))\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det\n                          (upd_cols M (insert x F)\n                            (\\<lambda>i. sum (a i) S)) =\n                         (\\<Sum>f\\<in>insert x F \\<rightarrow>\\<^sub>E S.\n                            Square_Matrix.det\n                             (upd_cols M (insert x F)\n                               (\\<lambda>i. a i (f i))))", "have \"\\<dots> = det (upd_col (upd_cols M T (\\<lambda>i. sum (a i) S)) i (\\<Sum>s\\<in>S. a i s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S.\n       \\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n         Square_Matrix.det\n          (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i)))) =\n    Square_Matrix.det\n     (upd_col (upd_cols M T (\\<lambda>i. sum (a i) S)) i (sum (a i) S))", "unfolding insert(3)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s\\<in>S.\n       Square_Matrix.det\n        (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. sum (a i) S))) =\n    Square_Matrix.det\n     (upd_col (upd_cols M T (\\<lambda>i. sum (a i) S)) i (sum (a i) S))", "by (simp add: upd_cols_upd_col_swap[OF \\<open>i \\<notin> T\\<close>] det_col_sum)"], ["proof (state)\nthis:\n  (\\<Sum>s\\<in>S.\n     \\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det\n        (upd_cols (upd_col M i (a i s)) T (\\<lambda>i. a i (f i)))) =\n  Square_Matrix.det\n   (upd_col (upd_cols M T (\\<lambda>i. sum (a i) S)) i (sum (a i) S))\n\ngoal (3 subgoals):\n 1. \\<And>A M.\n       infinite A \\<Longrightarrow>\n       Square_Matrix.det (upd_cols M A (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>A \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M A (\\<lambda>i. a i (f i))))\n 2. \\<And>M.\n       Square_Matrix.det (upd_cols M {} (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>{} \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M {} (\\<lambda>i. a i (f i))))\n 3. \\<And>x F M.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>M.\n           Square_Matrix.det (upd_cols M F (\\<lambda>i. sum (a i) S)) =\n           (\\<Sum>f\\<in>F \\<rightarrow>\\<^sub>E S.\n              Square_Matrix.det\n               (upd_cols M F (\\<lambda>i. a i (f i))))\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det\n                          (upd_cols M (insert x F)\n                            (\\<lambda>i. sum (a i) S)) =\n                         (\\<Sum>f\\<in>insert x F \\<rightarrow>\\<^sub>E S.\n                            Square_Matrix.det\n                             (upd_cols M (insert x F)\n                               (\\<lambda>i. a i (f i))))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S.\n     Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n  Square_Matrix.det\n   (upd_col (upd_cols M T (\\<lambda>i. sum (a i) S)) i (sum (a i) S))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S.\n     Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. a i (f i)))) =\n  Square_Matrix.det\n   (upd_col (upd_cols M T (\\<lambda>i. sum (a i) S)) i (sum (a i) S))\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. sum (a i) S)) =\n    (\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. a i (f i))))", "by (simp add: upd_cols_insert)"], ["proof (state)\nthis:\n  Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. sum (a i) S)) =\n  (\\<Sum>f\\<in>insert i T \\<rightarrow>\\<^sub>E S.\n     Square_Matrix.det (upd_cols M (insert i T) (\\<lambda>i. a i (f i))))\n\ngoal (2 subgoals):\n 1. \\<And>A M.\n       infinite A \\<Longrightarrow>\n       Square_Matrix.det (upd_cols M A (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>A \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M A (\\<lambda>i. a i (f i))))\n 2. \\<And>M.\n       Square_Matrix.det (upd_cols M {} (\\<lambda>i. sum (a i) S)) =\n       (\\<Sum>f\\<in>{} \\<rightarrow>\\<^sub>E S.\n          Square_Matrix.det (upd_cols M {} (\\<lambda>i. a i (f i))))", "qed auto"], ["", "lemma det_rows_sum:\n  \"det (upd_rows M T (\\<lambda>i. \\<Sum>s\\<in>S. a i s)) = (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S. det (upd_rows M T (\\<lambda>i. a i (f i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_rows M T (\\<lambda>i. sum (a i) S)) =\n    (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det (upd_rows M T (\\<lambda>i. a i (f i))))", "using det_cols_sum[of \"transpose M\" T a S]"], ["proof (prove)\nusing this:\n  Square_Matrix.det\n   (upd_cols (Square_Matrix.transpose M) T (\\<lambda>i. sum (a i) S)) =\n  (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n     Square_Matrix.det\n      (upd_cols (Square_Matrix.transpose M) T (\\<lambda>i. a i (f i))))\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_rows M T (\\<lambda>i. sum (a i) S)) =\n    (\\<Sum>f\\<in>T \\<rightarrow>\\<^sub>E S.\n       Square_Matrix.det (upd_rows M T (\\<lambda>i. a i (f i))))", "by (simp add: upd_cols_transpose det_transpose)"], ["", "lemma det_rows_mult: \"det (upd_rows M T (\\<lambda>i. c i *s a i)) = (\\<Prod>i\\<in>T. c i) * det (upd_rows M T a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_rows M T (\\<lambda>i. c i *s a i)) =\n    prod c T * Square_Matrix.det (upd_rows M T a)", "by transfer (simp add: prod.If_cases sum_distrib_left field_simps prod.distrib)"], ["", "lemma det_cols_mult: \"det (upd_cols M T (\\<lambda>i. c i *s a i)) = (\\<Prod>i\\<in>T. c i) * det (upd_cols M T a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_cols M T (\\<lambda>i. c i *s a i)) =\n    prod c T * Square_Matrix.det (upd_cols M T a)", "using det_rows_mult[of \"transpose M\" T c a]"], ["proof (prove)\nusing this:\n  Square_Matrix.det\n   (upd_rows (Square_Matrix.transpose M) T (\\<lambda>i. c i *s a i)) =\n  prod c T * Square_Matrix.det (upd_rows (Square_Matrix.transpose M) T a)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_cols M T (\\<lambda>i. c i *s a i)) =\n    prod c T * Square_Matrix.det (upd_cols M T a)", "by (simp add: det_transpose upd_rows_transpose)"], ["", "lemma det_perm_rows_If: \"det (perm_rows B f) = (if f permutes UNIV then of_int (sign f) * det B else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))\n 2. \\<not> ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "assume \"\\<not> f permutes UNIV\""], ["proof (state)\nthis:\n  \\<not> f permutes UNIV\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))\n 2. \\<not> ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "moreover"], ["proof (state)\nthis:\n  \\<not> f permutes UNIV\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))\n 2. \\<not> ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "with bij_imp_permutes[of f UNIV]"], ["proof (chain)\npicking this:\n  \\<lbrakk>bij f;\n   \\<And>x. x \\<notin> UNIV \\<Longrightarrow> f x = x\\<rbrakk>\n  \\<Longrightarrow> f permutes UNIV\n  \\<not> f permutes UNIV", "have \"\\<not> inj f\""], ["proof (prove)\nusing this:\n  \\<lbrakk>bij f;\n   \\<And>x. x \\<notin> UNIV \\<Longrightarrow> f x = x\\<rbrakk>\n  \\<Longrightarrow> f permutes UNIV\n  \\<not> f permutes UNIV\n\ngoal (1 subgoal):\n 1. \\<not> inj f", "using finite_UNIV_inj_surj[of f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>bij f;\n   \\<And>x. x \\<notin> UNIV \\<Longrightarrow> f x = x\\<rbrakk>\n  \\<Longrightarrow> f permutes UNIV\n  \\<not> f permutes UNIV\n  \\<lbrakk>finite UNIV; inj f\\<rbrakk> \\<Longrightarrow> surj f\n\ngoal (1 subgoal):\n 1. \\<not> inj f", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  \\<not> inj f\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))\n 2. \\<not> ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "then"], ["proof (chain)\npicking this:\n  \\<not> inj f", "obtain i j where \"f i = f j\" \"i \\<noteq> j\""], ["proof (prove)\nusing this:\n  \\<not> inj f\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>f i = f j; i \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  f i = f j\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))\n 2. \\<not> ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "moreover"], ["proof (state)\nthis:\n  f i = f j\n  i \\<noteq> j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))\n 2. \\<not> ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "then"], ["proof (chain)\npicking this:\n  f i = f j\n  i \\<noteq> j", "have \"row (perm_rows B f) i = row (perm_rows B f) j\""], ["proof (prove)\nusing this:\n  f i = f j\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Square_Matrix.row (perm_rows B f) i =\n    Square_Matrix.row (perm_rows B f) j", "by transfer (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  Square_Matrix.row (perm_rows B f) i = Square_Matrix.row (perm_rows B f) j\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))\n 2. \\<not> ?P \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> f permutes UNIV\n  f i = f j\n  i \\<noteq> j\n  Square_Matrix.row (perm_rows B f) i = Square_Matrix.row (perm_rows B f) j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> f permutes UNIV\n  f i = f j\n  i \\<noteq> j\n  Square_Matrix.row (perm_rows B f) i = Square_Matrix.row (perm_rows B f) j\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "by (simp add: det_identical_rows)"], ["proof (state)\nthis:\n  Square_Matrix.det (perm_rows B f) =\n  (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> f permutes UNIV \\<Longrightarrow>\n    Square_Matrix.det (perm_rows B f) =\n    (if f permutes UNIV then of_int (sign f) * Square_Matrix.det B\n     else (0::'a))", "qed (simp add: det_perm_rows)"], ["", "lemma det_mult: \"det (A * B) = det A * det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "have \"A * B = upd_rows 0 UNIV (\\<lambda>i. \\<Sum>j\\<in>UNIV. to_fun A i j *s row B j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B =\n    upd_rows 0 UNIV\n     (\\<lambda>i. \\<Sum>j\\<in>UNIV. to_fun A i j *s Square_Matrix.row B j)", "by transfer simp"], ["proof (state)\nthis:\n  A * B =\n  upd_rows 0 UNIV\n   (\\<lambda>i. \\<Sum>j\\<in>UNIV. to_fun A i j *s Square_Matrix.row B j)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "moreover"], ["proof (state)\nthis:\n  A * B =\n  upd_rows 0 UNIV\n   (\\<lambda>i. \\<Sum>j\\<in>UNIV. to_fun A i j *s Square_Matrix.row B j)\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "have \"\\<And>f. upd_rows 0 UNIV (\\<lambda>i. Square_Matrix.row B (f i)) = perm_rows B f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       upd_rows 0 UNIV (\\<lambda>i. Square_Matrix.row B (f i)) =\n       perm_rows B f", "by transfer simp"], ["proof (state)\nthis:\n  upd_rows 0 UNIV (\\<lambda>i. Square_Matrix.row B (?f i)) = perm_rows B ?f\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "moreover"], ["proof (state)\nthis:\n  upd_rows 0 UNIV (\\<lambda>i. Square_Matrix.row B (?f i)) = perm_rows B ?f\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "have \"det A = (\\<Sum>p | p permutes UNIV. of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det A =\n    (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))", "by transfer rule"], ["proof (state)\nthis:\n  Square_Matrix.det A =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "ultimately"], ["proof (chain)\npicking this:\n  A * B =\n  upd_rows 0 UNIV\n   (\\<lambda>i. \\<Sum>j\\<in>UNIV. to_fun A i j *s Square_Matrix.row B j)\n  upd_rows 0 UNIV (\\<lambda>i. Square_Matrix.row B (?f i)) = perm_rows B ?f\n  Square_Matrix.det A =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))", "show ?thesis"], ["proof (prove)\nusing this:\n  A * B =\n  upd_rows 0 UNIV\n   (\\<lambda>i. \\<Sum>j\\<in>UNIV. to_fun A i j *s Square_Matrix.row B j)\n  upd_rows 0 UNIV (\\<lambda>i. Square_Matrix.row B (?f i)) = perm_rows B ?f\n  Square_Matrix.det A =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. to_fun A i (p i)))\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B", "by (auto simp add: det_rows_sum det_rows_mult sum_distrib_right det_perm_rows_If\n             split: if_split_asm intro!: sum.mono_neutral_cong_right)"], ["proof (state)\nthis:\n  Square_Matrix.det (A * B) = Square_Matrix.det A * Square_Matrix.det B\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition minor :: \"'a^^'b \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> 'a::semiring_1^^'b\" is\n  \"\\<lambda>A i j k l. if k = i \\<and> l = j then 1 else if k = i \\<or> l = j then 0 else A k l\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma minor_transpose: \"minor (transpose A) i j = transpose (minor A j i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minor (Square_Matrix.transpose A) i j =\n    Square_Matrix.transpose (minor A j i)", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma minor_eq_row_col: \"minor M i j = upd_row (upd_col M j (axis i 1)) i (axis j 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minor M i j = upd_row (upd_col M j (axis i (1::'a))) i (axis j (1::'a))", "by transfer (simp add: fun_eq_iff axis_def)"], ["", "lemma minor_eq_col_row: \"minor M i j = upd_col (upd_row M i (axis j 1)) j (axis i 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minor M i j = upd_col (upd_row M i (axis j (1::'a))) j (axis i (1::'a))", "by transfer (simp add: fun_eq_iff axis_def)"], ["", "lemma row_minor: \"row (minor M i j) i = axis j 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.row (minor M i j) i = axis j (1::'a)", "by (simp add: minor_eq_row_col)"], ["", "lemma col_minor: \"col (minor M i j) j = axis i 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (minor M i j) j = axis i (1::'a)", "by (simp add: minor_eq_col_row)"], ["", "lemma det_minor_row':\n  \"row B i = axis j 1 \\<Longrightarrow> det (minor B i j) = det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.row B i = axis j (1::'a) \\<Longrightarrow>\n    Square_Matrix.det (minor B i j) = Square_Matrix.det B", "proof (induction \"{k. to_fun B k j \\<noteq> 0} - {i}\" arbitrary: B rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>B.\n       \\<lbrakk>{} = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 3. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "case empty"], ["proof (state)\nthis:\n  {} = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>B.\n       \\<lbrakk>{} = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 3. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "then"], ["proof (chain)\npicking this:\n  {} = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)", "have \"\\<And>k. k \\<noteq> i \\<longrightarrow> to_fun B k j = 0\""], ["proof (prove)\nusing this:\n  {} = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>k. k \\<noteq> i \\<longrightarrow> to_fun B k j = (0::'a)", "by (auto simp add: card_eq_0_iff)"], ["proof (state)\nthis:\n  ?k \\<noteq> i \\<longrightarrow> to_fun B ?k j = (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>B.\n       \\<lbrakk>{} = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 3. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "with empty.prems"], ["proof (chain)\npicking this:\n  Square_Matrix.row B i = axis j (1::'a)\n  ?k \\<noteq> i \\<longrightarrow> to_fun B ?k j = (0::'a)", "have \"axis i 1 = col B j\""], ["proof (prove)\nusing this:\n  Square_Matrix.row B i = axis j (1::'a)\n  ?k \\<noteq> i \\<longrightarrow> to_fun B ?k j = (0::'a)\n\ngoal (1 subgoal):\n 1. axis i (1::'a) = col B j", "by transfer (auto simp: vec_eq_iff axis_def)"], ["proof (state)\nthis:\n  axis i (1::'a) = col B j\n\ngoal (3 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>B.\n       \\<lbrakk>{} = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 3. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "with empty.prems[symmetric]"], ["proof (chain)\npicking this:\n  axis j (1::'a) = Square_Matrix.row B i\n  axis i (1::'a) = col B j", "show ?case"], ["proof (prove)\nusing this:\n  axis j (1::'a) = Square_Matrix.row B i\n  axis i (1::'a) = col B j\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) = Square_Matrix.det B", "by (simp add: minor_eq_row_col)"], ["proof (state)\nthis:\n  Square_Matrix.det (minor B i j) = Square_Matrix.det B\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "case (insert r NZ)"], ["proof (state)\nthis:\n  finite NZ\n  r \\<notin> NZ\n  \\<lbrakk>NZ = {k. to_fun ?B k j \\<noteq> (0::'a)} - {i};\n   Square_Matrix.row ?B i = axis j (1::'a)\\<rbrakk>\n  \\<Longrightarrow> Square_Matrix.det (minor ?B i j) = Square_Matrix.det ?B\n  insert r NZ = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "then"], ["proof (chain)\npicking this:\n  finite NZ\n  r \\<notin> NZ\n  \\<lbrakk>NZ = {k. to_fun ?B k j \\<noteq> (0::'a)} - {i};\n   Square_Matrix.row ?B i = axis j (1::'a)\\<rbrakk>\n  \\<Longrightarrow> Square_Matrix.det (minor ?B i j) = Square_Matrix.det ?B\n  insert r NZ = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)", "have r: \"r \\<noteq> i\" \"to_fun B r j \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite NZ\n  r \\<notin> NZ\n  \\<lbrakk>NZ = {k. to_fun ?B k j \\<noteq> (0::'a)} - {i};\n   Square_Matrix.row ?B i = axis j (1::'a)\\<rbrakk>\n  \\<Longrightarrow> Square_Matrix.det (minor ?B i j) = Square_Matrix.det ?B\n  insert r NZ = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)\n\ngoal (1 subgoal):\n 1. r \\<noteq> i &&& to_fun B r j \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> i\n  to_fun B r j \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "let ?B' = \"upd_row B r (row B r - (to_fun B r j) *s row B i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "have \"det (minor ?B' i j) = det ?B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det\n     (minor\n       (upd_row B r\n         (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n       i j) =\n    Square_Matrix.det\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))", "proof (rule insert.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. NZ =\n    {k. to_fun\n         (upd_row B r\n           (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n         k j \\<noteq>\n        (0::'a)} -\n    {i}\n 2. Square_Matrix.row\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i =\n    axis j (1::'a)", "show \"NZ = {k. to_fun ?B' k j \\<noteq> 0} - {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NZ =\n    {k. to_fun\n         (upd_row B r\n           (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n         k j \\<noteq>\n        (0::'a)} -\n    {i}", "using insert.hyps(2,4) insert.prems"], ["proof (prove)\nusing this:\n  r \\<notin> NZ\n  insert r NZ = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)\n\ngoal (1 subgoal):\n 1. NZ =\n    {k. to_fun\n         (upd_row B r\n           (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n         k j \\<noteq>\n        (0::'a)} -\n    {i}", "by transfer (auto simp add: axis_def set_eq_iff)"], ["proof (state)\nthis:\n  NZ =\n  {k. to_fun\n       (upd_row B r\n         (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n       k j \\<noteq>\n      (0::'a)} -\n  {i}\n\ngoal (1 subgoal):\n 1. Square_Matrix.row\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i =\n    axis j (1::'a)", "show \"row ?B' i = axis j 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.row\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i =\n    axis j (1::'a)", "using r insert"], ["proof (prove)\nusing this:\n  r \\<noteq> i\n  to_fun B r j \\<noteq> (0::'a)\n  finite NZ\n  r \\<notin> NZ\n  \\<lbrakk>NZ = {k. to_fun ?B k j \\<noteq> (0::'a)} - {i};\n   Square_Matrix.row ?B i = axis j (1::'a)\\<rbrakk>\n  \\<Longrightarrow> Square_Matrix.det (minor ?B i j) = Square_Matrix.det ?B\n  insert r NZ = {k. to_fun B k j \\<noteq> (0::'a)} - {i}\n  Square_Matrix.row B i = axis j (1::'a)\n\ngoal (1 subgoal):\n 1. Square_Matrix.row\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i =\n    axis j (1::'a)", "by (simp add: row_upd_row_If)"], ["proof (state)\nthis:\n  Square_Matrix.row\n   (upd_row B r\n     (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n   i =\n  axis j (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Square_Matrix.det\n   (minor\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i j) =\n  Square_Matrix.det\n   (upd_row B r\n     (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "also"], ["proof (state)\nthis:\n  Square_Matrix.det\n   (minor\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i j) =\n  Square_Matrix.det\n   (upd_row B r\n     (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "have \"minor ?B' i j = minor B i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minor\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i j =\n    minor B i j", "using r insert.prems"], ["proof (prove)\nusing this:\n  r \\<noteq> i\n  to_fun B r j \\<noteq> (0::'a)\n  Square_Matrix.row B i = axis j (1::'a)\n\ngoal (1 subgoal):\n 1. minor\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n     i j =\n    minor B i j", "by transfer (simp add: fun_eq_iff axis_def)"], ["proof (state)\nthis:\n  minor\n   (upd_row B r\n     (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n   i j =\n  minor B i j\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "also"], ["proof (state)\nthis:\n  minor\n   (upd_row B r\n     (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i))\n   i j =\n  minor B i j\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "have \"det ?B' = det B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i)) =\n    Square_Matrix.det B", "using \\<open>r \\<noteq> i\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> i\n\ngoal (1 subgoal):\n 1. Square_Matrix.det\n     (upd_row B r\n       (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i)) =\n    Square_Matrix.det B", "by (simp add: det_row_minus det_row_mul det_identical_rows[OF \\<open>r \\<noteq> i\\<close>] row_upd_row_If)"], ["proof (state)\nthis:\n  Square_Matrix.det\n   (upd_row B r\n     (Square_Matrix.row B r - to_fun B r j *s Square_Matrix.row B i)) =\n  Square_Matrix.det B\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B\n 2. \\<And>x F B.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>B.\n           \\<lbrakk>F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n            Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n           \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                             Square_Matrix.det B;\n        insert x F = {k. to_fun B k j \\<noteq> (0::'a)} - {i};\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "finally"], ["proof (chain)\npicking this:\n  Square_Matrix.det (minor B i j) = Square_Matrix.det B", "show ?case"], ["proof (prove)\nusing this:\n  Square_Matrix.det (minor B i j) = Square_Matrix.det B\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) = Square_Matrix.det B", "."], ["proof (state)\nthis:\n  Square_Matrix.det (minor B i j) = Square_Matrix.det B\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>infinite ({k. to_fun B k j \\<noteq> (0::'a)} - {i});\n        Square_Matrix.row B i = axis j (1::'a)\\<rbrakk>\n       \\<Longrightarrow> Square_Matrix.det (minor B i j) =\n                         Square_Matrix.det B", "qed simp"], ["", "lemma det_minor_row: \"det (minor B i j) = det (upd_row B i (axis j 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) =\n    Square_Matrix.det (upd_row B i (axis j (1::'a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) =\n    Square_Matrix.det (upd_row B i (axis j (1::'a)))", "have \"det (minor (upd_row B i (axis j 1)) i j) = det (upd_row B i (axis j 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor (upd_row B i (axis j (1::'a))) i j) =\n    Square_Matrix.det (upd_row B i (axis j (1::'a)))", "by (rule det_minor_row') simp"], ["proof (state)\nthis:\n  Square_Matrix.det (minor (upd_row B i (axis j (1::'a))) i j) =\n  Square_Matrix.det (upd_row B i (axis j (1::'a)))\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) =\n    Square_Matrix.det (upd_row B i (axis j (1::'a)))", "then"], ["proof (chain)\npicking this:\n  Square_Matrix.det (minor (upd_row B i (axis j (1::'a))) i j) =\n  Square_Matrix.det (upd_row B i (axis j (1::'a)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Square_Matrix.det (minor (upd_row B i (axis j (1::'a))) i j) =\n  Square_Matrix.det (upd_row B i (axis j (1::'a)))\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) =\n    Square_Matrix.det (upd_row B i (axis j (1::'a)))", "by (simp add: minor_eq_col_row)"], ["proof (state)\nthis:\n  Square_Matrix.det (minor B i j) =\n  Square_Matrix.det (upd_row B i (axis j (1::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_minor_col: \"det (minor B i j) = det (upd_col B j (axis i 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) =\n    Square_Matrix.det (upd_col B j (axis i (1::'a)))", "using det_minor_row[of \"transpose B\" j i]"], ["proof (prove)\nusing this:\n  Square_Matrix.det (minor (Square_Matrix.transpose B) j i) =\n  Square_Matrix.det (upd_row (Square_Matrix.transpose B) j (axis i (1::'a)))\n\ngoal (1 subgoal):\n 1. Square_Matrix.det (minor B i j) =\n    Square_Matrix.det (upd_col B j (axis i (1::'a)))", "by (simp add: minor_transpose det_transpose upd_row_transpose)"], ["", "lift_definition cofactor :: \"'a^^'b \\<Rightarrow> 'a::comm_ring_1^^'b\" is\n  \"\\<lambda>A i j. det (minor A i j)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma cofactor_transpose: \"cofactor (transpose A) = transpose (cofactor A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactor (Square_Matrix.transpose A) =\n    Square_Matrix.transpose (cofactor A)", "by (simp add: cofactor_def minor_transpose det_transpose transpose.rep_eq to_fun_inject[symmetric] of_fun_inverse)"], ["", "definition \"adjugate A = transpose (cofactor A)\""], ["", "lemma adjugate_transpose: \"adjugate (transpose A) = transpose (adjugate A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjugate (Square_Matrix.transpose A) =\n    Square_Matrix.transpose (adjugate A)", "by (simp add: adjugate_def cofactor_transpose)"], ["", "theorem adjugate_mult_det: \"adjugate A * A = diag (det A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjugate A * A = diag (Square_Matrix.det A)", "proof (intro to_fun_inject[THEN iffD1] fun_eq_iff[THEN iffD2] allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "fix i k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "have \"to_fun (adjugate A * A) i k = (\\<Sum>j\\<in>UNIV. to_fun A j k * det (minor A j i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_fun (adjugate A * A) i k =\n    (\\<Sum>j\\<in>UNIV. to_fun A j k * Square_Matrix.det (minor A j i))", "by (simp add: adjugate_def times_sq_matrix.rep_eq transpose.rep_eq cofactor_def mult.commute of_fun_inverse)"], ["proof (state)\nthis:\n  to_fun (adjugate A * A) i k =\n  (\\<Sum>j\\<in>UNIV. to_fun A j k * Square_Matrix.det (minor A j i))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "also"], ["proof (state)\nthis:\n  to_fun (adjugate A * A) i k =\n  (\\<Sum>j\\<in>UNIV. to_fun A j k * Square_Matrix.det (minor A j i))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "have \"\\<dots> = det (upd_col A i (\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. to_fun A j k * Square_Matrix.det (minor A j i)) =\n    Square_Matrix.det\n     (upd_col A i (\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j (1::'a)))", "by (simp add: det_minor_col det_col_mul det_col_sum)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. to_fun A j k * Square_Matrix.det (minor A j i)) =\n  Square_Matrix.det\n   (upd_col A i (\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j (1::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. to_fun A j k * Square_Matrix.det (minor A j i)) =\n  Square_Matrix.det\n   (upd_col A i (\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j (1::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "have \"(\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j 1) = col A k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j (1::'a)) = col A k", "by transfer (simp add: smult_axis vec_eq_iff, simp add: axis_def sum.If_cases)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j (1::'a)) = col A k\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. to_fun A j k *s axis j (1::'a)) = col A k\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "have \"det (upd_col A i (col A k)) = (if i = k then det A else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.det (upd_col A i (col A k)) =\n    (if i = k then Square_Matrix.det A else (0::'a))", "by (auto simp: col_upd_col_If det_identical_cols[of i k])"], ["proof (state)\nthis:\n  Square_Matrix.det (upd_col A i (col A k)) =\n  (if i = k then Square_Matrix.det A else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "also"], ["proof (state)\nthis:\n  Square_Matrix.det (upd_col A i (col A k)) =\n  (if i = k then Square_Matrix.det A else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "have \"\\<dots> = to_fun (diag (det A)) i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = k then Square_Matrix.det A else (0::'a)) =\n    to_fun (diag (Square_Matrix.det A)) i k", "by (simp add: diag.rep_eq)"], ["proof (state)\nthis:\n  (if i = k then Square_Matrix.det A else (0::'a)) =\n  to_fun (diag (Square_Matrix.det A)) i k\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       to_fun (adjugate A * A) x xa =\n       to_fun (diag (Square_Matrix.det A)) x xa", "finally"], ["proof (chain)\npicking this:\n  to_fun (adjugate A * A) i k = to_fun (diag (Square_Matrix.det A)) i k", "show \"to_fun (adjugate A * A) i k = to_fun (diag (det A)) i k\""], ["proof (prove)\nusing this:\n  to_fun (adjugate A * A) i k = to_fun (diag (Square_Matrix.det A)) i k\n\ngoal (1 subgoal):\n 1. to_fun (adjugate A * A) i k = to_fun (diag (Square_Matrix.det A)) i k", "."], ["proof (state)\nthis:\n  to_fun (adjugate A * A) i k = to_fun (diag (Square_Matrix.det A)) i k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_adjugate_det: \"A * adjugate A = diag (det A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * adjugate A = diag (Square_Matrix.det A)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A * adjugate A = diag (Square_Matrix.det A)", "have \"transpose (transpose (A * adjugate A)) = transpose (diag (det A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (Square_Matrix.transpose (A * adjugate A)) =\n    Square_Matrix.transpose (diag (Square_Matrix.det A))", "unfolding transpose_mult adjugate_transpose[symmetric] adjugate_mult_det det_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. Square_Matrix.transpose (diag (Square_Matrix.det A)) =\n    Square_Matrix.transpose (diag (Square_Matrix.det A))", ".."], ["proof (state)\nthis:\n  Square_Matrix.transpose (Square_Matrix.transpose (A * adjugate A)) =\n  Square_Matrix.transpose (diag (Square_Matrix.det A))\n\ngoal (1 subgoal):\n 1. A * adjugate A = diag (Square_Matrix.det A)", "then"], ["proof (chain)\npicking this:\n  Square_Matrix.transpose (Square_Matrix.transpose (A * adjugate A)) =\n  Square_Matrix.transpose (diag (Square_Matrix.det A))", "show ?thesis"], ["proof (prove)\nusing this:\n  Square_Matrix.transpose (Square_Matrix.transpose (A * adjugate A)) =\n  Square_Matrix.transpose (diag (Square_Matrix.det A))\n\ngoal (1 subgoal):\n 1. A * adjugate A = diag (Square_Matrix.det A)", "by simp"], ["proof (state)\nthis:\n  A * adjugate A = diag (Square_Matrix.det A)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}