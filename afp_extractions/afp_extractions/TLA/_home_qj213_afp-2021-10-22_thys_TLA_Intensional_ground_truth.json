{"file_name": "/home/qj213/afp-2021-10-22/thys/TLA/Intensional.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TLA", "problem_names": ["lemmas intensional_rews[simp] = \n  unl_con unl_lift unl_lift2 unl_lift3 unl_lift4 \n  unl_Rall unl_Rex unl_Rex1", "lemma intD[dest]: \"\\<turnstile> A \\<Longrightarrow> w \\<Turnstile> A\"", "lemma intI [intro!]: assumes P1:\"(\\<And> w. w \\<Turnstile> A)\" shows \"\\<turnstile> A\"", "lemma inteq_reflection: assumes P1: \"\\<turnstile> x=y\" shows  \"(x \\<equiv> y)\"", "lemma int_simps:\n  \"\\<turnstile> (x=x) = #True\"\n  \"\\<turnstile> (\\<not> #True) = #False\"\n  \"\\<turnstile> (\\<not> #False) = #True\"\n  \"\\<turnstile> (\\<not>\\<not> P) = P\"\n  \"\\<turnstile> ((\\<not> P) = P) = #False\"\n  \"\\<turnstile> (P = (\\<not>P)) = #False\"\n  \"\\<turnstile> (P \\<noteq> Q) = (P = (\\<not> Q))\"\n  \"\\<turnstile> (#True=P) = P\"\n  \"\\<turnstile> (P=#True) = P\"\n  \"\\<turnstile> (#True \\<longrightarrow> P) = P\"\n  \"\\<turnstile> (#False \\<longrightarrow> P) = #True\"\n  \"\\<turnstile> (P \\<longrightarrow> #True) = #True\"\n  \"\\<turnstile> (P \\<longrightarrow> P) = #True\"\n  \"\\<turnstile> (P \\<longrightarrow> #False) = (\\<not>P)\"\n  \"\\<turnstile> (P \\<longrightarrow> ~P) = (\\<not>P)\"\n  \"\\<turnstile> (P \\<and> #True) = P\"\n  \"\\<turnstile> (#True \\<and> P) = P\"\n  \"\\<turnstile> (P \\<and> #False) = #False\"\n  \"\\<turnstile> (#False \\<and> P) = #False\"\n  \"\\<turnstile> (P \\<and> P) = P\"\n  \"\\<turnstile> (P \\<and> ~P) = #False\"\n  \"\\<turnstile> (\\<not>P \\<and> P) = #False\"\n  \"\\<turnstile> (P \\<or> #True) = #True\"\n  \"\\<turnstile> (#True \\<or> P) = #True\"\n  \"\\<turnstile> (P \\<or> #False) = P\"\n  \"\\<turnstile> (#False \\<or> P) = P\"\n  \"\\<turnstile> (P \\<or> P) = P\"\n  \"\\<turnstile> (P \\<or> \\<not>P) = #True\"\n  \"\\<turnstile> (\\<not>P \\<or> P) = #True\"\n  \"\\<turnstile> (\\<forall> x. P) = P\"\n  \"\\<turnstile> (\\<exists> x. P) = P\"", "lemmas intensional_simps[simp] = int_simps[THEN inteq_reflection]", "lemma Not_Rall: \"\\<turnstile> (\\<not>(\\<forall> x. F x)) = (\\<exists> x. \\<not>F x)\"", "lemma Not_Rex: \"\\<turnstile> (\\<not>(\\<exists> x. F x)) = (\\<forall> x. \\<not>F x)\"", "lemma TrueW [simp]: \"\\<turnstile> #True\"", "lemma int_eq: \"\\<turnstile> X = Y \\<Longrightarrow> X = Y\"", "lemma int_iffI: \n  assumes \"\\<turnstile> F \\<longrightarrow> G\" and \"\\<turnstile> G \\<longrightarrow> F\"\n  shows \"\\<turnstile> F = G\"", "lemma int_iffD1: assumes h: \"\\<turnstile> F = G\" shows \"\\<turnstile> F \\<longrightarrow> G\"", "lemma int_iffD2: assumes h: \"\\<turnstile> F = G\" shows \"\\<turnstile> G \\<longrightarrow> F\"", "lemma lift_imp_trans: \n  assumes \"\\<turnstile> A \\<longrightarrow> B\" and \"\\<turnstile> B \\<longrightarrow> C\"\n  shows \"\\<turnstile> A \\<longrightarrow> C\"", "lemma lift_imp_neg: assumes \"\\<turnstile> A \\<longrightarrow> B\" shows \"\\<turnstile> \\<not>B \\<longrightarrow> \\<not>A\"", "lemma lift_and_com:  \"\\<turnstile> (A \\<and> B) = (B \\<and> A)\""], "translations": [["", "lemmas intensional_rews[simp] = \n  unl_con unl_lift unl_lift2 unl_lift3 unl_lift4 \n  unl_Rall unl_Rex unl_Rex1"], ["", "subsection\\<open>Concrete Syntax\\<close>"], ["", "nonterminal\n  lift and liftargs"], ["", "text\\<open>\n  The non-terminal @{term lift} represents lifted expressions. The idea is to use \n  Isabelle's macro mechanism to convert between the concrete and abstract syntax.\n\\<close>"], ["", "syntax\n  \"\"            :: \"id \\<Rightarrow> lift\"                          (\"_\")\n  \"\"            :: \"longid \\<Rightarrow> lift\"                      (\"_\")\n  \"\"            :: \"var \\<Rightarrow> lift\"                         (\"_\")\n  \"_applC\"      :: \"[lift, cargs] \\<Rightarrow> lift\"               (\"(1_/ _)\" [1000, 1000] 999)\n  \"\"            :: \"lift \\<Rightarrow> lift\"                        (\"'(_')\")\n  \"_lambda\"     :: \"[idts, 'a] \\<Rightarrow> lift\"                  (\"(3%_./ _)\" [0, 3] 3)\n  \"_constrain\"  :: \"[lift, type] \\<Rightarrow> lift\"                (\"(_::_)\" [4, 0] 3)\n  \"\"            :: \"lift \\<Rightarrow> liftargs\"                    (\"_\")\n  \"_liftargs\"   :: \"[lift, liftargs] \\<Rightarrow> liftargs\"        (\"_,/ _\")\n  \"_Valid\"      :: \"lift \\<Rightarrow> bool\"                        (\"(\\<turnstile> _)\" 5)\n  \"_holdsAt\"    :: \"['a, lift] \\<Rightarrow> bool\"                  (\"(_ \\<Turnstile> _)\" [100,10] 10)\n\n  (* Syntax for lifted expressions outside the scope of \\<turnstile> or \\<Turnstile>.*)\n  \"LIFT\"        :: \"lift \\<Rightarrow> 'a\"                          (\"LIFT _\")\n\n  (* generic syntax for lifted constants and functions *)\n  \"_const\"      :: \"'a \\<Rightarrow> lift\"                          (\"(#_)\" [1000] 999)\n  \"_lift\"       :: \"['a, lift] \\<Rightarrow> lift\"                  (\"(_<_>)\" [1000] 999)\n  \"_lift2\"      :: \"['a, lift, lift] \\<Rightarrow> lift\"            (\"(_<_,/ _>)\" [1000] 999)\n  \"_lift3\"      :: \"['a, lift, lift, lift] \\<Rightarrow> lift\"      (\"(_<_,/ _,/ _>)\" [1000] 999)\n  \"_lift4\"      :: \"['a, lift, lift, lift,lift] \\<Rightarrow> lift\"      (\"(_<_,/ _,/ _,/ _>)\" [1000] 999)\n\n  (* concrete syntax for common infix functions: reuse same symbol *)\n  \"_liftEqu\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ =/ _)\" [50,51] 50)\n  \"_liftNeq\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (infixl \"\\<noteq>\" 50)\n  \"_liftNot\"    :: \"lift \\<Rightarrow> lift\"                        (\"\\<not> _\" [90] 90)\n  \"_liftAnd\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (infixr \"\\<and>\" 35)\n  \"_liftOr\"     :: \"[lift, lift] \\<Rightarrow> lift\"                (infixr \"\\<or>\" 30)\n  \"_liftImp\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (infixr \"\\<longrightarrow>\" 25)\n  \"_liftIf\"     :: \"[lift, lift, lift] \\<Rightarrow> lift\"          (\"(if (_)/ then (_)/ else (_))\" 10)\n  \"_liftPlus\"   :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ +/ _)\" [66,65] 65)\n  \"_liftMinus\"  :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ -/ _)\" [66,65] 65)\n  \"_liftTimes\"  :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ */ _)\" [71,70] 70)\n  \"_liftDiv\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ div _)\" [71,70] 70)\n  \"_liftMod\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ mod _)\" [71,70] 70)\n  \"_liftLess\"   :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_/ < _)\"  [50, 51] 50)\n  \"_liftLeq\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_/ \\<le> _)\" [50, 51] 50)\n  \"_liftMem\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_/ \\<in> _)\" [50, 51] 50)\n  \"_liftNotMem\" :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_/ \\<notin> _)\" [50, 51] 50)\n  \"_liftFinset\" :: \"liftargs => lift\"                    (\"{(_)}\")\n  (** TODO: syntax for lifted collection / comprehension **)\n  \"_liftPair\"   :: \"[lift,liftargs] \\<Rightarrow> lift\"                   (\"(1'(_,/ _'))\")\n  (* infix syntax for list operations *)\n  \"_liftCons\" :: \"[lift, lift] \\<Rightarrow> lift\"                  (\"(_ #/ _)\" [65,66] 65)\n  \"_liftApp\"  :: \"[lift, lift] \\<Rightarrow> lift\"                  (\"(_ @/ _)\" [65,66] 65)\n  \"_liftList\" :: \"liftargs \\<Rightarrow> lift\"                      (\"[(_)]\")\n\n  (* Rigid quantification (syntax level) *)\n  \"_ARAll\"  :: \"[idts, lift] \\<Rightarrow> lift\"                    (\"(3! _./ _)\" [0, 10] 10)\n  \"_AREx\"   :: \"[idts, lift] \\<Rightarrow> lift\"                    (\"(3? _./ _)\" [0, 10] 10)\n  \"_AREx1\"  :: \"[idts, lift] \\<Rightarrow> lift\"                    (\"(3?! _./ _)\" [0, 10] 10)\n  \"_RAll\"       :: \"[idts, lift] \\<Rightarrow> lift\"                (\"(3\\<forall>_./ _)\" [0, 10] 10)\n  \"_REx\"        :: \"[idts, lift] \\<Rightarrow> lift\"                (\"(3\\<exists>_./ _)\" [0, 10] 10)\n  \"_REx1\"       :: \"[idts, lift] \\<Rightarrow> lift\"                (\"(3\\<exists>!_./ _)\" [0, 10] 10)"], ["", "translations\n  \"_const\"        \\<rightleftharpoons>  \"CONST const\""], ["", "translations\n  \"_lift\"         \\<rightleftharpoons> \"CONST lift\"\n  \"_lift2\"        \\<rightleftharpoons> \"CONST lift2\"\n  \"_lift3\"        \\<rightleftharpoons> \"CONST lift3\"\n  \"_lift4\"        \\<rightleftharpoons> \"CONST lift4\"\n  \"_Valid\"        \\<rightleftharpoons> \"CONST Valid\""], ["", "translations\n  \"_RAll x A\"     \\<rightleftharpoons> \"Rall x. A\"\n  \"_REx x A\"      \\<rightleftharpoons> \"Rex x. A\"\n  \"_REx1 x A\"     \\<rightleftharpoons> \"Rex! x. A\""], ["", "translations\n  \"_ARAll\"        \\<rightharpoonup>  \"_RAll\"\n  \"_AREx\"         \\<rightharpoonup> \"_REx\"\n  \"_AREx1\"        \\<rightharpoonup> \"_REx1\"\n\n  \"w \\<Turnstile> A\"        \\<rightharpoonup> \"A w\"\n  \"LIFT A\"        \\<rightharpoonup> \"A::_\\<Rightarrow>_\""], ["", "translations\n  \"_liftEqu\"      \\<rightleftharpoons> \"_lift2 (=)\"\n  \"_liftNeq u v\"  \\<rightleftharpoons> \"_liftNot (_liftEqu u v)\"\n  \"_liftNot\"      \\<rightleftharpoons> \"_lift (CONST Not)\"\n  \"_liftAnd\"      \\<rightleftharpoons> \"_lift2 (&)\"\n  \"_liftOr\"       \\<rightleftharpoons> \"_lift2 ((|) )\"\n  \"_liftImp\"      \\<rightleftharpoons> \"_lift2 (-->)\"\n  \"_liftIf\"       \\<rightleftharpoons> \"_lift3 (CONST If)\"\n  \"_liftPlus\"     \\<rightleftharpoons> \"_lift2 (+)\"\n  \"_liftMinus\"    \\<rightleftharpoons> \"_lift2 (-)\"\n  \"_liftTimes\"    \\<rightleftharpoons> \"_lift2 (*)\"\n  \"_liftDiv\"      \\<rightleftharpoons> \"_lift2 (div)\"\n \"_liftMod\"      \\<rightleftharpoons> \"_lift2 (mod)\"\n  \"_liftLess\"     \\<rightleftharpoons> \"_lift2 (<)\"\n  \"_liftLeq\"      \\<rightleftharpoons> \"_lift2 (<=)\"\n  \"_liftMem\"      \\<rightleftharpoons> \"_lift2 (:)\"\n  \"_liftNotMem x xs\"             \\<rightleftharpoons> \"_liftNot (_liftMem x xs)\""], ["", "translations\n  \"_liftFinset (_liftargs x xs)\" \\<rightleftharpoons> \"_lift2 (CONST insert) x (_liftFinset xs)\"\n  \"_liftFinset x\"                \\<rightleftharpoons> \"_lift2 (CONST insert) x (_const (CONST Set.empty))\"\n  \"_liftPair x (_liftargs y z)\"  \\<rightleftharpoons> \"_liftPair x (_liftPair y z)\"\n  \"_liftPair\"                    \\<rightleftharpoons> \"_lift2 (CONST Pair)\"\n  \"_liftCons\"                    \\<rightleftharpoons> \"_lift2 (CONST Cons)\"\n  \"_liftApp\"                     \\<rightleftharpoons> \"_lift2 (@)\"\n  \"_liftList (_liftargs x xs)\"   \\<rightleftharpoons> \"_liftCons x (_liftList xs)\"\n  \"_liftList x\"                  \\<rightleftharpoons> \"_liftCons x (_const [])\"\n\n  \"w \\<Turnstile> \\<not> A\" \\<leftharpoondown> \"_liftNot A w\"\n  \"w \\<Turnstile> A \\<and> B\" \\<leftharpoondown> \"_liftAnd A B w\"\n  \"w \\<Turnstile> A \\<or> B\" \\<leftharpoondown> \"_liftOr A B w\"\n  \"w \\<Turnstile> A \\<longrightarrow> B\" \\<leftharpoondown> \"_liftImp A B w\"\n  \"w \\<Turnstile> u = v\" \\<leftharpoondown> \"_liftEqu u v w\"\n  \"w \\<Turnstile> \\<forall>x. A\" \\<leftharpoondown> \"_RAll x A w\"\n  \"w \\<Turnstile> \\<exists>x. A\" \\<leftharpoondown> \"_REx x A w\"\n  \"w \\<Turnstile> \\<exists>!x. A\" \\<leftharpoondown> \"_REx1 x A w\""], ["", "syntax (ASCII)\n  \"_Valid\"      :: \"lift \\<Rightarrow> bool\"                        (\"(|- _)\" 5)\n  \"_holdsAt\"    :: \"['a, lift] \\<Rightarrow> bool\"                  (\"(_ |= _)\" [100,10] 10)\n  \"_liftNeq\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ ~=/ _)\" [50,51] 50)\n  \"_liftNot\"    :: \"lift \\<Rightarrow> lift\"                        (\"(~ _)\" [90] 90)\n  \"_liftAnd\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ &/ _)\" [36,35] 35)\n  \"_liftOr\"     :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ |/ _)\" [31,30] 30)\n  \"_liftImp\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_ -->/ _)\" [26,25] 25)\n  \"_liftLeq\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_/ <= _)\" [50, 51] 50)\n  \"_liftMem\"    :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_/ : _)\" [50, 51] 50)\n  \"_liftNotMem\" :: \"[lift, lift] \\<Rightarrow> lift\"                (\"(_/ ~: _)\" [50, 51] 50)\n  \"_RAll\" :: \"[idts, lift] \\<Rightarrow> lift\"                      (\"(3ALL _./ _)\" [0, 10] 10)\n  \"_REx\"  :: \"[idts, lift] \\<Rightarrow> lift\"                      (\"(3EX _./ _)\" [0, 10] 10)\n  \"_REx1\" :: \"[idts, lift] \\<Rightarrow> lift\"                      (\"(3EX! _./ _)\" [0, 10] 10)"], ["", "subsection \\<open>Lemmas and Tactics\\<close>"], ["", "lemma intD[dest]: \"\\<turnstile> A \\<Longrightarrow> w \\<Turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> A \\<Longrightarrow> A w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> A \\<Longrightarrow> A w", "assume a:\"\\<turnstile> A\""], ["proof (state)\nthis:\n  \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<turnstile> A \\<Longrightarrow> A w", "from a"], ["proof (chain)\npicking this:\n  \\<turnstile> A", "have \"\\<forall>w. w \\<Turnstile> A\""], ["proof (prove)\nusing this:\n  \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<forall>w. A w", "by (auto simp add: Valid_def)"], ["proof (state)\nthis:\n  \\<forall>w. A w\n\ngoal (1 subgoal):\n 1. \\<turnstile> A \\<Longrightarrow> A w", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>w. A w\n\ngoal (1 subgoal):\n 1. A w", ".."], ["proof (state)\nthis:\n  A w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intI [intro!]: assumes P1:\"(\\<And> w. w \\<Turnstile> A)\" shows \"\\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> A", "using assms"], ["proof (prove)\nusing this:\n  A ?w\n\ngoal (1 subgoal):\n 1. \\<turnstile> A", "by (auto simp: Valid_def)"], ["", "text\\<open>\n  Basic unlifting introduces a parameter @{term w} and applies basic rewrites, e.g \n  @{term \"\\<turnstile> F = G\"} becomes @{term \"F w = G w\"} and @{term \"\\<turnstile> F \\<longrightarrow> G\"} becomes   \n  @{term \"F w \\<longrightarrow> G w\"}.\n\\<close>"], ["", "method_setup int_unlift = \\<open>\n  Scan.succeed (fn ctxt => SIMPLE_METHOD'\n    (resolve_tac ctxt @{thms intI} THEN' rewrite_goal_tac ctxt @{thms intensional_rews}))\n\\<close> \"method to unlift and followed by intensional rewrites\""], ["", "lemma inteq_reflection: assumes P1: \"\\<turnstile> x=y\" shows  \"(x \\<equiv> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<equiv> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<equiv> y", "from P1"], ["proof (chain)\npicking this:\n  \\<turnstile> x = y", "have P2: \"\\<forall>w. x w = y w\""], ["proof (prove)\nusing this:\n  \\<turnstile> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>w. x w = y w", "by (unfold Valid_def unl_lift2)"], ["proof (state)\nthis:\n  \\<forall>w. x w = y w\n\ngoal (1 subgoal):\n 1. x \\<equiv> y", "hence P3:\"x=y\""], ["proof (prove)\nusing this:\n  \\<forall>w. x w = y w\n\ngoal (1 subgoal):\n 1. x = y", "by blast"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<equiv> y", "thus \"x \\<equiv> y\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<equiv> y", "by (rule \"eq_reflection\")"], ["proof (state)\nthis:\n  x \\<equiv> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_simps:\n  \"\\<turnstile> (x=x) = #True\"\n  \"\\<turnstile> (\\<not> #True) = #False\"\n  \"\\<turnstile> (\\<not> #False) = #True\"\n  \"\\<turnstile> (\\<not>\\<not> P) = P\"\n  \"\\<turnstile> ((\\<not> P) = P) = #False\"\n  \"\\<turnstile> (P = (\\<not>P)) = #False\"\n  \"\\<turnstile> (P \\<noteq> Q) = (P = (\\<not> Q))\"\n  \"\\<turnstile> (#True=P) = P\"\n  \"\\<turnstile> (P=#True) = P\"\n  \"\\<turnstile> (#True \\<longrightarrow> P) = P\"\n  \"\\<turnstile> (#False \\<longrightarrow> P) = #True\"\n  \"\\<turnstile> (P \\<longrightarrow> #True) = #True\"\n  \"\\<turnstile> (P \\<longrightarrow> P) = #True\"\n  \"\\<turnstile> (P \\<longrightarrow> #False) = (\\<not>P)\"\n  \"\\<turnstile> (P \\<longrightarrow> ~P) = (\\<not>P)\"\n  \"\\<turnstile> (P \\<and> #True) = P\"\n  \"\\<turnstile> (#True \\<and> P) = P\"\n  \"\\<turnstile> (P \\<and> #False) = #False\"\n  \"\\<turnstile> (#False \\<and> P) = #False\"\n  \"\\<turnstile> (P \\<and> P) = P\"\n  \"\\<turnstile> (P \\<and> ~P) = #False\"\n  \"\\<turnstile> (\\<not>P \\<and> P) = #False\"\n  \"\\<turnstile> (P \\<or> #True) = #True\"\n  \"\\<turnstile> (#True \\<or> P) = #True\"\n  \"\\<turnstile> (P \\<or> #False) = P\"\n  \"\\<turnstile> (#False \\<or> P) = P\"\n  \"\\<turnstile> (P \\<or> P) = P\"\n  \"\\<turnstile> (P \\<or> \\<not>P) = #True\"\n  \"\\<turnstile> (\\<not>P \\<or> P) = #True\"\n  \"\\<turnstile> (\\<forall> x. P) = P\"\n  \"\\<turnstile> (\\<exists> x. P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<turnstile> x = x = #True &&&\n       \\<turnstile> \\<not> #True = #False &&&\n       \\<turnstile> \\<not> #False = #True) &&&\n      (\\<turnstile> \\<not> \\<not> P = P &&&\n       \\<turnstile> \\<not> P = P = #False) &&&\n      \\<turnstile> P = \\<not> P = #False &&&\n      \\<turnstile> P \\<noteq> Q = (P = \\<not> Q)) &&&\n     ((\\<turnstile> #True = P = P &&& \\<turnstile> P = #True = P) &&&\n      \\<turnstile> (#True \\<longrightarrow> P) = P &&&\n      \\<turnstile> (#False \\<longrightarrow> P) = #True) &&&\n     (\\<turnstile> (P \\<longrightarrow> #True) = #True &&&\n      \\<turnstile> (P \\<longrightarrow> P) = #True) &&&\n     \\<turnstile> (P \\<longrightarrow> #False) = \\<not> P &&&\n     \\<turnstile> (P \\<longrightarrow> \\<not> P) = \\<not> P) &&&\n    (((\\<turnstile> (P \\<and> #True) = P &&&\n       \\<turnstile> (#True \\<and> P) = P) &&&\n      \\<turnstile> (P \\<and> #False) = #False &&&\n      \\<turnstile> (#False \\<and> P) = #False) &&&\n     (\\<turnstile> (P \\<and> P) = P &&&\n      \\<turnstile> (P \\<and> \\<not> P) = #False) &&&\n     \\<turnstile> (\\<not> P \\<and> P) = #False &&&\n     \\<turnstile> (P \\<or> #True) = #True) &&&\n    ((\\<turnstile> (#True \\<or> P) = #True &&&\n      \\<turnstile> (P \\<or> #False) = P) &&&\n     \\<turnstile> (#False \\<or> P) = P &&& \\<turnstile> (P \\<or> P) = P) &&&\n    (\\<turnstile> (P \\<or> \\<not> P) = #True &&&\n     \\<turnstile> (\\<not> P \\<or> P) = #True) &&&\n    \\<turnstile> (\\<forall>x. P) = P &&& \\<turnstile> (\\<exists>x. P) = P", "by auto"], ["", "lemmas intensional_simps[simp] = int_simps[THEN inteq_reflection]"], ["", "method_setup int_rewrite = \\<open>\n  Scan.succeed (fn ctxt => SIMPLE_METHOD' (rewrite_goal_tac ctxt @{thms intensional_simps}))\n\\<close> \"rewrite method at intensional level\""], ["", "lemma Not_Rall: \"\\<turnstile> (\\<not>(\\<forall> x. F x)) = (\\<exists> x. \\<not>F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<not> (\\<forall>x. F x) = (\\<exists>x. \\<not> F x)", "by auto"], ["", "lemma Not_Rex: \"\\<turnstile> (\\<not>(\\<exists> x. F x)) = (\\<forall> x. \\<not>F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<not> (\\<exists>x. F x) = (\\<forall>x. \\<not> F x)", "by auto"], ["", "lemma TrueW [simp]: \"\\<turnstile> #True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> #True", "by auto"], ["", "lemma int_eq: \"\\<turnstile> X = Y \\<Longrightarrow> X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> X = Y \\<Longrightarrow> X = Y", "by (auto simp: inteq_reflection)"], ["", "lemma int_iffI: \n  assumes \"\\<turnstile> F \\<longrightarrow> G\" and \"\\<turnstile> G \\<longrightarrow> F\"\n  shows \"\\<turnstile> F = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> F = G", "using assms"], ["proof (prove)\nusing this:\n  \\<turnstile> F \\<longrightarrow> G\n  \\<turnstile> G \\<longrightarrow> F\n\ngoal (1 subgoal):\n 1. \\<turnstile> F = G", "by force"], ["", "lemma int_iffD1: assumes h: \"\\<turnstile> F = G\" shows \"\\<turnstile> F \\<longrightarrow> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> F \\<longrightarrow> G", "using h"], ["proof (prove)\nusing this:\n  \\<turnstile> F = G\n\ngoal (1 subgoal):\n 1. \\<turnstile> F \\<longrightarrow> G", "by auto"], ["", "lemma int_iffD2: assumes h: \"\\<turnstile> F = G\" shows \"\\<turnstile> G \\<longrightarrow> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> G \\<longrightarrow> F", "using h"], ["proof (prove)\nusing this:\n  \\<turnstile> F = G\n\ngoal (1 subgoal):\n 1. \\<turnstile> G \\<longrightarrow> F", "by auto"], ["", "lemma lift_imp_trans: \n  assumes \"\\<turnstile> A \\<longrightarrow> B\" and \"\\<turnstile> B \\<longrightarrow> C\"\n  shows \"\\<turnstile> A \\<longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> A \\<longrightarrow> C", "using assms"], ["proof (prove)\nusing this:\n  \\<turnstile> A \\<longrightarrow> B\n  \\<turnstile> B \\<longrightarrow> C\n\ngoal (1 subgoal):\n 1. \\<turnstile> A \\<longrightarrow> C", "by force"], ["", "lemma lift_imp_neg: assumes \"\\<turnstile> A \\<longrightarrow> B\" shows \"\\<turnstile> \\<not>B \\<longrightarrow> \\<not>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<not> B \\<longrightarrow> \\<not> A", "using assms"], ["proof (prove)\nusing this:\n  \\<turnstile> A \\<longrightarrow> B\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<not> B \\<longrightarrow> \\<not> A", "by auto"], ["", "lemma lift_and_com:  \"\\<turnstile> (A \\<and> B) = (B \\<and> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> (A \\<and> B) = (B \\<and> A)", "by auto"], ["", "end"]]}