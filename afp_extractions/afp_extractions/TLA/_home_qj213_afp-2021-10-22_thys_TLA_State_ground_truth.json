{"file_name": "/home/qj213/afp-2021-10-22/thys/TLA/State.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TLA", "problem_names": ["lemma basevars: \"basevars vs \\<Longrightarrow> \\<exists>u. vs u = c\"", "lemma baseE: \n  assumes H1: \"basevars v\" and H2:\"\\<And>x. v x = c \\<Longrightarrow> Q\"\n  shows \"Q\"", "lemma first_baseE:\n  assumes H1: \"basevars v\" and H2: \"\\<And>x. v (first x) = c \\<Longrightarrow> Q\"\n  shows \"Q\"", "lemma base_pair1: \n  assumes h: \"basevars (x,y)\"\n  shows \"basevars x\"", "lemma base_pair2: \n  assumes h: \"basevars (x,y)\"\n  shows \"basevars y\"", "lemma base_pair: \"basevars (x,y) \\<Longrightarrow> basevars x \\<and> basevars y\"", "lemma unit_base: \"basevars (v::state \\<Rightarrow> unit)\"", "lemma\n  fixes x :: \"state \\<Rightarrow> bool\"\n  assumes h1: \"basevars (x,x)\"\n  shows \"False\"", "lemma\n  fixes x :: \"state \\<Rightarrow> nat\"\n  assumes h1: \"basevars (x,x)\"\n  shows \"False\"", "lemma base_enabled:\n  assumes h1: \"basevars vs\"\n  and h2: \"\\<And>u. vs (first u) = c \\<Longrightarrow> ((first s) ## u) \\<Turnstile> F\"\n  shows \"s \\<Turnstile> Enabled F\"", "lemmas eexI_unl = eexI[unlift_rule] \\<comment> \\<open>@{text \"w \\<Turnstile> F x \\<Longrightarrow> w \\<Turnstile> (\\<exists>\\<exists> x. F x)\"}\\<close>", "lemmas tla_defs = unch_def before_def after_def first_def second_def suffix_def \n                  tail_def nexts_def app_def angle_actrans_def actrans_def"], "translations": [["", "lemma basevars: \"basevars vs \\<Longrightarrow> \\<exists>u. vs u = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basevars vs \\<Longrightarrow> \\<exists>u. vs u = c", "proof (unfold basevars_def surj_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = vs x \\<Longrightarrow> \\<exists>u. vs u = c", "assume \"\\<forall>y. \\<exists>x. y = vs x\""], ["proof (state)\nthis:\n  \\<forall>y. \\<exists>x. y = vs x\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = vs x \\<Longrightarrow> \\<exists>u. vs u = c", "then"], ["proof (chain)\npicking this:\n  \\<forall>y. \\<exists>x. y = vs x", "obtain x where \"c = vs x\""], ["proof (prove)\nusing this:\n  \\<forall>y. \\<exists>x. y = vs x\n\ngoal (1 subgoal):\n 1. (\\<And>x. c = vs x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  c = vs x\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = vs x \\<Longrightarrow> \\<exists>u. vs u = c", "thus \"\\<exists>u. vs u = c\""], ["proof (prove)\nusing this:\n  c = vs x\n\ngoal (1 subgoal):\n 1. \\<exists>u. vs u = c", "by blast"], ["proof (state)\nthis:\n  \\<exists>u. vs u = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma baseE: \n  assumes H1: \"basevars v\" and H2:\"\\<And>x. v x = c \\<Longrightarrow> Q\"\n  shows \"Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q", "using H1[THEN basevars] H2"], ["proof (prove)\nusing this:\n  \\<exists>u. v u = ?c\n  v ?x = c \\<Longrightarrow> Q\n\ngoal (1 subgoal):\n 1. Q", "by auto"], ["", "text \\<open>A variant written for sequences rather than single states.\\<close>"], ["", "lemma first_baseE:\n  assumes H1: \"basevars v\" and H2: \"\\<And>x. v (first x) = c \\<Longrightarrow> Q\"\n  shows \"Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q", "using H1[THEN basevars] H2"], ["proof (prove)\nusing this:\n  \\<exists>u. v u = ?c\n  v (first ?x) = c \\<Longrightarrow> Q\n\ngoal (1 subgoal):\n 1. Q", "by (force simp: first_def)"], ["", "lemma base_pair1: \n  assumes h: \"basevars (x,y)\"\n  shows \"basevars x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basevars x", "proof (auto simp: basevars_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> range x", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> range x", "from h[THEN basevars]"], ["proof (chain)\npicking this:\n  \\<exists>u. (x, y) u = ?c", "obtain s where \"(LIFT (x,y)) s = (c, arbitrary)\""], ["proof (prove)\nusing this:\n  \\<exists>u. (x, y) u = ?c\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        (x, y) s = (c, arbitrary) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, y) s = (c, arbitrary)\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> range x", "thus \"c \\<in> range x\""], ["proof (prove)\nusing this:\n  (x, y) s = (c, arbitrary)\n\ngoal (1 subgoal):\n 1. c \\<in> range x", "by auto"], ["proof (state)\nthis:\n  c \\<in> range x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_pair2: \n  assumes h: \"basevars (x,y)\"\n  shows \"basevars y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basevars y", "proof (auto simp: basevars_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> range y", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> range y", "from h[THEN basevars]"], ["proof (chain)\npicking this:\n  \\<exists>u. (x, y) u = ?c", "obtain s where \"(LIFT (x,y)) s = (arbitrary, d)\""], ["proof (prove)\nusing this:\n  \\<exists>u. (x, y) u = ?c\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        (x, y) s = (arbitrary, d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (x, y) s = (arbitrary, d)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> range y", "thus \"d \\<in> range y\""], ["proof (prove)\nusing this:\n  (x, y) s = (arbitrary, d)\n\ngoal (1 subgoal):\n 1. d \\<in> range y", "by auto"], ["proof (state)\nthis:\n  d \\<in> range y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_pair: \"basevars (x,y) \\<Longrightarrow> basevars x \\<and> basevars y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basevars (x, y) \\<Longrightarrow> basevars x \\<and> basevars y", "by (auto elim: base_pair1 base_pair2)"], ["", "text \\<open>\n  Since the @{typ unit} type has just one value, any state function of unit type\n  satisfies the predicate \\<open>basevars\\<close>. The following theorem can sometimes\n  be useful because it gives a trivial solution for \\<open>basevars\\<close> premises.\n\\<close>"], ["", "lemma unit_base: \"basevars (v::state \\<Rightarrow> unit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basevars v", "by (auto simp: basevars_def)"], ["", "text \\<open>\n  A pair of the form \\<open>(x,x)\\<close> will generally not satisfy the predicate\n  \\<open>basevars\\<close> -- except for pathological cases such as \\<open>x::unit\\<close>.\n\\<close>"], ["", "lemma\n  fixes x :: \"state \\<Rightarrow> bool\"\n  assumes h1: \"basevars (x,x)\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from h1"], ["proof (chain)\npicking this:\n  basevars (x, x)", "have \"\\<exists>u. (LIFT (x,x)) u = (False,True)\""], ["proof (prove)\nusing this:\n  basevars (x, x)\n\ngoal (1 subgoal):\n 1. \\<exists>u. (x, x) u = (False, True)", "by (rule basevars)"], ["proof (state)\nthis:\n  \\<exists>u. (x, x) u = (False, True)\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>u. (x, x) u = (False, True)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  fixes x :: \"state \\<Rightarrow> nat\"\n  assumes h1: \"basevars (x,x)\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from h1"], ["proof (chain)\npicking this:\n  basevars (x, x)", "have \"\\<exists>u. (LIFT (x,x)) u = (0,1)\""], ["proof (prove)\nusing this:\n  basevars (x, x)\n\ngoal (1 subgoal):\n 1. \\<exists>u. (x, x) u = (0, 1)", "by (rule basevars)"], ["proof (state)\nthis:\n  \\<exists>u. (x, x) u = (0, 1)\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>u. (x, x) u = (0, 1)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following theorem reduces the reasoning about the existence of a\n  state sequence satisfiyng an enabledness predicate to finding a suitable\n  value \\<open>c\\<close> at the successor state for the base variables of the \n  specification. This rule is intended for reasoning about standard TLA\n  specifications, where \\<open>Enabled\\<close> is applied to actions, not arbitrary\n  pre-formulas.\n\\<close>"], ["", "lemma base_enabled:\n  assumes h1: \"basevars vs\"\n  and h2: \"\\<And>u. vs (first u) = c \\<Longrightarrow> ((first s) ## u) \\<Turnstile> F\"\n  shows \"s \\<Turnstile> Enabled F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Enabled F) s", "using h1"], ["proof (prove)\nusing this:\n  basevars vs\n\ngoal (1 subgoal):\n 1. (Enabled F) s", "proof (rule first_baseE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. vs (first x) = ?c \\<Longrightarrow> (Enabled F) s", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. vs (first x) = ?c \\<Longrightarrow> (Enabled F) s", "assume \"vs (first t) = c\""], ["proof (state)\nthis:\n  vs (first t) = c\n\ngoal (1 subgoal):\n 1. \\<And>x. vs (first x) = ?c \\<Longrightarrow> (Enabled F) s", "hence \"((first s) ## t) \\<Turnstile> F\""], ["proof (prove)\nusing this:\n  vs (first t) = c\n\ngoal (1 subgoal):\n 1. F (first s ## t)", "by (rule h2)"], ["proof (state)\nthis:\n  F (first s ## t)\n\ngoal (1 subgoal):\n 1. \\<And>x. vs (first x) = ?c \\<Longrightarrow> (Enabled F) s", "thus \"s \\<Turnstile> Enabled F\""], ["proof (prove)\nusing this:\n  F (first s ## t)\n\ngoal (1 subgoal):\n 1. (Enabled F) s", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  F (first s ## t)\n\ngoal (1 subgoal):\n 1. \\<exists>t. F (first s ## t)", "by blast"], ["proof (state)\nthis:\n  (Enabled F) s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Temporal Quantifiers\""], ["", "text\\<open>\n  In \\cite{Lamport94}, Lamport gives a stuttering invariant definition\n  of quantification over (flexible) variables. It relies on similarity\n  of two sequences (as supported in our @{theory TLA.Sequence} theory), and\n  equivalence of two sequences up to a variable (the bound variable).\n  However, sequence equaivalence up to a variable, requires state\n  equaivalence up to a variable. Our state representation above does not\n  support this, hence we cannot encode Lamport's definition in our theory.\n  Thus, we need to axiomatise quantification over (flexible) variables.\n  Note that with a state representation supporting this, our theory should\n  allow such an encoding.\n\\<close>"], ["", "consts\n  EEx        :: \"('a statefun \\<Rightarrow> temporal) \\<Rightarrow> temporal\"       (binder \"Eex \" 10)\n  AAll       :: \"('a statefun \\<Rightarrow> temporal) \\<Rightarrow> temporal\"       (binder \"Aall \" 10)"], ["", "syntax\n  \"_EEx\"     :: \"[idts, lift] => lift\"                (\"(3\\<exists>\\<exists> _./ _)\" [0,10] 10)\n  \"_AAll\"    :: \"[idts, lift] => lift\"                (\"(3\\<forall>\\<forall> _./ _)\" [0,10] 10)"], ["", "translations\n  \"_EEx v A\"  ==   \"Eex v. A\"\n  \"_AAll v A\" ==   \"Aall v. A\""], ["", "axiomatization where\n     eexI: \"\\<turnstile> F x \\<longrightarrow> (\\<exists>\\<exists> x. F x)\"\nand  eexE: \"\\<lbrakk>s \\<Turnstile> (\\<exists>\\<exists> x. F x) ; basevars vs; (!! x. \\<lbrakk> basevars (x,vs); s \\<Turnstile> F x \\<rbrakk> \\<Longrightarrow> s \\<Turnstile> G)\\<rbrakk>\n            \\<Longrightarrow> (s \\<Turnstile> G)\"\nand  all_def: \"\\<turnstile> (\\<forall>\\<forall> x. F x) = (\\<not>(\\<exists>\\<exists> x. \\<not>(F x)))\"\nand  eexSTUT: \"STUTINV F x \\<Longrightarrow> STUTINV (\\<exists>\\<exists> x. F x)\"\nand  history: \"\\<turnstile> (I \\<and> \\<box>[A]_v) = (\\<exists>\\<exists> h. ($h = ha) \\<and> I \\<and> \\<box>[A \\<and> h$=hb]_(h,v))\""], ["", "lemmas eexI_unl = eexI[unlift_rule] \\<comment> \\<open>@{text \"w \\<Turnstile> F x \\<Longrightarrow> w \\<Turnstile> (\\<exists>\\<exists> x. F x)\"}\\<close>"], ["", "text \\<open>\n  \\<open>tla_defs\\<close> can be used to unfold TLA definitions into lowest predicate level.\n  This is particularly useful for reasoning about enabledness of formulas.\n\\<close>"], ["", "lemmas tla_defs = unch_def before_def after_def first_def second_def suffix_def \n                  tail_def nexts_def app_def angle_actrans_def actrans_def"], ["", "end"]]}