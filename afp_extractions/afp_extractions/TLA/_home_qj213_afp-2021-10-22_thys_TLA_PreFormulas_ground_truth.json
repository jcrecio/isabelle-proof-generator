{"file_name": "/home/qj213/afp-2021-10-22/thys/TLA/PreFormulas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TLA", "problem_names": ["lemma prefD[dest]: \"|~ A \\<Longrightarrow> w \\<Turnstile> A\"", "lemma prefI[intro!]: \"(\\<And> w. w \\<Turnstile> A) \\<Longrightarrow> |~ A\"", "lemma prefeq_reflection: assumes P1: \"|~ x=y\" shows  \"(x \\<equiv> y)\"", "lemma pref_True[simp]: \"|~ #True\"", "lemma pref_eq: \"|~ X = Y \\<Longrightarrow> X = Y\"", "lemma pref_iffI: \n  assumes \"|~ F \\<longrightarrow> G\" and \"|~ G \\<longrightarrow> F\"\n  shows \"|~ F = G\"", "lemma pref_iffD1: assumes \"|~ F = G\" shows \"|~ F \\<longrightarrow> G\"", "lemma pref_iffD2: assumes \"|~ F = G\" shows \"|~ G \\<longrightarrow> F\"", "lemma unl_pref_imp: \n  assumes \"|~ F \\<longrightarrow> G\" shows \"\\<And> w. w \\<Turnstile> F \\<Longrightarrow> w \\<Turnstile> G\"", "lemma pref_imp_trans:\n  assumes \"|~ F \\<longrightarrow> G\" and \"|~ G \\<longrightarrow> H\"\n  shows \"|~ F \\<longrightarrow> H\"", "lemma pre_id_unch: assumes h: \"stutinv F\"\n  shows \"|~ F \\<and> Unchanged id \\<longrightarrow> \\<circle>F\"", "lemma pre_ex_unch: \n  assumes h: \"stutinv F\"\n  shows \"\\<exists>(v::'a::world \\<Rightarrow> 'a). ( |~ F \\<and> Unchanged v \\<longrightarrow> \\<circle>F)\"", "lemma unch_pair: \"|~ Unchanged (x,y) = (Unchanged x \\<and> Unchanged y)\"", "lemmas unch_eq1 = unch_pair[THEN pref_eq]", "lemmas unch_eq2 = unch_pair[THEN prefeq_reflection]", "lemma angle_actrans_sem: \"|~ \\<langle>F\\<rangle>_v = (F \\<and> v$ \\<noteq> $v)\"", "lemmas angle_actrans_sem_eq = angle_actrans_sem[THEN pref_eq]", "lemma after_const: \"|~ (#c)` = #c\"", "lemma after_fun1: \"|~ f<x>` = f<x`>\"", "lemma after_fun2: \"|~ f<x,y>` = f <x`,y`>\"", "lemma after_fun3: \"|~ f<x,y,z>` = f <x`,y`,z`>\"", "lemma after_fun4: \"|~ f<x,y,z,zz>` = f <x`,y`,z`,zz`>\"", "lemma after_forall: \"|~ (\\<forall> x. P x)` = (\\<forall> x. (P x)`)\"", "lemma after_exists: \"|~ (\\<exists> x. P x)` = (\\<exists> x. (P x)`)\"", "lemma after_exists1: \"|~ (\\<exists>! x. P x)` = (\\<exists>! x. (P x)`)\"", "lemmas all_after = after_const after_fun1 after_fun2 after_fun3 after_fun4\n  after_forall after_exists after_exists1", "lemmas all_after_unl = all_after[THEN prefD]", "lemmas all_after_eq = all_after[THEN prefeq_reflection]", "lemma before_const: \"\\<turnstile> $(#c) = #c\"", "lemma before_fun1: \"\\<turnstile> $(f<x>) = f <$x>\"", "lemma before_fun2: \"\\<turnstile> $(f<x,y>) = f <$x,$y>\"", "lemma before_fun3: \"\\<turnstile> $(f<x,y,z>) = f <$x,$y,$z>\"", "lemma before_fun4: \"\\<turnstile> $(f<x,y,z,zz>) = f <$x,$y,$z,$zz>\"", "lemma before_forall: \"\\<turnstile> $(\\<forall> x. P x) = (\\<forall> x. $(P x))\"", "lemma before_exists: \"\\<turnstile> $(\\<exists> x. P x) = (\\<exists> x. $(P x))\"", "lemma before_exists1: \"\\<turnstile> $(\\<exists>! x. P x) = (\\<exists>! x. $(P x))\"", "lemmas all_before = before_const before_fun1 before_fun2 before_fun3 before_fun4\n  before_forall before_exists before_exists1", "lemmas all_before_unl = all_before[THEN intD]", "lemmas all_before_eq = all_before[THEN inteq_reflection]", "lemma angle_actrans_conj: \"|~ (\\<langle>F \\<and> G\\<rangle>_v) = (\\<langle>F\\<rangle>_v \\<and> \\<langle>G\\<rangle>_v)\"", "lemma angle_actrans_disj: \"|~ (\\<langle>F \\<or> G\\<rangle>_v) = (\\<langle>F\\<rangle>_v \\<or> \\<langle>G\\<rangle>_v)\"", "lemma int_eq_true: \"\\<turnstile> P \\<Longrightarrow> \\<turnstile> P = #True\"", "lemma pref_eq_true: \"|~ P \\<Longrightarrow> |~ P = #True\""], "translations": [["", "lemma prefD[dest]: \"|~ A \\<Longrightarrow> w \\<Turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ A \\<Longrightarrow> A w", "by (simp add: PreValid_def)"], ["", "lemma prefI[intro!]: \"(\\<And> w. w \\<Turnstile> A) \\<Longrightarrow> |~ A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. A w) \\<Longrightarrow> |~ A", "by (simp add: PreValid_def)"], ["", "method_setup pref_unlift = \\<open>\n  Scan.succeed (fn ctxt => SIMPLE_METHOD'\n    (resolve_tac ctxt @{thms prefI} THEN' rewrite_goal_tac ctxt @{thms intensional_rews}))\n\\<close> \"int_unlift for PreFormulas\""], ["", "lemma prefeq_reflection: assumes P1: \"|~ x=y\" shows  \"(x \\<equiv> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<equiv> y", "using P1"], ["proof (prove)\nusing this:\n  |~ x = y\n\ngoal (1 subgoal):\n 1. x \\<equiv> y", "by (intro eq_reflection) force"], ["", "lemma pref_True[simp]: \"|~ #True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ #True", "by auto"], ["", "lemma pref_eq: \"|~ X = Y \\<Longrightarrow> X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ X = Y \\<Longrightarrow> X = Y", "by (auto simp: prefeq_reflection)"], ["", "lemma pref_iffI: \n  assumes \"|~ F \\<longrightarrow> G\" and \"|~ G \\<longrightarrow> F\"\n  shows \"|~ F = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ F = G", "using assms"], ["proof (prove)\nusing this:\n  |~ F \\<longrightarrow> G\n  |~ G \\<longrightarrow> F\n\ngoal (1 subgoal):\n 1. |~ F = G", "by force"], ["", "lemma pref_iffD1: assumes \"|~ F = G\" shows \"|~ F \\<longrightarrow> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ F \\<longrightarrow> G", "using assms"], ["proof (prove)\nusing this:\n  |~ F = G\n\ngoal (1 subgoal):\n 1. |~ F \\<longrightarrow> G", "by auto"], ["", "lemma pref_iffD2: assumes \"|~ F = G\" shows \"|~ G \\<longrightarrow> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ G \\<longrightarrow> F", "using assms"], ["proof (prove)\nusing this:\n  |~ F = G\n\ngoal (1 subgoal):\n 1. |~ G \\<longrightarrow> F", "by auto"], ["", "lemma unl_pref_imp: \n  assumes \"|~ F \\<longrightarrow> G\" shows \"\\<And> w. w \\<Turnstile> F \\<Longrightarrow> w \\<Turnstile> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w. F w \\<Longrightarrow> G w", "using assms"], ["proof (prove)\nusing this:\n  |~ F \\<longrightarrow> G\n\ngoal (1 subgoal):\n 1. \\<And>w. F w \\<Longrightarrow> G w", "by auto"], ["", "lemma pref_imp_trans:\n  assumes \"|~ F \\<longrightarrow> G\" and \"|~ G \\<longrightarrow> H\"\n  shows \"|~ F \\<longrightarrow> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ F \\<longrightarrow> H", "using assms"], ["proof (prove)\nusing this:\n  |~ F \\<longrightarrow> G\n  |~ G \\<longrightarrow> H\n\ngoal (1 subgoal):\n 1. |~ F \\<longrightarrow> H", "by force"], ["", "subsection \"Lemmas about \\<open>Unchanged\\<close>\""], ["", "text \\<open>\n  Many of the \\tlastar{} axioms only require a state function witness\n  which leaves the state space unchanged. An obvious witness is the\n  @{term id} function. The lemmas require that the given formula is\n  invariant under stuttering.\n\\<close>"], ["", "lemma pre_id_unch: assumes h: \"stutinv F\"\n  shows \"|~ F \\<and> Unchanged id \\<longrightarrow> \\<circle>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ F \\<and> Unchanged id \\<longrightarrow> \\<circle>F", "proof (pref_unlift, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>F w; (Unchanged id) w\\<rbrakk>\n       \\<Longrightarrow> (\\<circle>F) w", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>F w; (Unchanged id) w\\<rbrakk>\n       \\<Longrightarrow> (\\<circle>F) w", "assume a1: \"s \\<Turnstile> F\" and  a2: \"s \\<Turnstile> Unchanged id\""], ["proof (state)\nthis:\n  F s\n  (Unchanged id) s\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>F w; (Unchanged id) w\\<rbrakk>\n       \\<Longrightarrow> (\\<circle>F) w", "from a2"], ["proof (chain)\npicking this:\n  (Unchanged id) s", "have \"(id (second s) = id (first s))\""], ["proof (prove)\nusing this:\n  (Unchanged id) s\n\ngoal (1 subgoal):\n 1. id (second s) = id (first s)", "by (simp add: unch_defs)"], ["proof (state)\nthis:\n  id (second s) = id (first s)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>F w; (Unchanged id) w\\<rbrakk>\n       \\<Longrightarrow> (\\<circle>F) w", "hence \"s \\<approx> (tail s)\""], ["proof (prove)\nusing this:\n  id (second s) = id (first s)\n\ngoal (1 subgoal):\n 1. s \\<approx> tail s", "by (simp add: addfirststut)"], ["proof (state)\nthis:\n  s \\<approx> tail s\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>F w; (Unchanged id) w\\<rbrakk>\n       \\<Longrightarrow> (\\<circle>F) w", "with h a1"], ["proof (chain)\npicking this:\n  STUTINV F\n  F s\n  s \\<approx> tail s", "have \"(tail s) \\<Turnstile> F\""], ["proof (prove)\nusing this:\n  STUTINV F\n  F s\n  s \\<approx> tail s\n\ngoal (1 subgoal):\n 1. F (tail s)", "by (simp add: stutinv_def)"], ["proof (state)\nthis:\n  F (tail s)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>F w; (Unchanged id) w\\<rbrakk>\n       \\<Longrightarrow> (\\<circle>F) w", "thus \"s \\<Turnstile> \\<circle>F\""], ["proof (prove)\nusing this:\n  F (tail s)\n\ngoal (1 subgoal):\n 1. (\\<circle>F) s", "by (unfold nexts_def)"], ["proof (state)\nthis:\n  (\\<circle>F) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pre_ex_unch: \n  assumes h: \"stutinv F\"\n  shows \"\\<exists>(v::'a::world \\<Rightarrow> 'a). ( |~ F \\<and> Unchanged v \\<longrightarrow> \\<circle>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. (|~ F \\<and> Unchanged v \\<longrightarrow> \\<circle>F)", "using pre_id_unch[OF h]"], ["proof (prove)\nusing this:\n  |~ F \\<and> Unchanged id \\<longrightarrow> \\<circle>F\n\ngoal (1 subgoal):\n 1. \\<exists>v. (|~ F \\<and> Unchanged v \\<longrightarrow> \\<circle>F)", "by blast"], ["", "lemma unch_pair: \"|~ Unchanged (x,y) = (Unchanged x \\<and> Unchanged y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Unchanged (x, y) = (Unchanged x \\<and> Unchanged y)", "by (auto simp: unch_def before_def after_def nexts_def)"], ["", "lemmas unch_eq1 = unch_pair[THEN pref_eq]"], ["", "lemmas unch_eq2 = unch_pair[THEN prefeq_reflection]"], ["", "lemma angle_actrans_sem: \"|~ \\<langle>F\\<rangle>_v = (F \\<and> v$ \\<noteq> $v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>F\\<rangle>_v = (F \\<and> v$ \\<noteq> $v)", "by (auto simp: angle_actrans_def actrans_def unch_def)"], ["", "lemmas angle_actrans_sem_eq = angle_actrans_sem[THEN pref_eq]"], ["", "subsection \"Lemmas about \\<open>after\\<close>\""], ["", "lemma after_const: \"|~ (#c)` = #c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ #c$ = #c", "by (auto simp: nexts_def before_def after_def)"], ["", "lemma after_fun1: \"|~ f<x>` = f<x`>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ f<x>$ = f<x$>", "by (auto simp: nexts_def before_def after_def)"], ["", "lemma after_fun2: \"|~ f<x,y>` = f <x`,y`>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ f<x, y>$ = f<x$, y$>", "by (auto simp: nexts_def before_def after_def)"], ["", "lemma after_fun3: \"|~ f<x,y,z>` = f <x`,y`,z`>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ f<x, y, z>$ = f<x$, y$, z$>", "by (auto simp: nexts_def before_def after_def)"], ["", "lemma after_fun4: \"|~ f<x,y,z,zz>` = f <x`,y`,z`,zz`>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ f<x, y, z, zz>$ = f<x$, y$, z$, zz$>", "by (auto simp: nexts_def before_def after_def)"], ["", "lemma after_forall: \"|~ (\\<forall> x. P x)` = (\\<forall> x. (P x)`)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ (\\<forall>x. P x)$ = (\\<forall>x. P x$)", "by (auto simp: nexts_def before_def after_def)"], ["", "lemma after_exists: \"|~ (\\<exists> x. P x)` = (\\<exists> x. (P x)`)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ (\\<exists>x. P x)$ = (\\<exists>x. P x$)", "by (auto simp: nexts_def before_def after_def)"], ["", "lemma after_exists1: \"|~ (\\<exists>! x. P x)` = (\\<exists>! x. (P x)`)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ (\\<exists>!x. P x)$ = (\\<exists>!x. P x$)", "by (auto simp: nexts_def before_def after_def)"], ["", "lemmas all_after = after_const after_fun1 after_fun2 after_fun3 after_fun4\n  after_forall after_exists after_exists1"], ["", "lemmas all_after_unl = all_after[THEN prefD]"], ["", "lemmas all_after_eq = all_after[THEN prefeq_reflection]"], ["", "subsection \"Lemmas about \\<open>before\\<close>\""], ["", "lemma before_const: \"\\<turnstile> $(#c) = #c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $#c = #c", "by (auto simp: before_def)"], ["", "lemma before_fun1: \"\\<turnstile> $(f<x>) = f <$x>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $f<x> = f<$x>", "by (auto simp: before_def)"], ["", "lemma before_fun2: \"\\<turnstile> $(f<x,y>) = f <$x,$y>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $f<x, y> = f<$x, $y>", "by (auto simp: before_def)"], ["", "lemma before_fun3: \"\\<turnstile> $(f<x,y,z>) = f <$x,$y,$z>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $f<x, y, z> = f<$x, $y, $z>", "by (auto simp: before_def)"], ["", "lemma before_fun4: \"\\<turnstile> $(f<x,y,z,zz>) = f <$x,$y,$z,$zz>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $f<x, y, z, zz> = f<$x, $y, $z, $zz>", "by (auto simp: before_def)"], ["", "lemma before_forall: \"\\<turnstile> $(\\<forall> x. P x) = (\\<forall> x. $(P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $(\\<forall>x. P x) = (\\<forall>x. $P x)", "by (auto simp: before_def)"], ["", "lemma before_exists: \"\\<turnstile> $(\\<exists> x. P x) = (\\<exists> x. $(P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $(\\<exists>x. P x) = (\\<exists>x. $P x)", "by (auto simp: before_def)"], ["", "lemma before_exists1: \"\\<turnstile> $(\\<exists>! x. P x) = (\\<exists>! x. $(P x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $(\\<exists>!x. P x) = (\\<exists>!x. $P x)", "by (auto simp: before_def)"], ["", "lemmas all_before = before_const before_fun1 before_fun2 before_fun3 before_fun4\n  before_forall before_exists before_exists1"], ["", "lemmas all_before_unl = all_before[THEN intD]"], ["", "lemmas all_before_eq = all_before[THEN inteq_reflection]"], ["", "subsection \"Some general properties\""], ["", "lemma angle_actrans_conj: \"|~ (\\<langle>F \\<and> G\\<rangle>_v) = (\\<langle>F\\<rangle>_v \\<and> \\<langle>G\\<rangle>_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>F \\<and> G\\<rangle>_v =\n       (\\<langle>F\\<rangle>_v \\<and> \\<langle>G\\<rangle>_v)", "by (auto simp: angle_actrans_def actrans_def unch_def)"], ["", "lemma angle_actrans_disj: \"|~ (\\<langle>F \\<or> G\\<rangle>_v) = (\\<langle>F\\<rangle>_v \\<or> \\<langle>G\\<rangle>_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>F \\<or> G\\<rangle>_v =\n       (\\<langle>F\\<rangle>_v \\<or> \\<langle>G\\<rangle>_v)", "by (auto simp: angle_actrans_def actrans_def unch_def)"], ["", "lemma int_eq_true: \"\\<turnstile> P \\<Longrightarrow> \\<turnstile> P = #True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> P \\<Longrightarrow> \\<turnstile> P = #True", "by auto"], ["", "lemma pref_eq_true: \"|~ P \\<Longrightarrow> |~ P = #True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ P \\<Longrightarrow> |~ P = #True", "by auto"], ["", "subsection \"Unlifting attributes and methods\""], ["", "text \\<open>Attribute which unlifts an intensional formula or preformula\\<close>"], ["", "ML \\<open>\nfun unl_rewr ctxt thm = \n    let\n       val unl = (thm RS @{thm intD}) handle THM _ => (thm RS @{thm prefD})\n                                      handle THM _ => thm\n       val rewr = rewrite_rule ctxt @{thms intensional_rews} \n     in\n       unl |> rewr\n     end;\n\\<close>"], ["", "attribute_setup unlifted = \\<open>\n  Scan.succeed (Thm.rule_attribute [] (unl_rewr o Context.proof_of))\n\\<close> \"unlift intensional formulas\""], ["", "attribute_setup unlift_rule = \\<open>\n  Scan.succeed\n    (Thm.rule_attribute []\n      (Context.proof_of #> (fn ctxt => Object_Logic.rulify ctxt o unl_rewr ctxt)))\n\\<close> \"unlift and rulify intensional formulas\""], ["", "text \\<open>\n  Attribute which turns an intensional formula or preformula into a rewrite rule.\n  Formulas \\<open>F\\<close> that are not equalities are turned into \\<open>F \\<equiv> #True\\<close>.\n\\<close>"], ["", "ML \\<open>\nfun int_rewr thm = \n   (thm RS @{thm inteq_reflection})\n     handle THM _ => (thm RS @{thm prefeq_reflection})\n     handle THM _ => ((thm RS @{thm int_eq_true}) RS @{thm inteq_reflection})\n     handle THM _ => ((thm RS @{thm pref_eq_true}) RS @{thm prefeq_reflection});\n\\<close>"], ["", "attribute_setup simp_unl = \\<open>\n    Attrib.add_del\n      (Thm.declaration_attribute\n        (fn th => Simplifier.map_ss (Simplifier.add_simp (int_rewr th))))\n      (K (NONE, NONE))  (* note only adding -- removing is ignored *)\n\\<close> \"add thm unlifted from rewrites from intensional formulas or preformulas\""], ["", "attribute_setup int_rewrite = \\<open>Scan.succeed (Thm.rule_attribute [] (fn _ => int_rewr))\\<close>\n  \"produce rewrites from intensional formulas or preformulas\""], ["", "end"]]}