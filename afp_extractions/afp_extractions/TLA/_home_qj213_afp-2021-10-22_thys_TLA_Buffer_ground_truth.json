{"file_name": "/home/qj213/afp-2021-10-22/thys/TLA/Buffer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TLA", "problem_names": ["lemmas buffer_defs = BInit_def Enq_def Deq_def Nxt_def \n                     ISpec_def Spec_def BInv_def", "lemma ISpec_stutinv: \"STUTINV (ISpec ic q oc)\"", "lemma Spec_stutinv: \"STUTINV Spec ic oc\"", "lemma tl_self_iff_empty[simp]: \"(tl xs = xs) = (xs = [])\"", "lemma tl_self_iff_empty'[simp]: \"(xs = tl xs) = (xs = [])\"", "lemma Deq_visible:\n  assumes v: \"\\<turnstile> Unchanged v \\<longrightarrow> Unchanged q\"\n  shows \"|~ <Deq ic q oc>_v = Deq ic q oc\"", "lemma Deq_enabledE: \"\\<turnstile> Enabled <Deq ic q oc>_(ic,q,oc) \\<longrightarrow> $q ~= #[]\"", "lemma noreps_empty [simp]: \"noreps []\"", "lemma noreps_singleton: \"noreps [x]\"  \\<comment> \\<open>special case of following lemma\\<close>", "lemma noreps_cons [simp]:\n  \"noreps (x # xs) = (noreps xs \\<and> (xs = [] \\<or> x \\<noteq> hd xs))\"", "lemma noreps_append [simp]:\n  \"noreps (xs @ ys) = \n   (noreps xs \\<and> noreps ys \\<and> (xs = [] \\<or> ys = [] \\<or> List.last xs \\<noteq> hd ys))\"", "lemma ISpec_BInv_lemma:\n  \"\\<turnstile> BInit ic q oc \\<and> \\<box>[Nxt ic q oc]_(ic,q,oc) \\<longrightarrow> \\<box>(BInv ic q oc)\"", "theorem ISpec_BInv: \"\\<turnstile> ISpec ic q oc \\<longrightarrow> \\<box>(BInv ic q oc)\"", "lemmas db_defs = buffer_defs DBSpec_def FullInit_def FullNxt_def FullSpec_def\n                   qc_def vars_def", "lemma DBSpec_stutinv: \"STUTINV DBSpec\"", "lemma FullSpec_stutinv: \"STUTINV FullSpec\"", "lemma DBNxt_then_FullNxt:\n    \"\\<turnstile> \\<box>BInv inp q1 mid\n        \\<and> \\<box>[Nxt inp q1 mid]_(inp,q1,mid) \n        \\<and> \\<box>[Nxt mid q2 out]_(mid,q2,out)\n        \\<and> \\<box>[\\<not>(Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\n        \\<longrightarrow> \\<box>[FullNxt]_vars\"\n    (is \"\\<turnstile> \\<box>?inv \\<and> ?nxts \\<longrightarrow> \\<box>[FullNxt]_vars\")", "theorem DBSpec_impl_FullSpec: \"\\<turnstile> DBSpec \\<longrightarrow> FullSpec\"", "lemma FullInit: \"\\<turnstile> FullInit \\<longrightarrow> BInit inp qc out\"", "lemma Full_step_simulation:\n    \"|~ [FullNxt]_vars \\<longrightarrow> [Nxt inp qc out]_(inp,qc,out)\"", "lemma Deq1_enabled: \"\\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars = ($q1 \\<noteq> #[])\"", "lemma Deq2_enabled: \"\\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars = ($q2 \\<noteq> #[])\"", "lemma Full_fairness:\n    \"\\<turnstile> \\<box>[FullNxt]_vars \\<and> WF(Deq mid q2 out)_vars \\<and> \\<box>WF(Deq inp q1 mid)_vars\n       \\<longrightarrow> WF(Deq inp qc out)_(inp,qc,out)\"", "theorem FullSpec_impl_ISpec: \"\\<turnstile> FullSpec \\<longrightarrow> ISpec inp qc out\"", "theorem FullSpec_impl_Spec: \"\\<turnstile> FullSpec \\<longrightarrow> Spec inp out\"", "theorem DBSpec_impl_Spec: \"\\<turnstile> DBSpec \\<longrightarrow> Spec inp out\""], "translations": [["", "lemmas buffer_defs = BInit_def Enq_def Deq_def Nxt_def \n                     ISpec_def Spec_def BInv_def"], ["", "lemma ISpec_stutinv: \"STUTINV (ISpec ic q oc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV ISpec ic q oc", "unfolding buffer_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV (($q = #[] \\<and> $ic = $oc) \\<and>\n             \\<box>[ic$ \\<noteq> $ic \\<and>\n                    q$ = $q @ [ic$] \\<and> oc$ = $oc \\<or>\n                    #0 < length<$q> \\<and>\n                    oc$ = hd<$q> \\<and>\n                    q$ = tl<$q> \\<and> ic$ = $ic]_(ic, q, oc) \\<and>\n             WF(#0 < length<$q> \\<and>\n                oc$ = hd<$q> \\<and>\n                q$ = tl<$q> \\<and> ic$ = $ic)_(ic, q, oc))", "by (simp add: bothstutinvs livestutinv)"], ["", "lemma Spec_stutinv: \"STUTINV Spec ic oc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV Spec ic oc", "unfolding buffer_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV (\\<exists>\\<exists> q.\n                ($q = #[] \\<and> $ic = $oc) \\<and>\n                \\<box>[ic$ \\<noteq> $ic \\<and>\n                       q$ = $q @ [ic$] \\<and> oc$ = $oc \\<or>\n                       #0 < length<$q> \\<and>\n                       oc$ = hd<$q> \\<and>\n                       q$ = tl<$q> \\<and> ic$ = $ic]_(ic, q, oc) \\<and>\n                WF(#0 < length<$q> \\<and>\n                   oc$ = hd<$q> \\<and>\n                   q$ = tl<$q> \\<and> ic$ = $ic)_(ic, q, oc))", "by (simp add: bothstutinvs livestutinv eexSTUT)"], ["", "text \\<open>A lemma about lists that is useful in the following\\<close>"], ["", "lemma tl_self_iff_empty[simp]: \"(tl xs = xs) = (xs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tl xs = xs) = (xs = [])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. tl xs = xs \\<Longrightarrow> xs = []\n 2. xs = [] \\<Longrightarrow> tl xs = xs", "assume 1: \"tl xs = xs\""], ["proof (state)\nthis:\n  tl xs = xs\n\ngoal (2 subgoals):\n 1. tl xs = xs \\<Longrightarrow> xs = []\n 2. xs = [] \\<Longrightarrow> tl xs = xs", "show \"xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "assume \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "with 1"], ["proof (chain)\npicking this:\n  tl xs = xs\n  xs \\<noteq> []", "show \"False\""], ["proof (prove)\nusing this:\n  tl xs = xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = []\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> tl xs = xs", "qed (auto)"], ["", "lemma tl_self_iff_empty'[simp]: \"(xs = tl xs) = (xs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = tl xs) = (xs = [])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = tl xs \\<Longrightarrow> xs = []\n 2. xs = [] \\<Longrightarrow> xs = tl xs", "assume 1: \"xs = tl xs\""], ["proof (state)\nthis:\n  xs = tl xs\n\ngoal (2 subgoals):\n 1. xs = tl xs \\<Longrightarrow> xs = []\n 2. xs = [] \\<Longrightarrow> xs = tl xs", "show \"xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "assume \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "with 1"], ["proof (chain)\npicking this:\n  xs = tl xs\n  xs \\<noteq> []", "show \"False\""], ["proof (prove)\nusing this:\n  xs = tl xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = []\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow> xs = tl xs", "qed (auto)"], ["", "lemma Deq_visible:\n  assumes v: \"\\<turnstile> Unchanged v \\<longrightarrow> Unchanged q\"\n  shows \"|~ <Deq ic q oc>_v = Deq ic q oc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>Deq ic q oc\\<rangle>_v = Deq ic q oc", "proof (auto simp: tla_defs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>Deq ic q oc w; v (w (Suc 0)) = v (w 0)\\<rbrakk>\n       \\<Longrightarrow> False", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>Deq ic q oc w; v (w (Suc 0)) = v (w 0)\\<rbrakk>\n       \\<Longrightarrow> False", "assume deq: \"w \\<Turnstile> Deq ic q oc\" and unch: \"v (w (Suc 0)) = v (w 0)\""], ["proof (state)\nthis:\n  Deq ic q oc w\n  v (w (Suc 0)) = v (w 0)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>Deq ic q oc w; v (w (Suc 0)) = v (w 0)\\<rbrakk>\n       \\<Longrightarrow> False", "from unch v[unlifted]"], ["proof (chain)\npicking this:\n  v (w (Suc 0)) = v (w 0)\n  (Unchanged v) ?w \\<longrightarrow> (Unchanged q) ?w", "have \"q (w (Suc 0)) = q (w 0)\""], ["proof (prove)\nusing this:\n  v (w (Suc 0)) = v (w 0)\n  (Unchanged v) ?w \\<longrightarrow> (Unchanged q) ?w\n\ngoal (1 subgoal):\n 1. q (w (Suc 0)) = q (w 0)", "by (auto simp: tla_defs)"], ["proof (state)\nthis:\n  q (w (Suc 0)) = q (w 0)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>Deq ic q oc w; v (w (Suc 0)) = v (w 0)\\<rbrakk>\n       \\<Longrightarrow> False", "with deq"], ["proof (chain)\npicking this:\n  Deq ic q oc w\n  q (w (Suc 0)) = q (w 0)", "show \"False\""], ["proof (prove)\nusing this:\n  Deq ic q oc w\n  q (w (Suc 0)) = q (w 0)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: Deq_def tla_defs)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Deq_enabledE: \"\\<turnstile> Enabled <Deq ic q oc>_(ic,q,oc) \\<longrightarrow> $q ~= #[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq ic q\n                                   oc\\<rangle>_(ic, q, oc) \\<longrightarrow>\n                 $q \\<noteq> #[]", "by (auto elim!: enabledE simp: Deq_def tla_defs)"], ["", "text \\<open>\n  We now prove that \\<open>BInv\\<close> is an invariant of the Buffer\n  specification.\n\n  We need several lemmas about \\<open>noreps\\<close> that are used in the\n  invariant proof.\n\\<close>"], ["", "lemma noreps_empty [simp]: \"noreps []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps []", "by (auto simp: noreps_def)"], ["", "lemma noreps_singleton: \"noreps [x]\"  \\<comment> \\<open>special case of following lemma\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps [x]", "by (auto simp: noreps_def)"], ["", "lemma noreps_cons [simp]:\n  \"noreps (x # xs) = (noreps xs \\<and> (xs = [] \\<or> x \\<noteq> hd xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps (x # xs) = (noreps xs \\<and> (xs = [] \\<or> x \\<noteq> hd xs))", "proof (auto simp: noreps_singleton)"], ["proof (state)\ngoal (3 subgoals):\n 1. noreps (x # xs) \\<Longrightarrow> noreps xs\n 2. \\<lbrakk>noreps (hd xs # xs); xs \\<noteq> []; x = hd xs\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "assume cons: \"noreps (x # xs)\""], ["proof (state)\nthis:\n  noreps (x # xs)\n\ngoal (3 subgoals):\n 1. noreps (x # xs) \\<Longrightarrow> noreps xs\n 2. \\<lbrakk>noreps (hd xs # xs); xs \\<noteq> []; x = hd xs\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "show \"noreps xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps xs", "proof (auto simp: noreps_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "assume i: \"i < length xs - Suc 0\" and eq: \"xs!i = xs!(Suc i)\""], ["proof (state)\nthis:\n  i < length xs - Suc 0\n  xs ! i = xs ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < length xs - Suc 0", "have \"Suc i < length (x#xs) - 1\""], ["proof (prove)\nusing this:\n  i < length xs - Suc 0\n\ngoal (1 subgoal):\n 1. Suc i < length (x # xs) - 1", "by auto"], ["proof (state)\nthis:\n  Suc i < length (x # xs) - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Suc i < length (x # xs) - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "from eq"], ["proof (chain)\npicking this:\n  xs ! i = xs ! Suc i", "have \"(x#xs)!(Suc i) = (x#xs)!(Suc (Suc i))\""], ["proof (prove)\nusing this:\n  xs ! i = xs ! Suc i\n\ngoal (1 subgoal):\n 1. (x # xs) ! Suc i = (x # xs) ! Suc (Suc i)", "by auto"], ["proof (state)\nthis:\n  (x # xs) ! Suc i = (x # xs) ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (x # xs) ! Suc i = (x # xs) ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "note cons"], ["proof (state)\nthis:\n  noreps (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Suc i < length (x # xs) - 1\n  (x # xs) ! Suc i = (x # xs) ! Suc (Suc i)\n  noreps (x # xs)", "show False"], ["proof (prove)\nusing this:\n  Suc i < length (x # xs) - 1\n  (x # xs) ! Suc i = (x # xs) ! Suc (Suc i)\n  noreps (x # xs)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noreps xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (hd xs # xs); xs \\<noteq> []; x = hd xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (hd xs # xs); xs \\<noteq> []; x = hd xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "assume 1: \"noreps (hd xs # xs)\" and 2: \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  noreps (hd xs # xs)\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (hd xs # xs); xs \\<noteq> []; x = hd xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "from 2"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain x xxs where \"xs = x # xxs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xxs. xs = x # xxs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs = x # xxs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (hd xs # xs); xs \\<noteq> []; x = hd xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "with 1"], ["proof (chain)\npicking this:\n  noreps (hd xs # xs)\n  xs = x # xxs", "show False"], ["proof (prove)\nusing this:\n  noreps (hd xs # xs)\n  xs = x # xxs\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "assume 1: \"noreps xs\" and 2: \"x \\<noteq> hd xs\""], ["proof (state)\nthis:\n  noreps xs\n  x \\<noteq> hd xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>noreps xs; x \\<noteq> hd xs\\<rbrakk>\n    \\<Longrightarrow> noreps (x # xs)", "show \"noreps (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps (x # xs)", "proof (auto simp: noreps_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs; (x # xs) ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs; (x # xs) ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> False", "assume i: \"i < length xs\" and eq: \"(x # xs)!i = xs!i\""], ["proof (state)\nthis:\n  i < length xs\n  (x # xs) ! i = xs ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs; (x # xs) ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < length xs", "obtain y ys where xs: \"xs = y # ys\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs; (x # xs) ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "assume \"i = 0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with eq 2 xs"], ["proof (chain)\npicking this:\n  (x # xs) ! i = xs ! i\n  x \\<noteq> hd xs\n  xs = y # ys\n  i = 0", "show False"], ["proof (prove)\nusing this:\n  (x # xs) ! i = xs ! i\n  x \\<noteq> hd xs\n  xs = y # ys\n  i = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "assume k: \"i = Suc k\""], ["proof (state)\nthis:\n  i = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with i eq xs 1"], ["proof (chain)\npicking this:\n  i < length xs\n  (x # xs) ! i = xs ! i\n  xs = y # ys\n  noreps xs\n  i = Suc k", "show False"], ["proof (prove)\nusing this:\n  i < length xs\n  (x # xs) ! i = xs ! i\n  xs = y # ys\n  noreps xs\n  i = Suc k\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noreps (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma noreps_append [simp]:\n  \"noreps (xs @ ys) = \n   (noreps xs \\<and> noreps ys \\<and> (xs = [] \\<or> ys = [] \\<or> List.last xs \\<noteq> hd ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps (xs @ ys) =\n    (noreps xs \\<and>\n     noreps ys \\<and>\n     (xs = [] \\<or> ys = [] \\<or> List.last xs \\<noteq> hd ys))", "proof auto"], ["proof (state)\ngoal (4 subgoals):\n 1. noreps (xs @ ys) \\<Longrightarrow> noreps xs\n 2. noreps (xs @ ys) \\<Longrightarrow> noreps ys\n 3. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "assume 1: \"noreps (xs @ ys)\""], ["proof (state)\nthis:\n  noreps (xs @ ys)\n\ngoal (4 subgoals):\n 1. noreps (xs @ ys) \\<Longrightarrow> noreps xs\n 2. noreps (xs @ ys) \\<Longrightarrow> noreps ys\n 3. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "show \"noreps xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps xs", "proof (auto simp: noreps_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "assume i: \"i < length xs - Suc 0\" and eq: \"xs!i = xs!(Suc i)\""], ["proof (state)\nthis:\n  i < length xs - Suc 0\n  xs ! i = xs ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < length xs - Suc 0", "have \"i < length (xs @ ys) - Suc 0\""], ["proof (prove)\nusing this:\n  i < length xs - Suc 0\n\ngoal (1 subgoal):\n 1. i < length (xs @ ys) - Suc 0", "by auto"], ["proof (state)\nthis:\n  i < length (xs @ ys) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i < length (xs @ ys) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "from i eq"], ["proof (chain)\npicking this:\n  i < length xs - Suc 0\n  xs ! i = xs ! Suc i", "have \"(xs @ ys)!i = (xs@ys)!(Suc i)\""], ["proof (prove)\nusing this:\n  i < length xs - Suc 0\n  xs ! i = xs ! Suc i\n\ngoal (1 subgoal):\n 1. (xs @ ys) ! i = (xs @ ys) ! Suc i", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "note 1"], ["proof (state)\nthis:\n  noreps (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs - Suc 0; xs ! i = xs ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i < length (xs @ ys) - Suc 0\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n  noreps (xs @ ys)", "show \"False\""], ["proof (prove)\nusing this:\n  i < length (xs @ ys) - Suc 0\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n  noreps (xs @ ys)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noreps xs\n\ngoal (3 subgoals):\n 1. noreps (xs @ ys) \\<Longrightarrow> noreps ys\n 2. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. noreps (xs @ ys) \\<Longrightarrow> noreps ys\n 2. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "assume 1: \"noreps (xs @ ys)\""], ["proof (state)\nthis:\n  noreps (xs @ ys)\n\ngoal (3 subgoals):\n 1. noreps (xs @ ys) \\<Longrightarrow> noreps ys\n 2. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "show \"noreps ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps ys", "proof (auto simp: noreps_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "assume i: \"i < length ys - Suc 0\" and eq: \"ys!i = ys!(Suc i)\""], ["proof (state)\nthis:\n  i < length ys - Suc 0\n  ys ! i = ys ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  i < length ys - Suc 0", "have \"i + length xs < length (xs @ ys) - Suc 0\""], ["proof (prove)\nusing this:\n  i < length ys - Suc 0\n\ngoal (1 subgoal):\n 1. i + length xs < length (xs @ ys) - Suc 0", "by auto"], ["proof (state)\nthis:\n  i + length xs < length (xs @ ys) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i + length xs < length (xs @ ys) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "from i eq"], ["proof (chain)\npicking this:\n  i < length ys - Suc 0\n  ys ! i = ys ! Suc i", "have \"(xs @ ys)!(i+length xs) = (xs@ys)!(Suc (i + length xs))\""], ["proof (prove)\nusing this:\n  i < length ys - Suc 0\n  ys ! i = ys ! Suc i\n\ngoal (1 subgoal):\n 1. (xs @ ys) ! (i + length xs) = (xs @ ys) ! Suc (i + length xs)", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (xs @ ys) ! (i + length xs) = (xs @ ys) ! Suc (i + length xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (xs @ ys) ! (i + length xs) = (xs @ ys) ! Suc (i + length xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "note 1"], ["proof (state)\nthis:\n  noreps (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length ys - Suc 0; ys ! i = ys ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i + length xs < length (xs @ ys) - Suc 0\n  (xs @ ys) ! (i + length xs) = (xs @ ys) ! Suc (i + length xs)\n  noreps (xs @ ys)", "show \"False\""], ["proof (prove)\nusing this:\n  i + length xs < length (xs @ ys) - Suc 0\n  (xs @ ys) ! (i + length xs) = (xs @ ys) ! Suc (i + length xs)\n  noreps (xs @ ys)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noreps ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "assume 1: \"noreps (xs @ ys)\" and 2: \"xs \\<noteq> []\" and 3: \"ys \\<noteq> []\"\n     and 4: \"List.last xs = hd ys\""], ["proof (state)\nthis:\n  noreps (xs @ ys)\n  xs \\<noteq> []\n  ys \\<noteq> []\n  List.last xs = hd ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "from 2"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain x xxs where xs: \"xs = x # xxs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xxs. xs = x # xxs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs = x # xxs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "from 3"], ["proof (chain)\npicking this:\n  ys \\<noteq> []", "obtain y yys where ys: \"ys = y # yys\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y yys. ys = y # yys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ys, auto)"], ["proof (state)\nthis:\n  ys = y # yys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "from xs ys"], ["proof (chain)\npicking this:\n  xs = x # xxs\n  ys = y # yys", "have 5: \"length xxs < length (xs @ ys) - 1\""], ["proof (prove)\nusing this:\n  xs = x # xxs\n  ys = y # yys\n\ngoal (1 subgoal):\n 1. length xxs < length (xs @ ys) - 1", "by auto"], ["proof (state)\nthis:\n  length xxs < length (xs @ ys) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "from 4 xs ys"], ["proof (chain)\npicking this:\n  List.last xs = hd ys\n  xs = x # xxs\n  ys = y # yys", "have \"(xs @ ys) ! (length xxs) = (xs @ ys) ! (Suc (length xxs))\""], ["proof (prove)\nusing this:\n  List.last xs = hd ys\n  xs = x # xxs\n  ys = y # yys\n\ngoal (1 subgoal):\n 1. (xs @ ys) ! length xxs = (xs @ ys) ! Suc (length xxs)", "by (auto simp: nth_append last_conv_nth)"], ["proof (state)\nthis:\n  (xs @ ys) ! length xxs = (xs @ ys) ! Suc (length xxs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>noreps (xs @ ys); xs \\<noteq> []; ys \\<noteq> [];\n     List.last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "with 5 1"], ["proof (chain)\npicking this:\n  length xxs < length (xs @ ys) - 1\n  noreps (xs @ ys)\n  (xs @ ys) ! length xxs = (xs @ ys) ! Suc (length xxs)", "show \"False\""], ["proof (prove)\nusing this:\n  length xxs < length (xs @ ys) - 1\n  noreps (xs @ ys)\n  (xs @ ys) ! length xxs = (xs @ ys) ! Suc (length xxs)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "assume 1: \"noreps xs\" and 2: \"noreps ys\" and 3: \"List.last xs \\<noteq> hd ys\""], ["proof (state)\nthis:\n  noreps xs\n  noreps ys\n  List.last xs \\<noteq> hd ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>noreps xs; noreps ys; List.last xs \\<noteq> hd ys\\<rbrakk>\n    \\<Longrightarrow> noreps (xs @ ys)", "show \"noreps (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps (xs @ ys)", "proof (cases \"xs = [] \\<or> ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<or> ys = [] \\<Longrightarrow> noreps (xs @ ys)\n 2. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> noreps (xs @ ys)", "case True"], ["proof (state)\nthis:\n  xs = [] \\<or> ys = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<or> ys = [] \\<Longrightarrow> noreps (xs @ ys)\n 2. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> noreps (xs @ ys)", "with 1 2"], ["proof (chain)\npicking this:\n  noreps xs\n  noreps ys\n  xs = [] \\<or> ys = []", "show ?thesis"], ["proof (prove)\nusing this:\n  noreps xs\n  noreps ys\n  xs = [] \\<or> ys = []\n\ngoal (1 subgoal):\n 1. noreps (xs @ ys)", "by auto"], ["proof (state)\nthis:\n  noreps (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> noreps (xs @ ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> noreps (xs @ ys)", "case False"], ["proof (state)\nthis:\n  \\<not> (xs = [] \\<or> ys = [])\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> noreps (xs @ ys)", "then"], ["proof (chain)\npicking this:\n  \\<not> (xs = [] \\<or> ys = [])", "obtain x xxs where xs: \"xs = x # xxs\""], ["proof (prove)\nusing this:\n  \\<not> (xs = [] \\<or> ys = [])\n\ngoal (1 subgoal):\n 1. (\\<And>x xxs. xs = x # xxs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs = x # xxs\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> noreps (xs @ ys)", "from False"], ["proof (chain)\npicking this:\n  \\<not> (xs = [] \\<or> ys = [])", "obtain y yys where ys: \"ys = y # yys\""], ["proof (prove)\nusing this:\n  \\<not> (xs = [] \\<or> ys = [])\n\ngoal (1 subgoal):\n 1. (\\<And>y yys. ys = y # yys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ys, auto)"], ["proof (state)\nthis:\n  ys = y # yys\n\ngoal (1 subgoal):\n 1. \\<not> (xs = [] \\<or> ys = []) \\<Longrightarrow> noreps (xs @ ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. noreps (xs @ ys)", "proof (auto simp: noreps_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs + length ys - Suc 0;\n        (xs @ ys) ! i = (xs @ ys) ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs + length ys - Suc 0;\n        (xs @ ys) ! i = (xs @ ys) ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "assume i: \"i < length xs + length ys - Suc 0\"\n         and eq: \"(xs @ ys)!i = (xs @ ys)!(Suc i)\""], ["proof (state)\nthis:\n  i < length xs + length ys - Suc 0\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs + length ys - Suc 0;\n        (xs @ ys) ! i = (xs @ ys) ! Suc i\\<rbrakk>\n       \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"i < length xxs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length xxs \\<Longrightarrow> False\n 2. \\<not> i < length xxs \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  i < length xxs\n\ngoal (2 subgoals):\n 1. i < length xxs \\<Longrightarrow> False\n 2. \\<not> i < length xxs \\<Longrightarrow> False", "hence \"i < length (x # xxs)\""], ["proof (prove)\nusing this:\n  i < length xxs\n\ngoal (1 subgoal):\n 1. i < length (x # xxs)", "by simp"], ["proof (state)\nthis:\n  i < length (x # xxs)\n\ngoal (2 subgoals):\n 1. i < length xxs \\<Longrightarrow> False\n 2. \\<not> i < length xxs \\<Longrightarrow> False", "hence xsi: \"((x # xxs) @ ys)!i = (x # xxs)!i\""], ["proof (prove)\nusing this:\n  i < length (x # xxs)\n\ngoal (1 subgoal):\n 1. ((x # xxs) @ ys) ! i = (x # xxs) ! i", "unfolding nth_append"], ["proof (prove)\nusing this:\n  i < length (x # xxs)\n\ngoal (1 subgoal):\n 1. (if i < length (x # xxs) then (x # xxs) ! i\n     else ys ! (i - length (x # xxs))) =\n    (x # xxs) ! i", "by simp"], ["proof (state)\nthis:\n  ((x # xxs) @ ys) ! i = (x # xxs) ! i\n\ngoal (2 subgoals):\n 1. i < length xxs \\<Longrightarrow> False\n 2. \\<not> i < length xxs \\<Longrightarrow> False", "from True"], ["proof (chain)\npicking this:\n  i < length xxs", "have \"(xxs @ ys)!i = xxs!i\""], ["proof (prove)\nusing this:\n  i < length xxs\n\ngoal (1 subgoal):\n 1. (xxs @ ys) ! i = xxs ! i", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (xxs @ ys) ! i = xxs ! i\n\ngoal (2 subgoals):\n 1. i < length xxs \\<Longrightarrow> False\n 2. \\<not> i < length xxs \\<Longrightarrow> False", "with True xsi eq 1 xs"], ["proof (chain)\npicking this:\n  i < length xxs\n  ((x # xxs) @ ys) ! i = (x # xxs) ! i\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n  noreps xs\n  xs = x # xxs\n  (xxs @ ys) ! i = xxs ! i", "show \"False\""], ["proof (prove)\nusing this:\n  i < length xxs\n  ((x # xxs) @ ys) ! i = (x # xxs) ! i\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n  noreps xs\n  xs = x # xxs\n  (xxs @ ys) ! i = xxs ! i\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> i < length xxs \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length xxs \\<Longrightarrow> False", "assume i2: \"\\<not>(i < length xxs)\""], ["proof (state)\nthis:\n  \\<not> i < length xxs\n\ngoal (1 subgoal):\n 1. \\<not> i < length xxs \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"i = length xxs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = length xxs \\<Longrightarrow> False\n 2. i \\<noteq> length xxs \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  i = length xxs\n\ngoal (2 subgoals):\n 1. i = length xxs \\<Longrightarrow> False\n 2. i \\<noteq> length xxs \\<Longrightarrow> False", "with xs"], ["proof (chain)\npicking this:\n  xs = x # xxs\n  i = length xxs", "have xsi: \"(xs @ ys)!i = List.last xs\""], ["proof (prove)\nusing this:\n  xs = x # xxs\n  i = length xxs\n\ngoal (1 subgoal):\n 1. (xs @ ys) ! i = List.last xs", "by (auto simp: nth_append last_conv_nth)"], ["proof (state)\nthis:\n  (xs @ ys) ! i = List.last xs\n\ngoal (2 subgoals):\n 1. i = length xxs \\<Longrightarrow> False\n 2. i \\<noteq> length xxs \\<Longrightarrow> False", "from True xs ys"], ["proof (chain)\npicking this:\n  i = length xxs\n  xs = x # xxs\n  ys = y # yys", "have \"(xs @ ys)!(Suc i) = y\""], ["proof (prove)\nusing this:\n  i = length xxs\n  xs = x # xxs\n  ys = y # yys\n\ngoal (1 subgoal):\n 1. (xs @ ys) ! Suc i = y", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (xs @ ys) ! Suc i = y\n\ngoal (2 subgoals):\n 1. i = length xxs \\<Longrightarrow> False\n 2. i \\<noteq> length xxs \\<Longrightarrow> False", "with 3 ys eq xsi"], ["proof (chain)\npicking this:\n  List.last xs \\<noteq> hd ys\n  ys = y # yys\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n  (xs @ ys) ! i = List.last xs\n  (xs @ ys) ! Suc i = y", "show False"], ["proof (prove)\nusing this:\n  List.last xs \\<noteq> hd ys\n  ys = y # yys\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n  (xs @ ys) ! i = List.last xs\n  (xs @ ys) ! Suc i = y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  i \\<noteq> length xxs\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "with i2 xs"], ["proof (chain)\npicking this:\n  \\<not> i < length xxs\n  xs = x # xxs\n  i \\<noteq> length xxs", "have xsi: \"\\<not>(i < length xs)\""], ["proof (prove)\nusing this:\n  \\<not> i < length xxs\n  xs = x # xxs\n  i \\<noteq> length xxs\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs", "by auto"], ["proof (state)\nthis:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "hence \"(xs @ ys)!i = ys!(i - length xs)\""], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. (xs @ ys) ! i = ys ! (i - length xs)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (xs @ ys) ! i = ys ! (i - length xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (xs @ ys) ! i = ys ! (i - length xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "from xsi"], ["proof (chain)\npicking this:\n  \\<not> i < length xs", "have \"Suc i - length xs = Suc (i - length xs)\""], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. Suc i - length xs = Suc (i - length xs)", "by auto"], ["proof (state)\nthis:\n  Suc i - length xs = Suc (i - length xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "with xsi"], ["proof (chain)\npicking this:\n  \\<not> i < length xs\n  Suc i - length xs = Suc (i - length xs)", "have \"(xs @ ys)!(Suc i) = ys!(Suc (i - length xs))\""], ["proof (prove)\nusing this:\n  \\<not> i < length xs\n  Suc i - length xs = Suc (i - length xs)\n\ngoal (1 subgoal):\n 1. (xs @ ys) ! Suc i = ys ! Suc (i - length xs)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (xs @ ys) ! Suc i = ys ! Suc (i - length xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (xs @ ys) ! Suc i = ys ! Suc (i - length xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "from i xsi"], ["proof (chain)\npicking this:\n  i < length xs + length ys - Suc 0\n  \\<not> i < length xs", "have \"i - length xs < length ys - 1\""], ["proof (prove)\nusing this:\n  i < length xs + length ys - Suc 0\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. i - length xs < length ys - 1", "by auto"], ["proof (state)\nthis:\n  i - length xs < length ys - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "with 2"], ["proof (chain)\npicking this:\n  noreps ys\n  i - length xs < length ys - 1", "have \"ys!(i - length xs) \\<noteq> ys!(Suc (i - length xs))\""], ["proof (prove)\nusing this:\n  noreps ys\n  i - length xs < length ys - 1\n\ngoal (1 subgoal):\n 1. ys ! (i - length xs) \\<noteq> ys ! Suc (i - length xs)", "by (auto simp: noreps_def)"], ["proof (state)\nthis:\n  ys ! (i - length xs) \\<noteq> ys ! Suc (i - length xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ys ! (i - length xs) \\<noteq> ys ! Suc (i - length xs)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "note eq"], ["proof (state)\nthis:\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n\ngoal (1 subgoal):\n 1. i \\<noteq> length xxs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (xs @ ys) ! i = ys ! (i - length xs)\n  (xs @ ys) ! Suc i = ys ! Suc (i - length xs)\n  ys ! (i - length xs) \\<noteq> ys ! Suc (i - length xs)\n  (xs @ ys) ! i = (xs @ ys) ! Suc i", "show False"], ["proof (prove)\nusing this:\n  (xs @ ys) ! i = ys ! (i - length xs)\n  (xs @ ys) ! Suc i = ys ! Suc (i - length xs)\n  ys ! (i - length xs) \\<noteq> ys ! Suc (i - length xs)\n  (xs @ ys) ! i = (xs @ ys) ! Suc i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noreps (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  noreps (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ISpec_BInv_lemma:\n  \"\\<turnstile> BInit ic q oc \\<and> \\<box>[Nxt ic q oc]_(ic,q,oc) \\<longrightarrow> \\<box>(BInv ic q oc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> BInit ic q oc \\<and>\n                 \\<box>[Nxt ic q oc]_(ic, q, oc) \\<longrightarrow>\n                 \\<box>BInv ic q oc", "proof (rule invmono)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<turnstile> BInit ic q oc \\<longrightarrow> BInv ic q oc\n 2. |~ BInv ic q oc \\<and>\n       _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n       \\<circle>BInv ic q oc", "show \"\\<turnstile> BInit ic q oc \\<longrightarrow> BInv ic q oc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> BInit ic q oc \\<longrightarrow> BInv ic q oc", "by (auto simp: BInit_def BInv_def)"], ["proof (state)\nthis:\n  \\<turnstile> BInit ic q oc \\<longrightarrow> BInv ic q oc\n\ngoal (1 subgoal):\n 1. |~ BInv ic q oc \\<and>\n       _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n       \\<circle>BInv ic q oc", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. |~ BInv ic q oc \\<and>\n       _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n       \\<circle>BInv ic q oc", "have enq: \"|~ Enq ic q oc \\<longrightarrow> BInv ic q oc \\<longrightarrow> \\<circle>(BInv ic q oc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Enq ic q oc \\<longrightarrow>\n       BInv ic q oc \\<longrightarrow> \\<circle>BInv ic q oc", "by (auto simp: Enq_def BInv_def tla_defs)"], ["proof (state)\nthis:\n  |~ Enq ic q oc \\<longrightarrow>\n     BInv ic q oc \\<longrightarrow> \\<circle>BInv ic q oc\n\ngoal (1 subgoal):\n 1. |~ BInv ic q oc \\<and>\n       _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n       \\<circle>BInv ic q oc", "have deq: \"|~ Deq ic q oc \\<longrightarrow> BInv ic q oc \\<longrightarrow> \\<circle>(BInv ic q oc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Deq ic q oc \\<longrightarrow>\n       BInv ic q oc \\<longrightarrow> \\<circle>BInv ic q oc", "by (auto simp: Deq_def BInv_def tla_defs neq_Nil_conv)"], ["proof (state)\nthis:\n  |~ Deq ic q oc \\<longrightarrow>\n     BInv ic q oc \\<longrightarrow> \\<circle>BInv ic q oc\n\ngoal (1 subgoal):\n 1. |~ BInv ic q oc \\<and>\n       _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n       \\<circle>BInv ic q oc", "have unch: \"|~ Unchanged (ic,q,oc) \\<longrightarrow> BInv ic q oc \\<longrightarrow> \\<circle>(BInv ic q oc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Unchanged (ic, q, oc) \\<longrightarrow>\n       BInv ic q oc \\<longrightarrow> \\<circle>BInv ic q oc", "by (auto simp: BInv_def tla_defs)"], ["proof (state)\nthis:\n  |~ Unchanged (ic, q, oc) \\<longrightarrow>\n     BInv ic q oc \\<longrightarrow> \\<circle>BInv ic q oc\n\ngoal (1 subgoal):\n 1. |~ BInv ic q oc \\<and>\n       _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n       \\<circle>BInv ic q oc", "show \"|~ BInv ic q oc \\<and> [Nxt ic q oc]_(ic, q, oc) \\<longrightarrow> \\<circle>(BInv ic q oc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ BInv ic q oc \\<and>\n       _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n       \\<circle>BInv ic q oc", "by (auto simp: Nxt_def actrans_def \n             elim: enq[unlift_rule] deq[unlift_rule] unch[unlift_rule])"], ["proof (state)\nthis:\n  |~ BInv ic q oc \\<and>\n     _actrans (Nxt ic q oc) (ic, q, oc) \\<longrightarrow>\n     \\<circle>BInv ic q oc\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ISpec_BInv: \"\\<turnstile> ISpec ic q oc \\<longrightarrow> \\<box>(BInv ic q oc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> ISpec ic q oc \\<longrightarrow> \\<box>BInv ic q oc", "by (auto simp: ISpec_def intro: ISpec_BInv_lemma[unlift_rule])"], ["", "subsection \"Two FIFO buffers in a row implement a buffer\""], ["", "locale DBuffer =\n  fixes inp :: \"'a statefun\"       \\<comment> \\<open>input channel for double FIFO\\<close>\n    and mid :: \"'a statefun\"       \\<comment> \\<open>channel linking the two buffers\\<close>\n    and out :: \"'a statefun\"       \\<comment> \\<open>output channel for double FIFO\\<close>\n    and q1  :: \"'a list statefun\"  \\<comment> \\<open>inner queue of first FIFO\\<close>\n    and q2  :: \"'a list statefun\"  \\<comment> \\<open>inner queue of second FIFO\\<close>\n    and vars\n  defines \"vars \\<equiv> LIFT (inp,mid,out,q1,q2)\"\n  assumes DB_base: \"basevars vars\"\nbegin"], ["", "text \\<open>\n    We need to specify the behavior of two FIFO buffers in a row.\n    Intuitively, that specification is just the conjunction of\n    two buffer specifications, where the first buffer has input\n    channel \\<open>inp\\<close> and output channel \\<open>mid\\<close> whereas\n    the second one receives from \\<open>mid\\<close> and outputs on \\<open>out\\<close>.\n    However, this conjunction allows a simultaneous enqueue action\n    of the first buffer and dequeue of the second one. It would not\n    implement the previous buffer specification, which excludes such\n    simultaneous enqueueing and dequeueing (it is written in\n    ``interleaving style''). We could relax the specification of\n    the FIFO buffer above, which is esthetically pleasant, but\n    non-interleaving specifications are usually hard to get right\n    and to understand. We therefore impose an interleaving constraint\n    on the specification of the double buffer, which requires that\n    enqueueing and dequeueing do not happen simultaneously.\n\\<close>"], ["", "definition DBSpec\n  where \"DBSpec \\<equiv> TEMP ISpec inp q1 mid\n                     \\<and> ISpec mid q2 out\n                     \\<and> \\<box>[\\<not>(Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\""], ["", "text \\<open>\n    The proof rules of TLA are geared towards specifications of the\n    form \\<open>Init \\<and> \\<box>[Next]_vars \\<and> L\\<close>, and we prove that\n    \\<open>DBSpec\\<close> corresponds to a specification in this form,\n    which we now define.\n\\<close>"], ["", "definition FullInit\n  where \"FullInit \\<equiv> TEMP (BInit inp q1 mid \\<and> BInit mid q2 out)\""], ["", "definition FullNxt\n  where \"FullNxt \\<equiv> TEMP (Enq inp q1 mid \\<and> Unchanged (q2,out)\n                       \\<or> Deq inp q1 mid \\<and> Enq mid q2 out\n                       \\<or> Deq mid q2 out \\<and> Unchanged (inp,q1))\""], ["", "definition FullSpec\n  where \"FullSpec \\<equiv> TEMP FullInit\n                       \\<and> \\<box>[FullNxt]_vars\n                       \\<and> WF(Deq inp q1 mid)_vars\n                       \\<and> WF(Deq mid q2 out)_vars\""], ["", "text \\<open>\n    The concatenation of the two queues will serve as the refinement mapping.\n\\<close>"], ["", "definition qc :: \"'a list statefun\"\n  where \"qc \\<equiv> LIFT (q2 @ q1)\""], ["", "lemmas db_defs = buffer_defs DBSpec_def FullInit_def FullNxt_def FullSpec_def\n                   qc_def vars_def"], ["", "lemma DBSpec_stutinv: \"STUTINV DBSpec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV DBSpec", "unfolding db_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV ((($q1 = #[] \\<and> $inp = $mid) \\<and>\n              \\<box>[inp$ \\<noteq> $inp \\<and>\n                     q1$ = $q1 @ [inp$] \\<and> mid$ = $mid \\<or>\n                     #0 < length<$q1> \\<and>\n                     mid$ = hd<$q1> \\<and>\n                     q1$ = tl<$q1> \\<and> inp$ = $inp]_(inp, q1, mid) \\<and>\n              WF(#0 < length<$q1> \\<and>\n                 mid$ = hd<$q1> \\<and>\n                 q1$ = tl<$q1> \\<and> inp$ = $inp)_(inp, q1, mid)) \\<and>\n             (($q2 = #[] \\<and> $mid = $out) \\<and>\n              \\<box>[mid$ \\<noteq> $mid \\<and>\n                     q2$ = $q2 @ [mid$] \\<and> out$ = $out \\<or>\n                     #0 < length<$q2> \\<and>\n                     out$ = hd<$q2> \\<and>\n                     q2$ = tl<$q2> \\<and> mid$ = $mid]_(mid, q2, out) \\<and>\n              WF(#0 < length<$q2> \\<and>\n                 out$ = hd<$q2> \\<and>\n                 q2$ = tl<$q2> \\<and> mid$ = $mid)_(mid, q2, out)) \\<and>\n             \\<box>[\\<not> ((inp$ \\<noteq> $inp \\<and>\n                             q1$ = $q1 @ [inp$] \\<and> mid$ = $mid) \\<and>\n                            #0 < length<$q2> \\<and>\n                            out$ = hd<$q2> \\<and>\n                            q2$ = tl<$q2> \\<and>\n                            mid$ = $mid)]_(inp, mid, out, q1, q2))", "by (simp add: bothstutinvs livestutinv)"], ["", "lemma FullSpec_stutinv: \"STUTINV FullSpec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV FullSpec", "unfolding db_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. STUTINV ((($q1 = #[] \\<and> $inp = $mid) \\<and>\n              $q2 = #[] \\<and> $mid = $out) \\<and>\n             \\<box>[(inp$ \\<noteq> $inp \\<and>\n                     q1$ = $q1 @ [inp$] \\<and> mid$ = $mid) \\<and>\n                    Unchanged (q2, out) \\<or>\n                    (#0 < length<$q1> \\<and>\n                     mid$ = hd<$q1> \\<and>\n                     q1$ = tl<$q1> \\<and> inp$ = $inp) \\<and>\n                    mid$ \\<noteq> $mid \\<and>\n                    q2$ = $q2 @ [mid$] \\<and> out$ = $out \\<or>\n                    (#0 < length<$q2> \\<and>\n                     out$ = hd<$q2> \\<and>\n                     q2$ = tl<$q2> \\<and> mid$ = $mid) \\<and>\n                    Unchanged (inp, q1)]_(inp, mid, out, q1, q2) \\<and>\n             WF(#0 < length<$q1> \\<and>\n                mid$ = hd<$q1> \\<and>\n                q1$ = tl<$q1> \\<and>\n                inp$ = $inp)_(inp, mid, out, q1, q2) \\<and>\n             WF(#0 < length<$q2> \\<and>\n                out$ = hd<$q2> \\<and>\n                q2$ = tl<$q2> \\<and> mid$ = $mid)_(inp, mid, out, q1, q2))", "by (simp add: bothstutinvs livestutinv)"], ["", "text \\<open>\n    We prove that \\<open>DBSpec\\<close> implies \\<open>FullSpec\\<close>. (The converse\n    implication also holds but is not needed for our implementation proof.)\n\\<close>"], ["", "text \\<open>\n    The following lemma is somewhat more bureaucratic than we'd like\n    it to be. It shows that the conjunction of the next-state relations,\n    together with the invariant for the first queue, implies the full\n    next-state relation of the combined queues.\n\\<close>"], ["", "lemma DBNxt_then_FullNxt:\n    \"\\<turnstile> \\<box>BInv inp q1 mid\n        \\<and> \\<box>[Nxt inp q1 mid]_(inp,q1,mid) \n        \\<and> \\<box>[Nxt mid q2 out]_(mid,q2,out)\n        \\<and> \\<box>[\\<not>(Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\n        \\<longrightarrow> \\<box>[FullNxt]_vars\"\n    (is \"\\<turnstile> \\<box>?inv \\<and> ?nxts \\<longrightarrow> \\<box>[FullNxt]_vars\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "have \"\\<turnstile> \\<box>[Nxt inp q1 mid]_(inp,q1,mid)\n          \\<and> \\<box>[Nxt mid q2 out]_(mid,q2,out)\n          \\<longrightarrow> \\<box>[  [Nxt inp q1 mid]_(inp,q1,mid) \n               \\<and> [Nxt mid q2 out]_(mid,q2,out)]_((inp,q1,mid),(mid,q2,out))\"\n      (is \"\\<turnstile> ?tmp \\<longrightarrow> \\<box>[?b1b2]_?vs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n                 \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                        _actrans (Nxt mid q2 out)\n                         (mid, q2, out)]_((inp, q1, mid), mid, q2, out)", "by (auto simp: M12[int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out)\n                       (mid, q2, out)]_((inp, q1, mid), mid, q2, out)\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "moreover"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out)\n                       (mid, q2, out)]_((inp, q1, mid), mid, q2, out)\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "have \"\\<turnstile> \\<box>[?b1b2]_?vs \\<longrightarrow> \\<box>[?b1b2]_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                        _actrans (Nxt mid q2 out)\n                         (mid, q2,\n                          out)]_((inp, q1, mid), mid, q2,\n                                 out) \\<longrightarrow>\n                 \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                        _actrans (Nxt mid q2 out) (mid, q2, out)]_vars", "by (rule R1, auto simp: vars_def tla_defs)"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out)\n                       (mid, q2,\n                        out)]_((inp, q1, mid), mid, q2,\n                               out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out)\n                       (mid, q2, out)]_((inp, q1, mid), mid, q2, out)\n  \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out)\n                       (mid, q2,\n                        out)]_((inp, q1, mid), mid, q2,\n                               out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars", "have 1: \"\\<turnstile> \\<box>[Nxt inp q1 mid]_(inp,q1,mid)\n             \\<and> \\<box>[Nxt mid q2 out]_(mid,q2,out)\n             \\<longrightarrow> \\<box>[  [Nxt inp q1 mid]_(inp,q1,mid) \n                   \\<and> [Nxt mid q2 out]_(mid,q2,out) ]_vars\""], ["proof (prove)\nusing this:\n  \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out)\n                       (mid, q2, out)]_((inp, q1, mid), mid, q2, out)\n  \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out)\n                       (mid, q2,\n                        out)]_((inp, q1, mid), mid, q2,\n                               out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n                 \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                        _actrans (Nxt mid q2 out) (mid, q2, out)]_vars", "by force"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "have 2: \"\\<turnstile> \\<box>[?b1b2]_vars \\<and> \\<box>[\\<not>(Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\n               \\<longrightarrow> \\<box>[?b1b2 \\<and> \\<not>(Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\"\n      (is \"\\<turnstile> ?tmp2 \\<longrightarrow> \\<box>[?mid]_vars\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                        _actrans (Nxt mid q2 out)\n                         (mid, q2, out)]_vars \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                         _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                        \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out)]_vars", "by (simp add: M8[int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars \\<and>\n               \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                              Deq mid q2 out)]_vars \\<longrightarrow>\n               \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                       _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                      \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "have \"\\<turnstile> ?inv \\<longrightarrow> #True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> BInv inp q1 mid \\<longrightarrow> #True", "by auto"], ["proof (state)\nthis:\n  \\<turnstile> BInv inp q1 mid \\<longrightarrow> #True\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "moreover"], ["proof (state)\nthis:\n  \\<turnstile> BInv inp q1 mid \\<longrightarrow> #True\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "have \"|~ ?inv \\<and> \\<circle>?inv \\<and> [?mid]_vars \\<longrightarrow> [FullNxt]_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       \\<circle>BInv inp q1 mid \\<and>\n       _actrans\n        ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n          _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n         \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n        vars \\<longrightarrow>\n       _actrans FullNxt vars", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       \\<circle>BInv inp q1 mid \\<and>\n       _actrans\n        ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n          _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n         \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n        vars \\<longrightarrow>\n       _actrans FullNxt vars", "have \"|~ ?inv \\<and> ?mid \\<longrightarrow> [FullNxt]_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       _actrans FullNxt vars", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       _actrans FullNxt vars", "have A: \"|~ Nxt inp q1 mid\n                    \\<longrightarrow> [Nxt mid q2 out]_(mid,q2,out)\n                    \\<longrightarrow> \\<not>(Enq inp q1 mid \\<and> Deq mid q2 out)\n                    \\<longrightarrow> ?inv\n                    \\<longrightarrow> FullNxt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Nxt inp q1 mid \\<longrightarrow>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> FullNxt", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. |~ Nxt inp q1 mid \\<longrightarrow>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> FullNxt", "have enq: \"|~ Enq inp q1 mid\n                        \\<and> [Nxt mid q2 out]_(mid,q2,out)\n                        \\<and> \\<not>(Deq mid q2 out)\n                        \\<longrightarrow> Unchanged (q2,out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Enq inp q1 mid \\<and>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n       \\<not> Deq mid q2 out \\<longrightarrow>\n       Unchanged (q2, out)", "by (auto simp: db_defs tla_defs)"], ["proof (state)\nthis:\n  |~ Enq inp q1 mid \\<and>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n     \\<not> Deq mid q2 out \\<longrightarrow>\n     Unchanged (q2, out)\n\ngoal (1 subgoal):\n 1. |~ Nxt inp q1 mid \\<longrightarrow>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> FullNxt", "have deq1: \"|~ Deq inp q1 mid \\<longrightarrow> ?inv \\<longrightarrow> mid$ \\<noteq> $mid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Deq inp q1 mid \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> mid$ \\<noteq> $mid", "by (auto simp: Deq_def BInv_def)"], ["proof (state)\nthis:\n  |~ Deq inp q1 mid \\<longrightarrow>\n     BInv inp q1 mid \\<longrightarrow> mid$ \\<noteq> $mid\n\ngoal (1 subgoal):\n 1. |~ Nxt inp q1 mid \\<longrightarrow>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> FullNxt", "have deq2: \"|~ Deq mid q2 out \\<longrightarrow> mid$ = $mid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Deq mid q2 out \\<longrightarrow> mid$ = $mid", "by (auto simp: Deq_def)"], ["proof (state)\nthis:\n  |~ Deq mid q2 out \\<longrightarrow> mid$ = $mid\n\ngoal (1 subgoal):\n 1. |~ Nxt inp q1 mid \\<longrightarrow>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> FullNxt", "have deq: \"|~ Deq inp q1 mid\n                        \\<and> [Nxt mid q2 out]_(mid,q2,out)\n                        \\<and> ?inv\n                        \\<longrightarrow> Enq mid q2 out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Deq inp q1 mid \\<and>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n       BInv inp q1 mid \\<longrightarrow>\n       Enq mid q2 out", "by (force simp: Nxt_def tla_defs\n                      dest: deq1[unlift_rule] deq2[unlift_rule])"], ["proof (state)\nthis:\n  |~ Deq inp q1 mid \\<and>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n     BInv inp q1 mid \\<longrightarrow>\n     Enq mid q2 out\n\ngoal (1 subgoal):\n 1. |~ Nxt inp q1 mid \\<longrightarrow>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> FullNxt", "with enq"], ["proof (chain)\npicking this:\n  |~ Enq inp q1 mid \\<and>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n     \\<not> Deq mid q2 out \\<longrightarrow>\n     Unchanged (q2, out)\n  |~ Deq inp q1 mid \\<and>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n     BInv inp q1 mid \\<longrightarrow>\n     Enq mid q2 out", "show ?thesis"], ["proof (prove)\nusing this:\n  |~ Enq inp q1 mid \\<and>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n     \\<not> Deq mid q2 out \\<longrightarrow>\n     Unchanged (q2, out)\n  |~ Deq inp q1 mid \\<and>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<and>\n     BInv inp q1 mid \\<longrightarrow>\n     Enq mid q2 out\n\ngoal (1 subgoal):\n 1. |~ Nxt inp q1 mid \\<longrightarrow>\n       _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       BInv inp q1 mid \\<longrightarrow> FullNxt", "by (force simp: Nxt_def FullNxt_def)"], ["proof (state)\nthis:\n  |~ Nxt inp q1 mid \\<longrightarrow>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n     \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n     BInv inp q1 mid \\<longrightarrow> FullNxt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |~ Nxt inp q1 mid \\<longrightarrow>\n     _actrans (Nxt mid q2 out) (mid, q2, out) \\<longrightarrow>\n     \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n     BInv inp q1 mid \\<longrightarrow> FullNxt\n\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       _actrans FullNxt vars", "have B: \"|~ Nxt mid q2 out\n                    \\<longrightarrow> Unchanged (inp,q1,mid)\n                    \\<longrightarrow> FullNxt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ Nxt mid q2 out \\<longrightarrow>\n       Unchanged (inp, q1, mid) \\<longrightarrow> FullNxt", "by (auto simp: db_defs tla_defs)"], ["proof (state)\nthis:\n  |~ Nxt mid q2 out \\<longrightarrow>\n     Unchanged (inp, q1, mid) \\<longrightarrow> FullNxt\n\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       _actrans FullNxt vars", "have C: \"\\<turnstile> Unchanged (inp,q1,mid) \n                \\<longrightarrow> Unchanged (mid,q2,out)\n                \\<longrightarrow> Unchanged vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Unchanged (inp, q1, mid) \\<longrightarrow>\n                 Unchanged (mid, q2, out) \\<longrightarrow> Unchanged vars", "by (auto simp: vars_def tla_defs)"], ["proof (state)\nthis:\n  \\<turnstile> Unchanged (inp, q1, mid) \\<longrightarrow>\n               Unchanged (mid, q2, out) \\<longrightarrow> Unchanged vars\n\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       _actrans FullNxt vars", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n       _actrans FullNxt vars", "by (force simp: actrans_def \n                    dest: A[unlift_rule] B[unlift_rule] C[unlift_rule])"], ["proof (state)\nthis:\n  |~ BInv inp q1 mid \\<and>\n     (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n      _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n     \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n     _actrans FullNxt vars\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |~ BInv inp q1 mid \\<and>\n     (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n      _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n     \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n     _actrans FullNxt vars\n\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       \\<circle>BInv inp q1 mid \\<and>\n       _actrans\n        ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n          _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n         \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n        vars \\<longrightarrow>\n       _actrans FullNxt vars", "thus ?thesis"], ["proof (prove)\nusing this:\n  |~ BInv inp q1 mid \\<and>\n     (_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n      _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n     \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out) \\<longrightarrow>\n     _actrans FullNxt vars\n\ngoal (1 subgoal):\n 1. |~ BInv inp q1 mid \\<and>\n       \\<circle>BInv inp q1 mid \\<and>\n       _actrans\n        ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n          _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n         \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n        vars \\<longrightarrow>\n       _actrans FullNxt vars", "by (auto simp: tla_defs)"], ["proof (state)\nthis:\n  |~ BInv inp q1 mid \\<and>\n     \\<circle>BInv inp q1 mid \\<and>\n     _actrans\n      ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n      vars \\<longrightarrow>\n     _actrans FullNxt vars\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |~ BInv inp q1 mid \\<and>\n     \\<circle>BInv inp q1 mid \\<and>\n     _actrans\n      ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n      vars \\<longrightarrow>\n     _actrans FullNxt vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile> BInv inp q1 mid \\<longrightarrow> #True\n  |~ BInv inp q1 mid \\<and>\n     \\<circle>BInv inp q1 mid \\<and>\n     _actrans\n      ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n      vars \\<longrightarrow>\n     _actrans FullNxt vars", "have \"\\<turnstile> \\<box>?inv \\<and> \\<box>[?mid]_vars \\<longrightarrow> \\<box>#True \\<and> \\<box>[FullNxt]_vars\""], ["proof (prove)\nusing this:\n  \\<turnstile> BInv inp q1 mid \\<longrightarrow> #True\n  |~ BInv inp q1 mid \\<and>\n     \\<circle>BInv inp q1 mid \\<and>\n     _actrans\n      ((_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n        _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n       \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out))\n      vars \\<longrightarrow>\n     _actrans FullNxt vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                         _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                        \\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>#True \\<and> \\<box>[FullNxt]_vars", "by (rule TLA2)"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n               \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                       _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                      \\<not> (Enq inp q1 mid \\<and>\n                              Deq mid q2 out)]_vars \\<longrightarrow>\n               \\<box>#True \\<and> \\<box>[FullNxt]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "with 1 2"], ["proof (chain)\npicking this:\n  \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars\n  \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars \\<and>\n               \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                              Deq mid q2 out)]_vars \\<longrightarrow>\n               \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                       _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                      \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\n  \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n               \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                       _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                      \\<not> (Enq inp q1 mid \\<and>\n                              Deq mid q2 out)]_vars \\<longrightarrow>\n               \\<box>#True \\<and> \\<box>[FullNxt]_vars", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile> \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<longrightarrow>\n               \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars\n  \\<turnstile> \\<box>[_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                      _actrans (Nxt mid q2 out) (mid, q2, out)]_vars \\<and>\n               \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                              Deq mid q2 out)]_vars \\<longrightarrow>\n               \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                       _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                      \\<not> (Enq inp q1 mid \\<and> Deq mid q2 out)]_vars\n  \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n               \\<box>[(_actrans (Nxt inp q1 mid) (inp, q1, mid) \\<and>\n                       _actrans (Nxt mid q2 out) (mid, q2, out)) \\<and>\n                      \\<not> (Enq inp q1 mid \\<and>\n                              Deq mid q2 out)]_vars \\<longrightarrow>\n               \\<box>#True \\<and> \\<box>[FullNxt]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n                 \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n                 \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n                 \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                                Deq mid q2 out)]_vars \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "by force"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>BInv inp q1 mid \\<and>\n               \\<box>[Nxt inp q1 mid]_(inp, q1, mid) \\<and>\n               \\<box>[Nxt mid q2 out]_(mid, q2, out) \\<and>\n               \\<box>[\\<not> (Enq inp q1 mid \\<and>\n                              Deq mid q2 out)]_vars \\<longrightarrow>\n               \\<box>[FullNxt]_vars\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    It is now easy to show that \\<open>DBSpec\\<close> refines \\<open>FullSpec\\<close>.\n\\<close>"], ["", "theorem DBSpec_impl_FullSpec: \"\\<turnstile> DBSpec \\<longrightarrow> FullSpec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullSpec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullSpec", "have 1: \"\\<turnstile> DBSpec \\<longrightarrow> FullInit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullInit", "by (auto simp: DBSpec_def FullInit_def ISpec_def)"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> FullInit\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullSpec", "have 2: \"\\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars", "have \"\\<turnstile> DBSpec \\<longrightarrow> \\<box>(BInv inp q1 mid)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> \\<box>BInv inp q1 mid", "by (auto simp: DBSpec_def intro: ISpec_BInv[unlift_rule])"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> \\<box>BInv inp q1 mid\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars", "moreover"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> \\<box>BInv inp q1 mid\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars", "have \"\\<turnstile> DBSpec \\<and> \\<box>(BInv inp q1 mid) \\<longrightarrow> \\<box>[FullNxt]_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<and> \\<box>BInv inp q1 mid \\<longrightarrow>\n                 \\<box>[FullNxt]_vars", "by (auto simp: DBSpec_def ISpec_def\n                 intro: DBNxt_then_FullNxt[unlift_rule])"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<and> \\<box>BInv inp q1 mid \\<longrightarrow>\n               \\<box>[FullNxt]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile> DBSpec \\<longrightarrow> \\<box>BInv inp q1 mid\n  \\<turnstile> DBSpec \\<and> \\<box>BInv inp q1 mid \\<longrightarrow>\n               \\<box>[FullNxt]_vars", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile> DBSpec \\<longrightarrow> \\<box>BInv inp q1 mid\n  \\<turnstile> DBSpec \\<and> \\<box>BInv inp q1 mid \\<longrightarrow>\n               \\<box>[FullNxt]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars", "by force"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> \\<box>[FullNxt]_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullSpec", "have 3: \"\\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars", "have 31: \"\\<turnstile> Unchanged vars \\<longrightarrow> Unchanged q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Unchanged vars \\<longrightarrow> Unchanged q1", "by (auto simp: vars_def tla_defs)"], ["proof (state)\nthis:\n  \\<turnstile> Unchanged vars \\<longrightarrow> Unchanged q1\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars", "have 32: \"\\<turnstile> Unchanged (inp,q1,mid) \\<longrightarrow> Unchanged q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Unchanged (inp, q1, mid) \\<longrightarrow> Unchanged q1", "by (auto simp: tla_defs)"], ["proof (state)\nthis:\n  \\<turnstile> Unchanged (inp, q1, mid) \\<longrightarrow> Unchanged q1\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars", "have deq: \"|~ \\<langle>Deq inp q1 mid\\<rangle>_vars = \\<langle>Deq inp q1 mid\\<rangle>_(inp,q1,mid)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>Deq inp q1 mid\\<rangle>_vars =\n       \\<langle>Deq inp q1 mid\\<rangle>_(inp, q1, mid)", "by (simp add: Deq_visible[OF 31, int_rewrite] \n                      Deq_visible[OF 32, int_rewrite])"], ["proof (state)\nthis:\n  |~ \\<langle>Deq inp q1 mid\\<rangle>_vars =\n     \\<langle>Deq inp q1 mid\\<rangle>_(inp, q1, mid)\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars", "by (auto simp: DBSpec_def ISpec_def WeakF_def \n                       deq[int_rewrite] deq[THEN AA26,int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> WF(Deq inp q1 mid)_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullSpec", "have 4: \"\\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars", "have 41: \"\\<turnstile> Unchanged vars \\<longrightarrow> Unchanged q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Unchanged vars \\<longrightarrow> Unchanged q2", "by (auto simp: vars_def tla_defs)"], ["proof (state)\nthis:\n  \\<turnstile> Unchanged vars \\<longrightarrow> Unchanged q2\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars", "have 42: \"\\<turnstile> Unchanged (mid,q2,out) \\<longrightarrow> Unchanged q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Unchanged (mid, q2, out) \\<longrightarrow> Unchanged q2", "by (auto simp: tla_defs)"], ["proof (state)\nthis:\n  \\<turnstile> Unchanged (mid, q2, out) \\<longrightarrow> Unchanged q2\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars", "have deq: \"|~ \\<langle>Deq mid q2 out\\<rangle>_vars = \\<langle>Deq mid q2 out\\<rangle>_(mid,q2,out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>Deq mid q2 out\\<rangle>_vars =\n       \\<langle>Deq mid q2 out\\<rangle>_(mid, q2, out)", "by (simp add: Deq_visible[OF 41, int_rewrite] \n                      Deq_visible[OF 42, int_rewrite])"], ["proof (state)\nthis:\n  |~ \\<langle>Deq mid q2 out\\<rangle>_vars =\n     \\<langle>Deq mid q2 out\\<rangle>_(mid, q2, out)\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars", "by (auto simp: DBSpec_def ISpec_def WeakF_def \n                       deq[int_rewrite] deq[THEN AA26,int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> WF(Deq mid q2 out)_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullSpec", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> FullSpec", "by (auto simp: FullSpec_def \n               elim: 1[unlift_rule] 2[unlift_rule] 3[unlift_rule] \n                     4[unlift_rule])"], ["proof (state)\nthis:\n  \\<turnstile> DBSpec \\<longrightarrow> FullSpec\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    We now prove that two FIFO buffers in a row (as specified by formula\n    \\<open>FullSpec\\<close>) implement a FIFO buffer whose internal queue is the\n    concatenation of the two buffers. We start by proving step simulation.\n\\<close>"], ["", "lemma FullInit: \"\\<turnstile> FullInit \\<longrightarrow> BInit inp qc out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> FullInit \\<longrightarrow> BInit inp qc out", "by (auto simp: db_defs tla_defs)"], ["", "lemma Full_step_simulation:\n    \"|~ [FullNxt]_vars \\<longrightarrow> [Nxt inp qc out]_(inp,qc,out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ _actrans FullNxt vars \\<longrightarrow>\n       _actrans (Nxt inp qc out) (inp, qc, out)", "by (auto simp: db_defs tla_defs)"], ["", "text \\<open>\n    The liveness condition requires that the combined buffer\n    eventually performs a \\<open>Deq\\<close> action on the output channel\n    if it contains some element. The idea is to use the\n    fairness hypothesis for the first buffer to prove that in that\n    case, eventually the queue of the second buffer will be\n    non-empty, and that it must therefore eventually dequeue\n    some element.\n\n    The first step is to establish the enabledness conditions\n    for the two \\<open>Deq\\<close> actions of the implementation.\n\\<close>"], ["", "lemma Deq1_enabled: \"\\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars = ($q1 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars =\n                 ($q1 \\<noteq> #[])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars =\n                 ($q1 \\<noteq> #[])", "have 1: \"|~ \\<langle>Deq inp q1 mid\\<rangle>_vars = Deq inp q1 mid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>Deq inp q1 mid\\<rangle>_vars = Deq inp q1 mid", "by (rule Deq_visible, auto simp: vars_def tla_defs)"], ["proof (state)\nthis:\n  |~ \\<langle>Deq inp q1 mid\\<rangle>_vars = Deq inp q1 mid\n\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars =\n                 ($q1 \\<noteq> #[])", "have \"\\<turnstile> Enabled (Deq inp q1 mid) = ($q1 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled Deq inp q1 mid = ($q1 \\<noteq> #[])", "by (force simp: Deq_def tla_defs vars_def\n                intro: base_enabled[OF DB_base] elim!: enabledE)"], ["proof (state)\nthis:\n  \\<turnstile> Enabled Deq inp q1 mid = ($q1 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars =\n                 ($q1 \\<noteq> #[])", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile> Enabled Deq inp q1 mid = ($q1 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars =\n                 ($q1 \\<noteq> #[])", "by (simp add: 1[int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars =\n               ($q1 \\<noteq> #[])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Deq2_enabled: \"\\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars = ($q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars =\n                 ($q2 \\<noteq> #[])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars =\n                 ($q2 \\<noteq> #[])", "have 1: \"|~ \\<langle>Deq mid q2 out\\<rangle>_vars = Deq mid q2 out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>Deq mid q2 out\\<rangle>_vars = Deq mid q2 out", "by (rule Deq_visible, auto simp: vars_def tla_defs)"], ["proof (state)\nthis:\n  |~ \\<langle>Deq mid q2 out\\<rangle>_vars = Deq mid q2 out\n\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars =\n                 ($q2 \\<noteq> #[])", "have \"\\<turnstile> Enabled (Deq mid q2 out) = ($q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled Deq mid q2 out = ($q2 \\<noteq> #[])", "by (force simp: Deq_def tla_defs vars_def\n                intro: base_enabled[OF DB_base] elim!: enabledE)"], ["proof (state)\nthis:\n  \\<turnstile> Enabled Deq mid q2 out = ($q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars =\n                 ($q2 \\<noteq> #[])", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile> Enabled Deq mid q2 out = ($q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars =\n                 ($q2 \\<noteq> #[])", "by (simp add: 1[int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars =\n               ($q2 \\<noteq> #[])\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    We now use rule \\<open>WF2\\<close> to prove that the combined buffer\n    (behaving according to specification \\<open>FullSpec\\<close>)\n    implements the fairness condition of the single buffer under\n    the refinement mapping.\n\\<close>"], ["", "lemma Full_fairness:\n    \"\\<turnstile> \\<box>[FullNxt]_vars \\<and> WF(Deq mid q2 out)_vars \\<and> \\<box>WF(Deq inp q1 mid)_vars\n       \\<longrightarrow> WF(Deq inp qc out)_(inp,qc,out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 WF(Deq inp qc out)_(inp, qc, out)", "proof (rule WF2)\n    \\<comment> \\<open>the helpful action is the @{text Deq} action of the second queue\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. |~ \\<langle>FullNxt \\<and> ?B\\<rangle>_vars \\<longrightarrow>\n       \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out)\n 2. |~ ?P \\<and>\n       \\<circle>?P \\<and>\n       \\<langle>FullNxt \\<and>\n                Deq mid q2 out\\<rangle>_vars \\<longrightarrow>\n       ?B\n 3. \\<turnstile> ?P \\<and>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<longrightarrow>\n                 Enabled \\<langle>Deq mid q2 out\\<rangle>_vars\n 4. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> ?B]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>?P", "show \"|~ \\<langle>FullNxt \\<and> Deq mid q2 out\\<rangle>_vars \\<longrightarrow> \\<langle>Deq inp qc out\\<rangle>_(inp,qc,out)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ \\<langle>FullNxt \\<and>\n                Deq mid q2 out\\<rangle>_vars \\<longrightarrow>\n       \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out)", "by (auto simp: db_defs tla_defs)"], ["proof (state)\nthis:\n  |~ \\<langle>FullNxt \\<and> Deq mid q2 out\\<rangle>_vars \\<longrightarrow>\n     \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out)\n\ngoal (3 subgoals):\n 1. |~ ?P \\<and>\n       \\<circle>?P \\<and>\n       \\<langle>FullNxt \\<and>\n                Deq mid q2 out\\<rangle>_vars \\<longrightarrow>\n       Deq mid q2 out\n 2. \\<turnstile> ?P \\<and>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<longrightarrow>\n                 Enabled \\<langle>Deq mid q2 out\\<rangle>_vars\n 3. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>?P", "next\n    \\<comment> \\<open>the helpful condition is the second queue being non-empty\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. |~ ?P \\<and>\n       \\<circle>?P \\<and>\n       \\<langle>FullNxt \\<and>\n                Deq mid q2 out\\<rangle>_vars \\<longrightarrow>\n       Deq mid q2 out\n 2. \\<turnstile> ?P \\<and>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<longrightarrow>\n                 Enabled \\<langle>Deq mid q2 out\\<rangle>_vars\n 3. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>?P", "show \"|~ ($q2 \\<noteq> #[]) \\<and> \\<circle>($q2 \\<noteq> #[]) \\<and> \\<langle>FullNxt \\<and> Deq mid q2 out\\<rangle>_vars \n             \\<longrightarrow> Deq mid q2 out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ $q2 \\<noteq> #[] \\<and>\n       \\<circle>($q2 \\<noteq> #[]) \\<and>\n       \\<langle>FullNxt \\<and>\n                Deq mid q2 out\\<rangle>_vars \\<longrightarrow>\n       Deq mid q2 out", "by (auto simp: tla_defs)"], ["proof (state)\nthis:\n  |~ $q2 \\<noteq> #[] \\<and>\n     \\<circle>($q2 \\<noteq> #[]) \\<and>\n     \\<langle>FullNxt \\<and> Deq mid q2 out\\<rangle>_vars \\<longrightarrow>\n     Deq mid q2 out\n\ngoal (2 subgoals):\n 1. \\<turnstile> $q2 \\<noteq> #[] \\<and>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<longrightarrow>\n                 Enabled \\<langle>Deq mid q2 out\\<rangle>_vars\n 2. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<turnstile> $q2 \\<noteq> #[] \\<and>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<longrightarrow>\n                 Enabled \\<langle>Deq mid q2 out\\<rangle>_vars\n 2. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "show \"\\<turnstile> $q2 \\<noteq> #[] \\<and> Enabled \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out)\n             \\<longrightarrow> Enabled \\<langle>Deq mid q2 out\\<rangle>_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $q2 \\<noteq> #[] \\<and>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<longrightarrow>\n                 Enabled \\<langle>Deq mid q2 out\\<rangle>_vars", "unfolding Deq2_enabled[int_rewrite]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $q2 \\<noteq> #[] \\<and>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<longrightarrow>\n                 $q2 \\<noteq> #[]", "by auto"], ["proof (state)\nthis:\n  \\<turnstile> $q2 \\<noteq> #[] \\<and>\n               Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<longrightarrow>\n               Enabled \\<langle>Deq mid q2 out\\<rangle>_vars\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "txt \\<open>\n      The difficult part of the proof is to show that the helpful\n      condition will eventually always be true provided that the\n      combined dequeue action is eventually always enabled and that\n      the helpful action is never executed. We prove that (1) the\n      helpful condition persists and (2) that it must eventually\n      become true.\n\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "have \"\\<turnstile> \\<box>\\<box>[FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars\n            \\<longrightarrow> \\<box>($q2 \\<noteq> #[] \\<longrightarrow> \\<box>($q2 \\<noteq> #[]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>\\<box>[FullNxt \\<and>\n                              \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n                 \\<box>($q2 \\<noteq> #[] \\<longrightarrow>\n                        \\<box>($q2 \\<noteq> #[]))", "proof (rule STL4)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and>\n                        \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n                 $q2 \\<noteq> #[] \\<longrightarrow> \\<box>($q2 \\<noteq> #[])", "have \"|~ $q2 \\<noteq> #[] \\<and> [FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars\n               \\<longrightarrow> \\<circle>($q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ $q2 \\<noteq> #[] \\<and>\n       _actrans (FullNxt \\<and> \\<not> Deq mid q2 out)\n        vars \\<longrightarrow>\n       \\<circle>($q2 \\<noteq> #[])", "by (auto simp: db_defs tla_defs)"], ["proof (state)\nthis:\n  |~ $q2 \\<noteq> #[] \\<and>\n     _actrans (FullNxt \\<and> \\<not> Deq mid q2 out) vars \\<longrightarrow>\n     \\<circle>($q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and>\n                        \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n                 $q2 \\<noteq> #[] \\<longrightarrow> \\<box>($q2 \\<noteq> #[])", "from this[THEN INV1]"], ["proof (chain)\npicking this:\n  \\<turnstile> $q2 \\<noteq> #[] \\<and>\n               \\<box>[FullNxt \\<and>\n                      \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               \\<box>($q2 \\<noteq> #[])", "show \"\\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars\n              \\<longrightarrow> ($q2 \\<noteq> #[] \\<longrightarrow> \\<box>($q2 \\<noteq> #[]))\""], ["proof (prove)\nusing this:\n  \\<turnstile> $q2 \\<noteq> #[] \\<and>\n               \\<box>[FullNxt \\<and>\n                      \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               \\<box>($q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and>\n                        \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n                 $q2 \\<noteq> #[] \\<longrightarrow> \\<box>($q2 \\<noteq> #[])", "by auto"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and>\n                      \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               $q2 \\<noteq> #[] \\<longrightarrow> \\<box>($q2 \\<noteq> #[])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>\\<box>[FullNxt \\<and>\n                            \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               \\<box>($q2 \\<noteq> #[] \\<longrightarrow>\n                      \\<box>($q2 \\<noteq> #[]))\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "hence 1: \"\\<turnstile> \\<box>[FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars\n                \\<longrightarrow> \\<diamond>($q2 \\<noteq> #[]) \\<longrightarrow> \\<diamond>\\<box>($q2 \\<noteq> #[])\""], ["proof (prove)\nusing this:\n  \\<turnstile> \\<box>\\<box>[FullNxt \\<and>\n                            \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               \\<box>($q2 \\<noteq> #[] \\<longrightarrow>\n                      \\<box>($q2 \\<noteq> #[]))\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and>\n                        \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n                 \\<diamond>($q2 \\<noteq> #[]) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "by (force intro: E31[unlift_rule])"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and>\n                      \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               \\<diamond>($q2 \\<noteq> #[]) \\<longrightarrow>\n               \\<diamond>\\<box>($q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "have 2: \"\\<turnstile> \\<box>[FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars\n               \\<and> WF(Deq inp q1 mid)_vars\n               \\<longrightarrow> (Enabled \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out) \\<leadsto> $q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "have qc: \"\\<turnstile> ($qc \\<noteq> #[]) = ($q1 \\<noteq> #[] \\<or> $q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $qc \\<noteq> #[] =\n                 ($q1 \\<noteq> #[] \\<or> $q2 \\<noteq> #[])", "by (auto simp: qc_def tla_defs)"], ["proof (state)\nthis:\n  \\<turnstile> $qc \\<noteq> #[] = ($q1 \\<noteq> #[] \\<or> $q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "have \"\\<turnstile> \\<box>[FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars \\<and> WF(Deq inp q1 mid)_vars\n              \\<longrightarrow> ($q1 \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 $q1 \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]", "proof (rule WF1)"], ["proof (state)\ngoal (4 subgoals):\n 1. |~ $q1 \\<noteq> #[] \\<and>\n       _actrans (FullNxt \\<and> \\<not> Deq mid q2 out)\n        vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[]) \\<or> \\<circle>($q2 \\<noteq> #[])\n 2. |~ $q1 \\<noteq> #[] \\<and>\n       \\<langle>(FullNxt \\<and> \\<not> Deq mid q2 out) \\<and>\n                Deq inp q1 mid\\<rangle>_vars \\<longrightarrow>\n       \\<circle>($q2 \\<noteq> #[])\n 3. \\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow>\n                 Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars\n 4. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "show \"|~ $q1 \\<noteq> #[] \\<and> [FullNxt \\<and> \\<not> Deq mid q2 out]_vars\n                 \\<longrightarrow> \\<circle>($q1 \\<noteq> #[]) \\<or> \\<circle>($q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ $q1 \\<noteq> #[] \\<and>\n       _actrans (FullNxt \\<and> \\<not> Deq mid q2 out)\n        vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[]) \\<or> \\<circle>($q2 \\<noteq> #[])", "by (auto simp: db_defs tla_defs)"], ["proof (state)\nthis:\n  |~ $q1 \\<noteq> #[] \\<and>\n     _actrans (FullNxt \\<and> \\<not> Deq mid q2 out) vars \\<longrightarrow>\n     \\<circle>($q1 \\<noteq> #[]) \\<or> \\<circle>($q2 \\<noteq> #[])\n\ngoal (3 subgoals):\n 1. |~ $q1 \\<noteq> #[] \\<and>\n       \\<langle>(FullNxt \\<and> \\<not> Deq mid q2 out) \\<and>\n                Deq inp q1 mid\\<rangle>_vars \\<longrightarrow>\n       \\<circle>($q2 \\<noteq> #[])\n 2. \\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow>\n                 Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars\n 3. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. |~ $q1 \\<noteq> #[] \\<and>\n       \\<langle>(FullNxt \\<and> \\<not> Deq mid q2 out) \\<and>\n                Deq inp q1 mid\\<rangle>_vars \\<longrightarrow>\n       \\<circle>($q2 \\<noteq> #[])\n 2. \\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow>\n                 Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars\n 3. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "show \"|~ $q1 \\<noteq> #[] \n                 \\<and> \\<langle>(FullNxt \\<and> \\<not> Deq mid q2 out) \\<and> Deq inp q1 mid\\<rangle>_vars \\<longrightarrow>\n                 \\<circle>($q2 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ $q1 \\<noteq> #[] \\<and>\n       \\<langle>(FullNxt \\<and> \\<not> Deq mid q2 out) \\<and>\n                Deq inp q1 mid\\<rangle>_vars \\<longrightarrow>\n       \\<circle>($q2 \\<noteq> #[])", "by (auto simp: db_defs tla_defs)"], ["proof (state)\nthis:\n  |~ $q1 \\<noteq> #[] \\<and>\n     \\<langle>(FullNxt \\<and> \\<not> Deq mid q2 out) \\<and>\n              Deq inp q1 mid\\<rangle>_vars \\<longrightarrow>\n     \\<circle>($q2 \\<noteq> #[])\n\ngoal (2 subgoals):\n 1. \\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow>\n                 Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars\n 2. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow>\n                 Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars\n 2. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "show \"\\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow> Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow>\n                 Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars", "by (simp add: Deq1_enabled[int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> $q1 \\<noteq> #[] \\<longrightarrow>\n               Enabled \\<langle>Deq inp q1 mid\\<rangle>_vars\n\ngoal (1 subgoal):\n 1. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "show \"|~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow> \\<circle>($q1 \\<noteq> #[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n       \\<circle>($q1 \\<noteq> #[])", "by (auto simp: vars_def tla_defs)"], ["proof (state)\nthis:\n  |~ $q1 \\<noteq> #[] \\<and> Unchanged vars \\<longrightarrow>\n     \\<circle>($q1 \\<noteq> #[])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               $q1 \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "hence \"\\<turnstile> \\<box>[FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars \n                  \\<and> WF(Deq inp q1 mid)_vars\n                  \\<longrightarrow> ($qc \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[])\""], ["proof (prove)\nusing this:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               $q1 \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 $qc \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]", "by (auto simp: qc[int_rewrite] LT17[int_rewrite] LT1[int_rewrite])"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               $qc \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "moreover"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               $qc \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "have \"\\<turnstile> Enabled \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out) \\<leadsto> $qc \\<noteq> #[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $qc \\<noteq> #[]", "by (rule Deq_enabledE[THEN LT3])"], ["proof (state)\nthis:\n  \\<turnstile> Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<leadsto> $qc \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "ultimately"], ["proof (chain)\npicking this:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               $qc \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]\n  \\<turnstile> Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<leadsto> $qc \\<noteq> #[]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               $qc \\<noteq> #[] \\<leadsto> $q2 \\<noteq> #[]\n  \\<turnstile> Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<leadsto> $qc \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<longrightarrow>\n                 Enabled \\<langle>Deq inp qc\n                                   out\\<rangle>_(inp, qc,\n           out) \\<leadsto> $q2 \\<noteq> #[]", "by (force elim: LT13[unlift_rule])"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<leadsto> $q2 \\<noteq> #[]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<leadsto> $q2 \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "with LT6"], ["proof (chain)\npicking this:\n  \\<turnstile> \\<diamond>?F \\<longrightarrow>\n               (?F \\<leadsto> ?G) \\<longrightarrow> \\<diamond>?G\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<leadsto> $q2 \\<noteq> #[]", "have \"\\<turnstile> \\<box>[FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars\n             \\<and> WF(Deq inp q1 mid)_vars\n             \\<and> \\<diamond>Enabled \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out)\n             \\<longrightarrow> \\<diamond>($q2 \\<noteq> #[])\""], ["proof (prove)\nusing this:\n  \\<turnstile> \\<diamond>?F \\<longrightarrow>\n               (?F \\<leadsto> ?G) \\<longrightarrow> \\<diamond>?G\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               Enabled \\<langle>Deq inp qc\n                                 out\\<rangle>_(inp, qc,\n         out) \\<leadsto> $q2 \\<noteq> #[]\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>Enabled \\<langle>Deq inp qc\n       out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>($q2 \\<noteq> #[])", "by force"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<and>\n               \\<diamond>Enabled \\<langle>Deq inp qc\n     out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n               \\<diamond>($q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "with 1 E16"], ["proof (chain)\npicking this:\n  \\<turnstile> \\<box>[FullNxt \\<and>\n                      \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               \\<diamond>($q2 \\<noteq> #[]) \\<longrightarrow>\n               \\<diamond>\\<box>($q2 \\<noteq> #[])\n  \\<turnstile> \\<diamond>\\<box>?F \\<longrightarrow> \\<diamond>?F\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<and>\n               \\<diamond>Enabled \\<langle>Deq inp qc\n     out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n               \\<diamond>($q2 \\<noteq> #[])", "show \"\\<turnstile> \\<box>[FullNxt \\<and> \\<not>(Deq mid q2 out)]_vars\n            \\<and> WF(Deq mid q2 out)_vars\n            \\<and> \\<box>WF(Deq inp q1 mid)_vars\n            \\<and> \\<diamond>\\<box> Enabled \\<langle>Deq inp qc out\\<rangle>_(inp, qc, out)\n            \\<longrightarrow> \\<diamond>\\<box>($q2 \\<noteq> #[])\""], ["proof (prove)\nusing this:\n  \\<turnstile> \\<box>[FullNxt \\<and>\n                      \\<not> Deq mid q2 out]_vars \\<longrightarrow>\n               \\<diamond>($q2 \\<noteq> #[]) \\<longrightarrow>\n               \\<diamond>\\<box>($q2 \\<noteq> #[])\n  \\<turnstile> \\<diamond>\\<box>?F \\<longrightarrow> \\<diamond>?F\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq inp q1 mid)_vars \\<and>\n               \\<diamond>Enabled \\<langle>Deq inp qc\n     out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n               \\<diamond>($q2 \\<noteq> #[])\n\ngoal (1 subgoal):\n 1. \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<and>\n                 \\<box>WF(Deq inp q1 mid)_vars \\<and>\n                 \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n             out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n                 \\<diamond>\\<box>($q2 \\<noteq> #[])", "by force"], ["proof (state)\nthis:\n  \\<turnstile> \\<box>[FullNxt \\<and> \\<not> Deq mid q2 out]_vars \\<and>\n               WF(Deq mid q2 out)_vars \\<and>\n               \\<box>WF(Deq inp q1 mid)_vars \\<and>\n               \\<diamond>\\<box>Enabled \\<langle>Deq inp qc\n           out\\<rangle>_(inp, qc, out) \\<longrightarrow>\n               \\<diamond>\\<box>($q2 \\<noteq> #[])\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    Putting everything together, we obtain that \\<open>FullSpec\\<close> refines\n    the Buffer specification under the refinement mapping.\n\\<close>"], ["", "theorem FullSpec_impl_ISpec: \"\\<turnstile> FullSpec \\<longrightarrow> ISpec inp qc out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> FullSpec \\<longrightarrow> ISpec inp qc out", "unfolding FullSpec_def ISpec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> FullInit \\<and>\n                 \\<box>[FullNxt]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<longrightarrow>\n                 BInit inp qc out \\<and>\n                 \\<box>[Nxt inp qc out]_(inp, qc, out) \\<and>\n                 WF(Deq inp qc out)_(inp, qc, out)", "using FullInit Full_step_simulation[THEN M11] Full_fairness"], ["proof (prove)\nusing this:\n  \\<turnstile> FullInit \\<longrightarrow> BInit inp qc out\n  \\<turnstile> \\<box>[FullNxt]_vars \\<longrightarrow>\n               \\<box>[Nxt inp qc out]_(inp, qc, out)\n  \\<turnstile> \\<box>[FullNxt]_vars \\<and>\n               WF(Deq mid q2 out)_vars \\<and>\n               \\<box>WF(Deq inp q1 mid)_vars \\<longrightarrow>\n               WF(Deq inp qc out)_(inp, qc, out)\n\ngoal (1 subgoal):\n 1. \\<turnstile> FullInit \\<and>\n                 \\<box>[FullNxt]_vars \\<and>\n                 WF(Deq inp q1 mid)_vars \\<and>\n                 WF(Deq mid q2 out)_vars \\<longrightarrow>\n                 BInit inp qc out \\<and>\n                 \\<box>[Nxt inp qc out]_(inp, qc, out) \\<and>\n                 WF(Deq inp qc out)_(inp, qc, out)", "by force"], ["", "theorem FullSpec_impl_Spec: \"\\<turnstile> FullSpec \\<longrightarrow> Spec inp out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> FullSpec \\<longrightarrow> Spec inp out", "unfolding Spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> FullSpec \\<longrightarrow>\n                 (\\<exists>\\<exists> q. ISpec inp q out)", "using FullSpec_impl_ISpec"], ["proof (prove)\nusing this:\n  \\<turnstile> FullSpec \\<longrightarrow> ISpec inp qc out\n\ngoal (1 subgoal):\n 1. \\<turnstile> FullSpec \\<longrightarrow>\n                 (\\<exists>\\<exists> q. ISpec inp q out)", "by (force intro: eexI[unlift_rule])"], ["", "text \\<open>\n    By transitivity, two buffers in a row also implement a single buffer.\n\\<close>"], ["", "theorem DBSpec_impl_Spec: \"\\<turnstile> DBSpec \\<longrightarrow> Spec inp out\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> DBSpec \\<longrightarrow> Spec inp out", "by (rule lift_imp_trans[OF DBSpec_impl_FullSpec FullSpec_impl_Spec])"], ["", "end \\<comment> \\<open>locale DBuffer\\<close>"], ["", "end"]]}