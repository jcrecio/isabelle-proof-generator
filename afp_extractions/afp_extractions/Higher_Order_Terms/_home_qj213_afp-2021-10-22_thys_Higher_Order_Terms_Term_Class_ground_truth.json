{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Term_Class.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemma freess_cons[simp]: \"freess (x # xs) = frees x |\\<union>| freess xs\"", "lemma freess_single: \"freess [x] = frees x\"", "lemma freess_empty[simp]: \"freess [] = {||}\"", "lemma freess_app[simp]: \"freess (xs @ ys) = freess xs |\\<union>| freess ys\"", "lemma freess_subset: \"set xs \\<subseteq> set ys \\<Longrightarrow> freess xs |\\<subseteq>| freess ys\"", "lemmas term_inject = free_inject const_inject app_inject", "lemmas term_distinct[simp] =\n  app_const_distinct app_const_distinct[symmetric]\n  app_free_distinct app_free_distinct[symmetric]\n  free_const_distinct free_const_distinct[symmetric]", "lemma app_size1: \"size u\\<^sub>1 < size (app u\\<^sub>1 u\\<^sub>2)\"", "lemma app_size2: \"size u\\<^sub>2 < size (app u\\<^sub>1 u\\<^sub>2)\"", "lemma unx_some_lemmas:\n  \"unapp u = Some x \\<Longrightarrow> unconst u = None\"\n  \"unapp u = Some x \\<Longrightarrow> unfree u = None\"\n  \"unconst u = Some y \\<Longrightarrow> unapp u = None\"\n  \"unconst u = Some y \\<Longrightarrow> unfree u = None\"\n  \"unfree u = Some z \\<Longrightarrow> unconst u = None\"\n  \"unfree u = Some z \\<Longrightarrow> unapp u = None\"", "lemma unx_none_simps[simp]:\n  \"unapp (const name) = None\"\n  \"unapp (free name) = None\"\n  \"unconst (app t u) = None\"\n  \"unconst (free name) = None\"\n  \"unfree (const name) = None\"\n  \"unfree (app t u) = None\"", "lemma term_cases:\n  obtains (free) name where \"t = free name\"\n        | (const) name where \"t = const name\"\n        | (app) u\\<^sub>1 u\\<^sub>2 where \"t = app u\\<^sub>1 u\\<^sub>2\"\n        | (other) \"unfree t = None\" \"unapp t = None\" \"unconst t = None\"", "lemma is_const_simps[simp]:\n  \"is_const (const name)\"\n  \"\\<not> is_const (app t u)\"\n  \"\\<not> is_const (free name)\"", "lemma const_name_simps[simp]:\n  \"const_name (const name) = name\"\n  \"is_const t \\<Longrightarrow> const (const_name t) = t\"", "lemma is_free_simps[simp]:\n  \"is_free (free name)\"\n  \"\\<not> is_free (const name)\"\n  \"\\<not> is_free (app t u)\"", "lemma free_name_simps[simp]:\n  \"free_name (free name) = name\"\n  \"is_free t \\<Longrightarrow> free (free_name t) = t\"", "lemma app_simps[simp]:\n  \"\\<not> is_app (const name)\"\n  \"\\<not> is_app (free name)\"\n  \"is_app (app t u)\"", "lemma left_right_simps[simp]:\n  \"left (app l r) = l\"\n  \"right (app l r) = r\"\n  \"is_app t \\<Longrightarrow> app (left t) (right t) = t\"", "lemma closed_except_const[simp]: \"closed_except (const name) S\"", "lemma closed_except_self: \"closed_except t (frees t)\"", "lemma subst_id: \"id_env env \\<Longrightarrow> subst t env = t\"", "lemma subst_drop: \"x |\\<notin>| frees t \\<Longrightarrow> subst t (fmdrop x env) = subst t env\"", "lemma subst_frees: \"fmpred (\\<lambda>_. closed) env \\<Longrightarrow> frees (subst t env) = frees t |-| fmdom env\"", "lemma subst_consts': \"consts (subst t env) = consts t |\\<union>| ffUnion (consts |`| fmimage env (frees t))\"", "lemma match_simps[simp]:\n  \"match (t\\<^sub>1 $ t\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) = do {\n    env\\<^sub>1 \\<leftarrow> match t\\<^sub>1 u\\<^sub>1;\n    env\\<^sub>2 \\<leftarrow> match t\\<^sub>2 u\\<^sub>2;\n    Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n  }\"\n  \"match (Const name) (const name') = (if name = name' then Some fmempty else None)\"", "lemma match_some_induct[consumes 1, case_names app const free]:\n  assumes \"match t u = Some env\"\n  assumes \"\\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2. P t\\<^sub>1 u\\<^sub>1 env\\<^sub>1 \\<Longrightarrow> match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1 \\<Longrightarrow> P t\\<^sub>2 u\\<^sub>2 env\\<^sub>2 \\<Longrightarrow> match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2 \\<Longrightarrow> P (t\\<^sub>1 $ t\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\"\n  assumes \"\\<And>name. P (Const name) (const name) fmempty\"\n  assumes \"\\<And>name u. P (Free name) u (fmupd name u fmempty)\"\n  shows \"P t u env\"", "lemma match_dom: \"match p t = Some env \\<Longrightarrow> fmdom env = frees p\"", "lemma match_vars: \"match p t = Some env \\<Longrightarrow> fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees t) env\"", "lemma match_appE_split:\n  assumes \"match (t\\<^sub>1 $ t\\<^sub>2) u = Some env\"\n  obtains u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2 where\n    \"u = app u\\<^sub>1 u\\<^sub>2\" \"match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\" \"match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\" \"env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\"", "lemma subst_consts:\n  assumes \"consts t |\\<subseteq>| S\" \"fmpred (\\<lambda>_ u. consts u |\\<subseteq>| S) env\"\n  shows \"consts (subst t env) |\\<subseteq>| S\"", "lemma subst_empty[simp]: \"subst t fmempty = t\"", "lemma subst_drop_fset: \"fdisjnt S (frees t) \\<Longrightarrow> subst t (fmdrop_fset S env) = subst t env\"", "lemma subst_restrict:\n  assumes \"frees t |\\<subseteq>| M\"\n  shows \"subst t (fmrestrict_fset M env) = subst t env\"", "lemma subst_closed_except_id:\n  assumes \"closed_except t S\" \"fdisjnt (fmdom env) S\"\n  shows \"subst t env = t\"", "lemma subst_closed_except_preserved:\n  assumes \"closed_except t S\" \"fdisjnt (fmdom env) S\"\n  shows \"closed_except (subst t env) S\"", "lemma subst_indep0:\n  assumes \"closed_env env\\<^sub>2\" \"fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\"\n  shows \"subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst (subst t env\\<^sub>2) env\\<^sub>1\"", "lemma subst_indep:\n  assumes \"closed_env \\<Gamma>'\"\n  shows \"subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') = subst (subst t \\<Gamma>') \\<Gamma>\"", "lemma subst_indep':\n  assumes \"closed_env \\<Gamma>'\" \"fdisjnt (fmdom \\<Gamma>') (fmdom \\<Gamma>)\"\n  shows \"subst t (\\<Gamma>' ++\\<^sub>f \\<Gamma>) = subst (subst t \\<Gamma>') \\<Gamma>\"", "lemma subst_twice:\n  assumes \"\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\" \"closed_env \\<Gamma>'\"\n  shows \"subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>\"", "lemmas matchs_induct = matchs.induct[case_names empty cons]", "lemma matchs_alt_def0:\n  assumes \"length ps = length vs\"\n  shows \"map_option (\\<lambda>env. m ++\\<^sub>f env) (matchs ps vs) = map_option (foldl (++\\<^sub>f) m) (those (map2 match ps vs))\"", "lemma matchs_alt_def:\n  assumes \"length ps = length vs\"\n  shows \"matchs ps vs = map_option (foldl (++\\<^sub>f) fmempty) (those (map2 match ps vs))\"", "lemma matchs_neq_length_none[simp]: \"length xs \\<noteq> length ys \\<Longrightarrow> matchs xs ys = None\"", "lemma matchs_app[simp]:\n  assumes \"length xs\\<^sub>2 = length ys\\<^sub>2\"\n  shows \"matchs (xs\\<^sub>1 @ xs\\<^sub>2) (ys\\<^sub>1 @ ys\\<^sub>2) =\n          matchs xs\\<^sub>1 ys\\<^sub>1 \\<bind> (\\<lambda>env\\<^sub>1. matchs xs\\<^sub>2 ys\\<^sub>2 \\<bind> (\\<lambda>env\\<^sub>2. Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)))\"", "lemma find_match_map:\n  \"find_match (map (\\<lambda>(pat, t). (pat, f pat t)) cs) t =\n    map_option (\\<lambda>(env, pat, rhs). (env, pat, f pat rhs)) (find_match cs t)\"", "lemma find_match_elem:\n  assumes \"find_match cs t = Some (env, pat, rhs)\"\n  shows \"(pat, rhs) \\<in> set cs\" \"match pat t = Some env\"", "lemma match_subst_closed:\n  assumes \"match pat t = Some env\" \"closed_except rhs (frees pat)\" \"closed t\"\n  shows \"closed (subst rhs env)\"", "lemma rewrite_step_closed:\n  assumes \"frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\" \"(t\\<^sub>1, t\\<^sub>2) \\<turnstile> u \\<rightarrow> u'\" \"closed u\"\n  shows \"closed u'\"", "lemma matchesI[intro]: \"subst t env = u \\<Longrightarrow> t \\<lesssim> u\"", "lemma matchesE[elim]:\n  assumes \"t \\<lesssim> u\"\n  obtains env where \"subst t env = u\"", "lemma overlapping_refl: \"overlapping t t\"", "lemma overlapping_sym: \"overlapping t u \\<Longrightarrow> overlapping u t\"", "lemma overlappingI[intro]: \"s \\<lesssim> u \\<Longrightarrow> t \\<lesssim> u \\<Longrightarrow> overlapping s t\"", "lemma overlappingE[elim]:\n  assumes \"overlapping s t\"\n  obtains u where \"s \\<lesssim> u\" \"t \\<lesssim> u\"", "lemma rewrite_firstE:\n  assumes \"rewrite_first cs t t'\"\n  obtains pat rhs env where \"(pat, rhs) \\<in> set cs\" \"match pat t = Some env\" \"t' = subst rhs env\"", "lemma find_match_rewrite_first:\n  assumes \"find_match cs t = Some (env, pat, rhs)\"\n  shows \"rewrite_first cs t (subst rhs env)\"", "lemma term_cases_cong[fundef_cong]:\n  assumes \"t = u\" \"otherwise1 = otherwise2\"\n  assumes \"(\\<And>name. t = const name \\<Longrightarrow> if_const1 name = if_const2 name)\"\n  assumes \"(\\<And>name. t = free name \\<Longrightarrow> if_free1 name = if_free2 name)\"\n  assumes \"(\\<And>u\\<^sub>1 u\\<^sub>2. t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> if_app1 u\\<^sub>1 u\\<^sub>2 = if_app2 u\\<^sub>1 u\\<^sub>2)\"\n  shows \"term_cases if_const1 if_free1 if_app1 otherwise1 t = term_cases if_const2 if_free2 if_app2 otherwise2 u\"", "lemma term_cases[simp]:\n  \"term_cases if_const if_free if_app otherwise (const name) = if_const name\"\n  \"term_cases if_const if_free if_app otherwise (free name) = if_free name\"\n  \"term_cases if_const if_free if_app otherwise (app t u) = if_app t u\"", "lemma term_cases_template:\n  assumes \"\\<And>x. f x = term_cases if_const if_free if_app otherwise x\"\n  shows \"f (const name) = if_const name\"\n    and \"f (free name) = if_free name\"\n    and \"f (app t u) = if_app t u\"", "lemma strip_comb_simps[simp]:\n  \"strip_comb (app t u) = (let (f, args) = strip_comb t in (f, args @ [u]))\"\n  \"unapp t = None \\<Longrightarrow> strip_comb t = (t, [])\"", "lemma strip_comb_induct[case_names app no_app]:\n  assumes \"\\<And>x y. P x \\<Longrightarrow> P (app x y)\"\n  assumes \"\\<And>t. unapp t = None \\<Longrightarrow> P t\"\n  shows \"P t\"", "lemma strip_comb_size: \"t' \\<in> set (snd (strip_comb t)) \\<Longrightarrow> size t' < size t\"", "lemma sstrip_comb_termination[termination_simp]:\n  \"(f, ts) = strip_comb t \\<Longrightarrow> t' \\<in> set ts \\<Longrightarrow> size t' < size t\"", "lemma strip_comb_empty: \"snd (strip_comb t) = [] \\<Longrightarrow> fst (strip_comb t) = t\"", "lemma strip_comb_app: \"fst (strip_comb (app t u)) = fst (strip_comb t)\"", "lemma list_comb_app[simp]: \"list_comb f (xs @ ys) = list_comb (list_comb f xs) ys\"", "lemma list_comb_size[simp]: \"size (list_comb f xs) = size f + size_list size xs\"", "lemma subst_list_comb: \"subst (list_comb f xs) env = list_comb (subst f env) (map (\\<lambda>t. subst t env) xs)\"", "lemma list_strip_comb[simp]: \"list_comb (fst (strip_comb t)) (snd (strip_comb t)) = t\"", "lemma strip_list_comb: \"strip_comb (list_comb f ys) = (fst (strip_comb f), snd (strip_comb f) @ ys)\"", "lemma strip_list_comb_const: \"strip_comb (name $$ xs) = (const name, xs)\"", "lemma frees_list_comb[simp]: \"frees (list_comb t xs) = frees t |\\<union>| freess xs\"", "lemma consts_list_comb: \"consts (list_comb f xs) = consts f |\\<union>| ffUnion (fset_of_list (map consts xs))\"", "lemma ids_list_comb: \"ids (list_comb f xs) = ids f |\\<union>| ffUnion (fset_of_list (map ids xs))\"", "lemma frees_strip_comb: \"frees t = frees (fst (strip_comb t)) |\\<union>| freess (snd (strip_comb t))\"", "lemma list_comb_cases':\n  obtains (app) \"is_app (list_comb f xs)\"\n        | (empty) \"list_comb f xs = f\" \"xs = []\"", "lemma list_comb_cases[consumes 1]:\n  assumes \"t = list_comb f xs\"\n  obtains (head) \"t = f\" \"xs = []\"\n        | (app) u v where \"t = app u v\"", "lemmas left_nesting_simps[simp] = term_cases_template[OF left_nesting.simps]", "lemma list_comb_nesting[simp]: \"left_nesting (list_comb f xs) = left_nesting f + length xs\"", "lemma list_comb_cond_inj:\n  assumes \"list_comb f xs = list_comb g ys\" \"left_nesting f = left_nesting g\"\n  shows \"xs = ys\" \"f = g\"", "lemma list_comb_inj_second: \"inj (list_comb f)\"", "lemma list_comb_semi_inj:\n  assumes \"length xs = length ys\"\n  assumes \"list_comb f xs = list_comb g ys\"\n  shows \"xs = ys\" \"f = g\"", "lemmas no_abs_simps[simp] = term_cases_template[OF no_abs.simps]", "lemma no_abs_induct[consumes 1, case_names free const app, induct pred: no_abs]:\n  assumes \"no_abs t\"\n  assumes \"\\<And>name. P (free name)\"\n  assumes \"\\<And>name. P (const name)\"\n  assumes \"\\<And>t\\<^sub>1 t\\<^sub>2. P t\\<^sub>1 \\<Longrightarrow> no_abs t\\<^sub>1 \\<Longrightarrow> P t\\<^sub>2 \\<Longrightarrow> no_abs t\\<^sub>2 \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2)\"\n  shows \"P t\"", "lemma no_abs_cases[consumes 1, cases pred: no_abs]:\n  assumes \"no_abs t\"\n  obtains (free) name where \"t = free name\"\n        | (const) name where \"t = const name\"\n        | (app) t\\<^sub>1 t\\<^sub>2 where \"t = app t\\<^sub>1 t\\<^sub>2\" \"no_abs t\\<^sub>1\" \"no_abs t\\<^sub>2\"", "lemmas is_abs_simps[simp] = term_cases_template[OF is_abs_def]", "lemma list_comb: \"P (list_comb f xs) \\<longleftrightarrow> P f \\<and> list_all P xs\"", "lemma match:\n  assumes \"match pat t = Some env\" \"P t\"\n  shows \"fmpred (\\<lambda>_. P) env\"", "lemma matchs:\n  assumes \"matchs pats ts = Some env\" \"list_all P ts\"\n  shows \"fmpred (\\<lambda>_. P) env\"", "lemma rewrite_step:\n  assumes \"(lhs, rhs) \\<turnstile> t \\<rightarrow> t'\" \"P t\" \"P rhs\"\n  shows \"P t'\"", "lemma list_comb: \"P (list_comb f xs) \\<longleftrightarrow> P f \\<or> list_ex P xs\"", "lemma match:\n  assumes \"match pat t = Some env\" \"\\<not> P t\"\n  shows \"fmpred (\\<lambda>_ t. \\<not> P t) env\"", "lemma related_match:\n  assumes \"match x u = Some env\" \"P t u\"\n  obtains env' where \"match x t = Some env'\" \"P_env env' env\"", "lemma list_combI:\n  assumes \"list_all2 P us\\<^sub>1 us\\<^sub>2\" \"P t\\<^sub>1 t\\<^sub>2\"\n  shows \"P (list_comb t\\<^sub>1 us\\<^sub>1) (list_comb t\\<^sub>2 us\\<^sub>2)\"", "lemma list_combE:\n  assumes \"P t (name $$ args)\"\n  obtains args' where \"t = name $$ args'\" \"list_all2 P args' args\"", "lemma unconst_rel: \"P t u \\<Longrightarrow> unconst t = unconst u\"", "lemma unapp_rel: \"P t u \\<Longrightarrow> rel_option (rel_prod P P) (unapp t) (unapp u)\"", "lemma match_rel:\n  assumes \"P t u\"\n  shows \"rel_option P_env (match p t) (match p u)\"", "lemma find_match_rel:\n  assumes \"list_all2 (rel_prod (=) P) cs cs'\" \"P t t'\"\n  shows \"rel_option (rel_prod P_env (rel_prod (=) P)) (find_match cs t) (find_match cs' t')\"", "lemmas convert_term_simps[simp] = term_cases_template[OF convert_term.simps]", "lemma convert_term_id:\n  assumes \"no_abs t\"\n  shows \"convert_term t = t\"", "lemma convert_term_no_abs:\n  assumes \"no_abs t\"\n  shows \"no_abs (convert_term t)\"", "lemma convert_term_inj:\n  assumes \"no_abs t\" \"no_abs t'\" \"convert_term t = convert_term t'\"\n  shows \"t = t'\"", "lemma convert_term_idem:\n  assumes \"no_abs t\"\n  shows \"convert_term (convert_term t) = convert_term t\"", "lemma convert_term_frees[simp]:\n  assumes \"no_abs t\"\n  shows \"frees (convert_term t) = frees t\"", "lemma convert_term_consts[simp]:\n  assumes \"no_abs t\"\n  shows \"consts (convert_term t) = consts t\"", "lemma convert_term_match:\n  assumes \"match t u = Some env\"\n  shows \"match t (convert_term u) = Some (fmmap convert_term env)\""], "translations": [["", "lemma freess_cons[simp]: \"freess (x # xs) = frees x |\\<union>| freess xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess (x # xs) = frees x |\\<union>| freess xs", "unfolding freess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ffUnion \\<circ> fset_of_list \\<circ> map frees) (x # xs) =\n    frees x |\\<union>| (ffUnion \\<circ> fset_of_list \\<circ> map frees) xs", "by simp"], ["", "lemma freess_single: \"freess [x] = frees x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess [x] = frees x", "unfolding freess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ffUnion \\<circ> fset_of_list \\<circ> map frees) [x] = frees x", "by simp"], ["", "lemma freess_empty[simp]: \"freess [] = {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess [] = {||}", "unfolding freess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ffUnion \\<circ> fset_of_list \\<circ> map frees) [] = {||}", "by simp"], ["", "lemma freess_app[simp]: \"freess (xs @ ys) = freess xs |\\<union>| freess ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess (xs @ ys) = freess xs |\\<union>| freess ys", "unfolding freess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ffUnion \\<circ> fset_of_list \\<circ> map frees) (xs @ ys) =\n    (ffUnion \\<circ> fset_of_list \\<circ> map frees) xs |\\<union>|\n    (ffUnion \\<circ> fset_of_list \\<circ> map frees) ys", "by simp"], ["", "lemma freess_subset: \"set xs \\<subseteq> set ys \\<Longrightarrow> freess xs |\\<subseteq>| freess ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ys \\<Longrightarrow>\n    freess xs |\\<subseteq>| freess ys", "unfolding freess_def comp_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ys \\<Longrightarrow>\n    ffUnion (fset_of_list (map frees xs)) |\\<subseteq>|\n    ffUnion (fset_of_list (map frees ys))", "by (intro ffunion_mono fset_of_list_subset) auto"], ["", "abbreviation id_env :: \"(name, 'a) fmap \\<Rightarrow> bool\" where\n\"id_env \\<equiv> fmpred (\\<lambda>x y. y = free x)\""], ["", "definition closed_except :: \"'a \\<Rightarrow> name fset \\<Rightarrow> bool\" where\n\"closed_except t S \\<longleftrightarrow> frees t |\\<subseteq>| S\""], ["", "abbreviation closed :: \"'a \\<Rightarrow> bool\" where\n\"closed t \\<equiv> closed_except t {||}\""], ["", "lemmas term_inject = free_inject const_inject app_inject"], ["", "lemmas term_distinct[simp] =\n  app_const_distinct app_const_distinct[symmetric]\n  app_free_distinct app_free_distinct[symmetric]\n  free_const_distinct free_const_distinct[symmetric]"], ["", "lemma app_size1: \"size u\\<^sub>1 < size (app u\\<^sub>1 u\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size u\\<^sub>1 < size (app u\\<^sub>1 u\\<^sub>2)", "by simp"], ["", "lemma app_size2: \"size u\\<^sub>2 < size (app u\\<^sub>1 u\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size u\\<^sub>2 < size (app u\\<^sub>1 u\\<^sub>2)", "by simp"], ["", "lemma unx_some_lemmas:\n  \"unapp u = Some x \\<Longrightarrow> unconst u = None\"\n  \"unapp u = Some x \\<Longrightarrow> unfree u = None\"\n  \"unconst u = Some y \\<Longrightarrow> unapp u = None\"\n  \"unconst u = Some y \\<Longrightarrow> unfree u = None\"\n  \"unfree u = Some z \\<Longrightarrow> unconst u = None\"\n  \"unfree u = Some z \\<Longrightarrow> unapp u = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((unapp u = Some x \\<Longrightarrow> unconst u = None) &&&\n     (unapp u = Some x \\<Longrightarrow> unfree u = None) &&&\n     (unconst u = Some y \\<Longrightarrow> unapp u = None)) &&&\n    (unconst u = Some y \\<Longrightarrow> unfree u = None) &&&\n    (unfree u = Some z \\<Longrightarrow> unconst u = None) &&&\n    (unfree u = Some z \\<Longrightarrow> unapp u = None)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unapp u = Some x \\<Longrightarrow> unconst u = None", "by (metis app_unapp const_unconst app_const_distinct not_None_eq surj_pair)"], ["proof (prove)\ngoal (5 subgoals):\n 1. unapp u = Some x \\<Longrightarrow> unfree u = None\n 2. unconst u = Some y \\<Longrightarrow> unapp u = None\n 3. unconst u = Some y \\<Longrightarrow> unfree u = None\n 4. unfree u = Some z \\<Longrightarrow> unconst u = None\n 5. unfree u = Some z \\<Longrightarrow> unapp u = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unapp u = Some x \\<Longrightarrow> unfree u = None", "by (metis app_free_distinct app_unapp free_unfree option.exhaust surj_pair)"], ["proof (prove)\ngoal (4 subgoals):\n 1. unconst u = Some y \\<Longrightarrow> unapp u = None\n 2. unconst u = Some y \\<Longrightarrow> unfree u = None\n 3. unfree u = Some z \\<Longrightarrow> unconst u = None\n 4. unfree u = Some z \\<Longrightarrow> unapp u = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unconst u = Some y \\<Longrightarrow> unapp u = None", "by (metis app_unapp const_unconst app_const_distinct old.prod.exhaust option.distinct(1) option.expand option.sel)"], ["proof (prove)\ngoal (3 subgoals):\n 1. unconst u = Some y \\<Longrightarrow> unfree u = None\n 2. unfree u = Some z \\<Longrightarrow> unconst u = None\n 3. unfree u = Some z \\<Longrightarrow> unapp u = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unconst u = Some y \\<Longrightarrow> unfree u = None", "by (metis const_unconst free_const_distinct free_unfree option.exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. unfree u = Some z \\<Longrightarrow> unconst u = None\n 2. unfree u = Some z \\<Longrightarrow> unapp u = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree u = Some z \\<Longrightarrow> unconst u = None", "by (metis const_unconst free_const_distinct free_unfree option.exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree u = Some z \\<Longrightarrow> unapp u = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree u = Some z \\<Longrightarrow> unapp u = None", "by (metis app_free_distinct app_unapp free_unfree not_Some_eq surj_pair)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma unx_none_simps[simp]:\n  \"unapp (const name) = None\"\n  \"unapp (free name) = None\"\n  \"unconst (app t u) = None\"\n  \"unconst (free name) = None\"\n  \"unfree (const name) = None\"\n  \"unfree (app t u) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unapp (const name) = None &&&\n     unapp (free name) = None &&& unconst (app t u) = None) &&&\n    unconst (free name) = None &&&\n    unfree (const name) = None &&& unfree (app t u) = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unapp (const name) = None", "by (metis app_unapp app_const_distinct not_None_eq surj_pair)"], ["proof (prove)\ngoal (5 subgoals):\n 1. unapp (free name) = None\n 2. unconst (app t u) = None\n 3. unconst (free name) = None\n 4. unfree (const name) = None\n 5. unfree (app t u) = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unapp (free name) = None", "by (metis app_free_distinct app_unapp option.exhaust surj_pair)"], ["proof (prove)\ngoal (4 subgoals):\n 1. unconst (app t u) = None\n 2. unconst (free name) = None\n 3. unfree (const name) = None\n 4. unfree (app t u) = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unconst (app t u) = None", "by (metis const_unconst app_const_distinct option.distinct(1) option.expand option.sel)"], ["proof (prove)\ngoal (3 subgoals):\n 1. unconst (free name) = None\n 2. unfree (const name) = None\n 3. unfree (app t u) = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unconst (free name) = None", "by (metis const_unconst free_const_distinct option.exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. unfree (const name) = None\n 2. unfree (app t u) = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree (const name) = None", "by (metis free_const_distinct free_unfree option.exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree (app t u) = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree (app t u) = None", "by (metis app_free_distinct free_unfree not_Some_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma term_cases:\n  obtains (free) name where \"t = free name\"\n        | (const) name where \"t = const name\"\n        | (app) u\\<^sub>1 u\\<^sub>2 where \"t = app u\\<^sub>1 u\\<^sub>2\"\n        | (other) \"unfree t = None\" \"unapp t = None\" \"unconst t = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases \"unfree t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     unfree t = None\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (cases \"unconst t\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     unfree t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = None; unconst t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (cases \"unapp t\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     unfree t = None; unconst t = None; unapp t = None\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = None; unconst t = None; unapp t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = None; unconst t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     unfree t = None; unconst t = None; unapp t = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = None; unconst t = None; unapp t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = None; unconst t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     unfree t = None; unconst t = None; unapp t = Some x\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases x) auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = None; unconst t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     unfree t = None; unconst t = Some a_\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n        \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        unfree t = Some a\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>u\\<^sub>1 u\\<^sub>2.\n        t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> thesis;\n     \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     unfree t = Some a_\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition is_const where\n\"is_const t \\<longleftrightarrow> (unconst t \\<noteq> None)\""], ["", "definition const_name where\n\"const_name t = (case unconst t of Some name \\<Rightarrow> name)\""], ["", "lemma is_const_simps[simp]:\n  \"is_const (const name)\"\n  \"\\<not> is_const (app t u)\"\n  \"\\<not> is_const (free name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_const (const name) &&&\n    \\<not> is_const (app t u) &&& \\<not> is_const (free name)", "unfolding is_const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unconst (const name) \\<noteq> None &&&\n    \\<not> unconst (app t u) \\<noteq> None &&&\n    \\<not> unconst (free name) \\<noteq> None", "by simp+"], ["", "lemma const_name_simps[simp]:\n  \"const_name (const name) = name\"\n  \"is_const t \\<Longrightarrow> const (const_name t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_name (const name) = name &&&\n    (is_const t \\<Longrightarrow> const (const_name t) = t)", "unfolding const_name_def is_const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case unconst (const name) of Some name \\<Rightarrow> name) = name &&&\n    (unconst t \\<noteq> None \\<Longrightarrow>\n     const (case unconst t of Some name \\<Rightarrow> name) = t)", "by auto"], ["", "definition is_free where\n\"is_free t \\<longleftrightarrow> (unfree t \\<noteq> None)\""], ["", "definition free_name where\n\"free_name t = (case unfree t of Some name \\<Rightarrow> name)\""], ["", "lemma is_free_simps[simp]:\n  \"is_free (free name)\"\n  \"\\<not> is_free (const name)\"\n  \"\\<not> is_free (app t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_free (free name) &&&\n    \\<not> is_free (const name) &&& \\<not> is_free (app t u)", "unfolding is_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree (free name) \\<noteq> None &&&\n    \\<not> unfree (const name) \\<noteq> None &&&\n    \\<not> unfree (app t u) \\<noteq> None", "by simp+"], ["", "lemma free_name_simps[simp]:\n  \"free_name (free name) = name\"\n  \"is_free t \\<Longrightarrow> free (free_name t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. free_name (free name) = name &&&\n    (is_free t \\<Longrightarrow> free (free_name t) = t)", "unfolding free_name_def is_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case unfree (free name) of Some name \\<Rightarrow> name) = name &&&\n    (unfree t \\<noteq> None \\<Longrightarrow>\n     free (case unfree t of Some name \\<Rightarrow> name) = t)", "by auto"], ["", "definition is_app where\n\"is_app t \\<longleftrightarrow> (unapp t \\<noteq> None)\""], ["", "definition left where\n\"left t = (case unapp t of Some (l, _) \\<Rightarrow> l)\""], ["", "definition right where\n\"right t = (case unapp t of Some (_, r) \\<Rightarrow> r)\""], ["", "lemma app_simps[simp]:\n  \"\\<not> is_app (const name)\"\n  \"\\<not> is_app (free name)\"\n  \"is_app (app t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_app (const name) &&&\n    \\<not> is_app (free name) &&& is_app (app t u)", "unfolding is_app_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unapp (const name) \\<noteq> None &&&\n    \\<not> unapp (free name) \\<noteq> None &&& unapp (app t u) \\<noteq> None", "by simp+"], ["", "lemma left_right_simps[simp]:\n  \"left (app l r) = l\"\n  \"right (app l r) = r\"\n  \"is_app t \\<Longrightarrow> app (left t) (right t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left (app l r) = l &&&\n    right (app l r) = r &&&\n    (is_app t \\<Longrightarrow> app (left t) (right t) = t)", "unfolding is_app_def left_def right_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case unapp (app l r) of Some (l, xa) \\<Rightarrow> l) = l &&&\n    (case unapp (app l r) of Some (xa, r) \\<Rightarrow> r) = r &&&\n    (unapp t \\<noteq> None \\<Longrightarrow>\n     app (case unapp t of Some (l, xa) \\<Rightarrow> l)\n      (case unapp t of Some (xa, r) \\<Rightarrow> r) =\n     t)", "by auto"], ["", "definition ids :: \"'a \\<Rightarrow> name fset\" where\n\"ids t = frees t |\\<union>| consts t\""], ["", "lemma closed_except_const[simp]: \"closed_except (const name) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (const name) S", "unfolding closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (const name) |\\<subseteq>| S", "by auto"], ["", "abbreviation closed_env :: \"(name, 'a) fmap \\<Rightarrow> bool\" where\n\"closed_env \\<equiv> fmpred (\\<lambda>_. closed)\""], ["", "lemma closed_except_self: \"closed_except t (frees t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t (frees t)", "unfolding closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| frees t", "by simp"], ["", "end"], ["", "class \"term\" = pre_term + size +\n  fixes\n    abs_pred :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes\n    raw_induct[case_names const free app abs]:\n      \"(\\<And>name. P (const name)) \\<Longrightarrow>\n        (\\<And>name. P (free name)) \\<Longrightarrow>\n        (\\<And>t\\<^sub>1 t\\<^sub>2. P t\\<^sub>1 \\<Longrightarrow> P t\\<^sub>2 \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2)) \\<Longrightarrow>\n        (\\<And>t. abs_pred P t) \\<Longrightarrow>\n        P t\"\n  assumes\n    raw_subst_id: \"abs_pred (\\<lambda>t. \\<forall>env. id_env env \\<longrightarrow> subst t env = t) t\" and\n    raw_subst_drop: \"abs_pred (\\<lambda>t. x |\\<notin>| frees t \\<longrightarrow> (\\<forall>env. subst t (fmdrop x env) = subst t env)) t\" and\n    raw_subst_indep: \"abs_pred (\\<lambda>t. \\<forall>env\\<^sub>1 env\\<^sub>2. closed_env env\\<^sub>2 \\<longrightarrow> fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2) \\<longrightarrow> subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst (subst t env\\<^sub>2) env\\<^sub>1) t\" and\n    raw_subst_frees: \"abs_pred (\\<lambda>t. \\<forall>env. closed_env env \\<longrightarrow> frees (subst t env) = frees t |-| fmdom env) t\" and\n    raw_subst_consts': \"abs_pred (\\<lambda>a. \\<forall>x. consts (subst a x) = consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a))) t\" and\n    abs_pred_trivI: \"P t \\<Longrightarrow> abs_pred P t\"\nbegin"], ["", "lemma subst_id: \"id_env env \\<Longrightarrow> subst t env = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_env env \\<Longrightarrow> subst t env = t", "proof (induction t arbitrary: env rule: raw_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name env.\n       id_env env \\<Longrightarrow> subst (const name) env = const name\n 2. \\<And>name env.\n       id_env env \\<Longrightarrow> subst (free name) env = free name\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   id_env env \\<Longrightarrow>\n                   subst t\\<^sub>1 env = t\\<^sub>1;\n        \\<And>env.\n           id_env env \\<Longrightarrow> subst t\\<^sub>2 env = t\\<^sub>2;\n        id_env env\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2) env =\n                         app t\\<^sub>1 t\\<^sub>2\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a. \\<forall>x. id_env x \\<longrightarrow> subst a x = a) t", "case (abs t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>name env.\n       id_env env \\<Longrightarrow> subst (const name) env = const name\n 2. \\<And>name env.\n       id_env env \\<Longrightarrow> subst (free name) env = free name\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   id_env env \\<Longrightarrow>\n                   subst t\\<^sub>1 env = t\\<^sub>1;\n        \\<And>env.\n           id_env env \\<Longrightarrow> subst t\\<^sub>2 env = t\\<^sub>2;\n        id_env env\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2) env =\n                         app t\\<^sub>1 t\\<^sub>2\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a. \\<forall>x. id_env x \\<longrightarrow> subst a x = a) t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a. \\<forall>x. id_env x \\<longrightarrow> subst a x = a) t", "by (rule raw_subst_id)"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a. \\<forall>x. id_env x \\<longrightarrow> subst a x = a) t\n\ngoal (3 subgoals):\n 1. \\<And>name env.\n       id_env env \\<Longrightarrow> subst (const name) env = const name\n 2. \\<And>name env.\n       id_env env \\<Longrightarrow> subst (free name) env = free name\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   id_env env \\<Longrightarrow>\n                   subst t\\<^sub>1 env = t\\<^sub>1;\n        \\<And>env.\n           id_env env \\<Longrightarrow> subst t\\<^sub>2 env = t\\<^sub>2;\n        id_env env\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2) env =\n                         app t\\<^sub>1 t\\<^sub>2", "qed (auto split: option.splits)"], ["", "lemma subst_drop: \"x |\\<notin>| frees t \\<Longrightarrow> subst t (fmdrop x env) = subst t env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<notin>| frees t \\<Longrightarrow>\n    subst t (fmdrop x env) = subst t env", "proof (induction t arbitrary: env rule: raw_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name env.\n       x |\\<notin>| frees (const name) \\<Longrightarrow>\n       subst (const name) (fmdrop x env) = subst (const name) env\n 2. \\<And>name env.\n       x |\\<notin>| frees (free name) \\<Longrightarrow>\n       subst (free name) (fmdrop x env) = subst (free name) env\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   x |\\<notin>| frees t\\<^sub>1 \\<Longrightarrow>\n                   subst t\\<^sub>1 (fmdrop x env) = subst t\\<^sub>1 env;\n        \\<And>env.\n           x |\\<notin>| frees t\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2 (fmdrop x env) = subst t\\<^sub>2 env;\n        x |\\<notin>| frees (app t\\<^sub>1 t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2) (fmdrop x env) =\n                         subst (app t\\<^sub>1 t\\<^sub>2) env\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            x |\\<notin>| frees a \\<longrightarrow>\n            (\\<forall>xa. subst a (fmdrop x xa) = subst a xa))\n        t", "case (abs t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>name env.\n       x |\\<notin>| frees (const name) \\<Longrightarrow>\n       subst (const name) (fmdrop x env) = subst (const name) env\n 2. \\<And>name env.\n       x |\\<notin>| frees (free name) \\<Longrightarrow>\n       subst (free name) (fmdrop x env) = subst (free name) env\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   x |\\<notin>| frees t\\<^sub>1 \\<Longrightarrow>\n                   subst t\\<^sub>1 (fmdrop x env) = subst t\\<^sub>1 env;\n        \\<And>env.\n           x |\\<notin>| frees t\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2 (fmdrop x env) = subst t\\<^sub>2 env;\n        x |\\<notin>| frees (app t\\<^sub>1 t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2) (fmdrop x env) =\n                         subst (app t\\<^sub>1 t\\<^sub>2) env\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            x |\\<notin>| frees a \\<longrightarrow>\n            (\\<forall>xa. subst a (fmdrop x xa) = subst a xa))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a.\n         x |\\<notin>| frees a \\<longrightarrow>\n         (\\<forall>xa. subst a (fmdrop x xa) = subst a xa))\n     t", "by (rule raw_subst_drop)"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a.\n       x |\\<notin>| frees a \\<longrightarrow>\n       (\\<forall>xa. subst a (fmdrop x xa) = subst a xa))\n   t\n\ngoal (3 subgoals):\n 1. \\<And>name env.\n       x |\\<notin>| frees (const name) \\<Longrightarrow>\n       subst (const name) (fmdrop x env) = subst (const name) env\n 2. \\<And>name env.\n       x |\\<notin>| frees (free name) \\<Longrightarrow>\n       subst (free name) (fmdrop x env) = subst (free name) env\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   x |\\<notin>| frees t\\<^sub>1 \\<Longrightarrow>\n                   subst t\\<^sub>1 (fmdrop x env) = subst t\\<^sub>1 env;\n        \\<And>env.\n           x |\\<notin>| frees t\\<^sub>2 \\<Longrightarrow>\n           subst t\\<^sub>2 (fmdrop x env) = subst t\\<^sub>2 env;\n        x |\\<notin>| frees (app t\\<^sub>1 t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2) (fmdrop x env) =\n                         subst (app t\\<^sub>1 t\\<^sub>2) env", "qed (auto split: option.splits)"], ["", "lemma subst_frees: \"fmpred (\\<lambda>_. closed) env \\<Longrightarrow> frees (subst t env) = frees t |-| fmdom env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env env \\<Longrightarrow>\n    frees (subst t env) = frees t |-| fmdom env", "proof (induction t arbitrary: env rule: raw_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name env.\n       closed_env env \\<Longrightarrow>\n       frees (subst (const name) env) = frees (const name) |-| fmdom env\n 2. \\<And>name env.\n       closed_env env \\<Longrightarrow>\n       frees (subst (free name) env) = frees (free name) |-| fmdom env\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   closed_env env \\<Longrightarrow>\n                   frees (subst t\\<^sub>1 env) =\n                   frees t\\<^sub>1 |-| fmdom env;\n        \\<And>env.\n           closed_env env \\<Longrightarrow>\n           frees (subst t\\<^sub>2 env) = frees t\\<^sub>2 |-| fmdom env;\n        closed_env env\\<rbrakk>\n       \\<Longrightarrow> frees (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         frees (app t\\<^sub>1 t\\<^sub>2) |-| fmdom env\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               closed_env x \\<longrightarrow>\n               frees (subst a x) = frees a |-| fmdom x)\n        t", "case (abs t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>name env.\n       closed_env env \\<Longrightarrow>\n       frees (subst (const name) env) = frees (const name) |-| fmdom env\n 2. \\<And>name env.\n       closed_env env \\<Longrightarrow>\n       frees (subst (free name) env) = frees (free name) |-| fmdom env\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   closed_env env \\<Longrightarrow>\n                   frees (subst t\\<^sub>1 env) =\n                   frees t\\<^sub>1 |-| fmdom env;\n        \\<And>env.\n           closed_env env \\<Longrightarrow>\n           frees (subst t\\<^sub>2 env) = frees t\\<^sub>2 |-| fmdom env;\n        closed_env env\\<rbrakk>\n       \\<Longrightarrow> frees (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         frees (app t\\<^sub>1 t\\<^sub>2) |-| fmdom env\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               closed_env x \\<longrightarrow>\n               frees (subst a x) = frees a |-| fmdom x)\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a.\n         \\<forall>x.\n            closed_env x \\<longrightarrow>\n            frees (subst a x) = frees a |-| fmdom x)\n     t", "by (rule raw_subst_frees)"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a.\n       \\<forall>x.\n          closed_env x \\<longrightarrow>\n          frees (subst a x) = frees a |-| fmdom x)\n   t\n\ngoal (3 subgoals):\n 1. \\<And>name env.\n       closed_env env \\<Longrightarrow>\n       frees (subst (const name) env) = frees (const name) |-| fmdom env\n 2. \\<And>name env.\n       closed_env env \\<Longrightarrow>\n       frees (subst (free name) env) = frees (free name) |-| fmdom env\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   closed_env env \\<Longrightarrow>\n                   frees (subst t\\<^sub>1 env) =\n                   frees t\\<^sub>1 |-| fmdom env;\n        \\<And>env.\n           closed_env env \\<Longrightarrow>\n           frees (subst t\\<^sub>2 env) = frees t\\<^sub>2 |-| fmdom env;\n        closed_env env\\<rbrakk>\n       \\<Longrightarrow> frees (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         frees (app t\\<^sub>1 t\\<^sub>2) |-| fmdom env", "qed (auto split: option.splits simp: closed_except_def)"], ["", "lemma subst_consts': \"consts (subst t env) = consts t |\\<union>| ffUnion (consts |`| fmimage env (frees t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst t env) =\n    consts t |\\<union>| ffUnion (consts |`| fmimage env (frees t))", "proof (induction t arbitrary: env rule: raw_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name env.\n       consts (subst (const name) env) =\n       consts (const name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (const name)))\n 2. \\<And>name env.\n       consts (subst (free name) env) =\n       consts (free name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (free name)))\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   consts (subst t\\<^sub>1 env) =\n                   consts t\\<^sub>1 |\\<union>|\n                   ffUnion (consts |`| fmimage env (frees t\\<^sub>1));\n        \\<And>env.\n           consts (subst t\\<^sub>2 env) =\n           consts t\\<^sub>2 |\\<union>|\n           ffUnion (consts |`| fmimage env (frees t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> consts (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         consts (app t\\<^sub>1 t\\<^sub>2) |\\<union>|\n                         ffUnion\n                          (consts |`|\n                           fmimage env (frees (app t\\<^sub>1 t\\<^sub>2)))\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t", "case (free name)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>name env.\n       consts (subst (const name) env) =\n       consts (const name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (const name)))\n 2. \\<And>name env.\n       consts (subst (free name) env) =\n       consts (free name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (free name)))\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   consts (subst t\\<^sub>1 env) =\n                   consts t\\<^sub>1 |\\<union>|\n                   ffUnion (consts |`| fmimage env (frees t\\<^sub>1));\n        \\<And>env.\n           consts (subst t\\<^sub>2 env) =\n           consts t\\<^sub>2 |\\<union>|\n           ffUnion (consts |`| fmimage env (frees t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> consts (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         consts (app t\\<^sub>1 t\\<^sub>2) |\\<union>|\n                         ffUnion\n                          (consts |`|\n                           fmimage env (frees (app t\\<^sub>1 t\\<^sub>2)))\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst (free name) env) =\n    consts (free name) |\\<union>|\n    ffUnion (consts |`| fmimage env (frees (free name)))", "by (auto\n          split: option.splits\n          simp: ffUnion_alt_def fmlookup_ran_iff fmlookup_image_iff fmlookup_dom_iff\n          intro!: fBexI)"], ["proof (state)\nthis:\n  consts (subst (free name) env) =\n  consts (free name) |\\<union>|\n  ffUnion (consts |`| fmimage env (frees (free name)))\n\ngoal (3 subgoals):\n 1. \\<And>name env.\n       consts (subst (const name) env) =\n       consts (const name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (const name)))\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   consts (subst t\\<^sub>1 env) =\n                   consts t\\<^sub>1 |\\<union>|\n                   ffUnion (consts |`| fmimage env (frees t\\<^sub>1));\n        \\<And>env.\n           consts (subst t\\<^sub>2 env) =\n           consts t\\<^sub>2 |\\<union>|\n           ffUnion (consts |`| fmimage env (frees t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> consts (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         consts (app t\\<^sub>1 t\\<^sub>2) |\\<union>|\n                         ffUnion\n                          (consts |`|\n                           fmimage env (frees (app t\\<^sub>1 t\\<^sub>2)))\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name env.\n       consts (subst (const name) env) =\n       consts (const name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (const name)))\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   consts (subst t\\<^sub>1 env) =\n                   consts t\\<^sub>1 |\\<union>|\n                   ffUnion (consts |`| fmimage env (frees t\\<^sub>1));\n        \\<And>env.\n           consts (subst t\\<^sub>2 env) =\n           consts t\\<^sub>2 |\\<union>|\n           ffUnion (consts |`| fmimage env (frees t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> consts (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         consts (app t\\<^sub>1 t\\<^sub>2) |\\<union>|\n                         ffUnion\n                          (consts |`|\n                           fmimage env (frees (app t\\<^sub>1 t\\<^sub>2)))\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t", "case (abs t)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>name env.\n       consts (subst (const name) env) =\n       consts (const name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (const name)))\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   consts (subst t\\<^sub>1 env) =\n                   consts t\\<^sub>1 |\\<union>|\n                   ffUnion (consts |`| fmimage env (frees t\\<^sub>1));\n        \\<And>env.\n           consts (subst t\\<^sub>2 env) =\n           consts t\\<^sub>2 |\\<union>|\n           ffUnion (consts |`| fmimage env (frees t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> consts (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         consts (app t\\<^sub>1 t\\<^sub>2) |\\<union>|\n                         ffUnion\n                          (consts |`|\n                           fmimage env (frees (app t\\<^sub>1 t\\<^sub>2)))\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a.\n         \\<forall>x.\n            consts (subst a x) =\n            consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n     t", "by (rule raw_subst_consts')"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a.\n       \\<forall>x.\n          consts (subst a x) =\n          consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n   t\n\ngoal (2 subgoals):\n 1. \\<And>name env.\n       consts (subst (const name) env) =\n       consts (const name) |\\<union>|\n       ffUnion (consts |`| fmimage env (frees (const name)))\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env.\n       \\<lbrakk>\\<And>env.\n                   consts (subst t\\<^sub>1 env) =\n                   consts t\\<^sub>1 |\\<union>|\n                   ffUnion (consts |`| fmimage env (frees t\\<^sub>1));\n        \\<And>env.\n           consts (subst t\\<^sub>2 env) =\n           consts t\\<^sub>2 |\\<union>|\n           ffUnion (consts |`| fmimage env (frees t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> consts (subst (app t\\<^sub>1 t\\<^sub>2) env) =\n                         consts (app t\\<^sub>1 t\\<^sub>2) |\\<union>|\n                         ffUnion\n                          (consts |`|\n                           fmimage env (frees (app t\\<^sub>1 t\\<^sub>2)))", "qed (auto simp: funion_image_bind_eq finter_funion_distrib fbind_funion)"], ["", "fun match :: \"term \\<Rightarrow> 'a \\<Rightarrow> (name, 'a) fmap option\" where\n\"match (t\\<^sub>1 $ t\\<^sub>2) u = do {\n  (u\\<^sub>1, u\\<^sub>2) \\<leftarrow> unapp u;\n  env\\<^sub>1 \\<leftarrow> match t\\<^sub>1 u\\<^sub>1;\n  env\\<^sub>2 \\<leftarrow> match t\\<^sub>2 u\\<^sub>2;\n  Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n}\" |\n\"match (Const name) u =\n  (case unconst u of\n    None \\<Rightarrow> None\n  | Some name' \\<Rightarrow> if name = name' then Some fmempty else None)\" |\n\"match (Free name) u = Some (fmap_of_list [(name, u)])\" |\n\"match (Bound n) u = None\" |\n\"match (Abs t) u = None\""], ["", "lemma match_simps[simp]:\n  \"match (t\\<^sub>1 $ t\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) = do {\n    env\\<^sub>1 \\<leftarrow> match t\\<^sub>1 u\\<^sub>1;\n    env\\<^sub>2 \\<leftarrow> match t\\<^sub>2 u\\<^sub>2;\n    Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n  }\"\n  \"match (Const name) (const name') = (if name = name' then Some fmempty else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (t\\<^sub>1 $ t\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) =\n    match t\\<^sub>1 u\\<^sub>1 \\<bind>\n    (\\<lambda>env\\<^sub>1.\n        match t\\<^sub>2 u\\<^sub>2 \\<bind>\n        (\\<lambda>env\\<^sub>2.\n            Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))) &&&\n    match (Const name) (const name') =\n    (if name = name' then Some fmempty else None)", "by auto"], ["", "lemma match_some_induct[consumes 1, case_names app const free]:\n  assumes \"match t u = Some env\"\n  assumes \"\\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2. P t\\<^sub>1 u\\<^sub>1 env\\<^sub>1 \\<Longrightarrow> match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1 \\<Longrightarrow> P t\\<^sub>2 u\\<^sub>2 env\\<^sub>2 \\<Longrightarrow> match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2 \\<Longrightarrow> P (t\\<^sub>1 $ t\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\"\n  assumes \"\\<And>name. P (Const name) (const name) fmempty\"\n  assumes \"\\<And>name u. P (Free name) u (fmupd name u fmempty)\"\n  shows \"P t u env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t u env", "using assms"], ["proof (prove)\nusing this:\n  match t u = Some env\n  \\<lbrakk>P ?t\\<^sub>1 ?u\\<^sub>1 ?env\\<^sub>1;\n   match ?t\\<^sub>1 ?u\\<^sub>1 = Some ?env\\<^sub>1;\n   P ?t\\<^sub>2 ?u\\<^sub>2 ?env\\<^sub>2;\n   match ?t\\<^sub>2 ?u\\<^sub>2 = Some ?env\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (?t\\<^sub>1 $ ?t\\<^sub>2) (app ?u\\<^sub>1 ?u\\<^sub>2)\n                     (?env\\<^sub>1 ++\\<^sub>f ?env\\<^sub>2)\n  P (Const ?name) (const ?name) fmempty\n  P (Free ?name) ?u (fmupd ?name ?u fmempty)\n\ngoal (1 subgoal):\n 1. P t u env", "by (induction t u arbitrary: env rule: match.induct)\n   (auto split: option.splits if_splits elim!: option_bindE)"], ["", "lemma match_dom: \"match p t = Some env \\<Longrightarrow> fmdom env = frees p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match p t = Some env \\<Longrightarrow> fmdom env = frees p", "by (induction p arbitrary: t env)\n   (fastforce split: option.splits if_splits elim: option_bindE)+"], ["", "lemma match_vars: \"match p t = Some env \\<Longrightarrow> fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees t) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match p t = Some env \\<Longrightarrow>\n    fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees t) env", "proof (induction p t env rule: match_some_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>1)\n                 env\\<^sub>1;\n        match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n        fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>2)\n         env\\<^sub>2;\n        match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> fmpred\n                          (\\<lambda>_ u.\n                              frees u |\\<subseteq>|\n                              frees (app u\\<^sub>1 u\\<^sub>2))\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n 2. \\<And>name.\n       fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees (const name))\n        fmempty\n 3. \\<And>name u.\n       fmpred (\\<lambda>_ ua. frees ua |\\<subseteq>| frees u)\n        (fmupd name u fmempty)", "case (app t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2)"], ["proof (state)\nthis:\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>1) env\\<^sub>1\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>2) env\\<^sub>2\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>1)\n                 env\\<^sub>1;\n        match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n        fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>2)\n         env\\<^sub>2;\n        match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> fmpred\n                          (\\<lambda>_ u.\n                              frees u |\\<subseteq>|\n                              frees (app u\\<^sub>1 u\\<^sub>2))\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n 2. \\<And>name.\n       fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees (const name))\n        fmempty\n 3. \\<And>name u.\n       fmpred (\\<lambda>_ ua. frees ua |\\<subseteq>| frees u)\n        (fmupd name u fmempty)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred\n     (\\<lambda>_ u. frees u |\\<subseteq>| frees (app u\\<^sub>1 u\\<^sub>2))\n     (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmpred\n     (\\<lambda>_ u. frees u |\\<subseteq>| frees (app u\\<^sub>1 u\\<^sub>2))\n     env\\<^sub>1\n 2. fmpred\n     (\\<lambda>_ u. frees u |\\<subseteq>| frees (app u\\<^sub>1 u\\<^sub>2))\n     env\\<^sub>2", "using app"], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>1) env\\<^sub>1\n  fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees u\\<^sub>2) env\\<^sub>2\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (2 subgoals):\n 1. fmpred\n     (\\<lambda>_ u. frees u |\\<subseteq>| frees (app u\\<^sub>1 u\\<^sub>2))\n     env\\<^sub>1\n 2. fmpred\n     (\\<lambda>_ u. frees u |\\<subseteq>| frees (app u\\<^sub>1 u\\<^sub>2))\n     env\\<^sub>2", "by (fastforce intro: fmpred_mono_strong)+"], ["proof (state)\nthis:\n  fmpred\n   (\\<lambda>_ u. frees u |\\<subseteq>| frees (app u\\<^sub>1 u\\<^sub>2))\n   (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       fmpred (\\<lambda>_ u. frees u |\\<subseteq>| frees (const name))\n        fmempty\n 2. \\<And>name u.\n       fmpred (\\<lambda>_ ua. frees ua |\\<subseteq>| frees u)\n        (fmupd name u fmempty)", "qed auto"], ["", "lemma match_appE_split:\n  assumes \"match (t\\<^sub>1 $ t\\<^sub>2) u = Some env\"\n  obtains u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2 where\n    \"u = app u\\<^sub>1 u\\<^sub>2\" \"match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\" \"match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\" \"env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n        \\<lbrakk>u = app u\\<^sub>1 u\\<^sub>2;\n         match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n         match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2;\n         env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  match (t\\<^sub>1 $ t\\<^sub>2) u = Some env\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n        \\<lbrakk>u = app u\\<^sub>1 u\\<^sub>2;\n         match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n         match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2;\n         env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits elim!: option_bindE)"], ["", "lemma subst_consts:\n  assumes \"consts t |\\<subseteq>| S\" \"fmpred (\\<lambda>_ u. consts u |\\<subseteq>| S) env\"\n  shows \"consts (subst t env) |\\<subseteq>| S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (subst t env) |\\<subseteq>| S", "apply (subst subst_consts')"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts t |\\<union>|\n    ffUnion (consts |`| fmimage env (frees t)) |\\<subseteq>|\n    S", "using assms"], ["proof (prove)\nusing this:\n  consts t |\\<subseteq>| S\n  fmpred (\\<lambda>_ u. consts u |\\<subseteq>| S) env\n\ngoal (1 subgoal):\n 1. consts t |\\<union>|\n    ffUnion (consts |`| fmimage env (frees t)) |\\<subseteq>|\n    S", "by (auto intro!: ffUnion_least)"], ["", "lemma subst_empty[simp]: \"subst t fmempty = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t fmempty = t", "by (auto simp: subst_id)"], ["", "lemma subst_drop_fset: \"fdisjnt S (frees t) \\<Longrightarrow> subst t (fmdrop_fset S env) = subst t env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt S (frees t) \\<Longrightarrow>\n    subst t (fmdrop_fset S env) = subst t env", "by (induct S) (auto simp: subst_drop fdisjnt_alt_def)"], ["", "lemma subst_restrict:\n  assumes \"frees t |\\<subseteq>| M\"\n  shows \"subst t (fmrestrict_fset M env) = subst t env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset M env) = subst t env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset M env) = subst t env", "have *: \"fmrestrict_fset M env = fmdrop_fset (fmdom env - M) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_fset M env = fmdrop_fset (fmdom env |-| M) env", "by (rule fmap_ext) auto"], ["proof (state)\nthis:\n  fmrestrict_fset M env = fmdrop_fset (fmdom env |-| M) env\n\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset M env) = subst t env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset M env) = subst t env", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmdrop_fset (fmdom env |-| M) env) = subst t env", "apply (subst subst_drop_fset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fdisjnt (fmdom env |-| M) (frees t)\n 2. subst t env = subst t env", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmdom env |-| M |\\<inter>| frees t = {||}\n 2. subst t env = subst t env", "using assms"], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| M\n\ngoal (2 subgoals):\n 1. fmdom env |-| M |\\<inter>| frees t = {||}\n 2. subst t env = subst t env", "by auto"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset M env) = subst t env\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_restrict'[simp]: \"subst t (fmrestrict_fset (frees t) env) = subst t env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset (frees t) env) = subst t env", "by (simp add: subst_restrict)"], ["", "corollary subst_cong:\n  assumes \"\\<And>x. x |\\<in>| frees t \\<Longrightarrow> fmlookup \\<Gamma>\\<^sub>1 x = fmlookup \\<Gamma>\\<^sub>2 x\"\n  shows \"subst t \\<Gamma>\\<^sub>1 = subst t \\<Gamma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t \\<Gamma>\\<^sub>1 = subst t \\<Gamma>\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst t \\<Gamma>\\<^sub>1 = subst t \\<Gamma>\\<^sub>2", "have \"fmrestrict_fset (frees t) \\<Gamma>\\<^sub>1 = fmrestrict_fset (frees t) \\<Gamma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_fset (frees t) \\<Gamma>\\<^sub>1 =\n    fmrestrict_fset (frees t) \\<Gamma>\\<^sub>2", "apply (rule fmap_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (fmrestrict_fset (frees t) \\<Gamma>\\<^sub>1) x =\n       fmlookup (fmrestrict_fset (frees t) \\<Gamma>\\<^sub>2) x", "using assms"], ["proof (prove)\nusing this:\n  ?x |\\<in>| frees t \\<Longrightarrow>\n  fmlookup \\<Gamma>\\<^sub>1 ?x = fmlookup \\<Gamma>\\<^sub>2 ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       fmlookup (fmrestrict_fset (frees t) \\<Gamma>\\<^sub>1) x =\n       fmlookup (fmrestrict_fset (frees t) \\<Gamma>\\<^sub>2) x", "by simp"], ["proof (state)\nthis:\n  fmrestrict_fset (frees t) \\<Gamma>\\<^sub>1 =\n  fmrestrict_fset (frees t) \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t \\<Gamma>\\<^sub>1 = subst t \\<Gamma>\\<^sub>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  fmrestrict_fset (frees t) \\<Gamma>\\<^sub>1 =\n  fmrestrict_fset (frees t) \\<Gamma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t \\<Gamma>\\<^sub>1 = subst t \\<Gamma>\\<^sub>2", "by (metis subst_restrict')"], ["proof (state)\nthis:\n  subst t \\<Gamma>\\<^sub>1 = subst t \\<Gamma>\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_add_disjnt:\n  assumes \"fdisjnt (frees t) (fmdom env\\<^sub>1)\"\n  shows \"subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t (fmrestrict_fset (frees t) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    subst t (fmrestrict_fset (frees t) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))", "by (metis subst_restrict')"], ["proof (state)\nthis:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  subst t (fmrestrict_fset (frees t) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  subst t (fmrestrict_fset (frees t) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t (fmrestrict_fset (frees t) env\\<^sub>1 ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmrestrict_fset (frees t) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)) =\n    subst t\n     (fmrestrict_fset (frees t) env\\<^sub>1 ++\\<^sub>f\n      fmrestrict_fset (frees t) env\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset (frees t) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)) =\n  subst t\n   (fmrestrict_fset (frees t) env\\<^sub>1 ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset (frees t) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)) =\n  subst t\n   (fmrestrict_fset (frees t) env\\<^sub>1 ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmrestrict_fset (frees t) env\\<^sub>1 ++\\<^sub>f\n      fmrestrict_fset (frees t) env\\<^sub>2) =\n    subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)", "unfolding fmfilter_alt_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>1 ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2) =\n    subst t\n     (fmempty ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2)", "apply (subst fmfilter_false)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       fmlookup env\\<^sub>1 x = Some y \\<Longrightarrow>\n       x |\\<notin>| frees t\n 2. subst t\n     (fmempty ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2) =\n    subst t\n     (fmempty ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  fdisjnt (frees t) (fmdom env\\<^sub>1)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       fmlookup env\\<^sub>1 x = Some y \\<Longrightarrow>\n       x |\\<notin>| frees t\n 2. subst t\n     (fmempty ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2) =\n    subst t\n     (fmempty ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2)", "by (auto simp: fdisjnt_alt_def intro: fmdomI)"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t) env\\<^sub>1 ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2) =\n  subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t) env\\<^sub>1 ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2) =\n  subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t (fmrestrict_fset (frees t) env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2) =\n    subst t (fmrestrict_fset (frees t) env\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2) =\n  subst t (fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2) =\n  subst t (fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset (frees t) env\\<^sub>2) = subst t env\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset (frees t) env\\<^sub>2) = subst t env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "finally"], ["proof (chain)\npicking this:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "."], ["proof (state)\nthis:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_add_shadowed_env:\n  assumes \"frees t |\\<subseteq>| fmdom env\\<^sub>2\"\n  shows \"subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    subst t\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "by (subst fmadd_drop_left_dom) rule"], ["proof (state)\nthis:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  subst t\n   (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  subst t\n   (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t (fmrestrict_fset (frees t) (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    subst t\n     (fmrestrict_fset (frees t)\n       (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))", "by (metis subst_restrict')"], ["proof (state)\nthis:\n  subst t\n   (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t\n   (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2))\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t (fmrestrict_fset (frees t) (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1) ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmrestrict_fset (frees t)\n       (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f\n        env\\<^sub>2)) =\n    subst t\n     (fmrestrict_fset (frees t)\n       (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1) ++\\<^sub>f\n      fmrestrict_fset (frees t) env\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)) =\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1) ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)) =\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1) ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmrestrict_fset (frees t)\n       (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1) ++\\<^sub>f\n      fmrestrict_fset (frees t) env\\<^sub>2) =\n    subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)", "unfolding fmfilter_alt_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmfilter (\\<lambda>a. a |\\<in>| frees t)\n       (fmfilter (\\<lambda>a. a |\\<notin>| fmdom env\\<^sub>2)\n         env\\<^sub>1) ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2) =\n    subst t\n     (fmempty ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2)", "using fsubsetD[OF assms]"], ["proof (prove)\nusing this:\n  ?c |\\<in>| frees t \\<Longrightarrow> ?c |\\<in>| fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t\n     (fmfilter (\\<lambda>a. a |\\<in>| frees t)\n       (fmfilter (\\<lambda>a. a |\\<notin>| fmdom env\\<^sub>2)\n         env\\<^sub>1) ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2) =\n    subst t\n     (fmempty ++\\<^sub>f\n      fmfilter (\\<lambda>a. a |\\<in>| frees t) env\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1) ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2) =\n  subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "also"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t)\n     (fmdrop_fset (fmdom env\\<^sub>2) env\\<^sub>1) ++\\<^sub>f\n    fmrestrict_fset (frees t) env\\<^sub>2) =\n  subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "have \"\\<dots> = subst t env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2) =\n    subst t env\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  subst t (fmempty ++\\<^sub>f fmrestrict_fset (frees t) env\\<^sub>2) =\n  subst t env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "finally"], ["proof (chain)\npicking this:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2", "."], ["proof (state)\nthis:\n  subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst t env\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_restrict_closed: \"closed_except t S \\<Longrightarrow> subst t (fmrestrict_fset S env) = subst t env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except t S \\<Longrightarrow>\n    subst t (fmrestrict_fset S env) = subst t env", "by (metis subst_restrict closed_except_def)"], ["", "lemma subst_closed_except_id:\n  assumes \"closed_except t S\" \"fdisjnt (fmdom env) S\"\n  shows \"subst t env = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t env = t", "using assms"], ["proof (prove)\nusing this:\n  closed_except t S\n  fdisjnt (fmdom env) S\n\ngoal (1 subgoal):\n 1. subst t env = t", "by (metis fdisjnt_subset_right fmdom_drop_fset fminus_cancel fmrestrict_fset_dom\n          fmrestrict_fset_null closed_except_def subst_drop_fset subst_empty)"], ["", "lemma subst_closed_except_preserved:\n  assumes \"closed_except t S\" \"fdisjnt (fmdom env) S\"\n  shows \"closed_except (subst t env) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_except (subst t env) S", "using assms"], ["proof (prove)\nusing this:\n  closed_except t S\n  fdisjnt (fmdom env) S\n\ngoal (1 subgoal):\n 1. closed_except (subst t env) S", "by (metis subst_closed_except_id)"], ["", "corollary subst_closed_id: \"closed t \\<Longrightarrow> subst t env = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t \\<Longrightarrow> subst t env = t", "by (simp add: subst_closed_except_id fdisjnt_alt_def)"], ["", "corollary subst_closed_preserved: \"closed t \\<Longrightarrow> closed (subst t env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t \\<Longrightarrow> closed (subst t env)", "by (simp add: subst_closed_except_preserved fdisjnt_alt_def)"], ["", "context begin"], ["", "private"], ["", "lemma subst_indep0:\n  assumes \"closed_env env\\<^sub>2\" \"fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\"\n  shows \"subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) = subst (subst t env\\<^sub>2) env\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    subst (subst t env\\<^sub>2) env\\<^sub>1", "using assms"], ["proof (prove)\nusing this:\n  closed_env env\\<^sub>2\n  fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    subst (subst t env\\<^sub>2) env\\<^sub>1", "proof (induction t arbitrary: env\\<^sub>1 env\\<^sub>2 rule: raw_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (const name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (const name) env\\<^sub>2) env\\<^sub>1\n 2. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (free name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (free name) env\\<^sub>2) env\\<^sub>1\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>\\<And>env\\<^sub>1 env\\<^sub>2.\n                   \\<lbrakk>closed_env env\\<^sub>2;\n                    fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\n(env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                                     subst (subst t\\<^sub>1 env\\<^sub>2)\nenv\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           \\<lbrakk>closed_env env\\<^sub>2;\n            fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                             subst (subst t\\<^sub>2 env\\<^sub>2)\n                              env\\<^sub>1;\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (app t\\<^sub>1 t\\<^sub>2) env\\<^sub>2)\n                          env\\<^sub>1\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x xa.\n               closed_env xa \\<longrightarrow>\n               fdisjnt (fmdom x) (fmdom xa) \\<longrightarrow>\n               subst a (x ++\\<^sub>f xa) = subst (subst a xa) x)\n        t", "case (free name)"], ["proof (state)\nthis:\n  closed_env env\\<^sub>2\n  fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (const name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (const name) env\\<^sub>2) env\\<^sub>1\n 2. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (free name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (free name) env\\<^sub>2) env\\<^sub>1\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>\\<And>env\\<^sub>1 env\\<^sub>2.\n                   \\<lbrakk>closed_env env\\<^sub>2;\n                    fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\n(env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                                     subst (subst t\\<^sub>1 env\\<^sub>2)\nenv\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           \\<lbrakk>closed_env env\\<^sub>2;\n            fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                             subst (subst t\\<^sub>2 env\\<^sub>2)\n                              env\\<^sub>1;\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (app t\\<^sub>1 t\\<^sub>2) env\\<^sub>2)\n                          env\\<^sub>1\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x xa.\n               closed_env xa \\<longrightarrow>\n               fdisjnt (fmdom x) (fmdom xa) \\<longrightarrow>\n               subst a (x ++\\<^sub>f xa) = subst (subst a xa) x)\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (free name) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    subst (subst (free name) env\\<^sub>2) env\\<^sub>1", "using \\<open>closed_env env\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  closed_env env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst (free name) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    subst (subst (free name) env\\<^sub>2) env\\<^sub>1", "by (cases rule: fmpred_cases[where x = name]) (auto simp: subst_closed_id)"], ["proof (state)\nthis:\n  subst (free name) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  subst (subst (free name) env\\<^sub>2) env\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (const name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (const name) env\\<^sub>2) env\\<^sub>1\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>\\<And>env\\<^sub>1 env\\<^sub>2.\n                   \\<lbrakk>closed_env env\\<^sub>2;\n                    fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\n(env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                                     subst (subst t\\<^sub>1 env\\<^sub>2)\nenv\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           \\<lbrakk>closed_env env\\<^sub>2;\n            fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                             subst (subst t\\<^sub>2 env\\<^sub>2)\n                              env\\<^sub>1;\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (app t\\<^sub>1 t\\<^sub>2) env\\<^sub>2)\n                          env\\<^sub>1\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x xa.\n               closed_env xa \\<longrightarrow>\n               fdisjnt (fmdom x) (fmdom xa) \\<longrightarrow>\n               subst a (x ++\\<^sub>f xa) = subst (subst a xa) x)\n        t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (const name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (const name) env\\<^sub>2) env\\<^sub>1\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>\\<And>env\\<^sub>1 env\\<^sub>2.\n                   \\<lbrakk>closed_env env\\<^sub>2;\n                    fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\n(env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                                     subst (subst t\\<^sub>1 env\\<^sub>2)\nenv\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           \\<lbrakk>closed_env env\\<^sub>2;\n            fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                             subst (subst t\\<^sub>2 env\\<^sub>2)\n                              env\\<^sub>1;\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (app t\\<^sub>1 t\\<^sub>2) env\\<^sub>2)\n                          env\\<^sub>1\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x xa.\n               closed_env xa \\<longrightarrow>\n               fdisjnt (fmdom x) (fmdom xa) \\<longrightarrow>\n               subst a (x ++\\<^sub>f xa) = subst (subst a xa) x)\n        t", "case (abs t)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (const name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (const name) env\\<^sub>2) env\\<^sub>1\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>\\<And>env\\<^sub>1 env\\<^sub>2.\n                   \\<lbrakk>closed_env env\\<^sub>2;\n                    fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\n(env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                                     subst (subst t\\<^sub>1 env\\<^sub>2)\nenv\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           \\<lbrakk>closed_env env\\<^sub>2;\n            fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                             subst (subst t\\<^sub>2 env\\<^sub>2)\n                              env\\<^sub>1;\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (app t\\<^sub>1 t\\<^sub>2) env\\<^sub>2)\n                          env\\<^sub>1\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x xa.\n               closed_env xa \\<longrightarrow>\n               fdisjnt (fmdom x) (fmdom xa) \\<longrightarrow>\n               subst a (x ++\\<^sub>f xa) = subst (subst a xa) x)\n        t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_pred\n     (\\<lambda>a.\n         \\<forall>x xa.\n            closed_env xa \\<longrightarrow>\n            fdisjnt (fmdom x) (fmdom xa) \\<longrightarrow>\n            subst a (x ++\\<^sub>f xa) = subst (subst a xa) x)\n     t", "by (rule raw_subst_indep)"], ["proof (state)\nthis:\n  abs_pred\n   (\\<lambda>a.\n       \\<forall>x xa.\n          closed_env xa \\<longrightarrow>\n          fdisjnt (fmdom x) (fmdom xa) \\<longrightarrow>\n          subst a (x ++\\<^sub>f xa) = subst (subst a xa) x)\n   t\n\ngoal (2 subgoals):\n 1. \\<And>name env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (const name)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (const name) env\\<^sub>2) env\\<^sub>1\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 env\\<^sub>1 env\\<^sub>2.\n       \\<lbrakk>\\<And>env\\<^sub>1 env\\<^sub>2.\n                   \\<lbrakk>closed_env env\\<^sub>2;\n                    fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n                   \\<Longrightarrow> subst t\\<^sub>1\n(env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                                     subst (subst t\\<^sub>1 env\\<^sub>2)\nenv\\<^sub>1;\n        \\<And>env\\<^sub>1 env\\<^sub>2.\n           \\<lbrakk>closed_env env\\<^sub>2;\n            fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> subst t\\<^sub>2\n                              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                             subst (subst t\\<^sub>2 env\\<^sub>2)\n                              env\\<^sub>1;\n        closed_env env\\<^sub>2;\n        fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> subst (app t\\<^sub>1 t\\<^sub>2)\n                          (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                         subst (subst (app t\\<^sub>1 t\\<^sub>2) env\\<^sub>2)\n                          env\\<^sub>1", "qed auto"], ["", "lemma subst_indep:\n  assumes \"closed_env \\<Gamma>'\"\n  shows \"subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') = subst (subst t \\<Gamma>') \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "have \"subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') = subst t (fmrestrict_fset (frees t) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst t (fmrestrict_fset (frees t) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))", "by (metis subst_restrict')"], ["proof (state)\nthis:\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n  subst t (fmrestrict_fset (frees t) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "also"], ["proof (state)\nthis:\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n  subst t (fmrestrict_fset (frees t) (\\<Gamma> ++\\<^sub>f \\<Gamma>'))\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "have \"\\<dots> = subst t (fmrestrict_fset (frees t) \\<Gamma> ++\\<^sub>f \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset (frees t) (\\<Gamma> ++\\<^sub>f \\<Gamma>')) =\n    subst t (fmrestrict_fset (frees t) \\<Gamma> ++\\<^sub>f \\<Gamma>')", "by (smt fmlookup_add fmlookup_restrict_fset subst_cong)"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset (frees t) (\\<Gamma> ++\\<^sub>f \\<Gamma>')) =\n  subst t (fmrestrict_fset (frees t) \\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "also"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset (frees t) (\\<Gamma> ++\\<^sub>f \\<Gamma>')) =\n  subst t (fmrestrict_fset (frees t) \\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "have \"\\<dots> = subst t (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma> ++\\<^sub>f \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (fmrestrict_fset (frees t) \\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst t\n     (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma> ++\\<^sub>f\n      \\<Gamma>')", "by (rule subst_cong) (simp add: fmfilter_alt_defs(5))"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset (frees t) \\<Gamma> ++\\<^sub>f \\<Gamma>') =\n  subst t\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma> ++\\<^sub>f\n    \\<Gamma>')\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "also"], ["proof (state)\nthis:\n  subst t (fmrestrict_fset (frees t) \\<Gamma> ++\\<^sub>f \\<Gamma>') =\n  subst t\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma> ++\\<^sub>f\n    \\<Gamma>')\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "have \"\\<dots> = subst (subst t \\<Gamma>') (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t\n     (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma> ++\\<^sub>f\n      \\<Gamma>') =\n    subst (subst t \\<Gamma>')\n     (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>)", "apply (rule subst_indep0[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fmdom (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>))\n     (fmdom \\<Gamma>')", "using fmdom_restrict_fset"], ["proof (prove)\nusing this:\n  fmdom (fmrestrict_fset ?A ?m) |\\<subseteq>| ?A\n\ngoal (1 subgoal):\n 1. fdisjnt (fmdom (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>))\n     (fmdom \\<Gamma>')", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  fmdom (fmrestrict_fset ?A ?m) |\\<subseteq>| ?A\n\ngoal (1 subgoal):\n 1. fmdom\n     (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>) |\\<inter>|\n    fmdom \\<Gamma>' =\n    {||}", "by auto"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma> ++\\<^sub>f\n    \\<Gamma>') =\n  subst (subst t \\<Gamma>')\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>)\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "also"], ["proof (state)\nthis:\n  subst t\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma> ++\\<^sub>f\n    \\<Gamma>') =\n  subst (subst t \\<Gamma>')\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>)\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "have \"\\<dots> = subst (subst t \\<Gamma>') (fmrestrict_fset (frees (subst t \\<Gamma>')) \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>')\n     (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>) =\n    subst (subst t \\<Gamma>')\n     (fmrestrict_fset (frees (subst t \\<Gamma>')) \\<Gamma>)", "using assms"], ["proof (prove)\nusing this:\n  closed_env \\<Gamma>'\n\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>')\n     (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>) =\n    subst (subst t \\<Gamma>')\n     (fmrestrict_fset (frees (subst t \\<Gamma>')) \\<Gamma>)", "by (auto simp: subst_frees)"], ["proof (state)\nthis:\n  subst (subst t \\<Gamma>')\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>) =\n  subst (subst t \\<Gamma>')\n   (fmrestrict_fset (frees (subst t \\<Gamma>')) \\<Gamma>)\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "also"], ["proof (state)\nthis:\n  subst (subst t \\<Gamma>')\n   (fmrestrict_fset (frees t |-| fmdom \\<Gamma>') \\<Gamma>) =\n  subst (subst t \\<Gamma>')\n   (fmrestrict_fset (frees (subst t \\<Gamma>')) \\<Gamma>)\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "have \"\\<dots> = subst (subst t \\<Gamma>') \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>')\n     (fmrestrict_fset (frees (subst t \\<Gamma>')) \\<Gamma>) =\n    subst (subst t \\<Gamma>') \\<Gamma>", "by simp"], ["proof (state)\nthis:\n  subst (subst t \\<Gamma>')\n   (fmrestrict_fset (frees (subst t \\<Gamma>')) \\<Gamma>) =\n  subst (subst t \\<Gamma>') \\<Gamma>\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "finally"], ["proof (chain)\npicking this:\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n  subst (subst t \\<Gamma>') \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n  subst (subst t \\<Gamma>') \\<Gamma>\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n    subst (subst t \\<Gamma>') \\<Gamma>", "."], ["proof (state)\nthis:\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') =\n  subst (subst t \\<Gamma>') \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_indep':\n  assumes \"closed_env \\<Gamma>'\" \"fdisjnt (fmdom \\<Gamma>') (fmdom \\<Gamma>)\"\n  shows \"subst t (\\<Gamma>' ++\\<^sub>f \\<Gamma>) = subst (subst t \\<Gamma>') \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (\\<Gamma>' ++\\<^sub>f \\<Gamma>) =\n    subst (subst t \\<Gamma>') \\<Gamma>", "using assms"], ["proof (prove)\nusing this:\n  closed_env \\<Gamma>'\n  fdisjnt (fmdom \\<Gamma>') (fmdom \\<Gamma>)\n\ngoal (1 subgoal):\n 1. subst t (\\<Gamma>' ++\\<^sub>f \\<Gamma>) =\n    subst (subst t \\<Gamma>') \\<Gamma>", "by (metis subst_indep fmadd_disjnt)"], ["", "lemma subst_twice:\n  assumes \"\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\" \"closed_env \\<Gamma>'\"\n  shows \"subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>", "have \"subst (subst t \\<Gamma>') \\<Gamma> = subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>') \\<Gamma> =\n    subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>')", "apply (rule subst_indep[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_env \\<Gamma>'", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst (subst t \\<Gamma>') \\<Gamma> =\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>", "also"], ["proof (state)\nthis:\n  subst (subst t \\<Gamma>') \\<Gamma> =\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>')\n\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>", "have \"\\<dots> = subst t \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') = subst t \\<Gamma>", "apply (rule subst_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees t \\<Longrightarrow>\n       fmlookup (\\<Gamma> ++\\<^sub>f \\<Gamma>') x = fmlookup \\<Gamma> x", "using \\<open>\\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  \\<Gamma>' \\<subseteq>\\<^sub>f \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees t \\<Longrightarrow>\n       fmlookup (\\<Gamma> ++\\<^sub>f \\<Gamma>') x = fmlookup \\<Gamma> x", "unfolding fmsubset_alt_def"], ["proof (prove)\nusing this:\n  fmpred (\\<lambda>k v. fmlookup \\<Gamma> k = Some v) \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>| frees t \\<Longrightarrow>\n       fmlookup (\\<Gamma> ++\\<^sub>f \\<Gamma>') x = fmlookup \\<Gamma> x", "by fastforce"], ["proof (state)\nthis:\n  subst t (\\<Gamma> ++\\<^sub>f \\<Gamma>') = subst t \\<Gamma>\n\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>", "finally"], ["proof (chain)\npicking this:\n  subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>\n\ngoal (1 subgoal):\n 1. subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>", "."], ["proof (state)\nthis:\n  subst (subst t \\<Gamma>') \\<Gamma> = subst t \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "fun matchs :: \"term list \\<Rightarrow> 'a list \\<Rightarrow> (name, 'a) fmap option\" where\n\"matchs [] [] = Some fmempty\" |\n\"matchs (t # ts) (u # us) = do { env\\<^sub>1 \\<leftarrow> match t u; env\\<^sub>2 \\<leftarrow> matchs ts us; Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) }\" |\n\"matchs _ _ = None\""], ["", "lemmas matchs_induct = matchs.induct[case_names empty cons]"], ["", "context begin"], ["", "private"], ["", "lemma matchs_alt_def0:\n  assumes \"length ps = length vs\"\n  shows \"map_option (\\<lambda>env. m ++\\<^sub>f env) (matchs ps vs) = map_option (foldl (++\\<^sub>f) m) (those (map2 match ps vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option ((++\\<^sub>f) m) (matchs ps vs) =\n    map_option (foldl (++\\<^sub>f) m) (those (Term_Utils.map2 match ps vs))", "using assms"], ["proof (prove)\nusing this:\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. map_option ((++\\<^sub>f) m) (matchs ps vs) =\n    map_option (foldl (++\\<^sub>f) m) (those (Term_Utils.map2 match ps vs))", "proof (induction arbitrary: m rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       map_option ((++\\<^sub>f) m) (matchs [] []) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match [] []))\n 2. \\<And>x xs y ys m.\n       \\<lbrakk>length xs = length ys;\n        \\<And>m.\n           map_option ((++\\<^sub>f) m) (matchs xs ys) =\n           map_option (foldl (++\\<^sub>f) m)\n            (those (Term_Utils.map2 match xs ys))\\<rbrakk>\n       \\<Longrightarrow> map_option ((++\\<^sub>f) m)\n                          (matchs (x # xs) (y # ys)) =\n                         map_option (foldl (++\\<^sub>f) m)\n                          (those (Term_Utils.map2 match (x # xs) (y # ys)))", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  map_option ((++\\<^sub>f) ?m) (matchs xs ys) =\n  map_option (foldl (++\\<^sub>f) ?m) (those (Term_Utils.map2 match xs ys))\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       map_option ((++\\<^sub>f) m) (matchs [] []) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match [] []))\n 2. \\<And>x xs y ys m.\n       \\<lbrakk>length xs = length ys;\n        \\<And>m.\n           map_option ((++\\<^sub>f) m) (matchs xs ys) =\n           map_option (foldl (++\\<^sub>f) m)\n            (those (Term_Utils.map2 match xs ys))\\<rbrakk>\n       \\<Longrightarrow> map_option ((++\\<^sub>f) m)\n                          (matchs (x # xs) (y # ys)) =\n                         map_option (foldl (++\\<^sub>f) m)\n                          (those (Term_Utils.map2 match (x # xs) (y # ys)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))", "proof (cases \"match x y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. match x y = None \\<Longrightarrow>\n    map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))\n 2. \\<And>a.\n       match x y = Some a \\<Longrightarrow>\n       map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match (x # xs) (y # ys)))", "case x_y: Some"], ["proof (state)\nthis:\n  match x y = Some a_\n\ngoal (2 subgoals):\n 1. match x y = None \\<Longrightarrow>\n    map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))\n 2. \\<And>a.\n       match x y = Some a \\<Longrightarrow>\n       map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match (x # xs) (y # ys)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))", "proof (cases \"matchs xs ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. matchs xs ys = None \\<Longrightarrow>\n    map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))\n 2. \\<And>a.\n       matchs xs ys = Some a \\<Longrightarrow>\n       map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match (x # xs) (y # ys)))", "case None"], ["proof (state)\nthis:\n  matchs xs ys = None\n\ngoal (2 subgoals):\n 1. matchs xs ys = None \\<Longrightarrow>\n    map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))\n 2. \\<And>a.\n       matchs xs ys = Some a \\<Longrightarrow>\n       map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match (x # xs) (y # ys)))", "with x_y Cons"], ["proof (chain)\npicking this:\n  match x y = Some a_\n  length xs = length ys\n  map_option ((++\\<^sub>f) ?m) (matchs xs ys) =\n  map_option (foldl (++\\<^sub>f) ?m) (those (Term_Utils.map2 match xs ys))\n  matchs xs ys = None", "show ?thesis"], ["proof (prove)\nusing this:\n  match x y = Some a_\n  length xs = length ys\n  map_option ((++\\<^sub>f) ?m) (matchs xs ys) =\n  map_option (foldl (++\\<^sub>f) ?m) (those (Term_Utils.map2 match xs ys))\n  matchs xs ys = None\n\ngoal (1 subgoal):\n 1. map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))", "by simp"], ["proof (state)\nthis:\n  map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n  map_option (foldl (++\\<^sub>f) m)\n   (those (Term_Utils.map2 match (x # xs) (y # ys)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       matchs xs ys = Some a \\<Longrightarrow>\n       map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match (x # xs) (y # ys)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       matchs xs ys = Some a \\<Longrightarrow>\n       map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match (x # xs) (y # ys)))", "case Some"], ["proof (state)\nthis:\n  matchs xs ys = Some a_\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       matchs xs ys = Some a \\<Longrightarrow>\n       map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match (x # xs) (y # ys)))", "with x_y"], ["proof (chain)\npicking this:\n  match x y = Some a___\n  matchs xs ys = Some a_", "show ?thesis"], ["proof (prove)\nusing this:\n  match x y = Some a___\n  matchs xs ys = Some a_\n\ngoal (1 subgoal):\n 1. map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match x y = Some a___; matchs xs ys = Some a_\\<rbrakk>\n    \\<Longrightarrow> Some (m ++\\<^sub>f a___ ++\\<^sub>f a_) =\n                      map_option (foldl (++\\<^sub>f) m)\n                       (map_option ((#) a___)\n                         (those (Term_Utils.map2 match xs ys)))", "using Cons(2)"], ["proof (prove)\nusing this:\n  map_option ((++\\<^sub>f) ?m) (matchs xs ys) =\n  map_option (foldl (++\\<^sub>f) ?m) (those (Term_Utils.map2 match xs ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match x y = Some a___; matchs xs ys = Some a_\\<rbrakk>\n    \\<Longrightarrow> Some (m ++\\<^sub>f a___ ++\\<^sub>f a_) =\n                      map_option (foldl (++\\<^sub>f) m)\n                       (map_option ((#) a___)\n                         (those (Term_Utils.map2 match xs ys)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match x y = Some a___; matchs xs ys = Some a_;\n     \\<And>m.\n        Some (m ++\\<^sub>f a_) =\n        map_option (foldl (++\\<^sub>f) m)\n         (those (Term_Utils.map2 match xs ys))\\<rbrakk>\n    \\<Longrightarrow> map_option (foldl (++\\<^sub>f) (m ++\\<^sub>f a___))\n                       (those (Term_Utils.map2 match xs ys)) =\n                      map_option (foldl (++\\<^sub>f) m)\n                       (map_option ((#) a___)\n                         (those (Term_Utils.map2 match xs ys)))", "apply (subst option.map_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match x y = Some a___; matchs xs ys = Some a_;\n     \\<And>m.\n        Some (m ++\\<^sub>f a_) =\n        map_option (foldl (++\\<^sub>f) m)\n         (those (Term_Utils.map2 match xs ys))\\<rbrakk>\n    \\<Longrightarrow> map_option (foldl (++\\<^sub>f) (m ++\\<^sub>f a___))\n                       (those (Term_Utils.map2 match xs ys)) =\n                      map_option (foldl (++\\<^sub>f) m \\<circ> (#) a___)\n                       (those (Term_Utils.map2 match xs ys))", "by (auto cong: map_option_cong)"], ["proof (state)\nthis:\n  map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n  map_option (foldl (++\\<^sub>f) m)\n   (those (Term_Utils.map2 match (x # xs) (y # ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n  map_option (foldl (++\\<^sub>f) m)\n   (those (Term_Utils.map2 match (x # xs) (y # ys)))\n\ngoal (1 subgoal):\n 1. match x y = None \\<Longrightarrow>\n    map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n    map_option (foldl (++\\<^sub>f) m)\n     (those (Term_Utils.map2 match (x # xs) (y # ys)))", "qed simp"], ["proof (state)\nthis:\n  map_option ((++\\<^sub>f) m) (matchs (x # xs) (y # ys)) =\n  map_option (foldl (++\\<^sub>f) m)\n   (those (Term_Utils.map2 match (x # xs) (y # ys)))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       map_option ((++\\<^sub>f) m) (matchs [] []) =\n       map_option (foldl (++\\<^sub>f) m)\n        (those (Term_Utils.map2 match [] []))", "qed simp"], ["", "lemma matchs_alt_def:\n  assumes \"length ps = length vs\"\n  shows \"matchs ps vs = map_option (foldl (++\\<^sub>f) fmempty) (those (map2 match ps vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchs ps vs =\n    map_option (foldl (++\\<^sub>f) fmempty)\n     (those (Term_Utils.map2 match ps vs))", "by (subst matchs_alt_def0[where m = fmempty, simplified, symmetric, OF assms])\n   (simp add: option.map_ident)"], ["", "end"], ["", "lemma matchs_neq_length_none[simp]: \"length xs \\<noteq> length ys \\<Longrightarrow> matchs xs ys = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<noteq> length ys \\<Longrightarrow> matchs xs ys = None", "by (induct xs ys rule: matchs.induct) fastforce+"], ["", "corollary matchs_some_eq_length: \"matchs xs ys = Some env \\<Longrightarrow> length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchs xs ys = Some env \\<Longrightarrow> length xs = length ys", "by (metis option.distinct(1) matchs_neq_length_none)"], ["", "lemma matchs_app[simp]:\n  assumes \"length xs\\<^sub>2 = length ys\\<^sub>2\"\n  shows \"matchs (xs\\<^sub>1 @ xs\\<^sub>2) (ys\\<^sub>1 @ ys\\<^sub>2) =\n          matchs xs\\<^sub>1 ys\\<^sub>1 \\<bind> (\\<lambda>env\\<^sub>1. matchs xs\\<^sub>2 ys\\<^sub>2 \\<bind> (\\<lambda>env\\<^sub>2. Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchs (xs\\<^sub>1 @ xs\\<^sub>2) (ys\\<^sub>1 @ ys\\<^sub>2) =\n    matchs xs\\<^sub>1 ys\\<^sub>1 \\<bind>\n    (\\<lambda>env\\<^sub>1.\n        matchs xs\\<^sub>2 ys\\<^sub>2 \\<bind>\n        (\\<lambda>env\\<^sub>2. Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)))", "using assms"], ["proof (prove)\nusing this:\n  length xs\\<^sub>2 = length ys\\<^sub>2\n\ngoal (1 subgoal):\n 1. matchs (xs\\<^sub>1 @ xs\\<^sub>2) (ys\\<^sub>1 @ ys\\<^sub>2) =\n    matchs xs\\<^sub>1 ys\\<^sub>1 \\<bind>\n    (\\<lambda>env\\<^sub>1.\n        matchs xs\\<^sub>2 ys\\<^sub>2 \\<bind>\n        (\\<lambda>env\\<^sub>2. Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)))", "by (induct xs\\<^sub>1 ys\\<^sub>1 rule: matchs.induct) fastforce+"], ["", "corollary matchs_appI:\n  assumes \"matchs xs ys = Some env\\<^sub>1\" \"matchs xs' ys' = Some env\\<^sub>2\"\n  shows \"matchs (xs @ xs') (ys @ ys') = Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchs (xs @ xs') (ys @ ys') = Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  matchs xs ys = Some env\\<^sub>1\n  matchs xs' ys' = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. matchs (xs @ xs') (ys @ ys') = Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "by (metis (no_types, lifting) Option.bind_lunit matchs_app matchs_some_eq_length)"], ["", "corollary matchs_dom:\n  assumes \"matchs ps ts = Some env\"\n  shows \"fmdom env = freess ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom env = freess ps", "using assms"], ["proof (prove)\nusing this:\n  matchs ps ts = Some env\n\ngoal (1 subgoal):\n 1. fmdom env = freess ps", "by (induction ps ts arbitrary: env rule: matchs_induct)\n   (auto simp: match_dom elim!: option_bindE)"], ["", "fun find_match :: \"(term \\<times> 'a) list \\<Rightarrow> 'a \\<Rightarrow> ((name, 'a) fmap \\<times> term \\<times> 'a) option\" where\n\"find_match [] _ = None\" |\n\"find_match ((pat, rhs) # cs) t =\n  (case match pat t of\n    Some env \\<Rightarrow> Some (env, pat, rhs)\n  | None \\<Rightarrow> find_match cs t)\""], ["", "lemma find_match_map:\n  \"find_match (map (\\<lambda>(pat, t). (pat, f pat t)) cs) t =\n    map_option (\\<lambda>(env, pat, rhs). (env, pat, f pat rhs)) (find_match cs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_match (map (\\<lambda>(pat, t). (pat, f pat t)) cs) t =\n    map_option (\\<lambda>(env, pat, rhs). (env, pat, f pat rhs))\n     (find_match cs t)", "by (induct cs) (auto split: option.splits)"], ["", "lemma find_match_elem:\n  assumes \"find_match cs t = Some (env, pat, rhs)\"\n  shows \"(pat, rhs) \\<in> set cs\" \"match pat t = Some env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& match pat t = Some env", "using assms"], ["proof (prove)\nusing this:\n  find_match cs t = Some (env, pat, rhs)\n\ngoal (1 subgoal):\n 1. (pat, rhs) \\<in> set cs &&& match pat t = Some env", "by (induct cs) (auto split: option.splits)"], ["", "lemma match_subst_closed:\n  assumes \"match pat t = Some env\" \"closed_except rhs (frees pat)\" \"closed t\"\n  shows \"closed (subst rhs env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (subst rhs env)", "using assms"], ["proof (prove)\nusing this:\n  match pat t = Some env\n  closed_except rhs (frees pat)\n  closed t\n\ngoal (1 subgoal):\n 1. closed (subst rhs env)", "by (smt fminusE fmpred_iff fset_mp fsubsetI closed_except_def match_vars match_dom subst_frees)"], ["", "fun rewrite_step :: \"(term \\<times> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a option\" where\n\"rewrite_step (t\\<^sub>1, t\\<^sub>2) u = map_option (subst t\\<^sub>2) (match t\\<^sub>1 u)\""], ["", "abbreviation rewrite_step' :: \"(term \\<times> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (\"_/ \\<turnstile>/ _ \\<rightarrow>/ _\" [50,0,50] 50) where\n\"r \\<turnstile> t \\<rightarrow> u \\<equiv> rewrite_step r t = Some u\""], ["", "lemma rewrite_step_closed:\n  assumes \"frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\" \"(t\\<^sub>1, t\\<^sub>2) \\<turnstile> u \\<rightarrow> u'\" \"closed u\"\n  shows \"closed u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed u'", "from assms"], ["proof (chain)\npicking this:\n  frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\n  (t\\<^sub>1, t\\<^sub>2) \\<turnstile> u \\<rightarrow> u'\n  closed u", "obtain env where *: \"match t\\<^sub>1 u = Some env\""], ["proof (prove)\nusing this:\n  frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\n  (t\\<^sub>1, t\\<^sub>2) \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        match t\\<^sub>1 u = Some env \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  match t\\<^sub>1 u = Some env\n\ngoal (1 subgoal):\n 1. closed u'", "then"], ["proof (chain)\npicking this:\n  match t\\<^sub>1 u = Some env", "have \"closed (subst t\\<^sub>2 env)\""], ["proof (prove)\nusing this:\n  match t\\<^sub>1 u = Some env\n\ngoal (1 subgoal):\n 1. closed (subst t\\<^sub>2 env)", "apply (rule match_subst_closed[where pat = t\\<^sub>1 and t = u])"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_except t\\<^sub>2 (frees t\\<^sub>1)\n 2. closed u", "using assms"], ["proof (prove)\nusing this:\n  frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\n  (t\\<^sub>1, t\\<^sub>2) \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (2 subgoals):\n 1. closed_except t\\<^sub>2 (frees t\\<^sub>1)\n 2. closed u", "unfolding closed_except_def"], ["proof (prove)\nusing this:\n  frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\n  (t\\<^sub>1, t\\<^sub>2) \\<turnstile> u \\<rightarrow> u'\n  frees u |\\<subseteq>| {||}\n\ngoal (2 subgoals):\n 1. frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\n 2. frees u |\\<subseteq>| {||}", "by auto"], ["proof (state)\nthis:\n  closed (subst t\\<^sub>2 env)\n\ngoal (1 subgoal):\n 1. closed u'", "with *"], ["proof (chain)\npicking this:\n  match t\\<^sub>1 u = Some env\n  closed (subst t\\<^sub>2 env)", "show ?thesis"], ["proof (prove)\nusing this:\n  match t\\<^sub>1 u = Some env\n  closed (subst t\\<^sub>2 env)\n\ngoal (1 subgoal):\n 1. closed u'", "using assms"], ["proof (prove)\nusing this:\n  match t\\<^sub>1 u = Some env\n  closed (subst t\\<^sub>2 env)\n  frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1\n  (t\\<^sub>1, t\\<^sub>2) \\<turnstile> u \\<rightarrow> u'\n  closed u\n\ngoal (1 subgoal):\n 1. closed u'", "by auto"], ["proof (state)\nthis:\n  closed u'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition matches :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \"\\<lesssim>\" 50) where\n\"t \\<lesssim> u \\<longleftrightarrow> (\\<exists>env. subst t env = u)\""], ["", "lemma matchesI[intro]: \"subst t env = u \\<Longrightarrow> t \\<lesssim> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t env = u \\<Longrightarrow> t \\<lesssim> u", "unfolding matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t env = u \\<Longrightarrow> \\<exists>env. subst t env = u", "by auto"], ["", "lemma matchesE[elim]:\n  assumes \"t \\<lesssim> u\"\n  obtains env where \"subst t env = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>env. subst t env = u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  t \\<lesssim> u\n\ngoal (1 subgoal):\n 1. (\\<And>env. subst t env = u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding matches_def"], ["proof (prove)\nusing this:\n  \\<exists>env. subst t env = u\n\ngoal (1 subgoal):\n 1. (\\<And>env. subst t env = u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "definition overlapping :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n\"overlapping s t \\<longleftrightarrow> (\\<exists>u. s \\<lesssim> u \\<and> t \\<lesssim> u)\""], ["", "lemma overlapping_refl: \"overlapping t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. overlapping t t", "unfolding overlapping_def matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       (\\<exists>env. subst t env = u) \\<and>\n       (\\<exists>env. subst t env = u)", "by blast"], ["", "lemma overlapping_sym: \"overlapping t u \\<Longrightarrow> overlapping u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. overlapping t u \\<Longrightarrow> overlapping u t", "unfolding overlapping_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ua. t \\<lesssim> ua \\<and> u \\<lesssim> ua \\<Longrightarrow>\n    \\<exists>ua. u \\<lesssim> ua \\<and> t \\<lesssim> ua", "by auto"], ["", "lemma overlappingI[intro]: \"s \\<lesssim> u \\<Longrightarrow> t \\<lesssim> u \\<Longrightarrow> overlapping s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<lesssim> u; t \\<lesssim> u\\<rbrakk>\n    \\<Longrightarrow> overlapping s t", "unfolding overlapping_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<lesssim> u; t \\<lesssim> u\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. s \\<lesssim> u \\<and> t \\<lesssim> u", "by auto"], ["", "lemma overlappingE[elim]:\n  assumes \"overlapping s t\"\n  obtains u where \"s \\<lesssim> u\" \"t \\<lesssim> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s \\<lesssim> u; t \\<lesssim> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  overlapping s t\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s \\<lesssim> u; t \\<lesssim> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding overlapping_def"], ["proof (prove)\nusing this:\n  \\<exists>u. s \\<lesssim> u \\<and> t \\<lesssim> u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>s \\<lesssim> u; t \\<lesssim> u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "abbreviation \"non_overlapping s t \\<equiv> \\<not> overlapping s t\""], ["", "corollary non_overlapping_implies_neq: \"non_overlapping t u \\<Longrightarrow> t \\<noteq> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_overlapping t u \\<Longrightarrow> t \\<noteq> u", "by (metis overlapping_refl)"], ["", "end"], ["", "inductive rewrite_first :: \"(term \\<times> 'a::term) list \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\nmatch: \"match pat t = Some env \\<Longrightarrow> rewrite_first ((pat, rhs) # _) t (subst rhs env)\" |\nnomatch: \"match pat t = None \\<Longrightarrow> rewrite_first cs t t' \\<Longrightarrow> rewrite_first ((pat, _) # cs) t t'\""], ["", "code_pred (modes: i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) rewrite_first"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma rewrite_firstE:\n  assumes \"rewrite_first cs t t'\"\n  obtains pat rhs env where \"(pat, rhs) \\<in> set cs\" \"match pat t = Some env\" \"t' = subst rhs env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat rhs env.\n        \\<lbrakk>(pat, rhs) \\<in> set cs; match pat t = Some env;\n         t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  rewrite_first cs t t'\n\ngoal (1 subgoal):\n 1. (\\<And>pat rhs env.\n        \\<lbrakk>(pat, rhs) \\<in> set cs; match pat t = Some env;\n         t' = subst rhs env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induction auto"], ["", "text \\<open>\n  This doesn't follow from @{thm [source] find_match_elem}, because @{const rewrite_first} requires\n  the first match, not just any.\n\\<close>"], ["", "lemma find_match_rewrite_first:\n  assumes \"find_match cs t = Some (env, pat, rhs)\"\n  shows \"rewrite_first cs t (subst rhs env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rewrite_first cs t (subst rhs env)", "using assms"], ["proof (prove)\nusing this:\n  find_match cs t = Some (env, pat, rhs)\n\ngoal (1 subgoal):\n 1. rewrite_first cs t (subst rhs env)", "proof (induction cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_match [] t = Some (env, pat, rhs) \\<Longrightarrow>\n    rewrite_first [] t (subst rhs env)\n 2. \\<And>a cs.\n       \\<lbrakk>find_match cs t = Some (env, pat, rhs) \\<Longrightarrow>\n                rewrite_first cs t (subst rhs env);\n        find_match (a # cs) t = Some (env, pat, rhs)\\<rbrakk>\n       \\<Longrightarrow> rewrite_first (a # cs) t (subst rhs env)", "case (Cons c cs)"], ["proof (state)\nthis:\n  find_match cs t = Some (env, pat, rhs) \\<Longrightarrow>\n  rewrite_first cs t (subst rhs env)\n  find_match (c # cs) t = Some (env, pat, rhs)\n\ngoal (2 subgoals):\n 1. find_match [] t = Some (env, pat, rhs) \\<Longrightarrow>\n    rewrite_first [] t (subst rhs env)\n 2. \\<And>a cs.\n       \\<lbrakk>find_match cs t = Some (env, pat, rhs) \\<Longrightarrow>\n                rewrite_first cs t (subst rhs env);\n        find_match (a # cs) t = Some (env, pat, rhs)\\<rbrakk>\n       \\<Longrightarrow> rewrite_first (a # cs) t (subst rhs env)", "obtain pat0 rhs0 where \"c = (pat0, rhs0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pat0 rhs0.\n        c = (pat0, rhs0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  c = (pat0, rhs0)\n\ngoal (2 subgoals):\n 1. find_match [] t = Some (env, pat, rhs) \\<Longrightarrow>\n    rewrite_first [] t (subst rhs env)\n 2. \\<And>a cs.\n       \\<lbrakk>find_match cs t = Some (env, pat, rhs) \\<Longrightarrow>\n                rewrite_first cs t (subst rhs env);\n        find_match (a # cs) t = Some (env, pat, rhs)\\<rbrakk>\n       \\<Longrightarrow> rewrite_first (a # cs) t (subst rhs env)", "thus ?case"], ["proof (prove)\nusing this:\n  c = (pat0, rhs0)\n\ngoal (1 subgoal):\n 1. rewrite_first (c # cs) t (subst rhs env)", "using Cons"], ["proof (prove)\nusing this:\n  c = (pat0, rhs0)\n  find_match cs t = Some (env, pat, rhs) \\<Longrightarrow>\n  rewrite_first cs t (subst rhs env)\n  find_match (c # cs) t = Some (env, pat, rhs)\n\ngoal (1 subgoal):\n 1. rewrite_first (c # cs) t (subst rhs env)", "by (cases \"match pat0 t\") (auto intro: rewrite_first.intros)"], ["proof (state)\nthis:\n  rewrite_first (c # cs) t (subst rhs env)\n\ngoal (1 subgoal):\n 1. find_match [] t = Some (env, pat, rhs) \\<Longrightarrow>\n    rewrite_first [] t (subst rhs env)", "qed simp"], ["", "definition term_cases :: \"(name \\<Rightarrow> 'b) \\<Rightarrow> (name \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'a::term \\<Rightarrow> 'b\" where\n\"term_cases if_const if_free if_app otherwise t =\n  (case unconst t of\n    Some name \\<Rightarrow> if_const name |\n    None \\<Rightarrow> (case unfree t of\n      Some name \\<Rightarrow> if_free name |\n      None \\<Rightarrow>\n        (case unapp t of\n          Some (t, u) \\<Rightarrow> if_app t u\n        | None \\<Rightarrow> otherwise)))\""], ["", "lemma term_cases_cong[fundef_cong]:\n  assumes \"t = u\" \"otherwise1 = otherwise2\"\n  assumes \"(\\<And>name. t = const name \\<Longrightarrow> if_const1 name = if_const2 name)\"\n  assumes \"(\\<And>name. t = free name \\<Longrightarrow> if_free1 name = if_free2 name)\"\n  assumes \"(\\<And>u\\<^sub>1 u\\<^sub>2. t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> if_app1 u\\<^sub>1 u\\<^sub>2 = if_app2 u\\<^sub>1 u\\<^sub>2)\"\n  shows \"term_cases if_const1 if_free1 if_app1 otherwise1 t = term_cases if_const2 if_free2 if_app2 otherwise2 u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_cases if_const1 if_free1 if_app1 otherwise1 t =\n    term_cases if_const2 if_free2 if_app2 otherwise2 u", "using assms"], ["proof (prove)\nusing this:\n  t = u\n  otherwise1 = otherwise2\n  t = const ?name \\<Longrightarrow> if_const1 ?name = if_const2 ?name\n  t = free ?name \\<Longrightarrow> if_free1 ?name = if_free2 ?name\n  t = app ?u\\<^sub>1 ?u\\<^sub>2 \\<Longrightarrow>\n  if_app1 ?u\\<^sub>1 ?u\\<^sub>2 = if_app2 ?u\\<^sub>1 ?u\\<^sub>2\n\ngoal (1 subgoal):\n 1. term_cases if_const1 if_free1 if_app1 otherwise1 t =\n    term_cases if_const2 if_free2 if_app2 otherwise2 u", "unfolding term_cases_def"], ["proof (prove)\nusing this:\n  t = u\n  otherwise1 = otherwise2\n  t = const ?name \\<Longrightarrow> if_const1 ?name = if_const2 ?name\n  t = free ?name \\<Longrightarrow> if_free1 ?name = if_free2 ?name\n  t = app ?u\\<^sub>1 ?u\\<^sub>2 \\<Longrightarrow>\n  if_app1 ?u\\<^sub>1 ?u\\<^sub>2 = if_app2 ?u\\<^sub>1 ?u\\<^sub>2\n\ngoal (1 subgoal):\n 1. (case unconst t of\n     None \\<Rightarrow>\n       case unfree t of\n       None \\<Rightarrow>\n         case unapp t of None \\<Rightarrow> otherwise1\n         | Some (xa, xb) \\<Rightarrow> if_app1 xa xb\n       | Some x \\<Rightarrow> if_free1 x\n     | Some x \\<Rightarrow> if_const1 x) =\n    (case unconst u of\n     None \\<Rightarrow>\n       case unfree u of\n       None \\<Rightarrow>\n         case unapp u of None \\<Rightarrow> otherwise2\n         | Some (xa, xb) \\<Rightarrow> if_app2 xa xb\n       | Some x \\<Rightarrow> if_free2 x\n     | Some x \\<Rightarrow> if_const2 x)", "by (auto split: option.splits)"], ["", "lemma term_cases[simp]:\n  \"term_cases if_const if_free if_app otherwise (const name) = if_const name\"\n  \"term_cases if_const if_free if_app otherwise (free name) = if_free name\"\n  \"term_cases if_const if_free if_app otherwise (app t u) = if_app t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_cases if_const if_free if_app otherwise (const name) =\n    if_const name &&&\n    term_cases if_const if_free if_app otherwise (free name) =\n    if_free name &&&\n    term_cases if_const if_free if_app otherwise (app t u) = if_app t u", "unfolding term_cases_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case unconst (const name) of\n     None \\<Rightarrow>\n       case unfree (const name) of\n       None \\<Rightarrow>\n         case unapp (const name) of None \\<Rightarrow> otherwise\n         | Some (xa, xb) \\<Rightarrow> if_app xa xb\n       | Some x \\<Rightarrow> if_free x\n     | Some x \\<Rightarrow> if_const x) =\n    if_const name &&&\n    (case unconst (free name) of\n     None \\<Rightarrow>\n       case unfree (free name) of\n       None \\<Rightarrow>\n         case unapp (free name) of None \\<Rightarrow> otherwise\n         | Some (xa, xb) \\<Rightarrow> if_app xa xb\n       | Some x \\<Rightarrow> if_free x\n     | Some x \\<Rightarrow> if_const x) =\n    if_free name &&&\n    (case unconst (app t u) of\n     None \\<Rightarrow>\n       case unfree (app t u) of\n       None \\<Rightarrow>\n         case unapp (app t u) of None \\<Rightarrow> otherwise\n         | Some (xa, xb) \\<Rightarrow> if_app xa xb\n       | Some x \\<Rightarrow> if_free x\n     | Some x \\<Rightarrow> if_const x) =\n    if_app t u", "by (auto split: option.splits)"], ["", "lemma term_cases_template:\n  assumes \"\\<And>x. f x = term_cases if_const if_free if_app otherwise x\"\n  shows \"f (const name) = if_const name\"\n    and \"f (free name) = if_free name\"\n    and \"f (app t u) = if_app t u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (const name) = if_const name &&&\n    f (free name) = if_free name &&& f (app t u) = if_app t u", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_cases if_const if_free if_app otherwise (const name) =\n    if_const name &&&\n    term_cases if_const if_free if_app otherwise (free name) =\n    if_free name &&&\n    term_cases if_const if_free if_app otherwise (app t u) = if_app t u", "by (rule term_cases)+"], ["", "context \"term\" begin"], ["", "function (sequential) strip_comb :: \"'a \\<Rightarrow> 'a \\<times> 'a list\" where\n[simp del]: \"strip_comb t =\n  (case unapp t of\n    Some (t, u) \\<Rightarrow>\n      (let (f, args) = strip_comb t in (f, args @ [u]))\n  | None \\<Rightarrow> (t, []))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>t. x = t \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>t ta.\n       t = ta \\<Longrightarrow>\n       (case unapp t of None \\<Rightarrow> (t, [])\n        | Some (t, u) \\<Rightarrow>\n            let (f, args) = strip_comb_sumC t in (f, args @ [u])) =\n       (case unapp ta of None \\<Rightarrow> (ta, [])\n        | Some (t, u) \\<Rightarrow>\n            let (f, args) = strip_comb_sumC t in (f, args @ [u]))", "by pat_completeness auto"], ["", "(* FIXME why is this not automatic? *)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. strip_comb_dom x", "apply (relation \"measure size\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure size)\n 2. \\<And>t x2 x y.\n       \\<lbrakk>unapp t = Some x2; (x, y) = x2\\<rbrakk>\n       \\<Longrightarrow> (x, t) \\<in> measure size", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x2 x y.\n       \\<lbrakk>unapp t = Some x2; (x, y) = x2\\<rbrakk>\n       \\<Longrightarrow> (x, t) \\<in> measure size", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strip_comb_simps[simp]:\n  \"strip_comb (app t u) = (let (f, args) = strip_comb t in (f, args @ [u]))\"\n  \"unapp t = None \\<Longrightarrow> strip_comb t = (t, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (app t u) =\n    (let (f, args) = strip_comb t in (f, args @ [u])) &&&\n    (unapp t = None \\<Longrightarrow> strip_comb t = (t, []))", "by (subst strip_comb.simps; auto)+"], ["", "lemma strip_comb_induct[case_names app no_app]:\n  assumes \"\\<And>x y. P x \\<Longrightarrow> P (app x y)\"\n  assumes \"\\<And>t. unapp t = None \\<Longrightarrow> P t\"\n  shows \"P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "proof (rule strip_comb.induct, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       (\\<And>x2 x y.\n           \\<lbrakk>unapp t = Some x2; (x, y) = x2\\<rbrakk>\n           \\<Longrightarrow> P x) \\<Longrightarrow>\n       P t", "case (1 t)"], ["proof (state)\nthis:\n  \\<lbrakk>unapp t = Some ?x2.0; (?x, ?y) = ?x2.0\\<rbrakk>\n  \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       (\\<And>x2 x y.\n           \\<lbrakk>unapp t = Some x2; (x, y) = x2\\<rbrakk>\n           \\<Longrightarrow> P x) \\<Longrightarrow>\n       P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "proof (cases \"unapp t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unapp t = None \\<Longrightarrow> P t\n 2. \\<And>a. unapp t = Some a \\<Longrightarrow> P t", "case None"], ["proof (state)\nthis:\n  unapp t = None\n\ngoal (2 subgoals):\n 1. unapp t = None \\<Longrightarrow> P t\n 2. \\<And>a. unapp t = Some a \\<Longrightarrow> P t", "with assms"], ["proof (chain)\npicking this:\n  P ?x \\<Longrightarrow> P (app ?x ?y)\n  unapp ?t = None \\<Longrightarrow> P ?t\n  unapp t = None", "show ?thesis"], ["proof (prove)\nusing this:\n  P ?x \\<Longrightarrow> P (app ?x ?y)\n  unapp ?t = None \\<Longrightarrow> P ?t\n  unapp t = None\n\ngoal (1 subgoal):\n 1. P t", "by metis"], ["proof (state)\nthis:\n  P t\n\ngoal (1 subgoal):\n 1. \\<And>a. unapp t = Some a \\<Longrightarrow> P t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. unapp t = Some a \\<Longrightarrow> P t", "case (Some a)"], ["proof (state)\nthis:\n  unapp t = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a. unapp t = Some a \\<Longrightarrow> P t", "then"], ["proof (chain)\npicking this:\n  unapp t = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  unapp t = Some a\n\ngoal (1 subgoal):\n 1. P t", "apply (cases a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>unapp t = Some a; a = (aa, b)\\<rbrakk> \\<Longrightarrow> P t", "using 1 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>unapp t = Some ?x2.0; (?x, ?y) = ?x2.0\\<rbrakk>\n  \\<Longrightarrow> P ?x\n  P ?x \\<Longrightarrow> P (app ?x ?y)\n  unapp ?t = None \\<Longrightarrow> P ?t\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>unapp t = Some a; a = (aa, b)\\<rbrakk> \\<Longrightarrow> P t", "by auto"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strip_comb_size: \"t' \\<in> set (snd (strip_comb t)) \\<Longrightarrow> size t' < size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t' \\<in> set (snd (strip_comb t)) \\<Longrightarrow> size t' < size t", "by (induction t rule: strip_comb_induct) (auto split: prod.splits)"], ["", "lemma sstrip_comb_termination[termination_simp]:\n  \"(f, ts) = strip_comb t \\<Longrightarrow> t' \\<in> set ts \\<Longrightarrow> size t' < size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, ts) = strip_comb t; t' \\<in> set ts\\<rbrakk>\n    \\<Longrightarrow> size t' < size t", "by (metis snd_conv strip_comb_size)"], ["", "lemma strip_comb_empty: \"snd (strip_comb t) = [] \\<Longrightarrow> fst (strip_comb t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (strip_comb t) = [] \\<Longrightarrow> fst (strip_comb t) = t", "by (induction t rule: strip_comb_induct) (auto split: prod.splits)"], ["", "lemma strip_comb_app: \"fst (strip_comb (app t u)) = fst (strip_comb t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (strip_comb (app t u)) = fst (strip_comb t)", "by (simp split: prod.splits)"], ["", "primrec list_comb :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a\" where\n\"list_comb f [] = f\" |\n\"list_comb f (t # ts) = list_comb (app f t) ts\""], ["", "lemma list_comb_app[simp]: \"list_comb f (xs @ ys) = list_comb (list_comb f xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_comb f (xs @ ys) = list_comb (list_comb f xs) ys", "by (induct xs arbitrary: f) auto"], ["", "corollary list_comb_snoc: \"app (list_comb f xs) y = list_comb f (xs @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app (list_comb f xs) y = list_comb f (xs @ [y])", "by simp"], ["", "lemma list_comb_size[simp]: \"size (list_comb f xs) = size f + size_list size xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (list_comb f xs) = size f + size_list size xs", "by (induct xs arbitrary: f) auto"], ["", "lemma subst_list_comb: \"subst (list_comb f xs) env = list_comb (subst f env) (map (\\<lambda>t. subst t env) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (list_comb f xs) env =\n    list_comb (subst f env) (map (\\<lambda>t. subst t env) xs)", "by (induct xs arbitrary: f) auto"], ["", "abbreviation const_list_comb :: \"name \\<Rightarrow> 'a list \\<Rightarrow> 'a\" (infixl \"$$\" 70) where\n\"const_list_comb name \\<equiv> list_comb (const name)\""], ["", "lemma list_strip_comb[simp]: \"list_comb (fst (strip_comb t)) (snd (strip_comb t)) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_comb (fst (strip_comb t)) (snd (strip_comb t)) = t", "by (induction t rule: strip_comb_induct) (auto split: prod.splits)"], ["", "lemma strip_list_comb: \"strip_comb (list_comb f ys) = (fst (strip_comb f), snd (strip_comb f) @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (list_comb f ys) =\n    (fst (strip_comb f), snd (strip_comb f) @ ys)", "by (induct ys arbitrary: f) (auto simp: split_beta)"], ["", "lemma strip_list_comb_const: \"strip_comb (name $$ xs) = (const name, xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_comb (name $$ xs) = (const name, xs)", "by (simp add: strip_list_comb)"], ["", "lemma frees_list_comb[simp]: \"frees (list_comb t xs) = frees t |\\<union>| freess xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (list_comb t xs) = frees t |\\<union>| freess xs", "by (induct xs arbitrary: t) (auto simp: freess_def)"], ["", "lemma consts_list_comb: \"consts (list_comb f xs) = consts f |\\<union>| ffUnion (fset_of_list (map consts xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (list_comb f xs) =\n    consts f |\\<union>| ffUnion (fset_of_list (map consts xs))", "by (induct xs arbitrary: f) auto"], ["", "lemma ids_list_comb: \"ids (list_comb f xs) = ids f |\\<union>| ffUnion (fset_of_list (map ids xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ids (list_comb f xs) =\n    ids f |\\<union>| ffUnion (fset_of_list (map ids xs))", "unfolding ids_def frees_list_comb consts_list_comb freess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees f |\\<union>|\n    (ffUnion \\<circ> fset_of_list \\<circ> map frees) xs |\\<union>|\n    (consts f |\\<union>| ffUnion (fset_of_list (map consts xs))) =\n    frees f |\\<union>| consts f |\\<union>|\n    ffUnion\n     (fset_of_list (map (\\<lambda>t. frees t |\\<union>| consts t) xs))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<notin>|\n                ffUnion\n                 ((\\<lambda>t. frees t |\\<union>| consts t) |`|\n                  fset_of_list xs);\n        x |\\<notin>| consts f;\n        x |\\<in>| ffUnion (frees |`| fset_of_list xs)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees f\n 2. \\<And>x.\n       \\<lbrakk>x |\\<notin>|\n                ffUnion\n                 ((\\<lambda>t. frees t |\\<union>| consts t) |`|\n                  fset_of_list xs);\n        x |\\<notin>| consts f;\n        x |\\<in>| ffUnion (consts |`| fset_of_list xs)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees f\n 3. \\<And>x.\n       \\<lbrakk>x |\\<notin>| ffUnion (consts |`| fset_of_list xs);\n        x |\\<notin>| consts f;\n        x |\\<notin>| ffUnion (frees |`| fset_of_list xs);\n        x |\\<in>|\n        ffUnion\n         ((\\<lambda>t. frees t |\\<union>| consts t) |`|\n          fset_of_list xs)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees f", "apply (smt fbind_iff finsert_absorb finsert_fsubset funion_image_bind_eq inf_sup_ord(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<notin>|\n                ffUnion\n                 ((\\<lambda>t. frees t |\\<union>| consts t) |`|\n                  fset_of_list xs);\n        x |\\<notin>| consts f;\n        x |\\<in>| ffUnion (consts |`| fset_of_list xs)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees f\n 2. \\<And>x.\n       \\<lbrakk>x |\\<notin>| ffUnion (consts |`| fset_of_list xs);\n        x |\\<notin>| consts f;\n        x |\\<notin>| ffUnion (frees |`| fset_of_list xs);\n        x |\\<in>|\n        ffUnion\n         ((\\<lambda>t. frees t |\\<union>| consts t) |`|\n          fset_of_list xs)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees f", "apply (metis fbind_iff funionCI funion_image_bind_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x |\\<notin>| ffUnion (consts |`| fset_of_list xs);\n        x |\\<notin>| consts f;\n        x |\\<notin>| ffUnion (frees |`| fset_of_list xs);\n        x |\\<in>|\n        ffUnion\n         ((\\<lambda>t. frees t |\\<union>| consts t) |`|\n          fset_of_list xs)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| frees f", "by (smt fbind_iff funionE funion_image_bind_eq)"], ["", "lemma frees_strip_comb: \"frees t = frees (fst (strip_comb t)) |\\<union>| freess (snd (strip_comb t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t =\n    frees (fst (strip_comb t)) |\\<union>| freess (snd (strip_comb t))", "by (metis list_strip_comb frees_list_comb)"], ["", "lemma list_comb_cases':\n  obtains (app) \"is_app (list_comb f xs)\"\n        | (empty) \"list_comb f xs = f\" \"xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_app (list_comb f xs) \\<Longrightarrow> thesis;\n     \\<lbrakk>list_comb f xs = f; xs = []\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (induction xs arbitrary: f) auto"], ["", "(* FIXME case names? *)"], ["", "lemma list_comb_cases[consumes 1]:\n  assumes \"t = list_comb f xs\"\n  obtains (head) \"t = f\" \"xs = []\"\n        | (app) u v where \"t = app u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>t = f; xs = []\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>u v. t = app u v \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  t = list_comb f xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>t = f; xs = []\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>u v. t = app u v \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis list_comb_cases' left_right_simps(3))"], ["", "end"], ["", "fun left_nesting :: \"'a::term \\<Rightarrow> nat\" where\n[simp del]: \"left_nesting t = term_cases (\\<lambda>_. 0) (\\<lambda>_. 0) (\\<lambda>t u. Suc (left_nesting t)) 0 t\""], ["", "lemmas left_nesting_simps[simp] = term_cases_template[OF left_nesting.simps]"], ["", "lemma list_comb_nesting[simp]: \"left_nesting (list_comb f xs) = left_nesting f + length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_nesting (list_comb f xs) = left_nesting f + length xs", "by (induct xs arbitrary: f) auto"], ["", "lemma list_comb_cond_inj:\n  assumes \"list_comb f xs = list_comb g ys\" \"left_nesting f = left_nesting g\"\n  shows \"xs = ys\" \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys &&& f = g", "using assms"], ["proof (prove)\nusing this:\n  list_comb f xs = list_comb g ys\n  left_nesting f = left_nesting g\n\ngoal (1 subgoal):\n 1. xs = ys &&& f = g", "proof (induction xs arbitrary: f g ys)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g\n 3. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 4. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g\n 3. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 4. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "fix f g :: 'a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g\n 3. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 4. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "fix ys"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g\n 3. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 4. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "assume prems: \"list_comb f [] = list_comb g ys\" \"left_nesting f = left_nesting g\""], ["proof (state)\nthis:\n  list_comb f [] = list_comb g ys\n  left_nesting f = left_nesting g\n\ngoal (4 subgoals):\n 1. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g\n 3. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 4. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "hence \"left_nesting f = left_nesting g + length ys\""], ["proof (prove)\nusing this:\n  list_comb f [] = list_comb g ys\n  left_nesting f = left_nesting g\n\ngoal (1 subgoal):\n 1. left_nesting f = left_nesting g + length ys", "by simp"], ["proof (state)\nthis:\n  left_nesting f = left_nesting g + length ys\n\ngoal (4 subgoals):\n 1. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> [] = ys\n 2. \\<And>f g ys.\n       \\<lbrakk>list_comb f [] = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g\n 3. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 4. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "with prems"], ["proof (chain)\npicking this:\n  list_comb f [] = list_comb g ys\n  left_nesting f = left_nesting g\n  left_nesting f = left_nesting g + length ys", "show \"[] = ys\" \"f = g\""], ["proof (prove)\nusing this:\n  list_comb f [] = list_comb g ys\n  left_nesting f = left_nesting g\n  left_nesting f = left_nesting g + length ys\n\ngoal (1 subgoal):\n 1. [] = ys &&& f = g", "by simp+"], ["proof (state)\nthis:\n  [] = ys\n  f = g\n\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>list_comb ?f xs = list_comb ?g ?ys;\n   left_nesting ?f = left_nesting ?g\\<rbrakk>\n  \\<Longrightarrow> xs = ?ys\n  \\<lbrakk>list_comb ?f xs = list_comb ?g ?ys;\n   left_nesting ?f = left_nesting ?g\\<rbrakk>\n  \\<Longrightarrow> ?f = ?g\n\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "fix f g ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "assume prems: \"list_comb f (x # xs) = list_comb g ys\" \"left_nesting f = left_nesting g\""], ["proof (state)\nthis:\n  list_comb f (x # xs) = list_comb g ys\n  left_nesting f = left_nesting g\n\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "hence \"left_nesting (list_comb f (x # xs)) = left_nesting (list_comb g ys)\""], ["proof (prove)\nusing this:\n  list_comb f (x # xs) = list_comb g ys\n  left_nesting f = left_nesting g\n\ngoal (1 subgoal):\n 1. left_nesting (list_comb f (x # xs)) = left_nesting (list_comb g ys)", "by simp"], ["proof (state)\nthis:\n  left_nesting (list_comb f (x # xs)) = left_nesting (list_comb g ys)\n\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "hence \"Suc (left_nesting f + length xs) = left_nesting g + length ys\""], ["proof (prove)\nusing this:\n  left_nesting (list_comb f (x # xs)) = left_nesting (list_comb g ys)\n\ngoal (1 subgoal):\n 1. Suc (left_nesting f + length xs) = left_nesting g + length ys", "by simp"], ["proof (state)\nthis:\n  Suc (left_nesting f + length xs) = left_nesting g + length ys\n\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "with prems"], ["proof (chain)\npicking this:\n  list_comb f (x # xs) = list_comb g ys\n  left_nesting f = left_nesting g\n  Suc (left_nesting f + length xs) = left_nesting g + length ys", "have \"length ys = Suc (length xs)\""], ["proof (prove)\nusing this:\n  list_comb f (x # xs) = list_comb g ys\n  left_nesting f = left_nesting g\n  Suc (left_nesting f + length xs) = left_nesting g + length ys\n\ngoal (1 subgoal):\n 1. length ys = Suc (length xs)", "by linarith"], ["proof (state)\nthis:\n  length ys = Suc (length xs)\n\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "then"], ["proof (chain)\npicking this:\n  length ys = Suc (length xs)", "obtain z zs where \"ys = z # zs\""], ["proof (prove)\nusing this:\n  length ys = Suc (length xs)\n\ngoal (1 subgoal):\n 1. (\\<And>z zs. ys = z # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv)"], ["proof (state)\nthis:\n  ys = z # zs\n\ngoal (2 subgoals):\n 1. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> a # xs = ys\n 2. \\<And>a xs f g ys.\n       \\<lbrakk>\\<And>f g ys.\n                   \\<lbrakk>list_comb f xs = list_comb g ys;\n                    left_nesting f = left_nesting g\\<rbrakk>\n                   \\<Longrightarrow> xs = ys;\n        \\<And>f g ys.\n           \\<lbrakk>list_comb f xs = list_comb g ys;\n            left_nesting f = left_nesting g\\<rbrakk>\n           \\<Longrightarrow> f = g;\n        list_comb f (a # xs) = list_comb g ys;\n        left_nesting f = left_nesting g\\<rbrakk>\n       \\<Longrightarrow> f = g", "thus \"x # xs = ys\" \"f = g\""], ["proof (prove)\nusing this:\n  ys = z # zs\n\ngoal (1 subgoal):\n 1. x # xs = ys &&& f = g", "using prems Cons[where ys = zs and f = \"app f x\" and g = \"app g z\"]"], ["proof (prove)\nusing this:\n  ys = z # zs\n  list_comb f (x # xs) = list_comb g ys\n  left_nesting f = left_nesting g\n  \\<lbrakk>list_comb (app f x) xs = list_comb (app g z) zs;\n   left_nesting (app f x) = left_nesting (app g z)\\<rbrakk>\n  \\<Longrightarrow> xs = zs\n  \\<lbrakk>list_comb (app f x) xs = list_comb (app g z) zs;\n   left_nesting (app f x) = left_nesting (app g z)\\<rbrakk>\n  \\<Longrightarrow> app f x = app g z\n\ngoal (1 subgoal):\n 1. x # xs = ys &&& f = g", "by (auto dest: app_inject)"], ["proof (state)\nthis:\n  x # xs = ys\n  f = g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_comb_inj_second: \"inj (list_comb f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (list_comb f)", "by (metis injI list_comb_cond_inj)"], ["", "lemma list_comb_semi_inj:\n  assumes \"length xs = length ys\"\n  assumes \"list_comb f xs = list_comb g ys\"\n  shows \"xs = ys\" \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys &&& f = g", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = ys\n 2. f = g", "from assms"], ["proof (chain)\npicking this:\n  length xs = length ys\n  list_comb f xs = list_comb g ys", "have \"left_nesting (list_comb f xs) = left_nesting (list_comb g ys)\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  list_comb f xs = list_comb g ys\n\ngoal (1 subgoal):\n 1. left_nesting (list_comb f xs) = left_nesting (list_comb g ys)", "by simp"], ["proof (state)\nthis:\n  left_nesting (list_comb f xs) = left_nesting (list_comb g ys)\n\ngoal (2 subgoals):\n 1. xs = ys\n 2. f = g", "with assms"], ["proof (chain)\npicking this:\n  length xs = length ys\n  list_comb f xs = list_comb g ys\n  left_nesting (list_comb f xs) = left_nesting (list_comb g ys)", "have \"left_nesting f = left_nesting g\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  list_comb f xs = list_comb g ys\n  left_nesting (list_comb f xs) = left_nesting (list_comb g ys)\n\ngoal (1 subgoal):\n 1. left_nesting f = left_nesting g", "unfolding list_comb_nesting"], ["proof (prove)\nusing this:\n  length xs = length ys\n  list_comb f xs = list_comb g ys\n  left_nesting f + length xs = left_nesting g + length ys\n\ngoal (1 subgoal):\n 1. left_nesting f = left_nesting g", "by simp"], ["proof (state)\nthis:\n  left_nesting f = left_nesting g\n\ngoal (2 subgoals):\n 1. xs = ys\n 2. f = g", "with assms"], ["proof (chain)\npicking this:\n  length xs = length ys\n  list_comb f xs = list_comb g ys\n  left_nesting f = left_nesting g", "show \"xs = ys\" \"f = g\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  list_comb f xs = list_comb g ys\n  left_nesting f = left_nesting g\n\ngoal (1 subgoal):\n 1. xs = ys &&& f = g", "by (metis list_comb_cond_inj)+"], ["proof (state)\nthis:\n  xs = ys\n  f = g\n\ngoal:\nNo subgoals!", "qed"], ["", "fun no_abs :: \"'a::term \\<Rightarrow> bool\" where\n[simp del]: \"no_abs t = term_cases (\\<lambda>_. True) (\\<lambda>_. True) (\\<lambda>t u. no_abs t \\<and> no_abs u) False t\""], ["", "lemmas no_abs_simps[simp] = term_cases_template[OF no_abs.simps]"], ["", "lemma no_abs_induct[consumes 1, case_names free const app, induct pred: no_abs]:\n  assumes \"no_abs t\"\n  assumes \"\\<And>name. P (free name)\"\n  assumes \"\\<And>name. P (const name)\"\n  assumes \"\\<And>t\\<^sub>1 t\\<^sub>2. P t\\<^sub>1 \\<Longrightarrow> no_abs t\\<^sub>1 \\<Longrightarrow> P t\\<^sub>2 \\<Longrightarrow> no_abs t\\<^sub>2 \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2)\"\n  shows \"P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "using assms(1)"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. P t", "proof (induction rule: no_abs.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>u\\<^sub>1 u\\<^sub>2.\n                   \\<lbrakk>t = app u\\<^sub>1 u\\<^sub>2;\n                    no_abs u\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> P u\\<^sub>1;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           \\<lbrakk>t = app u\\<^sub>1 u\\<^sub>2; no_abs u\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P u\\<^sub>2;\n        no_abs t\\<rbrakk>\n       \\<Longrightarrow> P t", "case (1 t)"], ["proof (state)\nthis:\n  \\<lbrakk>t = app ?u\\<^sub>1 ?u\\<^sub>2; no_abs ?u\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> P ?u\\<^sub>1\n  \\<lbrakk>t = app ?u\\<^sub>1 ?u\\<^sub>2; no_abs ?u\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P ?u\\<^sub>2\n  no_abs t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<And>u\\<^sub>1 u\\<^sub>2.\n                   \\<lbrakk>t = app u\\<^sub>1 u\\<^sub>2;\n                    no_abs u\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> P u\\<^sub>1;\n        \\<And>u\\<^sub>1 u\\<^sub>2.\n           \\<lbrakk>t = app u\\<^sub>1 u\\<^sub>2; no_abs u\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P u\\<^sub>2;\n        no_abs t\\<rbrakk>\n       \\<Longrightarrow> P t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "proof (cases rule: pre_term_class.term_cases[where t = t])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name. t = free name \\<Longrightarrow> P t\n 2. \\<And>name. t = const name \\<Longrightarrow> P t\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 4. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "case (free name)"], ["proof (state)\nthis:\n  t = free name\n\ngoal (4 subgoals):\n 1. \\<And>name. t = free name \\<Longrightarrow> P t\n 2. \\<And>name. t = const name \\<Longrightarrow> P t\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 4. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "then"], ["proof (chain)\npicking this:\n  t = free name", "show ?thesis"], ["proof (prove)\nusing this:\n  t = free name\n\ngoal (1 subgoal):\n 1. P t", "using assms"], ["proof (prove)\nusing this:\n  t = free name\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. P t", "by auto"], ["proof (state)\nthis:\n  P t\n\ngoal (3 subgoals):\n 1. \\<And>name. t = const name \\<Longrightarrow> P t\n 2. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 3. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name. t = const name \\<Longrightarrow> P t\n 2. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 3. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "case (const name)"], ["proof (state)\nthis:\n  t = const name\n\ngoal (3 subgoals):\n 1. \\<And>name. t = const name \\<Longrightarrow> P t\n 2. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 3. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "then"], ["proof (chain)\npicking this:\n  t = const name", "show ?thesis"], ["proof (prove)\nusing this:\n  t = const name\n\ngoal (1 subgoal):\n 1. P t", "using assms"], ["proof (prove)\nusing this:\n  t = const name\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. P t", "by auto"], ["proof (state)\nthis:\n  P t\n\ngoal (2 subgoals):\n 1. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 2. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 2. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "case (app u\\<^sub>1 u\\<^sub>2)"], ["proof (state)\nthis:\n  t = app u\\<^sub>1 u\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 2. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "with assms"], ["proof (chain)\npicking this:\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  t = app u\\<^sub>1 u\\<^sub>2", "have \"P u\\<^sub>1\" \"P u\\<^sub>2\""], ["proof (prove)\nusing this:\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  t = app u\\<^sub>1 u\\<^sub>2\n\ngoal (1 subgoal):\n 1. P u\\<^sub>1 &&& P u\\<^sub>2", "using 1"], ["proof (prove)\nusing this:\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  t = app u\\<^sub>1 u\\<^sub>2\n  \\<lbrakk>t = app ?u\\<^sub>1 ?u\\<^sub>2; no_abs ?u\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> P ?u\\<^sub>1\n  \\<lbrakk>t = app ?u\\<^sub>1 ?u\\<^sub>2; no_abs ?u\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P ?u\\<^sub>2\n  no_abs t\n\ngoal (1 subgoal):\n 1. P u\\<^sub>1 &&& P u\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  P u\\<^sub>1\n  P u\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>u\\<^sub>1 u\\<^sub>2.\n       t = app u\\<^sub>1 u\\<^sub>2 \\<Longrightarrow> P t\n 2. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "with assms \\<open>no_abs t\\<close>"], ["proof (chain)\npicking this:\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  no_abs t\n  P u\\<^sub>1\n  P u\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  no_abs t\n  P u\\<^sub>1\n  P u\\<^sub>2\n\ngoal (1 subgoal):\n 1. P t", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  no_abs t\n  P (free ?name)\n  P (const ?name)\n  \\<lbrakk>P ?t\\<^sub>1; no_abs ?t\\<^sub>1; P ?t\\<^sub>2;\n   no_abs ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  no_abs (app u\\<^sub>1 u\\<^sub>2)\n  P u\\<^sub>1\n  P u\\<^sub>2\n\ngoal (1 subgoal):\n 1. P (app u\\<^sub>1 u\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  P t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "case other"], ["proof (state)\nthis:\n  unfree t = None\n  unapp t = None\n  unconst t = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> P t", "then"], ["proof (chain)\npicking this:\n  unfree t = None\n  unapp t = None\n  unconst t = None", "show ?thesis"], ["proof (prove)\nusing this:\n  unfree t = None\n  unapp t = None\n  unconst t = None\n\ngoal (1 subgoal):\n 1. P t", "using \\<open>no_abs t\\<close>"], ["proof (prove)\nusing this:\n  unfree t = None\n  unapp t = None\n  unconst t = None\n  no_abs t\n\ngoal (1 subgoal):\n 1. P t", "apply (subst (asm) no_abs.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None;\n     term_cases (\\<lambda>_. True) (\\<lambda>_. True)\n      (\\<lambda>t u. no_abs t \\<and> no_abs u) False t\\<rbrakk>\n    \\<Longrightarrow> P t", "apply (subst (asm) term_cases_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None;\n     case unconst t of\n     None \\<Rightarrow>\n       case unfree t of\n       None \\<Rightarrow>\n         case unapp t of None \\<Rightarrow> False\n         | Some (t, u) \\<Rightarrow> no_abs t \\<and> no_abs u\n       | Some name \\<Rightarrow> True\n     | Some name \\<Rightarrow> True\\<rbrakk>\n    \\<Longrightarrow> P t", "by simp"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_abs_cases[consumes 1, cases pred: no_abs]:\n  assumes \"no_abs t\"\n  obtains (free) name where \"t = free name\"\n        | (const) name where \"t = const name\"\n        | (app) t\\<^sub>1 t\\<^sub>2 where \"t = app t\\<^sub>1 t\\<^sub>2\" \"no_abs t\\<^sub>1\" \"no_abs t\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n         no_abs t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases rule: pre_term_class.term_cases[where t = t])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = free name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = const name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = app u\\<^sub>1 u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n         no_abs t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "case (app u\\<^sub>1 u\\<^sub>2)"], ["proof (state)\nthis:\n  t = app u\\<^sub>1 u\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = free name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = const name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>u\\<^sub>1 u\\<^sub>2.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = app u\\<^sub>1 u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n         no_abs t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. t = app ?t\\<^sub>1 ?t\\<^sub>2\n 2. no_abs ?t\\<^sub>1\n 3. no_abs ?t\\<^sub>2", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_abs u\\<^sub>1\n 2. no_abs u\\<^sub>2", "using \\<open>no_abs t\\<close>"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (2 subgoals):\n 1. no_abs u\\<^sub>1\n 2. no_abs u\\<^sub>2", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  no_abs (app u\\<^sub>1 u\\<^sub>2)\n\ngoal (2 subgoals):\n 1. no_abs u\\<^sub>1\n 2. no_abs u\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = free name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = const name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n         no_abs t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = free name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = const name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n         no_abs t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "case other"], ["proof (state)\nthis:\n  unfree t = None\n  unapp t = None\n  unconst t = None\n\ngoal (3 subgoals):\n 1. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = free name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = const name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n         no_abs t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  unfree t = None\n  unapp t = None\n  unconst t = None", "have False"], ["proof (prove)\nusing this:\n  unfree t = None\n  unapp t = None\n  unconst t = None\n\ngoal (1 subgoal):\n 1. False", "using \\<open>no_abs t\\<close>"], ["proof (prove)\nusing this:\n  unfree t = None\n  unapp t = None\n  unconst t = None\n  no_abs t\n\ngoal (1 subgoal):\n 1. False", "apply (subst (asm) no_abs.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unfree t = None; unapp t = None; unconst t = None;\n     term_cases (\\<lambda>_. True) (\\<lambda>_. True)\n      (\\<lambda>t u. no_abs t \\<and> no_abs u) False t\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto simp: term_cases_def)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = free name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = const name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n     \\<And>name. t = const name \\<Longrightarrow> thesis;\n     \\<And>t\\<^sub>1 t\\<^sub>2.\n        \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n         no_abs t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     unfree t = None; unapp t = None; unconst t = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = free name\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name.\n       \\<lbrakk>\\<And>name. t = free name \\<Longrightarrow> thesis;\n        \\<And>name. t = const name \\<Longrightarrow> thesis;\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>t = app t\\<^sub>1 t\\<^sub>2; no_abs t\\<^sub>1;\n            no_abs t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        t = const name\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed"], ["", "definition is_abs :: \"'a::term \\<Rightarrow> bool\" where\n\"is_abs t = term_cases (\\<lambda>_. False) (\\<lambda>_. False) (\\<lambda>_ _. False) True t\""], ["", "lemmas is_abs_simps[simp] = term_cases_template[OF is_abs_def]"], ["", "definition abs_ish :: \"term list \\<Rightarrow> 'a::term \\<Rightarrow> bool\" where\n\"abs_ish pats rhs \\<longleftrightarrow> pats \\<noteq> [] \\<or> is_abs rhs\""], ["", "locale simple_syntactic_and =\n  fixes P :: \"'a::term \\<Rightarrow> bool\"\n  assumes app: \"P (app t u) \\<longleftrightarrow> P t \\<and> P u\"\nbegin"], ["", "context\n  notes app[simp]\nbegin"], ["", "lemma list_comb: \"P (list_comb f xs) \\<longleftrightarrow> P f \\<and> list_all P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (list_comb f xs) = (P f \\<and> list_all P xs)", "by (induction xs arbitrary: f) auto"], ["", "corollary list_combE:\n  assumes \"P (list_comb f xs)\"\n  shows \"P f\" \"x \\<in> set xs \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P f &&& (x \\<in> set xs \\<Longrightarrow> P x)", "using assms"], ["proof (prove)\nusing this:\n  P (list_comb f xs)\n\ngoal (1 subgoal):\n 1. P f &&& (x \\<in> set xs \\<Longrightarrow> P x)", "by (auto simp: list_comb list_all_iff)"], ["", "lemma match:\n  assumes \"match pat t = Some env\" \"P t\"\n  shows \"fmpred (\\<lambda>_. P) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. P) env", "using assms"], ["proof (prove)\nusing this:\n  match pat t = Some env\n  P t\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. P) env", "by (induction pat t env rule: match_some_induct) auto"], ["", "lemma matchs:\n  assumes \"matchs pats ts = Some env\" \"list_all P ts\"\n  shows \"fmpred (\\<lambda>_. P) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. P) env", "using assms"], ["proof (prove)\nusing this:\n  matchs pats ts = Some env\n  list_all P ts\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_. P) env", "by (induction pats ts arbitrary: env rule: matchs.induct) (auto elim!: option_bindE intro: match)"], ["", "end"], ["", "end"], ["", "locale subst_syntactic_and = simple_syntactic_and +\n  assumes subst: \"P t \\<Longrightarrow> fmpred (\\<lambda>_. P) env \\<Longrightarrow> P (subst t env)\"\nbegin"], ["", "lemma rewrite_step:\n  assumes \"(lhs, rhs) \\<turnstile> t \\<rightarrow> t'\" \"P t\" \"P rhs\"\n  shows \"P t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t'", "using assms"], ["proof (prove)\nusing this:\n  (lhs, rhs) \\<turnstile> t \\<rightarrow> t'\n  P t\n  P rhs\n\ngoal (1 subgoal):\n 1. P t'", "by (auto intro: match subst)"], ["", "end"], ["", "locale simple_syntactic_or =\n  fixes P :: \"'a::term \\<Rightarrow> bool\"\n  assumes app: \"P (app t u) \\<longleftrightarrow> P t \\<or> P u\"\nbegin"], ["", "context\n  notes app[simp]\nbegin"], ["", "lemma list_comb: \"P (list_comb f xs) \\<longleftrightarrow> P f \\<or> list_ex P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (list_comb f xs) = (P f \\<or> list_ex P xs)", "by (induction xs arbitrary: f) auto"], ["", "lemma match:\n  assumes \"match pat t = Some env\" \"\\<not> P t\"\n  shows \"fmpred (\\<lambda>_ t. \\<not> P t) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_ t. \\<not> P t) env", "using assms"], ["proof (prove)\nusing this:\n  match pat t = Some env\n  \\<not> P t\n\ngoal (1 subgoal):\n 1. fmpred (\\<lambda>_ t. \\<not> P t) env", "by (induction pat t env rule: match_some_induct) auto"], ["", "end"], ["", "sublocale neg: simple_syntactic_and \"\\<lambda>t. \\<not> P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_syntactic_and (\\<lambda>t. \\<not> P t)", "by standard (auto simp: app)"], ["", "end"], ["", "global_interpretation no_abs: simple_syntactic_and no_abs"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_syntactic_and no_abs", "by standard simp"], ["", "global_interpretation closed: simple_syntactic_and \"\\<lambda>t. closed_except t S\" for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_syntactic_and (\\<lambda>t. closed_except t S)", "by standard (simp add: closed_except_def)"], ["", "global_interpretation closed: subst_syntactic_and closed"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_syntactic_and closed", "by standard (rule subst_closed_preserved)"], ["", "corollary closed_list_comb: \"closed (name $$ args) \\<longleftrightarrow> list_all closed args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (name $$ args) = list_all closed args", "by (simp add: closed.list_comb)"], ["", "locale term_struct_rel =\n  fixes P :: \"'a::term \\<Rightarrow> 'b::term \\<Rightarrow> bool\"\n  assumes P_t_const: \"P t (const name) \\<Longrightarrow> t = const name\"\n  assumes P_const_const: \"P (const name) (const name)\"\n  assumes P_t_app: \"P t (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow> \\<exists>t\\<^sub>1 t\\<^sub>2. t = app t\\<^sub>1 t\\<^sub>2 \\<and> P t\\<^sub>1 u\\<^sub>1 \\<and> P t\\<^sub>2 u\\<^sub>2\"\n  assumes P_app_app: \"P t\\<^sub>1 u\\<^sub>1 \\<Longrightarrow> P t\\<^sub>2 u\\<^sub>2 \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2)\"\nbegin"], ["", "abbreviation P_env :: \"('k, 'a) fmap \\<Rightarrow> ('k, 'b) fmap \\<Rightarrow> bool\" where\n\"P_env \\<equiv> fmrel P\""], ["", "lemma related_match:\n  assumes \"match x u = Some env\" \"P t u\"\n  obtains env' where \"match x t = Some env'\" \"P_env env' env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match x t = Some env'; P_env env' env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  match x u = Some env\n  P t u\n\ngoal (1 subgoal):\n 1. (\\<And>env'.\n        \\<lbrakk>match x t = Some env'; P_env env' env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction x u env arbitrary: t thesis rule: match_some_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2 t\n       thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>env'.\n                               \\<lbrakk>match t\\<^sub>1 t = Some env';\n                                P_env env' env\\<^sub>1\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t u\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>env'.\n                       \\<lbrakk>match t\\<^sub>2 t = Some env';\n                        P_env env' env\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            P t u\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2;\n        \\<And>env'.\n           \\<lbrakk>match (t\\<^sub>1 $ t\\<^sub>2) t = Some env';\n            P_env env' (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (app u\\<^sub>1 u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Const name) t = Some env';\n                    P_env env' fmempty\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (const name)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name u t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Free name) t = Some env';\n                    P_env env' (fmupd name u fmempty)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t u\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (app v\\<^sub>1 v\\<^sub>2 w\\<^sub>1 w\\<^sub>2 env\\<^sub>1 env\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>env'.\n              \\<lbrakk>match v\\<^sub>1 ?t1 = Some env';\n               P_env env' env\\<^sub>1\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 w\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  \\<lbrakk>\\<And>env'.\n              \\<lbrakk>match v\\<^sub>2 ?t1 = Some env';\n               P_env env' env\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 w\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  match v\\<^sub>1 w\\<^sub>1 = Some env\\<^sub>1\n  match v\\<^sub>2 w\\<^sub>2 = Some env\\<^sub>2\n  \\<lbrakk>match (v\\<^sub>1 $ v\\<^sub>2) t = Some ?env'1;\n   P_env ?env'1 (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (app w\\<^sub>1 w\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2 t\n       thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>env'.\n                               \\<lbrakk>match t\\<^sub>1 t = Some env';\n                                P_env env' env\\<^sub>1\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t u\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>env'.\n                       \\<lbrakk>match t\\<^sub>2 t = Some env';\n                        P_env env' env\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            P t u\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2;\n        \\<And>env'.\n           \\<lbrakk>match (t\\<^sub>1 $ t\\<^sub>2) t = Some env';\n            P_env env' (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (app u\\<^sub>1 u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Const name) t = Some env';\n                    P_env env' fmempty\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (const name)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name u t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Free name) t = Some env';\n                    P_env env' (fmupd name u fmempty)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t u\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain u\\<^sub>1 u\\<^sub>2 where \"t = app u\\<^sub>1 u\\<^sub>2\" \"P u\\<^sub>1 w\\<^sub>1\" \"P u\\<^sub>2 w\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1 u\\<^sub>2.\n        \\<lbrakk>t = app u\\<^sub>1 u\\<^sub>2; P u\\<^sub>1 w\\<^sub>1;\n         P u\\<^sub>2 w\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P_t_app[OF \\<open>P t (app w\\<^sub>1 w\\<^sub>2)\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>t\\<^sub>1 t\\<^sub>2.\n     t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n     P t\\<^sub>1 w\\<^sub>1 \\<and> P t\\<^sub>2 w\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1 u\\<^sub>2.\n        \\<lbrakk>t = app u\\<^sub>1 u\\<^sub>2; P u\\<^sub>1 w\\<^sub>1;\n         P u\\<^sub>2 w\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = app u\\<^sub>1 u\\<^sub>2\n  P u\\<^sub>1 w\\<^sub>1\n  P u\\<^sub>2 w\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2 t\n       thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>env'.\n                               \\<lbrakk>match t\\<^sub>1 t = Some env';\n                                P_env env' env\\<^sub>1\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t u\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>env'.\n                       \\<lbrakk>match t\\<^sub>2 t = Some env';\n                        P_env env' env\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            P t u\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2;\n        \\<And>env'.\n           \\<lbrakk>match (t\\<^sub>1 $ t\\<^sub>2) t = Some env';\n            P_env env' (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (app u\\<^sub>1 u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Const name) t = Some env';\n                    P_env env' fmempty\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (const name)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name u t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Free name) t = Some env';\n                    P_env env' (fmupd name u fmempty)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t u\\<rbrakk>\n       \\<Longrightarrow> thesis", "with app"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>env'.\n              \\<lbrakk>match v\\<^sub>1 ?t1 = Some env';\n               P_env env' env\\<^sub>1\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 w\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  \\<lbrakk>\\<And>env'.\n              \\<lbrakk>match v\\<^sub>2 ?t1 = Some env';\n               P_env env' env\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 w\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  match v\\<^sub>1 w\\<^sub>1 = Some env\\<^sub>1\n  match v\\<^sub>2 w\\<^sub>2 = Some env\\<^sub>2\n  \\<lbrakk>match (v\\<^sub>1 $ v\\<^sub>2) t = Some ?env'1;\n   P_env ?env'1 (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (app w\\<^sub>1 w\\<^sub>2)\n  t = app u\\<^sub>1 u\\<^sub>2\n  P u\\<^sub>1 w\\<^sub>1\n  P u\\<^sub>2 w\\<^sub>2", "obtain env\\<^sub>1' env\\<^sub>2'\n    where \"match v\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1'\" \"P_env env\\<^sub>1' env\\<^sub>1\"\n      and \"match v\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2'\" \"P_env env\\<^sub>2' env\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>env'.\n              \\<lbrakk>match v\\<^sub>1 ?t1 = Some env';\n               P_env env' env\\<^sub>1\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 w\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  \\<lbrakk>\\<And>env'.\n              \\<lbrakk>match v\\<^sub>2 ?t1 = Some env';\n               P_env env' env\\<^sub>2\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 w\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  match v\\<^sub>1 w\\<^sub>1 = Some env\\<^sub>1\n  match v\\<^sub>2 w\\<^sub>2 = Some env\\<^sub>2\n  \\<lbrakk>match (v\\<^sub>1 $ v\\<^sub>2) t = Some ?env'1;\n   P_env ?env'1 (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  P t (app w\\<^sub>1 w\\<^sub>2)\n  t = app u\\<^sub>1 u\\<^sub>2\n  P u\\<^sub>1 w\\<^sub>1\n  P u\\<^sub>2 w\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1' env\\<^sub>2'.\n        \\<lbrakk>match v\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1';\n         P_env env\\<^sub>1' env\\<^sub>1;\n         match v\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2';\n         P_env env\\<^sub>2' env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  match v\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1'\n  P_env env\\<^sub>1' env\\<^sub>1\n  match v\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2'\n  P_env env\\<^sub>2' env\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2 t\n       thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>env'.\n                               \\<lbrakk>match t\\<^sub>1 t = Some env';\n                                P_env env' env\\<^sub>1\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t u\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>env'.\n                       \\<lbrakk>match t\\<^sub>2 t = Some env';\n                        P_env env' env\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            P t u\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2;\n        \\<And>env'.\n           \\<lbrakk>match (t\\<^sub>1 $ t\\<^sub>2) t = Some env';\n            P_env env' (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (app u\\<^sub>1 u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Const name) t = Some env';\n                    P_env env' fmempty\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (const name)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name u t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Free name) t = Some env';\n                    P_env env' (fmupd name u fmempty)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t u\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"match (v\\<^sub>1 $ v\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) = Some (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\""], ["proof (prove)\nusing this:\n  match v\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1'\n  P_env env\\<^sub>1' env\\<^sub>1\n  match v\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2'\n  P_env env\\<^sub>2' env\\<^sub>2\n\ngoal (1 subgoal):\n 1. match (v\\<^sub>1 $ v\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) =\n    Some (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')", "by simp"], ["proof (state)\nthis:\n  match (v\\<^sub>1 $ v\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) =\n  Some (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\n\ngoal (3 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 u\\<^sub>1 u\\<^sub>2 env\\<^sub>1 env\\<^sub>2 t\n       thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>env'.\n                               \\<lbrakk>match t\\<^sub>1 t = Some env';\n                                P_env env' env\\<^sub>1\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t u\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n        \\<And>t thesis.\n           \\<lbrakk>\\<And>env'.\n                       \\<lbrakk>match t\\<^sub>2 t = Some env';\n                        P_env env' env\\<^sub>2\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            P t u\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2;\n        \\<And>env'.\n           \\<lbrakk>match (t\\<^sub>1 $ t\\<^sub>2) t = Some env';\n            P_env env' (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (app u\\<^sub>1 u\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Const name) t = Some env';\n                    P_env env' fmempty\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (const name)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>name u t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Free name) t = Some env';\n                    P_env env' (fmupd name u fmempty)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t u\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule app.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. match (v\\<^sub>1 $ v\\<^sub>2) t = Some ?env'1\n 2. P_env ?env'1 (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "show \"match (v\\<^sub>1 $ v\\<^sub>2) t = Some (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (v\\<^sub>1 $ v\\<^sub>2) t =\n    Some (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. match (v\\<^sub>1 $ v\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) =\n    Some (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')", "by fact"], ["proof (state)\nthis:\n  match (v\\<^sub>1 $ v\\<^sub>2) t =\n  Some (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\n\ngoal (1 subgoal):\n 1. P_env (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\n     (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P_env (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\n     (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "show \"P_env (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2') (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_env (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\n     (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "by rule fact+"], ["proof (state)\nthis:\n  P_env (env\\<^sub>1' ++\\<^sub>f env\\<^sub>2')\n   (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>name t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Const name) t = Some env';\n                    P_env env' fmempty\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (const name)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>name u t thesis.\n       \\<lbrakk>\\<And>env'.\n                   \\<lbrakk>match (Free name) t = Some env';\n                    P_env env' (fmupd name u fmempty)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t u\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed (auto split: option.splits if_splits dest: P_t_const)"], ["", "lemma list_combI:\n  assumes \"list_all2 P us\\<^sub>1 us\\<^sub>2\" \"P t\\<^sub>1 t\\<^sub>2\"\n  shows \"P (list_comb t\\<^sub>1 us\\<^sub>1) (list_comb t\\<^sub>2 us\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (list_comb t\\<^sub>1 us\\<^sub>1) (list_comb t\\<^sub>2 us\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  list_all2 P us\\<^sub>1 us\\<^sub>2\n  P t\\<^sub>1 t\\<^sub>2\n\ngoal (1 subgoal):\n 1. P (list_comb t\\<^sub>1 us\\<^sub>1) (list_comb t\\<^sub>2 us\\<^sub>2)", "by (induction arbitrary: t\\<^sub>1 t\\<^sub>2 rule: list.rel_induct) (auto intro: P_app_app)"], ["", "lemma list_combE:\n  assumes \"P t (name $$ args)\"\n  obtains args' where \"t = name $$ args'\" \"list_all2 P args' args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>args'.\n        \\<lbrakk>t = name $$ args'; list_all2 P args' args\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  P t (name $$ args)\n\ngoal (1 subgoal):\n 1. (\\<And>args'.\n        \\<lbrakk>t = name $$ args'; list_all2 P args' args\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction args arbitrary: t thesis rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t thesis.\n       \\<lbrakk>\\<And>args'.\n                   \\<lbrakk>t = name $$ args'; list_all2 P args' []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (name $$ [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (name $$ [])\n\ngoal (2 subgoals):\n 1. \\<And>t thesis.\n       \\<lbrakk>\\<And>args'.\n                   \\<lbrakk>t = name $$ args'; list_all2 P args' []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (name $$ [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"P t (const name)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (name $$ [])\n\ngoal (1 subgoal):\n 1. P t (const name)", "by simp"], ["proof (state)\nthis:\n  P t (const name)\n\ngoal (2 subgoals):\n 1. \\<And>t thesis.\n       \\<lbrakk>\\<And>args'.\n                   \\<lbrakk>t = name $$ args'; list_all2 P args' []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (name $$ [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"t = const name\""], ["proof (prove)\nusing this:\n  P t (const name)\n\ngoal (1 subgoal):\n 1. t = const name", "using P_t_const"], ["proof (prove)\nusing this:\n  P t (const name)\n  P ?t (const ?name) \\<Longrightarrow> ?t = const ?name\n\ngoal (1 subgoal):\n 1. t = const name", "by auto"], ["proof (state)\nthis:\n  t = const name\n\ngoal (2 subgoals):\n 1. \\<And>t thesis.\n       \\<lbrakk>\\<And>args'.\n                   \\<lbrakk>t = name $$ args'; list_all2 P args' []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        P t (name $$ [])\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "with Nil"], ["proof (chain)\npicking this:\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (name $$ [])\n  t = const name", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (name $$ [])\n  t = const name\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>args'.\n              \\<lbrakk>?t1 = name $$ args'; list_all2 P args' xs\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 (name $$ xs)\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 (xs @ [x])\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (name $$ (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"P t (app (name $$ xs) x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>args'.\n              \\<lbrakk>?t1 = name $$ args'; list_all2 P args' xs\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 (name $$ xs)\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 (xs @ [x])\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (name $$ (xs @ [x]))\n\ngoal (1 subgoal):\n 1. P t (app (name $$ xs) x)", "by simp"], ["proof (state)\nthis:\n  P t (app (name $$ xs) x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain t' y where \"t = app t' y\" \"P t' (name $$ xs)\" \"P y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t' y.\n        \\<lbrakk>t = app t' y; P t' (name $$ xs); P y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using P_t_app[OF \\<open>P t (app (name $$ xs) x)\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>t\\<^sub>1 t\\<^sub>2.\n     t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n     P t\\<^sub>1 (name $$ xs) \\<and> P t\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. (\\<And>t' y.\n        \\<lbrakk>t = app t' y; P t' (name $$ xs); P y x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = app t' y\n  P t' (name $$ xs)\n  P y x\n\ngoal (1 subgoal):\n 1. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "with snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>args'.\n              \\<lbrakk>?t1 = name $$ args'; list_all2 P args' xs\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 (name $$ xs)\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 (xs @ [x])\\<rbrakk>\n  \\<Longrightarrow> thesis\n  P t (name $$ (xs @ [x]))\n  t = app t' y\n  P t' (name $$ xs)\n  P y x", "obtain ys where \"t' = name $$ ys\" \"list_all2 P ys xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>args'.\n              \\<lbrakk>?t1 = name $$ args'; list_all2 P args' xs\\<rbrakk>\n              \\<Longrightarrow> ?thesis1;\n   P ?t1 (name $$ xs)\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n  \\<lbrakk>t = name $$ ?args'1; list_all2 P ?args'1 (xs @ [x])\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  P t (name $$ (xs @ [x]))\n  t = app t' y\n  P t' (name $$ xs)\n  P y x\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>t' = name $$ ys; list_all2 P ys xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' = name $$ ys\n  list_all2 P ys xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs t thesis.\n       \\<lbrakk>\\<And>t thesis.\n                   \\<lbrakk>\\<And>args'.\n                               \\<lbrakk>t = name $$ args';\n                                list_all2 P args' xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    P t (name $$ xs)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>args'.\n           \\<lbrakk>t = name $$ args'; list_all2 P args' (xs @ [x])\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        P t (name $$ (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule snoc.prems)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = name $$ ?args'1\n 2. list_all2 P ?args'1 (xs @ [x])", "show \"t = name $$ (ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = name $$ (ys @ [y])", "unfolding \\<open>t = app t' y\\<close> \\<open>t' = name $$ ys\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. app (name $$ ys) y = name $$ (ys @ [y])", "by simp"], ["proof (state)\nthis:\n  t = name $$ (ys @ [y])\n\ngoal (1 subgoal):\n 1. list_all2 P (ys @ [y]) (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 P (ys @ [y]) (xs @ [x])", "have \"list_all2 P [y] [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 P [y] [x]", "using \\<open>P y x\\<close>"], ["proof (prove)\nusing this:\n  P y x\n\ngoal (1 subgoal):\n 1. list_all2 P [y] [x]", "by simp"], ["proof (state)\nthis:\n  list_all2 P [y] [x]\n\ngoal (1 subgoal):\n 1. list_all2 P (ys @ [y]) (xs @ [x])", "thus \"list_all2 P (ys @ [y]) (xs @ [x])\""], ["proof (prove)\nusing this:\n  list_all2 P [y] [x]\n\ngoal (1 subgoal):\n 1. list_all2 P (ys @ [y]) (xs @ [x])", "using \\<open>list_all2 P ys xs\\<close>"], ["proof (prove)\nusing this:\n  list_all2 P [y] [x]\n  list_all2 P ys xs\n\ngoal (1 subgoal):\n 1. list_all2 P (ys @ [y]) (xs @ [x])", "by (metis list_all2_appendI)"], ["proof (state)\nthis:\n  list_all2 P (ys @ [y]) (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale term_struct_rel_strong = term_struct_rel +\n  assumes P_const_t: \"P (const name) t \\<Longrightarrow> t = const name\"\n  assumes P_app_t: \"P (app u\\<^sub>1 u\\<^sub>2) t \\<Longrightarrow> \\<exists>t\\<^sub>1 t\\<^sub>2. t = app t\\<^sub>1 t\\<^sub>2 \\<and> P u\\<^sub>1 t\\<^sub>1 \\<and> P u\\<^sub>2 t\\<^sub>2\"\nbegin"], ["", "lemma unconst_rel: \"P t u \\<Longrightarrow> unconst t = unconst u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t u \\<Longrightarrow> unconst t = unconst u", "by (metis P_const_t P_t_const const_name_simps(2) is_const_def unconst_const)"], ["", "lemma unapp_rel: \"P t u \\<Longrightarrow> rel_option (rel_prod P P) (unapp t) (unapp u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t u \\<Longrightarrow> rel_option (rel_prod P P) (unapp t) (unapp u)", "by (smt P_app_t P_t_app is_app_def left_right_simps(3) option.rel_sel option.sel option.simps(3) rel_prod_inject unapp_app)"], ["", "lemma match_rel:\n  assumes \"P t u\"\n  shows \"rel_option P_env (match p t) (match p u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option P_env (match p t) (match p u)", "using assms"], ["proof (prove)\nusing this:\n  P t u\n\ngoal (1 subgoal):\n 1. rel_option P_env (match p t) (match p u)", "proof (induction p arbitrary: t u)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Const x) t) (match (Const x) u)\n 2. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Free x) t) (match (Free x) u)\n 3. \\<And>p t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p t) (match p u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (\\<Lambda> p) t)\n                          (match (\\<Lambda> p) u)\n 4. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Bound x) t) (match (Bound x) u)\n 5. \\<And>p1 p2 t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p1 t) (match p1 u);\n        \\<And>t u.\n           P t u \\<Longrightarrow>\n           rel_option P_env (match p2 t) (match p2 u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (p1 $ p2) t)\n                          (match (p1 $ p2) u)", "case (Const name)"], ["proof (state)\nthis:\n  P t u\n\ngoal (5 subgoals):\n 1. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Const x) t) (match (Const x) u)\n 2. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Free x) t) (match (Free x) u)\n 3. \\<And>p t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p t) (match p u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (\\<Lambda> p) t)\n                          (match (\\<Lambda> p) u)\n 4. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Bound x) t) (match (Bound x) u)\n 5. \\<And>p1 p2 t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p1 t) (match p1 u);\n        \\<And>t u.\n           P t u \\<Longrightarrow>\n           rel_option P_env (match p2 t) (match p2 u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (p1 $ p2) t)\n                          (match (p1 $ p2) u)", "thus ?case"], ["proof (prove)\nusing this:\n  P t u\n\ngoal (1 subgoal):\n 1. rel_option P_env (match (Const name) t) (match (Const name) u)", "by (auto split: option.splits simp: unconst_rel)"], ["proof (state)\nthis:\n  rel_option P_env (match (Const name) t) (match (Const name) u)\n\ngoal (4 subgoals):\n 1. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Free x) t) (match (Free x) u)\n 2. \\<And>p t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p t) (match p u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (\\<Lambda> p) t)\n                          (match (\\<Lambda> p) u)\n 3. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Bound x) t) (match (Bound x) u)\n 4. \\<And>p1 p2 t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p1 t) (match p1 u);\n        \\<And>t u.\n           P t u \\<Longrightarrow>\n           rel_option P_env (match p2 t) (match p2 u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (p1 $ p2) t)\n                          (match (p1 $ p2) u)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Free x) t) (match (Free x) u)\n 2. \\<And>p t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p t) (match p u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (\\<Lambda> p) t)\n                          (match (\\<Lambda> p) u)\n 3. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Bound x) t) (match (Bound x) u)\n 4. \\<And>p1 p2 t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p1 t) (match p1 u);\n        \\<And>t u.\n           P t u \\<Longrightarrow>\n           rel_option P_env (match p2 t) (match p2 u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (p1 $ p2) t)\n                          (match (p1 $ p2) u)", "case (App p1 p2)"], ["proof (state)\nthis:\n  P ?t1 ?u1 \\<Longrightarrow> rel_option P_env (match p1 ?t1) (match p1 ?u1)\n  P ?t1 ?u1 \\<Longrightarrow> rel_option P_env (match p2 ?t1) (match p2 ?u1)\n  P t u\n\ngoal (4 subgoals):\n 1. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Free x) t) (match (Free x) u)\n 2. \\<And>p t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p t) (match p u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (\\<Lambda> p) t)\n                          (match (\\<Lambda> p) u)\n 3. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Bound x) t) (match (Bound x) u)\n 4. \\<And>p1 p2 t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p1 t) (match p1 u);\n        \\<And>t u.\n           P t u \\<Longrightarrow>\n           rel_option P_env (match p2 t) (match p2 u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (p1 $ p2) t)\n                          (match (p1 $ p2) u)", "hence \"rel_option (rel_prod P P) (unapp t) (unapp u)\""], ["proof (prove)\nusing this:\n  P ?t1 ?u1 \\<Longrightarrow> rel_option P_env (match p1 ?t1) (match p1 ?u1)\n  P ?t1 ?u1 \\<Longrightarrow> rel_option P_env (match p2 ?t1) (match p2 ?u1)\n  P t u\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod P P) (unapp t) (unapp u)", "by (metis unapp_rel)"], ["proof (state)\nthis:\n  rel_option (rel_prod P P) (unapp t) (unapp u)\n\ngoal (4 subgoals):\n 1. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Free x) t) (match (Free x) u)\n 2. \\<And>p t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p t) (match p u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (\\<Lambda> p) t)\n                          (match (\\<Lambda> p) u)\n 3. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Bound x) t) (match (Bound x) u)\n 4. \\<And>p1 p2 t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p1 t) (match p1 u);\n        \\<And>t u.\n           P t u \\<Longrightarrow>\n           rel_option P_env (match p2 t) (match p2 u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (p1 $ p2) t)\n                          (match (p1 $ p2) u)", "thus ?case"], ["proof (prove)\nusing this:\n  rel_option (rel_prod P P) (unapp t) (unapp u)\n\ngoal (1 subgoal):\n 1. rel_option P_env (match (p1 $ p2) t) (match (p1 $ p2) u)", "using App"], ["proof (prove)\nusing this:\n  rel_option (rel_prod P P) (unapp t) (unapp u)\n  P ?t1 ?u1 \\<Longrightarrow> rel_option P_env (match p1 ?t1) (match p1 ?u1)\n  P ?t1 ?u1 \\<Longrightarrow> rel_option P_env (match p2 ?t1) (match p2 ?u1)\n  P t u\n\ngoal (1 subgoal):\n 1. rel_option P_env (match (p1 $ p2) t) (match (p1 $ p2) u)", "by cases (auto split: option.splits intro!: rel_option_bind)"], ["proof (state)\nthis:\n  rel_option P_env (match (p1 $ p2) t) (match (p1 $ p2) u)\n\ngoal (3 subgoals):\n 1. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Free x) t) (match (Free x) u)\n 2. \\<And>p t u.\n       \\<lbrakk>\\<And>t u.\n                   P t u \\<Longrightarrow>\n                   rel_option P_env (match p t) (match p u);\n        P t u\\<rbrakk>\n       \\<Longrightarrow> rel_option P_env (match (\\<Lambda> p) t)\n                          (match (\\<Lambda> p) u)\n 3. \\<And>x t u.\n       P t u \\<Longrightarrow>\n       rel_option P_env (match (Bound x) t) (match (Bound x) u)", "qed auto"], ["", "lemma find_match_rel:\n  assumes \"list_all2 (rel_prod (=) P) cs cs'\" \"P t t'\"\n  shows \"rel_option (rel_prod P_env (rel_prod (=) P)) (find_match cs t) (find_match cs' t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_prod P_env (rel_prod (=) P)) (find_match cs t)\n     (find_match cs' t')", "using assms"], ["proof (prove)\nusing this:\n  list_all2 (rel_prod (=) P) cs cs'\n  P t t'\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod P_env (rel_prod (=) P)) (find_match cs t)\n     (find_match cs' t')", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. P t t' \\<Longrightarrow>\n    rel_option (rel_prod P_env (rel_prod (=) P)) (find_match [] t)\n     (find_match [] t')\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) P x y; list_all2 (rel_prod (=) P) xs ys;\n        P t t' \\<Longrightarrow>\n        rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n         (find_match ys t');\n        P t t'\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod P_env (rel_prod (=) P))\n                          (find_match (x # xs) t) (find_match (y # ys) t')", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  rel_prod (=) P x y\n  list_all2 (rel_prod (=) P) xs ys\n  P t t' \\<Longrightarrow>\n  rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n   (find_match ys t')\n  P t t'\n\ngoal (2 subgoals):\n 1. P t t' \\<Longrightarrow>\n    rel_option (rel_prod P_env (rel_prod (=) P)) (find_match [] t)\n     (find_match [] t')\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) P x y; list_all2 (rel_prod (=) P) xs ys;\n        P t t' \\<Longrightarrow>\n        rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n         (find_match ys t');\n        P t t'\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod P_env (rel_prod (=) P))\n                          (find_match (x # xs) t) (find_match (y # ys) t')", "moreover"], ["proof (state)\nthis:\n  rel_prod (=) P x y\n  list_all2 (rel_prod (=) P) xs ys\n  P t t' \\<Longrightarrow>\n  rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n   (find_match ys t')\n  P t t'\n\ngoal (2 subgoals):\n 1. P t t' \\<Longrightarrow>\n    rel_option (rel_prod P_env (rel_prod (=) P)) (find_match [] t)\n     (find_match [] t')\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) P x y; list_all2 (rel_prod (=) P) xs ys;\n        P t t' \\<Longrightarrow>\n        rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n         (find_match ys t');\n        P t t'\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod P_env (rel_prod (=) P))\n                          (find_match (x # xs) t) (find_match (y # ys) t')", "obtain px tx py ty where \"x = (px, tx)\" \"y = (py, ty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>px tx py ty.\n        \\<lbrakk>x = (px, tx); y = (py, ty)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, cases y) auto"], ["proof (state)\nthis:\n  x = (px, tx)\n  y = (py, ty)\n\ngoal (2 subgoals):\n 1. P t t' \\<Longrightarrow>\n    rel_option (rel_prod P_env (rel_prod (=) P)) (find_match [] t)\n     (find_match [] t')\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) P x y; list_all2 (rel_prod (=) P) xs ys;\n        P t t' \\<Longrightarrow>\n        rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n         (find_match ys t');\n        P t t'\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod P_env (rel_prod (=) P))\n                          (find_match (x # xs) t) (find_match (y # ys) t')", "moreover"], ["proof (state)\nthis:\n  x = (px, tx)\n  y = (py, ty)\n\ngoal (2 subgoals):\n 1. P t t' \\<Longrightarrow>\n    rel_option (rel_prod P_env (rel_prod (=) P)) (find_match [] t)\n     (find_match [] t')\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) P x y; list_all2 (rel_prod (=) P) xs ys;\n        P t t' \\<Longrightarrow>\n        rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n         (find_match ys t');\n        P t t'\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod P_env (rel_prod (=) P))\n                          (find_match (x # xs) t) (find_match (y # ys) t')", "note match_rel[OF Cons(4), where p = px]"], ["proof (state)\nthis:\n  rel_option P_env (match px t) (match px t')\n\ngoal (2 subgoals):\n 1. P t t' \\<Longrightarrow>\n    rel_option (rel_prod P_env (rel_prod (=) P)) (find_match [] t)\n     (find_match [] t')\n 2. \\<And>x xs y ys.\n       \\<lbrakk>rel_prod (=) P x y; list_all2 (rel_prod (=) P) xs ys;\n        P t t' \\<Longrightarrow>\n        rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n         (find_match ys t');\n        P t t'\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod P_env (rel_prod (=) P))\n                          (find_match (x # xs) t) (find_match (y # ys) t')", "ultimately"], ["proof (chain)\npicking this:\n  rel_prod (=) P x y\n  list_all2 (rel_prod (=) P) xs ys\n  P t t' \\<Longrightarrow>\n  rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n   (find_match ys t')\n  P t t'\n  x = (px, tx)\n  y = (py, ty)\n  rel_option P_env (match px t) (match px t')", "show ?case"], ["proof (prove)\nusing this:\n  rel_prod (=) P x y\n  list_all2 (rel_prod (=) P) xs ys\n  P t t' \\<Longrightarrow>\n  rel_option (rel_prod P_env (rel_prod (=) P)) (find_match xs t)\n   (find_match ys t')\n  P t t'\n  x = (px, tx)\n  y = (py, ty)\n  rel_option P_env (match px t) (match px t')\n\ngoal (1 subgoal):\n 1. rel_option (rel_prod P_env (rel_prod (=) P)) (find_match (x # xs) t)\n     (find_match (y # ys) t')", "by (auto elim: option.rel_cases)"], ["proof (state)\nthis:\n  rel_option (rel_prod P_env (rel_prod (=) P)) (find_match (x # xs) t)\n   (find_match (y # ys) t')\n\ngoal (1 subgoal):\n 1. P t t' \\<Longrightarrow>\n    rel_option (rel_prod P_env (rel_prod (=) P)) (find_match [] t)\n     (find_match [] t')", "qed auto"], ["", "end"], ["", "fun convert_term :: \"'a::term \\<Rightarrow> 'b::term\" where\n[simp del]: \"convert_term t = term_cases const free (\\<lambda>t u. app (convert_term t) (convert_term u)) undefined t\""], ["", "lemmas convert_term_simps[simp] = term_cases_template[OF convert_term.simps]"], ["", "lemma convert_term_id:\n  assumes \"no_abs t\"\n  shows \"convert_term t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term t = t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. convert_term t = t", "by induction auto"], ["", "lemma convert_term_no_abs:\n  assumes \"no_abs t\"\n  shows \"no_abs (convert_term t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs (convert_term t)", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. no_abs (convert_term t)", "by induction auto"], ["", "lemma convert_term_inj:\n  assumes \"no_abs t\" \"no_abs t'\" \"convert_term t = convert_term t'\"\n  shows \"t = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = t'", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n  no_abs t'\n  convert_term t = convert_term t'\n\ngoal (1 subgoal):\n 1. t = t'", "proof (induction t arbitrary: t')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name t'.\n       \\<lbrakk>no_abs t';\n        convert_term (free name) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> free name = t'\n 2. \\<And>name t'.\n       \\<lbrakk>no_abs t';\n        convert_term (const name) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> const name = t'\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "case (free name)"], ["proof (state)\nthis:\n  no_abs t'\n  convert_term (free name) = convert_term t'\n\ngoal (3 subgoals):\n 1. \\<And>name t'.\n       \\<lbrakk>no_abs t';\n        convert_term (free name) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> free name = t'\n 2. \\<And>name t'.\n       \\<lbrakk>no_abs t';\n        convert_term (const name) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> const name = t'\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "then"], ["proof (chain)\npicking this:\n  no_abs t'\n  convert_term (free name) = convert_term t'", "show ?case"], ["proof (prove)\nusing this:\n  no_abs t'\n  convert_term (free name) = convert_term t'\n\ngoal (1 subgoal):\n 1. free name = t'", "by cases (auto dest: term_inject)"], ["proof (state)\nthis:\n  free name = t'\n\ngoal (2 subgoals):\n 1. \\<And>name t'.\n       \\<lbrakk>no_abs t';\n        convert_term (const name) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> const name = t'\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name t'.\n       \\<lbrakk>no_abs t';\n        convert_term (const name) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> const name = t'\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "case (const name)"], ["proof (state)\nthis:\n  no_abs t'\n  convert_term (const name) = convert_term t'\n\ngoal (2 subgoals):\n 1. \\<And>name t'.\n       \\<lbrakk>no_abs t';\n        convert_term (const name) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> const name = t'\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "then"], ["proof (chain)\npicking this:\n  no_abs t'\n  convert_term (const name) = convert_term t'", "show ?case"], ["proof (prove)\nusing this:\n  no_abs t'\n  convert_term (const name) = convert_term t'\n\ngoal (1 subgoal):\n 1. const name = t'", "by cases (auto dest: term_inject)"], ["proof (state)\nthis:\n  const name = t'\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "case (app t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>no_abs ?t'; convert_term t\\<^sub>1 = convert_term ?t'\\<rbrakk>\n  \\<Longrightarrow> t\\<^sub>1 = ?t'\n  \\<lbrakk>no_abs ?t'; convert_term t\\<^sub>2 = convert_term ?t'\\<rbrakk>\n  \\<Longrightarrow> t\\<^sub>2 = ?t'\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n  no_abs t'\n  convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>no_abs t';\n                    convert_term t\\<^sub>1 = convert_term t'\\<rbrakk>\n                   \\<Longrightarrow> t\\<^sub>1 = t';\n        no_abs t\\<^sub>1;\n        \\<And>t'.\n           \\<lbrakk>no_abs t';\n            convert_term t\\<^sub>2 = convert_term t'\\<rbrakk>\n           \\<Longrightarrow> t\\<^sub>2 = t';\n        no_abs t\\<^sub>2; no_abs t';\n        convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "from \\<open>no_abs t'\\<close>"], ["proof (chain)\npicking this:\n  no_abs t'", "show ?case"], ["proof (prove)\nusing this:\n  no_abs t'\n\ngoal (1 subgoal):\n 1. app t\\<^sub>1 t\\<^sub>2 = t'", "apply cases"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>name.\n       t' = free name \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'\n 2. \\<And>name.\n       t' = const name \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'\n 3. \\<And>t\\<^sub>1' t\\<^sub>2'.\n       \\<lbrakk>t' = app t\\<^sub>1' t\\<^sub>2'; no_abs t\\<^sub>1';\n        no_abs t\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>no_abs ?t'; convert_term t\\<^sub>1 = convert_term ?t'\\<rbrakk>\n  \\<Longrightarrow> t\\<^sub>1 = ?t'\n  \\<lbrakk>no_abs ?t'; convert_term t\\<^sub>2 = convert_term ?t'\\<rbrakk>\n  \\<Longrightarrow> t\\<^sub>2 = ?t'\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n  no_abs t'\n  convert_term (app t\\<^sub>1 t\\<^sub>2) = convert_term t'\n\ngoal (3 subgoals):\n 1. \\<And>name.\n       t' = free name \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'\n 2. \\<And>name.\n       t' = const name \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'\n 3. \\<And>t\\<^sub>1' t\\<^sub>2'.\n       \\<lbrakk>t' = app t\\<^sub>1' t\\<^sub>2'; no_abs t\\<^sub>1';\n        no_abs t\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 = t'", "by (auto dest: term_inject)"], ["proof (state)\nthis:\n  app t\\<^sub>1 t\\<^sub>2 = t'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convert_term_idem:\n  assumes \"no_abs t\"\n  shows \"convert_term (convert_term t) = convert_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_term (convert_term t) = convert_term t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. convert_term (convert_term t) = convert_term t", "by (induction t) auto"], ["", "lemma convert_term_frees[simp]:\n  assumes \"no_abs t\"\n  shows \"frees (convert_term t) = frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (convert_term t) = frees t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. frees (convert_term t) = frees t", "by induction auto"], ["", "lemma convert_term_consts[simp]:\n  assumes \"no_abs t\"\n  shows \"consts (convert_term t) = consts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (convert_term t) = consts t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. consts (convert_term t) = consts t", "by induction auto"], ["", "text \\<open>\n  The following lemma does not generalize to when @{prop \\<open>match t u = None\\<close>}. Assume matching\n  return @{const None}, because the pattern is an application and the object is a term satisfying\n  @{const is_abs}. Now, @{const convert_term} applied to the object will produce @{const undefined}.\n  Of course we don't know anything about that and whether or not that matches. A workaround would\n  be to require implementations of @{class term} to prove @{prop \\<open>\\<exists>t. is_abs t\\<close>}, such that\n  @{const convert_term} could use that instead of @{const undefined}. This seems to be too much of a\n  special case in order to be useful.\n\\<close>"], ["", "lemma convert_term_match:\n  assumes \"match t u = Some env\"\n  shows \"match t (convert_term u) = Some (fmmap convert_term env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match t (convert_term u) = Some (fmmap convert_term env)", "using assms"], ["proof (prove)\nusing this:\n  match t u = Some env\n\ngoal (1 subgoal):\n 1. match t (convert_term u) = Some (fmmap convert_term env)", "by (induction t u env rule: match_some_induct) auto"], ["", "section \\<open>Related work\\<close>"], ["", "text \\<open>\n  Schmidt-Schau{\\ss} and Siekmann @{cite schmidt1988unification} discuss the concept of\n  \\<^emph>\\<open>unification algebras\\<close>. They generalize terms to \\<^emph>\\<open>objects\\<close> and substitutions to \\<^emph>\\<open>mappings\\<close>.\n  A unification problem can be rephrased to finding a mapping such that a set of objects are mapped\n  to the same object. The advantage of this generalization is that other -- superficially unrelated\n  -- problems like solving algebraic equations or querying logic programs can be seen as unification\n  problems.\n\n  In particular, the authors note that among the similarities of such problems are that ``objects\n  [have] variables'' whose ``names do not matter'' and ``there exists an operation like substituting\n  objects into variables''. The major difference between this formalization and their work is that I\n  use concrete types for variables and mappings. Otherwise, some similarities to here can be found.\n\n  Eder @{cite eder1985properties} discusses properties of substitutions with a special focus on a\n  partial ordering between substitutions. However, Eder constructs and uses a concrete type of\n  first-order terms, similarly to Sternagel and Thiemann @{cite sternagel2018terms}.\n\n  Williams @{cite williams1991instantiation} defines substitutions as elements in a monoid.\n  In this setting, instantiations can be represented as \\<^emph>\\<open>monoid actions\\<close>. Williams then proceeds to\n  define -- for arbitrary sets of terms and variables -- the notion of \\<^emph>\\<open>instantiation systems,\\<close>\n  heavily drawing on notation from Schmidt-Schau{\\ss} and Siekmann. Some of the presented axioms\n  are also present in this formalization, as are some theorems that have a direct correspondence.\n\\<close>"], ["", "end"]]}