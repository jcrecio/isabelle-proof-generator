{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Term.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemma is_const_free[simp]: \"\\<not> is_const (Free name)\"", "lemma is_free_app[simp]: \"\\<not> is_free (t $ u)\"", "lemma is_free_free[simp]: \"is_free (Free name)\"", "lemma is_const_const[simp]: \"is_const (Const name)\"", "lemma list_comb_free: \"is_free (list_comb f xs) \\<Longrightarrow> is_free f\"", "lemma const_list_comb_free[simp]: \"\\<not> is_free (name $$ args)\"", "lemma match_list_comb_list_comb_eq_lengths[simp]:\n  assumes \"length ps = length vs\"\n  shows \"match (list_comb f ps) (list_comb g vs) =\n    (case match f g of\n      Some env \\<Rightarrow>\n        (case those (map2 match ps vs) of\n          Some envs \\<Rightarrow> Some (foldl (++\\<^sub>f) env envs)\n        | None \\<Rightarrow> None)\n    | None \\<Rightarrow> None)\"", "lemma matchs_match_list_comb[simp]: \"match (name $$ xs) (name $$ ys) = matchs xs ys\"", "lemma incr_bounds_frees[simp]: \"frees (incr_bounds n k t) = frees t\"", "lemma incr_bounds_zero[simp]: \"incr_bounds 0 i t = t\"", "lemma replace_bound_frees: \"frees (replace_bound n t t') |\\<subseteq>| frees t |\\<union>| frees t'\"", "lemma replace_bound_eq:\n  assumes \"i |\\<notin>| bounds t\"\n  shows \"replace_bound i t t' = incr_bounds (-1) (i + 1) t\"", "lemma wellformed_inc:\n  assumes \"wellformed' k t\" \"k \\<le> n\"\n  shows \"wellformed' n t\"", "lemma wellformed'_replace_bound_eq:\n  assumes \"wellformed' n t\" \"k \\<ge> n\"\n  shows \"replace_bound k t u = t\"", "lemma wellformed_replace_bound_eq: \"wellformed t \\<Longrightarrow> replace_bound k t u = t\"", "lemma incr_bounds_eq: \"n \\<ge> k \\<Longrightarrow> wellformed' k t \\<Longrightarrow> incr_bounds i n t = t\"", "lemma incr_bounds_subst:\n  assumes \"\\<And>t. t \\<in> fmran' env \\<Longrightarrow> wellformed t\"\n  shows \"incr_bounds i n (subst t env) = subst (incr_bounds i n t) env\"", "lemma incr_bounds_wellformed:\n  assumes \"wellformed' m u\"\n  shows \"wellformed' (k + m) (incr_bounds (int k) n u)\"", "lemma replace_bound_wellformed:\n  assumes \"wellformed u\" \"wellformed' (Suc k) t\" \"i \\<le> k\"\n  shows \"wellformed' k (replace_bound i t u)\"", "lemma subst_wellformed:\n  assumes \"wellformed' n t\" \"fmpred (\\<lambda>_. wellformed) env\"\n  shows \"wellformed' n (subst t env)\"", "lemma match_list_combE:\n  assumes \"match (name $$ xs) t = Some env\"\n  obtains ys where \"t = name $$ ys\" \"matchs xs ys = Some env\"", "lemma left_nesting_neq_match:\n  \"left_nesting f \\<noteq> left_nesting g \\<Longrightarrow> is_const (fst (strip_comb f)) \\<Longrightarrow> match f g = None\"", "lemma match_list_comb_list_comb_none_structure:\n  assumes \"length ps = length vs\" \"left_nesting f \\<noteq> left_nesting g\"\n  assumes \"is_const (fst (strip_comb f))\"\n  shows \"match (list_comb f ps) (list_comb g vs) = None\"", "lemma match_list_comb_list_comb_some:\n  assumes \"match (list_comb f ps) (list_comb g vs) = Some env\" \"left_nesting f = left_nesting g\"\n  assumes \"is_const (fst (strip_comb f))\"\n  shows \"match f g \\<noteq> None\" \"length ps = length vs\"", "lemma match_list_comb_list_comb_none_name[simp]:\n  assumes \"name \\<noteq> name'\"\n  shows \"match (name $$ ps) (name' $$ vs) = None\"", "lemma match_list_comb_list_comb_none_length[simp]:\n  assumes \"length ps \\<noteq> length vs\"\n  shows \"match (name $$ ps) (name' $$ vs) = None\""], "translations": [["", "lemma is_const_free[simp]: \"\\<not> is_const (Free name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_const (Free name)", "unfolding is_const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unconst (Free name) \\<noteq> None", "by simp"], ["", "lemma is_free_app[simp]: \"\\<not> is_free (t $ u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_free (t $ u)", "unfolding is_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> unfree (t $ u) \\<noteq> None", "by simp"], ["", "lemma is_free_free[simp]: \"is_free (Free name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_free (Free name)", "unfolding is_free_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfree (Free name) \\<noteq> None", "by simp"], ["", "lemma is_const_const[simp]: \"is_const (Const name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_const (Const name)", "unfolding is_const_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unconst (Const name) \\<noteq> None", "by simp"], ["", "lemma list_comb_free: \"is_free (list_comb f xs) \\<Longrightarrow> is_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_free (list_comb f xs) \\<Longrightarrow> is_free f", "apply (induction xs arbitrary: f)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f. is_free (list_comb f []) \\<Longrightarrow> is_free f\n 2. \\<And>a xs f.\n       \\<lbrakk>\\<And>f.\n                   is_free (list_comb f xs) \\<Longrightarrow> is_free f;\n        is_free (list_comb f (a # xs))\\<rbrakk>\n       \\<Longrightarrow> is_free f", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs f.\n       \\<lbrakk>\\<And>f.\n                   is_free (list_comb f xs) \\<Longrightarrow> is_free f;\n        is_free (list_comb (app f a) xs)\\<rbrakk>\n       \\<Longrightarrow> is_free f", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_free f_", "apply (insert prems(1)[OF prems(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_free (app f_ a_) \\<Longrightarrow> is_free f_", "unfolding app_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_free (app f_ a_) \\<Longrightarrow> is_free f_", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma const_list_comb_free[simp]: \"\\<not> is_free (name $$ args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_free (name $$ args)", "by (fastforce dest: list_comb_free simp: const_term_def)"], ["", "corollary const_list_comb_neq_free[simp]: \"name $$ args \\<noteq> free name'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name $$ args \\<noteq> free name'", "by (metis const_list_comb_free is_free_simps(1))"], ["", "declare const_list_comb_neq_free[symmetric, simp]"], ["", "lemma match_list_comb_list_comb_eq_lengths[simp]:\n  assumes \"length ps = length vs\"\n  shows \"match (list_comb f ps) (list_comb g vs) =\n    (case match f g of\n      Some env \\<Rightarrow>\n        (case those (map2 match ps vs) of\n          Some envs \\<Rightarrow> Some (foldl (++\\<^sub>f) env envs)\n        | None \\<Rightarrow> None)\n    | None \\<Rightarrow> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb g vs) =\n    (case match f g of None \\<Rightarrow> None\n     | Some env \\<Rightarrow>\n         case those (Term_Utils.map2 match ps vs) of None \\<Rightarrow> None\n         | Some envs \\<Rightarrow> Some (foldl (++\\<^sub>f) env envs))", "using assms"], ["proof (prove)\nusing this:\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb g vs) =\n    (case match f g of None \\<Rightarrow> None\n     | Some env \\<Rightarrow>\n         case those (Term_Utils.map2 match ps vs) of None \\<Rightarrow> None\n         | Some envs \\<Rightarrow> Some (foldl (++\\<^sub>f) env envs))", "by (induction ps vs arbitrary: f g rule: list_induct2) (auto split: option.splits simp: app_term_def)"], ["", "lemma matchs_match_list_comb[simp]: \"match (name $$ xs) (name $$ ys) = matchs xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (name $$ xs) (name $$ ys) = matchs xs ys", "proof (induction xs arbitrary: ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. match (name $$ []) (name $$ ys) = matchs [] ys\n 2. \\<And>x xs ys.\n       (\\<And>ys.\n           match (name $$ xs) (name $$ ys) = matchs xs ys) \\<Longrightarrow>\n       match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys. match (name $$ []) (name $$ ys) = matchs [] ys\n 2. \\<And>x xs ys.\n       (\\<And>ys.\n           match (name $$ xs) (name $$ ys) = matchs xs ys) \\<Longrightarrow>\n       match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. match (name $$ []) (name $$ ys) = matchs [] ys", "by (cases ys rule: rev_cases) (auto simp: const_term_def)"], ["proof (state)\nthis:\n  match (name $$ []) (name $$ ys) = matchs [] ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       (\\<And>ys.\n           match (name $$ xs) (name $$ ys) = matchs xs ys) \\<Longrightarrow>\n       match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       (\\<And>ys.\n           match (name $$ xs) (name $$ ys) = matchs xs ys) \\<Longrightarrow>\n       match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "case (snoc x xs)"], ["proof (state)\nthis:\n  match (name $$ xs) (name $$ ?ys) = matchs xs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       (\\<And>ys.\n           match (name $$ xs) (name $$ ys) = matchs xs ys) \\<Longrightarrow>\n       match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "note snoc0 = snoc"], ["proof (state)\nthis:\n  match (name $$ xs) (name $$ ?ys) = matchs xs ?ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       (\\<And>ys.\n           match (name $$ xs) (name $$ ys) = matchs xs ys) \\<Longrightarrow>\n       match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "have \"match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys", "proof (cases ys rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys\n 2. \\<And>ys y.\n       ys = ys @ [y] \\<Longrightarrow>\n       match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys", "case (snoc zs z)"], ["proof (state)\nthis:\n  ys = zs @ [z]\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys\n 2. \\<And>ys y.\n       ys = ys @ [y] \\<Longrightarrow>\n       match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys", "unfolding snoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. match (name $$ xs $ x) (name $$ (zs @ [z])) =\n    matchs (xs @ [x]) (zs @ [z])", "using snoc0"], ["proof (prove)\nusing this:\n  match (name $$ xs) (name $$ ?ys) = matchs xs ?ys\n\ngoal (1 subgoal):\n 1. match (name $$ xs $ x) (name $$ (zs @ [z])) =\n    matchs (xs @ [x]) (zs @ [z])", "by simp"], ["proof (state)\nthis:\n  match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow>\n    match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys", "qed auto"], ["proof (state)\nthis:\n  match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       (\\<And>ys.\n           match (name $$ xs) (name $$ ys) = matchs xs ys) \\<Longrightarrow>\n       match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "thus ?case"], ["proof (prove)\nusing this:\n  match (name $$ xs $ x) (name $$ ys) = matchs (xs @ [x]) ys\n\ngoal (1 subgoal):\n 1. match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys", "by (simp add: app_term_def)"], ["proof (state)\nthis:\n  match (name $$ (xs @ [x])) (name $$ ys) = matchs (xs @ [x]) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "fun bounds :: \"term \\<Rightarrow> nat fset\" where\n\"bounds (Bound i) = {| i |}\" |\n\"bounds (t\\<^sub>1 $ t\\<^sub>2) = bounds t\\<^sub>1 |\\<union>| bounds t\\<^sub>2\" |\n\"bounds (\\<Lambda> t) = (\\<lambda>i. i - 1) |`| (bounds t - {| 0 |})\" |\n\"bounds _ = {||}\""], ["", "definition shift_nat :: \"nat \\<Rightarrow> int \\<Rightarrow> nat\" where\n[simp]: \"shift_nat n k = (if k \\<ge> 0 then n + nat k else n - nat \\<bar>k\\<bar>)\""], ["", "fun incr_bounds :: \"int \\<Rightarrow> nat \\<Rightarrow> term \\<Rightarrow> term\" where\n\"incr_bounds inc lev (Bound i) = (if i \\<ge> lev then Bound (shift_nat i inc) else Bound i)\" |\n\"incr_bounds inc lev (\\<Lambda> u) = \\<Lambda> incr_bounds inc (lev + 1) u\" |\n\"incr_bounds inc lev (t\\<^sub>1 $ t\\<^sub>2) = incr_bounds inc lev t\\<^sub>1 $ incr_bounds inc lev t\\<^sub>2\" |\n\"incr_bounds _ _ t = t\""], ["", "lemma incr_bounds_frees[simp]: \"frees (incr_bounds n k t) = frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (incr_bounds n k t) = frees t", "by (induction n k t rule: incr_bounds.induct) auto"], ["", "lemma incr_bounds_zero[simp]: \"incr_bounds 0 i t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incr_bounds 0 i t = t", "by (induct t arbitrary: i) auto"], ["", "fun replace_bound :: \"nat \\<Rightarrow> term \\<Rightarrow> term \\<Rightarrow> term\" where\n\"replace_bound lev (Bound i) t = (if i < lev then Bound i else if i = lev then incr_bounds (int lev) 0 t else Bound (i - 1))\" |\n\"replace_bound lev (t\\<^sub>1 $ t\\<^sub>2) t = replace_bound lev t\\<^sub>1 t $ replace_bound lev t\\<^sub>2 t\" |\n\"replace_bound lev (\\<Lambda> u) t = \\<Lambda> replace_bound (lev + 1) u t\" |\n\"replace_bound _ t _ = t\""], ["", "abbreviation \\<beta>_reduce :: \"term \\<Rightarrow> term \\<Rightarrow> term\" (\"_ [_]\\<^sub>\\<beta>\") where\n\"t [u]\\<^sub>\\<beta> \\<equiv> replace_bound 0 t u\""], ["", "lemma replace_bound_frees: \"frees (replace_bound n t t') |\\<subseteq>| frees t |\\<union>| frees t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (replace_bound n t t') |\\<subseteq>| frees t |\\<union>| frees t'", "by (induction n t t' rule: replace_bound.induct) auto"], ["", "lemma replace_bound_eq:\n  assumes \"i |\\<notin>| bounds t\"\n  shows \"replace_bound i t t' = incr_bounds (-1) (i + 1) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_bound i t t' = incr_bounds (- 1) (i + 1) t", "using assms"], ["proof (prove)\nusing this:\n  i |\\<notin>| bounds t\n\ngoal (1 subgoal):\n 1. replace_bound i t t' = incr_bounds (- 1) (i + 1) t", "by (induct t arbitrary: i) force+"], ["", "fun wellformed' :: \"nat \\<Rightarrow> term \\<Rightarrow> bool\" where\n\"wellformed' n (t\\<^sub>1 $ t\\<^sub>2) \\<longleftrightarrow> wellformed' n t\\<^sub>1 \\<and> wellformed' n t\\<^sub>2\" |\n\"wellformed' n (Bound n') \\<longleftrightarrow> n' < n\" |\n\"wellformed' n (\\<Lambda> t) \\<longleftrightarrow> wellformed' (n + 1) t\" |\n\"wellformed' _ _ \\<longleftrightarrow> True\""], ["", "lemma wellformed_inc:\n  assumes \"wellformed' k t\" \"k \\<le> n\"\n  shows \"wellformed' n t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' n t", "using assms"], ["proof (prove)\nusing this:\n  wellformed' k t\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. wellformed' n t", "by (induct t arbitrary: k n) auto"], ["", "abbreviation wellformed :: \"term \\<Rightarrow> bool\" where\n\"wellformed \\<equiv> wellformed' 0\""], ["", "lemma wellformed'_replace_bound_eq:\n  assumes \"wellformed' n t\" \"k \\<ge> n\"\n  shows \"replace_bound k t u = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_bound k t u = t", "using assms"], ["proof (prove)\nusing this:\n  wellformed' n t\n  n \\<le> k\n\ngoal (1 subgoal):\n 1. replace_bound k t u = t", "by (induction t arbitrary: n k) auto"], ["", "lemma wellformed_replace_bound_eq: \"wellformed t \\<Longrightarrow> replace_bound k t u = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed t \\<Longrightarrow> replace_bound k t u = t", "by (rule wellformed'_replace_bound_eq) simp+"], ["", "lemma incr_bounds_eq: \"n \\<ge> k \\<Longrightarrow> wellformed' k t \\<Longrightarrow> incr_bounds i n t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> n; wellformed' k t\\<rbrakk>\n    \\<Longrightarrow> incr_bounds i n t = t", "by (induct t arbitrary: k n) force+"], ["", "lemma incr_bounds_subst:\n  assumes \"\\<And>t. t \\<in> fmran' env \\<Longrightarrow> wellformed t\"\n  shows \"incr_bounds i n (subst t env) = subst (incr_bounds i n t) env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incr_bounds i n (subst t env) = subst (incr_bounds i n t) env", "proof (induction t arbitrary: n)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x n.\n       incr_bounds i n (subst (Const x) env) =\n       subst (incr_bounds i n (Const x)) env\n 2. \\<And>x n.\n       incr_bounds i n (subst (Free x) env) =\n       subst (incr_bounds i n (Free x)) env\n 3. \\<And>t n.\n       (\\<And>n.\n           incr_bounds i n (subst t env) =\n           subst (incr_bounds i n t) env) \\<Longrightarrow>\n       incr_bounds i n (subst (\\<Lambda> t) env) =\n       subst (incr_bounds i n (\\<Lambda> t)) env\n 4. \\<And>x n.\n       incr_bounds i n (subst (Bound x) env) =\n       subst (incr_bounds i n (Bound x)) env\n 5. \\<And>t1 t2 n.\n       \\<lbrakk>\\<And>n.\n                   incr_bounds i n (subst t1 env) =\n                   subst (incr_bounds i n t1) env;\n        \\<And>n.\n           incr_bounds i n (subst t2 env) =\n           subst (incr_bounds i n t2) env\\<rbrakk>\n       \\<Longrightarrow> incr_bounds i n (subst (t1 $ t2) env) =\n                         subst (incr_bounds i n (t1 $ t2)) env", "case (Free name)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x n.\n       incr_bounds i n (subst (Const x) env) =\n       subst (incr_bounds i n (Const x)) env\n 2. \\<And>x n.\n       incr_bounds i n (subst (Free x) env) =\n       subst (incr_bounds i n (Free x)) env\n 3. \\<And>t n.\n       (\\<And>n.\n           incr_bounds i n (subst t env) =\n           subst (incr_bounds i n t) env) \\<Longrightarrow>\n       incr_bounds i n (subst (\\<Lambda> t) env) =\n       subst (incr_bounds i n (\\<Lambda> t)) env\n 4. \\<And>x n.\n       incr_bounds i n (subst (Bound x) env) =\n       subst (incr_bounds i n (Bound x)) env\n 5. \\<And>t1 t2 n.\n       \\<lbrakk>\\<And>n.\n                   incr_bounds i n (subst t1 env) =\n                   subst (incr_bounds i n t1) env;\n        \\<And>n.\n           incr_bounds i n (subst t2 env) =\n           subst (incr_bounds i n t2) env\\<rbrakk>\n       \\<Longrightarrow> incr_bounds i n (subst (t1 $ t2) env) =\n                         subst (incr_bounds i n (t1 $ t2)) env", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. incr_bounds i n (subst (Free name) env) =\n    subst (incr_bounds i n (Free name)) env", "proof (cases \"fmlookup env name\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fmlookup env name = None \\<Longrightarrow>\n    incr_bounds i n (subst (Free name) env) =\n    subst (incr_bounds i n (Free name)) env\n 2. \\<And>a.\n       fmlookup env name = Some a \\<Longrightarrow>\n       incr_bounds i n (subst (Free name) env) =\n       subst (incr_bounds i n (Free name)) env", "case (Some t)"], ["proof (state)\nthis:\n  fmlookup env name = Some t\n\ngoal (2 subgoals):\n 1. fmlookup env name = None \\<Longrightarrow>\n    incr_bounds i n (subst (Free name) env) =\n    subst (incr_bounds i n (Free name)) env\n 2. \\<And>a.\n       fmlookup env name = Some a \\<Longrightarrow>\n       incr_bounds i n (subst (Free name) env) =\n       subst (incr_bounds i n (Free name)) env", "hence \"wellformed t\""], ["proof (prove)\nusing this:\n  fmlookup env name = Some t\n\ngoal (1 subgoal):\n 1. wellformed t", "using assms"], ["proof (prove)\nusing this:\n  fmlookup env name = Some t\n  ?t \\<in> fmran' env \\<Longrightarrow> wellformed ?t\n\ngoal (1 subgoal):\n 1. wellformed t", "by (auto intro: fmran'I)"], ["proof (state)\nthis:\n  wellformed t\n\ngoal (2 subgoals):\n 1. fmlookup env name = None \\<Longrightarrow>\n    incr_bounds i n (subst (Free name) env) =\n    subst (incr_bounds i n (Free name)) env\n 2. \\<And>a.\n       fmlookup env name = Some a \\<Longrightarrow>\n       incr_bounds i n (subst (Free name) env) =\n       subst (incr_bounds i n (Free name)) env", "hence \"incr_bounds i n t = t\""], ["proof (prove)\nusing this:\n  wellformed t\n\ngoal (1 subgoal):\n 1. incr_bounds i n t = t", "by (subst incr_bounds_eq) auto"], ["proof (state)\nthis:\n  incr_bounds i n t = t\n\ngoal (2 subgoals):\n 1. fmlookup env name = None \\<Longrightarrow>\n    incr_bounds i n (subst (Free name) env) =\n    subst (incr_bounds i n (Free name)) env\n 2. \\<And>a.\n       fmlookup env name = Some a \\<Longrightarrow>\n       incr_bounds i n (subst (Free name) env) =\n       subst (incr_bounds i n (Free name)) env", "with Some"], ["proof (chain)\npicking this:\n  fmlookup env name = Some t\n  incr_bounds i n t = t", "show ?thesis"], ["proof (prove)\nusing this:\n  fmlookup env name = Some t\n  incr_bounds i n t = t\n\ngoal (1 subgoal):\n 1. incr_bounds i n (subst (Free name) env) =\n    subst (incr_bounds i n (Free name)) env", "by simp"], ["proof (state)\nthis:\n  incr_bounds i n (subst (Free name) env) =\n  subst (incr_bounds i n (Free name)) env\n\ngoal (1 subgoal):\n 1. fmlookup env name = None \\<Longrightarrow>\n    incr_bounds i n (subst (Free name) env) =\n    subst (incr_bounds i n (Free name)) env", "qed auto"], ["proof (state)\nthis:\n  incr_bounds i n (subst (Free name) env) =\n  subst (incr_bounds i n (Free name)) env\n\ngoal (4 subgoals):\n 1. \\<And>x n.\n       incr_bounds i n (subst (Const x) env) =\n       subst (incr_bounds i n (Const x)) env\n 2. \\<And>t n.\n       (\\<And>n.\n           incr_bounds i n (subst t env) =\n           subst (incr_bounds i n t) env) \\<Longrightarrow>\n       incr_bounds i n (subst (\\<Lambda> t) env) =\n       subst (incr_bounds i n (\\<Lambda> t)) env\n 3. \\<And>x n.\n       incr_bounds i n (subst (Bound x) env) =\n       subst (incr_bounds i n (Bound x)) env\n 4. \\<And>t1 t2 n.\n       \\<lbrakk>\\<And>n.\n                   incr_bounds i n (subst t1 env) =\n                   subst (incr_bounds i n t1) env;\n        \\<And>n.\n           incr_bounds i n (subst t2 env) =\n           subst (incr_bounds i n t2) env\\<rbrakk>\n       \\<Longrightarrow> incr_bounds i n (subst (t1 $ t2) env) =\n                         subst (incr_bounds i n (t1 $ t2)) env", "qed auto"], ["", "lemma incr_bounds_wellformed:\n  assumes \"wellformed' m u\"\n  shows \"wellformed' (k + m) (incr_bounds (int k) n u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (k + m) (incr_bounds (int k) n u)", "using assms"], ["proof (prove)\nusing this:\n  wellformed' m u\n\ngoal (1 subgoal):\n 1. wellformed' (k + m) (incr_bounds (int k) n u)", "by (induct u arbitrary: n m) force+"], ["", "lemma replace_bound_wellformed:\n  assumes \"wellformed u\" \"wellformed' (Suc k) t\" \"i \\<le> k\"\n  shows \"wellformed' k (replace_bound i t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' k (replace_bound i t u)", "using assms"], ["proof (prove)\nusing this:\n  wellformed u\n  wellformed' (Suc k) t\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. wellformed' k (replace_bound i t u)", "apply (induction t arbitrary: i k)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x i k.\n       \\<lbrakk>wellformed u; wellformed' (Suc k) (Const x);\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (replace_bound i (Const x) u)\n 2. \\<And>x i k.\n       \\<lbrakk>wellformed u; wellformed' (Suc k) (Free x);\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (replace_bound i (Free x) u)\n 3. \\<And>t i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<lbrakk>wellformed u; wellformed' (Suc k) t;\n                    i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> wellformed' k (replace_bound i t u);\n        wellformed u; wellformed' (Suc k) (\\<Lambda> t); i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (replace_bound i (\\<Lambda> t) u)\n 4. \\<And>x i k.\n       \\<lbrakk>wellformed u; wellformed' (Suc k) (Bound x);\n        i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (replace_bound i (Bound x) u)\n 5. \\<And>t1 t2 i k.\n       \\<lbrakk>\\<And>i k.\n                   \\<lbrakk>wellformed u; wellformed' (Suc k) t1;\n                    i \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> wellformed' k (replace_bound i t1 u);\n        \\<And>i k.\n           \\<lbrakk>wellformed u; wellformed' (Suc k) t2; i \\<le> k\\<rbrakk>\n           \\<Longrightarrow> wellformed' k (replace_bound i t2 u);\n        wellformed u; wellformed' (Suc k) (t1 $ t2); i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (replace_bound i (t1 $ t2) u)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i k.\n       \\<lbrakk>wellformed u; i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (incr_bounds (int i) 0 u)", "using incr_bounds_wellformed[where m = 0, simplified]"], ["proof (prove)\nusing this:\n  wellformed ?u \\<Longrightarrow>\n  wellformed' ?k (incr_bounds (int ?k) ?n ?u)\n\ngoal (1 subgoal):\n 1. \\<And>i k.\n       \\<lbrakk>wellformed u; i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (incr_bounds (int i) 0 u)", "using wellformed_inc"], ["proof (prove)\nusing this:\n  wellformed ?u \\<Longrightarrow>\n  wellformed' ?k (incr_bounds (int ?k) ?n ?u)\n  \\<lbrakk>wellformed' ?k ?t; ?k \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> wellformed' ?n ?t\n\ngoal (1 subgoal):\n 1. \\<And>i k.\n       \\<lbrakk>wellformed u; i \\<le> k\\<rbrakk>\n       \\<Longrightarrow> wellformed' k (incr_bounds (int i) 0 u)", "by blast"], ["", "lemma subst_wellformed:\n  assumes \"wellformed' n t\" \"fmpred (\\<lambda>_. wellformed) env\"\n  shows \"wellformed' n (subst t env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' n (subst t env)", "using assms"], ["proof (prove)\nusing this:\n  wellformed' n t\n  fmpred (\\<lambda>_. wellformed) env\n\ngoal (1 subgoal):\n 1. wellformed' n (subst t env)", "by (induction t arbitrary: n) (auto split: option.splits intro: wellformed_inc)"], ["", "global_interpretation wellformed: simple_syntactic_and \"wellformed' n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_syntactic_and (wellformed' n)", "by standard (auto simp: app_term_def)"], ["", "global_interpretation wellformed: subst_syntactic_and wellformed"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_syntactic_and wellformed", "by standard (auto intro: subst_wellformed)"], ["", "lemma match_list_combE:\n  assumes \"match (name $$ xs) t = Some env\"\n  obtains ys where \"t = name $$ ys\" \"matchs xs ys = Some env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>t = name $$ ys; matchs xs ys = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>t = name $$ ys; matchs xs ys = Some env\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms that"], ["proof (chain)\npicking this:\n  match (name $$ xs) t = Some env\n  \\<lbrakk>t = name $$ ?ys; matchs xs ?ys = Some env\\<rbrakk>\n  \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  match (name $$ xs) t = Some env\n  \\<lbrakk>t = name $$ ?ys; matchs xs ?ys = Some env\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof (induction xs arbitrary: t env thesis rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t env thesis.\n       \\<lbrakk>match (name $$ []) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs [] ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  match (name $$ []) t = Some env\n  \\<lbrakk>t = name $$ ?ys; matchs [] ?ys = Some env\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>t env thesis.\n       \\<lbrakk>match (name $$ []) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs [] ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Nil(1)"], ["proof (chain)\npicking this:\n  match (name $$ []) t = Some env", "show ?case"], ["proof (prove)\nusing this:\n  match (name $$ []) t = Some env\n\ngoal (1 subgoal):\n 1. thesis", "apply (auto simp: const_term_def split: option.splits if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unconst t = Some name; env = fmempty\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Nil(2)[where ys = \"[]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = name $$ []; matchs [] [] = Some env\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>unconst t = Some name; env = fmempty\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>match (name $$ xs) ?t = Some ?env;\n   \\<And>ys.\n      \\<lbrakk>?t = name $$ ys; matchs xs ys = Some ?env\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  match (name $$ (xs @ [x])) t = Some env\n  \\<lbrakk>t = name $$ ?ys; matchs (xs @ [x]) ?ys = Some env\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain t' y where \"t = app t' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t' y. t = app t' y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>match _ t = Some env\\<close>"], ["proof (prove)\nusing this:\n  match (name $$ (xs @ [x])) t = Some env\n\ngoal (1 subgoal):\n 1. (\\<And>t' y. t = app t' y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: app_term_def elim!: option_bindE)"], ["proof (state)\nthis:\n  t = app t' y\n\ngoal (1 subgoal):\n 1. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "from snoc(2)"], ["proof (chain)\npicking this:\n  match (name $$ (xs @ [x])) t = Some env", "obtain env\\<^sub>1 env\\<^sub>2\n        where \"match (name $$ xs) t' = Some env\\<^sub>1\" \"match x y = Some env\\<^sub>2\" \"env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\""], ["proof (prove)\nusing this:\n  match (name $$ (xs @ [x])) t = Some env\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1 env\\<^sub>2.\n        \\<lbrakk>match (name $$ xs) t' = Some env\\<^sub>1;\n         match x y = Some env\\<^sub>2;\n         env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  match (name $$ (xs @ [x])) (app t' y) = Some env\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1 env\\<^sub>2.\n        \\<lbrakk>match (name $$ xs) t' = Some env\\<^sub>1;\n         match x y = Some env\\<^sub>2;\n         env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: app_term_def elim: option_bindE)"], ["proof (state)\nthis:\n  match (name $$ xs) t' = Some env\\<^sub>1\n  match x y = Some env\\<^sub>2\n  env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "with snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>match (name $$ xs) ?t = Some ?env;\n   \\<And>ys.\n      \\<lbrakk>?t = name $$ ys; matchs xs ys = Some ?env\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  match (name $$ (xs @ [x])) t = Some env\n  \\<lbrakk>t = name $$ ?ys; matchs (xs @ [x]) ?ys = Some env\\<rbrakk>\n  \\<Longrightarrow> thesis\n  match (name $$ xs) t' = Some env\\<^sub>1\n  match x y = Some env\\<^sub>2\n  env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2", "obtain ys where \"t' = name $$ ys\" \"matchs xs ys = Some env\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>match (name $$ xs) ?t = Some ?env;\n   \\<And>ys.\n      \\<lbrakk>?t = name $$ ys; matchs xs ys = Some ?env\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  match (name $$ (xs @ [x])) t = Some env\n  \\<lbrakk>t = name $$ ?ys; matchs (xs @ [x]) ?ys = Some env\\<rbrakk>\n  \\<Longrightarrow> thesisa__\n  match (name $$ xs) t' = Some env\\<^sub>1\n  match x y = Some env\\<^sub>2\n  env = env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>t' = name $$ ys; matchs xs ys = Some env\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' = name $$ ys\n  matchs xs ys = Some env\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>x xs t env thesis.\n       \\<lbrakk>\\<And>t env thesis.\n                   \\<lbrakk>match (name $$ xs) t = Some env;\n                    \\<And>ys.\n                       \\<lbrakk>t = name $$ ys;\n                        matchs xs ys = Some env\\<rbrakk>\n                       \\<Longrightarrow> thesis\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        match (name $$ (xs @ [x])) t = Some env;\n        \\<And>ys.\n           \\<lbrakk>t = name $$ ys; matchs (xs @ [x]) ys = Some env\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule snoc(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. t = name $$ ?ys\n 2. matchs (xs @ [x]) ?ys = Some env", "show \"t = name $$ (ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = name $$ (ys @ [y])", "unfolding \\<open>t = _\\<close> \\<open>t' = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. app (name $$ ys) y = name $$ (ys @ [y])", "by simp"], ["proof (state)\nthis:\n  t = name $$ (ys @ [y])\n\ngoal (1 subgoal):\n 1. matchs (xs @ [x]) (ys @ [y]) = Some env", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. matchs (xs @ [x]) (ys @ [y]) = Some env", "have \"matchs [x] [y] = Some env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matchs [x] [y] = Some env\\<^sub>2", "using \\<open>match x y = _\\<close>"], ["proof (prove)\nusing this:\n  match x y = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. matchs [x] [y] = Some env\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  matchs [x] [y] = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. matchs (xs @ [x]) (ys @ [y]) = Some env", "thus \"matchs (xs @ [x]) (ys @ [y]) = Some env\""], ["proof (prove)\nusing this:\n  matchs [x] [y] = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. matchs (xs @ [x]) (ys @ [y]) = Some env", "unfolding \\<open>env = _\\<close>"], ["proof (prove)\nusing this:\n  matchs [x] [y] = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. matchs (xs @ [x]) (ys @ [y]) = Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "using \\<open>matchs xs ys = _\\<close>"], ["proof (prove)\nusing this:\n  matchs [x] [y] = Some env\\<^sub>2\n  matchs xs ys = Some env\\<^sub>1\n\ngoal (1 subgoal):\n 1. matchs (xs @ [x]) (ys @ [y]) = Some (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  matchs (xs @ [x]) (ys @ [y]) = Some env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_nesting_neq_match:\n  \"left_nesting f \\<noteq> left_nesting g \\<Longrightarrow> is_const (fst (strip_comb f)) \\<Longrightarrow> match f g = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n     is_const (fst (strip_comb f))\\<rbrakk>\n    \\<Longrightarrow> match f g = None", "proof (induction f arbitrary: g)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x g.\n       \\<lbrakk>left_nesting (Const x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Const x)))\\<rbrakk>\n       \\<Longrightarrow> match (Const x) g = None\n 2. \\<And>x g.\n       \\<lbrakk>left_nesting (Free x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Free x)))\\<rbrakk>\n       \\<Longrightarrow> match (Free x) g = None\n 3. \\<And>f g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f))\\<rbrakk>\n                   \\<Longrightarrow> match f g = None;\n        left_nesting (\\<Lambda> f) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (\\<Lambda> f)))\\<rbrakk>\n       \\<Longrightarrow> match (\\<Lambda> f) g = None\n 4. \\<And>x g.\n       \\<lbrakk>left_nesting (Bound x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Bound x)))\\<rbrakk>\n       \\<Longrightarrow> match (Bound x) g = None\n 5. \\<And>f1 f2 g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f1))\\<rbrakk>\n                   \\<Longrightarrow> match f1 g = None;\n        \\<And>g.\n           \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n            is_const (fst (strip_comb f2))\\<rbrakk>\n           \\<Longrightarrow> match f2 g = None;\n        left_nesting (f1 $ f2) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (f1 $ f2)))\\<rbrakk>\n       \\<Longrightarrow> match (f1 $ f2) g = None", "case (Const x)"], ["proof (state)\nthis:\n  left_nesting (Const x) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (Const x)))\n\ngoal (5 subgoals):\n 1. \\<And>x g.\n       \\<lbrakk>left_nesting (Const x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Const x)))\\<rbrakk>\n       \\<Longrightarrow> match (Const x) g = None\n 2. \\<And>x g.\n       \\<lbrakk>left_nesting (Free x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Free x)))\\<rbrakk>\n       \\<Longrightarrow> match (Free x) g = None\n 3. \\<And>f g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f))\\<rbrakk>\n                   \\<Longrightarrow> match f g = None;\n        left_nesting (\\<Lambda> f) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (\\<Lambda> f)))\\<rbrakk>\n       \\<Longrightarrow> match (\\<Lambda> f) g = None\n 4. \\<And>x g.\n       \\<lbrakk>left_nesting (Bound x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Bound x)))\\<rbrakk>\n       \\<Longrightarrow> match (Bound x) g = None\n 5. \\<And>f1 f2 g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f1))\\<rbrakk>\n                   \\<Longrightarrow> match f1 g = None;\n        \\<And>g.\n           \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n            is_const (fst (strip_comb f2))\\<rbrakk>\n           \\<Longrightarrow> match f2 g = None;\n        left_nesting (f1 $ f2) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (f1 $ f2)))\\<rbrakk>\n       \\<Longrightarrow> match (f1 $ f2) g = None", "then"], ["proof (chain)\npicking this:\n  left_nesting (Const x) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (Const x)))", "show ?case"], ["proof (prove)\nusing this:\n  left_nesting (Const x) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (Const x)))\n\ngoal (1 subgoal):\n 1. match (Const x) g = None", "apply (auto split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_nesting (Const x) \\<noteq> left_nesting g;\n     unconst g = Some x\\<rbrakk>\n    \\<Longrightarrow> False", "apply (fold const_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_nesting (const x) \\<noteq> left_nesting g;\n     unconst g = Some x\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  match (Const x) g = None\n\ngoal (4 subgoals):\n 1. \\<And>x g.\n       \\<lbrakk>left_nesting (Free x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Free x)))\\<rbrakk>\n       \\<Longrightarrow> match (Free x) g = None\n 2. \\<And>f g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f))\\<rbrakk>\n                   \\<Longrightarrow> match f g = None;\n        left_nesting (\\<Lambda> f) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (\\<Lambda> f)))\\<rbrakk>\n       \\<Longrightarrow> match (\\<Lambda> f) g = None\n 3. \\<And>x g.\n       \\<lbrakk>left_nesting (Bound x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Bound x)))\\<rbrakk>\n       \\<Longrightarrow> match (Bound x) g = None\n 4. \\<And>f1 f2 g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f1))\\<rbrakk>\n                   \\<Longrightarrow> match f1 g = None;\n        \\<And>g.\n           \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n            is_const (fst (strip_comb f2))\\<rbrakk>\n           \\<Longrightarrow> match f2 g = None;\n        left_nesting (f1 $ f2) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (f1 $ f2)))\\<rbrakk>\n       \\<Longrightarrow> match (f1 $ f2) g = None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x g.\n       \\<lbrakk>left_nesting (Free x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Free x)))\\<rbrakk>\n       \\<Longrightarrow> match (Free x) g = None\n 2. \\<And>f g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f))\\<rbrakk>\n                   \\<Longrightarrow> match f g = None;\n        left_nesting (\\<Lambda> f) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (\\<Lambda> f)))\\<rbrakk>\n       \\<Longrightarrow> match (\\<Lambda> f) g = None\n 3. \\<And>x g.\n       \\<lbrakk>left_nesting (Bound x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Bound x)))\\<rbrakk>\n       \\<Longrightarrow> match (Bound x) g = None\n 4. \\<And>f1 f2 g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f1))\\<rbrakk>\n                   \\<Longrightarrow> match f1 g = None;\n        \\<And>g.\n           \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n            is_const (fst (strip_comb f2))\\<rbrakk>\n           \\<Longrightarrow> match f2 g = None;\n        left_nesting (f1 $ f2) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (f1 $ f2)))\\<rbrakk>\n       \\<Longrightarrow> match (f1 $ f2) g = None", "case (App f1 f2)"], ["proof (state)\nthis:\n  \\<lbrakk>left_nesting f1 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f1))\\<rbrakk>\n  \\<Longrightarrow> match f1 ?g = None\n  \\<lbrakk>left_nesting f2 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f2))\\<rbrakk>\n  \\<Longrightarrow> match f2 ?g = None\n  left_nesting (f1 $ f2) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (f1 $ f2)))\n\ngoal (4 subgoals):\n 1. \\<And>x g.\n       \\<lbrakk>left_nesting (Free x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Free x)))\\<rbrakk>\n       \\<Longrightarrow> match (Free x) g = None\n 2. \\<And>f g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f))\\<rbrakk>\n                   \\<Longrightarrow> match f g = None;\n        left_nesting (\\<Lambda> f) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (\\<Lambda> f)))\\<rbrakk>\n       \\<Longrightarrow> match (\\<Lambda> f) g = None\n 3. \\<And>x g.\n       \\<lbrakk>left_nesting (Bound x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Bound x)))\\<rbrakk>\n       \\<Longrightarrow> match (Bound x) g = None\n 4. \\<And>f1 f2 g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f1))\\<rbrakk>\n                   \\<Longrightarrow> match f1 g = None;\n        \\<And>g.\n           \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n            is_const (fst (strip_comb f2))\\<rbrakk>\n           \\<Longrightarrow> match f2 g = None;\n        left_nesting (f1 $ f2) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (f1 $ f2)))\\<rbrakk>\n       \\<Longrightarrow> match (f1 $ f2) g = None", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>left_nesting f1 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f1))\\<rbrakk>\n  \\<Longrightarrow> match f1 ?g = None\n  \\<lbrakk>left_nesting f2 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f2))\\<rbrakk>\n  \\<Longrightarrow> match f2 ?g = None\n  left_nesting (f1 $ f2) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (f1 $ f2)))", "have f1_g: \"Suc (left_nesting f1) \\<noteq> left_nesting g\" and f1: \"is_const (fst (strip_comb f1))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>left_nesting f1 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f1))\\<rbrakk>\n  \\<Longrightarrow> match f1 ?g = None\n  \\<lbrakk>left_nesting f2 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f2))\\<rbrakk>\n  \\<Longrightarrow> match f2 ?g = None\n  left_nesting (f1 $ f2) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (f1 $ f2)))\n\ngoal (1 subgoal):\n 1. Suc (left_nesting f1) \\<noteq> left_nesting g &&&\n    is_const (fst (strip_comb f1))", "apply (fold app_term_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>g.\n                \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                 is_const (fst (strip_comb f1))\\<rbrakk>\n                \\<Longrightarrow> match f1 g = None;\n     \\<And>g.\n        \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n         is_const (fst (strip_comb f2))\\<rbrakk>\n        \\<Longrightarrow> match f2 g = None;\n     left_nesting (app f1 f2) \\<noteq> left_nesting g;\n     is_const (fst (strip_comb (app f1 f2)))\\<rbrakk>\n    \\<Longrightarrow> Suc (left_nesting f1) \\<noteq> left_nesting g\n 2. \\<lbrakk>\\<And>g.\n                \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                 is_const (fst (strip_comb f1))\\<rbrakk>\n                \\<Longrightarrow> match f1 g = None;\n     \\<And>g.\n        \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n         is_const (fst (strip_comb f2))\\<rbrakk>\n        \\<Longrightarrow> match f2 g = None;\n     left_nesting (app f1 f2) \\<noteq> left_nesting g;\n     is_const (fst (strip_comb (app f1 f2)))\\<rbrakk>\n    \\<Longrightarrow> is_const (fst (strip_comb f1))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  Suc (left_nesting f1) \\<noteq> left_nesting g\n  is_const (fst (strip_comb f1))\n\ngoal (4 subgoals):\n 1. \\<And>x g.\n       \\<lbrakk>left_nesting (Free x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Free x)))\\<rbrakk>\n       \\<Longrightarrow> match (Free x) g = None\n 2. \\<And>f g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f))\\<rbrakk>\n                   \\<Longrightarrow> match f g = None;\n        left_nesting (\\<Lambda> f) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (\\<Lambda> f)))\\<rbrakk>\n       \\<Longrightarrow> match (\\<Lambda> f) g = None\n 3. \\<And>x g.\n       \\<lbrakk>left_nesting (Bound x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Bound x)))\\<rbrakk>\n       \\<Longrightarrow> match (Bound x) g = None\n 4. \\<And>f1 f2 g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f1 \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f1))\\<rbrakk>\n                   \\<Longrightarrow> match f1 g = None;\n        \\<And>g.\n           \\<lbrakk>left_nesting f2 \\<noteq> left_nesting g;\n            is_const (fst (strip_comb f2))\\<rbrakk>\n           \\<Longrightarrow> match f2 g = None;\n        left_nesting (f1 $ f2) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (f1 $ f2)))\\<rbrakk>\n       \\<Longrightarrow> match (f1 $ f2) g = None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. match (f1 $ f2) g = None", "proof (cases \"unapp g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unapp g = None \\<Longrightarrow> match (f1 $ f2) g = None\n 2. \\<And>a. unapp g = Some a \\<Longrightarrow> match (f1 $ f2) g = None", "case (Some g')"], ["proof (state)\nthis:\n  unapp g = Some g'\n\ngoal (2 subgoals):\n 1. unapp g = None \\<Longrightarrow> match (f1 $ f2) g = None\n 2. \\<And>a. unapp g = Some a \\<Longrightarrow> match (f1 $ f2) g = None", "obtain g1 g2 where \"g' = (g1, g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g1 g2. g' = (g1, g2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases g') auto"], ["proof (state)\nthis:\n  g' = (g1, g2)\n\ngoal (2 subgoals):\n 1. unapp g = None \\<Longrightarrow> match (f1 $ f2) g = None\n 2. \\<And>a. unapp g = Some a \\<Longrightarrow> match (f1 $ f2) g = None", "with Some"], ["proof (chain)\npicking this:\n  unapp g = Some g'\n  g' = (g1, g2)", "have \"g = app g1 g2\""], ["proof (prove)\nusing this:\n  unapp g = Some g'\n  g' = (g1, g2)\n\ngoal (1 subgoal):\n 1. g = app g1 g2", "by auto"], ["proof (state)\nthis:\n  g = app g1 g2\n\ngoal (2 subgoals):\n 1. unapp g = None \\<Longrightarrow> match (f1 $ f2) g = None\n 2. \\<And>a. unapp g = Some a \\<Longrightarrow> match (f1 $ f2) g = None", "with f1_g"], ["proof (chain)\npicking this:\n  Suc (left_nesting f1) \\<noteq> left_nesting g\n  g = app g1 g2", "have \"left_nesting f1 \\<noteq> left_nesting g1\""], ["proof (prove)\nusing this:\n  Suc (left_nesting f1) \\<noteq> left_nesting g\n  g = app g1 g2\n\ngoal (1 subgoal):\n 1. left_nesting f1 \\<noteq> left_nesting g1", "by simp"], ["proof (state)\nthis:\n  left_nesting f1 \\<noteq> left_nesting g1\n\ngoal (2 subgoals):\n 1. unapp g = None \\<Longrightarrow> match (f1 $ f2) g = None\n 2. \\<And>a. unapp g = Some a \\<Longrightarrow> match (f1 $ f2) g = None", "with f1 App"], ["proof (chain)\npicking this:\n  is_const (fst (strip_comb f1))\n  \\<lbrakk>left_nesting f1 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f1))\\<rbrakk>\n  \\<Longrightarrow> match f1 ?g = None\n  \\<lbrakk>left_nesting f2 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f2))\\<rbrakk>\n  \\<Longrightarrow> match f2 ?g = None\n  left_nesting (f1 $ f2) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (f1 $ f2)))\n  left_nesting f1 \\<noteq> left_nesting g1", "have \"match f1 g1 = None\""], ["proof (prove)\nusing this:\n  is_const (fst (strip_comb f1))\n  \\<lbrakk>left_nesting f1 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f1))\\<rbrakk>\n  \\<Longrightarrow> match f1 ?g = None\n  \\<lbrakk>left_nesting f2 \\<noteq> left_nesting ?g;\n   is_const (fst (strip_comb f2))\\<rbrakk>\n  \\<Longrightarrow> match f2 ?g = None\n  left_nesting (f1 $ f2) \\<noteq> left_nesting g\n  is_const (fst (strip_comb (f1 $ f2)))\n  left_nesting f1 \\<noteq> left_nesting g1\n\ngoal (1 subgoal):\n 1. match f1 g1 = None", "by simp"], ["proof (state)\nthis:\n  match f1 g1 = None\n\ngoal (2 subgoals):\n 1. unapp g = None \\<Longrightarrow> match (f1 $ f2) g = None\n 2. \\<And>a. unapp g = Some a \\<Longrightarrow> match (f1 $ f2) g = None", "then"], ["proof (chain)\npicking this:\n  match f1 g1 = None", "show ?thesis"], ["proof (prove)\nusing this:\n  match f1 g1 = None\n\ngoal (1 subgoal):\n 1. match (f1 $ f2) g = None", "unfolding \\<open>g' = _\\<close> \\<open>g = _\\<close>"], ["proof (prove)\nusing this:\n  match f1 g1 = None\n\ngoal (1 subgoal):\n 1. match (f1 $ f2) (app g1 g2) = None", "by simp"], ["proof (state)\nthis:\n  match (f1 $ f2) g = None\n\ngoal (1 subgoal):\n 1. unapp g = None \\<Longrightarrow> match (f1 $ f2) g = None", "qed simp"], ["proof (state)\nthis:\n  match (f1 $ f2) g = None\n\ngoal (3 subgoals):\n 1. \\<And>x g.\n       \\<lbrakk>left_nesting (Free x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Free x)))\\<rbrakk>\n       \\<Longrightarrow> match (Free x) g = None\n 2. \\<And>f g.\n       \\<lbrakk>\\<And>g.\n                   \\<lbrakk>left_nesting f \\<noteq> left_nesting g;\n                    is_const (fst (strip_comb f))\\<rbrakk>\n                   \\<Longrightarrow> match f g = None;\n        left_nesting (\\<Lambda> f) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (\\<Lambda> f)))\\<rbrakk>\n       \\<Longrightarrow> match (\\<Lambda> f) g = None\n 3. \\<And>x g.\n       \\<lbrakk>left_nesting (Bound x) \\<noteq> left_nesting g;\n        is_const (fst (strip_comb (Bound x)))\\<rbrakk>\n       \\<Longrightarrow> match (Bound x) g = None", "qed auto"], ["", "context begin"], ["", "private"], ["", "lemma match_list_comb_list_comb_none_structure:\n  assumes \"length ps = length vs\" \"left_nesting f \\<noteq> left_nesting g\"\n  assumes \"is_const (fst (strip_comb f))\"\n  shows \"match (list_comb f ps) (list_comb g vs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb g vs) = None", "using assms"], ["proof (prove)\nusing this:\n  length ps = length vs\n  left_nesting f \\<noteq> left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb g vs) = None", "by (induction ps vs arbitrary: f g rule: list_induct2) (auto simp: split_beta left_nesting_neq_match)"], ["", "lemma match_list_comb_list_comb_some:\n  assumes \"match (list_comb f ps) (list_comb g vs) = Some env\" \"left_nesting f = left_nesting g\"\n  assumes \"is_const (fst (strip_comb f))\"\n  shows \"match f g \\<noteq> None\" \"length ps = length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match f g \\<noteq> None &&& length ps = length vs", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. match f g \\<noteq> None\n 2. length ps = length vs", "have \"match f g \\<noteq> None \\<and> length ps = length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match f g \\<noteq> None \\<and> length ps = length vs", "proof (cases rule: linorder_cases[where y = \"length vs\" and x = \"length ps\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length ps = length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 3. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "assume \"length ps = length vs\""], ["proof (state)\nthis:\n  length ps = length vs\n\ngoal (3 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length ps = length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 3. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "thus ?thesis"], ["proof (prove)\nusing this:\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. match f g \\<noteq> None \\<and> length ps = length vs", "using assms"], ["proof (prove)\nusing this:\n  length ps = length vs\n  match (list_comb f ps) (list_comb g vs) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. match f g \\<noteq> None \\<and> length ps = length vs", "proof (induction ps vs arbitrary: f g env rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g env.\n       \\<lbrakk>match (list_comb f []) (list_comb g []) = Some env;\n        left_nesting f = left_nesting g;\n        is_const (fst (strip_comb f))\\<rbrakk>\n       \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                         length [] = length []\n 2. \\<And>x xs y ys f g env.\n       \\<lbrakk>length xs = length ys;\n        \\<And>f g env.\n           \\<lbrakk>match (list_comb f xs) (list_comb g ys) = Some env;\n            left_nesting f = left_nesting g;\n            is_const (fst (strip_comb f))\\<rbrakk>\n           \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                             length xs = length ys;\n        match (list_comb f (x # xs)) (list_comb g (y # ys)) = Some env;\n        left_nesting f = left_nesting g;\n        is_const (fst (strip_comb f))\\<rbrakk>\n       \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                         length (x # xs) = length (y # ys)", "case (Cons p ps v vs)"], ["proof (state)\nthis:\n  length ps = length vs\n  \\<lbrakk>match (list_comb ?f ps) (list_comb ?g vs) = Some ?env;\n   left_nesting ?f = left_nesting ?g;\n   is_const (fst (strip_comb ?f))\\<rbrakk>\n  \\<Longrightarrow> match ?f ?g \\<noteq> None \\<and> length ps = length vs\n  match (list_comb f (p # ps)) (list_comb g (v # vs)) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (2 subgoals):\n 1. \\<And>f g env.\n       \\<lbrakk>match (list_comb f []) (list_comb g []) = Some env;\n        left_nesting f = left_nesting g;\n        is_const (fst (strip_comb f))\\<rbrakk>\n       \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                         length [] = length []\n 2. \\<And>x xs y ys f g env.\n       \\<lbrakk>length xs = length ys;\n        \\<And>f g env.\n           \\<lbrakk>match (list_comb f xs) (list_comb g ys) = Some env;\n            left_nesting f = left_nesting g;\n            is_const (fst (strip_comb f))\\<rbrakk>\n           \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                             length xs = length ys;\n        match (list_comb f (x # xs)) (list_comb g (y # ys)) = Some env;\n        left_nesting f = left_nesting g;\n        is_const (fst (strip_comb f))\\<rbrakk>\n       \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                         length (x # xs) = length (y # ys)", "have \"match (app f p) (app g v) \\<noteq> None \\<and> length ps = length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (app f p) (app g v) \\<noteq> None \\<and> length ps = length vs", "proof (rule Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some ?env\n 2. left_nesting (app f p) = left_nesting (app g v)\n 3. is_const (fst (strip_comb (app f p)))", "show \"is_const (fst (strip_comb (app f p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb (app f p)))", "using Cons"], ["proof (prove)\nusing this:\n  length ps = length vs\n  \\<lbrakk>match (list_comb ?f ps) (list_comb ?g vs) = Some ?env;\n   left_nesting ?f = left_nesting ?g;\n   is_const (fst (strip_comb ?f))\\<rbrakk>\n  \\<Longrightarrow> match ?f ?g \\<noteq> None \\<and> length ps = length vs\n  match (list_comb f (p # ps)) (list_comb g (v # vs)) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb (app f p)))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  is_const (fst (strip_comb (app f p)))\n\ngoal (2 subgoals):\n 1. match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some ?env\n 2. left_nesting (app f p) = left_nesting (app g v)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some ?env\n 2. left_nesting (app f p) = left_nesting (app g v)", "show \"left_nesting (app f p) = left_nesting (app g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_nesting (app f p) = left_nesting (app g v)", "using Cons"], ["proof (prove)\nusing this:\n  length ps = length vs\n  \\<lbrakk>match (list_comb ?f ps) (list_comb ?g vs) = Some ?env;\n   left_nesting ?f = left_nesting ?g;\n   is_const (fst (strip_comb ?f))\\<rbrakk>\n  \\<Longrightarrow> match ?f ?g \\<noteq> None \\<and> length ps = length vs\n  match (list_comb f (p # ps)) (list_comb g (v # vs)) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. left_nesting (app f p) = left_nesting (app g v)", "by simp"], ["proof (state)\nthis:\n  left_nesting (app f p) = left_nesting (app g v)\n\ngoal (1 subgoal):\n 1. match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some ?env", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some ?env", "show \"match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some env", "using Cons"], ["proof (prove)\nusing this:\n  length ps = length vs\n  \\<lbrakk>match (list_comb ?f ps) (list_comb ?g vs) = Some ?env;\n   left_nesting ?f = left_nesting ?g;\n   is_const (fst (strip_comb ?f))\\<rbrakk>\n  \\<Longrightarrow> match ?f ?g \\<noteq> None \\<and> length ps = length vs\n  match (list_comb f (p # ps)) (list_comb g (v # vs)) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some env", "by simp"], ["proof (state)\nthis:\n  match (list_comb (app f p) ps) (list_comb (app g v) vs) = Some env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  match (app f p) (app g v) \\<noteq> None \\<and> length ps = length vs\n\ngoal (2 subgoals):\n 1. \\<And>f g env.\n       \\<lbrakk>match (list_comb f []) (list_comb g []) = Some env;\n        left_nesting f = left_nesting g;\n        is_const (fst (strip_comb f))\\<rbrakk>\n       \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                         length [] = length []\n 2. \\<And>x xs y ys f g env.\n       \\<lbrakk>length xs = length ys;\n        \\<And>f g env.\n           \\<lbrakk>match (list_comb f xs) (list_comb g ys) = Some env;\n            left_nesting f = left_nesting g;\n            is_const (fst (strip_comb f))\\<rbrakk>\n           \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                             length xs = length ys;\n        match (list_comb f (x # xs)) (list_comb g (y # ys)) = Some env;\n        left_nesting f = left_nesting g;\n        is_const (fst (strip_comb f))\\<rbrakk>\n       \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                         length (x # xs) = length (y # ys)", "thus ?case"], ["proof (prove)\nusing this:\n  match (app f p) (app g v) \\<noteq> None \\<and> length ps = length vs\n\ngoal (1 subgoal):\n 1. match f g \\<noteq> None \\<and> length (p # ps) = length (v # vs)", "unfolding app_term_def"], ["proof (prove)\nusing this:\n  match (f $ p) (app g v) \\<noteq> None \\<and> length ps = length vs\n\ngoal (1 subgoal):\n 1. match f g \\<noteq> None \\<and> length (p # ps) = length (v # vs)", "by (auto elim: match.elims option_bindE)"], ["proof (state)\nthis:\n  match f g \\<noteq> None \\<and> length (p # ps) = length (v # vs)\n\ngoal (1 subgoal):\n 1. \\<And>f g env.\n       \\<lbrakk>match (list_comb f []) (list_comb g []) = Some env;\n        left_nesting f = left_nesting g;\n        is_const (fst (strip_comb f))\\<rbrakk>\n       \\<Longrightarrow> match f g \\<noteq> None \\<and>\n                         length [] = length []", "qed auto"], ["proof (state)\nthis:\n  match f g \\<noteq> None \\<and> length ps = length vs\n\ngoal (2 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "assume \"length ps < length vs\""], ["proof (state)\nthis:\n  length ps < length vs\n\ngoal (2 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "then"], ["proof (chain)\npicking this:\n  length ps < length vs", "obtain vs\\<^sub>1 vs\\<^sub>2 where \"vs = vs\\<^sub>1 @ vs\\<^sub>2\" \"length ps = length vs\\<^sub>2\" \"0 < length vs\\<^sub>1\""], ["proof (prove)\nusing this:\n  length ps < length vs\n\ngoal (1 subgoal):\n 1. (\\<And>vs\\<^sub>1 vs\\<^sub>2.\n        \\<lbrakk>vs = vs\\<^sub>1 @ vs\\<^sub>2;\n         length ps = length vs\\<^sub>2; 0 < length vs\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: list_split)"], ["proof (state)\nthis:\n  vs = vs\\<^sub>1 @ vs\\<^sub>2\n  length ps = length vs\\<^sub>2\n  0 < length vs\\<^sub>1\n\ngoal (2 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "have \"match (list_comb f ps) (list_comb (list_comb g vs\\<^sub>1) vs\\<^sub>2) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb (list_comb g vs\\<^sub>1) vs\\<^sub>2) =\n    None", "proof (rule match_list_comb_list_comb_none_structure)"], ["proof (state)\ngoal (3 subgoals):\n 1. length ps = length vs\\<^sub>2\n 2. left_nesting f \\<noteq> left_nesting (list_comb g vs\\<^sub>1)\n 3. is_const (fst (strip_comb f))", "show \"left_nesting f \\<noteq> left_nesting (list_comb g vs\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_nesting f \\<noteq> left_nesting (list_comb g vs\\<^sub>1)", "using assms(2) \\<open>0 < length vs\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  left_nesting f = left_nesting g\n  0 < length vs\\<^sub>1\n\ngoal (1 subgoal):\n 1. left_nesting f \\<noteq> left_nesting (list_comb g vs\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  left_nesting f \\<noteq> left_nesting (list_comb g vs\\<^sub>1)\n\ngoal (2 subgoals):\n 1. length ps = length vs\\<^sub>2\n 2. is_const (fst (strip_comb f))", "qed fact+"], ["proof (state)\nthis:\n  match (list_comb f ps) (list_comb (list_comb g vs\\<^sub>1) vs\\<^sub>2) =\n  None\n\ngoal (2 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "hence \"match (list_comb f ps) (list_comb g vs) = None\""], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb (list_comb g vs\\<^sub>1) vs\\<^sub>2) =\n  None\n\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb g vs) = None", "unfolding \\<open>vs = _\\<close>"], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb (list_comb g vs\\<^sub>1) vs\\<^sub>2) =\n  None\n\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb g (vs\\<^sub>1 @ vs\\<^sub>2)) = None", "by simp"], ["proof (state)\nthis:\n  match (list_comb f ps) (list_comb g vs) = None\n\ngoal (2 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "hence False"], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb g vs) = None\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb g vs) = None\n  match (list_comb f ps) (list_comb g vs) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. length ps < length vs \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs\n 2. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. match f g \\<noteq> None \\<and> length ps = length vs", ".."], ["proof (state)\nthis:\n  match f g \\<noteq> None \\<and> length ps = length vs\n\ngoal (1 subgoal):\n 1. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "assume \"length vs < length ps\""], ["proof (state)\nthis:\n  length vs < length ps\n\ngoal (1 subgoal):\n 1. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "then"], ["proof (chain)\npicking this:\n  length vs < length ps", "obtain ps\\<^sub>1 ps\\<^sub>2 where \"ps = ps\\<^sub>1 @ ps\\<^sub>2\" \"length ps\\<^sub>2 = length vs\" \"0 < length ps\\<^sub>1\""], ["proof (prove)\nusing this:\n  length vs < length ps\n\ngoal (1 subgoal):\n 1. (\\<And>ps\\<^sub>1 ps\\<^sub>2.\n        \\<lbrakk>ps = ps\\<^sub>1 @ ps\\<^sub>2;\n         length ps\\<^sub>2 = length vs; 0 < length ps\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: list_split)"], ["proof (state)\nthis:\n  ps = ps\\<^sub>1 @ ps\\<^sub>2\n  length ps\\<^sub>2 = length vs\n  0 < length ps\\<^sub>1\n\ngoal (1 subgoal):\n 1. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "have \"match (list_comb (list_comb f ps\\<^sub>1) ps\\<^sub>2) (list_comb g vs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (list_comb (list_comb f ps\\<^sub>1) ps\\<^sub>2) (list_comb g vs) =\n    None", "proof (rule match_list_comb_list_comb_none_structure)"], ["proof (state)\ngoal (3 subgoals):\n 1. length ps\\<^sub>2 = length vs\n 2. left_nesting (list_comb f ps\\<^sub>1) \\<noteq> left_nesting g\n 3. is_const (fst (strip_comb (list_comb f ps\\<^sub>1)))", "show \"left_nesting (list_comb f ps\\<^sub>1) \\<noteq> left_nesting g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_nesting (list_comb f ps\\<^sub>1) \\<noteq> left_nesting g", "using assms \\<open>0 < length ps\\<^sub>1\\<close>"], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb g vs) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n  0 < length ps\\<^sub>1\n\ngoal (1 subgoal):\n 1. left_nesting (list_comb f ps\\<^sub>1) \\<noteq> left_nesting g", "by simp"], ["proof (state)\nthis:\n  left_nesting (list_comb f ps\\<^sub>1) \\<noteq> left_nesting g\n\ngoal (2 subgoals):\n 1. length ps\\<^sub>2 = length vs\n 2. is_const (fst (strip_comb (list_comb f ps\\<^sub>1)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length ps\\<^sub>2 = length vs\n 2. is_const (fst (strip_comb (list_comb f ps\\<^sub>1)))", "show \"is_const (fst (strip_comb (list_comb f ps\\<^sub>1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb (list_comb f ps\\<^sub>1)))", "using assms"], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb g vs) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. is_const (fst (strip_comb (list_comb f ps\\<^sub>1)))", "by (simp add: strip_list_comb)"], ["proof (state)\nthis:\n  is_const (fst (strip_comb (list_comb f ps\\<^sub>1)))\n\ngoal (1 subgoal):\n 1. length ps\\<^sub>2 = length vs", "qed fact"], ["proof (state)\nthis:\n  match (list_comb (list_comb f ps\\<^sub>1) ps\\<^sub>2) (list_comb g vs) =\n  None\n\ngoal (1 subgoal):\n 1. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "hence \"match (list_comb f ps) (list_comb g vs) = None\""], ["proof (prove)\nusing this:\n  match (list_comb (list_comb f ps\\<^sub>1) ps\\<^sub>2) (list_comb g vs) =\n  None\n\ngoal (1 subgoal):\n 1. match (list_comb f ps) (list_comb g vs) = None", "unfolding \\<open>ps = _\\<close>"], ["proof (prove)\nusing this:\n  match (list_comb (list_comb f ps\\<^sub>1) ps\\<^sub>2) (list_comb g vs) =\n  None\n\ngoal (1 subgoal):\n 1. match (list_comb f (ps\\<^sub>1 @ ps\\<^sub>2)) (list_comb g vs) = None", "by simp"], ["proof (state)\nthis:\n  match (list_comb f ps) (list_comb g vs) = None\n\ngoal (1 subgoal):\n 1. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "hence False"], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb g vs) = None\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  match (list_comb f ps) (list_comb g vs) = None\n  match (list_comb f ps) (list_comb g vs) = Some env\n  left_nesting f = left_nesting g\n  is_const (fst (strip_comb f))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. length vs < length ps \\<Longrightarrow>\n    match f g \\<noteq> None \\<and> length ps = length vs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. match f g \\<noteq> None \\<and> length ps = length vs", ".."], ["proof (state)\nthis:\n  match f g \\<noteq> None \\<and> length ps = length vs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  match f g \\<noteq> None \\<and> length ps = length vs\n\ngoal (2 subgoals):\n 1. match f g \\<noteq> None\n 2. length ps = length vs", "thus \"match f g \\<noteq> None\" \"length ps = length vs\""], ["proof (prove)\nusing this:\n  match f g \\<noteq> None \\<and> length ps = length vs\n\ngoal (1 subgoal):\n 1. match f g \\<noteq> None &&& length ps = length vs", "by simp+"], ["proof (state)\nthis:\n  match f g \\<noteq> None\n  length ps = length vs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma match_list_comb_list_comb_none_name[simp]:\n  assumes \"name \\<noteq> name'\"\n  shows \"match (name $$ ps) (name' $$ vs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) = None", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "assume \"match (name $$ ps) (name' $$ vs) \\<noteq> None\""], ["proof (state)\nthis:\n  match (name $$ ps) (name' $$ vs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  match (name $$ ps) (name' $$ vs) \\<noteq> None", "obtain env where *: \"match (name $$ ps) (name' $$ vs) = Some env\""], ["proof (prove)\nusing this:\n  match (name $$ ps) (name' $$ vs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        match (name $$ ps) (name' $$ vs) = Some env \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  match (name $$ ps) (name' $$ vs) = Some env\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "hence \"match (const name) (const name' :: 'a) \\<noteq> None\""], ["proof (prove)\nusing this:\n  match (name $$ ps) (name' $$ vs) = Some env\n\ngoal (1 subgoal):\n 1. match (const name) (const name') \\<noteq> None", "by (rule match_list_comb_list_comb_some) (simp add: is_const_def)+"], ["proof (state)\nthis:\n  match (const name) (const name') \\<noteq> None\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "hence \"name = name'\""], ["proof (prove)\nusing this:\n  match (const name) (const name') \\<noteq> None\n\ngoal (1 subgoal):\n 1. name = name'", "unfolding const_term_def"], ["proof (prove)\nusing this:\n  match (Const name) (const name') \\<noteq> None\n\ngoal (1 subgoal):\n 1. name = name'", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  name = name'\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  name = name'\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  name = name'\n  name \\<noteq> name'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma match_list_comb_list_comb_none_length[simp]:\n  assumes \"length ps \\<noteq> length vs\"\n  shows \"match (name $$ ps) (name' $$ vs) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) = None", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "assume \"match (name $$ ps) (name' $$ vs) \\<noteq> None\""], ["proof (state)\nthis:\n  match (name $$ ps) (name' $$ vs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  match (name $$ ps) (name' $$ vs) \\<noteq> None", "obtain env where \"match (name $$ ps) (name' $$ vs) = Some env\""], ["proof (prove)\nusing this:\n  match (name $$ ps) (name' $$ vs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>env.\n        match (name $$ ps) (name' $$ vs) = Some env \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  match (name $$ ps) (name' $$ vs) = Some env\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "hence \"length ps = length vs\""], ["proof (prove)\nusing this:\n  match (name $$ ps) (name' $$ vs) = Some env\n\ngoal (1 subgoal):\n 1. length ps = length vs", "by (rule match_list_comb_list_comb_some) (simp add: is_const_def)+"], ["proof (state)\nthis:\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name' $$ vs) \\<noteq> None \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  length ps = length vs\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  length ps = length vs\n  length ps \\<noteq> length vs\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "context term_struct_rel begin"], ["", "corollary related_matchs:\n  assumes \"matchs ps ts\\<^sub>2 = Some env\\<^sub>2\" \"list_all2 P ts\\<^sub>1 ts\\<^sub>2\"\n  obtains env\\<^sub>1 where \"matchs ps ts\\<^sub>1 = Some env\\<^sub>1\" \"P_env env\\<^sub>1 env\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix name \\<comment> \\<open>dummy\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  matchs ps ts\\<^sub>2 = Some env\\<^sub>2\n  list_all2 P ts\\<^sub>1 ts\\<^sub>2", "have \"match (name $$ ps) (name $$ ts\\<^sub>2) = Some env\\<^sub>2\""], ["proof (prove)\nusing this:\n  matchs ps ts\\<^sub>2 = Some env\\<^sub>2\n  list_all2 P ts\\<^sub>1 ts\\<^sub>2\n\ngoal (1 subgoal):\n 1. match (name $$ ps) (name $$ ts\\<^sub>2) = Some env\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  match (name $$ ps) (name $$ ts\\<^sub>2) = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  match (name $$ ps) (name $$ ts\\<^sub>2) = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"P (name $$ ts\\<^sub>1) (name $$ ts\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (name $$ ts\\<^sub>1) (name $$ ts\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  matchs ps ts\\<^sub>2 = Some env\\<^sub>2\n  list_all2 P ts\\<^sub>1 ts\\<^sub>2\n\ngoal (1 subgoal):\n 1. P (name $$ ts\\<^sub>1) (name $$ ts\\<^sub>2)", "by (auto intro: P_const_const list_combI)"], ["proof (state)\nthis:\n  P (name $$ ts\\<^sub>1) (name $$ ts\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  match (name $$ ps) (name $$ ts\\<^sub>2) = Some env\\<^sub>2\n  P (name $$ ts\\<^sub>1) (name $$ ts\\<^sub>2)", "obtain env\\<^sub>1 where \"match (name $$ ps) (name $$ ts\\<^sub>1) = Some env\\<^sub>1\" \"P_env env\\<^sub>1 env\\<^sub>2\""], ["proof (prove)\nusing this:\n  match (name $$ ps) (name $$ ts\\<^sub>2) = Some env\\<^sub>2\n  P (name $$ ts\\<^sub>1) (name $$ ts\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>match (name $$ ps) (name $$ ts\\<^sub>1) = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis related_match)"], ["proof (state)\nthis:\n  match (name $$ ps) (name $$ ts\\<^sub>1) = Some env\\<^sub>1\n  P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"matchs ps ts\\<^sub>1 = Some env\\<^sub>1\""], ["proof (prove)\nusing this:\n  match (name $$ ps) (name $$ ts\\<^sub>1) = Some env\\<^sub>1\n  P_env env\\<^sub>1 env\\<^sub>2\n\ngoal (1 subgoal):\n 1. matchs ps ts\\<^sub>1 = Some env\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  matchs ps ts\\<^sub>1 = Some env\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>env\\<^sub>1.\n        \\<lbrakk>matchs ps ts\\<^sub>1 = Some env\\<^sub>1;\n         P_env env\\<^sub>1 env\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule that) fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}