{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Name.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemma less_name_code[code]:\n  \"Name xs < Name [] \\<longleftrightarrow> False\"\n  \"Name [] < Name (x # xs) \\<longleftrightarrow> True\"\n  \"Name (x # xs) < Name (y # ys) \\<longleftrightarrow> (of_char x::nat) < of_char y \\<or> x = y \\<and> Name xs < Name ys\"", "lemma le_name_code[code]:\n  \"Name (x # xs) \\<le> Name [] \\<longleftrightarrow> False\"\n  \"Name [] \\<le> Name (x # xs) \\<longleftrightarrow> True\"\n  \"Name (x # xs) \\<le> Name (y # ys) \\<longleftrightarrow> (of_char x::nat) < of_char y \\<or> x = y \\<and> Name xs \\<le> Name ys\"", "lemma name_append_less:\n  assumes \"xs \\<noteq> Name []\"\n  shows \"append ys xs > ys\""], "translations": [["", "lemma less_name_code[code]:\n  \"Name xs < Name [] \\<longleftrightarrow> False\"\n  \"Name [] < Name (x # xs) \\<longleftrightarrow> True\"\n  \"Name (x # xs) < Name (y # ys) \\<longleftrightarrow> (of_char x::nat) < of_char y \\<or> x = y \\<and> Name xs < Name ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Name xs < Name []) = False &&&\n    (Name [] < Name (x # xs)) = True &&&\n    (Name (x # xs) < Name (y # ys)) =\n    (of_char x < of_char y \\<or> x = y \\<and> Name xs < Name ys)", "unfolding less_name_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((as_string (Name xs), as_string (Name []))\n     \\<in> lexord {(u, v). of_char u < of_char v}) =\n    False &&&\n    ((as_string (Name []), as_string (Name (x # xs)))\n     \\<in> lexord {(u, v). of_char u < of_char v}) =\n    True &&&\n    ((as_string (Name (x # xs)), as_string (Name (y # ys)))\n     \\<in> lexord {(u, v). of_char u < of_char v}) =\n    (of_char x < of_char y \\<or>\n     x = y \\<and>\n     (as_string (Name xs), as_string (Name ys))\n     \\<in> lexord {(u, v). of_char u < of_char v})", "by auto"], ["", "lemma le_name_code[code]:\n  \"Name (x # xs) \\<le> Name [] \\<longleftrightarrow> False\"\n  \"Name [] \\<le> Name (x # xs) \\<longleftrightarrow> True\"\n  \"Name (x # xs) \\<le> Name (y # ys) \\<longleftrightarrow> (of_char x::nat) < of_char y \\<or> x = y \\<and> Name xs \\<le> Name ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Name (x # xs) \\<le> Name []) = False &&&\n    (Name [] \\<le> Name (x # xs)) = True &&&\n    (Name (x # xs) \\<le> Name (y # ys)) =\n    (of_char x < of_char y \\<or> x = y \\<and> Name xs \\<le> Name ys)", "unfolding less_eq_name_def less_name_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((as_string (Name (x # xs)), as_string (Name []))\n     \\<in> lexord {(u, v). of_char u < of_char v} \\<or>\n     Name (x # xs) = Name []) =\n    False &&&\n    ((as_string (Name []), as_string (Name (x # xs)))\n     \\<in> lexord {(u, v). of_char u < of_char v} \\<or>\n     Name [] = Name (x # xs)) =\n    True &&&\n    ((as_string (Name (x # xs)), as_string (Name (y # ys)))\n     \\<in> lexord {(u, v). of_char u < of_char v} \\<or>\n     Name (x # xs) = Name (y # ys)) =\n    (of_char x < of_char y \\<or>\n     x = y \\<and>\n     ((as_string (Name xs), as_string (Name ys))\n      \\<in> lexord {(u, v). of_char u < of_char v} \\<or>\n      Name xs = Name ys))", "by auto"], ["", "context begin"], ["", "qualified"], ["", "definition append :: \"name \\<Rightarrow> name \\<Rightarrow> name\" where\n\"append v1 v2 = Name (as_string v1 @ as_string v2)\""], ["", "lemma name_append_less:\n  assumes \"xs \\<noteq> Name []\"\n  shows \"append ys xs > ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys < local.append ys xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ys < local.append ys xs", "have \"Name (ys @ xs) > Name ys\" if \"xs \\<noteq> []\" for xs ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. Name ys < Name (ys @ xs)", "using that"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Name ys < Name (ys @ xs)", "proof (induction ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs \\<noteq> [] \\<Longrightarrow> Name [] < Name ([] @ xs)\n 2. \\<And>a ys.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> Name ys < Name (ys @ xs);\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Name (a # ys) < Name ((a # ys) @ xs)", "case Nil"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. xs \\<noteq> [] \\<Longrightarrow> Name [] < Name ([] @ xs)\n 2. \\<And>a ys.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> Name ys < Name (ys @ xs);\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Name (a # ys) < Name ((a # ys) @ xs)", "thus ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Name [] < Name ([] @ xs)", "unfolding less_name_def"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (as_string (Name []), as_string (Name ([] @ xs)))\n    \\<in> lexord {(u, v). of_char u < of_char v}", "by (cases xs) auto"], ["proof (state)\nthis:\n  Name [] < Name ([] @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> Name ys < Name (ys @ xs);\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Name (a # ys) < Name ((a # ys) @ xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> Name ys < Name (ys @ xs);\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Name (a # ys) < Name ((a # ys) @ xs)", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow> Name ys < Name (ys @ xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> Name ys < Name (ys @ xs);\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Name (a # ys) < Name ((a # ys) @ xs)", "thus ?case"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow> Name ys < Name (ys @ xs)\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Name (y # ys) < Name ((y # ys) @ xs)", "unfolding less_name_def"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  (as_string (Name ys), as_string (Name (ys @ xs)))\n  \\<in> lexord {(u, v). of_char u < of_char v}\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (as_string (Name (y # ys)), as_string (Name ((y # ys) @ xs)))\n    \\<in> lexord {(u, v). of_char u < of_char v}", "by auto"], ["proof (state)\nthis:\n  Name (y # ys) < Name ((y # ys) @ xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?xs \\<noteq> [] \\<Longrightarrow> Name ?ys < Name (?ys @ ?xs)\n\ngoal (1 subgoal):\n 1. ys < local.append ys xs", "with assms"], ["proof (chain)\npicking this:\n  xs \\<noteq> Name []\n  ?xs \\<noteq> [] \\<Longrightarrow> Name ?ys < Name (?ys @ ?xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> Name []\n  ?xs \\<noteq> [] \\<Longrightarrow> Name ?ys < Name (?ys @ ?xs)\n\ngoal (1 subgoal):\n 1. ys < local.append ys xs", "unfolding append_def"], ["proof (prove)\nusing this:\n  xs \\<noteq> Name []\n  ?xs \\<noteq> [] \\<Longrightarrow> Name ?ys < Name (?ys @ ?xs)\n\ngoal (1 subgoal):\n 1. ys < Name (as_string ys @ as_string xs)", "by (cases xs, cases ys) auto"], ["proof (state)\nthis:\n  ys < local.append ys xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}