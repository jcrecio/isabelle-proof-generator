{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Disjoint_Sets.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemma disjnt_insert: \"x \\<notin> N \\<Longrightarrow> disjnt M N \\<Longrightarrow> disjnt (insert x M) N\"", "lemma disjnt_ge_max:\n  assumes \"finite Y\" \"\\<And>x. x \\<in> X \\<Longrightarrow> x > Max Y\"\n  shows \"disjnt X Y\"", "lemma fdisjnt_alt_def: \"fdisjnt M N \\<longleftrightarrow> (M |\\<inter>| N = {||})\"", "lemma fdisjnt_insert: \"x |\\<notin>| N \\<Longrightarrow> fdisjnt M N \\<Longrightarrow> fdisjnt (finsert x M) N\"", "lemma fdisjnt_subset_right: \"N' |\\<subseteq>| N \\<Longrightarrow> fdisjnt M N \\<Longrightarrow> fdisjnt M N'\"", "lemma fdisjnt_subset_left: \"N' |\\<subseteq>| N \\<Longrightarrow> fdisjnt N M \\<Longrightarrow> fdisjnt N' M\"", "lemma fdisjnt_union_right: \"fdisjnt M A \\<Longrightarrow> fdisjnt M B \\<Longrightarrow> fdisjnt M (A |\\<union>| B)\"", "lemma fdisjnt_union_left: \"fdisjnt A M \\<Longrightarrow> fdisjnt B M \\<Longrightarrow> fdisjnt (A |\\<union>| B) M\"", "lemma fdisjnt_swap: \"fdisjnt M N \\<Longrightarrow> fdisjnt N M\"", "lemma distinct_append_fset:\n  assumes \"distinct xs\" \"distinct ys\" \"fdisjnt (fset_of_list xs) (fset_of_list ys)\"\n  shows \"distinct (xs @ ys)\"", "lemma fdisjnt_contrI:\n  assumes \"\\<And>x. x |\\<in>| M \\<Longrightarrow> x |\\<in>| N \\<Longrightarrow> False\"\n  shows \"fdisjnt M N\"", "lemma fdisjnt_Union_left: \"fdisjnt (ffUnion S) T \\<longleftrightarrow> fBall S (\\<lambda>S. fdisjnt S T)\"", "lemma fdisjnt_Union_right: \"fdisjnt T (ffUnion S) \\<longleftrightarrow> fBall S (\\<lambda>S. fdisjnt T S)\"", "lemma fdisjnt_ge_max: \"fBall X (\\<lambda>x. x > fMax Y) \\<Longrightarrow> fdisjnt X Y\"", "lemma fmadd_disjnt: \"fdisjnt (fmdom m) (fmdom n) \\<Longrightarrow> m ++\\<^sub>f n = n ++\\<^sub>f m\""], "translations": [["", "lemma disjnt_insert: \"x \\<notin> N \\<Longrightarrow> disjnt M N \\<Longrightarrow> disjnt (insert x M) N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> N; disjnt M N\\<rbrakk>\n    \\<Longrightarrow> disjnt (insert x M) N", "unfolding disjnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> N; M \\<inter> N = {}\\<rbrakk>\n    \\<Longrightarrow> insert x M \\<inter> N = {}", "by simp"], ["", "lemma disjnt_ge_max:\n  assumes \"finite Y\" \"\\<And>x. x \\<in> X \\<Longrightarrow> x > Max Y\"\n  shows \"disjnt X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt X Y", "unfolding disjnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter> Y = {}", "by (meson Int_emptyI Max.coboundedI assms(1) assms(2) leD)"], ["", "context\n  includes fset.lifting\nbegin"], ["", "lift_definition fdisjnt :: \"'a fset \\<Rightarrow> 'a fset \\<Rightarrow> bool\" is disjnt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma fdisjnt_alt_def: \"fdisjnt M N \\<longleftrightarrow> (M |\\<inter>| N = {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt M N = (M |\\<inter>| N = {||})", "by transfer (simp add: disjnt_def)"], ["", "lemma fdisjnt_insert: \"x |\\<notin>| N \\<Longrightarrow> fdisjnt M N \\<Longrightarrow> fdisjnt (finsert x M) N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x |\\<notin>| N; fdisjnt M N\\<rbrakk>\n    \\<Longrightarrow> fdisjnt (finsert x M) N", "by transfer' (rule disjnt_insert)"], ["", "lemma fdisjnt_subset_right: \"N' |\\<subseteq>| N \\<Longrightarrow> fdisjnt M N \\<Longrightarrow> fdisjnt M N'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N' |\\<subseteq>| N; fdisjnt M N\\<rbrakk>\n    \\<Longrightarrow> fdisjnt M N'", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N' |\\<subseteq>| N; M |\\<inter>| N = {||}\\<rbrakk>\n    \\<Longrightarrow> M |\\<inter>| N' = {||}", "by auto"], ["", "lemma fdisjnt_subset_left: \"N' |\\<subseteq>| N \\<Longrightarrow> fdisjnt N M \\<Longrightarrow> fdisjnt N' M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N' |\\<subseteq>| N; fdisjnt N M\\<rbrakk>\n    \\<Longrightarrow> fdisjnt N' M", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>N' |\\<subseteq>| N; N |\\<inter>| M = {||}\\<rbrakk>\n    \\<Longrightarrow> N' |\\<inter>| M = {||}", "by auto"], ["", "lemma fdisjnt_union_right: \"fdisjnt M A \\<Longrightarrow> fdisjnt M B \\<Longrightarrow> fdisjnt M (A |\\<union>| B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fdisjnt M A; fdisjnt M B\\<rbrakk>\n    \\<Longrightarrow> fdisjnt M (A |\\<union>| B)", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M |\\<inter>| A = {||}; M |\\<inter>| B = {||}\\<rbrakk>\n    \\<Longrightarrow> M |\\<inter>| (A |\\<union>| B) = {||}", "by auto"], ["", "lemma fdisjnt_union_left: \"fdisjnt A M \\<Longrightarrow> fdisjnt B M \\<Longrightarrow> fdisjnt (A |\\<union>| B) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fdisjnt A M; fdisjnt B M\\<rbrakk>\n    \\<Longrightarrow> fdisjnt (A |\\<union>| B) M", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A |\\<inter>| M = {||}; B |\\<inter>| M = {||}\\<rbrakk>\n    \\<Longrightarrow> A |\\<union>| B |\\<inter>| M = {||}", "by auto"], ["", "lemma fdisjnt_swap: \"fdisjnt M N \\<Longrightarrow> fdisjnt N M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt M N \\<Longrightarrow> fdisjnt N M", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt M N \\<Longrightarrow> fdisjnt N M", "by transfer' (auto simp: disjnt_def)"], ["", "lemma distinct_append_fset:\n  assumes \"distinct xs\" \"distinct ys\" \"fdisjnt (fset_of_list xs) (fset_of_list ys)\"\n  shows \"distinct (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs @ ys)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  distinct ys\n  fdisjnt (fset_of_list xs) (fset_of_list ys)\n\ngoal (1 subgoal):\n 1. distinct (xs @ ys)", "by transfer' (simp add: disjnt_def)"], ["", "lemma fdisjnt_contrI:\n  assumes \"\\<And>x. x |\\<in>| M \\<Longrightarrow> x |\\<in>| N \\<Longrightarrow> False\"\n  shows \"fdisjnt M N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt M N", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x |\\<in>| M; ?x |\\<in>| N\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. fdisjnt M N", "by transfer' (auto simp: disjnt_def)"], ["", "lemma fdisjnt_Union_left: \"fdisjnt (ffUnion S) T \\<longleftrightarrow> fBall S (\\<lambda>S. fdisjnt S T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (ffUnion S) T = fBall S (\\<lambda>S. fdisjnt S T)", "by transfer' (auto simp: disjnt_def)"], ["", "lemma fdisjnt_Union_right: \"fdisjnt T (ffUnion S) \\<longleftrightarrow> fBall S (\\<lambda>S. fdisjnt T S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt T (ffUnion S) = fBall S (fdisjnt T)", "by transfer' (auto simp: disjnt_def)"], ["", "lemma fdisjnt_ge_max: \"fBall X (\\<lambda>x. x > fMax Y) \\<Longrightarrow> fdisjnt X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall X ((<) (fMax Y)) \\<Longrightarrow> fdisjnt X Y", "by transfer (auto intro: disjnt_ge_max)"], ["", "end"], ["", "(* FIXME should be provable without lifting *)"], ["", "lemma fmadd_disjnt: \"fdisjnt (fmdom m) (fmdom n) \\<Longrightarrow> m ++\\<^sub>f n = n ++\\<^sub>f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fmdom m) (fmdom n) \\<Longrightarrow>\n    m ++\\<^sub>f n = n ++\\<^sub>f m", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom m |\\<inter>| fmdom n = {||} \\<Longrightarrow>\n    m ++\\<^sub>f n = n ++\\<^sub>f m", "including fset.lifting fmap.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmdom m |\\<inter>| fmdom n = {||} \\<Longrightarrow>\n    m ++\\<^sub>f n = n ++\\<^sub>f m", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>finite (dom m); finite (dom n);\n        dom m \\<inter> dom n = {}\\<rbrakk>\n       \\<Longrightarrow> m ++ n = n ++ m", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n x.\n       \\<lbrakk>finite (dom m); finite (dom n);\n        dom m \\<inter> dom n = {}\\<rbrakk>\n       \\<Longrightarrow> (m ++ n) x = (n ++ m) x", "apply (auto simp: map_add_def split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}