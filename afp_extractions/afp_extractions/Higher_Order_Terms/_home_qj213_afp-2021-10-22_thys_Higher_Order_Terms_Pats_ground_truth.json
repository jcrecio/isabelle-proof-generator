{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Pats.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemmas linear_simps[simp] =\n  linear.simps(2)[folded const_term_def]\n  linear.simps(3)[folded app_term_def]", "lemma linear_implies_no_abs: \"linear t \\<Longrightarrow> no_abs t\"", "lemma linears_butlastI[intro]: \"linears ts \\<Longrightarrow> linears (butlast ts)\"", "lemma linears_appI[intro]:\n  assumes \"linears xs\" \"linears ys\" \"fdisjnt (freess xs) (freess ys)\"\n  shows \"linears (xs @ ys)\"", "lemma linears_linear: \"linears ts \\<Longrightarrow> t \\<in> set ts \\<Longrightarrow> linear t\"", "lemma linears_singleI[intro]: \"linear t \\<Longrightarrow> linears [t]\"", "lemma linear_strip_comb: \"linear t \\<Longrightarrow> linear (fst (strip_comb t))\"", "lemma linears_strip_comb: \"linear t \\<Longrightarrow> linears (snd (strip_comb t))\"", "lemma linears_appendD:\n  assumes \"linears (xs @ ys)\"\n  shows \"linears xs\" \"linears ys\" \"fdisjnt (freess xs) (freess ys)\"", "lemma linear_list_comb:\n  assumes \"linear f\" \"linears xs\" \"fdisjnt (frees f) (freess xs)\" \"\\<not> is_free f\"\n  shows \"linear (list_comb f xs)\"", "lemma linear_strip_comb_cases[consumes 1]:\n  assumes \"linear pat\"\n  obtains (comb) s args where \"strip_comb pat = (Const s, args)\" \"pat = s $$ args\"\n        | (free) s where \"strip_comb pat = (Free s, [])\" \"pat = Free s\"", "lemma wellformed_linearI: \"linear t \\<Longrightarrow> wellformed' n t\"", "lemma pat_cases:\n  obtains (free) s where \"t = Free s\"\n        | (comb) name args where \"linears args\" \"t = name $$ args\"\n        | (nonlinear) \"\\<not> linear t\"", "lemma linear_pat_induct[consumes 1, case_names free comb]:\n  assumes \"linear t\"\n  assumes \"\\<And>s. P (Free s)\"\n  assumes \"\\<And>name args. linears args \\<Longrightarrow> (\\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg) \\<Longrightarrow> P (name $$ args)\"\n  shows \"P t\"", "lemma match_subst_correctness0:\n  assumes \"linear t\"\n  shows \"case match t u of\n          None \\<Rightarrow> (\\<forall>env. subst (convert_term t) env \\<noteq> u) |\n          Some env \\<Rightarrow> subst (convert_term t) env = u\"", "lemma match_subst_some[simp]:\n  \"match t u = Some env \\<Longrightarrow> linear t \\<Longrightarrow> subst (convert_term t) env = u\"", "lemma match_subst_none:\n  \"match t u = None \\<Longrightarrow> linear t \\<Longrightarrow> subst (convert_term t) env = u \\<Longrightarrow> False\"", "lemma match_matches: \"match t u = Some env \\<Longrightarrow> linear t \\<Longrightarrow> t \\<lesssim> u\"", "lemma overlapping_var1I: \"overlapping (Free name) t\"", "lemma overlapping_var2I: \"overlapping t (Free name)\"", "lemma non_overlapping_appI1: \"non_overlapping t\\<^sub>1 u\\<^sub>1 \\<Longrightarrow> non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (u\\<^sub>1 $ u\\<^sub>2)\"", "lemma non_overlapping_appI2: \"non_overlapping t\\<^sub>2 u\\<^sub>2 \\<Longrightarrow> non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (u\\<^sub>1 $ u\\<^sub>2)\"", "lemma non_overlapping_app_constI: \"non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (Const name)\"", "lemma non_overlapping_const_appI: \"non_overlapping (Const name) (t\\<^sub>1 $ t\\<^sub>2)\"", "lemma non_overlapping_const_constI: \"x \\<noteq> y \\<Longrightarrow> non_overlapping (Const x) (Const y)\"", "lemma match_overlapping:\n  assumes \"linear t\\<^sub>1\" \"linear t\\<^sub>2\"\n  assumes \"match t\\<^sub>1 u = Some env\\<^sub>1\" \"match t\\<^sub>2 u = Some env\\<^sub>2\"\n  shows \"overlapping t\\<^sub>1 t\\<^sub>2\""], "translations": [["", "lemmas linear_simps[simp] =\n  linear.simps(2)[folded const_term_def]\n  linear.simps(3)[folded app_term_def]"], ["", "lemma linear_implies_no_abs: \"linear t \\<Longrightarrow> no_abs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> no_abs t", "proof induction"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x. linear (Const x) \\<Longrightarrow> no_abs (Const x)\n 2. \\<And>x. linear (Free x) \\<Longrightarrow> no_abs (Free x)\n 3. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 4. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "case Const"], ["proof (state)\nthis:\n  linear (Const x_)\n\ngoal (5 subgoals):\n 1. \\<And>x. linear (Const x) \\<Longrightarrow> no_abs (Const x)\n 2. \\<And>x. linear (Free x) \\<Longrightarrow> no_abs (Free x)\n 3. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 4. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 5. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "then"], ["proof (chain)\npicking this:\n  linear (Const x_)", "show ?case"], ["proof (prove)\nusing this:\n  linear (Const x_)\n\ngoal (1 subgoal):\n 1. no_abs (Const x_)", "by (fold const_term_def free_term_def app_term_def) auto"], ["proof (state)\nthis:\n  no_abs (Const x_)\n\ngoal (4 subgoals):\n 1. \\<And>x. linear (Free x) \\<Longrightarrow> no_abs (Free x)\n 2. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 3. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. linear (Free x) \\<Longrightarrow> no_abs (Free x)\n 2. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 3. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "case Free"], ["proof (state)\nthis:\n  linear (Free x_)\n\ngoal (4 subgoals):\n 1. \\<And>x. linear (Free x) \\<Longrightarrow> no_abs (Free x)\n 2. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 3. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 4. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "then"], ["proof (chain)\npicking this:\n  linear (Free x_)", "show ?case"], ["proof (prove)\nusing this:\n  linear (Free x_)\n\ngoal (1 subgoal):\n 1. no_abs (Free x_)", "by (fold const_term_def free_term_def app_term_def) auto"], ["proof (state)\nthis:\n  no_abs (Free x_)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 2. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 2. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "case App"], ["proof (state)\nthis:\n  linear x1a_ \\<Longrightarrow> no_abs x1a_\n  linear x2a_ \\<Longrightarrow> no_abs x2a_\n  linear (x1a_ $ x2a_)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 2. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)\n 3. \\<And>x1a x2a.\n       \\<lbrakk>linear x1a \\<Longrightarrow> no_abs x1a;\n        linear x2a \\<Longrightarrow> no_abs x2a; linear (x1a $ x2a)\\<rbrakk>\n       \\<Longrightarrow> no_abs (x1a $ x2a)", "then"], ["proof (chain)\npicking this:\n  linear x1a_ \\<Longrightarrow> no_abs x1a_\n  linear x2a_ \\<Longrightarrow> no_abs x2a_\n  linear (x1a_ $ x2a_)", "show ?case"], ["proof (prove)\nusing this:\n  linear x1a_ \\<Longrightarrow> no_abs x1a_\n  linear x2a_ \\<Longrightarrow> no_abs x2a_\n  linear (x1a_ $ x2a_)\n\ngoal (1 subgoal):\n 1. no_abs (x1a_ $ x2a_)", "by (fold const_term_def free_term_def app_term_def) auto"], ["proof (state)\nthis:\n  no_abs (x1a_ $ x2a_)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>linear x \\<Longrightarrow> no_abs x;\n        linear (\\<Lambda> x)\\<rbrakk>\n       \\<Longrightarrow> no_abs (\\<Lambda> x)\n 2. \\<And>x. linear (Bound x) \\<Longrightarrow> no_abs (Bound x)", "qed auto"], ["", "fun linears :: \"term list \\<Rightarrow> bool\" where\n\"linears [] \\<longleftrightarrow> True\" |\n\"linears (t # ts) \\<longleftrightarrow> linear t \\<and> fdisjnt (frees t) (freess ts) \\<and> linears ts\""], ["", "lemma linears_butlastI[intro]: \"linears ts \\<Longrightarrow> linears (butlast ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears ts \\<Longrightarrow> linears (butlast ts)", "proof (induction ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. linears [] \\<Longrightarrow> linears (butlast [])\n 2. \\<And>a ts.\n       \\<lbrakk>linears ts \\<Longrightarrow> linears (butlast ts);\n        linears (a # ts)\\<rbrakk>\n       \\<Longrightarrow> linears (butlast (a # ts))", "case (Cons t ts)"], ["proof (state)\nthis:\n  linears ts \\<Longrightarrow> linears (butlast ts)\n  linears (t # ts)\n\ngoal (2 subgoals):\n 1. linears [] \\<Longrightarrow> linears (butlast [])\n 2. \\<And>a ts.\n       \\<lbrakk>linears ts \\<Longrightarrow> linears (butlast ts);\n        linears (a # ts)\\<rbrakk>\n       \\<Longrightarrow> linears (butlast (a # ts))", "hence \"linear t\" \"linears (butlast ts)\""], ["proof (prove)\nusing this:\n  linears ts \\<Longrightarrow> linears (butlast ts)\n  linears (t # ts)\n\ngoal (1 subgoal):\n 1. linear t &&& linears (butlast ts)", "by simp+"], ["proof (state)\nthis:\n  linear t\n  linears (butlast ts)\n\ngoal (2 subgoals):\n 1. linears [] \\<Longrightarrow> linears (butlast [])\n 2. \\<And>a ts.\n       \\<lbrakk>linears ts \\<Longrightarrow> linears (butlast ts);\n        linears (a # ts)\\<rbrakk>\n       \\<Longrightarrow> linears (butlast (a # ts))", "moreover"], ["proof (state)\nthis:\n  linear t\n  linears (butlast ts)\n\ngoal (2 subgoals):\n 1. linears [] \\<Longrightarrow> linears (butlast [])\n 2. \\<And>a ts.\n       \\<lbrakk>linears ts \\<Longrightarrow> linears (butlast ts);\n        linears (a # ts)\\<rbrakk>\n       \\<Longrightarrow> linears (butlast (a # ts))", "have \" fdisjnt (frees t) (freess (butlast ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees t) (freess (butlast ts))", "proof (rule fdisjnt_subset_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. freess (butlast ts) |\\<subseteq>| ?N\n 2. fdisjnt (frees t) ?N", "show \"freess (butlast ts) |\\<subseteq>| freess ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess (butlast ts) |\\<subseteq>| freess ts", "by (rule freess_subset) (auto dest: in_set_butlastD)"], ["proof (state)\nthis:\n  freess (butlast ts) |\\<subseteq>| freess ts\n\ngoal (1 subgoal):\n 1. fdisjnt (frees t) (freess ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fdisjnt (frees t) (freess ts)", "show \"fdisjnt (frees t) (freess ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees t) (freess ts)", "using Cons"], ["proof (prove)\nusing this:\n  linears ts \\<Longrightarrow> linears (butlast ts)\n  linears (t # ts)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees t) (freess ts)", "by simp"], ["proof (state)\nthis:\n  fdisjnt (frees t) (freess ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fdisjnt (frees t) (freess (butlast ts))\n\ngoal (2 subgoals):\n 1. linears [] \\<Longrightarrow> linears (butlast [])\n 2. \\<And>a ts.\n       \\<lbrakk>linears ts \\<Longrightarrow> linears (butlast ts);\n        linears (a # ts)\\<rbrakk>\n       \\<Longrightarrow> linears (butlast (a # ts))", "ultimately"], ["proof (chain)\npicking this:\n  linear t\n  linears (butlast ts)\n  fdisjnt (frees t) (freess (butlast ts))", "show ?case"], ["proof (prove)\nusing this:\n  linear t\n  linears (butlast ts)\n  fdisjnt (frees t) (freess (butlast ts))\n\ngoal (1 subgoal):\n 1. linears (butlast (t # ts))", "by simp"], ["proof (state)\nthis:\n  linears (butlast (t # ts))\n\ngoal (1 subgoal):\n 1. linears [] \\<Longrightarrow> linears (butlast [])", "qed simp"], ["", "lemma linears_appI[intro]:\n  assumes \"linears xs\" \"linears ys\" \"fdisjnt (freess xs) (freess ys)\"\n  shows \"linears (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears (xs @ ys)", "using assms"], ["proof (prove)\nusing this:\n  linears xs\n  linears ys\n  fdisjnt (freess xs) (freess ys)\n\ngoal (1 subgoal):\n 1. linears (xs @ ys)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>linears []; linears ys;\n     fdisjnt (freess []) (freess ys)\\<rbrakk>\n    \\<Longrightarrow> linears ([] @ ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linears xs; linears ys;\n                 fdisjnt (freess xs) (freess ys)\\<rbrakk>\n                \\<Longrightarrow> linears (xs @ ys);\n        linears (a # xs); linears ys;\n        fdisjnt (freess (a # xs)) (freess ys)\\<rbrakk>\n       \\<Longrightarrow> linears ((a # xs) @ ys)", "case (Cons z zs)"], ["proof (state)\nthis:\n  \\<lbrakk>linears zs; linears ys; fdisjnt (freess zs) (freess ys)\\<rbrakk>\n  \\<Longrightarrow> linears (zs @ ys)\n  linears (z # zs)\n  linears ys\n  fdisjnt (freess (z # zs)) (freess ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>linears []; linears ys;\n     fdisjnt (freess []) (freess ys)\\<rbrakk>\n    \\<Longrightarrow> linears ([] @ ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linears xs; linears ys;\n                 fdisjnt (freess xs) (freess ys)\\<rbrakk>\n                \\<Longrightarrow> linears (xs @ ys);\n        linears (a # xs); linears ys;\n        fdisjnt (freess (a # xs)) (freess ys)\\<rbrakk>\n       \\<Longrightarrow> linears ((a # xs) @ ys)", "hence \"linears zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>linears zs; linears ys; fdisjnt (freess zs) (freess ys)\\<rbrakk>\n  \\<Longrightarrow> linears (zs @ ys)\n  linears (z # zs)\n  linears ys\n  fdisjnt (freess (z # zs)) (freess ys)\n\ngoal (1 subgoal):\n 1. linears zs", "by simp+"], ["proof (state)\nthis:\n  linears zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>linears []; linears ys;\n     fdisjnt (freess []) (freess ys)\\<rbrakk>\n    \\<Longrightarrow> linears ([] @ ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linears xs; linears ys;\n                 fdisjnt (freess xs) (freess ys)\\<rbrakk>\n                \\<Longrightarrow> linears (xs @ ys);\n        linears (a # xs); linears ys;\n        fdisjnt (freess (a # xs)) (freess ys)\\<rbrakk>\n       \\<Longrightarrow> linears ((a # xs) @ ys)", "have \"fdisjnt (frees z) (freess zs |\\<union>| freess ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees z) (freess zs |\\<union>| freess ys)", "proof (rule fdisjnt_union_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. fdisjnt (frees z) (freess zs)\n 2. fdisjnt (frees z) (freess ys)", "show \"fdisjnt (frees z) (freess zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees z) (freess zs)", "using \\<open>linears (z # zs)\\<close>"], ["proof (prove)\nusing this:\n  linears (z # zs)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees z) (freess zs)", "by simp"], ["proof (state)\nthis:\n  fdisjnt (frees z) (freess zs)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees z) (freess ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fdisjnt (frees z) (freess ys)", "have \"frees z |\\<subseteq>| freess (z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees z |\\<subseteq>| freess (z # zs)", "unfolding freess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees z |\\<subseteq>|\n    (ffUnion \\<circ> fset_of_list \\<circ> map frees) (z # zs)", "by simp"], ["proof (state)\nthis:\n  frees z |\\<subseteq>| freess (z # zs)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees z) (freess ys)", "thus \"fdisjnt (frees z) (freess ys)\""], ["proof (prove)\nusing this:\n  frees z |\\<subseteq>| freess (z # zs)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees z) (freess ys)", "by (rule fdisjnt_subset_left) fact"], ["proof (state)\nthis:\n  fdisjnt (frees z) (freess ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fdisjnt (frees z) (freess zs |\\<union>| freess ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>linears []; linears ys;\n     fdisjnt (freess []) (freess ys)\\<rbrakk>\n    \\<Longrightarrow> linears ([] @ ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linears xs; linears ys;\n                 fdisjnt (freess xs) (freess ys)\\<rbrakk>\n                \\<Longrightarrow> linears (xs @ ys);\n        linears (a # xs); linears ys;\n        fdisjnt (freess (a # xs)) (freess ys)\\<rbrakk>\n       \\<Longrightarrow> linears ((a # xs) @ ys)", "moreover"], ["proof (state)\nthis:\n  fdisjnt (frees z) (freess zs |\\<union>| freess ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>linears []; linears ys;\n     fdisjnt (freess []) (freess ys)\\<rbrakk>\n    \\<Longrightarrow> linears ([] @ ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linears xs; linears ys;\n                 fdisjnt (freess xs) (freess ys)\\<rbrakk>\n                \\<Longrightarrow> linears (xs @ ys);\n        linears (a # xs); linears ys;\n        fdisjnt (freess (a # xs)) (freess ys)\\<rbrakk>\n       \\<Longrightarrow> linears ((a # xs) @ ys)", "have \"linears (zs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears (zs @ ys)", "proof (rule Cons)"], ["proof (state)\ngoal (3 subgoals):\n 1. linears zs\n 2. linears ys\n 3. fdisjnt (freess zs) (freess ys)", "show \"fdisjnt (freess zs) (freess ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess zs) (freess ys)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>linears zs; linears ys; fdisjnt (freess zs) (freess ys)\\<rbrakk>\n  \\<Longrightarrow> linears (zs @ ys)\n  linears (z # zs)\n  linears ys\n  fdisjnt (freess (z # zs)) (freess ys)\n\ngoal (1 subgoal):\n 1. fdisjnt (freess zs) (freess ys)", "by (auto intro: freess_subset fdisjnt_subset_left)"], ["proof (state)\nthis:\n  fdisjnt (freess zs) (freess ys)\n\ngoal (2 subgoals):\n 1. linears zs\n 2. linears ys", "qed fact+"], ["proof (state)\nthis:\n  linears (zs @ ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>linears []; linears ys;\n     fdisjnt (freess []) (freess ys)\\<rbrakk>\n    \\<Longrightarrow> linears ([] @ ys)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>linears xs; linears ys;\n                 fdisjnt (freess xs) (freess ys)\\<rbrakk>\n                \\<Longrightarrow> linears (xs @ ys);\n        linears (a # xs); linears ys;\n        fdisjnt (freess (a # xs)) (freess ys)\\<rbrakk>\n       \\<Longrightarrow> linears ((a # xs) @ ys)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt (frees z) (freess zs |\\<union>| freess ys)\n  linears (zs @ ys)", "show ?case"], ["proof (prove)\nusing this:\n  fdisjnt (frees z) (freess zs |\\<union>| freess ys)\n  linears (zs @ ys)\n\ngoal (1 subgoal):\n 1. linears ((z # zs) @ ys)", "using Cons"], ["proof (prove)\nusing this:\n  fdisjnt (frees z) (freess zs |\\<union>| freess ys)\n  linears (zs @ ys)\n  \\<lbrakk>linears zs; linears ys; fdisjnt (freess zs) (freess ys)\\<rbrakk>\n  \\<Longrightarrow> linears (zs @ ys)\n  linears (z # zs)\n  linears ys\n  fdisjnt (freess (z # zs)) (freess ys)\n\ngoal (1 subgoal):\n 1. linears ((z # zs) @ ys)", "by auto"], ["proof (state)\nthis:\n  linears ((z # zs) @ ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>linears []; linears ys;\n     fdisjnt (freess []) (freess ys)\\<rbrakk>\n    \\<Longrightarrow> linears ([] @ ys)", "qed simp"], ["", "lemma linears_linear: \"linears ts \\<Longrightarrow> t \\<in> set ts \\<Longrightarrow> linear t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>linears ts; t \\<in> set ts\\<rbrakk> \\<Longrightarrow> linear t", "by (induct ts) auto"], ["", "lemma linears_singleI[intro]: \"linear t \\<Longrightarrow> linears [t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> linears [t]", "by (simp add: freess_def fdisjnt_alt_def)"], ["", "lemma linear_strip_comb: \"linear t \\<Longrightarrow> linear (fst (strip_comb t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> linear (fst (strip_comb t))", "by (induction t rule: strip_comb_induct) (auto simp: split_beta)"], ["", "lemma linears_strip_comb: \"linear t \\<Longrightarrow> linears (snd (strip_comb t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> linears (snd (strip_comb t))", "proof (induction t rule: strip_comb_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>linear x \\<Longrightarrow> linears (snd (strip_comb x));\n        linear (app x y)\\<rbrakk>\n       \\<Longrightarrow> linears (snd (strip_comb (app x y)))\n 2. \\<And>t.\n       \\<lbrakk>unapp t = None; linear t\\<rbrakk>\n       \\<Longrightarrow> linears (snd (strip_comb t))", "case (app t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  linear t\\<^sub>1 \\<Longrightarrow> linears (snd (strip_comb t\\<^sub>1))\n  linear (app t\\<^sub>1 t\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>linear x \\<Longrightarrow> linears (snd (strip_comb x));\n        linear (app x y)\\<rbrakk>\n       \\<Longrightarrow> linears (snd (strip_comb (app x y)))\n 2. \\<And>t.\n       \\<lbrakk>unapp t = None; linear t\\<rbrakk>\n       \\<Longrightarrow> linears (snd (strip_comb t))", "have \"linears (snd (strip_comb t\\<^sub>1) @ [t\\<^sub>2])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears (snd (strip_comb t\\<^sub>1) @ [t\\<^sub>2])", "proof (intro linears_appI linears_singleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. linears (snd (strip_comb t\\<^sub>1))\n 2. linear t\\<^sub>2\n 3. fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])", "have \"freess (snd (strip_comb t\\<^sub>1)) |\\<subseteq>| frees t\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess (snd (strip_comb t\\<^sub>1)) |\\<subseteq>| frees t\\<^sub>1", "by (subst frees_strip_comb) auto"], ["proof (state)\nthis:\n  freess (snd (strip_comb t\\<^sub>1)) |\\<subseteq>| frees t\\<^sub>1\n\ngoal (3 subgoals):\n 1. linears (snd (strip_comb t\\<^sub>1))\n 2. linear t\\<^sub>2\n 3. fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])", "moreover"], ["proof (state)\nthis:\n  freess (snd (strip_comb t\\<^sub>1)) |\\<subseteq>| frees t\\<^sub>1\n\ngoal (3 subgoals):\n 1. linears (snd (strip_comb t\\<^sub>1))\n 2. linear t\\<^sub>2\n 3. fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])", "have \"fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)", "using app"], ["proof (prove)\nusing this:\n  linear t\\<^sub>1 \\<Longrightarrow> linears (snd (strip_comb t\\<^sub>1))\n  linear (app t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\n\ngoal (3 subgoals):\n 1. linears (snd (strip_comb t\\<^sub>1))\n 2. linear t\\<^sub>2\n 3. fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])", "ultimately"], ["proof (chain)\npicking this:\n  freess (snd (strip_comb t\\<^sub>1)) |\\<subseteq>| frees t\\<^sub>1\n  fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)", "have \"fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (frees t\\<^sub>2)\""], ["proof (prove)\nusing this:\n  freess (snd (strip_comb t\\<^sub>1)) |\\<subseteq>| frees t\\<^sub>1\n  fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (frees t\\<^sub>2)", "by (rule fdisjnt_subset_left)"], ["proof (state)\nthis:\n  fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (frees t\\<^sub>2)\n\ngoal (3 subgoals):\n 1. linears (snd (strip_comb t\\<^sub>1))\n 2. linear t\\<^sub>2\n 3. fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])", "thus \"fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])\""], ["proof (prove)\nusing this:\n  fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (frees t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])", "by simp"], ["proof (state)\nthis:\n  fdisjnt (freess (snd (strip_comb t\\<^sub>1))) (freess [t\\<^sub>2])\n\ngoal (2 subgoals):\n 1. linears (snd (strip_comb t\\<^sub>1))\n 2. linear t\\<^sub>2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. linears (snd (strip_comb t\\<^sub>1))\n 2. linear t\\<^sub>2", "show \"linear t\\<^sub>2\" \"linears (snd (strip_comb t\\<^sub>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear t\\<^sub>2 &&& linears (snd (strip_comb t\\<^sub>1))", "using app"], ["proof (prove)\nusing this:\n  linear t\\<^sub>1 \\<Longrightarrow> linears (snd (strip_comb t\\<^sub>1))\n  linear (app t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. linear t\\<^sub>2 &&& linears (snd (strip_comb t\\<^sub>1))", "by auto"], ["proof (state)\nthis:\n  linear t\\<^sub>2\n  linears (snd (strip_comb t\\<^sub>1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  linears (snd (strip_comb t\\<^sub>1) @ [t\\<^sub>2])\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>linear x \\<Longrightarrow> linears (snd (strip_comb x));\n        linear (app x y)\\<rbrakk>\n       \\<Longrightarrow> linears (snd (strip_comb (app x y)))\n 2. \\<And>t.\n       \\<lbrakk>unapp t = None; linear t\\<rbrakk>\n       \\<Longrightarrow> linears (snd (strip_comb t))", "thus ?case"], ["proof (prove)\nusing this:\n  linears (snd (strip_comb t\\<^sub>1) @ [t\\<^sub>2])\n\ngoal (1 subgoal):\n 1. linears (snd (strip_comb (app t\\<^sub>1 t\\<^sub>2)))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  linears (snd (strip_comb (app t\\<^sub>1 t\\<^sub>2)))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>unapp t = None; linear t\\<rbrakk>\n       \\<Longrightarrow> linears (snd (strip_comb t))", "qed auto"], ["", "lemma linears_appendD:\n  assumes \"linears (xs @ ys)\"\n  shows \"linears xs\" \"linears ys\" \"fdisjnt (freess xs) (freess ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears xs &&& linears ys &&& fdisjnt (freess xs) (freess ys)", "using assms"], ["proof (prove)\nusing this:\n  linears (xs @ ys)\n\ngoal (1 subgoal):\n 1. linears xs &&& linears ys &&& fdisjnt (freess xs) (freess ys)", "proof (induction xs)"], ["proof (state)\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "case (Cons x xs)"], ["proof (state)\nthis:\n  linears (xs @ ys) \\<Longrightarrow> linears xs\n  linears (xs @ ys) \\<Longrightarrow> linears ys\n  linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys)\n\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "assume \"linears ((x # xs) @ ys)\""], ["proof (state)\nthis:\n  linears ((x # xs) @ ys)\n\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "hence \"linears (x # (xs @ ys))\""], ["proof (prove)\nusing this:\n  linears ((x # xs) @ ys)\n\ngoal (1 subgoal):\n 1. linears (x # xs @ ys)", "by simp"], ["proof (state)\nthis:\n  linears (x # xs @ ys)\n\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "hence \"linears (xs @ ys)\" \"linear x\" \"fdisjnt (frees x) (freess (xs @ ys))\""], ["proof (prove)\nusing this:\n  linears (x # xs @ ys)\n\ngoal (1 subgoal):\n 1. linears (xs @ ys) &&& linear x &&& fdisjnt (frees x) (freess (xs @ ys))", "by auto"], ["proof (state)\nthis:\n  linears (xs @ ys)\n  linear x\n  fdisjnt (frees x) (freess (xs @ ys))\n\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "hence \"linears xs\""], ["proof (prove)\nusing this:\n  linears (xs @ ys)\n  linear x\n  fdisjnt (frees x) (freess (xs @ ys))\n\ngoal (1 subgoal):\n 1. linears xs", "using Cons"], ["proof (prove)\nusing this:\n  linears (xs @ ys)\n  linear x\n  fdisjnt (frees x) (freess (xs @ ys))\n  linears (xs @ ys) \\<Longrightarrow> linears xs\n  linears (xs @ ys) \\<Longrightarrow> linears ys\n  linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys)\n\ngoal (1 subgoal):\n 1. linears xs", "by simp"], ["proof (state)\nthis:\n  linears xs\n\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "moreover"], ["proof (state)\nthis:\n  linears xs\n\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "have \"fdisjnt (frees x) (freess xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees x) (freess xs)", "proof (rule fdisjnt_subset_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. freess xs |\\<subseteq>| ?N\n 2. fdisjnt (frees x) ?N", "show \"freess xs |\\<subseteq>| freess (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess xs |\\<subseteq>| freess (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  freess xs |\\<subseteq>| freess (xs @ ys)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees x) (freess (xs @ ys))", "qed fact"], ["proof (state)\nthis:\n  fdisjnt (frees x) (freess xs)\n\ngoal (6 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears (a # xs)\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 6. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "ultimately"], ["proof (chain)\npicking this:\n  linears xs\n  fdisjnt (frees x) (freess xs)", "show \"linears (x # xs)\""], ["proof (prove)\nusing this:\n  linears xs\n  fdisjnt (frees x) (freess xs)\n\ngoal (1 subgoal):\n 1. linears (x # xs)", "using \\<open>linear x\\<close>"], ["proof (prove)\nusing this:\n  linears xs\n  fdisjnt (frees x) (freess xs)\n  linear x\n\ngoal (1 subgoal):\n 1. linears (x # xs)", "by auto"], ["proof (state)\nthis:\n  linears (x # xs)\n\ngoal (5 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "have \"fdisjnt (freess xs) (freess ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (freess xs) (freess ys)", "by (rule Cons) fact"], ["proof (state)\nthis:\n  fdisjnt (freess xs) (freess ys)\n\ngoal (5 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "moreover"], ["proof (state)\nthis:\n  fdisjnt (freess xs) (freess ys)\n\ngoal (5 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "have \"fdisjnt (frees x) (freess ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees x) (freess ys)", "proof (rule fdisjnt_subset_right)"], ["proof (state)\ngoal (2 subgoals):\n 1. freess ys |\\<subseteq>| ?N\n 2. fdisjnt (frees x) ?N", "show \"freess ys |\\<subseteq>| freess (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freess ys |\\<subseteq>| freess (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  freess ys |\\<subseteq>| freess (xs @ ys)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees x) (freess (xs @ ys))", "qed fact"], ["proof (state)\nthis:\n  fdisjnt (frees x) (freess ys)\n\ngoal (5 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys\n 5. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> fdisjnt (freess (a # xs)) (freess ys)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt (freess xs) (freess ys)\n  fdisjnt (frees x) (freess ys)", "show \"fdisjnt (freess (x # xs)) (freess ys)\""], ["proof (prove)\nusing this:\n  fdisjnt (freess xs) (freess ys)\n  fdisjnt (frees x) (freess ys)\n\ngoal (1 subgoal):\n 1. fdisjnt (freess (x # xs)) (freess ys)", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  freess xs |\\<inter>| freess ys = {||}\n  frees x |\\<inter>| freess ys = {||}\n\ngoal (1 subgoal):\n 1. freess (x # xs) |\\<inter>| freess ys = {||}", "by auto"], ["proof (state)\nthis:\n  fdisjnt (freess (x # xs)) (freess ys)\n\ngoal (4 subgoals):\n 1. linears ([] @ ys) \\<Longrightarrow> linears []\n 2. linears ([] @ ys) \\<Longrightarrow> linears ys\n 3. linears ([] @ ys) \\<Longrightarrow> fdisjnt (freess []) (freess ys)\n 4. \\<And>a xs.\n       \\<lbrakk>linears (xs @ ys) \\<Longrightarrow> linears xs;\n        linears (xs @ ys) \\<Longrightarrow> linears ys;\n        linears (xs @ ys) \\<Longrightarrow> fdisjnt (freess xs) (freess ys);\n        linears ((a # xs) @ ys)\\<rbrakk>\n       \\<Longrightarrow> linears ys", "qed (auto simp: fdisjnt_alt_def)"], ["", "lemma linear_list_comb:\n  assumes \"linear f\" \"linears xs\" \"fdisjnt (frees f) (freess xs)\" \"\\<not> is_free f\"\n  shows \"linear (list_comb f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (list_comb f xs)", "using assms"], ["proof (prove)\nusing this:\n  linear f\n  linears xs\n  fdisjnt (frees f) (freess xs)\n  \\<not> is_free f\n\ngoal (1 subgoal):\n 1. linear (list_comb f xs)", "proof (induction xs arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>linear f; linears []; fdisjnt (frees f) (freess []);\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f [])\n 2. \\<And>a xs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>linear f; linears xs;\n                    fdisjnt (frees f) (freess xs); \\<not> is_free f\\<rbrakk>\n                   \\<Longrightarrow> linear (list_comb f xs);\n        linear f; linears (a # xs); fdisjnt (frees f) (freess (a # xs));\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>linear ?f; linears xs; fdisjnt (frees ?f) (freess xs);\n   \\<not> is_free ?f\\<rbrakk>\n  \\<Longrightarrow> linear (list_comb ?f xs)\n  linear f\n  linears (x # xs)\n  fdisjnt (frees f) (freess (x # xs))\n  \\<not> is_free f\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>linear f; linears []; fdisjnt (frees f) (freess []);\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f [])\n 2. \\<And>a xs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>linear f; linears xs;\n                    fdisjnt (frees f) (freess xs); \\<not> is_free f\\<rbrakk>\n                   \\<Longrightarrow> linear (list_comb f xs);\n        linear f; linears (a # xs); fdisjnt (frees f) (freess (a # xs));\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f (a # xs))", "hence *: \"fdisjnt (frees f) (frees x |\\<union>| freess xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>linear ?f; linears xs; fdisjnt (frees ?f) (freess xs);\n   \\<not> is_free ?f\\<rbrakk>\n  \\<Longrightarrow> linear (list_comb ?f xs)\n  linear f\n  linears (x # xs)\n  fdisjnt (frees f) (freess (x # xs))\n  \\<not> is_free f\n\ngoal (1 subgoal):\n 1. fdisjnt (frees f) (frees x |\\<union>| freess xs)", "by simp"], ["proof (state)\nthis:\n  fdisjnt (frees f) (frees x |\\<union>| freess xs)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>linear f; linears []; fdisjnt (frees f) (freess []);\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f [])\n 2. \\<And>a xs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>linear f; linears xs;\n                    fdisjnt (frees f) (freess xs); \\<not> is_free f\\<rbrakk>\n                   \\<Longrightarrow> linear (list_comb f xs);\n        linear f; linears (a # xs); fdisjnt (frees f) (freess (a # xs));\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f (a # xs))", "have \"linear (list_comb (f $ x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (list_comb (f $ x) xs)", "proof (rule Cons)"], ["proof (state)\ngoal (4 subgoals):\n 1. linear (f $ x)\n 2. linears xs\n 3. fdisjnt (frees (f $ x)) (freess xs)\n 4. \\<not> is_free (f $ x)", "have \"linear x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear x", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>linear ?f; linears xs; fdisjnt (frees ?f) (freess xs);\n   \\<not> is_free ?f\\<rbrakk>\n  \\<Longrightarrow> linear (list_comb ?f xs)\n  linear f\n  linears (x # xs)\n  fdisjnt (frees f) (freess (x # xs))\n  \\<not> is_free f\n\ngoal (1 subgoal):\n 1. linear x", "by simp"], ["proof (state)\nthis:\n  linear x\n\ngoal (4 subgoals):\n 1. linear (f $ x)\n 2. linears xs\n 3. fdisjnt (frees (f $ x)) (freess xs)\n 4. \\<not> is_free (f $ x)", "moreover"], ["proof (state)\nthis:\n  linear x\n\ngoal (4 subgoals):\n 1. linear (f $ x)\n 2. linears xs\n 3. fdisjnt (frees (f $ x)) (freess xs)\n 4. \\<not> is_free (f $ x)", "have \"fdisjnt (frees f) (frees x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees f) (frees x)", "using *"], ["proof (prove)\nusing this:\n  fdisjnt (frees f) (frees x |\\<union>| freess xs)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees f) (frees x)", "by (auto intro: fdisjnt_subset_right)"], ["proof (state)\nthis:\n  fdisjnt (frees f) (frees x)\n\ngoal (4 subgoals):\n 1. linear (f $ x)\n 2. linears xs\n 3. fdisjnt (frees (f $ x)) (freess xs)\n 4. \\<not> is_free (f $ x)", "ultimately"], ["proof (chain)\npicking this:\n  linear x\n  fdisjnt (frees f) (frees x)", "show \"linear (f $ x)\""], ["proof (prove)\nusing this:\n  linear x\n  fdisjnt (frees f) (frees x)\n\ngoal (1 subgoal):\n 1. linear (f $ x)", "using assms Cons"], ["proof (prove)\nusing this:\n  linear x\n  fdisjnt (frees f) (frees x)\n  linear f\n  linears xs\n  fdisjnt (frees f) (freess xs)\n  \\<not> is_free f\n  \\<lbrakk>linear ?f; linears xs; fdisjnt (frees ?f) (freess xs);\n   \\<not> is_free ?f\\<rbrakk>\n  \\<Longrightarrow> linear (list_comb ?f xs)\n  linear f\n  linears (x # xs)\n  fdisjnt (frees f) (freess (x # xs))\n  \\<not> is_free f\n\ngoal (1 subgoal):\n 1. linear (f $ x)", "by simp"], ["proof (state)\nthis:\n  linear (f $ x)\n\ngoal (3 subgoals):\n 1. linears xs\n 2. fdisjnt (frees (f $ x)) (freess xs)\n 3. \\<not> is_free (f $ x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. linears xs\n 2. fdisjnt (frees (f $ x)) (freess xs)\n 3. \\<not> is_free (f $ x)", "show \"linears xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears xs", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>linear ?f; linears xs; fdisjnt (frees ?f) (freess xs);\n   \\<not> is_free ?f\\<rbrakk>\n  \\<Longrightarrow> linear (list_comb ?f xs)\n  linear f\n  linears (x # xs)\n  fdisjnt (frees f) (freess (x # xs))\n  \\<not> is_free f\n\ngoal (1 subgoal):\n 1. linears xs", "by simp"], ["proof (state)\nthis:\n  linears xs\n\ngoal (2 subgoals):\n 1. fdisjnt (frees (f $ x)) (freess xs)\n 2. \\<not> is_free (f $ x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. fdisjnt (frees (f $ x)) (freess xs)\n 2. \\<not> is_free (f $ x)", "have \"fdisjnt (frees f) (freess xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees f) (freess xs)", "using *"], ["proof (prove)\nusing this:\n  fdisjnt (frees f) (frees x |\\<union>| freess xs)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees f) (freess xs)", "by (auto intro: fdisjnt_subset_right)"], ["proof (state)\nthis:\n  fdisjnt (frees f) (freess xs)\n\ngoal (2 subgoals):\n 1. fdisjnt (frees (f $ x)) (freess xs)\n 2. \\<not> is_free (f $ x)", "moreover"], ["proof (state)\nthis:\n  fdisjnt (frees f) (freess xs)\n\ngoal (2 subgoals):\n 1. fdisjnt (frees (f $ x)) (freess xs)\n 2. \\<not> is_free (f $ x)", "have \"fdisjnt (frees x) (freess xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (frees x) (freess xs)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>linear ?f; linears xs; fdisjnt (frees ?f) (freess xs);\n   \\<not> is_free ?f\\<rbrakk>\n  \\<Longrightarrow> linear (list_comb ?f xs)\n  linear f\n  linears (x # xs)\n  fdisjnt (frees f) (freess (x # xs))\n  \\<not> is_free f\n\ngoal (1 subgoal):\n 1. fdisjnt (frees x) (freess xs)", "by simp"], ["proof (state)\nthis:\n  fdisjnt (frees x) (freess xs)\n\ngoal (2 subgoals):\n 1. fdisjnt (frees (f $ x)) (freess xs)\n 2. \\<not> is_free (f $ x)", "ultimately"], ["proof (chain)\npicking this:\n  fdisjnt (frees f) (freess xs)\n  fdisjnt (frees x) (freess xs)", "show \"fdisjnt (frees (f $ x)) (freess xs)\""], ["proof (prove)\nusing this:\n  fdisjnt (frees f) (freess xs)\n  fdisjnt (frees x) (freess xs)\n\ngoal (1 subgoal):\n 1. fdisjnt (frees (f $ x)) (freess xs)", "by (auto intro: fdisjnt_union_left)"], ["proof (state)\nthis:\n  fdisjnt (frees (f $ x)) (freess xs)\n\ngoal (1 subgoal):\n 1. \\<not> is_free (f $ x)", "qed auto"], ["proof (state)\nthis:\n  linear (list_comb (f $ x) xs)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>linear f; linears []; fdisjnt (frees f) (freess []);\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f [])\n 2. \\<And>a xs f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>linear f; linears xs;\n                    fdisjnt (frees f) (freess xs); \\<not> is_free f\\<rbrakk>\n                   \\<Longrightarrow> linear (list_comb f xs);\n        linear f; linears (a # xs); fdisjnt (frees f) (freess (a # xs));\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  linear (list_comb (f $ x) xs)\n\ngoal (1 subgoal):\n 1. linear (list_comb f (x # xs))", "by (simp add: app_term_def)"], ["proof (state)\nthis:\n  linear (list_comb f (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>linear f; linears []; fdisjnt (frees f) (freess []);\n        \\<not> is_free f\\<rbrakk>\n       \\<Longrightarrow> linear (list_comb f [])", "qed auto"], ["", "corollary linear_list_comb': \"linears xs \\<Longrightarrow> linear (name $$ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears xs \\<Longrightarrow> linear (name $$ xs)", "by (auto intro: linear_list_comb simp: fdisjnt_alt_def)"], ["", "lemma linear_strip_comb_cases[consumes 1]:\n  assumes \"linear pat\"\n  obtains (comb) s args where \"strip_comb pat = (Const s, args)\" \"pat = s $$ args\"\n        | (free) s where \"strip_comb pat = (Free s, [])\" \"pat = Free s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s args.\n                \\<lbrakk>strip_comb pat = (Const s, args);\n                 pat = s $$ args\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>s.\n        \\<lbrakk>strip_comb pat = (Free s, []); pat = Free s\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  linear pat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s args.\n                \\<lbrakk>strip_comb pat = (Const s, args);\n                 pat = s $$ args\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>s.\n        \\<lbrakk>strip_comb pat = (Free s, []); pat = Free s\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (induction pat rule: strip_comb_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<lbrakk>\\<And>s args.\n                            \\<lbrakk>strip_comb x = (Const s, args);\n                             x = s $$ args\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 \\<And>s.\n                    \\<lbrakk>strip_comb x = (Free s, []);\n                     x = Free s\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n                 linear x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>s args.\n           \\<lbrakk>strip_comb (app x y) = (Const s, args);\n            app x y = s $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>s.\n           \\<lbrakk>strip_comb (app x y) = (Free s, []);\n            app x y = Free s\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        linear (app x y)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t.\n       \\<lbrakk>unapp t = None;\n        \\<And>s args.\n           \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>s.\n           \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        linear t\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (app t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>s args.\n              \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n               t\\<^sub>1 = s $$ args\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   \\<And>s.\n      \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n       t\\<^sub>1 = Free s\\<rbrakk>\n      \\<Longrightarrow> thesis;\n   linear t\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Const ?s, ?args);\n   app t\\<^sub>1 t\\<^sub>2 = ?s $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Free ?s, []);\n   app t\\<^sub>1 t\\<^sub>2 = Free ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n  linear (app t\\<^sub>1 t\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<lbrakk>\\<And>s args.\n                            \\<lbrakk>strip_comb x = (Const s, args);\n                             x = s $$ args\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 \\<And>s.\n                    \\<lbrakk>strip_comb x = (Free s, []);\n                     x = Free s\\<rbrakk>\n                    \\<Longrightarrow> thesis;\n                 linear x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>s args.\n           \\<lbrakk>strip_comb (app x y) = (Const s, args);\n            app x y = s $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>s.\n           \\<lbrakk>strip_comb (app x y) = (Free s, []);\n            app x y = Free s\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        linear (app x y)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>t.\n       \\<lbrakk>unapp t = None;\n        \\<And>s args.\n           \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>s.\n           \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        linear t\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule \"app.IH\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n        t\\<^sub>1 = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. linear t\\<^sub>1", "show \"linear t\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear t\\<^sub>1", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>s args.\n              \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n               t\\<^sub>1 = s $$ args\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   \\<And>s.\n      \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n       t\\<^sub>1 = Free s\\<rbrakk>\n      \\<Longrightarrow> thesis;\n   linear t\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Const ?s, ?args);\n   app t\\<^sub>1 t\\<^sub>2 = ?s $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Free ?s, []);\n   app t\\<^sub>1 t\\<^sub>2 = Free ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n  linear (app t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. linear t\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  linear t\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n        t\\<^sub>1 = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n        t\\<^sub>1 = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n        t\\<^sub>1 = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"strip_comb t\\<^sub>1 = (Free s, [])\""], ["proof (state)\nthis:\n  strip_comb t\\<^sub>1 = (Free s, [])\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n        t\\<^sub>1 = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"t\\<^sub>1 = Free s\""], ["proof (prove)\nusing this:\n  strip_comb t\\<^sub>1 = (Free s, [])\n\ngoal (1 subgoal):\n 1. t\\<^sub>1 = Free s", "by (metis fst_conv snd_conv strip_comb_empty)"], ["proof (state)\nthis:\n  t\\<^sub>1 = Free s\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n        t\\<^sub>1 = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence False"], ["proof (prove)\nusing this:\n  t\\<^sub>1 = Free s\n\ngoal (1 subgoal):\n 1. False", "using app"], ["proof (prove)\nusing this:\n  t\\<^sub>1 = Free s\n  \\<lbrakk>\\<And>s args.\n              \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n               t\\<^sub>1 = s $$ args\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   \\<And>s.\n      \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n       t\\<^sub>1 = Free s\\<rbrakk>\n      \\<Longrightarrow> thesis;\n   linear t\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Const ?s, ?args);\n   app t\\<^sub>1 t\\<^sub>2 = ?s $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Free ?s, []);\n   app t\\<^sub>1 t\\<^sub>2 = Free ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n  linear (app t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n        t\\<^sub>1 = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix s args"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume \"strip_comb t\\<^sub>1 = (Const s, args)\""], ["proof (state)\nthis:\n  strip_comb t\\<^sub>1 = (Const s, args)\n\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n        t\\<^sub>1 = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "with app"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>s args.\n              \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n               t\\<^sub>1 = s $$ args\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   \\<And>s.\n      \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n       t\\<^sub>1 = Free s\\<rbrakk>\n      \\<Longrightarrow> thesis;\n   linear t\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Const ?s, ?args);\n   app t\\<^sub>1 t\\<^sub>2 = ?s $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Free ?s, []);\n   app t\\<^sub>1 t\\<^sub>2 = Free ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n  linear (app t\\<^sub>1 t\\<^sub>2)\n  strip_comb t\\<^sub>1 = (Const s, args)", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>s args.\n              \\<lbrakk>strip_comb t\\<^sub>1 = (Const s, args);\n               t\\<^sub>1 = s $$ args\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   \\<And>s.\n      \\<lbrakk>strip_comb t\\<^sub>1 = (Free s, []);\n       t\\<^sub>1 = Free s\\<rbrakk>\n      \\<Longrightarrow> thesis;\n   linear t\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Const ?s, ?args);\n   app t\\<^sub>1 t\\<^sub>2 = ?s $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb (app t\\<^sub>1 t\\<^sub>2) = (Free ?s, []);\n   app t\\<^sub>1 t\\<^sub>2 = Free ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n  linear (app t\\<^sub>1 t\\<^sub>2)\n  strip_comb t\\<^sub>1 = (Const s, args)\n\ngoal (1 subgoal):\n 1. thesis", "by (fastforce simp add: strip_comb_app)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>unapp t = None;\n        \\<And>s args.\n           \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>s.\n           \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        linear t\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>unapp t = None;\n        \\<And>s args.\n           \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>s.\n           \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        linear t\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (no_app t)"], ["proof (state)\nthis:\n  unapp t = None\n  \\<lbrakk>strip_comb t = (Const ?s, ?args); t = ?s $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb t = (Free ?s, []); t = Free ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n  linear t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>unapp t = None;\n        \\<And>s args.\n           \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>s.\n           \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        linear t\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?case"], ["proof (prove)\nusing this:\n  unapp t = None\n  \\<lbrakk>strip_comb t = (Const ?s, ?args); t = ?s $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>strip_comb t = (Free ?s, []); t = Free ?s\\<rbrakk>\n  \\<Longrightarrow> thesis\n  linear t\n\ngoal (1 subgoal):\n 1. thesis", "by (cases t) (auto simp: const_term_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wellformed_linearI: \"linear t \\<Longrightarrow> wellformed' n t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> wellformed' n t", "by (induct t) auto"], ["", "lemma pat_cases:\n  obtains (free) s where \"t = Free s\"\n        | (comb) name args where \"linears args\" \"t = name $$ args\"\n        | (nonlinear) \"\\<not> linear t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n     \\<And>args name.\n        \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<not> linear t \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Free x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Bound x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Free"], ["proof (state)\nthis:\n  t = Free x2_\n\ngoal (5 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Free x2\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x4.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Bound x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  t = Free x2_\n\ngoal (1 subgoal):\n 1. thesis", "using free"], ["proof (prove)\nusing this:\n  t = Free x2_\n  t = Free ?s \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Bound x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Bound x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Bound"], ["proof (state)\nthis:\n  t = Bound x4_\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x4.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Bound x4\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  t = Bound x4_\n\ngoal (1 subgoal):\n 1. thesis", "using nonlinear"], ["proof (prove)\nusing this:\n  t = Bound x4_\n  \\<not> linear t \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Abs"], ["proof (state)\nthis:\n  t = \\<Lambda> x3_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x3.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = \\<Lambda> x3\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  t = \\<Lambda> x3_\n\ngoal (1 subgoal):\n 1. thesis", "using nonlinear"], ["proof (prove)\nusing this:\n  t = \\<Lambda> x3_\n  \\<not> linear t \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Const name)"], ["proof (state)\nthis:\n  t = Const name\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"linears []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linears []", "by simp"], ["proof (state)\nthis:\n  linears []\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  linears []\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"t = name $$ []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = name $$ []", "unfolding Const"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const name = name $$ []", "by (simp add: const_term_def)"], ["proof (state)\nthis:\n  t = name $$ []\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = Const x1\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  linears []\n  t = name $$ []", "show thesis"], ["proof (prove)\nusing this:\n  linears []\n  t = name $$ []\n\ngoal (1 subgoal):\n 1. thesis", "by (rule comb)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (App u v)"], ["proof (state)\nthis:\n  t = u $ v\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n        \\<And>args name.\n           \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<not> linear t \\<Longrightarrow> thesis; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"linear t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. linear t \\<Longrightarrow> thesis\n 2. \\<not> linear t \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> linear t\n\ngoal (2 subgoals):\n 1. linear t \\<Longrightarrow> thesis\n 2. \\<not> linear t \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  \\<not> linear t\n\ngoal (1 subgoal):\n 1. thesis", "using nonlinear"], ["proof (prove)\nusing this:\n  \\<not> linear t\n  \\<not> linear t \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  linear t\n\ngoal (1 subgoal):\n 1. linear t \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  linear t\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases rule: linear_strip_comb_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "case free"], ["proof (state)\nthis:\n  strip_comb t = (Free s_, [])\n  t = Free s_\n\ngoal (2 subgoals):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>s.\n       \\<lbrakk>strip_comb t = (Free s, []); t = Free s\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  strip_comb t = (Free s_, [])\n  t = Free s_\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  strip_comb t = (Free s_, [])\n  t = Free s_\n  t = Free ?s \\<Longrightarrow> thesis\n  \\<lbrakk>linears ?args; t = ?name $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> linear t \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (comb name args)"], ["proof (state)\nthis:\n  strip_comb t = (Const name, args)\n  t = name $$ args\n\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  strip_comb t = (Const name, args)\n  t = name $$ args\n\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"linears (snd (strip_comb t))\""], ["proof (prove)\nusing this:\n  strip_comb t = (Const name, args)\n  t = name $$ args\n\ngoal (1 subgoal):\n 1. linears (snd (strip_comb t))", "using True"], ["proof (prove)\nusing this:\n  strip_comb t = (Const name, args)\n  t = name $$ args\n  linear t\n\ngoal (1 subgoal):\n 1. linears (snd (strip_comb t))", "by (blast intro: linears_strip_comb)"], ["proof (state)\nthis:\n  linears (snd (strip_comb t))\n\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  strip_comb t = (Const name, args)\n  t = name $$ args\n  linears (snd (strip_comb t))", "have \"linears args\""], ["proof (prove)\nusing this:\n  strip_comb t = (Const name, args)\n  t = name $$ args\n  linears (snd (strip_comb t))\n\ngoal (1 subgoal):\n 1. linears args", "by simp"], ["proof (state)\nthis:\n  linears args\n\ngoal (1 subgoal):\n 1. \\<And>s args.\n       \\<lbrakk>strip_comb t = (Const s, args); t = s $$ args\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  linears args\n\ngoal (1 subgoal):\n 1. thesis", "using that comb"], ["proof (prove)\nusing this:\n  linears args\n  t = Free ?s \\<Longrightarrow> thesis\n  \\<lbrakk>linears ?args; t = ?name $$ ?args\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> linear t \\<Longrightarrow> thesis\n  strip_comb t = (Const name, args)\n  t = name $$ args\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary linear_pat_cases[consumes 1]:\n  assumes \"linear t\"\n  obtains (free) s where \"t = Free s\"\n        | (comb) name args where \"linears args\" \"t = name $$ args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n     \\<And>args name.\n        \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  linear t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s. t = Free s \\<Longrightarrow> thesis;\n     \\<And>args name.\n        \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis pat_cases)"], ["", "lemma linear_pat_induct[consumes 1, case_names free comb]:\n  assumes \"linear t\"\n  assumes \"\\<And>s. P (Free s)\"\n  assumes \"\\<And>name args. linears args \\<Longrightarrow> (\\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg) \\<Longrightarrow> P (name $$ args)\"\n  shows \"P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "using wf_measure[of size] \\<open>linear t\\<close>"], ["proof (prove)\nusing this:\n  wf (measure size)\n  linear t\n\ngoal (1 subgoal):\n 1. P t", "proof (induction t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> measure size; linear y\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        linear x\\<rbrakk>\n       \\<Longrightarrow> P x", "case (less t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, t) \\<in> measure size; linear ?y\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  linear t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> measure size; linear y\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        linear x\\<rbrakk>\n       \\<Longrightarrow> P x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "using \\<open>linear t\\<close>"], ["proof (prove)\nusing this:\n  linear t\n\ngoal (1 subgoal):\n 1. P t", "proof (cases rule: linear_pat_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. t = Free s \\<Longrightarrow> P t\n 2. \\<And>name args.\n       \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n       \\<Longrightarrow> P t", "case (free name)"], ["proof (state)\nthis:\n  t = Free name\n\ngoal (2 subgoals):\n 1. \\<And>s. t = Free s \\<Longrightarrow> P t\n 2. \\<And>name args.\n       \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n       \\<Longrightarrow> P t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = Free name\n\ngoal (1 subgoal):\n 1. P t", "using assms"], ["proof (prove)\nusing this:\n  t = Free name\n  linear t\n  P (Free ?s)\n  \\<lbrakk>linears ?args;\n   \\<And>arg. arg \\<in> set ?args \\<Longrightarrow> P arg\\<rbrakk>\n  \\<Longrightarrow> P (?name $$ ?args)\n\ngoal (1 subgoal):\n 1. P t", "by simp"], ["proof (state)\nthis:\n  P t\n\ngoal (1 subgoal):\n 1. \\<And>name args.\n       \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n       \\<Longrightarrow> P t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>name args.\n       \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n       \\<Longrightarrow> P t", "case (comb name args)"], ["proof (state)\nthis:\n  linears args\n  t = name $$ args\n\ngoal (1 subgoal):\n 1. \\<And>name args.\n       \\<lbrakk>linears args; t = name $$ args\\<rbrakk>\n       \\<Longrightarrow> P t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "proof (cases \"args = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. args = [] \\<Longrightarrow> P t\n 2. args \\<noteq> [] \\<Longrightarrow> P t", "case True"], ["proof (state)\nthis:\n  args = []\n\ngoal (2 subgoals):\n 1. args = [] \\<Longrightarrow> P t\n 2. args \\<noteq> [] \\<Longrightarrow> P t", "thus ?thesis"], ["proof (prove)\nusing this:\n  args = []\n\ngoal (1 subgoal):\n 1. P t", "using assms comb"], ["proof (prove)\nusing this:\n  args = []\n  linear t\n  P (Free ?s)\n  \\<lbrakk>linears ?args;\n   \\<And>arg. arg \\<in> set ?args \\<Longrightarrow> P arg\\<rbrakk>\n  \\<Longrightarrow> P (?name $$ ?args)\n  linears args\n  t = name $$ args\n\ngoal (1 subgoal):\n 1. P t", "by fastforce"], ["proof (state)\nthis:\n  P t\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow> P t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow> P t", "case False"], ["proof (state)\nthis:\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow> P t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P t", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (name $$ args)", "proof (rule assms)"], ["proof (state)\ngoal (2 subgoals):\n 1. linears args\n 2. \\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg", "fix arg"], ["proof (state)\ngoal (2 subgoals):\n 1. linears args\n 2. \\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg", "assume \"arg \\<in> set args\""], ["proof (state)\nthis:\n  arg \\<in> set args\n\ngoal (2 subgoals):\n 1. linears args\n 2. \\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg", "then"], ["proof (chain)\npicking this:\n  arg \\<in> set args", "have \"(arg, t) \\<in> measure size\""], ["proof (prove)\nusing this:\n  arg \\<in> set args\n\ngoal (1 subgoal):\n 1. (arg, t) \\<in> measure size", "unfolding \\<open>t = _\\<close>"], ["proof (prove)\nusing this:\n  arg \\<in> set args\n\ngoal (1 subgoal):\n 1. (arg, name $$ args) \\<in> measure size", "by (induction args) auto"], ["proof (state)\nthis:\n  (arg, t) \\<in> measure size\n\ngoal (2 subgoals):\n 1. linears args\n 2. \\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg", "moreover"], ["proof (state)\nthis:\n  (arg, t) \\<in> measure size\n\ngoal (2 subgoals):\n 1. linears args\n 2. \\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg", "have \"linear arg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear arg", "using \\<open>arg \\<in> set args\\<close> \\<open>linears args\\<close>"], ["proof (prove)\nusing this:\n  arg \\<in> set args\n  linears args\n\ngoal (1 subgoal):\n 1. linear arg", "by (auto dest: linears_linear)"], ["proof (state)\nthis:\n  linear arg\n\ngoal (2 subgoals):\n 1. linears args\n 2. \\<And>arg. arg \\<in> set args \\<Longrightarrow> P arg", "ultimately"], ["proof (chain)\npicking this:\n  (arg, t) \\<in> measure size\n  linear arg", "show \"P arg\""], ["proof (prove)\nusing this:\n  (arg, t) \\<in> measure size\n  linear arg\n\ngoal (1 subgoal):\n 1. P arg", "using less"], ["proof (prove)\nusing this:\n  (arg, t) \\<in> measure size\n  linear arg\n  \\<lbrakk>(?y, t) \\<in> measure size; linear ?y\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  linear t\n\ngoal (1 subgoal):\n 1. P arg", "by auto"], ["proof (state)\nthis:\n  P arg\n\ngoal (1 subgoal):\n 1. linears args", "qed fact"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P t\n\ngoal:\nNo subgoals!", "qed"], ["", "context begin"], ["", "private"], ["", "lemma match_subst_correctness0:\n  assumes \"linear t\"\n  shows \"case match t u of\n          None \\<Rightarrow> (\\<forall>env. subst (convert_term t) env \\<noteq> u) |\n          Some env \\<Rightarrow> subst (convert_term t) env = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case match t u of\n    None \\<Rightarrow> \\<forall>env. subst (convert_term t) env \\<noteq> u\n    | Some env \\<Rightarrow> subst (convert_term t) env = u", "using assms"], ["proof (prove)\nusing this:\n  linear t\n\ngoal (1 subgoal):\n 1. case match t u of\n    None \\<Rightarrow> \\<forall>env. subst (convert_term t) env \\<noteq> u\n    | Some env \\<Rightarrow> subst (convert_term t) env = u", "proof (induction t arbitrary: u)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x u.\n       linear (Const x) \\<Longrightarrow>\n       case match (Const x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Const x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Const x)) env = u\n 2. \\<And>x u.\n       linear (Free x) \\<Longrightarrow>\n       case match (Free x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Free x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Free x)) env = u\n 3. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 4. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 5. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "case Free"], ["proof (state)\nthis:\n  linear (Free x_)\n\ngoal (5 subgoals):\n 1. \\<And>x u.\n       linear (Const x) \\<Longrightarrow>\n       case match (Const x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Const x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Const x)) env = u\n 2. \\<And>x u.\n       linear (Free x) \\<Longrightarrow>\n       case match (Free x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Free x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Free x)) env = u\n 3. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 4. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 5. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. case match (Free x_) u of\n    None \\<Rightarrow>\n      \\<forall>env. subst (convert_term (Free x_)) env \\<noteq> u\n    | Some env \\<Rightarrow> subst (convert_term (Free x_)) env = u", "unfolding match.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. case Some (fmap_of_list [(x_, u)]) of\n    None \\<Rightarrow>\n      \\<forall>env. subst (convert_term (Free x_)) env \\<noteq> u\n    | Some env \\<Rightarrow> subst (convert_term (Free x_)) env = u", "by (fold free_term_def) auto"], ["proof (state)\nthis:\n  case match (Free x_) u of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term (Free x_)) env \\<noteq> u\n  | Some env \\<Rightarrow> subst (convert_term (Free x_)) env = u\n\ngoal (4 subgoals):\n 1. \\<And>x u.\n       linear (Const x) \\<Longrightarrow>\n       case match (Const x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Const x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Const x)) env = u\n 2. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 3. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 4. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x u.\n       linear (Const x) \\<Longrightarrow>\n       case match (Const x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Const x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Const x)) env = u\n 2. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 3. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 4. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "case Const"], ["proof (state)\nthis:\n  linear (Const x_)\n\ngoal (4 subgoals):\n 1. \\<And>x u.\n       linear (Const x) \\<Longrightarrow>\n       case match (Const x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Const x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Const x)) env = u\n 2. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 3. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 4. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. case match (Const x_) u of\n    None \\<Rightarrow>\n      \\<forall>env. subst (convert_term (Const x_)) env \\<noteq> u\n    | Some env \\<Rightarrow> subst (convert_term (Const x_)) env = u", "unfolding match.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. case case unconst u of None \\<Rightarrow> None\n         | Some name' \\<Rightarrow>\n             if x_ = name' then Some fmempty else None of\n    None \\<Rightarrow>\n      \\<forall>env. subst (convert_term (Const x_)) env \\<noteq> u\n    | Some env \\<Rightarrow> subst (convert_term (Const x_)) env = u", "by (fold const_term_def) (auto split: option.splits)"], ["proof (state)\nthis:\n  case match (Const x_) u of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term (Const x_)) env \\<noteq> u\n  | Some env \\<Rightarrow> subst (convert_term (Const x_)) env = u\n\ngoal (3 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 2. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 3. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 2. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 3. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "case (App t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  linear t\\<^sub>1 \\<Longrightarrow>\n  case match t\\<^sub>1 ?u of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>1) env \\<noteq> ?u\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>1) env = ?u\n  linear t\\<^sub>2 \\<Longrightarrow>\n  case match t\\<^sub>2 ?u of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>2) env \\<noteq> ?u\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>2) env = ?u\n  linear (t\\<^sub>1 $ t\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 2. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 3. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "hence linear: \"linear t\\<^sub>1\" \"linear t\\<^sub>2\" \"fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\""], ["proof (prove)\nusing this:\n  linear t\\<^sub>1 \\<Longrightarrow>\n  case match t\\<^sub>1 ?u of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>1) env \\<noteq> ?u\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>1) env = ?u\n  linear t\\<^sub>2 \\<Longrightarrow>\n  case match t\\<^sub>2 ?u of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>2) env \\<noteq> ?u\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>2) env = ?u\n  linear (t\\<^sub>1 $ t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. linear t\\<^sub>1 &&&\n    linear t\\<^sub>2 &&& fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)", "by simp+"], ["proof (state)\nthis:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 2. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u\n 3. \\<And>t1 t2 u.\n       \\<lbrakk>\\<And>u.\n                   linear t1 \\<Longrightarrow>\n                   case match t1 u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t1) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t1) env = u;\n        \\<And>u.\n           linear t2 \\<Longrightarrow>\n           case match t2 u of\n           None \\<Rightarrow>\n             \\<forall>env. subst (convert_term t2) env \\<noteq> u\n           | Some env \\<Rightarrow> subst (convert_term t2) env = u;\n        linear (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> case match (t1 $ t2) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (t1 $ t2)) env \\<noteq> u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (t1 $ t2)) env = u", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "proof (cases \"unapp u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. unapp u = None \\<Longrightarrow>\n    case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n 2. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "case None"], ["proof (state)\nthis:\n  unapp u = None\n\ngoal (2 subgoals):\n 1. unapp u = None \\<Longrightarrow>\n    case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n 2. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "then"], ["proof (chain)\npicking this:\n  unapp u = None", "show ?thesis"], ["proof (prove)\nusing this:\n  unapp u = None\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. unapp u = None \\<Longrightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u", "apply (fold app_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. unapp u = None \\<Longrightarrow>\n    \\<forall>env.\n       subst (convert_term (app t\\<^sub>1 t\\<^sub>2)) env \\<noteq> u", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. unapp u = None \\<Longrightarrow>\n    \\<forall>env.\n       app (subst (convert_term t\\<^sub>1) env)\n        (subst (convert_term t\\<^sub>2) env) \\<noteq>\n       u", "using app_simps(3) is_app_def"], ["proof (prove)\nusing this:\n  is_app (app ?t ?u)\n  is_app ?t = (unapp ?t \\<noteq> None)\n\ngoal (1 subgoal):\n 1. unapp u = None \\<Longrightarrow>\n    \\<forall>env.\n       app (subst (convert_term t\\<^sub>1) env)\n        (subst (convert_term t\\<^sub>2) env) \\<noteq>\n       u", "by blast"], ["proof (state)\nthis:\n  case match (t\\<^sub>1 $ t\\<^sub>2) u of\n  None \\<Rightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n  | Some env \\<Rightarrow>\n      subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "case (Some u')"], ["proof (state)\nthis:\n  unapp u = Some u'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "then"], ["proof (chain)\npicking this:\n  unapp u = Some u'", "obtain u\\<^sub>1 u\\<^sub>2 where u: \"unapp u = Some (u\\<^sub>1, u\\<^sub>2)\""], ["proof (prove)\nusing this:\n  unapp u = Some u'\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1 u\\<^sub>2.\n        unapp u = Some (u\\<^sub>1, u\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases u') auto"], ["proof (state)\nthis:\n  unapp u = Some (u\\<^sub>1, u\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "hence \"u = app u\\<^sub>1 u\\<^sub>2\""], ["proof (prove)\nusing this:\n  unapp u = Some (u\\<^sub>1, u\\<^sub>2)\n\ngoal (1 subgoal):\n 1. u = app u\\<^sub>1 u\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  u = app u\\<^sub>1 u\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "note 1 = App(1)[OF \\<open>linear t\\<^sub>1\\<close>, of u\\<^sub>1]"], ["proof (state)\nthis:\n  case match t\\<^sub>1 u\\<^sub>1 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>1) env \\<noteq> u\\<^sub>1\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>1) env = u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "note 2 = App(2)[OF \\<open>linear t\\<^sub>2\\<close>, of u\\<^sub>2]"], ["proof (state)\nthis:\n  case match t\\<^sub>2 u\\<^sub>2 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>2) env \\<noteq> u\\<^sub>2\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>2) env = u\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       unapp u = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "proof (cases \"match t\\<^sub>1 u\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. match t\\<^sub>1 u\\<^sub>1 = None \\<Longrightarrow>\n    case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n 2. \\<And>a.\n       match t\\<^sub>1 u\\<^sub>1 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "case None"], ["proof (state)\nthis:\n  match t\\<^sub>1 u\\<^sub>1 = None\n\ngoal (2 subgoals):\n 1. match t\\<^sub>1 u\\<^sub>1 = None \\<Longrightarrow>\n    case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n 2. \\<And>a.\n       match t\\<^sub>1 u\\<^sub>1 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "then"], ["proof (chain)\npicking this:\n  match t\\<^sub>1 u\\<^sub>1 = None", "show ?thesis"], ["proof (prove)\nusing this:\n  match t\\<^sub>1 u\\<^sub>1 = None\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "using u"], ["proof (prove)\nusing this:\n  match t\\<^sub>1 u\\<^sub>1 = None\n  unapp u = Some (u\\<^sub>1, u\\<^sub>2)\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match t\\<^sub>1 u\\<^sub>1 = None;\n     unapp u = Some (u\\<^sub>1, u\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>env.\n                         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2))\n                          env \\<noteq>\n                         u", "apply (fold app_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match t\\<^sub>1 u\\<^sub>1 = None;\n     unapp u = Some (u\\<^sub>1, u\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>env.\n                         subst (convert_term (app t\\<^sub>1 t\\<^sub>2))\n                          env \\<noteq>\n                         u", "using 1"], ["proof (prove)\nusing this:\n  case match t\\<^sub>1 u\\<^sub>1 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>1) env \\<noteq> u\\<^sub>1\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>1) env = u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match t\\<^sub>1 u\\<^sub>1 = None;\n     unapp u = Some (u\\<^sub>1, u\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>env.\n                         subst (convert_term (app t\\<^sub>1 t\\<^sub>2))\n                          env \\<noteq>\n                         u", "by auto"], ["proof (state)\nthis:\n  case match (t\\<^sub>1 $ t\\<^sub>2) u of\n  None \\<Rightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n  | Some env \\<Rightarrow>\n      subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>1 u\\<^sub>1 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>1 u\\<^sub>1 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "case (Some env\\<^sub>1)"], ["proof (state)\nthis:\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>1 u\\<^sub>1 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "with 1"], ["proof (chain)\npicking this:\n  case match t\\<^sub>1 u\\<^sub>1 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>1) env \\<noteq> u\\<^sub>1\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>1) env = u\\<^sub>1\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1", "have s1: \"subst (convert_term t\\<^sub>1) env\\<^sub>1 = u\\<^sub>1\""], ["proof (prove)\nusing this:\n  case match t\\<^sub>1 u\\<^sub>1 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>1) env \\<noteq> u\\<^sub>1\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>1) env = u\\<^sub>1\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n\ngoal (1 subgoal):\n 1. subst (convert_term t\\<^sub>1) env\\<^sub>1 = u\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  subst (convert_term t\\<^sub>1) env\\<^sub>1 = u\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>1 u\\<^sub>1 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "proof (cases \"match t\\<^sub>2 u\\<^sub>2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. match t\\<^sub>2 u\\<^sub>2 = None \\<Longrightarrow>\n    case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n 2. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "case None"], ["proof (state)\nthis:\n  match t\\<^sub>2 u\\<^sub>2 = None\n\ngoal (2 subgoals):\n 1. match t\\<^sub>2 u\\<^sub>2 = None \\<Longrightarrow>\n    case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n 2. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "then"], ["proof (chain)\npicking this:\n  match t\\<^sub>2 u\\<^sub>2 = None", "show ?thesis"], ["proof (prove)\nusing this:\n  match t\\<^sub>2 u\\<^sub>2 = None\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "using u"], ["proof (prove)\nusing this:\n  match t\\<^sub>2 u\\<^sub>2 = None\n  unapp u = Some (u\\<^sub>1, u\\<^sub>2)\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match t\\<^sub>2 u\\<^sub>2 = None;\n     unapp u = Some (u\\<^sub>1, u\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>env.\n                         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2))\n                          env \\<noteq>\n                         u", "apply (fold app_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match t\\<^sub>2 u\\<^sub>2 = None;\n     unapp u = Some (u\\<^sub>1, u\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>env.\n                         subst (convert_term (app t\\<^sub>1 t\\<^sub>2))\n                          env \\<noteq>\n                         u", "using 2"], ["proof (prove)\nusing this:\n  case match t\\<^sub>2 u\\<^sub>2 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>2) env \\<noteq> u\\<^sub>2\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>2) env = u\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>match t\\<^sub>2 u\\<^sub>2 = None;\n     unapp u = Some (u\\<^sub>1, u\\<^sub>2)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>env.\n                         subst (convert_term (app t\\<^sub>1 t\\<^sub>2))\n                          env \\<noteq>\n                         u", "by auto"], ["proof (state)\nthis:\n  case match (t\\<^sub>1 $ t\\<^sub>2) u of\n  None \\<Rightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n  | Some env \\<Rightarrow>\n      subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "case (Some env\\<^sub>2)"], ["proof (state)\nthis:\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "with 2"], ["proof (chain)\npicking this:\n  case match t\\<^sub>2 u\\<^sub>2 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>2) env \\<noteq> u\\<^sub>2\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>2) env = u\\<^sub>2\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2", "have s2: \"subst (convert_term t\\<^sub>2) env\\<^sub>2 = u\\<^sub>2\""], ["proof (prove)\nusing this:\n  case match t\\<^sub>2 u\\<^sub>2 of\n  None \\<Rightarrow>\n    \\<forall>env. subst (convert_term t\\<^sub>2) env \\<noteq> u\\<^sub>2\n  | Some env \\<Rightarrow> subst (convert_term t\\<^sub>2) env = u\\<^sub>2\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst (convert_term t\\<^sub>2) env\\<^sub>2 = u\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  subst (convert_term t\\<^sub>2) env\\<^sub>2 = u\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "note match = \\<open>match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\\<close> \\<open>match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\\<close>"], ["proof (state)\nthis:\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "let ?env = \"env\\<^sub>1 ++\\<^sub>f env\\<^sub>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "from match"], ["proof (chain)\npicking this:\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2", "have \"frees t\\<^sub>1 = fmdom env\\<^sub>1\" \"frees t\\<^sub>2 = fmdom env\\<^sub>2\""], ["proof (prove)\nusing this:\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. frees t\\<^sub>1 = fmdom env\\<^sub>1 &&&\n    frees t\\<^sub>2 = fmdom env\\<^sub>2", "by (auto simp: match_dom)"], ["proof (state)\nthis:\n  frees t\\<^sub>1 = fmdom env\\<^sub>1\n  frees t\\<^sub>2 = fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "with linear"], ["proof (chain)\npicking this:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\n  frees t\\<^sub>1 = fmdom env\\<^sub>1\n  frees t\\<^sub>2 = fmdom env\\<^sub>2", "have \"env\\<^sub>1 = fmrestrict_fset (frees t\\<^sub>1) ?env\" \"env\\<^sub>2 = fmrestrict_fset (frees t\\<^sub>2) ?env\""], ["proof (prove)\nusing this:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\n  frees t\\<^sub>1 = fmdom env\\<^sub>1\n  frees t\\<^sub>2 = fmdom env\\<^sub>2\n\ngoal (1 subgoal):\n 1. env\\<^sub>1 =\n    fmrestrict_fset (frees t\\<^sub>1)\n     (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) &&&\n    env\\<^sub>2 =\n    fmrestrict_fset (frees t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>linear t\\<^sub>1; linear t\\<^sub>2;\n     fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2);\n     frees t\\<^sub>1 = fmdom env\\<^sub>1;\n     frees t\\<^sub>2 = fmdom env\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> env\\<^sub>1 =\n                      env\\<^sub>1 ++\\<^sub>f\n                      fmrestrict_fset (fmdom env\\<^sub>1) env\\<^sub>2\n 2. \\<lbrakk>linear t\\<^sub>1; linear t\\<^sub>2;\n     fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2);\n     frees t\\<^sub>1 = fmdom env\\<^sub>1;\n     frees t\\<^sub>2 = fmdom env\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> env\\<^sub>2 =\n                      fmrestrict_fset (fmdom env\\<^sub>2)\n                       env\\<^sub>1 ++\\<^sub>f\n                      env\\<^sub>2", "apply (auto simp: fmfilter_alt_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>linear t\\<^sub>1; linear t\\<^sub>2;\n     fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2);\n     frees t\\<^sub>1 = fmdom env\\<^sub>1;\n     frees t\\<^sub>2 = fmdom env\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> env\\<^sub>1 =\n                      env\\<^sub>1 ++\\<^sub>f\n                      fmfilter (\\<lambda>a. a |\\<in>| fmdom env\\<^sub>1)\n                       env\\<^sub>2\n 2. \\<lbrakk>linear t\\<^sub>1; linear t\\<^sub>2;\n     fdisjnt (fmdom env\\<^sub>1) (fmdom env\\<^sub>2);\n     frees t\\<^sub>1 = fmdom env\\<^sub>1;\n     frees t\\<^sub>2 = fmdom env\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> env\\<^sub>2 =\n                      fmfilter (\\<lambda>a. a |\\<in>| fmdom env\\<^sub>2)\n                       env\\<^sub>1 ++\\<^sub>f\n                      env\\<^sub>2", "apply (subst fmfilter_false; auto simp: fdisjnt_alt_def intro: fmdomI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  env\\<^sub>1 =\n  fmrestrict_fset (frees t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n  env\\<^sub>2 =\n  fmrestrict_fset (frees t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "with s1 s2"], ["proof (chain)\npicking this:\n  subst (convert_term t\\<^sub>1) env\\<^sub>1 = u\\<^sub>1\n  subst (convert_term t\\<^sub>2) env\\<^sub>2 = u\\<^sub>2\n  env\\<^sub>1 =\n  fmrestrict_fset (frees t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n  env\\<^sub>2 =\n  fmrestrict_fset (frees t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)", "have \"subst (convert_term t\\<^sub>1) ?env = u\\<^sub>1\" \"subst (convert_term t\\<^sub>2) ?env = u\\<^sub>2\""], ["proof (prove)\nusing this:\n  subst (convert_term t\\<^sub>1) env\\<^sub>1 = u\\<^sub>1\n  subst (convert_term t\\<^sub>2) env\\<^sub>2 = u\\<^sub>2\n  env\\<^sub>1 =\n  fmrestrict_fset (frees t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n  env\\<^sub>2 =\n  fmrestrict_fset (frees t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst (convert_term t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    u\\<^sub>1 &&&\n    subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    u\\<^sub>2", "using linear"], ["proof (prove)\nusing this:\n  subst (convert_term t\\<^sub>1) env\\<^sub>1 = u\\<^sub>1\n  subst (convert_term t\\<^sub>2) env\\<^sub>2 = u\\<^sub>2\n  env\\<^sub>1 =\n  fmrestrict_fset (frees t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n  env\\<^sub>2 =\n  fmrestrict_fset (frees t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2)\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  fdisjnt (frees t\\<^sub>1) (frees t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. subst (convert_term t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    u\\<^sub>1 &&&\n    subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n    u\\<^sub>2", "by (metis subst_restrict' convert_term_frees linear_implies_no_abs)+"], ["proof (state)\nthis:\n  subst (convert_term t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>1\n  subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match t\\<^sub>2 u\\<^sub>2 = Some a \\<Longrightarrow>\n       case match (t\\<^sub>1 $ t\\<^sub>2) u of\n       None \\<Rightarrow>\n         \\<forall>env.\n            subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n       | Some env \\<Rightarrow>\n           subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "then"], ["proof (chain)\npicking this:\n  subst (convert_term t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>1\n  subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  subst (convert_term t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>1\n  subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>2\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "using match"], ["proof (prove)\nusing this:\n  subst (convert_term t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>1\n  subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>2\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) u of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u", "unfolding \\<open>u = _\\<close>"], ["proof (prove)\nusing this:\n  subst (convert_term t\\<^sub>1) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>1\n  subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n  u\\<^sub>2\n  match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1\n  match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. case match (t\\<^sub>1 $ t\\<^sub>2) (app u\\<^sub>1 u\\<^sub>2) of\n    None \\<Rightarrow>\n      \\<forall>env.\n         subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq>\n         app u\\<^sub>1 u\\<^sub>2\n    | Some env \\<Rightarrow>\n        subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env =\n        app u\\<^sub>1 u\\<^sub>2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subst (convert_term t\\<^sub>1)\n              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n             u\\<^sub>1;\n     subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n     u\\<^sub>2;\n     match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n     match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> subst (convert_term (t\\<^sub>1 $ t\\<^sub>2))\n                       (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                      app u\\<^sub>1 u\\<^sub>2", "apply (fold app_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subst (convert_term t\\<^sub>1)\n              (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n             u\\<^sub>1;\n     subst (convert_term t\\<^sub>2) (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n     u\\<^sub>2;\n     match t\\<^sub>1 u\\<^sub>1 = Some env\\<^sub>1;\n     match t\\<^sub>2 u\\<^sub>2 = Some env\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> subst (convert_term (app t\\<^sub>1 t\\<^sub>2))\n                       (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n                      app u\\<^sub>1 u\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  case match (t\\<^sub>1 $ t\\<^sub>2) u of\n  None \\<Rightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n  | Some env \\<Rightarrow>\n      subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case match (t\\<^sub>1 $ t\\<^sub>2) u of\n  None \\<Rightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n  | Some env \\<Rightarrow>\n      subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case match (t\\<^sub>1 $ t\\<^sub>2) u of\n  None \\<Rightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n  | Some env \\<Rightarrow>\n      subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case match (t\\<^sub>1 $ t\\<^sub>2) u of\n  None \\<Rightarrow>\n    \\<forall>env.\n       subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env \\<noteq> u\n  | Some env \\<Rightarrow>\n      subst (convert_term (t\\<^sub>1 $ t\\<^sub>2)) env = u\n\ngoal (2 subgoals):\n 1. \\<And>t u.\n       \\<lbrakk>\\<And>u.\n                   linear t \\<Longrightarrow>\n                   case match t u of\n                   None \\<Rightarrow>\n                     \\<forall>env. subst (convert_term t) env \\<noteq> u\n                   | Some env \\<Rightarrow> subst (convert_term t) env = u;\n        linear (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> case match (\\<Lambda> t) u of\n                         None \\<Rightarrow>\n                           \\<forall>env.\n                              subst (convert_term (\\<Lambda> t))\n                               env \\<noteq>\n                              u\n                         | Some env \\<Rightarrow>\n                             subst (convert_term (\\<Lambda> t)) env = u\n 2. \\<And>x u.\n       linear (Bound x) \\<Longrightarrow>\n       case match (Bound x) u of\n       None \\<Rightarrow>\n         \\<forall>env. subst (convert_term (Bound x)) env \\<noteq> u\n       | Some env \\<Rightarrow> subst (convert_term (Bound x)) env = u", "qed auto"], ["", "lemma match_subst_some[simp]:\n  \"match t u = Some env \\<Longrightarrow> linear t \\<Longrightarrow> subst (convert_term t) env = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match t u = Some env; linear t\\<rbrakk>\n    \\<Longrightarrow> subst (convert_term t) env = u", "by (metis (mono_tags) match_subst_correctness0 option.simps(5))"], ["", "lemma match_subst_none:\n  \"match t u = None \\<Longrightarrow> linear t \\<Longrightarrow> subst (convert_term t) env = u \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match t u = None; linear t;\n     subst (convert_term t) env = u\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (mono_tags, lifting) match_subst_correctness0 option.simps(4))"], ["", "end"], ["", "(* FIXME inverse direction? *)"], ["", "lemma match_matches: \"match t u = Some env \\<Longrightarrow> linear t \\<Longrightarrow> t \\<lesssim> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>match t u = Some env; linear t\\<rbrakk>\n    \\<Longrightarrow> t \\<lesssim> u", "by (metis match_subst_some linear_implies_no_abs convert_term_id matchesI)"], ["", "lemma overlapping_var1I: \"overlapping (Free name) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. overlapping (Free name) t", "proof (intro overlappingI matchesI)"], ["proof (state)\ngoal (2 subgoals):\n 1. subst (Free name) ?env2 = ?u\n 2. subst t ?env1 = ?u", "show \"subst (Free name) (fmap_of_list [(name, t)]) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (Free name) (fmap_of_list [(name, t)]) = t", "by simp"], ["proof (state)\nthis:\n  subst (Free name) (fmap_of_list [(name, t)]) = t\n\ngoal (1 subgoal):\n 1. subst t ?env1 = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst t ?env1 = t", "show \"subst t fmempty = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t fmempty = t", "by simp"], ["proof (state)\nthis:\n  subst t fmempty = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma overlapping_var2I: \"overlapping t (Free name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. overlapping t (Free name)", "proof (intro overlappingI matchesI)"], ["proof (state)\ngoal (2 subgoals):\n 1. subst t ?env2 = ?u\n 2. subst (Free name) ?env1 = ?u", "show \"subst (Free name) (fmap_of_list [(name, t)]) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (Free name) (fmap_of_list [(name, t)]) = t", "by simp"], ["proof (state)\nthis:\n  subst (Free name) (fmap_of_list [(name, t)]) = t\n\ngoal (1 subgoal):\n 1. subst t ?env2 = t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. subst t ?env2 = t", "show \"subst t fmempty = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t fmempty = t", "by simp"], ["proof (state)\nthis:\n  subst t fmempty = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_overlapping_appI1: \"non_overlapping t\\<^sub>1 u\\<^sub>1 \\<Longrightarrow> non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (u\\<^sub>1 $ u\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_overlapping t\\<^sub>1 u\\<^sub>1 \\<Longrightarrow>\n    non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (u\\<^sub>1 $ u\\<^sub>2)", "unfolding overlapping_def matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>u.\n       (\\<exists>env. subst t\\<^sub>1 env = u) \\<and>\n       (\\<exists>env. subst u\\<^sub>1 env = u) \\<Longrightarrow>\n    \\<nexists>u.\n       (\\<exists>env. subst (t\\<^sub>1 $ t\\<^sub>2) env = u) \\<and>\n       (\\<exists>env. subst (u\\<^sub>1 $ u\\<^sub>2) env = u)", "by auto"], ["", "lemma non_overlapping_appI2: \"non_overlapping t\\<^sub>2 u\\<^sub>2 \\<Longrightarrow> non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (u\\<^sub>1 $ u\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_overlapping t\\<^sub>2 u\\<^sub>2 \\<Longrightarrow>\n    non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (u\\<^sub>1 $ u\\<^sub>2)", "unfolding overlapping_def matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>u.\n       (\\<exists>env. subst t\\<^sub>2 env = u) \\<and>\n       (\\<exists>env. subst u\\<^sub>2 env = u) \\<Longrightarrow>\n    \\<nexists>u.\n       (\\<exists>env. subst (t\\<^sub>1 $ t\\<^sub>2) env = u) \\<and>\n       (\\<exists>env. subst (u\\<^sub>1 $ u\\<^sub>2) env = u)", "by auto"], ["", "lemma non_overlapping_app_constI: \"non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (Const name)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_overlapping (t\\<^sub>1 $ t\\<^sub>2) (Const name)", "unfolding overlapping_def matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>u.\n       (\\<exists>env. subst (t\\<^sub>1 $ t\\<^sub>2) env = u) \\<and>\n       (\\<exists>env. subst (Const name) env = u)", "by simp"], ["", "lemma non_overlapping_const_appI: \"non_overlapping (Const name) (t\\<^sub>1 $ t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_overlapping (Const name) (t\\<^sub>1 $ t\\<^sub>2)", "unfolding overlapping_def matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>u.\n       (\\<exists>env. subst (Const name) env = u) \\<and>\n       (\\<exists>env. subst (t\\<^sub>1 $ t\\<^sub>2) env = u)", "by simp"], ["", "lemma non_overlapping_const_constI: \"x \\<noteq> y \\<Longrightarrow> non_overlapping (Const x) (Const y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> non_overlapping (Const x) (Const y)", "unfolding overlapping_def matches_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    \\<nexists>u.\n       (\\<exists>env. subst (Const x) env = u) \\<and>\n       (\\<exists>env. subst (Const y) env = u)", "by simp"], ["", "lemma match_overlapping:\n  assumes \"linear t\\<^sub>1\" \"linear t\\<^sub>2\"\n  assumes \"match t\\<^sub>1 u = Some env\\<^sub>1\" \"match t\\<^sub>2 u = Some env\\<^sub>2\"\n  shows \"overlapping t\\<^sub>1 t\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. overlapping t\\<^sub>1 t\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. overlapping t\\<^sub>1 t\\<^sub>2", "define env\\<^sub>1' where \"env\\<^sub>1' = (fmmap convert_term env\\<^sub>1 :: (name, term) fmap)\""], ["proof (state)\nthis:\n  env\\<^sub>1' = fmmap convert_term env\\<^sub>1\n\ngoal (1 subgoal):\n 1. overlapping t\\<^sub>1 t\\<^sub>2", "define env\\<^sub>2' where \"env\\<^sub>2' = (fmmap convert_term env\\<^sub>2 :: (name, term) fmap)\""], ["proof (state)\nthis:\n  env\\<^sub>2' = fmmap convert_term env\\<^sub>2\n\ngoal (1 subgoal):\n 1. overlapping t\\<^sub>1 t\\<^sub>2", "from assms"], ["proof (chain)\npicking this:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  match t\\<^sub>1 u = Some env\\<^sub>1\n  match t\\<^sub>2 u = Some env\\<^sub>2", "have \"match t\\<^sub>1 (convert_term u :: term) = Some env\\<^sub>1'\" \"match t\\<^sub>2 (convert_term u :: term) = Some env\\<^sub>2'\""], ["proof (prove)\nusing this:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  match t\\<^sub>1 u = Some env\\<^sub>1\n  match t\\<^sub>2 u = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. match t\\<^sub>1 (convert_term u) = Some env\\<^sub>1' &&&\n    match t\\<^sub>2 (convert_term u) = Some env\\<^sub>2'", "unfolding env\\<^sub>1'_def env\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  match t\\<^sub>1 u = Some env\\<^sub>1\n  match t\\<^sub>2 u = Some env\\<^sub>2\n\ngoal (1 subgoal):\n 1. match t\\<^sub>1 (convert_term u) =\n    Some (fmmap convert_term env\\<^sub>1) &&&\n    match t\\<^sub>2 (convert_term u) = Some (fmmap convert_term env\\<^sub>2)", "by (metis convert_term_match)+"], ["proof (state)\nthis:\n  match t\\<^sub>1 (convert_term u) = Some env\\<^sub>1'\n  match t\\<^sub>2 (convert_term u) = Some env\\<^sub>2'\n\ngoal (1 subgoal):\n 1. overlapping t\\<^sub>1 t\\<^sub>2", "with assms"], ["proof (chain)\npicking this:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  match t\\<^sub>1 u = Some env\\<^sub>1\n  match t\\<^sub>2 u = Some env\\<^sub>2\n  match t\\<^sub>1 (convert_term u) = Some env\\<^sub>1'\n  match t\\<^sub>2 (convert_term u) = Some env\\<^sub>2'", "show ?thesis"], ["proof (prove)\nusing this:\n  linear t\\<^sub>1\n  linear t\\<^sub>2\n  match t\\<^sub>1 u = Some env\\<^sub>1\n  match t\\<^sub>2 u = Some env\\<^sub>2\n  match t\\<^sub>1 (convert_term u) = Some env\\<^sub>1'\n  match t\\<^sub>2 (convert_term u) = Some env\\<^sub>2'\n\ngoal (1 subgoal):\n 1. overlapping t\\<^sub>1 t\\<^sub>2", "by (metis overlappingI match_matches)"], ["proof (state)\nthis:\n  overlapping t\\<^sub>1 t\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}