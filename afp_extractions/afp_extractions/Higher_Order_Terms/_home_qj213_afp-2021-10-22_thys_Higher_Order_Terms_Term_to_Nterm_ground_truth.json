{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Term_to_Nterm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemma alpha_equiv_refl[intro?]:\n  assumes \"fmpred (=) \\<Gamma>\"\n  shows \"alpha_equiv \\<Gamma> t t\"", "lemmas term_to_nterm_induct = term_to_nterm.induct[case_names const free bound abs app]", "lemma term_to_nterm:\n  assumes \"no_abs t\"\n  shows \"fst (run_state (term_to_nterm \\<Gamma> t) x) = convert_term t\"", "lemma term_to_nterm_mono: \"mono_state (term_to_nterm \\<Gamma> x)\"", "lemma term_to_nterm_vars0:\n  assumes \"wellformed' (length \\<Gamma>) t\"\n  shows \"frees (fst (run_state (term_to_nterm \\<Gamma> t) s)) |\\<subseteq>| frees t |\\<union>| fset_of_list \\<Gamma>\"", "lemma term_to_nterm_consts: \"pred_state (\\<lambda>t'. consts t' = consts t) (term_to_nterm \\<Gamma> t)\"", "lemma nterm_to_term:\n  assumes \"no_abs t\" \"fdisjnt (fset_of_list \\<Gamma>) (frees t)\"\n  shows \"nterm_to_term \\<Gamma> t = convert_term t\"", "lemma nterm_to_term': \"no_abs t \\<Longrightarrow> nterm_to_term' t = convert_term t\"", "lemma nterm_to_term_frees[simp]: \"frees (nterm_to_term \\<Gamma> t) = frees t - fset_of_list \\<Gamma>\"", "lemma term_to_nterm_nterm_to_term0:\n  assumes \"wellformed' (length \\<Gamma>) t\" \"fdisjnt (fset_of_list \\<Gamma>) (frees t)\" \"distinct \\<Gamma>\"\n  assumes \"fBall (frees t |\\<union>| fset_of_list \\<Gamma>) (\\<lambda>x. x \\<le> s)\"\n  shows \"nterm_to_term \\<Gamma> (fst (run_state (term_to_nterm \\<Gamma> t) s)) = t\"", "lemma term_to_nterm_nterm_to_term:\n  assumes \"wellformed t\" \"frees t |\\<subseteq>| S\"\n  shows \"nterm_to_term' (frun_fresh (term_to_nterm [] t) (S |\\<union>| Q)) = t\"", "lemma nterm_to_term_eq:\n  assumes \"frees u |\\<subseteq>| fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\"\n  shows \"nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u\"", "lemma nterm_to_term_wellformed: \"wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> t)\"", "lemma nterm_to_term_term_to_nterm:\n  assumes \"frees t |\\<subseteq>| fset_of_list \\<Gamma>\" \"length \\<Gamma> = length \\<Gamma>'\"\n  shows \"alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>')) t (fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term \\<Gamma> t)) s))\"", "lemma term_to_nterm_alpha_equiv0:\n  \"length \\<Gamma>1 = length \\<Gamma>2 \\<Longrightarrow> distinct \\<Gamma>1 \\<Longrightarrow> distinct \\<Gamma>2 \\<Longrightarrow> wellformed' (length \\<Gamma>1) t1 \\<Longrightarrow>\n   fresh_fin (frees t1 |\\<union>| fset_of_list \\<Gamma>1) s1 \\<Longrightarrow> fdisjnt (fset_of_list \\<Gamma>1) (frees t1) \\<Longrightarrow>\n   fresh_fin (frees t1 |\\<union>| fset_of_list \\<Gamma>2) s2 \\<Longrightarrow> fdisjnt (fset_of_list \\<Gamma>2) (frees t1) \\<Longrightarrow>\n   alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2)) (fst( run_state (term_to_nterm \\<Gamma>1 t1) s1)) (fst ( run_state (term_to_nterm \\<Gamma>2 t1) s2))\"", "lemma term_to_nterm_alpha_equiv:\n  assumes \"length \\<Gamma>1 = length \\<Gamma>2\" \"distinct \\<Gamma>1\" \"distinct \\<Gamma>2\" \"closed t\"\n  assumes \"wellformed' (length \\<Gamma>1) t\"\n  assumes \"fresh_fin (fset_of_list \\<Gamma>1) s1\" \"fresh_fin (fset_of_list \\<Gamma>2) s2\"\n  shows \"alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2)) (fst (run_state (term_to_nterm \\<Gamma>1 t) s1)) (fst (run_state (term_to_nterm \\<Gamma>2 t) s2))\"\n  \\<comment> \\<open>An instantiated version of this lemma with @{prop \\<open>\\<Gamma>1 = []\\<close>} and @{prop \\<open>\\<Gamma>2 = []\\<close>}\n      would not make sense because then it would just be a special case of\n      @{thm [source=true] alpha_eq_refl}.\\<close>", "lemma env_nrelated_closed:\n  assumes \"nrelated.P_env \\<Gamma> env nenv\" \"closed_env nenv\"\n  shows \"nrelated.P_env \\<Gamma>' env nenv\"", "lemma nrelated_subst:\n  assumes \"nrelated.P_env \\<Gamma> env nenv\" \"closed_env nenv\" \"fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\"\n  shows \"subst (nterm_to_term \\<Gamma> t) env = nterm_to_term \\<Gamma> (subst t nenv)\"", "lemma nterm_to_term_insert_dupl:\n  assumes \"y \\<in> set (take n \\<Gamma>)\" \"n \\<le> length \\<Gamma>\"\n  shows \"nterm_to_term \\<Gamma> t = incr_bounds (- 1) (Suc n) (nterm_to_term (insert_nth n y \\<Gamma>) t)\"", "lemma nterm_to_term_bounds_dupl:\n  assumes \"i < length \\<Gamma>\" \"j < length \\<Gamma>\" \"i < j\"\n  assumes \"\\<Gamma> ! i = \\<Gamma> ! j\"\n  shows \"j |\\<notin>| bounds (nterm_to_term \\<Gamma> t)\"", "lemma subst_single_eq: \"subst_single t s t' = subst t (fmap_of_list [(s, t')])\"", "lemma nterm_to_term_subst_replace_bound:\n  assumes \"closed u'\" \"n \\<le> length \\<Gamma>\" \"x \\<notin> set (take n \\<Gamma>)\"\n  shows \"nterm_to_term \\<Gamma> (subst_single u x u') = replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u')\""], "translations": [["", "lemma alpha_equiv_refl[intro?]:\n  assumes \"fmpred (=) \\<Gamma>\"\n  shows \"alpha_equiv \\<Gamma> t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv \\<Gamma> t t", "using assms"], ["proof (prove)\nusing this:\n  fmpred (=) \\<Gamma>\n\ngoal (1 subgoal):\n 1. alpha_equiv \\<Gamma> t t", "proof (induction t arbitrary: \\<Gamma>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       fmpred (=) \\<Gamma> \\<Longrightarrow>\n       alpha_equiv \\<Gamma> (Nconst x) (Nconst x)\n 2. \\<And>x \\<Gamma>.\n       fmpred (=) \\<Gamma> \\<Longrightarrow>\n       alpha_equiv \\<Gamma> (Nvar x) (Nvar x)\n 3. \\<And>x1a t \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fmpred (=) \\<Gamma> \\<Longrightarrow>\n                   alpha_equiv \\<Gamma> t t;\n        fmpred (=) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t)\n                          (\\<Lambda>\\<^sub>n x1a. t)\n 4. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fmpred (=) \\<Gamma> \\<Longrightarrow>\n                   alpha_equiv \\<Gamma> t1 t1;\n        \\<And>\\<Gamma>.\n           fmpred (=) \\<Gamma> \\<Longrightarrow> alpha_equiv \\<Gamma> t2 t2;\n        fmpred (=) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv \\<Gamma> (t1 $\\<^sub>n t2)\n                          (t1 $\\<^sub>n t2)", "case Napp"], ["proof (state)\nthis:\n  fmpred (=) ?\\<Gamma> \\<Longrightarrow> alpha_equiv ?\\<Gamma> t1_ t1_\n  fmpred (=) ?\\<Gamma> \\<Longrightarrow> alpha_equiv ?\\<Gamma> t2_ t2_\n  fmpred (=) \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       fmpred (=) \\<Gamma> \\<Longrightarrow>\n       alpha_equiv \\<Gamma> (Nconst x) (Nconst x)\n 2. \\<And>x \\<Gamma>.\n       fmpred (=) \\<Gamma> \\<Longrightarrow>\n       alpha_equiv \\<Gamma> (Nvar x) (Nvar x)\n 3. \\<And>x1a t \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fmpred (=) \\<Gamma> \\<Longrightarrow>\n                   alpha_equiv \\<Gamma> t t;\n        fmpred (=) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t)\n                          (\\<Lambda>\\<^sub>n x1a. t)\n 4. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fmpred (=) \\<Gamma> \\<Longrightarrow>\n                   alpha_equiv \\<Gamma> t1 t1;\n        \\<And>\\<Gamma>.\n           fmpred (=) \\<Gamma> \\<Longrightarrow> alpha_equiv \\<Gamma> t2 t2;\n        fmpred (=) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv \\<Gamma> (t1 $\\<^sub>n t2)\n                          (t1 $\\<^sub>n t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv \\<Gamma> (t1_ $\\<^sub>n t2_) (t1_ $\\<^sub>n t2_)", "apply (rule alpha_equiv.app; rule Napp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmpred (=) \\<Gamma>\n 2. fmpred (=) \\<Gamma>", "using Napp.prems"], ["proof (prove)\nusing this:\n  fmpred (=) \\<Gamma>\n\ngoal (2 subgoals):\n 1. fmpred (=) \\<Gamma>\n 2. fmpred (=) \\<Gamma>", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  fmpred (=) \\<Gamma>\n\ngoal (2 subgoals):\n 1. fmpred (=) \\<Gamma>\n 2. fmpred (=) \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  alpha_equiv \\<Gamma> (t1_ $\\<^sub>n t2_) (t1_ $\\<^sub>n t2_)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma>.\n       fmpred (=) \\<Gamma> \\<Longrightarrow>\n       alpha_equiv \\<Gamma> (Nconst x) (Nconst x)\n 2. \\<And>x \\<Gamma>.\n       fmpred (=) \\<Gamma> \\<Longrightarrow>\n       alpha_equiv \\<Gamma> (Nvar x) (Nvar x)\n 3. \\<And>x1a t \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fmpred (=) \\<Gamma> \\<Longrightarrow>\n                   alpha_equiv \\<Gamma> t t;\n        fmpred (=) \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t)\n                          (\\<Lambda>\\<^sub>n x1a. t)", "qed (auto simp: fdisjnt_alt_def intro: alpha_equiv.intros)"], ["", "corollary alpha_eq_refl: \"alpha_eq t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<approx>\\<^sub>\\<alpha> t", "by (auto intro: alpha_equiv_refl)"], ["", "section \\<open>From @{typ term} to @{typ nterm}\\<close>"], ["", "fun term_to_nterm :: \"name list \\<Rightarrow> term \\<Rightarrow> (name, nterm) state\" where\n\"term_to_nterm _ (Const name) = State_Monad.return (Nconst name)\" |\n\"term_to_nterm _ (Free name) = State_Monad.return (Nvar name)\" |\n\"term_to_nterm \\<Gamma> (Bound n) = State_Monad.return (Nvar (\\<Gamma> ! n))\" |\n\"term_to_nterm \\<Gamma> (\\<Lambda> t) = do {\n  n \\<leftarrow> fresh_create;\n  e \\<leftarrow> term_to_nterm (n # \\<Gamma>) t;\n  State_Monad.return (\\<Lambda>\\<^sub>n n. e)\n}\" |\n\"term_to_nterm \\<Gamma> (t\\<^sub>1 $ t\\<^sub>2) = do {\n  e\\<^sub>1 \\<leftarrow> term_to_nterm \\<Gamma> t\\<^sub>1;\n  e\\<^sub>2 \\<leftarrow> term_to_nterm \\<Gamma> t\\<^sub>2;\n  State_Monad.return (e\\<^sub>1 $\\<^sub>n e\\<^sub>2)\n}\""], ["", "lemmas term_to_nterm_induct = term_to_nterm.induct[case_names const free bound abs app]"], ["", "lemma term_to_nterm:\n  assumes \"no_abs t\"\n  shows \"fst (run_state (term_to_nterm \\<Gamma> t) x) = convert_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (run_state (term_to_nterm \\<Gamma> t) x) = convert_term t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n\ngoal (1 subgoal):\n 1. fst (run_state (term_to_nterm \\<Gamma> t) x) = convert_term t", "apply (induction arbitrary: x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>name x.\n       fst (run_state (term_to_nterm \\<Gamma> (free name)) x) =\n       convert_term (free name)\n 2. \\<And>name x.\n       fst (run_state (term_to_nterm \\<Gamma> (const name)) x) =\n       convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x) =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>x.\n           fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x) =\n           convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> fst (run_state\n                               (term_to_nterm \\<Gamma>\n                                 (app t\\<^sub>1 t\\<^sub>2))\n                               x) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>name x.\n       fst (run_state (term_to_nterm \\<Gamma> (free name)) x) = free name\n 2. \\<And>name x.\n       fst (run_state (term_to_nterm \\<Gamma> (const name)) x) = const name\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 x.\n       \\<lbrakk>\\<And>x.\n                   fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) x) =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>x.\n           fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2) x) =\n           convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> fst (run_state\n                               (term_to_nterm \\<Gamma>\n                                 (app t\\<^sub>1 t\\<^sub>2))\n                               x) =\n                         app (convert_term t\\<^sub>1)\n                          (convert_term t\\<^sub>2)", "by (auto simp: free_term_def free_nterm_def const_term_def const_nterm_def app_term_def app_nterm_def split_beta split: prod.splits)"], ["", "definition term_to_nterm' :: \"term \\<Rightarrow> nterm\" where\n\"term_to_nterm' t = frun_fresh (term_to_nterm [] t) (frees t)\""], ["", "lemma term_to_nterm_mono: \"mono_state (term_to_nterm \\<Gamma> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono_state (term_to_nterm \\<Gamma> x)", "by (induction \\<Gamma> x rule: term_to_nterm.induct) (auto intro: bind_mono_strong)"], ["", "lemma term_to_nterm_vars0:\n  assumes \"wellformed' (length \\<Gamma>) t\"\n  shows \"frees (fst (run_state (term_to_nterm \\<Gamma> t) s)) |\\<subseteq>| frees t |\\<union>| fset_of_list \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (fst (run_state (term_to_nterm \\<Gamma> t) s)) |\\<subseteq>|\n    frees t |\\<union>| fset_of_list \\<Gamma>", "using assms"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) t\n\ngoal (1 subgoal):\n 1. frees (fst (run_state (term_to_nterm \\<Gamma> t) s)) |\\<subseteq>|\n    frees t |\\<union>| fset_of_list \\<Gamma>", "proof (induction \\<Gamma> t arbitrary: s rule: term_to_nterm_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> n s.\n       wellformed' (length \\<Gamma>) (Bound n) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm \\<Gamma> (Bound n)) s)) |\\<subseteq>|\n       frees (Bound n) |\\<union>| fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "case (bound \\<Gamma> i)"], ["proof (state)\nthis:\n  wellformed' (length \\<Gamma>) (Bound i)\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> n s.\n       wellformed' (length \\<Gamma>) (Bound n) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm \\<Gamma> (Bound n)) s)) |\\<subseteq>|\n       frees (Bound n) |\\<union>| fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "hence \"\\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>\""], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) (Bound i)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>", "including fset.lifting"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) (Bound i)\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>", "by transfer auto"], ["proof (state)\nthis:\n  \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> n s.\n       wellformed' (length \\<Gamma>) (Bound n) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm \\<Gamma> (Bound n)) s)) |\\<subseteq>|\n       frees (Bound n) |\\<union>| fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> ! i |\\<in>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. frees\n     (fst (run_state (term_to_nterm \\<Gamma> (Bound i)) s)) |\\<subseteq>|\n    frees (Bound i) |\\<union>| fset_of_list \\<Gamma>", "by (auto simp: State_Monad.return_def)"], ["proof (state)\nthis:\n  frees (fst (run_state (term_to_nterm \\<Gamma> (Bound i)) s)) |\\<subseteq>|\n  frees (Bound i) |\\<union>| fset_of_list \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "case (abs \\<Gamma> t)"], ["proof (state)\nthis:\n  wellformed' (length (?x # \\<Gamma>)) t \\<Longrightarrow>\n  frees (fst (run_state (term_to_nterm (?x # \\<Gamma>) t) ?s)) |\\<subseteq>|\n  frees t |\\<union>| fset_of_list (?x # \\<Gamma>)\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "let ?x = \"next s\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "from abs"], ["proof (chain)\npicking this:\n  wellformed' (length (?x # \\<Gamma>)) t \\<Longrightarrow>\n  frees (fst (run_state (term_to_nterm (?x # \\<Gamma>) t) ?s)) |\\<subseteq>|\n  frees t |\\<union>| fset_of_list (?x # \\<Gamma>)\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)", "have \"frees (fst (run_state (term_to_nterm (?x # \\<Gamma>) t) ?x)) |\\<subseteq>| frees t |\\<union>| {|?x|} |\\<union>| fset_of_list \\<Gamma>\""], ["proof (prove)\nusing this:\n  wellformed' (length (?x # \\<Gamma>)) t \\<Longrightarrow>\n  frees (fst (run_state (term_to_nterm (?x # \\<Gamma>) t) ?s)) |\\<subseteq>|\n  frees t |\\<union>| fset_of_list (?x # \\<Gamma>)\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n\ngoal (1 subgoal):\n 1. frees\n     (fst (run_state (term_to_nterm (next s # \\<Gamma>) t)\n            (next s))) |\\<subseteq>|\n    frees t |\\<union>| {|next s|} |\\<union>| fset_of_list \\<Gamma>", "by simp"], ["proof (state)\nthis:\n  frees\n   (fst (run_state (term_to_nterm (next s # \\<Gamma>) t)\n          (next s))) |\\<subseteq>|\n  frees t |\\<union>| {|next s|} |\\<union>| fset_of_list \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   wellformed' (length (x # \\<Gamma>)) t \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm (x # \\<Gamma>) t)\n                           s)) |\\<subseteq>|\n                   frees t |\\<union>| fset_of_list (x # \\<Gamma>);\n        wellformed' (length \\<Gamma>) (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) |\\<subseteq>|\n                         frees (\\<Lambda> t) |\\<union>|\n                         fset_of_list \\<Gamma>\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "thus ?case"], ["proof (prove)\nusing this:\n  frees\n   (fst (run_state (term_to_nterm (next s # \\<Gamma>) t)\n          (next s))) |\\<subseteq>|\n  frees t |\\<union>| {|next s|} |\\<union>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. frees\n     (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t))\n            s)) |\\<subseteq>|\n    frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>", "by (auto simp: create_alt_def split_beta)"], ["proof (state)\nthis:\n  frees\n   (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t)) s)) |\\<subseteq>|\n  frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name s.\n       wellformed' (length uu_) (Const name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uu_ (Const name)) s)) |\\<subseteq>|\n       frees (Const name) |\\<union>| fset_of_list uu_\n 2. \\<And>uv_ name s.\n       wellformed' (length uv_) (Free name) \\<Longrightarrow>\n       frees\n        (fst (run_state (term_to_nterm uv_ (Free name)) s)) |\\<subseteq>|\n       frees (Free name) |\\<union>| fset_of_list uv_\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   wellformed' (length \\<Gamma>) t\\<^sub>1 \\<Longrightarrow>\n                   frees\n                    (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                           s)) |\\<subseteq>|\n                   frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>;\n        \\<And>x s.\n           wellformed' (length \\<Gamma>) t\\<^sub>2 \\<Longrightarrow>\n           frees\n            (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                   s)) |\\<subseteq>|\n           frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> frees\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) |\\<subseteq>|\n                         frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>|\n                         fset_of_list \\<Gamma>", "qed (auto simp: split_beta)"], ["", "corollary term_to_nterm_vars:\n  assumes \"wellformed t\"\n  shows \"frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t", "let ?\\<Gamma> = \"[]\""], ["proof (state)\ngoal (1 subgoal):\n 1. frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t", "from assms"], ["proof (chain)\npicking this:\n  wellformed t", "have \"wellformed' (length ?\\<Gamma>) t\""], ["proof (prove)\nusing this:\n  wellformed t\n\ngoal (1 subgoal):\n 1. wellformed' (length []) t", "by simp"], ["proof (state)\nthis:\n  wellformed' (length []) t\n\ngoal (1 subgoal):\n 1. frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t", "hence \"frees (fst (run_state (term_to_nterm ?\\<Gamma> t) (fNext F))) |\\<subseteq>| (frees t |\\<union>| fset_of_list ?\\<Gamma>)\""], ["proof (prove)\nusing this:\n  wellformed' (length []) t\n\ngoal (1 subgoal):\n 1. frees\n     (fst (run_state (term_to_nterm [] t) (fresh_fNext F))) |\\<subseteq>|\n    frees t |\\<union>| fset_of_list []", "by (rule term_to_nterm_vars0)"], ["proof (state)\nthis:\n  frees (fst (run_state (term_to_nterm [] t) (fresh_fNext F))) |\\<subseteq>|\n  frees t |\\<union>| fset_of_list []\n\ngoal (1 subgoal):\n 1. frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t", "thus ?thesis"], ["proof (prove)\nusing this:\n  frees (fst (run_state (term_to_nterm [] t) (fresh_fNext F))) |\\<subseteq>|\n  frees t |\\<union>| fset_of_list []\n\ngoal (1 subgoal):\n 1. frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t", "by (simp add: fresh_fNext_def fresh_frun_def)"], ["proof (state)\nthis:\n  frees (fresh_frun (term_to_nterm [] t) F) |\\<subseteq>| frees t\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary term_to_nterm_closed: \"closed t \\<Longrightarrow> wellformed t \\<Longrightarrow> closed (term_to_nterm' t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed t; wellformed t\\<rbrakk>\n    \\<Longrightarrow> closed (term_to_nterm' t)", "using term_to_nterm_vars[where F = \"frees t\" and t = t, simplified]"], ["proof (prove)\nusing this:\n  wellformed t \\<Longrightarrow>\n  frees (fresh_frun (term_to_nterm [] t) (frees t)) |\\<subseteq>| frees t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>closed t; wellformed t\\<rbrakk>\n    \\<Longrightarrow> closed (term_to_nterm' t)", "unfolding closed_except_def term_to_nterm'_def"], ["proof (prove)\nusing this:\n  wellformed t \\<Longrightarrow>\n  frees (fresh_frun (term_to_nterm [] t) (frees t)) |\\<subseteq>| frees t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>frees t |\\<subseteq>| {||}; wellformed t\\<rbrakk>\n    \\<Longrightarrow> frees\n                       (frun_fresh (term_to_nterm [] t)\n                         (frees t)) |\\<subseteq>|\n                      {||}", "by (simp add: fresh_frun_def)"], ["", "lemma term_to_nterm_consts: \"pred_state (\\<lambda>t'. consts t' = consts t) (term_to_nterm \\<Gamma> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_state (\\<lambda>t'. consts t' = consts t)\n     (term_to_nterm \\<Gamma> t)", "apply (rule pred_stateI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s s'.\n       run_state (term_to_nterm \\<Gamma> t) s = (a, s') \\<Longrightarrow>\n       consts a = consts t", "apply (induction t arbitrary: \\<Gamma>)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x a s s' \\<Gamma>.\n       run_state (term_to_nterm \\<Gamma> (Const x)) s =\n       (a, s') \\<Longrightarrow>\n       consts a = consts (Const x)\n 2. \\<And>x a s s' \\<Gamma>.\n       run_state (term_to_nterm \\<Gamma> (Free x)) s =\n       (a, s') \\<Longrightarrow>\n       consts a = consts (Free x)\n 3. \\<And>t a s s' \\<Gamma>.\n       \\<lbrakk>\\<And>a s s' \\<Gamma>.\n                   run_state (term_to_nterm \\<Gamma> t) s =\n                   (a, s') \\<Longrightarrow>\n                   consts a = consts t;\n        run_state (term_to_nterm \\<Gamma> (\\<Lambda> t)) s =\n        (a, s')\\<rbrakk>\n       \\<Longrightarrow> consts a = consts (\\<Lambda> t)\n 4. \\<And>x a s s' \\<Gamma>.\n       run_state (term_to_nterm \\<Gamma> (Bound x)) s =\n       (a, s') \\<Longrightarrow>\n       consts a = consts (Bound x)\n 5. \\<And>t1 t2 a s s' \\<Gamma>.\n       \\<lbrakk>\\<And>a s s' \\<Gamma>.\n                   run_state (term_to_nterm \\<Gamma> t1) s =\n                   (a, s') \\<Longrightarrow>\n                   consts a = consts t1;\n        \\<And>a s s' \\<Gamma>.\n           run_state (term_to_nterm \\<Gamma> t2) s =\n           (a, s') \\<Longrightarrow>\n           consts a = consts t2;\n        run_state (term_to_nterm \\<Gamma> (t1 $ t2)) s = (a, s')\\<rbrakk>\n       \\<Longrightarrow> consts a = consts (t1 $ t2)", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>From @{typ nterm} to @{typ term}\\<close>"], ["", "fun nterm_to_term :: \"name list \\<Rightarrow> nterm \\<Rightarrow> term\" where\n\"nterm_to_term \\<Gamma> (Nconst name) = Const name\" |\n\"nterm_to_term \\<Gamma> (Nvar name) = (case find_first name \\<Gamma> of Some n \\<Rightarrow> Bound n | None \\<Rightarrow> Free name)\" |\n\"nterm_to_term \\<Gamma> (t $\\<^sub>n u) = nterm_to_term \\<Gamma> t $ nterm_to_term \\<Gamma> u\" |\n\"nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t) = \\<Lambda> nterm_to_term (x # \\<Gamma>) t\""], ["", "lemma nterm_to_term:\n  assumes \"no_abs t\" \"fdisjnt (fset_of_list \\<Gamma>) (frees t)\"\n  shows \"nterm_to_term \\<Gamma> t = convert_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> t = convert_term t", "using assms"], ["proof (prove)\nusing this:\n  no_abs t\n  fdisjnt (fset_of_list \\<Gamma>) (frees t)\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> t = convert_term t", "proof (induction arbitrary: \\<Gamma>)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma>.\n       fdisjnt (fset_of_list \\<Gamma>) (frees (free name)) \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (free name) = convert_term (free name)\n 2. \\<And>name \\<Gamma>.\n       fdisjnt (fset_of_list \\<Gamma>)\n        (frees (const name)) \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (const name) = convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (free name)"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list \\<Gamma>) (frees (free name))\n\ngoal (3 subgoals):\n 1. \\<And>name \\<Gamma>.\n       fdisjnt (fset_of_list \\<Gamma>) (frees (free name)) \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (free name) = convert_term (free name)\n 2. \\<And>name \\<Gamma>.\n       fdisjnt (fset_of_list \\<Gamma>)\n        (frees (const name)) \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (const name) = convert_term (const name)\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  fdisjnt (fset_of_list \\<Gamma>) (frees (free name))", "show ?case"], ["proof (prove)\nusing this:\n  fdisjnt (fset_of_list \\<Gamma>) (frees (free name))\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (free name) = convert_term (free name)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list \\<Gamma>) {|name|} \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (free name) = free name", "apply (auto simp: free_nterm_def free_term_def fdisjnt_alt_def split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<notin>| fset_of_list \\<Gamma> \\<Longrightarrow>\n    find_first name \\<Gamma> = None", "apply (rule find_first_none)"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<notin>| fset_of_list \\<Gamma> \\<Longrightarrow>\n    name \\<notin> set \\<Gamma>", "by (metis fset_of_list_elem)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (free name) = convert_term (free name)\n\ngoal (2 subgoals):\n 1. \\<And>name \\<Gamma>.\n       fdisjnt (fset_of_list \\<Gamma>)\n        (frees (const name)) \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name \\<Gamma>.\n       fdisjnt (fset_of_list \\<Gamma>)\n        (frees (const name)) \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (const name)"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list \\<Gamma>) (frees (const name))\n\ngoal (2 subgoals):\n 1. \\<And>name \\<Gamma>.\n       fdisjnt (fset_of_list \\<Gamma>)\n        (frees (const name)) \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (const name) = convert_term (const name)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (const name) = convert_term (const name)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (const name) = const name", "by (simp add: const_nterm_def const_term_def)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (const name) = convert_term (const name)\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "case (app t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list ?\\<Gamma>) (frees t\\<^sub>1) \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1\n  fdisjnt (fset_of_list ?\\<Gamma>) (frees t\\<^sub>2) \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n  fdisjnt (fset_of_list \\<Gamma>) (frees (app t\\<^sub>1 t\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  fdisjnt (fset_of_list ?\\<Gamma>) (frees t\\<^sub>1) \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1\n  fdisjnt (fset_of_list ?\\<Gamma>) (frees t\\<^sub>2) \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n  fdisjnt (fset_of_list \\<Gamma>) (frees (app t\\<^sub>1 t\\<^sub>2))", "have \"nterm_to_term \\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1\" \"nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2\""], ["proof (prove)\nusing this:\n  fdisjnt (fset_of_list ?\\<Gamma>) (frees t\\<^sub>1) \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1\n  fdisjnt (fset_of_list ?\\<Gamma>) (frees t\\<^sub>2) \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2\n  no_abs t\\<^sub>1\n  no_abs t\\<^sub>2\n  fdisjnt (fset_of_list \\<Gamma>) (frees (app t\\<^sub>1 t\\<^sub>2))\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1 &&&\n    nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2", "by (auto simp: fdisjnt_alt_def finter_funion_distrib)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1\n  nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   fdisjnt (fset_of_list \\<Gamma>)\n                    (frees t\\<^sub>1) \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> t\\<^sub>1 =\n                   convert_term t\\<^sub>1;\n        no_abs t\\<^sub>1;\n        \\<And>\\<Gamma>.\n           fdisjnt (fset_of_list \\<Gamma>)\n            (frees t\\<^sub>2) \\<Longrightarrow>\n           nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2;\n        no_abs t\\<^sub>2;\n        fdisjnt (fset_of_list \\<Gamma>)\n         (frees (app t\\<^sub>1 t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                         convert_term (app t\\<^sub>1 t\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  nterm_to_term \\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1\n  nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  nterm_to_term \\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1\n  nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n    convert_term (app t\\<^sub>1 t\\<^sub>2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nterm_to_term \\<Gamma> t\\<^sub>1 = convert_term t\\<^sub>1;\n     nterm_to_term \\<Gamma> t\\<^sub>2 = convert_term t\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n                      app (convert_term t\\<^sub>1) (convert_term t\\<^sub>2)", "by (simp add: app_nterm_def app_term_def)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (app t\\<^sub>1 t\\<^sub>2) =\n  convert_term (app t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"nterm_to_term' \\<equiv> nterm_to_term []\""], ["", "lemma nterm_to_term': \"no_abs t \\<Longrightarrow> nterm_to_term' t = convert_term t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_abs t \\<Longrightarrow> nterm_to_term' t = convert_term t", "by (auto simp: fdisjnt_alt_def nterm_to_term)"], ["", "lemma nterm_to_term_frees[simp]: \"frees (nterm_to_term \\<Gamma> t) = frees t - fset_of_list \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (nterm_to_term \\<Gamma> t) = frees t |-| fset_of_list \\<Gamma>", "proof (induction t arbitrary: \\<Gamma>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       frees (nterm_to_term \\<Gamma> (Nconst x)) =\n       frees (Nconst x) |-| fset_of_list \\<Gamma>\n 2. \\<And>x \\<Gamma>.\n       frees (nterm_to_term \\<Gamma> (Nvar x)) =\n       frees (Nvar x) |-| fset_of_list \\<Gamma>\n 3. \\<And>x1a t \\<Gamma>.\n       (\\<And>\\<Gamma>.\n           frees (nterm_to_term \\<Gamma> t) =\n           frees t |-| fset_of_list \\<Gamma>) \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t)) =\n       frees (\\<Lambda>\\<^sub>n x1a. t) |-| fset_of_list \\<Gamma>\n 4. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   frees (nterm_to_term \\<Gamma> t1) =\n                   frees t1 |-| fset_of_list \\<Gamma>;\n        \\<And>\\<Gamma>.\n           frees (nterm_to_term \\<Gamma> t2) =\n           frees t2 |-| fset_of_list \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> frees (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2)) =\n                         frees (t1 $\\<^sub>n t2) |-| fset_of_list \\<Gamma>", "case (Nvar name)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       frees (nterm_to_term \\<Gamma> (Nconst x)) =\n       frees (Nconst x) |-| fset_of_list \\<Gamma>\n 2. \\<And>x \\<Gamma>.\n       frees (nterm_to_term \\<Gamma> (Nvar x)) =\n       frees (Nvar x) |-| fset_of_list \\<Gamma>\n 3. \\<And>x1a t \\<Gamma>.\n       (\\<And>\\<Gamma>.\n           frees (nterm_to_term \\<Gamma> t) =\n           frees t |-| fset_of_list \\<Gamma>) \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t)) =\n       frees (\\<Lambda>\\<^sub>n x1a. t) |-| fset_of_list \\<Gamma>\n 4. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   frees (nterm_to_term \\<Gamma> t1) =\n                   frees t1 |-| fset_of_list \\<Gamma>;\n        \\<And>\\<Gamma>.\n           frees (nterm_to_term \\<Gamma> t2) =\n           frees t2 |-| fset_of_list \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> frees (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2)) =\n                         frees (t1 $\\<^sub>n t2) |-| fset_of_list \\<Gamma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (nterm_to_term \\<Gamma> (Nvar name)) =\n    frees (Nvar name) |-| fset_of_list \\<Gamma>", "proof (cases \"find_first name \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find_first name \\<Gamma> = None \\<Longrightarrow>\n    frees (nterm_to_term \\<Gamma> (Nvar name)) =\n    frees (Nvar name) |-| fset_of_list \\<Gamma>\n 2. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (Nvar name)) =\n       frees (Nvar name) |-| fset_of_list \\<Gamma>", "case None"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = None\n\ngoal (2 subgoals):\n 1. find_first name \\<Gamma> = None \\<Longrightarrow>\n    frees (nterm_to_term \\<Gamma> (Nvar name)) =\n    frees (Nvar name) |-| fset_of_list \\<Gamma>\n 2. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (Nvar name)) =\n       frees (Nvar name) |-| fset_of_list \\<Gamma>", "hence \"name |\\<notin>| fset_of_list \\<Gamma>\""], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = None\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fset_of_list \\<Gamma>", "including fset.lifting"], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = None\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fset_of_list \\<Gamma>", "by transfer (metis find_first_some option.distinct(1))"], ["proof (state)\nthis:\n  name |\\<notin>| fset_of_list \\<Gamma>\n\ngoal (2 subgoals):\n 1. find_first name \\<Gamma> = None \\<Longrightarrow>\n    frees (nterm_to_term \\<Gamma> (Nvar name)) =\n    frees (Nvar name) |-| fset_of_list \\<Gamma>\n 2. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (Nvar name)) =\n       frees (Nvar name) |-| fset_of_list \\<Gamma>", "with None"], ["proof (chain)\npicking this:\n  find_first name \\<Gamma> = None\n  name |\\<notin>| fset_of_list \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = None\n  name |\\<notin>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. frees (nterm_to_term \\<Gamma> (Nvar name)) =\n    frees (Nvar name) |-| fset_of_list \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  frees (nterm_to_term \\<Gamma> (Nvar name)) =\n  frees (Nvar name) |-| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (Nvar name)) =\n       frees (Nvar name) |-| fset_of_list \\<Gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (Nvar name)) =\n       frees (Nvar name) |-| fset_of_list \\<Gamma>", "case (Some u)"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = Some u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (Nvar name)) =\n       frees (Nvar name) |-| fset_of_list \\<Gamma>", "hence \"name |\\<in>| fset_of_list \\<Gamma>\""], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = Some u\n\ngoal (1 subgoal):\n 1. name |\\<in>| fset_of_list \\<Gamma>", "including fset.lifting"], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = Some u\n\ngoal (1 subgoal):\n 1. name |\\<in>| fset_of_list \\<Gamma>", "by transfer (metis find_first_none option.distinct(1))"], ["proof (state)\nthis:\n  name |\\<in>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (Nvar name)) =\n       frees (Nvar name) |-| fset_of_list \\<Gamma>", "with Some"], ["proof (chain)\npicking this:\n  find_first name \\<Gamma> = Some u\n  name |\\<in>| fset_of_list \\<Gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = Some u\n  name |\\<in>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. frees (nterm_to_term \\<Gamma> (Nvar name)) =\n    frees (Nvar name) |-| fset_of_list \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  frees (nterm_to_term \\<Gamma> (Nvar name)) =\n  frees (Nvar name) |-| fset_of_list \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  frees (nterm_to_term \\<Gamma> (Nvar name)) =\n  frees (Nvar name) |-| fset_of_list \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma>.\n       frees (nterm_to_term \\<Gamma> (Nconst x)) =\n       frees (Nconst x) |-| fset_of_list \\<Gamma>\n 2. \\<And>x1a t \\<Gamma>.\n       (\\<And>\\<Gamma>.\n           frees (nterm_to_term \\<Gamma> t) =\n           frees t |-| fset_of_list \\<Gamma>) \\<Longrightarrow>\n       frees (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t)) =\n       frees (\\<Lambda>\\<^sub>n x1a. t) |-| fset_of_list \\<Gamma>\n 3. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   frees (nterm_to_term \\<Gamma> t1) =\n                   frees t1 |-| fset_of_list \\<Gamma>;\n        \\<And>\\<Gamma>.\n           frees (nterm_to_term \\<Gamma> t2) =\n           frees t2 |-| fset_of_list \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> frees (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2)) =\n                         frees (t1 $\\<^sub>n t2) |-| fset_of_list \\<Gamma>", "qed (auto split: option.splits)"], ["", "section \\<open>Correctness\\<close>"], ["", "text \\<open>Some proofs in this section have been contributed by Yu Zhang.\\<close>"], ["", "lemma term_to_nterm_nterm_to_term0:\n  assumes \"wellformed' (length \\<Gamma>) t\" \"fdisjnt (fset_of_list \\<Gamma>) (frees t)\" \"distinct \\<Gamma>\"\n  assumes \"fBall (frees t |\\<union>| fset_of_list \\<Gamma>) (\\<lambda>x. x \\<le> s)\"\n  shows \"nterm_to_term \\<Gamma> (fst (run_state (term_to_nterm \\<Gamma> t) s)) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (fst (run_state (term_to_nterm \\<Gamma> t) s)) =\n    t", "using assms"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) t\n  fdisjnt (fset_of_list \\<Gamma>) (frees t)\n  distinct \\<Gamma>\n  fBall (frees t |\\<union>| fset_of_list \\<Gamma>) (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (fst (run_state (term_to_nterm \\<Gamma> t) s)) =\n    t", "proof (induction \\<Gamma> t arbitrary: s rule: term_to_nterm_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>uv_ name s.\n       \\<lbrakk>wellformed' (length uv_) (Free name);\n        fdisjnt (fset_of_list uv_) (frees (Free name)); distinct uv_;\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uv_\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s)) =\n                         Free name\n 3. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "case (free \\<Gamma> name)"], ["proof (state)\nthis:\n  wellformed' (length \\<Gamma>) (Free name)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (Free name))\n  distinct \\<Gamma>\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>uv_ name s.\n       \\<lbrakk>wellformed' (length uv_) (Free name);\n        fdisjnt (fset_of_list uv_) (frees (Free name)); distinct uv_;\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uv_\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s)) =\n                         Free name\n 3. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "hence \"fdisjnt (fset_of_list \\<Gamma>) {|name|}\""], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) (Free name)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (Free name))\n  distinct \\<Gamma>\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list \\<Gamma>) {|name|}", "by simp"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list \\<Gamma>) {|name|}\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>uv_ name s.\n       \\<lbrakk>wellformed' (length uv_) (Free name);\n        fdisjnt (fset_of_list uv_) (frees (Free name)); distinct uv_;\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uv_\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s)) =\n                         Free name\n 3. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "hence \"name \\<notin> set \\<Gamma>\""], ["proof (prove)\nusing this:\n  fdisjnt (fset_of_list \\<Gamma>) {|name|}\n\ngoal (1 subgoal):\n 1. name \\<notin> set \\<Gamma>", "including fset.lifting"], ["proof (prove)\nusing this:\n  fdisjnt (fset_of_list \\<Gamma>) {|name|}\n\ngoal (1 subgoal):\n 1. name \\<notin> set \\<Gamma>", "by transfer' (simp add: disjnt_def)"], ["proof (state)\nthis:\n  name \\<notin> set \\<Gamma>\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>uv_ name s.\n       \\<lbrakk>wellformed' (length uv_) (Free name);\n        fdisjnt (fset_of_list uv_) (frees (Free name)); distinct uv_;\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uv_\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s)) =\n                         Free name\n 3. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "hence \"find_first name \\<Gamma> = None\""], ["proof (prove)\nusing this:\n  name \\<notin> set \\<Gamma>\n\ngoal (1 subgoal):\n 1. find_first name \\<Gamma> = None", "by (rule find_first_none)"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = None\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>uv_ name s.\n       \\<lbrakk>wellformed' (length uv_) (Free name);\n        fdisjnt (fset_of_list uv_) (frees (Free name)); distinct uv_;\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uv_\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s)) =\n                         Free name\n 3. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 4. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "thus ?case"], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = None\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> (Free name)) s)) =\n    Free name", "by (simp add: State_Monad.return_def)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma>\n   (fst (run_state (term_to_nterm \\<Gamma> (Free name)) s)) =\n  Free name\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "case (bound \\<Gamma> i)"], ["proof (state)\nthis:\n  wellformed' (length \\<Gamma>) (Bound i)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (Bound i))\n  distinct \\<Gamma>\n  fBall (frees (Bound i) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> n s.\n       \\<lbrakk>wellformed' (length \\<Gamma>) (Bound n);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        distinct \\<Gamma>;\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s)) =\n                         Bound n\n 3. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "thus ?case"], ["proof (prove)\nusing this:\n  wellformed' (length \\<Gamma>) (Bound i)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (Bound i))\n  distinct \\<Gamma>\n  fBall (frees (Bound i) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> (Bound i)) s)) =\n    Bound i", "by (simp add: State_Monad.return_def find_first_some_index)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma>\n   (fst (run_state (term_to_nterm \\<Gamma> (Bound i)) s)) =\n  Bound i\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "case (app \\<Gamma> t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                            ?s)) =\n                    t\\<^sub>1\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                            ?s)) =\n                    t\\<^sub>2\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  distinct \\<Gamma>\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "have \"fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1)", "apply (rule fdisjnt_subset_right[where N = \"frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. frees t\\<^sub>1 |\\<subseteq>| frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2\n 2. fdisjnt (fset_of_list \\<Gamma>)\n     (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2)", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                            ?s)) =\n                    t\\<^sub>1\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                            ?s)) =\n                    t\\<^sub>2\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  distinct \\<Gamma>\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (2 subgoals):\n 1. frees t\\<^sub>1 |\\<subseteq>| frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2\n 2. fdisjnt (fset_of_list \\<Gamma>)\n     (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "have \"fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2)", "apply (rule fdisjnt_subset_right[where N = \"frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2\n 2. fdisjnt (fset_of_list \\<Gamma>)\n     (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2)", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                            ?s)) =\n                    t\\<^sub>1\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                            ?s)) =\n                    t\\<^sub>2\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  distinct \\<Gamma>\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (2 subgoals):\n 1. frees t\\<^sub>2 |\\<subseteq>| frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2\n 2. fdisjnt (fset_of_list \\<Gamma>)\n     (frees t\\<^sub>1 |\\<union>| frees t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "have s: \"s \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)", "apply (rule state_io_relD[OF term_to_nterm_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (term_to_nterm ?\\<Gamma>1 ?x1) s =\n    (?a, snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s))", "apply (rule surjective_pairing)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    distinct \\<Gamma>;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n                                     t\\<^sub>1;\n        \\<And>x s.\n           \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            distinct \\<Gamma>;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>x. x \\<le> s)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma>\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2)\n                                     s)) =\n                             t\\<^sub>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        distinct \\<Gamma>;\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s)) =\n                         t\\<^sub>1 $ t\\<^sub>2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> (t\\<^sub>1 $ t\\<^sub>2)) s)) =\n    t\\<^sub>1 $ t\\<^sub>2", "apply (auto simp: split_beta)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n    t\\<^sub>1\n 2. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)))) =\n    t\\<^sub>2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)) =\n    t\\<^sub>1", "apply (rule app)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>1\n 2. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1)\n 3. distinct \\<Gamma>\n 4. fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>1", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                            ?s)) =\n                    t\\<^sub>1\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                            ?s)) =\n                    t\\<^sub>2\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  distinct \\<Gamma>\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>1", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1)\n 2. distinct \\<Gamma>\n 3. fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1)", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct \\<Gamma>\n 2. fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct \\<Gamma>", "by fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s)", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                            ?s)) =\n                    t\\<^sub>1\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                            ?s)) =\n                    t\\<^sub>2\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  distinct \\<Gamma>\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)))) =\n    t\\<^sub>2", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)))) =\n    t\\<^sub>2", "apply (rule app)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>2\n 2. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2)\n 3. distinct \\<Gamma>\n 4. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x.\n         x \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>2", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                            ?s)) =\n                    t\\<^sub>1\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                            ?s)) =\n                    t\\<^sub>2\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  distinct \\<Gamma>\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) t\\<^sub>2", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2)\n 2. distinct \\<Gamma>\n 3. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x.\n         x \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2)", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct \\<Gamma>\n 2. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x.\n         x \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct \\<Gamma>", "by fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x.\n         x \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s))", "using app s"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>1;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1)\n                            ?s)) =\n                    t\\<^sub>1\n  \\<lbrakk>wellformed' (length \\<Gamma>) t\\<^sub>2;\n   fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2); distinct \\<Gamma>;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term \\<Gamma>\n                     (fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>2)\n                            ?s)) =\n                    t\\<^sub>2\n  wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  distinct \\<Gamma>\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n  s \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s)\n\ngoal (1 subgoal):\n 1. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x.\n         x \\<le> snd (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s))", "by force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma>\n   (fst (run_state (term_to_nterm \\<Gamma> (t\\<^sub>1 $ t\\<^sub>2)) s)) =\n  t\\<^sub>1 $ t\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t", "case (abs \\<Gamma> t)"], ["proof (state)\nthis:\n  \\<lbrakk>wellformed' (length (?x # \\<Gamma>)) t;\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   distinct (?x # \\<Gamma>);\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term (?x # \\<Gamma>)\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s)) =\n                    t\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  distinct \\<Gamma>\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t", "have \"next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>", "using abs(5)[simplified]"], ["proof (prove)\nusing this:\n  fBall (frees t |\\<union>| fset_of_list \\<Gamma>) (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>", "by (rule next_ge_fall)"], ["proof (state)\nthis:\n  next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t", "have \"nterm_to_term (next s # \\<Gamma>) (fst (run_state (term_to_nterm (next s # \\<Gamma>) t) (next s))) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term (next s # \\<Gamma>)\n     (fst (run_state (term_to_nterm (next s # \\<Gamma>) t) (next s))) =\n    t", "proof (subst abs)"], ["proof (state)\ngoal (5 subgoals):\n 1. wellformed' (length (next s # \\<Gamma>)) t\n 2. fdisjnt (fset_of_list (next s # \\<Gamma>)) (frees t)\n 3. distinct (next s # \\<Gamma>)\n 4. fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>))\n     (\\<lambda>x. x \\<le> next s)\n 5. t = t", "show \"wellformed' (length (next s # \\<Gamma>)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length (next s # \\<Gamma>)) t", "using abs"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellformed' (length (?x # \\<Gamma>)) t;\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   distinct (?x # \\<Gamma>);\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term (?x # \\<Gamma>)\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s)) =\n                    t\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  distinct \\<Gamma>\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. wellformed' (length (next s # \\<Gamma>)) t", "by auto"], ["proof (state)\nthis:\n  wellformed' (length (next s # \\<Gamma>)) t\n\ngoal (4 subgoals):\n 1. fdisjnt (fset_of_list (next s # \\<Gamma>)) (frees t)\n 2. distinct (next s # \\<Gamma>)\n 3. fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>))\n     (\\<lambda>x. x \\<le> next s)\n 4. t = t", "show \"fdisjnt (fset_of_list (next s # \\<Gamma>)) (frees t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list (next s # \\<Gamma>)) (frees t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (finsert (next s) (fset_of_list \\<Gamma>)) (frees t)", "apply (rule fdisjnt_insert)"], ["proof (prove)\ngoal (2 subgoals):\n 1. next s |\\<notin>| frees t\n 2. fdisjnt (fset_of_list \\<Gamma>) (frees t)", "using \\<open>next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>\\<close> abs"], ["proof (prove)\nusing this:\n  next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>\n  \\<lbrakk>wellformed' (length (?x # \\<Gamma>)) t;\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   distinct (?x # \\<Gamma>);\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>x. x \\<le> ?s)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term (?x # \\<Gamma>)\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s)) =\n                    t\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  distinct \\<Gamma>\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (2 subgoals):\n 1. next s |\\<notin>| frees t\n 2. fdisjnt (fset_of_list \\<Gamma>) (frees t)", "by auto"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list (next s # \\<Gamma>)) (frees t)\n\ngoal (3 subgoals):\n 1. distinct (next s # \\<Gamma>)\n 2. fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>))\n     (\\<lambda>x. x \\<le> next s)\n 3. t = t", "show \"distinct (next s # \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (next s # \\<Gamma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. next s \\<notin> set \\<Gamma> \\<and> distinct \\<Gamma>", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. next s \\<notin> set \\<Gamma>\n 2. distinct \\<Gamma>", "using \\<open>next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  next s |\\<notin>| frees t |\\<union>| fset_of_list \\<Gamma>\n\ngoal (2 subgoals):\n 1. next s \\<notin> set \\<Gamma>\n 2. distinct \\<Gamma>", "apply (simp add: fset_of_list_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct \\<Gamma>", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (next s # \\<Gamma>)\n\ngoal (2 subgoals):\n 1. fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>))\n     (\\<lambda>x. x \\<le> next s)\n 2. t = t", "show \"fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>)) (\\<lambda>x. x \\<le> next s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>))\n     (\\<lambda>x. x \\<le> next s)", "using abs(5)"], ["proof (prove)\nusing this:\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>x. x \\<le> s)\n\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>))\n     (\\<lambda>x. x \\<le> next s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s) \\<Longrightarrow>\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> next s)", "apply (rule fBall_pred_weaken[where P = \"\\<lambda>x. x \\<le> s\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n                 (\\<lambda>x. x \\<le> s);\n        x |\\<in>| frees t |\\<union>| fset_of_list \\<Gamma>;\n        x \\<le> s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> next s\n 2. fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s) \\<Longrightarrow>\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>) (\\<lambda>x. x \\<le> s)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n              (\\<lambda>x. x \\<le> s);\n     x_ |\\<in>| frees t |\\<union>| fset_of_list \\<Gamma>;\n     x_ \\<le> s\\<rbrakk>\n    \\<Longrightarrow> x_ \\<le> next s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n              (\\<lambda>x. x \\<le> s);\n     x_ |\\<in>| frees t \\<or> x_ |\\<in>| fset_of_list \\<Gamma>;\n     x_ \\<le> s\\<rbrakk>\n    \\<Longrightarrow> x_ \\<le> next s", "by (meson dual_order.strict_implies_order dual_order.strict_trans2 fresh_class.next_ge)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s) \\<Longrightarrow>\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>) (\\<lambda>x. x \\<le> s)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>x. x \\<le> s) \\<Longrightarrow>\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>) (\\<lambda>x. x \\<le> s)", "by assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fBall (frees t |\\<union>| fset_of_list (next s # \\<Gamma>))\n   (\\<lambda>x. x \\<le> next s)\n\ngoal (1 subgoal):\n 1. t = t", "qed auto"], ["proof (state)\nthis:\n  nterm_to_term (next s # \\<Gamma>)\n   (fst (run_state (term_to_nterm (next s # \\<Gamma>) t) (next s))) =\n  t\n\ngoal (2 subgoals):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name\n 2. \\<And>\\<Gamma> t s.\n       \\<lbrakk>\\<And>x s.\n                   \\<lbrakk>wellformed' (length (x # \\<Gamma>)) t;\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    distinct (x # \\<Gamma>);\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>x. x \\<le> s)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term (x # \\<Gamma>)\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s)) =\n                                     t;\n        wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        distinct \\<Gamma>;\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t))\n                                 s)) =\n                         \\<Lambda> t", "thus ?case"], ["proof (prove)\nusing this:\n  nterm_to_term (next s # \\<Gamma>)\n   (fst (run_state (term_to_nterm (next s # \\<Gamma>) t) (next s))) =\n  t\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma>\n     (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t)) s)) =\n    \\<Lambda> t", "by (auto simp: split_beta create_alt_def)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma>\n   (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t)) s)) =\n  \\<Lambda> t\n\ngoal (1 subgoal):\n 1. \\<And>uu_ name s.\n       \\<lbrakk>wellformed' (length uu_) (Const name);\n        fdisjnt (fset_of_list uu_) (frees (Const name)); distinct uu_;\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>x. x \\<le> s)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term uu_\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s)) =\n                         Const name", "qed (auto simp: State_Monad.return_def)"], ["", "lemma term_to_nterm_nterm_to_term:\n  assumes \"wellformed t\" \"frees t |\\<subseteq>| S\"\n  shows \"nterm_to_term' (frun_fresh (term_to_nterm [] t) (S |\\<union>| Q)) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term' (frun_fresh (term_to_nterm [] t) (S |\\<union>| Q)) = t", "proof (rule term_to_nterm_nterm_to_term0)"], ["proof (state)\ngoal (4 subgoals):\n 1. wellformed' (length []) t\n 2. fdisjnt (fset_of_list []) (frees t)\n 3. distinct []\n 4. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "show \"wellformed' (length []) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length []) t", "using assms"], ["proof (prove)\nusing this:\n  wellformed t\n  frees t |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. wellformed' (length []) t", "by simp"], ["proof (state)\nthis:\n  wellformed' (length []) t\n\ngoal (3 subgoals):\n 1. fdisjnt (fset_of_list []) (frees t)\n 2. distinct []\n 3. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. fdisjnt (fset_of_list []) (frees t)\n 2. distinct []\n 3. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "show \"fdisjnt (fset_of_list []) (frees t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (fset_of_list []) (frees t)", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fset_of_list [] |\\<inter>| frees t = {||}", "by simp"], ["proof (state)\nthis:\n  fdisjnt (fset_of_list []) (frees t)\n\ngoal (2 subgoals):\n 1. distinct []\n 2. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct []\n 2. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "have \"fBall (S |\\<union>| Q) (\\<lambda>x. x < fresh.fNext next default (S |\\<union>| Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (S |\\<union>| Q)\n     (\\<lambda>x. x < fresh.fNext next default (S |\\<union>| Q))", "by (metis fNext_geq_not_member fresh_fNext_def le_less_linear fBallI)"], ["proof (state)\nthis:\n  fBall (S |\\<union>| Q)\n   (\\<lambda>x. x < fresh.fNext next default (S |\\<union>| Q))\n\ngoal (2 subgoals):\n 1. distinct []\n 2. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "hence \"fBall (S |\\<union>| Q) (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))\""], ["proof (prove)\nusing this:\n  fBall (S |\\<union>| Q)\n   (\\<lambda>x. x < fresh.fNext next default (S |\\<union>| Q))\n\ngoal (1 subgoal):\n 1. fBall (S |\\<union>| Q)\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "by (meson fBall_pred_weaken less_eq_name_def)"], ["proof (state)\nthis:\n  fBall (S |\\<union>| Q)\n   (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))\n\ngoal (2 subgoals):\n 1. distinct []\n 2. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "thus \"fBall (frees t |\\<union>| fset_of_list []) (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))\""], ["proof (prove)\nusing this:\n  fBall (S |\\<union>| Q)\n   (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))\n\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "using \\<open>frees t |\\<subseteq>| S\\<close>"], ["proof (prove)\nusing this:\n  fBall (S |\\<union>| Q)\n   (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))\n  frees t |\\<subseteq>| S\n\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list [])\n     (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))", "by auto"], ["proof (state)\nthis:\n  fBall (frees t |\\<union>| fset_of_list [])\n   (\\<lambda>x. x \\<le> fresh.fNext next default (S |\\<union>| Q))\n\ngoal (1 subgoal):\n 1. distinct []", "qed simp"], ["", "corollary term_to_nterm_nterm_to_term_simple:\n  assumes \"wellformed t\"\n  shows \"nterm_to_term' (term_to_nterm' t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term' (term_to_nterm' t) = t", "unfolding term_to_nterm'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term' (frun_fresh (term_to_nterm [] t) (frees t)) = t", "using assms"], ["proof (prove)\nusing this:\n  wellformed t\n\ngoal (1 subgoal):\n 1. nterm_to_term' (frun_fresh (term_to_nterm [] t) (frees t)) = t", "by (metis order_refl sup.idem term_to_nterm_nterm_to_term)"], ["", "lemma nterm_to_term_eq:\n  assumes \"frees u |\\<subseteq>| fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\"\n  shows \"nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u", "using assms"], ["proof (prove)\nusing this:\n  frees u |\\<subseteq>| fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u", "proof (induction u arbitrary: \\<Gamma> \\<Gamma>')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nvar x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nvar x) = nterm_to_term \\<Gamma>' (Nvar x)\n 3. \\<And>x1a u \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u;\n        frees (\\<Lambda>\\<^sub>n x1a. u) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. u) =\n                         nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x1a. u)\n 4. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "case (Nvar name)"], ["proof (state)\nthis:\n  frees (Nvar name) |\\<subseteq>|\n  fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nvar x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nvar x) = nterm_to_term \\<Gamma>' (Nvar x)\n 3. \\<And>x1a u \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u;\n        frees (\\<Lambda>\\<^sub>n x1a. u) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. u) =\n                         nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x1a. u)\n 4. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "hence \"name \\<in> set (common_prefix \\<Gamma> \\<Gamma>')\""], ["proof (prove)\nusing this:\n  frees (Nvar name) |\\<subseteq>|\n  fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (1 subgoal):\n 1. name \\<in> set (common_prefix \\<Gamma> \\<Gamma>')", "unfolding frees_nterm.simps"], ["proof (prove)\nusing this:\n  {|name|} |\\<subseteq>| fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (1 subgoal):\n 1. name \\<in> set (common_prefix \\<Gamma> \\<Gamma>')", "including fset.lifting"], ["proof (prove)\nusing this:\n  {|name|} |\\<subseteq>| fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (1 subgoal):\n 1. name \\<in> set (common_prefix \\<Gamma> \\<Gamma>')", "by transfer' simp"], ["proof (state)\nthis:\n  name \\<in> set (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nvar x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nvar x) = nterm_to_term \\<Gamma>' (Nvar x)\n 3. \\<And>x1a u \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u;\n        frees (\\<Lambda>\\<^sub>n x1a. u) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. u) =\n                         nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x1a. u)\n 4. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "thus ?case"], ["proof (prove)\nusing this:\n  name \\<in> set (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (Nvar name) = nterm_to_term \\<Gamma>' (Nvar name)", "by (auto simp: common_prefix_find)"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (Nvar name) = nterm_to_term \\<Gamma>' (Nvar name)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>x1a u \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u;\n        frees (\\<Lambda>\\<^sub>n x1a. u) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. u) =\n                         nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x1a. u)\n 3. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>x1a u \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u;\n        frees (\\<Lambda>\\<^sub>n x1a. u) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. u) =\n                         nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x1a. u)\n 3. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "case (Nabs x t)"], ["proof (state)\nthis:\n  frees t |\\<subseteq>|\n  fset_of_list (common_prefix ?\\<Gamma> ?\\<Gamma>') \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t = nterm_to_term ?\\<Gamma>' t\n  frees (\\<Lambda>\\<^sub>n x. t) |\\<subseteq>|\n  fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>x1a u \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u;\n        frees (\\<Lambda>\\<^sub>n x1a. u) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. u) =\n                         nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x1a. u)\n 3. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "hence *: \"frees t - {|x|} |\\<subseteq>| fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\""], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>|\n  fset_of_list (common_prefix ?\\<Gamma> ?\\<Gamma>') \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t = nterm_to_term ?\\<Gamma>' t\n  frees (\\<Lambda>\\<^sub>n x. t) |\\<subseteq>|\n  fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (1 subgoal):\n 1. frees t |-| {|x|} |\\<subseteq>|\n    fset_of_list (common_prefix \\<Gamma> \\<Gamma>')", "by simp"], ["proof (state)\nthis:\n  frees t |-| {|x|} |\\<subseteq>|\n  fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>x1a u \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u = nterm_to_term \\<Gamma>' u;\n        frees (\\<Lambda>\\<^sub>n x1a. u) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. u) =\n                         nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x1a. u)\n 3. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t) =\n    nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x. t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term (x # \\<Gamma>) t = nterm_to_term (x # \\<Gamma>') t", "apply (rule Nabs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>|\n    fset_of_list (common_prefix (x # \\<Gamma>) (x # \\<Gamma>'))", "using * Nabs"], ["proof (prove)\nusing this:\n  frees t |-| {|x|} |\\<subseteq>|\n  fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n  frees t |\\<subseteq>|\n  fset_of_list (common_prefix ?\\<Gamma> ?\\<Gamma>') \\<Longrightarrow>\n  nterm_to_term ?\\<Gamma> t = nterm_to_term ?\\<Gamma>' t\n  frees (\\<Lambda>\\<^sub>n x. t) |\\<subseteq>|\n  fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\n\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>|\n    fset_of_list (common_prefix (x # \\<Gamma>) (x # \\<Gamma>'))", "by auto"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t) =\n  nterm_to_term \\<Gamma>' (\\<Lambda>\\<^sub>n x. t)\n\ngoal (2 subgoals):\n 1. \\<And>x \\<Gamma> \\<Gamma>'.\n       frees (Nconst x) |\\<subseteq>|\n       fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n       nterm_to_term \\<Gamma> (Nconst x) =\n       nterm_to_term \\<Gamma>' (Nconst x)\n 2. \\<And>u1 u2 \\<Gamma> \\<Gamma>'.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Gamma>'.\n                   frees u1 |\\<subseteq>|\n                   fset_of_list\n                    (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n                   nterm_to_term \\<Gamma> u1 = nterm_to_term \\<Gamma>' u1;\n        \\<And>\\<Gamma> \\<Gamma>'.\n           frees u2 |\\<subseteq>|\n           fset_of_list (common_prefix \\<Gamma> \\<Gamma>') \\<Longrightarrow>\n           nterm_to_term \\<Gamma> u2 = nterm_to_term \\<Gamma>' u2;\n        frees (u1 $\\<^sub>n u2) |\\<subseteq>|\n        fset_of_list (common_prefix \\<Gamma> \\<Gamma>')\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (u1 $\\<^sub>n u2) =\n                         nterm_to_term \\<Gamma>' (u1 $\\<^sub>n u2)", "qed auto"], ["", "corollary nterm_to_term_eq_closed: \"closed t \\<Longrightarrow> nterm_to_term \\<Gamma> t = nterm_to_term \\<Gamma>' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t \\<Longrightarrow>\n    nterm_to_term \\<Gamma> t = nterm_to_term \\<Gamma>' t", "by (rule nterm_to_term_eq) (auto simp: closed_except_def)"], ["", "lemma nterm_to_term_wellformed: \"wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> t)", "proof (induction t arbitrary: \\<Gamma>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nvar x))\n 3. \\<And>x1a t \\<Gamma>.\n       (\\<And>\\<Gamma>.\n           wellformed' (length \\<Gamma>)\n            (nterm_to_term \\<Gamma> t)) \\<Longrightarrow>\n       wellformed' (length \\<Gamma>)\n        (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t))\n 4. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   wellformed' (length \\<Gamma>)\n                    (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma>.\n           wellformed' (length \\<Gamma>)\n            (nterm_to_term \\<Gamma> t2)\\<rbrakk>\n       \\<Longrightarrow> wellformed' (length \\<Gamma>)\n                          (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "case (Nabs x t)"], ["proof (state)\nthis:\n  wellformed' (length ?\\<Gamma>) (nterm_to_term ?\\<Gamma> t)\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nvar x))\n 3. \\<And>x1a t \\<Gamma>.\n       (\\<And>\\<Gamma>.\n           wellformed' (length \\<Gamma>)\n            (nterm_to_term \\<Gamma> t)) \\<Longrightarrow>\n       wellformed' (length \\<Gamma>)\n        (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t))\n 4. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   wellformed' (length \\<Gamma>)\n                    (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma>.\n           wellformed' (length \\<Gamma>)\n            (nterm_to_term \\<Gamma> t2)\\<rbrakk>\n       \\<Longrightarrow> wellformed' (length \\<Gamma>)\n                          (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "hence \"wellformed' (Suc (length \\<Gamma>)) (nterm_to_term (x # \\<Gamma>) t)\""], ["proof (prove)\nusing this:\n  wellformed' (length ?\\<Gamma>) (nterm_to_term ?\\<Gamma> t)\n\ngoal (1 subgoal):\n 1. wellformed' (Suc (length \\<Gamma>)) (nterm_to_term (x # \\<Gamma>) t)", "by (metis length_Cons)"], ["proof (state)\nthis:\n  wellformed' (Suc (length \\<Gamma>)) (nterm_to_term (x # \\<Gamma>) t)\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nvar x))\n 3. \\<And>x1a t \\<Gamma>.\n       (\\<And>\\<Gamma>.\n           wellformed' (length \\<Gamma>)\n            (nterm_to_term \\<Gamma> t)) \\<Longrightarrow>\n       wellformed' (length \\<Gamma>)\n        (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t))\n 4. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   wellformed' (length \\<Gamma>)\n                    (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma>.\n           wellformed' (length \\<Gamma>)\n            (nterm_to_term \\<Gamma> t2)\\<rbrakk>\n       \\<Longrightarrow> wellformed' (length \\<Gamma>)\n                          (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "thus ?case"], ["proof (prove)\nusing this:\n  wellformed' (Suc (length \\<Gamma>)) (nterm_to_term (x # \\<Gamma>) t)\n\ngoal (1 subgoal):\n 1. wellformed' (length \\<Gamma>)\n     (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))", "by auto"], ["proof (state)\nthis:\n  wellformed' (length \\<Gamma>)\n   (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x \\<Gamma>.\n       wellformed' (length \\<Gamma>) (nterm_to_term \\<Gamma> (Nvar x))\n 3. \\<And>t1 t2 \\<Gamma>.\n       \\<lbrakk>\\<And>\\<Gamma>.\n                   wellformed' (length \\<Gamma>)\n                    (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma>.\n           wellformed' (length \\<Gamma>)\n            (nterm_to_term \\<Gamma> t2)\\<rbrakk>\n       \\<Longrightarrow> wellformed' (length \\<Gamma>)\n                          (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "qed (auto simp: find_first_correct split: option.splits)"], ["", "corollary nterm_to_term_closed_wellformed: \"closed t \\<Longrightarrow> wellformed (nterm_to_term \\<Gamma> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t \\<Longrightarrow> wellformed (nterm_to_term \\<Gamma> t)", "by (metis Ex_list_of_length nterm_to_term_eq_closed nterm_to_term_wellformed)"], ["", "lemma nterm_to_term_term_to_nterm:\n  assumes \"frees t |\\<subseteq>| fset_of_list \\<Gamma>\" \"length \\<Gamma> = length \\<Gamma>'\"\n  shows \"alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>')) t (fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term \\<Gamma> t)) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>')) t\n     (fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term \\<Gamma> t))\n            s))", "using assms"], ["proof (prove)\nusing this:\n  frees t |\\<subseteq>| fset_of_list \\<Gamma>\n  length \\<Gamma> = length \\<Gamma>'\n\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>')) t\n     (fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term \\<Gamma> t))\n            s))", "proof (induction \\<Gamma> t arbitrary: s \\<Gamma>' rule:nterm_to_term.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name s \\<Gamma>'.\n       \\<lbrakk>frees (Nconst name) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (Nconst name)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (Nconst name)))\n                                 s))\n 2. \\<And>\\<Gamma> name s \\<Gamma>'.\n       \\<lbrakk>frees (Nvar name) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (Nvar name)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (Nvar name)))\n                                 s))\n 3. \\<And>\\<Gamma> t u s \\<Gamma>'.\n       \\<lbrakk>\\<And>s \\<Gamma>'.\n                   \\<lbrakk>frees t |\\<subseteq>| fset_of_list \\<Gamma>;\n                    length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>')) t\n(fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term \\<Gamma> t)) s));\n        \\<And>s \\<Gamma>'.\n           \\<lbrakk>frees u |\\<subseteq>| fset_of_list \\<Gamma>;\n            length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>')) u\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>'\n (nterm_to_term \\<Gamma> u))\n                                     s));\n        frees (t $\\<^sub>n u) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (t $\\<^sub>n u)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (t $\\<^sub>n u)))\n                                 s))\n 4. \\<And>\\<Gamma> x t s \\<Gamma>'.\n       \\<lbrakk>\\<And>s \\<Gamma>'.\n                   \\<lbrakk>frees t |\\<subseteq>|\n                            fset_of_list (x # \\<Gamma>);\n                    length (x # \\<Gamma>) = length \\<Gamma>'\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>')) t\n(fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term (x # \\<Gamma>) t))\n       s));\n        frees (\\<Lambda>\\<^sub>n x. t) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (\\<Lambda>\\<^sub>n x. t)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma>\n                                     (\\<Lambda>\\<^sub>n x. t)))\n                                 s))", "case (4 \\<Gamma> x t)"], ["proof (state)\nthis:\n  \\<lbrakk>frees t |\\<subseteq>| fset_of_list (x # \\<Gamma>);\n   length (x # \\<Gamma>) = length ?\\<Gamma>'\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list (zip (x # \\<Gamma>) ?\\<Gamma>')) t\n                     (fst (run_state\n                            (term_to_nterm ?\\<Gamma>'\n                              (nterm_to_term (x # \\<Gamma>) t))\n                            ?s))\n  frees (\\<Lambda>\\<^sub>n x. t) |\\<subseteq>| fset_of_list \\<Gamma>\n  length \\<Gamma> = length \\<Gamma>'\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> name s \\<Gamma>'.\n       \\<lbrakk>frees (Nconst name) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (Nconst name)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (Nconst name)))\n                                 s))\n 2. \\<And>\\<Gamma> name s \\<Gamma>'.\n       \\<lbrakk>frees (Nvar name) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (Nvar name)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (Nvar name)))\n                                 s))\n 3. \\<And>\\<Gamma> t u s \\<Gamma>'.\n       \\<lbrakk>\\<And>s \\<Gamma>'.\n                   \\<lbrakk>frees t |\\<subseteq>| fset_of_list \\<Gamma>;\n                    length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>')) t\n(fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term \\<Gamma> t)) s));\n        \\<And>s \\<Gamma>'.\n           \\<lbrakk>frees u |\\<subseteq>| fset_of_list \\<Gamma>;\n            length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>')) u\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>'\n (nterm_to_term \\<Gamma> u))\n                                     s));\n        frees (t $\\<^sub>n u) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (t $\\<^sub>n u)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (t $\\<^sub>n u)))\n                                 s))\n 4. \\<And>\\<Gamma> x t s \\<Gamma>'.\n       \\<lbrakk>\\<And>s \\<Gamma>'.\n                   \\<lbrakk>frees t |\\<subseteq>|\n                            fset_of_list (x # \\<Gamma>);\n                    length (x # \\<Gamma>) = length \\<Gamma>'\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>')) t\n(fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term (x # \\<Gamma>) t))\n       s));\n        frees (\\<Lambda>\\<^sub>n x. t) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (\\<Lambda>\\<^sub>n x. t)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma>\n                                     (\\<Lambda>\\<^sub>n x. t)))\n                                 s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n     (\\<Lambda>\\<^sub>n x. t)\n     (fst (run_state\n            (term_to_nterm \\<Gamma>'\n              (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)))\n            s))", "apply (simp add: split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n     (\\<Lambda>\\<^sub>n x. t)\n     (\\<Lambda>\\<^sub>n fst (run_state fresh_create\n                              s). fst (run_state\n  (term_to_nterm (fst (run_state fresh_create s) # \\<Gamma>')\n    (nterm_to_term (x # \\<Gamma>) t))\n  (snd (run_state fresh_create s))))", "apply (rule alpha_equiv.abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv\n     (fmupd x (fst (run_state fresh_create s))\n       (fmap_of_list (zip \\<Gamma> \\<Gamma>')))\n     t (fst (run_state\n              (term_to_nterm (fst (run_state fresh_create s) # \\<Gamma>')\n                (nterm_to_term (x # \\<Gamma>) t))\n              (snd (run_state fresh_create s))))", "using \"4.IH\"[where \\<Gamma>' = \"next s # \\<Gamma>'\"] \"4.prems\""], ["proof (prove)\nusing this:\n  \\<lbrakk>frees t |\\<subseteq>| fset_of_list (x # \\<Gamma>);\n   length (x # \\<Gamma>) = length (next s # \\<Gamma>')\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list\n                       (zip (x # \\<Gamma>) (next s # \\<Gamma>')))\n                     t (fst (run_state\n                              (term_to_nterm (next s # \\<Gamma>')\n                                (nterm_to_term (x # \\<Gamma>) t))\n                              ?s))\n  frees (\\<Lambda>\\<^sub>n x. t) |\\<subseteq>| fset_of_list \\<Gamma>\n  length \\<Gamma> = length \\<Gamma>'\n\ngoal (1 subgoal):\n 1. alpha_equiv\n     (fmupd x (fst (run_state fresh_create s))\n       (fmap_of_list (zip \\<Gamma> \\<Gamma>')))\n     t (fst (run_state\n              (term_to_nterm (fst (run_state fresh_create s) # \\<Gamma>')\n                (nterm_to_term (x # \\<Gamma>) t))\n              (snd (run_state fresh_create s))))", "by (fastforce simp: create_alt_def intro: alpha_equiv.intros)"], ["proof (state)\nthis:\n  alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n   (\\<Lambda>\\<^sub>n x. t)\n   (fst (run_state\n          (term_to_nterm \\<Gamma>'\n            (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)))\n          s))\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> name s \\<Gamma>'.\n       \\<lbrakk>frees (Nconst name) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (Nconst name)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (Nconst name)))\n                                 s))\n 2. \\<And>\\<Gamma> name s \\<Gamma>'.\n       \\<lbrakk>frees (Nvar name) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (Nvar name)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (Nvar name)))\n                                 s))\n 3. \\<And>\\<Gamma> t u s \\<Gamma>'.\n       \\<lbrakk>\\<And>s \\<Gamma>'.\n                   \\<lbrakk>frees t |\\<subseteq>| fset_of_list \\<Gamma>;\n                    length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>')) t\n(fst (run_state (term_to_nterm \\<Gamma>' (nterm_to_term \\<Gamma> t)) s));\n        \\<And>s \\<Gamma>'.\n           \\<lbrakk>frees u |\\<subseteq>| fset_of_list \\<Gamma>;\n            length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>')) u\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>'\n (nterm_to_term \\<Gamma> u))\n                                     s));\n        frees (t $\\<^sub>n u) |\\<subseteq>| fset_of_list \\<Gamma>;\n        length \\<Gamma> = length \\<Gamma>'\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>'))\n                          (t $\\<^sub>n u)\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>'\n                                   (nterm_to_term \\<Gamma> (t $\\<^sub>n u)))\n                                 s))", "qed\n  (force split: option.splits intro: find_first_some intro!: alpha_equiv.intros\n         simp: fset_of_list_elem find_first_in_map split_beta fdisjnt_alt_def)+"], ["", "corollary nterm_to_term_term_to_nterm': \"closed t \\<Longrightarrow> t \\<approx>\\<^sub>\\<alpha> term_to_nterm' (nterm_to_term' t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed t \\<Longrightarrow>\n    t \\<approx>\\<^sub>\\<alpha> term_to_nterm' (nterm_to_term' t)", "unfolding term_to_nterm'_def closed_except_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| {||} \\<Longrightarrow>\n    t \\<approx>\\<^sub>\\<alpha>\n    frun_fresh (term_to_nterm [] (nterm_to_term' t))\n     (frees (nterm_to_term' t))", "apply (rule nterm_to_term_term_to_nterm[where \\<Gamma> = \"[]\" and \\<Gamma>' = \"[]\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees t |\\<subseteq>| {||} \\<Longrightarrow> frees t = {||}", "by auto"], ["", "context begin"], ["", "private"], ["", "lemma term_to_nterm_alpha_equiv0:\n  \"length \\<Gamma>1 = length \\<Gamma>2 \\<Longrightarrow> distinct \\<Gamma>1 \\<Longrightarrow> distinct \\<Gamma>2 \\<Longrightarrow> wellformed' (length \\<Gamma>1) t1 \\<Longrightarrow>\n   fresh_fin (frees t1 |\\<union>| fset_of_list \\<Gamma>1) s1 \\<Longrightarrow> fdisjnt (fset_of_list \\<Gamma>1) (frees t1) \\<Longrightarrow>\n   fresh_fin (frees t1 |\\<union>| fset_of_list \\<Gamma>2) s2 \\<Longrightarrow> fdisjnt (fset_of_list \\<Gamma>2) (frees t1) \\<Longrightarrow>\n   alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2)) (fst( run_state (term_to_nterm \\<Gamma>1 t1) s1)) (fst ( run_state (term_to_nterm \\<Gamma>2 t1) s2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length \\<Gamma>1 = length \\<Gamma>2; distinct \\<Gamma>1;\n     distinct \\<Gamma>2; wellformed' (length \\<Gamma>1) t1;\n     fBall (frees t1 |\\<union>| fset_of_list \\<Gamma>1)\n      (\\<lambda>y. y \\<le> s1);\n     fdisjnt (fset_of_list \\<Gamma>1) (frees t1);\n     fBall (frees t1 |\\<union>| fset_of_list \\<Gamma>2)\n      (\\<lambda>y. y \\<le> s2);\n     fdisjnt (fset_of_list \\<Gamma>2) (frees t1)\\<rbrakk>\n    \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n                       (fst (run_state (term_to_nterm \\<Gamma>1 t1) s1))\n                       (fst (run_state (term_to_nterm \\<Gamma>2 t1) s2))", "proof (induction \\<Gamma>1 t1 arbitrary: \\<Gamma>2 s1 s2 rule:term_to_nterm_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>uv_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uv_ = length \\<Gamma>2; distinct uv_;\n        distinct \\<Gamma>2; wellformed' (length uv_) (Free name);\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uv_) (frees (Free name));\n        fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uv_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Free name)) s2))\n 3. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 4. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "case (free \\<Gamma>1 name)"], ["proof (state)\nthis:\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (Free name)\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (Free name))\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>uv_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uv_ = length \\<Gamma>2; distinct uv_;\n        distinct \\<Gamma>2; wellformed' (length uv_) (Free name);\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uv_) (frees (Free name));\n        fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uv_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Free name)) s2))\n 3. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 4. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "then"], ["proof (chain)\npicking this:\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (Free name)\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (Free name))\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))", "have \"name |\\<notin>| fmdom (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\""], ["proof (prove)\nusing this:\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (Free name)\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (Free name))\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (Free name)\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fset_of_list \\<Gamma>1 |\\<inter>| frees (Free name) = {||}\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fset_of_list \\<Gamma>2 |\\<inter>| frees (Free name) = {||}\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fmdom (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))", "by force"], ["proof (state)\nthis:\n  name |\\<notin>| fmdom (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>uv_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uv_ = length \\<Gamma>2; distinct uv_;\n        distinct \\<Gamma>2; wellformed' (length uv_) (Free name);\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uv_) (frees (Free name));\n        fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uv_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Free name)) s2))\n 3. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 4. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "moreover"], ["proof (state)\nthis:\n  name |\\<notin>| fmdom (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>uv_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uv_ = length \\<Gamma>2; distinct uv_;\n        distinct \\<Gamma>2; wellformed' (length uv_) (Free name);\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uv_) (frees (Free name));\n        fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uv_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Free name)) s2))\n 3. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 4. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "have \"name |\\<notin>| fmran (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<notin>| fmran (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>|\n    fmran (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2)) \\<Longrightarrow>\n    False", "apply (subst (asm) fmran_of_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>|\n    snd |`|\n    fset_of_list\n     (AList.clearjunk (zip \\<Gamma>1 \\<Gamma>2)) \\<Longrightarrow>\n    False", "apply (subst (asm) fset_of_list_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>|\n    fset_of_list\n     (map snd (AList.clearjunk (zip \\<Gamma>1 \\<Gamma>2))) \\<Longrightarrow>\n    False", "apply (subst (asm) distinct_clearjunk_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst (zip \\<Gamma>1 \\<Gamma>2))\n 2. name |\\<in>|\n    fset_of_list (map snd (zip \\<Gamma>1 \\<Gamma>2)) \\<Longrightarrow>\n    False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (zip \\<Gamma>1 \\<Gamma>2))", "apply (subst map_fst_zip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length \\<Gamma>1 = length \\<Gamma>2\n 2. distinct \\<Gamma>1", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct \\<Gamma>1", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>|\n    fset_of_list (map snd (zip \\<Gamma>1 \\<Gamma>2)) \\<Longrightarrow>\n    False", "apply (subst (asm) map_snd_zip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length \\<Gamma>1 = length \\<Gamma>2\n 2. name |\\<in>| fset_of_list \\<Gamma>2 \\<Longrightarrow> False", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. name |\\<in>| fset_of_list \\<Gamma>2 \\<Longrightarrow> False", "using free"], ["proof (prove)\nusing this:\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (Free name)\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (Free name))\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\n\ngoal (1 subgoal):\n 1. name |\\<in>| fset_of_list \\<Gamma>2 \\<Longrightarrow> False", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (Free name)\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fset_of_list \\<Gamma>1 |\\<inter>| frees (Free name) = {||}\n  fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fset_of_list \\<Gamma>2 |\\<inter>| frees (Free name) = {||}\n\ngoal (1 subgoal):\n 1. name |\\<in>| fset_of_list \\<Gamma>2 \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  name |\\<notin>| fmran (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n\ngoal (5 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>uv_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uv_ = length \\<Gamma>2; distinct uv_;\n        distinct \\<Gamma>2; wellformed' (length uv_) (Free name);\n        fBall (frees (Free name) |\\<union>| fset_of_list uv_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uv_) (frees (Free name));\n        fBall (frees (Free name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Free name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uv_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uv_ (Free name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Free name)) s2))\n 3. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 4. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 5. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "ultimately"], ["proof (chain)\npicking this:\n  name |\\<notin>| fmdom (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n  name |\\<notin>| fmran (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))", "show ?case"], ["proof (prove)\nusing this:\n  name |\\<notin>| fmdom (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n  name |\\<notin>| fmran (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 (Free name)) s1))\n     (fst (run_state (term_to_nterm \\<Gamma>2 (Free name)) s2))", "by (force intro:alpha_equiv.intros)"], ["proof (state)\nthis:\n  alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n   (fst (run_state (term_to_nterm \\<Gamma>1 (Free name)) s1))\n   (fst (run_state (term_to_nterm \\<Gamma>2 (Free name)) s2))\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "case (abs \\<Gamma> t)"], ["proof (state)\nthis:\n  \\<lbrakk>length (?x # \\<Gamma>) = length ?\\<Gamma>2.0;\n   distinct (?x # \\<Gamma>); distinct ?\\<Gamma>2.0;\n   wellformed' (length (?x # \\<Gamma>)) t;\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   fBall (frees t |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list (zip (?x # \\<Gamma>) ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t) ?s2.0))\n  length \\<Gamma> = length \\<Gamma>2\n  distinct \\<Gamma>\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "have *: \"next s1 > s1\" \"next s2 > s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 < next s1 &&& s2 < next s2", "using next_ge"], ["proof (prove)\nusing this:\n  ?x < next ?x\n\ngoal (1 subgoal):\n 1. s1 < next s1 &&& s2 < next s2", "by force+"], ["proof (state)\nthis:\n  s1 < next s1\n  s2 < next s2\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "with abs"], ["proof (chain)\npicking this:\n  \\<lbrakk>length (?x # \\<Gamma>) = length ?\\<Gamma>2.0;\n   distinct (?x # \\<Gamma>); distinct ?\\<Gamma>2.0;\n   wellformed' (length (?x # \\<Gamma>)) t;\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   fBall (frees t |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list (zip (?x # \\<Gamma>) ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t) ?s2.0))\n  length \\<Gamma> = length \\<Gamma>2\n  distinct \\<Gamma>\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\n  s1 < next s1\n  s2 < next s2", "have \"next s1 \\<notin> set \\<Gamma>\" \"next s2 \\<notin> set \\<Gamma>2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length (?x # \\<Gamma>) = length ?\\<Gamma>2.0;\n   distinct (?x # \\<Gamma>); distinct ?\\<Gamma>2.0;\n   wellformed' (length (?x # \\<Gamma>)) t;\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   fBall (frees t |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list (zip (?x # \\<Gamma>) ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t) ?s2.0))\n  length \\<Gamma> = length \\<Gamma>2\n  distinct \\<Gamma>\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\n  s1 < next s1\n  s2 < next s2\n\ngoal (1 subgoal):\n 1. next s1 \\<notin> set \\<Gamma> &&& next s2 \\<notin> set \\<Gamma>2", "by (metis fBall_funion fset_of_list_elem next_ge_fall)+"], ["proof (state)\nthis:\n  next s1 \\<notin> set \\<Gamma>\n  next s2 \\<notin> set \\<Gamma>2\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "have \"fresh_fin (frees t |\\<union>| fset_of_list \\<Gamma>) (next s1)\"\n       \"fresh_fin (frees t |\\<union>| fset_of_list \\<Gamma>2) (next s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>y. y \\<le> next s1) &&&\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n     (\\<lambda>y. y \\<le> next s2)", "using * abs"], ["proof (prove)\nusing this:\n  s1 < next s1\n  s2 < next s2\n  \\<lbrakk>length (?x # \\<Gamma>) = length ?\\<Gamma>2.0;\n   distinct (?x # \\<Gamma>); distinct ?\\<Gamma>2.0;\n   wellformed' (length (?x # \\<Gamma>)) t;\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   fBall (frees t |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list (zip (?x # \\<Gamma>) ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t) ?s2.0))\n  length \\<Gamma> = length \\<Gamma>2\n  distinct \\<Gamma>\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\n\ngoal (1 subgoal):\n 1. fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>y. y \\<le> next s1) &&&\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n     (\\<lambda>y. y \\<le> next s2)", "by (smt dual_order.trans fBall_pred_weaken frees_term.simps(3) less_imp_le)+"], ["proof (state)\nthis:\n  fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>y. y \\<le> next s1)\n  fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> next s2)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "have \"fdisjnt (finsert (next s1) (fset_of_list \\<Gamma>)) (frees t)\"\n       \"fdisjnt (finsert (next s2) (fset_of_list \\<Gamma>2)) (frees t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fdisjnt (finsert (next s1) (fset_of_list \\<Gamma>)) (frees t) &&&\n    fdisjnt (finsert (next s2) (fset_of_list \\<Gamma>2)) (frees t)", "unfolding fdisjnt_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finsert (next s1) (fset_of_list \\<Gamma>) |\\<inter>| frees t = {||} &&&\n    finsert (next s2) (fset_of_list \\<Gamma>2) |\\<inter>| frees t = {||}", "using abs frees_term.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>length (?x # \\<Gamma>) = length ?\\<Gamma>2.0;\n   distinct (?x # \\<Gamma>); distinct ?\\<Gamma>2.0;\n   wellformed' (length (?x # \\<Gamma>)) t;\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   fBall (frees t |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list (zip (?x # \\<Gamma>) ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t) ?s2.0))\n  length \\<Gamma> = length \\<Gamma>2\n  distinct \\<Gamma>\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\n  frees (Free ?x) = {|?x|}\n  frees (?t\\<^sub>1 $ ?t\\<^sub>2) =\n  frees ?t\\<^sub>1 |\\<union>| frees ?t\\<^sub>2\n  frees (\\<Lambda> ?t) = frees ?t\n  frees (Const ?v) = {||}\n  frees (Bound ?v) = {||}\n\ngoal (1 subgoal):\n 1. finsert (next s1) (fset_of_list \\<Gamma>) |\\<inter>| frees t = {||} &&&\n    finsert (next s2) (fset_of_list \\<Gamma>2) |\\<inter>| frees t = {||}", "by (metis fdisjnt_alt_def finter_finsert_right funionCI inf_commute next_ge_fall)+"], ["proof (state)\nthis:\n  fdisjnt (finsert (next s1) (fset_of_list \\<Gamma>)) (frees t)\n  fdisjnt (finsert (next s2) (fset_of_list \\<Gamma>2)) (frees t)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "have \"wellformed' (Suc (length \\<Gamma>2)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellformed' (Suc (length \\<Gamma>2)) t", "using wellformed'.simps abs"], ["proof (prove)\nusing this:\n  wellformed' ?n (?t\\<^sub>1 $ ?t\\<^sub>2) =\n  (wellformed' ?n ?t\\<^sub>1 \\<and> wellformed' ?n ?t\\<^sub>2)\n  wellformed' ?n (Bound ?n') = (?n' < ?n)\n  wellformed' ?n (\\<Lambda> ?t) = wellformed' (?n + 1) ?t\n  wellformed' ?uu (Const ?v) = True\n  wellformed' ?uu (Free ?v) = True\n  \\<lbrakk>length (?x # \\<Gamma>) = length ?\\<Gamma>2.0;\n   distinct (?x # \\<Gamma>); distinct ?\\<Gamma>2.0;\n   wellformed' (length (?x # \\<Gamma>)) t;\n   fBall (frees t |\\<union>| fset_of_list (?x # \\<Gamma>))\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list (?x # \\<Gamma>)) (frees t);\n   fBall (frees t |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv\n                     (fmap_of_list (zip (?x # \\<Gamma>) ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm (?x # \\<Gamma>) t)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t) ?s2.0))\n  length \\<Gamma> = length \\<Gamma>2\n  distinct \\<Gamma>\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>) (\\<Lambda> t)\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t))\n  fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\n\ngoal (1 subgoal):\n 1. wellformed' (Suc (length \\<Gamma>2)) t", "by (metis Suc_eq_plus1)"], ["proof (state)\nthis:\n  wellformed' (Suc (length \\<Gamma>2)) t\n\ngoal (4 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>x \\<Gamma>2 s1 s2.\n                   \\<lbrakk>length (x # \\<Gamma>) = length \\<Gamma>2;\n                    distinct (x # \\<Gamma>); distinct \\<Gamma>2;\n                    wellformed' (length (x # \\<Gamma>)) t;\n                    fBall (frees t |\\<union>| fset_of_list (x # \\<Gamma>))\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list (x # \\<Gamma>)) (frees t);\n                    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2) (frees t)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip (x # \\<Gamma>) \\<Gamma>2))\n(fst (run_state (term_to_nterm (x # \\<Gamma>) t) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t) s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (\\<Lambda> t);\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (\\<Lambda> t));\n        fBall (frees (\\<Lambda> t) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (\\<Lambda> t))\n                                 s2))\n 4. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n     (fst (run_state (term_to_nterm \\<Gamma>2 (\\<Lambda> t)) s2))", "apply (auto simp: split_beta create_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n     (\\<Lambda>\\<^sub>n next\n                         s1. fst (run_state\n                                   (term_to_nterm (next s1 # \\<Gamma>) t)\n                                   (next s1)))\n     (\\<Lambda>\\<^sub>n next\n                         s2. fst (run_state\n                                   (term_to_nterm (next s2 # \\<Gamma>2) t)\n                                   (next s2)))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv\n     (fmupd (next s1) (next s2) (fmap_of_list (zip \\<Gamma> \\<Gamma>2)))\n     (fst (run_state (term_to_nterm (next s1 # \\<Gamma>) t) (next s1)))\n     (fst (run_state (term_to_nterm (next s2 # \\<Gamma>2) t) (next s2)))", "apply (rule abs.IH[of _ \"next s2 # \\<Gamma>2\", simplified])"], ["proof (prove)\ngoal (8 subgoals):\n 1. length \\<Gamma> = length \\<Gamma>2\n 2. next s1 \\<notin> set \\<Gamma> \\<and> distinct \\<Gamma>\n 3. next s2 \\<notin> set \\<Gamma>2 \\<and> distinct \\<Gamma>2\n 4. wellformed' (Suc (length \\<Gamma>2)) t\n 5. next s1 \\<le> next s1 \\<and>\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>)\n     (\\<lambda>y. y \\<le> next s1)\n 6. fdisjnt (finsert (next s1) (fset_of_list \\<Gamma>)) (frees t)\n 7. next s2 \\<le> next s2 \\<and>\n    fBall (frees t |\\<union>| fset_of_list \\<Gamma>2)\n     (\\<lambda>y. y \\<le> next s2)\n 8. fdisjnt (finsert (next s2) (fset_of_list \\<Gamma>2)) (frees t)", "by (fact | rule)+"], ["proof (state)\nthis:\n  alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n   (fst (run_state (term_to_nterm \\<Gamma> (\\<Lambda> t)) s1))\n   (fst (run_state (term_to_nterm \\<Gamma>2 (\\<Lambda> t)) s2))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "case (app \\<Gamma>1 t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>1;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1);\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>1)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>1)\n                            ?s2.0))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>2;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2);\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>2)\n                            ?s2.0))\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (t\\<^sub>1 $ t\\<^sub>2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (t\\<^sub>1 $ t\\<^sub>2))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "hence \"wellformed' (length \\<Gamma>1) t\\<^sub>1\" \"wellformed' (length \\<Gamma>1) t\\<^sub>2\"\n  and \"fresh_fin (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1) s1\" \"fresh_fin (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2) s2\"\n  and \"fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1)\" \"fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>1)\"\n  and \"fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2)\" \"fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>1;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1);\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>1)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>1)\n                            ?s2.0))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>2;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2);\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>2)\n                            ?s2.0))\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (t\\<^sub>1 $ t\\<^sub>2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (t\\<^sub>1 $ t\\<^sub>2))\n\ngoal (1 subgoal):\n 1. ((wellformed' (length \\<Gamma>1) t\\<^sub>1 &&&\n      wellformed' (length \\<Gamma>1) t\\<^sub>2) &&&\n     fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n      (\\<lambda>y. y \\<le> s1) &&&\n     fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n      (\\<lambda>y. y \\<le> s2)) &&&\n    (fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1) &&&\n     fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>1)) &&&\n    fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2) &&&\n    fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)", "using app"], ["proof (prove)\nusing this:\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>1;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1);\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>1)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>1)\n                            ?s2.0))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>2;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2);\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>2)\n                            ?s2.0))\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (t\\<^sub>1 $ t\\<^sub>2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>1;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1);\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>1)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>1)\n                            ?s2.0))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>2;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2);\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>2)\n                            ?s2.0))\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (t\\<^sub>1 $ t\\<^sub>2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (t\\<^sub>1 $ t\\<^sub>2))\n\ngoal (1 subgoal):\n 1. ((wellformed' (length \\<Gamma>1) t\\<^sub>1 &&&\n      wellformed' (length \\<Gamma>1) t\\<^sub>2) &&&\n     fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n      (\\<lambda>y. y \\<le> s1) &&&\n     fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n      (\\<lambda>y. y \\<le> s2)) &&&\n    (fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1) &&&\n     fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>1)) &&&\n    fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2) &&&\n    fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>1;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fset_of_list \\<Gamma>1 |\\<inter>| frees t\\<^sub>1 = {||};\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fset_of_list ?\\<Gamma>2.0 |\\<inter>| frees t\\<^sub>1 = {||}\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>1)\n                            ?s2.0))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>2;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fset_of_list \\<Gamma>1 |\\<inter>| frees t\\<^sub>2 = {||};\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fset_of_list ?\\<Gamma>2.0 |\\<inter>| frees t\\<^sub>2 = {||}\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>2)\n                            ?s2.0))\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (t\\<^sub>1 $ t\\<^sub>2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fset_of_list \\<Gamma>1 |\\<inter>| frees (t\\<^sub>1 $ t\\<^sub>2) = {||}\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fset_of_list \\<Gamma>2 |\\<inter>| frees (t\\<^sub>1 $ t\\<^sub>2) = {||}\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>1;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fset_of_list \\<Gamma>1 |\\<inter>| frees t\\<^sub>1 = {||};\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fset_of_list ?\\<Gamma>2.0 |\\<inter>| frees t\\<^sub>1 = {||}\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>1)\n                            ?s2.0))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>2;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fset_of_list \\<Gamma>1 |\\<inter>| frees t\\<^sub>2 = {||};\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fset_of_list ?\\<Gamma>2.0 |\\<inter>| frees t\\<^sub>2 = {||}\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>2)\n                            ?s2.0))\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (t\\<^sub>1 $ t\\<^sub>2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fset_of_list \\<Gamma>1 |\\<inter>| frees (t\\<^sub>1 $ t\\<^sub>2) = {||}\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fset_of_list \\<Gamma>2 |\\<inter>| frees (t\\<^sub>1 $ t\\<^sub>2) = {||}\n\ngoal (1 subgoal):\n 1. ((wellformed' (length \\<Gamma>1) t\\<^sub>1 &&&\n      wellformed' (length \\<Gamma>1) t\\<^sub>2) &&&\n     fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n      (\\<lambda>y. y \\<le> s1) &&&\n     fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n      (\\<lambda>y. y \\<le> s2)) &&&\n    (fset_of_list \\<Gamma>1 |\\<inter>| frees t\\<^sub>1 = {||} &&&\n     fset_of_list \\<Gamma>2 |\\<inter>| frees t\\<^sub>1 = {||}) &&&\n    fset_of_list \\<Gamma>1 |\\<inter>| frees t\\<^sub>2 = {||} &&&\n    fset_of_list \\<Gamma>2 |\\<inter>| frees t\\<^sub>2 = {||}", "by (auto simp: inf_sup_distrib1)"], ["proof (state)\nthis:\n  wellformed' (length \\<Gamma>1) t\\<^sub>1\n  wellformed' (length \\<Gamma>1) t\\<^sub>2\n  fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "have \"s1 \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1)\" \"s2 \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1) &&&\n    s2 \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)", "using term_to_nterm_mono"], ["proof (prove)\nusing this:\n  mono_state (term_to_nterm ?\\<Gamma> ?x)\n\ngoal (1 subgoal):\n 1. s1 \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1) &&&\n    s2 \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)", "by (simp add: state_io_rel_def)+"], ["proof (state)\nthis:\n  s1 \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1)\n  s2 \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "hence \"fresh_fin (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1) (snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))\""], ["proof (prove)\nusing this:\n  s1 \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1)\n  s2 \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)\n\ngoal (1 subgoal):\n 1. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n     (\\<lambda>y.\n         y \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))", "using \\<open>fresh_fin (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1) s1\\<close>"], ["proof (prove)\nusing this:\n  s1 \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1)\n  s2 \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n\ngoal (1 subgoal):\n 1. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n     (\\<lambda>y.\n         y \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))", "by force"], ["proof (state)\nthis:\n  fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y.\n       y \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "have \"fresh_fin (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2) (snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n     (\\<lambda>y.\n         y \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>|\n       frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2 \\<Longrightarrow>\n       x \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)", "using app frees_term.simps \\<open>s2 \\<le> _\\<close> dual_order.trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>1;\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1);\n   fBall (frees t\\<^sub>1 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>1)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>1)\n                            ?s2.0))\n  \\<lbrakk>length \\<Gamma>1 = length ?\\<Gamma>2.0; distinct \\<Gamma>1;\n   distinct ?\\<Gamma>2.0; wellformed' (length \\<Gamma>1) t\\<^sub>2;\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n    (\\<lambda>y. y \\<le> ?s1.0);\n   fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2);\n   fBall (frees t\\<^sub>2 |\\<union>| fset_of_list ?\\<Gamma>2.0)\n    (\\<lambda>y. y \\<le> ?s2.0);\n   fdisjnt (fset_of_list ?\\<Gamma>2.0) (frees t\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma>1 ?\\<Gamma>2.0))\n                     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n                            ?s1.0))\n                     (fst (run_state (term_to_nterm ?\\<Gamma>2.0 t\\<^sub>2)\n                            ?s2.0))\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  wellformed' (length \\<Gamma>1) (t\\<^sub>1 $ t\\<^sub>2)\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>1)\n   (\\<lambda>y. y \\<le> s1)\n  fdisjnt (fset_of_list \\<Gamma>1) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  fBall (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y. y \\<le> s2)\n  fdisjnt (fset_of_list \\<Gamma>2) (frees (t\\<^sub>1 $ t\\<^sub>2))\n  frees (Free ?x) = {|?x|}\n  frees (?t\\<^sub>1 $ ?t\\<^sub>2) =\n  frees ?t\\<^sub>1 |\\<union>| frees ?t\\<^sub>2\n  frees (\\<Lambda> ?t) = frees ?t\n  frees (Const ?v) = {||}\n  frees (Bound ?v) = {||}\n  s2 \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x |\\<in>|\n       frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2 \\<Longrightarrow>\n       x \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2)", "by (metis fbspec funion_iff)"], ["proof (state)\nthis:\n  fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n   (\\<lambda>y.\n       y \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))\n\ngoal (3 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))\n 3. \\<And>\\<Gamma> t\\<^sub>1 t\\<^sub>2 \\<Gamma>2 s1 s2.\n       \\<lbrakk>\\<And>\\<Gamma>2 s1 s2.\n                   \\<lbrakk>length \\<Gamma> = length \\<Gamma>2;\n                    distinct \\<Gamma>; distinct \\<Gamma>2;\n                    wellformed' (length \\<Gamma>) t\\<^sub>1;\n                    fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>)\n                     (\\<lambda>y. y \\<le> s1);\n                    fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>1);\n                    fBall\n                     (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n                     (\\<lambda>y. y \\<le> s2);\n                    fdisjnt (fset_of_list \\<Gamma>2)\n                     (frees t\\<^sub>1)\\<rbrakk>\n                   \\<Longrightarrow> alpha_equiv\n(fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n(fst (run_state (term_to_nterm \\<Gamma> t\\<^sub>1) s1))\n(fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2));\n        \\<And>x \\<Gamma>2 s1 s2.\n           \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n            distinct \\<Gamma>2; wellformed' (length \\<Gamma>) t\\<^sub>2;\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>)\n             (\\<lambda>y. y \\<le> s1);\n            fdisjnt (fset_of_list \\<Gamma>) (frees t\\<^sub>2);\n            fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n             (\\<lambda>y. y \\<le> s2);\n            fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)\\<rbrakk>\n           \\<Longrightarrow> alpha_equiv\n                              (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma> t\\<^sub>2) s1))\n                              (fst (run_state\n                                     (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n                                     s2));\n        length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2;\n        wellformed' (length \\<Gamma>) (t\\<^sub>1 $ t\\<^sub>2);\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (t\\<^sub>1 $ t\\<^sub>2));\n        fBall\n         (frees (t\\<^sub>1 $ t\\<^sub>2) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2)\n         (frees (t\\<^sub>1 $ t\\<^sub>2))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2\n                                   (t\\<^sub>1 $ t\\<^sub>2))\n                                 s2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 (t\\<^sub>1 $ t\\<^sub>2)) s1))\n     (fst (run_state (term_to_nterm \\<Gamma>2 (t\\<^sub>1 $ t\\<^sub>2)) s2))", "apply (auto simp: split_beta create_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1) $\\<^sub>n\n      fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2) $\\<^sub>n\n      fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))))", "apply (rule alpha_equiv.app)"], ["proof (prove)\ngoal (2 subgoals):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))\n 2. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))", "apply (rule app)"], ["proof (prove)\ngoal (8 subgoals):\n 1. length \\<Gamma>1 = length \\<Gamma>2\n 2. distinct \\<Gamma>1\n 3. distinct \\<Gamma>2\n 4. wellformed' (length \\<Gamma>1) t\\<^sub>1\n 5. fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>1)\n     (\\<lambda>y. y \\<le> s1)\n 6. fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>1)\n 7. fBall (frees t\\<^sub>1 |\\<union>| fset_of_list \\<Gamma>2)\n     (\\<lambda>y. y \\<le> s2)\n 8. fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>1)", "apply (simp | fact)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>2)\n            (snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))))", "apply (rule app)"], ["proof (prove)\ngoal (8 subgoals):\n 1. length \\<Gamma>1 = length \\<Gamma>2\n 2. distinct \\<Gamma>1\n 3. distinct \\<Gamma>2\n 4. wellformed' (length \\<Gamma>1) t\\<^sub>2\n 5. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>1)\n     (\\<lambda>y.\n         y \\<le> snd (run_state (term_to_nterm \\<Gamma>1 t\\<^sub>1) s1))\n 6. fdisjnt (fset_of_list \\<Gamma>1) (frees t\\<^sub>2)\n 7. fBall (frees t\\<^sub>2 |\\<union>| fset_of_list \\<Gamma>2)\n     (\\<lambda>y.\n         y \\<le> snd (run_state (term_to_nterm \\<Gamma>2 t\\<^sub>1) s2))\n 8. fdisjnt (fset_of_list \\<Gamma>2) (frees t\\<^sub>2)", "apply (simp | fact)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n   (fst (run_state (term_to_nterm \\<Gamma>1 (t\\<^sub>1 $ t\\<^sub>2)) s1))\n   (fst (run_state (term_to_nterm \\<Gamma>2 (t\\<^sub>1 $ t\\<^sub>2)) s2))\n\ngoal (2 subgoals):\n 1. \\<And>uu_ name \\<Gamma>2 s1 s2.\n       \\<lbrakk>length uu_ = length \\<Gamma>2; distinct uu_;\n        distinct \\<Gamma>2; wellformed' (length uu_) (Const name);\n        fBall (frees (Const name) |\\<union>| fset_of_list uu_)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list uu_) (frees (Const name));\n        fBall (frees (Const name) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Const name))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip uu_ \\<Gamma>2))\n                          (fst (run_state (term_to_nterm uu_ (Const name))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Const name)) s2))\n 2. \\<And>\\<Gamma> n \\<Gamma>2 s1 s2.\n       \\<lbrakk>length \\<Gamma> = length \\<Gamma>2; distinct \\<Gamma>;\n        distinct \\<Gamma>2; wellformed' (length \\<Gamma>) (Bound n);\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>)\n         (\\<lambda>y. y \\<le> s1);\n        fdisjnt (fset_of_list \\<Gamma>) (frees (Bound n));\n        fBall (frees (Bound n) |\\<union>| fset_of_list \\<Gamma>2)\n         (\\<lambda>y. y \\<le> s2);\n        fdisjnt (fset_of_list \\<Gamma>2) (frees (Bound n))\\<rbrakk>\n       \\<Longrightarrow> alpha_equiv (fmap_of_list (zip \\<Gamma> \\<Gamma>2))\n                          (fst (run_state (term_to_nterm \\<Gamma> (Bound n))\n                                 s1))\n                          (fst (run_state\n                                 (term_to_nterm \\<Gamma>2 (Bound n)) s2))", "qed (force intro: alpha_equiv.intros simp: fmlookup_of_list in_set_zip)+"], ["", "lemma term_to_nterm_alpha_equiv:\n  assumes \"length \\<Gamma>1 = length \\<Gamma>2\" \"distinct \\<Gamma>1\" \"distinct \\<Gamma>2\" \"closed t\"\n  assumes \"wellformed' (length \\<Gamma>1) t\"\n  assumes \"fresh_fin (fset_of_list \\<Gamma>1) s1\" \"fresh_fin (fset_of_list \\<Gamma>2) s2\"\n  shows \"alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2)) (fst (run_state (term_to_nterm \\<Gamma>1 t) s1)) (fst (run_state (term_to_nterm \\<Gamma>2 t) s2))\"\n  \\<comment> \\<open>An instantiated version of this lemma with @{prop \\<open>\\<Gamma>1 = []\\<close>} and @{prop \\<open>\\<Gamma>2 = []\\<close>}\n      would not make sense because then it would just be a special case of\n      @{thm [source=true] alpha_eq_refl}.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t) s1))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t) s2))", "using assms"], ["proof (prove)\nusing this:\n  length \\<Gamma>1 = length \\<Gamma>2\n  distinct \\<Gamma>1\n  distinct \\<Gamma>2\n  closed t\n  wellformed' (length \\<Gamma>1) t\n  fBall (fset_of_list \\<Gamma>1) (\\<lambda>y. y \\<le> s1)\n  fBall (fset_of_list \\<Gamma>2) (\\<lambda>y. y \\<le> s2)\n\ngoal (1 subgoal):\n 1. alpha_equiv (fmap_of_list (zip \\<Gamma>1 \\<Gamma>2))\n     (fst (run_state (term_to_nterm \\<Gamma>1 t) s1))\n     (fst (run_state (term_to_nterm \\<Gamma>2 t) s2))", "by (simp add: fdisjnt_alt_def closed_except_def term_to_nterm_alpha_equiv0)"], ["", "end"], ["", "global_interpretation nrelated: term_struct_rel_strong \"(\\<lambda>t n. t = nterm_to_term \\<Gamma> n)\" for \\<Gamma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. term_struct_rel_strong (\\<lambda>t n. t = nterm_to_term \\<Gamma> n)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>t name.\n       t = nterm_to_term \\<Gamma> (const name) \\<Longrightarrow>\n       t = const name\n 2. \\<And>name. const name = nterm_to_term \\<Gamma> (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t =\n       nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1 \\<and>\n          t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1;\n        t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>name t.\n       const name = nterm_to_term \\<Gamma> t \\<Longrightarrow>\n       t = const name\n 6. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>1 \\<and>\n          u\\<^sub>2 = nterm_to_term \\<Gamma> t\\<^sub>2", "case (5 name t)"], ["proof (state)\nthis:\n  const name = nterm_to_term \\<Gamma> t\n\ngoal (6 subgoals):\n 1. \\<And>t name.\n       t = nterm_to_term \\<Gamma> (const name) \\<Longrightarrow>\n       t = const name\n 2. \\<And>name. const name = nterm_to_term \\<Gamma> (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t =\n       nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1 \\<and>\n          t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1;\n        t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>name t.\n       const name = nterm_to_term \\<Gamma> t \\<Longrightarrow>\n       t = const name\n 6. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>1 \\<and>\n          u\\<^sub>2 = nterm_to_term \\<Gamma> t\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  const name = nterm_to_term \\<Gamma> t", "show ?case"], ["proof (prove)\nusing this:\n  const name = nterm_to_term \\<Gamma> t\n\ngoal (1 subgoal):\n 1. t = const name", "by (cases t) (auto simp: const_term_def const_nterm_def split: option.splits)"], ["proof (state)\nthis:\n  t = const name\n\ngoal (5 subgoals):\n 1. \\<And>t name.\n       t = nterm_to_term \\<Gamma> (const name) \\<Longrightarrow>\n       t = const name\n 2. \\<And>name. const name = nterm_to_term \\<Gamma> (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t =\n       nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1 \\<and>\n          t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1;\n        t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>1 \\<and>\n          u\\<^sub>2 = nterm_to_term \\<Gamma> t\\<^sub>2", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t name.\n       t = nterm_to_term \\<Gamma> (const name) \\<Longrightarrow>\n       t = const name\n 2. \\<And>name. const name = nterm_to_term \\<Gamma> (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t =\n       nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1 \\<and>\n          t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1;\n        t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>1 \\<and>\n          u\\<^sub>2 = nterm_to_term \\<Gamma> t\\<^sub>2", "case (6 u\\<^sub>1 u\\<^sub>2 t)"], ["proof (state)\nthis:\n  app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t\n\ngoal (5 subgoals):\n 1. \\<And>t name.\n       t = nterm_to_term \\<Gamma> (const name) \\<Longrightarrow>\n       t = const name\n 2. \\<And>name. const name = nterm_to_term \\<Gamma> (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t =\n       nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1 \\<and>\n          t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1;\n        t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2)\n 5. \\<And>u\\<^sub>1 u\\<^sub>2 t.\n       app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          u\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>1 \\<and>\n          u\\<^sub>2 = nterm_to_term \\<Gamma> t\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t", "show ?case"], ["proof (prove)\nusing this:\n  app u\\<^sub>1 u\\<^sub>2 = nterm_to_term \\<Gamma> t\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<^sub>1 t\\<^sub>2.\n       t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n       u\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>1 \\<and>\n       u\\<^sub>2 = nterm_to_term \\<Gamma> t\\<^sub>2", "by (cases t) (auto simp: app_term_def app_nterm_def split: option.splits)"], ["proof (state)\nthis:\n  \\<exists>t\\<^sub>1 t\\<^sub>2.\n     t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n     u\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>1 \\<and>\n     u\\<^sub>2 = nterm_to_term \\<Gamma> t\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>t name.\n       t = nterm_to_term \\<Gamma> (const name) \\<Longrightarrow>\n       t = const name\n 2. \\<And>name. const name = nterm_to_term \\<Gamma> (const name)\n 3. \\<And>t u\\<^sub>1 u\\<^sub>2.\n       t =\n       nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2) \\<Longrightarrow>\n       \\<exists>t\\<^sub>1 t\\<^sub>2.\n          t = app t\\<^sub>1 t\\<^sub>2 \\<and>\n          t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1 \\<and>\n          t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\n 4. \\<And>t\\<^sub>1 u\\<^sub>1 t\\<^sub>2 u\\<^sub>2.\n       \\<lbrakk>t\\<^sub>1 = nterm_to_term \\<Gamma> u\\<^sub>1;\n        t\\<^sub>2 = nterm_to_term \\<Gamma> u\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> app t\\<^sub>1 t\\<^sub>2 =\n                         nterm_to_term \\<Gamma> (app u\\<^sub>1 u\\<^sub>2)", "qed (auto simp: const_term_def const_nterm_def app_term_def app_nterm_def)"], ["", "lemma env_nrelated_closed:\n  assumes \"nrelated.P_env \\<Gamma> env nenv\" \"closed_env nenv\"\n  shows \"nrelated.P_env \\<Gamma>' env nenv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nrelated.P_env \\<Gamma>' env nenv", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma>' n)\n        (fmlookup env x) (fmlookup nenv x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma>' n)\n        (fmlookup env x) (fmlookup nenv x)", "from assms"], ["proof (chain)\npicking this:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv", "have \"rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma> n) (fmlookup env x) (fmlookup nenv x)\""], ["proof (prove)\nusing this:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma> n) (fmlookup env x)\n     (fmlookup nenv x)", "by auto"], ["proof (state)\nthis:\n  rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma> n) (fmlookup env x)\n   (fmlookup nenv x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma>' n)\n        (fmlookup env x) (fmlookup nenv x)", "thus \"rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma>' n) (fmlookup env x) (fmlookup nenv x)\""], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma> n) (fmlookup env x)\n   (fmlookup nenv x)\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma>' n)\n     (fmlookup env x) (fmlookup nenv x)", "using assms"], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma> n) (fmlookup env x)\n   (fmlookup nenv x)\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma>' n)\n     (fmlookup env x) (fmlookup nenv x)", "by (cases rule: option.rel_cases) (auto dest: fmdomI simp: nterm_to_term_eq_closed)"], ["proof (state)\nthis:\n  rel_option (\\<lambda>t n. t = nterm_to_term \\<Gamma>' n) (fmlookup env x)\n   (fmlookup nenv x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nrelated_subst:\n  assumes \"nrelated.P_env \\<Gamma> env nenv\" \"closed_env nenv\" \"fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\"\n  shows \"subst (nterm_to_term \\<Gamma> t) env = nterm_to_term \\<Gamma> (subst t nenv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (nterm_to_term \\<Gamma> t) env =\n    nterm_to_term \\<Gamma> (subst t nenv)", "using assms"], ["proof (prove)\nusing this:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\n\ngoal (1 subgoal):\n 1. subst (nterm_to_term \\<Gamma> t) env =\n    nterm_to_term \\<Gamma> (subst t nenv)", "proof (induction t arbitrary: \\<Gamma> env nenv)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nconst x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nconst x) nenv)\n 2. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nvar x) nenv)\n 3. \\<And>x1a t \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t) env =\n                                     nterm_to_term \\<Gamma> (subst t nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (\\<Lambda>\\<^sub>n x1a. t) nenv)\n 4. \\<And>t1 t2 \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t1) env =\n                                     nterm_to_term \\<Gamma> (subst t1 nenv);\n        \\<And>\\<Gamma> env nenv.\n           \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n            fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n           \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t2) env =\n                             nterm_to_term \\<Gamma> (subst t2 nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (t1 $\\<^sub>n t2) nenv)", "case (Nvar name)"], ["proof (state)\nthis:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nconst x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nconst x) nenv)\n 2. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nvar x) nenv)\n 3. \\<And>x1a t \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t) env =\n                                     nterm_to_term \\<Gamma> (subst t nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (\\<Lambda>\\<^sub>n x1a. t) nenv)\n 4. \\<And>t1 t2 \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t1) env =\n                                     nterm_to_term \\<Gamma> (subst t1 nenv);\n        \\<And>\\<Gamma> env nenv.\n           \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n            fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n           \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t2) env =\n                             nterm_to_term \\<Gamma> (subst t2 nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (t1 $\\<^sub>n t2) nenv)", "thus ?case"], ["proof (prove)\nusing this:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\n\ngoal (1 subgoal):\n 1. subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n    nterm_to_term \\<Gamma> (subst (Nvar name) nenv)", "proof (cases rule: fmrel_cases[where x = name])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>closed_env nenv; fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n     fmlookup env name = None; fmlookup nenv name = None\\<rbrakk>\n    \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                      nterm_to_term \\<Gamma> (subst (Nvar name) nenv)\n 2. \\<And>a b.\n       \\<lbrakk>closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n        fmlookup env name = Some a; fmlookup nenv name = Some b;\n        a = nterm_to_term \\<Gamma> b\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                         nterm_to_term \\<Gamma> (subst (Nvar name) nenv)", "case (some t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  fmlookup env name = Some t\\<^sub>1\n  fmlookup nenv name = Some t\\<^sub>2\n  t\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>closed_env nenv; fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n     fmlookup env name = None; fmlookup nenv name = None\\<rbrakk>\n    \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                      nterm_to_term \\<Gamma> (subst (Nvar name) nenv)\n 2. \\<And>a b.\n       \\<lbrakk>closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n        fmlookup env name = Some a; fmlookup nenv name = Some b;\n        a = nterm_to_term \\<Gamma> b\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                         nterm_to_term \\<Gamma> (subst (Nvar name) nenv)", "with Nvar"], ["proof (chain)\npicking this:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\n  fmlookup env name = Some t\\<^sub>1\n  fmlookup nenv name = Some t\\<^sub>2\n  t\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>2", "have \"name |\\<notin>| fset_of_list \\<Gamma>\""], ["proof (prove)\nusing this:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\n  fmlookup env name = Some t\\<^sub>1\n  fmlookup nenv name = Some t\\<^sub>2\n  t\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fset_of_list \\<Gamma>", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fset_of_list \\<Gamma> |\\<inter>| fmdom nenv = {||}\n  fmlookup env name = Some t\\<^sub>1\n  fmlookup nenv name = Some t\\<^sub>2\n  t\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>2\n\ngoal (1 subgoal):\n 1. name |\\<notin>| fset_of_list \\<Gamma>", "by (auto dest: fmdomI)"], ["proof (state)\nthis:\n  name |\\<notin>| fset_of_list \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>closed_env nenv; fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n     fmlookup env name = None; fmlookup nenv name = None\\<rbrakk>\n    \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                      nterm_to_term \\<Gamma> (subst (Nvar name) nenv)\n 2. \\<And>a b.\n       \\<lbrakk>closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n        fmlookup env name = Some a; fmlookup nenv name = Some b;\n        a = nterm_to_term \\<Gamma> b\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                         nterm_to_term \\<Gamma> (subst (Nvar name) nenv)", "hence \"find_first name \\<Gamma> = None\""], ["proof (prove)\nusing this:\n  name |\\<notin>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. find_first name \\<Gamma> = None", "including fset.lifting"], ["proof (prove)\nusing this:\n  name |\\<notin>| fset_of_list \\<Gamma>\n\ngoal (1 subgoal):\n 1. find_first name \\<Gamma> = None", "by transfer' (simp add: find_first_none)"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>closed_env nenv; fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n     fmlookup env name = None; fmlookup nenv name = None\\<rbrakk>\n    \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                      nterm_to_term \\<Gamma> (subst (Nvar name) nenv)\n 2. \\<And>a b.\n       \\<lbrakk>closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n        fmlookup env name = Some a; fmlookup nenv name = Some b;\n        a = nterm_to_term \\<Gamma> b\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                         nterm_to_term \\<Gamma> (subst (Nvar name) nenv)", "with some"], ["proof (chain)\npicking this:\n  fmlookup env name = Some t\\<^sub>1\n  fmlookup nenv name = Some t\\<^sub>2\n  t\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>2\n  find_first name \\<Gamma> = None", "show ?thesis"], ["proof (prove)\nusing this:\n  fmlookup env name = Some t\\<^sub>1\n  fmlookup nenv name = Some t\\<^sub>2\n  t\\<^sub>1 = nterm_to_term \\<Gamma> t\\<^sub>2\n  find_first name \\<Gamma> = None\n\ngoal (1 subgoal):\n 1. subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n    nterm_to_term \\<Gamma> (subst (Nvar name) nenv)", "by auto"], ["proof (state)\nthis:\n  subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n  nterm_to_term \\<Gamma> (subst (Nvar name) nenv)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_env nenv; fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv);\n     fmlookup env name = None; fmlookup nenv name = None\\<rbrakk>\n    \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n                      nterm_to_term \\<Gamma> (subst (Nvar name) nenv)", "qed (auto split: option.splits)"], ["proof (state)\nthis:\n  subst (nterm_to_term \\<Gamma> (Nvar name)) env =\n  nterm_to_term \\<Gamma> (subst (Nvar name) nenv)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nconst x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nconst x) nenv)\n 2. \\<And>x1a t \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t) env =\n                                     nterm_to_term \\<Gamma> (subst t nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (\\<Lambda>\\<^sub>n x1a. t) nenv)\n 3. \\<And>t1 t2 \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t1) env =\n                                     nterm_to_term \\<Gamma> (subst t1 nenv);\n        \\<And>\\<Gamma> env nenv.\n           \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n            fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n           \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t2) env =\n                             nterm_to_term \\<Gamma> (subst t2 nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (t1 $\\<^sub>n t2) nenv)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nconst x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nconst x) nenv)\n 2. \\<And>x1a t \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t) env =\n                                     nterm_to_term \\<Gamma> (subst t nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (\\<Lambda>\\<^sub>n x1a. t) nenv)\n 3. \\<And>t1 t2 \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t1) env =\n                                     nterm_to_term \\<Gamma> (subst t1 nenv);\n        \\<And>\\<Gamma> env nenv.\n           \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n            fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n           \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t2) env =\n                             nterm_to_term \\<Gamma> (subst t2 nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (t1 $\\<^sub>n t2) nenv)", "case (Nabs x t)"], ["proof (state)\nthis:\n  \\<lbrakk>nrelated.P_env ?\\<Gamma> ?env ?nenv; closed_env ?nenv;\n   fdisjnt (fset_of_list ?\\<Gamma>) (fmdom ?nenv)\\<rbrakk>\n  \\<Longrightarrow> subst (nterm_to_term ?\\<Gamma> t) ?env =\n                    nterm_to_term ?\\<Gamma> (subst t ?nenv)\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nconst x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nconst x) nenv)\n 2. \\<And>x1a t \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t) env =\n                                     nterm_to_term \\<Gamma> (subst t nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (\\<Lambda>\\<^sub>n x1a. t) nenv)\n 3. \\<And>t1 t2 \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t1) env =\n                                     nterm_to_term \\<Gamma> (subst t1 nenv);\n        \\<And>\\<Gamma> env nenv.\n           \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n            fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n           \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t2) env =\n                             nterm_to_term \\<Gamma> (subst t2 nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (t1 $\\<^sub>n t2) nenv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) env =\n    nterm_to_term \\<Gamma> (subst (\\<Lambda>\\<^sub>n x. t) nenv)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (nterm_to_term (x # \\<Gamma>) t) env =\n    nterm_to_term (x # \\<Gamma>) (subst t (fmdrop x nenv))", "apply (subst subst_drop[symmetric, where x = x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x |\\<notin>| frees (nterm_to_term (x # \\<Gamma>) t)\n 2. subst (nterm_to_term (x # \\<Gamma>) t) (fmdrop x env) =\n    nterm_to_term (x # \\<Gamma>) (subst t (fmdrop x nenv))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x |\\<notin>| frees (nterm_to_term (x # \\<Gamma>) t)", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (nterm_to_term (x # \\<Gamma>) t) (fmdrop x env) =\n    nterm_to_term (x # \\<Gamma>) (subst t (fmdrop x nenv))", "apply (rule Nabs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. nrelated.P_env (x # \\<Gamma>) (fmdrop x env) (fmdrop x nenv)\n 2. closed_env (fmdrop x nenv)\n 3. fdisjnt (fset_of_list (x # \\<Gamma>)) (fmdom (fmdrop x nenv))", "using Nabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>nrelated.P_env ?\\<Gamma> ?env ?nenv; closed_env ?nenv;\n   fdisjnt (fset_of_list ?\\<Gamma>) (fmdom ?nenv)\\<rbrakk>\n  \\<Longrightarrow> subst (nterm_to_term ?\\<Gamma> t) ?env =\n                    nterm_to_term ?\\<Gamma> (subst t ?nenv)\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\n\ngoal (3 subgoals):\n 1. nrelated.P_env (x # \\<Gamma>) (fmdrop x env) (fmdrop x nenv)\n 2. closed_env (fmdrop x nenv)\n 3. fdisjnt (fset_of_list (x # \\<Gamma>)) (fmdom (fmdrop x nenv))", "unfolding fdisjnt_alt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>nrelated.P_env ?\\<Gamma> ?env ?nenv; closed_env ?nenv;\n   fset_of_list ?\\<Gamma> |\\<inter>| fmdom ?nenv = {||}\\<rbrakk>\n  \\<Longrightarrow> subst (nterm_to_term ?\\<Gamma> t) ?env =\n                    nterm_to_term ?\\<Gamma> (subst t ?nenv)\n  nrelated.P_env \\<Gamma> env nenv\n  closed_env nenv\n  fset_of_list \\<Gamma> |\\<inter>| fmdom nenv = {||}\n\ngoal (3 subgoals):\n 1. nrelated.P_env (x # \\<Gamma>) (fmdrop x env) (fmdrop x nenv)\n 2. closed_env (fmdrop x nenv)\n 3. fset_of_list (x # \\<Gamma>) |\\<inter>| fmdom (fmdrop x nenv) = {||}", "by (auto intro: env_nrelated_closed)"], ["proof (state)\nthis:\n  subst (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) env =\n  nterm_to_term \\<Gamma> (subst (\\<Lambda>\\<^sub>n x. t) nenv)\n\ngoal (2 subgoals):\n 1. \\<And>x \\<Gamma> env nenv.\n       \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (Nconst x)) env =\n                         nterm_to_term \\<Gamma> (subst (Nconst x) nenv)\n 2. \\<And>t1 t2 \\<Gamma> env nenv.\n       \\<lbrakk>\\<And>\\<Gamma> env nenv.\n                   \\<lbrakk>nrelated.P_env \\<Gamma> env nenv;\n                    closed_env nenv;\n                    fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n                   \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t1) env =\n                                     nterm_to_term \\<Gamma> (subst t1 nenv);\n        \\<And>\\<Gamma> env nenv.\n           \\<lbrakk>nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n            fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n           \\<Longrightarrow> subst (nterm_to_term \\<Gamma> t2) env =\n                             nterm_to_term \\<Gamma> (subst t2 nenv);\n        nrelated.P_env \\<Gamma> env nenv; closed_env nenv;\n        fdisjnt (fset_of_list \\<Gamma>) (fmdom nenv)\\<rbrakk>\n       \\<Longrightarrow> subst (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))\n                          env =\n                         nterm_to_term \\<Gamma>\n                          (subst (t1 $\\<^sub>n t2) nenv)", "qed auto"], ["", "lemma nterm_to_term_insert_dupl:\n  assumes \"y \\<in> set (take n \\<Gamma>)\" \"n \\<le> length \\<Gamma>\"\n  shows \"nterm_to_term \\<Gamma> t = incr_bounds (- 1) (Suc n) (nterm_to_term (insert_nth n y \\<Gamma>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> t =\n    incr_bounds (- 1) (Suc n) (nterm_to_term (insert_nth n y \\<Gamma>) t)", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> set (take n \\<Gamma>)\n  n \\<le> length \\<Gamma>\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> t =\n    incr_bounds (- 1) (Suc n) (nterm_to_term (insert_nth n y \\<Gamma>) t)", "proof (induction t arbitrary: n \\<Gamma>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nconst x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (Nconst x))\n 2. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nvar x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar x))\n 3. \\<And>x1a t n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 4. \\<And>t1 t2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t1 =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t1);\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n            n \\<le> length \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> t2 =\n                             incr_bounds (- 1) (Suc n)\n                              (nterm_to_term (insert_nth n y \\<Gamma>) t2);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (t1 $\\<^sub>n t2))", "case (Nvar name)"], ["proof (state)\nthis:\n  y \\<in> set (take n \\<Gamma>)\n  n \\<le> length \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nconst x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (Nconst x))\n 2. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nvar x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar x))\n 3. \\<And>x1a t n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 4. \\<And>t1 t2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t1 =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t1);\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n            n \\<le> length \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> t2 =\n                             incr_bounds (- 1) (Suc n)\n                              (nterm_to_term (insert_nth n y \\<Gamma>) t2);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (t1 $\\<^sub>n t2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "proof (cases \"y = name\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))\n 2. y \\<noteq> name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "case True"], ["proof (state)\nthis:\n  y = name\n\ngoal (2 subgoals):\n 1. y = name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))\n 2. y \\<noteq> name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "with Nvar"], ["proof (chain)\npicking this:\n  y \\<in> set (take n \\<Gamma>)\n  n \\<le> length \\<Gamma>\n  y = name", "obtain i where \"find_first name \\<Gamma> = Some i\" \"i < n\""], ["proof (prove)\nusing this:\n  y \\<in> set (take n \\<Gamma>)\n  n \\<le> length \\<Gamma>\n  y = name\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>find_first name \\<Gamma> = Some i; i < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: find_first_some_strong)"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = Some i\n  i < n\n\ngoal (2 subgoals):\n 1. y = name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))\n 2. y \\<noteq> name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "hence \"find_first name (take n \\<Gamma>) = Some i\""], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = Some i\n  i < n\n\ngoal (1 subgoal):\n 1. find_first name (take n \\<Gamma>) = Some i", "by (rule find_first_prefix)"], ["proof (state)\nthis:\n  find_first name (take n \\<Gamma>) = Some i\n\ngoal (2 subgoals):\n 1. y = name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))\n 2. y \\<noteq> name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case find_first name \\<Gamma> of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    incr_bounds (- 1) (Suc n)\n     (case find_first name (take n \\<Gamma> @ y # drop n \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "apply (subst \\<open>find_first name \\<Gamma> = Some i\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Some i of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    incr_bounds (- 1) (Suc n)\n     (case find_first name (take n \\<Gamma> @ y # drop n \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bound i =\n    incr_bounds (- 1) (Suc n)\n     (case find_first name (take n \\<Gamma> @ y # drop n \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "apply (subst find_first_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bound i =\n    incr_bounds (- 1) (Suc n)\n     (case case find_first name (take n \\<Gamma>) of\n           None \\<Rightarrow>\n             map_option (\\<lambda>i. i + length (take n \\<Gamma>))\n              (find_first name (y # drop n \\<Gamma>))\n           | Some x \\<Rightarrow> Some x of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "apply (subst \\<open>find_first name (take n \\<Gamma>) = Some i\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bound i =\n    incr_bounds (- 1) (Suc n)\n     (case case Some i of\n           None \\<Rightarrow>\n             map_option (\\<lambda>i. i + length (take n \\<Gamma>))\n              (find_first name (y # drop n \\<Gamma>))\n           | Some x \\<Rightarrow> Some x of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n \\<le> i \\<longrightarrow> i = i - Suc 0", "using \\<open>i < n\\<close>"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. Suc n \\<le> i \\<longrightarrow> i = i - Suc 0", "by simp"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (Nvar name) =\n  incr_bounds (- 1) (Suc n)\n   (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))\n\ngoal (1 subgoal):\n 1. y \\<noteq> name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "case False"], ["proof (state)\nthis:\n  y \\<noteq> name\n\ngoal (1 subgoal):\n 1. y \\<noteq> name \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (Nvar name) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))", "apply (simp del: insert_nth_take_drop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case find_first name \\<Gamma> of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    incr_bounds (- 1) (Suc n)\n     (case find_first name (insert_nth n y \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "apply (subst find_first_insert_nth_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. name \\<noteq> y\n 2. (case find_first name \\<Gamma> of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    incr_bounds (- 1) (Suc n)\n     (case map_option (\\<lambda>i. if i < n then i else Suc i)\n            (find_first name \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. name \\<noteq> y", "using False"], ["proof (prove)\nusing this:\n  y \\<noteq> name\n\ngoal (1 subgoal):\n 1. name \\<noteq> y", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case find_first name \\<Gamma> of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    incr_bounds (- 1) (Suc n)\n     (case map_option (\\<lambda>i. if i < n then i else Suc i)\n            (find_first name \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)", "by (cases \"find_first name \\<Gamma>\") auto"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (Nvar name) =\n  incr_bounds (- 1) (Suc n)\n   (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (Nvar name) =\n  incr_bounds (- 1) (Suc n)\n   (nterm_to_term (insert_nth n y \\<Gamma>) (Nvar name))\n\ngoal (3 subgoals):\n 1. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nconst x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (Nconst x))\n 2. \\<And>x1a t n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 3. \\<And>t1 t2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t1 =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t1);\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n            n \\<le> length \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> t2 =\n                             incr_bounds (- 1) (Suc n)\n                              (nterm_to_term (insert_nth n y \\<Gamma>) t2);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (t1 $\\<^sub>n t2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nconst x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (Nconst x))\n 2. \\<And>x1a t n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 3. \\<And>t1 t2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t1 =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t1);\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n            n \\<le> length \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> t2 =\n                             incr_bounds (- 1) (Suc n)\n                              (nterm_to_term (insert_nth n y \\<Gamma>) t2);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (t1 $\\<^sub>n t2))", "case (Nabs x t)"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<in> set (take ?n ?\\<Gamma>);\n   ?n \\<le> length ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> t =\n                    incr_bounds (- 1) (Suc ?n)\n                     (nterm_to_term (insert_nth ?n y ?\\<Gamma>) t)\n  y \\<in> set (take n \\<Gamma>)\n  n \\<le> length \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nconst x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (Nconst x))\n 2. \\<And>x1a t n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x1a. t) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 3. \\<And>t1 t2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t1 =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t1);\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n            n \\<le> length \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> t2 =\n                             incr_bounds (- 1) (Suc n)\n                              (nterm_to_term (insert_nth n y \\<Gamma>) t2);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (t1 $\\<^sub>n t2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t) =\n    incr_bounds (- 1) (Suc n)\n     (nterm_to_term (insert_nth n y \\<Gamma>) (\\<Lambda>\\<^sub>n x. t))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term (x # \\<Gamma>) t =\n    incr_bounds (- 1) (Suc (Suc n))\n     (nterm_to_term (x # take n \\<Gamma> @ y # drop n \\<Gamma>) t)", "apply (subst Nabs(1)[where n = \"Suc n\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> set (take (Suc n) (x # \\<Gamma>))\n 2. Suc n \\<le> length (x # \\<Gamma>)\n 3. incr_bounds (- 1) (Suc (Suc n))\n     (nterm_to_term (insert_nth (Suc n) y (x # \\<Gamma>)) t) =\n    incr_bounds (- 1) (Suc (Suc n))\n     (nterm_to_term (x # take n \\<Gamma> @ y # drop n \\<Gamma>) t)", "using Nabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<in> set (take ?n ?\\<Gamma>);\n   ?n \\<le> length ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> t =\n                    incr_bounds (- 1) (Suc ?n)\n                     (nterm_to_term (insert_nth ?n y ?\\<Gamma>) t)\n  y \\<in> set (take n \\<Gamma>)\n  n \\<le> length \\<Gamma>\n\ngoal (3 subgoals):\n 1. y \\<in> set (take (Suc n) (x # \\<Gamma>))\n 2. Suc n \\<le> length (x # \\<Gamma>)\n 3. incr_bounds (- 1) (Suc (Suc n))\n     (nterm_to_term (insert_nth (Suc n) y (x # \\<Gamma>)) t) =\n    incr_bounds (- 1) (Suc (Suc n))\n     (nterm_to_term (x # take n \\<Gamma> @ y # drop n \\<Gamma>) t)", "by auto"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t) =\n  incr_bounds (- 1) (Suc n)\n   (nterm_to_term (insert_nth n y \\<Gamma>) (\\<Lambda>\\<^sub>n x. t))\n\ngoal (2 subgoals):\n 1. \\<And>x n \\<Gamma>.\n       \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n        n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (Nconst x) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (Nconst x))\n 2. \\<And>t1 t2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n                    n \\<le> length \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma> t1 =\n                                     incr_bounds (- 1) (Suc n)\n(nterm_to_term (insert_nth n y \\<Gamma>) t1);\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>y \\<in> set (take n \\<Gamma>);\n            n \\<le> length \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> t2 =\n                             incr_bounds (- 1) (Suc n)\n                              (nterm_to_term (insert_nth n y \\<Gamma>) t2);\n        y \\<in> set (take n \\<Gamma>); n \\<le> length \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2) =\n                         incr_bounds (- 1) (Suc n)\n                          (nterm_to_term (insert_nth n y \\<Gamma>)\n                            (t1 $\\<^sub>n t2))", "qed auto"], ["", "lemma nterm_to_term_bounds_dupl:\n  assumes \"i < length \\<Gamma>\" \"j < length \\<Gamma>\" \"i < j\"\n  assumes \"\\<Gamma> ! i = \\<Gamma> ! j\"\n  shows \"j |\\<notin>| bounds (nterm_to_term \\<Gamma> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j |\\<notin>| bounds (nterm_to_term \\<Gamma> t)", "using assms"], ["proof (prove)\nusing this:\n  i < length \\<Gamma>\n  j < length \\<Gamma>\n  i < j\n  \\<Gamma> ! i = \\<Gamma> ! j\n\ngoal (1 subgoal):\n 1. j |\\<notin>| bounds (nterm_to_term \\<Gamma> t)", "proof (induction t arbitrary: \\<Gamma> i j)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nvar x))\n 3. \\<And>x1a t \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 4. \\<And>t1 t2 \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma> i j.\n           \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n            \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n           \\<Longrightarrow> j |\\<notin>|\n                             bounds (nterm_to_term \\<Gamma> t2);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "case (Nvar name)"], ["proof (state)\nthis:\n  i < length \\<Gamma>\n  j < length \\<Gamma>\n  i < j\n  \\<Gamma> ! i = \\<Gamma> ! j\n\ngoal (4 subgoals):\n 1. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nvar x))\n 3. \\<And>x1a t \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 4. \\<And>t1 t2 \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma> i j.\n           \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n            \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n           \\<Longrightarrow> j |\\<notin>|\n                             bounds (nterm_to_term \\<Gamma> t2);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))", "proof (cases \"find_first name \\<Gamma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find_first name \\<Gamma> = None \\<Longrightarrow>\n    j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))\n 2. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))", "case (Some k)"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = Some k\n\ngoal (2 subgoals):\n 1. find_first name \\<Gamma> = None \\<Longrightarrow>\n    j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))\n 2. \\<And>a.\n       find_first name \\<Gamma> = Some a \\<Longrightarrow>\n       j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name)) \\<Longrightarrow>\n    False", "assume \"j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name))\""], ["proof (state)\nthis:\n  j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name))\n\ngoal (1 subgoal):\n 1. j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name)) \\<Longrightarrow>\n    False", "with Some"], ["proof (chain)\npicking this:\n  find_first name \\<Gamma> = Some k\n  j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name))", "have \"find_first name \\<Gamma> = Some j\""], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = Some k\n  j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name))\n\ngoal (1 subgoal):\n 1. find_first name \\<Gamma> = Some j", "by simp"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = Some j\n\ngoal (1 subgoal):\n 1. j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  find_first name \\<Gamma> = Some j\n\ngoal (1 subgoal):\n 1. j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name)) \\<Longrightarrow>\n    False", "have \"find_first name \\<Gamma> \\<noteq> Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_first name \\<Gamma> \\<noteq> Some j", "proof (rule find_first_later)"], ["proof (state)\ngoal (5 subgoals):\n 1. ?i < length \\<Gamma>\n 2. j < length \\<Gamma>\n 3. ?i < j\n 4. \\<Gamma> ! ?i = name\n 5. \\<Gamma> ! j = name", "show \"i < length \\<Gamma>\" \"j < length \\<Gamma>\" \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length \\<Gamma> &&& j < length \\<Gamma> &&& i < j", "by fact+"], ["proof (state)\nthis:\n  i < length \\<Gamma>\n  j < length \\<Gamma>\n  i < j\n\ngoal (2 subgoals):\n 1. \\<Gamma> ! i = name\n 2. \\<Gamma> ! j = name", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Gamma> ! i = name\n 2. \\<Gamma> ! j = name", "show \"\\<Gamma> ! j = name\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> ! j = name", "by (rule find_first_correct) fact"], ["proof (state)\nthis:\n  \\<Gamma> ! j = name\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! i = name", "thus \"\\<Gamma> ! i = name\""], ["proof (prove)\nusing this:\n  \\<Gamma> ! j = name\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! i = name", "using Nvar"], ["proof (prove)\nusing this:\n  \\<Gamma> ! j = name\n  i < length \\<Gamma>\n  j < length \\<Gamma>\n  i < j\n  \\<Gamma> ! i = \\<Gamma> ! j\n\ngoal (1 subgoal):\n 1. \\<Gamma> ! i = name", "by simp"], ["proof (state)\nthis:\n  \\<Gamma> ! i = name\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  find_first name \\<Gamma> \\<noteq> Some j\n\ngoal (1 subgoal):\n 1. j |\\<in>| bounds (nterm_to_term \\<Gamma> (Nvar name)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  find_first name \\<Gamma> = Some j\n  find_first name \\<Gamma> \\<noteq> Some j", "show False"], ["proof (prove)\nusing this:\n  find_first name \\<Gamma> = Some j\n  find_first name \\<Gamma> \\<noteq> Some j\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))\n\ngoal (1 subgoal):\n 1. find_first name \\<Gamma> = None \\<Longrightarrow>\n    j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))", "qed simp"], ["proof (state)\nthis:\n  j |\\<notin>| bounds (nterm_to_term \\<Gamma> (Nvar name))\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x1a t \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 3. \\<And>t1 t2 \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma> i j.\n           \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n            \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n           \\<Longrightarrow> j |\\<notin>|\n                             bounds (nterm_to_term \\<Gamma> t2);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x1a t \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 3. \\<And>t1 t2 \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma> i j.\n           \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n            \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n           \\<Longrightarrow> j |\\<notin>|\n                             bounds (nterm_to_term \\<Gamma> t2);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "case (Nabs x t)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length ?\\<Gamma>; ?j < length ?\\<Gamma>; ?i < ?j;\n   ?\\<Gamma> ! ?i = ?\\<Gamma> ! ?j\\<rbrakk>\n  \\<Longrightarrow> ?j |\\<notin>| bounds (nterm_to_term ?\\<Gamma> t)\n  i < length \\<Gamma>\n  j < length \\<Gamma>\n  i < j\n  \\<Gamma> ! i = \\<Gamma> ! j\n\ngoal (3 subgoals):\n 1. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>x1a t \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds\n                          (nterm_to_term \\<Gamma>\n                            (\\<Lambda>\\<^sub>n x1a. t))\n 3. \\<And>t1 t2 \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma> i j.\n           \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n            \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n           \\<Longrightarrow> j |\\<notin>|\n                             bounds (nterm_to_term \\<Gamma> t2);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. j |\\<notin>| bounds (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. j |\\<in>|\n    bounds\n     (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) \\<Longrightarrow>\n    False", "assume \"j |\\<in>| bounds (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))\""], ["proof (state)\nthis:\n  j |\\<in>| bounds (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))\n\ngoal (1 subgoal):\n 1. j |\\<in>|\n    bounds\n     (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  j |\\<in>| bounds (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))", "obtain j' where \"j' |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\" \"j' > 0\" \"j = j' - 1\""], ["proof (prove)\nusing this:\n  j |\\<in>| bounds (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j' |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t); 0 < j';\n         j = j' - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j' |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\n  0 < j'\n  j = j' - 1\n\ngoal (1 subgoal):\n 1. j |\\<in>|\n    bounds\n     (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) \\<Longrightarrow>\n    False", "hence \"Suc j |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\""], ["proof (prove)\nusing this:\n  j' |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\n  0 < j'\n  j = j' - 1\n\ngoal (1 subgoal):\n 1. Suc j |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)", "by simp"], ["proof (state)\nthis:\n  Suc j |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\n\ngoal (1 subgoal):\n 1. j |\\<in>|\n    bounds\n     (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  Suc j |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\n\ngoal (1 subgoal):\n 1. j |\\<in>|\n    bounds\n     (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) \\<Longrightarrow>\n    False", "have \"Suc j |\\<notin>| bounds (nterm_to_term (x # \\<Gamma>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc j |\\<notin>| bounds (nterm_to_term (x # \\<Gamma>) t)", "proof (rule Nabs)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?i < length (x # \\<Gamma>)\n 2. Suc j < length (x # \\<Gamma>)\n 3. ?i < Suc j\n 4. (x # \\<Gamma>) ! ?i = (x # \\<Gamma>) ! Suc j", "show \"Suc i < length (x # \\<Gamma>)\" \"Suc j < length (x # \\<Gamma>)\" \"Suc i < Suc j\" \"(x # \\<Gamma>) ! Suc i = (x # \\<Gamma>) ! Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc i < length (x # \\<Gamma>) &&& Suc j < length (x # \\<Gamma>)) &&&\n    Suc i < Suc j &&& (x # \\<Gamma>) ! Suc i = (x # \\<Gamma>) ! Suc j", "using Nabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length ?\\<Gamma>; ?j < length ?\\<Gamma>; ?i < ?j;\n   ?\\<Gamma> ! ?i = ?\\<Gamma> ! ?j\\<rbrakk>\n  \\<Longrightarrow> ?j |\\<notin>| bounds (nterm_to_term ?\\<Gamma> t)\n  i < length \\<Gamma>\n  j < length \\<Gamma>\n  i < j\n  \\<Gamma> ! i = \\<Gamma> ! j\n\ngoal (1 subgoal):\n 1. (Suc i < length (x # \\<Gamma>) &&& Suc j < length (x # \\<Gamma>)) &&&\n    Suc i < Suc j &&& (x # \\<Gamma>) ! Suc i = (x # \\<Gamma>) ! Suc j", "by simp+"], ["proof (state)\nthis:\n  Suc i < length (x # \\<Gamma>)\n  Suc j < length (x # \\<Gamma>)\n  Suc i < Suc j\n  (x # \\<Gamma>) ! Suc i = (x # \\<Gamma>) ! Suc j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc j |\\<notin>| bounds (nterm_to_term (x # \\<Gamma>) t)\n\ngoal (1 subgoal):\n 1. j |\\<in>|\n    bounds\n     (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  Suc j |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\n  Suc j |\\<notin>| bounds (nterm_to_term (x # \\<Gamma>) t)", "show False"], ["proof (prove)\nusing this:\n  Suc j |\\<in>| bounds (nterm_to_term (x # \\<Gamma>) t)\n  Suc j |\\<notin>| bounds (nterm_to_term (x # \\<Gamma>) t)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j |\\<notin>| bounds (nterm_to_term \\<Gamma> (\\<Lambda>\\<^sub>n x. t))\n\ngoal (2 subgoals):\n 1. \\<And>x \\<Gamma> i j.\n       \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (Nconst x))\n 2. \\<And>t1 t2 \\<Gamma> i j.\n       \\<lbrakk>\\<And>\\<Gamma> i j.\n                   \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n                    \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n                   \\<Longrightarrow> j |\\<notin>|\n                                     bounds (nterm_to_term \\<Gamma> t1);\n        \\<And>\\<Gamma> i j.\n           \\<lbrakk>i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n            \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n           \\<Longrightarrow> j |\\<notin>|\n                             bounds (nterm_to_term \\<Gamma> t2);\n        i < length \\<Gamma>; j < length \\<Gamma>; i < j;\n        \\<Gamma> ! i = \\<Gamma> ! j\\<rbrakk>\n       \\<Longrightarrow> j |\\<notin>|\n                         bounds (nterm_to_term \\<Gamma> (t1 $\\<^sub>n t2))", "qed auto"], ["", "fun subst_single :: \"nterm \\<Rightarrow> name \\<Rightarrow> nterm \\<Rightarrow> nterm\" where\n\"subst_single (Nvar s) s' t' = (if s = s' then t' else Nvar s)\" |\n\"subst_single (t\\<^sub>1 $\\<^sub>n t\\<^sub>2) s' t' = subst_single t\\<^sub>1 s' t' $\\<^sub>n subst_single t\\<^sub>2 s' t'\" |\n\"subst_single (\\<Lambda>\\<^sub>n x. t) s' t' = (\\<Lambda>\\<^sub>n x. (if x = s' then t else subst_single t s' t'))\" |\n\"subst_single t _ _ = t\""], ["", "lemma subst_single_eq: \"subst_single t s t' = subst t (fmap_of_list [(s, t')])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_single t s t' = subst t (fmap_of_list [(s, t')])", "proof (induction t)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       subst_single (Nconst x) s t' =\n       subst (Nconst x) (fmap_of_list [(s, t')])\n 2. \\<And>x.\n       subst_single (Nvar x) s t' = subst (Nvar x) (fmap_of_list [(s, t')])\n 3. \\<And>x1a t.\n       subst_single t s t' =\n       subst t (fmap_of_list [(s, t')]) \\<Longrightarrow>\n       subst_single (\\<Lambda>\\<^sub>n x1a. t) s t' =\n       subst (\\<Lambda>\\<^sub>n x1a. t) (fmap_of_list [(s, t')])\n 4. \\<And>t1 t2.\n       \\<lbrakk>subst_single t1 s t' = subst t1 (fmap_of_list [(s, t')]);\n        subst_single t2 s t' = subst t2 (fmap_of_list [(s, t')])\\<rbrakk>\n       \\<Longrightarrow> subst_single (t1 $\\<^sub>n t2) s t' =\n                         subst (t1 $\\<^sub>n t2) (fmap_of_list [(s, t')])", "case (Nabs x t)"], ["proof (state)\nthis:\n  subst_single t s t' = subst t (fmap_of_list [(s, t')])\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       subst_single (Nconst x) s t' =\n       subst (Nconst x) (fmap_of_list [(s, t')])\n 2. \\<And>x.\n       subst_single (Nvar x) s t' = subst (Nvar x) (fmap_of_list [(s, t')])\n 3. \\<And>x1a t.\n       subst_single t s t' =\n       subst t (fmap_of_list [(s, t')]) \\<Longrightarrow>\n       subst_single (\\<Lambda>\\<^sub>n x1a. t) s t' =\n       subst (\\<Lambda>\\<^sub>n x1a. t) (fmap_of_list [(s, t')])\n 4. \\<And>t1 t2.\n       \\<lbrakk>subst_single t1 s t' = subst t1 (fmap_of_list [(s, t')]);\n        subst_single t2 s t' = subst t2 (fmap_of_list [(s, t')])\\<rbrakk>\n       \\<Longrightarrow> subst_single (t1 $\\<^sub>n t2) s t' =\n                         subst (t1 $\\<^sub>n t2) (fmap_of_list [(s, t')])", "then"], ["proof (chain)\npicking this:\n  subst_single t s t' = subst t (fmap_of_list [(s, t')])", "show ?case"], ["proof (prove)\nusing this:\n  subst_single t s t' = subst t (fmap_of_list [(s, t')])\n\ngoal (1 subgoal):\n 1. subst_single (\\<Lambda>\\<^sub>n x. t) s t' =\n    subst (\\<Lambda>\\<^sub>n x. t) (fmap_of_list [(s, t')])", "by (cases \"x = s\") (simp add: fmfilter_alt_defs)+"], ["proof (state)\nthis:\n  subst_single (\\<Lambda>\\<^sub>n x. t) s t' =\n  subst (\\<Lambda>\\<^sub>n x. t) (fmap_of_list [(s, t')])\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       subst_single (Nconst x) s t' =\n       subst (Nconst x) (fmap_of_list [(s, t')])\n 2. \\<And>x.\n       subst_single (Nvar x) s t' = subst (Nvar x) (fmap_of_list [(s, t')])\n 3. \\<And>t1 t2.\n       \\<lbrakk>subst_single t1 s t' = subst t1 (fmap_of_list [(s, t')]);\n        subst_single t2 s t' = subst t2 (fmap_of_list [(s, t')])\\<rbrakk>\n       \\<Longrightarrow> subst_single (t1 $\\<^sub>n t2) s t' =\n                         subst (t1 $\\<^sub>n t2) (fmap_of_list [(s, t')])", "qed auto"], ["", "lemma nterm_to_term_subst_replace_bound:\n  assumes \"closed u'\" \"n \\<le> length \\<Gamma>\" \"x \\<notin> set (take n \\<Gamma>)\"\n  shows \"nterm_to_term \\<Gamma> (subst_single u x u') = replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single u x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) u)\n     (nterm_to_term \\<Gamma> u')", "using assms"], ["proof (prove)\nusing this:\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single u x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) u)\n     (nterm_to_term \\<Gamma> u')", "proof (induction u arbitrary: n \\<Gamma>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nvar xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nvar xa))\n                          (nterm_to_term \\<Gamma> u')\n 3. \\<And>x1a u n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (\\<Lambda>\\<^sub>n x1a. u) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. u))\n                          (nterm_to_term \\<Gamma> u')\n 4. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "case (Nvar name)"], ["proof (state)\nthis:\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (4 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nvar xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nvar xa))\n                          (nterm_to_term \\<Gamma> u')\n 3. \\<And>x1a u n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (\\<Lambda>\\<^sub>n x1a. u) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. u))\n                          (nterm_to_term \\<Gamma> u')\n 4. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "note insert_nth_take_drop[simp del]"], ["proof (state)\nthis:\n  insert_nth ?n ?x ?xs = take ?n ?xs @ [?x] @ drop ?n ?xs\n\ngoal (4 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nvar xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nvar xa))\n                          (nterm_to_term \\<Gamma> u')\n 3. \\<And>x1a u n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (\\<Lambda>\\<^sub>n x1a. u) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. u))\n                          (nterm_to_term \\<Gamma> u')\n 4. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "proof (cases \"name = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. name = x \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')\n 2. name \\<noteq> x \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "case True"], ["proof (state)\nthis:\n  name = x\n\ngoal (2 subgoals):\n 1. name = x \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')\n 2. name \\<noteq> x \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "thus ?thesis"], ["proof (prove)\nusing this:\n  name = x\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "using Nvar"], ["proof (prove)\nusing this:\n  name = x\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "apply (simp add: find_first_insert_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> nterm_to_term \\<Gamma> u' =\n                      incr_bounds (int n) 0 (nterm_to_term \\<Gamma> u')", "apply (subst incr_bounds_eq[where k = 0])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 0\n 2. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> wellformed (nterm_to_term \\<Gamma> u')\n 3. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> nterm_to_term \\<Gamma> u' = nterm_to_term \\<Gamma> u'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> 0", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> wellformed (nterm_to_term \\<Gamma> u')\n 2. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> nterm_to_term \\<Gamma> u' = nterm_to_term \\<Gamma> u'", "apply (rule nterm_to_term_closed_wellformed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> closed u'\n 2. \\<lbrakk>name = x; closed u'; n \\<le> length \\<Gamma>;\n     x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n    \\<Longrightarrow> nterm_to_term \\<Gamma> u' = nterm_to_term \\<Gamma> u'", "by auto"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n  replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n   (nterm_to_term \\<Gamma> u')\n\ngoal (1 subgoal):\n 1. name \\<noteq> x \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. name \\<noteq> x \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "case False"], ["proof (state)\nthis:\n  name \\<noteq> x\n\ngoal (1 subgoal):\n 1. name \\<noteq> x \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "thus ?thesis"], ["proof (prove)\nusing this:\n  name \\<noteq> x\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n    replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n     (nterm_to_term \\<Gamma> u')", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. name \\<noteq> x \\<Longrightarrow>\n    (case find_first name \\<Gamma> of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    replace_bound n\n     (case find_first name (insert_nth n x \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)\n     (nterm_to_term \\<Gamma> u')", "apply (subst find_first_insert_nth_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. name \\<noteq> x \\<Longrightarrow> name \\<noteq> x\n 2. name \\<noteq> x \\<Longrightarrow>\n    (case find_first name \\<Gamma> of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    replace_bound n\n     (case map_option (\\<lambda>i. if i < n then i else Suc i)\n            (find_first name \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)\n     (nterm_to_term \\<Gamma> u')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. name \\<noteq> x \\<Longrightarrow> name \\<noteq> x", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. name \\<noteq> x \\<Longrightarrow>\n    (case find_first name \\<Gamma> of None \\<Rightarrow> Free name\n     | Some x \\<Rightarrow> Bound x) =\n    replace_bound n\n     (case map_option (\\<lambda>i. if i < n then i else Suc i)\n            (find_first name \\<Gamma>) of\n      None \\<Rightarrow> Free name | Some x \\<Rightarrow> Bound x)\n     (nterm_to_term \\<Gamma> u')", "by (cases \"find_first name \\<Gamma>\") auto"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n  replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n   (nterm_to_term \\<Gamma> u')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (subst_single (Nvar name) x u') =\n  replace_bound n (nterm_to_term (insert_nth n x \\<Gamma>) (Nvar name))\n   (nterm_to_term \\<Gamma> u')\n\ngoal (3 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>x1a u n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (\\<Lambda>\\<^sub>n x1a. u) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. u))\n                          (nterm_to_term \\<Gamma> u')\n 3. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>x1a u n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (\\<Lambda>\\<^sub>n x1a. u) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. u))\n                          (nterm_to_term \\<Gamma> u')\n 3. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "case (Nabs y t)"], ["proof (state)\nthis:\n  \\<lbrakk>closed u'; ?n \\<le> length ?\\<Gamma>;\n   x \\<notin> set (take ?n ?\\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> (subst_single t x u') =\n                    replace_bound ?n\n                     (nterm_to_term (insert_nth ?n x ?\\<Gamma>) t)\n                     (nterm_to_term ?\\<Gamma> u')\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (3 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>x1a u n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (\\<Lambda>\\<^sub>n x1a. u) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. u))\n                          (nterm_to_term \\<Gamma> u')\n 3. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "note insert_nth_take_drop[simp del]"], ["proof (state)\nthis:\n  insert_nth ?n ?x ?xs = take ?n ?xs @ [?x] @ drop ?n ?xs\n\ngoal (3 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>x1a u n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u) (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (\\<Lambda>\\<^sub>n x1a. u) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (\\<Lambda>\\<^sub>n x1a. u))\n                          (nterm_to_term \\<Gamma> u')\n 3. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')\n 2. x \\<noteq> y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')\n 2. x \\<noteq> y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "have \"nterm_to_term (y # \\<Gamma>) t = replace_bound (Suc n) (nterm_to_term (y # insert_nth n y \\<Gamma>) t) (nterm_to_term \\<Gamma> u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term (y # \\<Gamma>) t =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "proof (subst replace_bound_eq)"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n |\\<notin>| bounds (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\n 2. nterm_to_term (y # \\<Gamma>) t =\n    incr_bounds (- 1) (Suc n + 1)\n     (nterm_to_term (y # insert_nth n y \\<Gamma>) t)", "show \"Suc n |\\<notin>| bounds (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n |\\<notin>| bounds (nterm_to_term (y # insert_nth n y \\<Gamma>) t)", "apply (rule nterm_to_term_bounds_dupl[where i = 0])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 < length (y # insert_nth n y \\<Gamma>)\n 2. Suc n < length (y # insert_nth n y \\<Gamma>)\n 3. 0 < Suc n\n 4. (y # insert_nth n y \\<Gamma>) ! 0 =\n    (y # insert_nth n y \\<Gamma>) ! Suc n", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (y # insert_nth n y \\<Gamma>)", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc n < length (y # insert_nth n y \\<Gamma>)\n 2. 0 < Suc n\n 3. (y # insert_nth n y \\<Gamma>) ! 0 =\n    (y # insert_nth n y \\<Gamma>) ! Suc n", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n < length (y # insert_nth n y \\<Gamma>)", "using Nabs(3)"], ["proof (prove)\nusing this:\n  n \\<le> length \\<Gamma>\n\ngoal (1 subgoal):\n 1. Suc n < length (y # insert_nth n y \\<Gamma>)", "by (simp add: insert_nth_take_drop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < Suc n\n 2. (y # insert_nth n y \\<Gamma>) ! 0 =\n    (y # insert_nth n y \\<Gamma>) ! Suc n", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Suc n", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y # insert_nth n y \\<Gamma>) ! 0 =\n    (y # insert_nth n y \\<Gamma>) ! Suc n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = insert_nth n y \\<Gamma> ! n", "apply (subst nth_insert_nth_index_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<le> length \\<Gamma>\n 2. y = y", "using Nabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed u'; ?n \\<le> length ?\\<Gamma>;\n   x \\<notin> set (take ?n ?\\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> (subst_single t x u') =\n                    replace_bound ?n\n                     (nterm_to_term (insert_nth ?n x ?\\<Gamma>) t)\n                     (nterm_to_term ?\\<Gamma> u')\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (2 subgoals):\n 1. n \\<le> length \\<Gamma>\n 2. y = y", "by auto"], ["proof (state)\nthis:\n  Suc n |\\<notin>| bounds (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\n\ngoal (1 subgoal):\n 1. nterm_to_term (y # \\<Gamma>) t =\n    incr_bounds (- 1) (Suc n + 1)\n     (nterm_to_term (y # insert_nth n y \\<Gamma>) t)", "show \"nterm_to_term (y # \\<Gamma>) t = incr_bounds (- 1) (Suc n + 1) (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term (y # \\<Gamma>) t =\n    incr_bounds (- 1) (Suc n + 1)\n     (nterm_to_term (y # insert_nth n y \\<Gamma>) t)", "apply (subst nterm_to_term_insert_dupl[where \\<Gamma> = \"y # \\<Gamma>\" and y = y and n = \"Suc n\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> set (take (Suc n) (y # \\<Gamma>))\n 2. Suc n \\<le> length (y # \\<Gamma>)\n 3. incr_bounds (- 1) (Suc (Suc n))\n     (nterm_to_term (insert_nth (Suc n) y (y # \\<Gamma>)) t) =\n    incr_bounds (- 1) (Suc n + 1)\n     (nterm_to_term (y # insert_nth n y \\<Gamma>) t)", "using Nabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed u'; ?n \\<le> length ?\\<Gamma>;\n   x \\<notin> set (take ?n ?\\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> (subst_single t x u') =\n                    replace_bound ?n\n                     (nterm_to_term (insert_nth ?n x ?\\<Gamma>) t)\n                     (nterm_to_term ?\\<Gamma> u')\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (3 subgoals):\n 1. y \\<in> set (take (Suc n) (y # \\<Gamma>))\n 2. Suc n \\<le> length (y # \\<Gamma>)\n 3. incr_bounds (- 1) (Suc (Suc n))\n     (nterm_to_term (insert_nth (Suc n) y (y # \\<Gamma>)) t) =\n    incr_bounds (- 1) (Suc n + 1)\n     (nterm_to_term (y # insert_nth n y \\<Gamma>) t)", "by auto"], ["proof (state)\nthis:\n  nterm_to_term (y # \\<Gamma>) t =\n  incr_bounds (- 1) (Suc n + 1)\n   (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nterm_to_term (y # \\<Gamma>) t =\n  replace_bound (Suc n) (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\n   (nterm_to_term \\<Gamma> u')\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')\n 2. x \\<noteq> y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "with True"], ["proof (chain)\npicking this:\n  x = y\n  nterm_to_term (y # \\<Gamma>) t =\n  replace_bound (Suc n) (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\n   (nterm_to_term \\<Gamma> u')", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n  nterm_to_term (y # \\<Gamma>) t =\n  replace_bound (Suc n) (nterm_to_term (y # insert_nth n y \\<Gamma>) t)\n   (nterm_to_term \\<Gamma> u')\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "by auto"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n  replace_bound n\n   (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n   (nterm_to_term \\<Gamma> u')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "have \"nterm_to_term (y # \\<Gamma>) (subst_single t x u') = replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t) (nterm_to_term \\<Gamma> u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term (y # \\<Gamma>) (subst_single t x u') =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "apply (subst Nabs(1)[of \"Suc n\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. closed u'\n 2. Suc n \\<le> length (y # \\<Gamma>)\n 3. x \\<notin> set (take (Suc n) (y # \\<Gamma>))\n 4. replace_bound (Suc n)\n     (nterm_to_term (insert_nth (Suc n) x (y # \\<Gamma>)) t)\n     (nterm_to_term (y # \\<Gamma>) u') =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed u'", "by fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. Suc n \\<le> length (y # \\<Gamma>)\n 2. x \\<notin> set (take (Suc n) (y # \\<Gamma>))\n 3. replace_bound (Suc n)\n     (nterm_to_term (insert_nth (Suc n) x (y # \\<Gamma>)) t)\n     (nterm_to_term (y # \\<Gamma>) u') =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n \\<le> length (y # \\<Gamma>)", "using Nabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed u'; ?n \\<le> length ?\\<Gamma>;\n   x \\<notin> set (take ?n ?\\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> (subst_single t x u') =\n                    replace_bound ?n\n                     (nterm_to_term (insert_nth ?n x ?\\<Gamma>) t)\n                     (nterm_to_term ?\\<Gamma> u')\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (1 subgoal):\n 1. Suc n \\<le> length (y # \\<Gamma>)", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> set (take (Suc n) (y # \\<Gamma>))\n 2. replace_bound (Suc n)\n     (nterm_to_term (insert_nth (Suc n) x (y # \\<Gamma>)) t)\n     (nterm_to_term (y # \\<Gamma>) u') =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (take (Suc n) (y # \\<Gamma>))", "using False Nabs"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<lbrakk>closed u'; ?n \\<le> length ?\\<Gamma>;\n   x \\<notin> set (take ?n ?\\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> (subst_single t x u') =\n                    replace_bound ?n\n                     (nterm_to_term (insert_nth ?n x ?\\<Gamma>) t)\n                     (nterm_to_term ?\\<Gamma> u')\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (take (Suc n) (y # \\<Gamma>))", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. replace_bound (Suc n)\n     (nterm_to_term (insert_nth (Suc n) x (y # \\<Gamma>)) t)\n     (nterm_to_term (y # \\<Gamma>) u') =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "apply (subst nterm_to_term_eq_closed[where t = u'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed u'\n 2. replace_bound (Suc n)\n     (nterm_to_term (insert_nth (Suc n) x (y # \\<Gamma>)) t)\n     (nterm_to_term ?\\<Gamma>'3 u') =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "using Nabs"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed u'; ?n \\<le> length ?\\<Gamma>;\n   x \\<notin> set (take ?n ?\\<Gamma>)\\<rbrakk>\n  \\<Longrightarrow> nterm_to_term ?\\<Gamma> (subst_single t x u') =\n                    replace_bound ?n\n                     (nterm_to_term (insert_nth ?n x ?\\<Gamma>) t)\n                     (nterm_to_term ?\\<Gamma> u')\n  closed u'\n  n \\<le> length \\<Gamma>\n  x \\<notin> set (take n \\<Gamma>)\n\ngoal (2 subgoals):\n 1. closed u'\n 2. replace_bound (Suc n)\n     (nterm_to_term (insert_nth (Suc n) x (y # \\<Gamma>)) t)\n     (nterm_to_term ?\\<Gamma>'3 u') =\n    replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n     (nterm_to_term \\<Gamma> u')", "by auto"], ["proof (state)\nthis:\n  nterm_to_term (y # \\<Gamma>) (subst_single t x u') =\n  replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n   (nterm_to_term \\<Gamma> u')\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "with False"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  nterm_to_term (y # \\<Gamma>) (subst_single t x u') =\n  replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n   (nterm_to_term \\<Gamma> u')", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  nterm_to_term (y # \\<Gamma>) (subst_single t x u') =\n  replace_bound (Suc n) (nterm_to_term (y # insert_nth n x \\<Gamma>) t)\n   (nterm_to_term \\<Gamma> u')\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n    replace_bound n\n     (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n     (nterm_to_term \\<Gamma> u')", "by auto"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n  replace_bound n\n   (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n   (nterm_to_term \\<Gamma> u')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nterm_to_term \\<Gamma> (subst_single (\\<Lambda>\\<^sub>n y. t) x u') =\n  replace_bound n\n   (nterm_to_term (insert_nth n x \\<Gamma>) (\\<Lambda>\\<^sub>n y. t))\n   (nterm_to_term \\<Gamma> u')\n\ngoal (2 subgoals):\n 1. \\<And>xa n \\<Gamma>.\n       \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (Nconst xa) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (Nconst xa))\n                          (nterm_to_term \\<Gamma> u')\n 2. \\<And>u1 u2 n \\<Gamma>.\n       \\<lbrakk>\\<And>n \\<Gamma>.\n                   \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n                    x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n                   \\<Longrightarrow> nterm_to_term \\<Gamma>\n(subst_single u1 x u') =\n                                     replace_bound n\n(nterm_to_term (insert_nth n x \\<Gamma>) u1) (nterm_to_term \\<Gamma> u');\n        \\<And>n \\<Gamma>.\n           \\<lbrakk>closed u'; n \\<le> length \\<Gamma>;\n            x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n           \\<Longrightarrow> nterm_to_term \\<Gamma> (subst_single u2 x u') =\n                             replace_bound n\n                              (nterm_to_term (insert_nth n x \\<Gamma>) u2)\n                              (nterm_to_term \\<Gamma> u');\n        closed u'; n \\<le> length \\<Gamma>;\n        x \\<notin> set (take n \\<Gamma>)\\<rbrakk>\n       \\<Longrightarrow> nterm_to_term \\<Gamma>\n                          (subst_single (u1 $\\<^sub>n u2) x u') =\n                         replace_bound n\n                          (nterm_to_term (insert_nth n x \\<Gamma>)\n                            (u1 $\\<^sub>n u2))\n                          (nterm_to_term \\<Gamma> u')", "qed auto"], ["", "corollary nterm_to_term_subst_\\<beta>:\n  assumes \"closed u'\"\n  shows \"nterm_to_term \\<Gamma> (subst u (fmap_of_list [(x, u')])) = nterm_to_term (x # \\<Gamma>) u [nterm_to_term \\<Gamma> u']\\<^sub>\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst u (fmap_of_list [(x, u')])) =\n    nterm_to_term (x # \\<Gamma>) u [nterm_to_term \\<Gamma> u']\\<^sub>\\<beta>", "using assms"], ["proof (prove)\nusing this:\n  closed u'\n\ngoal (1 subgoal):\n 1. nterm_to_term \\<Gamma> (subst u (fmap_of_list [(x, u')])) =\n    nterm_to_term (x # \\<Gamma>) u [nterm_to_term \\<Gamma> u']\\<^sub>\\<beta>", "by (rule nterm_to_term_subst_replace_bound[where n = 0, simplified, unfolded subst_single_eq])"], ["", "end"]]}