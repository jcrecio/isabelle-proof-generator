{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Lambda_Free_Compat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemma frees_tm[code, simp]:\n  \"frees (App f x) = frees f |\\<union>| frees x\"\n  \"frees (Hd h) = (case h of Sym _ \\<Rightarrow> fempty | Var v \\<Rightarrow> {| to_name v |})\"", "lemma consts_tm[code, simp]:\n  \"consts (App f x) = consts f |\\<union>| consts x\"\n  \"consts (Hd h) = (case h of Var _ \\<Rightarrow> fempty | Sym v \\<Rightarrow> {| to_name v |})\"", "lemma subst_tm[code, simp]:\n  \"subst (App t u) env = App (subst t env) (subst u env)\"\n  \"subst (Hd h) env = (case h of\n    Sym s \\<Rightarrow> Hd (Sym s) |\n    Var x \\<Rightarrow> (case fmlookup env (to_name x) of\n      Some t' \\<Rightarrow> t'\n    | None \\<Rightarrow> Hd (Var x)))\"", "lemma apps_list_comb: \"apps f xs = list_comb f xs\""], "translations": [["", "lemma frees_tm[code, simp]:\n  \"frees (App f x) = frees f |\\<union>| frees x\"\n  \"frees (Hd h) = (case h of Sym _ \\<Rightarrow> fempty | Var v \\<Rightarrow> {| to_name v |})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (tm.App f x) = frees f |\\<union>| frees x &&&\n    frees (Hd h) =\n    (case h of hd.Var v \\<Rightarrow> {|to_name v|}\n     | Sym x \\<Rightarrow> {||})", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (tm.App f x) = frees f |\\<union>| frees x &&&\n    frees (Hd h) =\n    (case h of hd.Var v \\<Rightarrow> {|to_name v|}\n     | Sym x \\<Rightarrow> {||})", "by (transfer; auto split: hd.splits)+"], ["", "lemma consts_tm[code, simp]:\n  \"consts (App f x) = consts f |\\<union>| consts x\"\n  \"consts (Hd h) = (case h of Var _ \\<Rightarrow> fempty | Sym v \\<Rightarrow> {| to_name v |})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (tm.App f x) = consts f |\\<union>| consts x &&&\n    consts (Hd h) =\n    (case h of hd.Var x \\<Rightarrow> {||}\n     | Sym v \\<Rightarrow> {|to_name v|})", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. consts (tm.App f x) = consts f |\\<union>| consts x &&&\n    consts (Hd h) =\n    (case h of hd.Var x \\<Rightarrow> {||}\n     | Sym v \\<Rightarrow> {|to_name v|})", "by (transfer; auto split: hd.splits)+"], ["", "definition subst_tm :: \"('a, 'b) tm \\<Rightarrow> (name, ('a, 'b) tm) fmap \\<Rightarrow> ('a, 'b) tm\" where\n\"subst_tm t env =\n  Lambda_Free_Term.subst (fmlookup_default env (Hd \\<circ> Var \\<circ> of_name) \\<circ> to_name) t\""], ["", "lemma subst_tm[code, simp]:\n  \"subst (App t u) env = App (subst t env) (subst u env)\"\n  \"subst (Hd h) env = (case h of\n    Sym s \\<Rightarrow> Hd (Sym s) |\n    Var x \\<Rightarrow> (case fmlookup env (to_name x) of\n      Some t' \\<Rightarrow> t'\n    | None \\<Rightarrow> Hd (Var x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (tm.App t u) env = tm.App (subst t env) (subst u env) &&&\n    subst (Hd h) env =\n    (case h of\n     hd.Var x \\<Rightarrow>\n       case fmlookup env (to_name x) of None \\<Rightarrow> Hd (hd.Var x)\n       | Some t' \\<Rightarrow> t'\n     | Sym s \\<Rightarrow> Hd (Sym s))", "unfolding subst_tm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lambda_Free_Term.subst\n     (fmlookup_default env (Hd \\<circ> hd.Var \\<circ> of_name) \\<circ>\n      to_name)\n     (tm.App t u) =\n    tm.App\n     (Lambda_Free_Term.subst\n       (fmlookup_default env (Hd \\<circ> hd.Var \\<circ> of_name) \\<circ>\n        to_name)\n       t)\n     (Lambda_Free_Term.subst\n       (fmlookup_default env (Hd \\<circ> hd.Var \\<circ> of_name) \\<circ>\n        to_name)\n       u) &&&\n    Lambda_Free_Term.subst\n     (fmlookup_default env (Hd \\<circ> hd.Var \\<circ> of_name) \\<circ>\n      to_name)\n     (Hd h) =\n    (case h of\n     hd.Var x \\<Rightarrow>\n       case fmlookup env (to_name x) of None \\<Rightarrow> Hd (hd.Var x)\n       | Some t' \\<Rightarrow> t'\n     | Sym s \\<Rightarrow> Hd (Sym s))", "by (auto simp: fmlookup_default_def split: hd.splits option.splits)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) tm, pre_term_class)", "by standard\n   (auto\n      simp: app_tm_def unapp_tm_def const_tm_def unconst_tm_def free_tm_def unfree_tm_def of_name_inj\n      split: tm.splits hd.splits option.splits)"], ["", "end"], ["", "instantiation tm :: (is_name, is_name) \"term\" begin"], ["", "definition abs_pred_tm :: \"(('a, 'b) tm \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) tm \\<Rightarrow> bool\" where\n\"abs_pred_tm P t \\<longleftrightarrow> True\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) tm, term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (1 P t)"], ["proof (state)\nthis:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "then"], ["proof (chain)\npicking this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t", "show ?case"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (1 subgoal):\n 1. P t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (Hd x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (tm.App t1 t2)", "case (Hd h)"], ["proof (state)\nthis:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (Hd x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (tm.App t1 t2)", "then"], ["proof (chain)\npicking this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x", "show ?case"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (1 subgoal):\n 1. P (Hd h)", "apply (cases h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x; h = hd.Var x1\\<rbrakk>\n       \\<Longrightarrow> P (Hd h)\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x; h = Sym x2\\<rbrakk>\n       \\<Longrightarrow> P (Hd h)", "apply (auto simp: free_tm_def const_tm_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<And>name. P (Hd (Sym (of_name name)));\n        \\<And>name. P (Hd (hd.Var (of_name name)));\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x; h = hd.Var x1\\<rbrakk>\n       \\<Longrightarrow> P (Hd (hd.Var x1))\n 2. \\<And>x2.\n       \\<lbrakk>\\<And>name. P (Hd (Sym (of_name name)));\n        \\<And>name. P (Hd (hd.Var (of_name name)));\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x; h = Sym x2\\<rbrakk>\n       \\<Longrightarrow> P (Hd (Sym x2))", "apply (metis of_to_name)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (Hd h)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (tm.App t1 t2)", "qed (auto simp: app_tm_def)"], ["proof (state)\nthis:\n  P t\n\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "qed (auto simp: abs_pred_tm_def)"], ["", "end"], ["", "lemma apps_list_comb: \"apps f xs = list_comb f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apps f xs = list_comb f xs", "by (induction xs arbitrary: f) (auto simp: app_tm_def)"], ["", "end"]]}