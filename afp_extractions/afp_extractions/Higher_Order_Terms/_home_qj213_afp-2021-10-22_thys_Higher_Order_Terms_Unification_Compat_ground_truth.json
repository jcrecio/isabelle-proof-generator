{"file_name": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms/Unification_Compat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Higher_Order_Terms", "problem_names": ["lemma to_of_name[simp]: \"to_name (of_name a) = a\"", "lemma of_to_name[simp]: \"of_name (to_name a) = a\"", "lemma of_name_inj: \"of_name name\\<^sub>1 = of_name name\\<^sub>2 \\<Longrightarrow> name\\<^sub>1 = name\\<^sub>2\"", "lemma [simp, code_unfold]: \"(to_name :: name \\<Rightarrow> name) = id\"", "lemma frees_trm[code, simp]:\n  \"frees (Var v) = {| to_name v |}\"\n  \"frees (trm.Const c) = {||}\"\n  \"frees (M \\<cdot> N) = frees M |\\<union>| frees N\"", "lemma assoc_alt_def[simp]:\n  \"assoc x y t = (case map_of t x of Some y' \\<Rightarrow> y' | _ \\<Rightarrow> y)\"", "lemma subst_eq: \"Unification.subst t s = subst t (fmap_of_list s)\""], "translations": [["", "lemma to_of_name[simp]: \"to_name (of_name a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_name (of_name a) = a", "unfolding to_name_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv of_name (of_name a) = a", "using bij"], ["proof (prove)\nusing this:\n  bij of_name\n\ngoal (1 subgoal):\n 1. inv of_name (of_name a) = a", "by (metis bij_inv_eq_iff)"], ["", "lemma of_to_name[simp]: \"of_name (to_name a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_name (to_name a) = a", "unfolding to_name_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_name (inv of_name a) = a", "using bij"], ["proof (prove)\nusing this:\n  bij of_name\n\ngoal (1 subgoal):\n 1. of_name (inv of_name a) = a", "by (meson bij_inv_eq_iff)"], ["", "lemma of_name_inj: \"of_name name\\<^sub>1 = of_name name\\<^sub>2 \\<Longrightarrow> name\\<^sub>1 = name\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_name name\\<^sub>1 = of_name name\\<^sub>2 \\<Longrightarrow>\n    name\\<^sub>1 = name\\<^sub>2", "using bij"], ["proof (prove)\nusing this:\n  bij of_name\n\ngoal (1 subgoal):\n 1. of_name name\\<^sub>1 = of_name name\\<^sub>2 \\<Longrightarrow>\n    name\\<^sub>1 = name\\<^sub>2", "by (metis to_of_name)"], ["", "end"], ["", "instantiation name :: is_name begin"], ["", "definition of_name_name :: \"name \\<Rightarrow> name\" where\n[code_unfold]: \"of_name_name x = x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(name, is_name_class)", "by standard (auto simp: of_name_name_def bij_betw_def inj_on_def)"], ["", "end"], ["", "lemma [simp, code_unfold]: \"(to_name :: name \\<Rightarrow> name) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_name = id", "unfolding to_name_def of_name_name_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<lambda>x. x) = id", "by auto"], ["", "instantiation trm :: (is_name) \"pre_term\" begin"], ["", "definition app_trm where\n\"app_trm = Comb\""], ["", "definition unapp_trm where\n\"unapp_trm t = (case t of Comb t u \\<Rightarrow> Some (t, u) | _ \\<Rightarrow> None)\""], ["", "definition const_trm where\n\"const_trm n = trm.Const (of_name n)\""], ["", "definition unconst_trm where\n\"unconst_trm t = (case t of trm.Const a \\<Rightarrow> Some (to_name a) | _ \\<Rightarrow> None)\""], ["", "definition free_trm where\n\"free_trm n = Var (of_name n)\""], ["", "definition unfree_trm where\n\"unfree_trm t = (case t of Var a \\<Rightarrow> Some (to_name a) | _ \\<Rightarrow> None)\""], ["", "primrec consts_trm :: \"'a trm \\<Rightarrow> name fset\" where\n\"consts_trm (Var _) = {||}\" |\n\"consts_trm (trm.Const c) = {| to_name c |}\" |\n\"consts_trm (M \\<cdot> N) = consts_trm M |\\<union>| consts_trm N\""], ["", "context\n  includes fset.lifting\nbegin"], ["", "lift_definition frees_trm :: \"'a trm \\<Rightarrow> name fset\" is \"\\<lambda>t. to_name ` vars_of t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>trm. finite (to_name ` vars_of trm)", "by auto"], ["", "end"], ["", "lemma frees_trm[code, simp]:\n  \"frees (Var v) = {| to_name v |}\"\n  \"frees (trm.Const c) = {||}\"\n  \"frees (M \\<cdot> N) = frees M |\\<union>| frees N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (Var v) = {|to_name v|} &&&\n    frees (trm.Const c) = {||} &&&\n    frees (M \\<cdot> N) = frees M |\\<union>| frees N", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. frees (Var v) = {|to_name v|} &&&\n    frees (trm.Const c) = {||} &&&\n    frees (M \\<cdot> N) = frees M |\\<union>| frees N", "by (transfer; auto)+"], ["", "primrec subst_trm :: \"'a trm \\<Rightarrow> (name, 'a trm) fmap \\<Rightarrow> 'a trm\" where\n\"subst_trm (Var v) env = (case fmlookup env (to_name v) of Some v' \\<Rightarrow> v' | _ \\<Rightarrow> Var v)\" |\n\"subst_trm (trm.Const c) _ = trm.Const c\" |\n\"subst_trm (M \\<cdot> N) env = subst_trm M env \\<cdot> subst_trm N env\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a trm, pre_term_class)", "by standard\n   (auto\n      simp: app_trm_def unapp_trm_def const_trm_def unconst_trm_def free_trm_def unfree_trm_def of_name_inj\n      split: trm.splits option.splits)"], ["", "end"], ["", "instantiation trm :: (is_name) \"term\" begin"], ["", "definition abs_pred_trm :: \"('a trm \\<Rightarrow> bool) \\<Rightarrow> 'a trm \\<Rightarrow> bool\" where\n\"abs_pred_trm P t \\<longleftrightarrow> True\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a trm, term_class)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "case (1 P t)"], ["proof (state)\nthis:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (7 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>t. abs_pred P t\\<rbrakk>\n       \\<Longrightarrow> P t\n 2. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 3. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 6. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 7. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "then"], ["proof (chain)\npicking this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t", "show ?case"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?t\n\ngoal (1 subgoal):\n 1. P t", "proof (induction t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (Var x)\n 2. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (trm.Const x)\n 3. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (t1 \\<cdot> t2)", "case Var"], ["proof (state)\nthis:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (Var x)\n 2. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (trm.Const x)\n 3. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (t1 \\<cdot> t2)", "then"], ["proof (chain)\npicking this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x", "show ?case"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (1 subgoal):\n 1. P (Var x_)", "unfolding free_trm_def"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (Var (of_name ?name))\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (1 subgoal):\n 1. P (Var x_)", "by (metis of_to_name)"], ["proof (state)\nthis:\n  P (Var x_)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (trm.Const x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (t1 \\<cdot> t2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (trm.Const x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (t1 \\<cdot> t2)", "case Const"], ["proof (state)\nthis:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (trm.Const x)\n 2. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (t1 \\<cdot> t2)", "then"], ["proof (chain)\npicking this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x", "show ?case"], ["proof (prove)\nusing this:\n  P (const ?name)\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (1 subgoal):\n 1. P (trm.Const x_)", "unfolding const_trm_def"], ["proof (prove)\nusing this:\n  P (trm.Const (of_name ?name))\n  P (free ?name)\n  \\<lbrakk>P ?t\\<^sub>1; P ?t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> P (app ?t\\<^sub>1 ?t\\<^sub>2)\n  abs_pred P ?x\n\ngoal (1 subgoal):\n 1. P (trm.Const x_)", "by (metis of_to_name)"], ["proof (state)\nthis:\n  P (trm.Const x_)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>name. P (const name);\n                 \\<And>name. P (free name);\n                 \\<And>t\\<^sub>1 t\\<^sub>2.\n                    \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n                    \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n                 \\<And>x. abs_pred P x\\<rbrakk>\n                \\<Longrightarrow> P t1;\n        \\<lbrakk>\\<And>name. P (const name); \\<And>name. P (free name);\n         \\<And>t\\<^sub>1 t\\<^sub>2.\n            \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n            \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n         \\<And>x. abs_pred P x\\<rbrakk>\n        \\<Longrightarrow> P t2;\n        \\<And>name. P (const name); \\<And>name. P (free name);\n        \\<And>t\\<^sub>1 t\\<^sub>2.\n           \\<lbrakk>P t\\<^sub>1; P t\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> P (app t\\<^sub>1 t\\<^sub>2);\n        \\<And>x. abs_pred P x\\<rbrakk>\n       \\<Longrightarrow> P (t1 \\<cdot> t2)", "qed (auto simp: app_trm_def)"], ["proof (state)\nthis:\n  P t\n\ngoal (6 subgoals):\n 1. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env. id_env env \\<longrightarrow> subst t env = t)\n        t\n 2. \\<And>x t.\n       abs_pred\n        (\\<lambda>t.\n            x |\\<notin>| frees t \\<longrightarrow>\n            (\\<forall>env. subst t (fmdrop x env) = subst t env))\n        t\n 3. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env\\<^sub>1 env\\<^sub>2.\n               closed_env env\\<^sub>2 \\<longrightarrow>\n               fdisjnt (fmdom env\\<^sub>1)\n                (fmdom env\\<^sub>2) \\<longrightarrow>\n               subst t (env\\<^sub>1 ++\\<^sub>f env\\<^sub>2) =\n               subst (subst t env\\<^sub>2) env\\<^sub>1)\n        t\n 4. \\<And>t.\n       abs_pred\n        (\\<lambda>t.\n            \\<forall>env.\n               closed_env env \\<longrightarrow>\n               frees (subst t env) = frees t |-| fmdom env)\n        t\n 5. \\<And>t.\n       abs_pred\n        (\\<lambda>a.\n            \\<forall>x.\n               consts (subst a x) =\n               consts a |\\<union>| ffUnion (consts |`| fmimage x (frees a)))\n        t\n 6. \\<And>P t. P t \\<Longrightarrow> abs_pred P t", "qed (auto simp: abs_pred_trm_def)"], ["", "end"], ["", "lemma assoc_alt_def[simp]:\n  \"assoc x y t = (case map_of t x of Some y' \\<Rightarrow> y' | _ \\<Rightarrow> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assoc x y t =\n    (case map_of t x of None \\<Rightarrow> y | Some y' \\<Rightarrow> y')", "by (induction t) auto"], ["", "lemma subst_eq: \"Unification.subst t s = subst t (fmap_of_list s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<lhd> s = subst t (fmap_of_list s)", "by (induction t) (auto split: option.splits simp: fmlookup_of_list)"], ["", "end"]]}