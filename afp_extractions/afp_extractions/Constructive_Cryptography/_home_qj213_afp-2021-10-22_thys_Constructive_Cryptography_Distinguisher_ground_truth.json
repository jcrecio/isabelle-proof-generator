{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Distinguisher.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma distinguish_attach: \"connect d (attach conv res) = connect (absorb d conv) res\"", "lemma absorb_comp_converter: \"absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'\"", "lemma connect_cong_trace:\n  fixes res1 res2 :: \"('a, 'b) resource\"\n  assumes trace_eq: \"A \\<turnstile>\\<^sub>R res1 \\<approx> res2\"\n    and WT: \"\\<I> \\<turnstile>g d \\<surd>\"\n    and out: \"outs_gpv \\<I> d \\<subseteq> A\"\n    and WT1: \"\\<I> \\<turnstile>res res1 \\<surd>\"\n    and WT2: \"\\<I> \\<turnstile>res res2 \\<surd>\"\n  shows \"connect d res1 = connect d res2\"", "lemma distinguish_trace_eq:\n  assumes distinguish: \"\\<And>distinguisher. \\<I> \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow> connect distinguisher res = connect distinguisher res'\"\n    and WT1: \"\\<I> \\<turnstile>res res1 \\<surd>\"\n    and WT2: \"\\<I> \\<turnstile>res res2 \\<surd>\"\n  shows \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'\"", "lemma connect_eq_resource_cong:\n  assumes \"\\<I> \\<turnstile>g distinguisher \\<surd>\"\n    and \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'\"\n    and \"\\<I> \\<turnstile>res res \\<surd>\"\n  shows \"connect distinguisher res = connect distinguisher res'\"", "lemma WT_gpv_absorb [WT_intro]:\n  \"\\<lbrakk> \\<I>' \\<turnstile>g gpv \\<surd>; \\<I>', \\<I> \\<turnstile>\\<^sub>C conv \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I> \\<turnstile>g absorb gpv conv \\<surd>\"", "lemma plossless_gpv_absorb [plossless_intro]:\n  assumes gpv: \"plossless_gpv \\<I>' gpv\"\n    and conv: \"plossless_converter \\<I>' \\<I> conv\"\n    and [WT_intro]: \"\\<I>' \\<turnstile>g gpv \\<surd>\" \"\\<I>', \\<I> \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"plossless_gpv \\<I> (absorb gpv conv)\"", "lemma interaction_any_bounded_by_absorb [interaction_bound]:\n  assumes gpv: \"interaction_any_bounded_by gpv bound1\"\n    and conv: \"interaction_any_bounded_converter conv bound2\"\n  shows \"interaction_any_bounded_by (absorb gpv conv) (bound1 * bound2)\""], "translations": [["", "lemma distinguish_attach: \"connect d (attach conv res) = connect (absorb d conv) res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connect d (attach conv res) = connect (absorb d conv) res", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. connect d (attach conv res) = connect (absorb d conv) res", "let ?R = \"\\<lambda>res (conv', res'). res = attach conv' res'\""], ["proof (state)\ngoal (1 subgoal):\n 1. connect d (attach conv res) = connect (absorb d conv) res", "have*: \"rel_spmf (rel_prod (=) ?R) (exec_gpv run_resource d (attach conv res))\n     (exec_gpv (\\<lambda>p y. map_spmf (\\<lambda>p. (fst (fst p), snd (fst p), snd p))\n       (exec_gpv run_resource (run_converter (fst p) y) (snd p))) d (conv, res))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=) (\\<lambda>res (conv', res'). res = attach conv' res'))\n     (exec_gpv run_resource d (attach conv res))\n     (exec_gpv\n       (\\<lambda>p y.\n           map_spmf (\\<lambda>p. (fst (fst p), snd (fst p), snd p))\n            (exec_gpv run_resource (run_converter (fst p) y) (snd p)))\n       d (conv, res))", "by(rule exec_gpv_parametric[where S=\"\\<lambda>res (conv', res'). res = attach conv' res'\" and CALL=\"(=)\", THEN rel_funD, THEN rel_funD, THEN rel_funD])\n      (auto simp add: gpv.rel_eq spmf_rel_map split_def intro: rel_spmf_reflI intro!: rel_funI)"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_prod (=) (\\<lambda>res (conv', res'). res = attach conv' res'))\n   (exec_gpv run_resource d (attach conv res))\n   (exec_gpv\n     (\\<lambda>p y.\n         map_spmf (\\<lambda>p. (fst (fst p), snd (fst p), snd p))\n          (exec_gpv run_resource (run_converter (fst p) y) (snd p)))\n     d (conv, res))\n\ngoal (1 subgoal):\n 1. connect d (attach conv res) = connect (absorb d conv) res", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. connect d (attach conv res) = connect (absorb d conv) res", "by(simp add: connect_def absorb_def exec_gpv_map_gpv_id spmf.map_comp exec_gpv_inline  o_def split_def spmf_rel_eq[symmetric])\n      (rule pmf.map_transfer[THEN rel_funD, THEN rel_funD]\n        , rule option.map_transfer[where Rb=\"rel_prod (=) ?R\", THEN rel_funD]\n        , auto simp add: * intro: fst_transfer)"], ["proof (state)\nthis:\n  connect d (attach conv res) = connect (absorb d conv) res\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma absorb_comp_converter: \"absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'", "let ?R = \"\\<lambda>conv (conv', conv''). conv = comp_converter conv' conv''\""], ["proof (state)\ngoal (1 subgoal):\n 1. absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'", "have*: \"rel_gpv (rel_prod (=) ?R) (=) (inline run_converter d (comp_converter conv conv'))\n   (inline (\\<lambda>p c2. map_gpv (\\<lambda>p. (fst (fst p), snd (fst p), snd p)) id (inline run_converter (run_converter (fst p) c2) (snd p)))  d (conv, conv'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (rel_prod (=)\n       (\\<lambda>conv (conv', conv''). conv = comp_converter conv' conv''))\n     (=) (inline run_converter d (comp_converter conv conv'))\n     (inline\n       (\\<lambda>p c2.\n           map_gpv (\\<lambda>p. (fst (fst p), snd (fst p), snd p)) id\n            (inline run_converter (run_converter (fst p) c2) (snd p)))\n       d (conv, conv'))", "by(rule inline_parametric[where C=\"(=)\", THEN rel_funD, THEN rel_funD, THEN rel_funD])\n      (auto simp add: gpv.rel_eq gpv.rel_map split_def intro: gpv.rel_refl_strong intro!: rel_funI)"], ["proof (state)\nthis:\n  rel_gpv\n   (rel_prod (=)\n     (\\<lambda>conv (conv', conv''). conv = comp_converter conv' conv''))\n   (=) (inline run_converter d (comp_converter conv conv'))\n   (inline\n     (\\<lambda>p c2.\n         map_gpv (\\<lambda>p. (fst (fst p), snd (fst p), snd p)) id\n          (inline run_converter (run_converter (fst p) c2) (snd p)))\n     d (conv, conv'))\n\ngoal (1 subgoal):\n 1. absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'", "by(simp add: gpv.rel_eq[symmetric] absorb_def inline_map_gpv gpv.map_comp inline_assoc o_def split_def id_def[symmetric])\n      (rule gpv.map_transfer[where R1b=\"rel_prod (=) ?R\", THEN rel_funD, THEN rel_funD, THEN rel_funD]\n        , auto simp add: * intro: fst_transfer id_transfer)"], ["proof (state)\nthis:\n  absorb d (comp_converter conv conv') = absorb (absorb d conv) conv'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma connect_cong_trace:\n  fixes res1 res2 :: \"('a, 'b) resource\"\n  assumes trace_eq: \"A \\<turnstile>\\<^sub>R res1 \\<approx> res2\"\n    and WT: \"\\<I> \\<turnstile>g d \\<surd>\"\n    and out: \"outs_gpv \\<I> d \\<subseteq> A\"\n    and WT1: \"\\<I> \\<turnstile>res res1 \\<surd>\"\n    and WT2: \"\\<I> \\<turnstile>res res2 \\<surd>\"\n  shows \"connect d res1 = connect d res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connect d res1 = connect d res2", "unfolding connect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_gpv run_resource d res1 = run_gpv run_resource d res2", "using trace_eq callee_invariant_run_resource callee_invariant_run_resource WT out WT1 WT2"], ["proof (prove)\nusing this:\n  A \\<turnstile>\\<^sub>R res1 \\<approx> res2\n  callee_invariant_on run_resource (WT_resource ?\\<I>) ?\\<I>\n  callee_invariant_on run_resource (WT_resource ?\\<I>) ?\\<I>\n  \\<I> \\<turnstile>g d \\<surd>\n  outs_gpv \\<I> d \\<subseteq> A\n  \\<I> \\<turnstile>res res1 \\<surd>\n  \\<I> \\<turnstile>res res2 \\<surd>\n\ngoal (1 subgoal):\n 1. run_gpv run_resource d res1 = run_gpv run_resource d res2", "by(rule trace_callee_eq'_run_gpv)"], ["", "lemma distinguish_trace_eq:\n  assumes distinguish: \"\\<And>distinguisher. \\<I> \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow> connect distinguisher res = connect distinguisher res'\"\n    and WT1: \"\\<I> \\<turnstile>res res1 \\<surd>\"\n    and WT2: \"\\<I> \\<turnstile>res res2 \\<surd>\"\n  shows \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "let ?P = \"\\<lambda>xs. \\<exists>x. set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and> x \\<in> outs_\\<I> \\<I> \\<and> trace_callee run_resource (return_spmf res) xs x \\<noteq> trace_callee run_resource (return_spmf res') xs x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'", "have \"Ex ?P\""], ["proof (prove)\nusing this:\n  \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'\n\ngoal (1 subgoal):\n 1. \\<exists>xs x.\n       set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n       x \\<in> outs_\\<I> \\<I> \\<and>\n       trace_callee run_resource (return_spmf res) xs x \\<noteq>\n       trace_callee run_resource (return_spmf res') xs x", "unfolding trace_callee_eq_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>xs.\n             set xs\n             \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<longrightarrow>\n             (\\<forall>x\\<in>outs_\\<I> \\<I>.\n                 trace_callee run_resource (return_spmf res) xs x =\n                 trace_callee run_resource (return_spmf res') xs x))\n\ngoal (1 subgoal):\n 1. \\<exists>xs x.\n       set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n       x \\<in> outs_\\<I> \\<I> \\<and>\n       trace_callee run_resource (return_spmf res) xs x \\<noteq>\n       trace_callee run_resource (return_spmf res') xs x", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs x.\n     set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n     x \\<in> outs_\\<I> \\<I> \\<and>\n     trace_callee run_resource (return_spmf res) xs x \\<noteq>\n     trace_callee run_resource (return_spmf res') xs x\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "with wf_strict_prefix[unfolded wfP_eq_minimal, THEN spec, of \"Collect ?P\"]"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> {xs.\n              \\<exists>x.\n                 set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n                 x \\<in> outs_\\<I> \\<I> \\<and>\n                 trace_callee run_resource (return_spmf res) xs x \\<noteq>\n                 trace_callee run_resource (return_spmf res') xs\n                  x} \\<longrightarrow>\n     (\\<exists>z\\<in>{xs.\n                      \\<exists>x.\n                         set xs\n                         \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n                         x \\<in> outs_\\<I> \\<I> \\<and>\n                         trace_callee run_resource (return_spmf res) xs\n                          x \\<noteq>\n                         trace_callee run_resource (return_spmf res') xs x}.\n         \\<forall>y.\n            strict_prefix y z \\<longrightarrow>\n            y \\<notin> {xs.\n                        \\<exists>x.\n                           set xs\n                           \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n                           x \\<in> outs_\\<I> \\<I> \\<and>\n                           trace_callee run_resource (return_spmf res) xs\n                            x \\<noteq>\n                           trace_callee run_resource (return_spmf res') xs\n                            x})\n  \\<exists>xs x.\n     set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n     x \\<in> outs_\\<I> \\<I> \\<and>\n     trace_callee run_resource (return_spmf res) xs x \\<noteq>\n     trace_callee run_resource (return_spmf res') xs x", "obtain xs x where xs: \"set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\"\n    and x: \"x \\<in> outs_\\<I> \\<I>\"\n    and neq: \"trace_callee run_resource (return_spmf res) xs x \\<noteq> trace_callee run_resource (return_spmf res') xs x\"\n    and shortest: \"\\<And>xs' x. \\<lbrakk> strict_prefix xs' xs; set xs' \\<subseteq>  outs_\\<I> \\<I> \\<times> UNIV; x \\<in> outs_\\<I> \\<I> \\<rbrakk>\n      \\<Longrightarrow> trace_callee run_resource (return_spmf res) xs' x = trace_callee run_resource (return_spmf res') xs' x\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> {xs.\n              \\<exists>x.\n                 set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n                 x \\<in> outs_\\<I> \\<I> \\<and>\n                 trace_callee run_resource (return_spmf res) xs x \\<noteq>\n                 trace_callee run_resource (return_spmf res') xs\n                  x} \\<longrightarrow>\n     (\\<exists>z\\<in>{xs.\n                      \\<exists>x.\n                         set xs\n                         \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n                         x \\<in> outs_\\<I> \\<I> \\<and>\n                         trace_callee run_resource (return_spmf res) xs\n                          x \\<noteq>\n                         trace_callee run_resource (return_spmf res') xs x}.\n         \\<forall>y.\n            strict_prefix y z \\<longrightarrow>\n            y \\<notin> {xs.\n                        \\<exists>x.\n                           set xs\n                           \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n                           x \\<in> outs_\\<I> \\<I> \\<and>\n                           trace_callee run_resource (return_spmf res) xs\n                            x \\<noteq>\n                           trace_callee run_resource (return_spmf res') xs\n                            x})\n  \\<exists>xs x.\n     set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV \\<and>\n     x \\<in> outs_\\<I> \\<I> \\<and>\n     trace_callee run_resource (return_spmf res) xs x \\<noteq>\n     trace_callee run_resource (return_spmf res') xs x\n\ngoal (1 subgoal):\n 1. (\\<And>xs x.\n        \\<lbrakk>set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV;\n         x \\<in> outs_\\<I> \\<I>;\n         trace_callee run_resource (return_spmf res) xs x \\<noteq>\n         trace_callee run_resource (return_spmf res') xs x;\n         \\<And>xs' x.\n            \\<lbrakk>strict_prefix xs' xs;\n             set xs' \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV;\n             x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n            \\<Longrightarrow> trace_callee run_resource (return_spmf res)\n                               xs' x =\n                              trace_callee run_resource (return_spmf res')\n                               xs' x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n  x \\<in> outs_\\<I> \\<I>\n  trace_callee run_resource (return_spmf res) xs x \\<noteq>\n  trace_callee run_resource (return_spmf res') xs x\n  \\<lbrakk>strict_prefix ?xs' xs;\n   set ?xs' \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV;\n   ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> trace_callee run_resource (return_spmf res) ?xs' ?x =\n                    trace_callee run_resource (return_spmf res') ?xs' ?x\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "have shortest: \"\\<And>xs' x. \\<lbrakk> strict_prefix xs' xs; x \\<in> outs_\\<I> \\<I> \\<rbrakk>\n      \\<Longrightarrow> trace_callee run_resource (return_spmf res) xs' x = trace_callee run_resource (return_spmf res') xs' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs' x.\n       \\<lbrakk>strict_prefix xs' xs; x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> trace_callee run_resource (return_spmf res) xs' x =\n                         trace_callee run_resource (return_spmf res') xs' x", "by(rule shortest)(use xs in \\<open>auto 4 3 dest: strict_prefix_setD\\<close>)"], ["proof (state)\nthis:\n  \\<lbrakk>strict_prefix ?xs' xs; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> trace_callee run_resource (return_spmf res) ?xs' ?x =\n                    trace_callee run_resource (return_spmf res') ?xs' ?x\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "define p where \"p \\<equiv> return_spmf res\""], ["proof (state)\nthis:\n  p \\<equiv> return_spmf res\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "define q where \"q \\<equiv> return_spmf res'\""], ["proof (state)\nthis:\n  q \\<equiv> return_spmf res'\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "have p: \"lossless_spmf p\" and q: \"lossless_spmf q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf p &&& lossless_spmf q", "by(simp_all add: p_def q_def)"], ["proof (state)\nthis:\n  lossless_spmf p\n  lossless_spmf q\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "from neq"], ["proof (chain)\npicking this:\n  trace_callee run_resource (return_spmf res) xs x \\<noteq>\n  trace_callee run_resource (return_spmf res') xs x", "obtain y where y: \"spmf (trace_callee run_resource p xs x) y \\<noteq> spmf (trace_callee run_resource q xs x) y\""], ["proof (prove)\nusing this:\n  trace_callee run_resource (return_spmf res) xs x \\<noteq>\n  trace_callee run_resource (return_spmf res') xs x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        spmf (trace_callee run_resource p xs x) y \\<noteq>\n        spmf (trace_callee run_resource q xs x) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce intro: spmf_eqI simp add: p_def q_def)"], ["proof (state)\nthis:\n  spmf (trace_callee run_resource p xs x) y \\<noteq>\n  spmf (trace_callee run_resource q xs x) y\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "have eq: \"spmf (trace_callee run_resource p ys x) y = spmf (trace_callee run_resource q ys x) y\"\n    if \"strict_prefix ys xs\" \"x \\<in> outs_\\<I> \\<I>\" for ys x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (trace_callee run_resource p ys x) y =\n    spmf (trace_callee run_resource q ys x) y", "using shortest[OF that]"], ["proof (prove)\nusing this:\n  trace_callee run_resource (return_spmf res) ys x =\n  trace_callee run_resource (return_spmf res') ys x\n\ngoal (1 subgoal):\n 1. spmf (trace_callee run_resource p ys x) y =\n    spmf (trace_callee run_resource q ys x) y", "by(auto intro: spmf_eqI simp add: p_def q_def)"], ["proof (state)\nthis:\n  \\<lbrakk>strict_prefix ?ys xs; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p ?ys ?x) ?y =\n                    spmf (trace_callee run_resource q ?ys ?x) ?y\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "define d :: \"('a \\<times> 'b) list \\<Rightarrow> _\"\n    where \"d = rec_list (Pause x (\\<lambda>y'. Done (y = y'))) (\\<lambda>(x, y) xs rec. Pause x (\\<lambda>input. if input = y then rec else Done False))\""], ["proof (state)\nthis:\n  d =\n  rec_list\n   (Generative_Probabilistic_Value.Pause x\n     (\\<lambda>y'. Generative_Probabilistic_Value.Done (y = y')))\n   (\\<lambda>(x, y) xs rec.\n       Generative_Probabilistic_Value.Pause x\n        (\\<lambda>input.\n            if input = y then rec\n            else Generative_Probabilistic_Value.Done False))\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "have d_simps [simp]:\n    \"d [] = Pause x (\\<lambda>y'. Done (y = y'))\"\n    \"d ((a, b) # xs) = Pause a (\\<lambda>input. if input = b then d xs else Done False)\" for a b xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. d [] =\n    Generative_Probabilistic_Value.Pause x\n     (\\<lambda>y'. Generative_Probabilistic_Value.Done (y = y')) &&&\n    d ((a, b) # xs) =\n    Generative_Probabilistic_Value.Pause a\n     (\\<lambda>input.\n         if input = b then d xs\n         else Generative_Probabilistic_Value.Done False)", "by(simp_all add: d_def fun_eq_iff)"], ["proof (state)\nthis:\n  d [] =\n  Generative_Probabilistic_Value.Pause x\n   (\\<lambda>y'. Generative_Probabilistic_Value.Done (y = y'))\n  d ((?a, ?b) # ?xs) =\n  Generative_Probabilistic_Value.Pause ?a\n   (\\<lambda>input.\n       if input = ?b then d ?xs\n       else Generative_Probabilistic_Value.Done False)\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "have WT_d: \"\\<I> \\<turnstile>g d xs \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g d xs \\<surd>", "using xs"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g d xs \\<surd>", "by(induction xs)(use x in auto)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g d xs \\<surd>\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "from distinguish[OF WT_d]"], ["proof (chain)\npicking this:\n  connect (d xs) res = connect (d xs) res'", "have \"spmf (bind_spmf p (connect (d xs))) True = spmf (bind_spmf q (connect (d xs))) True\""], ["proof (prove)\nusing this:\n  connect (d xs) res = connect (d xs) res'\n\ngoal (1 subgoal):\n 1. spmf (p \\<bind> connect (d xs)) True =\n    spmf (q \\<bind> connect (d xs)) True", "by(simp add: p_def q_def)"], ["proof (state)\nthis:\n  spmf (p \\<bind> connect (d xs)) True =\n  spmf (q \\<bind> connect (d xs)) True\n\ngoal (1 subgoal):\n 1. \\<not> outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res\n    \\<approx> res' \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  spmf (p \\<bind> connect (d xs)) True =\n  spmf (q \\<bind> connect (d xs)) True\n\ngoal (1 subgoal):\n 1. False", "using y eq xs"], ["proof (prove)\nusing this:\n  spmf (p \\<bind> connect (d xs)) True =\n  spmf (q \\<bind> connect (d xs)) True\n  spmf (trace_callee run_resource p xs x) y \\<noteq>\n  spmf (trace_callee run_resource q xs x) y\n  \\<lbrakk>strict_prefix ?ys xs; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p ?ys ?x) ?y =\n                    spmf (trace_callee run_resource q ?ys ?x) ?y\n  set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. False", "proof(induction xs arbitrary: p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>spmf (p \\<bind> connect (d [])) True =\n                spmf (q \\<bind> connect (d [])) True;\n        spmf (trace_callee run_resource p [] x) y \\<noteq>\n        spmf (trace_callee run_resource q [] x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys []; x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set [] \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  spmf (p \\<bind> connect (d [])) True =\n  spmf (q \\<bind> connect (d [])) True\n  spmf (trace_callee run_resource p [] x) y \\<noteq>\n  spmf (trace_callee run_resource q [] x) y\n  \\<lbrakk>strict_prefix ?ys []; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p ?ys ?x) ?y =\n                    spmf (trace_callee run_resource q ?ys ?x) ?y\n  set [] \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>spmf (p \\<bind> connect (d [])) True =\n                spmf (q \\<bind> connect (d [])) True;\n        spmf (trace_callee run_resource p [] x) y \\<noteq>\n        spmf (trace_callee run_resource q [] x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys []; x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set [] \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  spmf (p \\<bind> connect (d [])) True =\n  spmf (q \\<bind> connect (d [])) True\n  spmf (trace_callee run_resource p [] x) y \\<noteq>\n  spmf (trace_callee run_resource q [] x) y\n  \\<lbrakk>strict_prefix ?ys []; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p ?ys ?x) ?y =\n                    spmf (trace_callee run_resource q ?ys ?x) ?y\n  set [] \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  spmf (p \\<bind> connect (d [])) True =\n  spmf (q \\<bind> connect (d [])) True\n  spmf (trace_callee run_resource p [] x) y \\<noteq>\n  spmf (trace_callee run_resource q [] x) y\n  \\<lbrakk>strict_prefix ?ys []; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p ?ys ?x) ?y =\n                    spmf (trace_callee run_resource q ?ys ?x) ?y\n  set [] \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. False", "by(simp add: connect_def[abs_def] map_bind_spmf o_def split_def)\n        (simp add: map_spmf_conv_bind_spmf[symmetric] map_bind_spmf[unfolded o_def, symmetric] spmf_map vimage_def eq_commute)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "case (Cons xy xs p q)"], ["proof (state)\nthis:\n  \\<lbrakk>spmf (?p \\<bind> connect (d xs)) True =\n           spmf (?q \\<bind> connect (d xs)) True;\n   spmf (trace_callee run_resource ?p xs x) y \\<noteq>\n   spmf (trace_callee run_resource ?q xs x) y;\n   \\<And>ys x y.\n      \\<lbrakk>strict_prefix ys xs; x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n      \\<Longrightarrow> spmf (trace_callee run_resource ?p ys x) y =\n                        spmf (trace_callee run_resource ?q ys x) y;\n   set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n  \\<Longrightarrow> False\n  spmf (p \\<bind> connect (d (xy # xs))) True =\n  spmf (q \\<bind> connect (d (xy # xs))) True\n  spmf (trace_callee run_resource p (xy # xs) x) y \\<noteq>\n  spmf (trace_callee run_resource q (xy # xs) x) y\n  \\<lbrakk>strict_prefix ?ys (xy # xs); ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p ?ys ?x) ?y =\n                    spmf (trace_callee run_resource q ?ys ?x) ?y\n  set (xy # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "obtain x' y' where xy [simp]: \"xy = (x', y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' y'. xy = (x', y') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xy)"], ["proof (state)\nthis:\n  xy = (x', y')\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "let ?p = \"cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y'\"\n      and ?q = \"cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  spmf (p \\<bind> connect (d (xy # xs))) True =\n  spmf (q \\<bind> connect (d (xy # xs))) True", "have \"spmf ((map_spmf fst (p \\<bind> (\\<lambda>y. run_resource y x')) \\<bind> (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x')) x))) \\<bind> (\\<lambda>(a, b). if a = y' then connect (d xs) b else return_spmf False)) True =\n      spmf ((map_spmf fst (q \\<bind> (\\<lambda>y. run_resource y x')) \\<bind> (\\<lambda>x. map_spmf (Pair x) (cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x')) x))) \\<bind> (\\<lambda>(a, b). if a = y' then connect (d xs) b else return_spmf False)) True\""], ["proof (prove)\nusing this:\n  spmf (p \\<bind> connect (d (xy # xs))) True =\n  spmf (q \\<bind> connect (d (xy # xs))) True\n\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst (p \\<bind> (\\<lambda>y. run_resource y x')) \\<bind>\n      (\\<lambda>x.\n          map_spmf (Pair x)\n           (cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n             x)) \\<bind>\n      (\\<lambda>(a, b).\n          if a = y' then connect (d xs) b else return_spmf False))\n     True =\n    spmf\n     (map_spmf fst (q \\<bind> (\\<lambda>y. run_resource y x')) \\<bind>\n      (\\<lambda>x.\n          map_spmf (Pair x)\n           (cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n             x)) \\<bind>\n      (\\<lambda>(a, b).\n          if a = y' then connect (d xs) b else return_spmf False))\n     True", "unfolding cond_spmf_fst_inverse"], ["proof (prove)\nusing this:\n  spmf (p \\<bind> connect (d (xy # xs))) True =\n  spmf (q \\<bind> connect (d (xy # xs))) True\n\ngoal (1 subgoal):\n 1. spmf\n     (p \\<bind> (\\<lambda>y. run_resource y x') \\<bind>\n      (\\<lambda>(a, b).\n          if a = y' then connect (d xs) b else return_spmf False))\n     True =\n    spmf\n     (q \\<bind> (\\<lambda>y. run_resource y x') \\<bind>\n      (\\<lambda>(a, b).\n          if a = y' then connect (d xs) b else return_spmf False))\n     True", "by(clarsimp simp add: connect_def[abs_def] map_bind_spmf o_def split_def if_distrib[where f=\"\\<lambda>x. run_gpv _ x _\"] cong del: if_weak_cong)"], ["proof (state)\nthis:\n  spmf\n   (map_spmf fst (p \\<bind> (\\<lambda>y. run_resource y x')) \\<bind>\n    (\\<lambda>x.\n        map_spmf (Pair x)\n         (cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n           x)) \\<bind>\n    (\\<lambda>(a, b).\n        if a = y' then connect (d xs) b else return_spmf False))\n   True =\n  spmf\n   (map_spmf fst (q \\<bind> (\\<lambda>y. run_resource y x')) \\<bind>\n    (\\<lambda>x.\n        map_spmf (Pair x)\n         (cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n           x)) \\<bind>\n    (\\<lambda>(a, b).\n        if a = y' then connect (d xs) b else return_spmf False))\n   True\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"spmf ((p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) \\<bind>\n                (\\<lambda>a. if a = y' then cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x')) a \\<bind> connect (d xs)\n                          else bind_spmf (cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x')) a) (\\<lambda>_. return_spmf False))) True =\n      spmf ((q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) \\<bind>\n                (\\<lambda>a. if a = y' then cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x')) a \\<bind> connect (d xs)\n                            else bind_spmf (cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x')) a) (\\<lambda>_. return_spmf False))) True\""], ["proof (prove)\nusing this:\n  spmf\n   (map_spmf fst (p \\<bind> (\\<lambda>y. run_resource y x')) \\<bind>\n    (\\<lambda>x.\n        map_spmf (Pair x)\n         (cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n           x)) \\<bind>\n    (\\<lambda>(a, b).\n        if a = y' then connect (d xs) b else return_spmf False))\n   True =\n  spmf\n   (map_spmf fst (q \\<bind> (\\<lambda>y. run_resource y x')) \\<bind>\n    (\\<lambda>x.\n        map_spmf (Pair x)\n         (cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n           x)) \\<bind>\n    (\\<lambda>(a, b).\n        if a = y' then connect (d xs) b else return_spmf False))\n   True\n\ngoal (1 subgoal):\n 1. spmf\n     (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x')) \\<bind>\n      (\\<lambda>a.\n          if a = y'\n          then cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n                a \\<bind>\n               connect (d xs)\n          else cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n                a \\<bind>\n               (\\<lambda>_. return_spmf False)))\n     True =\n    spmf\n     (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x')) \\<bind>\n      (\\<lambda>a.\n          if a = y'\n          then cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n                a \\<bind>\n               connect (d xs)\n          else cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n                a \\<bind>\n               (\\<lambda>_. return_spmf False)))\n     True", "by(rule box_equals; use nothing in \\<open>rule arg_cong2[where f=spmf]\\<close>)\n        (auto simp add: map_bind_spmf bind_map_spmf o_def split_def intro!: bind_spmf_cong)"], ["proof (state)\nthis:\n  spmf\n   (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x')) \\<bind>\n    (\\<lambda>a.\n        if a = y'\n        then cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             connect (d xs)\n        else cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             (\\<lambda>_. return_spmf False)))\n   True =\n  spmf\n   (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x')) \\<bind>\n    (\\<lambda>a.\n        if a = y'\n        then cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             connect (d xs)\n        else cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             (\\<lambda>_. return_spmf False)))\n   True\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"LINT a|measure_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))). (if a = y' then spmf (?p \\<bind> connect (d xs)) True else 0) =\n      LINT a|measure_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))). (if a = y' then spmf (?q \\<bind> connect (d xs)) True else 0)\""], ["proof (prove)\nusing this:\n  spmf\n   (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x')) \\<bind>\n    (\\<lambda>a.\n        if a = y'\n        then cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             connect (d xs)\n        else cond_spmf_fst (p \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             (\\<lambda>_. return_spmf False)))\n   True =\n  spmf\n   (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x')) \\<bind>\n    (\\<lambda>a.\n        if a = y'\n        then cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             connect (d xs)\n        else cond_spmf_fst (q \\<bind> (\\<lambda>y. run_resource y x'))\n              a \\<bind>\n             (\\<lambda>_. return_spmf False)))\n   True\n\ngoal (1 subgoal):\n 1. LINT a|measure_spmf\n            (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n       (if a = y'\n        then spmf\n              (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x'))\n                y' \\<bind>\n               connect (d xs))\n              True\n        else 0) =\n    LINT a|measure_spmf\n            (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n       (if a = y'\n        then spmf\n              (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x'))\n                y' \\<bind>\n               connect (d xs))\n              True\n        else 0)", "by(rule box_equals; use nothing in \\<open>subst spmf_bind\\<close>)\n        (auto intro!: Bochner_Integration.integral_cong simp add: bind_spmf_const spmf_scale_spmf)"], ["proof (state)\nthis:\n  LINT a|measure_spmf\n          (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     (if a = y'\n      then spmf\n            (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x'))\n              y' \\<bind>\n             connect (d xs))\n            True\n      else 0) =\n  LINT a|measure_spmf\n          (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     (if a = y'\n      then spmf\n            (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x'))\n              y' \\<bind>\n             connect (d xs))\n            True\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"LINT a|measure_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))). indicator {y'} a * spmf (?p \\<bind> connect (d xs)) True =\n      LINT a|measure_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))). indicator {y'} a * spmf (?q \\<bind> connect (d xs)) True\""], ["proof (prove)\nusing this:\n  LINT a|measure_spmf\n          (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     (if a = y'\n      then spmf\n            (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x'))\n              y' \\<bind>\n             connect (d xs))\n            True\n      else 0) =\n  LINT a|measure_spmf\n          (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     (if a = y'\n      then spmf\n            (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x'))\n              y' \\<bind>\n             connect (d xs))\n            True\n      else 0)\n\ngoal (1 subgoal):\n 1. LINT a|measure_spmf\n            (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n       indicat_real {y'} a *\n       spmf\n        (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x'))\n          y' \\<bind>\n         connect (d xs))\n        True =\n    LINT a|measure_spmf\n            (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n       indicat_real {y'} a *\n       spmf\n        (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x'))\n          y' \\<bind>\n         connect (d xs))\n        True", "by(rule box_equals; use nothing in \\<open>rule Bochner_Integration.integral_cong\\<close>) auto"], ["proof (state)\nthis:\n  LINT a|measure_spmf\n          (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     indicat_real {y'} a *\n     spmf\n      (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n       connect (d xs))\n      True =\n  LINT a|measure_spmf\n          (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     indicat_real {y'} a *\n     spmf\n      (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n       connect (d xs))\n      True\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' * spmf (?p \\<bind> connect (d xs)) True =\n      spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' * spmf (?q \\<bind> connect (d xs)) True\""], ["proof (prove)\nusing this:\n  LINT a|measure_spmf\n          (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     indicat_real {y'} a *\n     spmf\n      (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n       connect (d xs))\n      True =\n  LINT a|measure_spmf\n          (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))).\n     indicat_real {y'} a *\n     spmf\n      (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n       connect (d xs))\n      True\n\ngoal (1 subgoal):\n 1. spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n    spmf\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n      connect (d xs))\n     True =\n    spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n    spmf\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n      connect (d xs))\n     True", "by(simp add: spmf_conv_measure_spmf)"], ["proof (state)\nthis:\n  spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "from Cons.prems(3)[of \"[]\" x'] Cons.prems(4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>strict_prefix [] (xy # xs); x' \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p [] x') ?y =\n                    spmf (trace_callee run_resource q [] x') ?y\n  set (xy # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV", "have \"spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' = spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_prefix [] (xy # xs); x' \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p [] x') ?y =\n                    spmf (trace_callee run_resource q [] x') ?y\n  set (xy # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' =\n    spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y'", "by(simp)"], ["proof (state)\nthis:\n  spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' =\n  spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y'\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n  spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' =\n  spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y'", "have \"spmf (?p \\<bind> connect (d xs)) True = spmf (?q \\<bind> connect (d xs)) True\""], ["proof (prove)\nusing this:\n  spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' *\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n  spmf (p \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y' =\n  spmf (q \\<bind> (\\<lambda>s. map_spmf fst (run_resource s x'))) y'\n\ngoal (1 subgoal):\n 1. spmf\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n      connect (d xs))\n     True =\n    spmf\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n      connect (d xs))\n     True", "by(auto simp add: cond_spmf_fst_def)(auto 4 3 simp add: spmf_eq_0_set_spmf cond_spmf_def o_def bind_UNION intro: rev_image_eqI)"], ["proof (state)\nthis:\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "have \"spmf (trace_callee run_resource ?p xs x) y \\<noteq> spmf (trace_callee run_resource ?q xs x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n     y \\<noteq>\n    spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n     y", "using Cons.prems"], ["proof (prove)\nusing this:\n  spmf (p \\<bind> connect (d (xy # xs))) True =\n  spmf (q \\<bind> connect (d (xy # xs))) True\n  spmf (trace_callee run_resource p (xy # xs) x) y \\<noteq>\n  spmf (trace_callee run_resource q (xy # xs) x) y\n  \\<lbrakk>strict_prefix ?ys (xy # xs); ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p ?ys ?x) ?y =\n                    spmf (trace_callee run_resource q ?ys ?x) ?y\n  set (xy # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n     y \\<noteq>\n    spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n     y", "by simp"], ["proof (state)\nthis:\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y \\<noteq>\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y \\<noteq>\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "have \"spmf (trace_callee run_resource ?p ys x) y = spmf (trace_callee run_resource ?q ys x) y\"\n      if ys: \"strict_prefix ys xs\" and x: \"x \\<in> outs_\\<I> \\<I>\" for ys x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') ys x)\n     y =\n    spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') ys x)\n     y", "using Cons.prems(3)[of \"xy # ys\" x y] ys x"], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_prefix (xy # ys) (xy # xs);\n   x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf (trace_callee run_resource p (xy # ys) x) y =\n                    spmf (trace_callee run_resource q (xy # ys) x) y\n  strict_prefix ys xs\n  x \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') ys x)\n     y =\n    spmf\n     (trace_callee run_resource\n       (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') ys x)\n     y", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>strict_prefix ?ys xs; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y =\n                    spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>strict_prefix ?ys xs; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y =\n                    spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "have \"set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV", "using Cons.prems(4)"], ["proof (prove)\nusing this:\n  set (xy # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>spmf (p \\<bind> connect (d xs)) True =\n                            spmf (q \\<bind> connect (d xs)) True;\n                    spmf (trace_callee run_resource p xs x) y \\<noteq>\n                    spmf (trace_callee run_resource q xs x) y;\n                    \\<And>ys x y.\n                       \\<lbrakk>strict_prefix ys xs;\n                        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n                       \\<Longrightarrow> spmf\n    (trace_callee run_resource p ys x) y =\n   spmf (trace_callee run_resource q ys x) y;\n                    set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> False;\n        spmf (p \\<bind> connect (d (a # xs))) True =\n        spmf (q \\<bind> connect (d (a # xs))) True;\n        spmf (trace_callee run_resource p (a # xs) x) y \\<noteq>\n        spmf (trace_callee run_resource q (a # xs) x) y;\n        \\<And>ys x y.\n           \\<lbrakk>strict_prefix ys (a # xs);\n            x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n           \\<Longrightarrow> spmf (trace_callee run_resource p ys x) y =\n                             spmf (trace_callee run_resource q ys x) y;\n        set (a # xs) \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y \\<noteq>\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y\n  \\<lbrakk>strict_prefix ?ys xs; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y =\n                    spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y\n  set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  spmf\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True =\n  spmf\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y' \\<bind>\n    connect (d xs))\n   True\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y \\<noteq>\n  spmf\n   (trace_callee run_resource\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. run_resource s x')) y') xs x)\n   y\n  \\<lbrakk>strict_prefix ?ys xs; ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y =\n                    spmf\n                     (trace_callee run_resource\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s. run_resource s x')) y')\n                       ?ys ?x)\n                     ?y\n  set xs \\<subseteq> outs_\\<I> \\<I> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. False", "by(rule Cons.IH)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma connect_eq_resource_cong:\n  assumes \"\\<I> \\<turnstile>g distinguisher \\<surd>\"\n    and \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'\"\n    and \"\\<I> \\<turnstile>res res \\<surd>\"\n  shows \"connect distinguisher res = connect distinguisher res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connect distinguisher res = connect distinguisher res'", "unfolding connect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_gpv run_resource distinguisher res =\n    run_gpv run_resource distinguisher res'", "by(fold spmf_rel_eq, rule map_spmf_parametric[THEN rel_funD, THEN rel_funD, rotated])\n    (auto simp add: rel_fun_def intro: assms exec_gpv_eq_resource_on )"], ["", "lemma WT_gpv_absorb [WT_intro]:\n  \"\\<lbrakk> \\<I>' \\<turnstile>g gpv \\<surd>; \\<I>', \\<I> \\<turnstile>\\<^sub>C conv \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I> \\<turnstile>g absorb gpv conv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     \\<I>', \\<I> \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g absorb gpv conv \\<surd>", "by(simp add: absorb_def run_converter.WT_gpv_inline_invar)"], ["", "lemma plossless_gpv_absorb [plossless_intro]:\n  assumes gpv: \"plossless_gpv \\<I>' gpv\"\n    and conv: \"plossless_converter \\<I>' \\<I> conv\"\n    and [WT_intro]: \"\\<I>' \\<turnstile>g gpv \\<surd>\" \"\\<I>', \\<I> \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"plossless_gpv \\<I> (absorb gpv conv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I> (absorb gpv conv)", "by(auto simp add: absorb_def intro: run_plossless_converter.plossless_inline_invariant[OF gpv] WT_intro conv dest: plossless_converterD)"], ["", "lemma interaction_any_bounded_by_absorb [interaction_bound]:\n  assumes gpv: \"interaction_any_bounded_by gpv bound1\"\n    and conv: \"interaction_any_bounded_converter conv bound2\"\n  shows \"interaction_any_bounded_by (absorb gpv conv) (bound1 * bound2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_by (absorb gpv conv) (bound1 * bound2)", "unfolding absorb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_by\n     (map_gpv fst id (inline run_converter gpv conv)) (bound1 * bound2)", "by(rule interaction_bounded_by_map_gpv_id, rule interaction_bounded_by_inline_invariant[OF gpv, rotated 2])\n    (rule conv, auto elim: interaction_any_bounded_converter.cases)"], ["", "end"]]}