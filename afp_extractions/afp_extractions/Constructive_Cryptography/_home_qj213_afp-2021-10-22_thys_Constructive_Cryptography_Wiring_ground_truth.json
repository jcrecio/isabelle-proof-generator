{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Wiring.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma WT_lassocr\\<^sub>C [WT_intro]: \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3, \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C lassocr\\<^sub>C \\<surd>\"", "lemma WT_rassocl\\<^sub>C [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3 \\<turnstile>\\<^sub>C rassocl\\<^sub>C \\<surd>\"", "lemma WT_swap\\<^sub>C [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1 \\<turnstile>\\<^sub>C swap\\<^sub>C \\<surd>\"", "lemma WT_swap_lassocr [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), \\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C swap_lassocr \\<surd>\"", "lemma WT_swap_rassocl [WT_intro]: \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3, (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>\\<^sub>C swap_rassocl \\<surd>\"", "lemma WT_parallel_wiring [WT_intro]:\n  \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4), (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C parallel_wiring \\<surd>\"", "lemma map_swap_sum_plus_oracle: includes lifting_syntax shows\n  \"(id ---> swap_sum ---> map_spmf (map_prod swap_sum id)) (oracle1 \\<oplus>\\<^sub>O oracle2) =\n   (oracle2 \\<oplus>\\<^sub>O oracle1)\"", "lemma map_\\<I>_rsuml_lsumr [simp]: \"map_\\<I> rsuml lsumr (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) = ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\"", "lemma map_\\<I>_lsumr_rsuml [simp]: \"map_\\<I> lsumr rsuml ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) = (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\"", "lemma map_\\<I>_swap_sum [simp]: \"map_\\<I> swap_sum swap_sum (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) = \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1\"", "lemma WT_parallel_resource1_wiring [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), \\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C parallel_resource1_wiring \\<surd>\"", "lemma plossless_rassocl\\<^sub>C [plossless_intro]: \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) rassocl\\<^sub>C\"", "lemma plossless_lassocr\\<^sub>C [plossless_intro]: \"plossless_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) lassocr\\<^sub>C\"", "lemma plossless_swap\\<^sub>C [plossless_intro]: \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C\"", "lemma plossless_swap_lassocr [plossless_intro]:\n  \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3)) swap_lassocr\"", "lemma rsuml_lsumr_parallel_converter2:\n  \"map_converter id id rsuml lsumr ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3) = \n   map_converter rsuml lsumr id id (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3)\"", "lemma comp_lassocr\\<^sub>C: \"((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3) \\<odot> lassocr\\<^sub>C = lassocr\\<^sub>C \\<odot> (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3)\"", "lemmas comp_lassocr\\<^sub>C' = comp_converter_eqs[OF comp_lassocr\\<^sub>C]", "lemma lsumr_rsuml_parallel_converter2:\n  \"map_converter id id lsumr rsuml (conv1 |\\<^sub>= (conv2 |\\<^sub>= conv3)) = \n   map_converter lsumr rsuml id id ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3)\"", "lemma comp_rassocl\\<^sub>C:\n  \"(conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) \\<odot> rassocl\\<^sub>C = rassocl\\<^sub>C \\<odot> ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3)\"", "lemmas comp_rassocl\\<^sub>C' = comp_converter_eqs[OF comp_rassocl\\<^sub>C]", "lemma swap_sum_right_gpv:\n  \"map_gpv' id swap_sum swap_sum (right_gpv gpv) = left_gpv gpv\"", "lemma swap_sum_left_gpv:\n  \"map_gpv' id swap_sum swap_sum (left_gpv gpv) = right_gpv gpv\"", "lemma swap_sum_parallel_converter2:\n  \"map_converter id id swap_sum swap_sum (conv1 |\\<^sub>= conv2) =\n   map_converter swap_sum swap_sum id id (conv2 |\\<^sub>= conv1)\"", "lemma comp_swap\\<^sub>C: \"(conv1 |\\<^sub>= conv2) \\<odot> swap\\<^sub>C = swap\\<^sub>C \\<odot> (conv2 |\\<^sub>= conv1)\"", "lemmas comp_swap\\<^sub>C' = comp_converter_eqs[OF comp_swap\\<^sub>C]", "lemma comp_swap_lassocr: \"(conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) \\<odot> swap_lassocr = swap_lassocr \\<odot> (conv2 |\\<^sub>= conv1 |\\<^sub>= conv3)\"", "lemmas comp_swap_lassocr' = comp_converter_eqs[OF comp_swap_lassocr]", "lemma comp_parallel_wiring:\n  \"((C1 |\\<^sub>= C2) |\\<^sub>= (C3 |\\<^sub>= C4)) \\<odot> parallel_wiring = parallel_wiring \\<odot> ((C1 |\\<^sub>= C3) |\\<^sub>= (C2 |\\<^sub>= C4))\"", "lemmas comp_parallel_wiring' = comp_converter_eqs[OF comp_parallel_wiring]", "lemma attach_converter_of_resource_conv_parallel_resource:\n  \"converter_of_resource res |\\<^sub>\\<propto> 1\\<^sub>C \\<rhd> res' = res \\<parallel> res'\"", "lemma attach_converter_of_resource_conv_parallel_resource2:\n  \" 1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res \\<rhd> res' = res' \\<parallel> res\"", "lemma plossless_parallel_wiring [plossless_intro]:\n  \"plossless_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4)) parallel_wiring\"", "lemma run_converter_lassocr [simp]:\n  \"run_converter lassocr\\<^sub>C x = Pause (rsuml x) (\\<lambda>x. Done (lsumr x, lassocr\\<^sub>C))\"", "lemma run_converter_rassocl [simp]:\n  \"run_converter rassocl\\<^sub>C x = Pause (lsumr x) (\\<lambda>x. Done (rsuml x, rassocl\\<^sub>C))\"", "lemma run_converter_swap [simp]: \"run_converter swap\\<^sub>C x = Pause (swap_sum x) (\\<lambda>x. Done (swap_sum x, swap\\<^sub>C))\"", "lemma run_converter_swap_lassocr [simp]:\n  \"run_converter swap_lassocr x = Pause (lassocr_swap_sum x) (\n     case lsumr x of Inl _ \\<Rightarrow> (\\<lambda>y. case lsumr y of Inl _ \\<Rightarrow> Done (lassocr_swap_sum y, swap_lassocr) | _ \\<Rightarrow> Fail)\n          | Inr _ \\<Rightarrow> (\\<lambda>y. case lsumr y of Inl _ \\<Rightarrow> Fail | Inr _ \\<Rightarrow> Done (lassocr_swap_sum y, swap_lassocr)))\"", "lemma run_converter_parallel_wiring:\n  \"run_converter parallel_wiring x = Pause (parallel_sum_wiring x) (\n    case rsuml x of Inl _ \\<Rightarrow> (\\<lambda>y. case rsuml y of Inl _ \\<Rightarrow> Done (parallel_sum_wiring y, parallel_wiring) | _ \\<Rightarrow> Fail)\n                | Inr x \\<Rightarrow> (case lsumr x of Inl _ \\<Rightarrow> (\\<lambda>y. case rsuml y of Inl _ \\<Rightarrow> Fail | Inr x \\<Rightarrow> (case lsumr x of Inl _ \\<Rightarrow> Done (parallel_sum_wiring y, parallel_wiring) | Inr _ \\<Rightarrow> Fail))\n                                          | Inr _ \\<Rightarrow> (\\<lambda>y. case rsuml y of Inl _ \\<Rightarrow> Fail | Inr x \\<Rightarrow> (case lsumr x of Inl _ \\<Rightarrow> Fail | Inr _ \\<Rightarrow> Done (parallel_sum_wiring y, parallel_wiring)))))\"", "lemma bound_lassocr\\<^sub>C [interaction_bound]: \"interaction_any_bounded_converter lassocr\\<^sub>C 1\"", "lemma bound_rassocl\\<^sub>C [interaction_bound]: \"interaction_any_bounded_converter rassocl\\<^sub>C 1\"", "lemma bound_swap\\<^sub>C [interaction_bound]: \"interaction_any_bounded_converter swap\\<^sub>C 1\"", "lemma bound_swap_rassocl [interaction_bound]: \"interaction_any_bounded_converter swap_rassocl 1\"", "lemma bound_swap_lassocr [interaction_bound]: \"interaction_any_bounded_converter swap_lassocr 1\"", "lemma bound_parallel_wiring [interaction_bound]: \"interaction_any_bounded_converter parallel_wiring 1\"", "lemmas wiringI = wiring", "lemma wiringD:\n  assumes \"wiring \\<I> \\<I>' cnv (f, g)\"\n  shows wiringD_eq: \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim> map_converter id id f g 1\\<^sub>C\"\n    and wiringD_WT: \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\"", "lemma apply_wiring_simps: \"apply_wiring (f, g) = map_fun id (map_fun f (map_spmf (map_prod g id)))\"", "lemma attach_wiring_resource_of_oracle:\n  assumes wiring: \"wiring \\<I>1 \\<I>2 conv fg\"\n    and WT: \"\\<I>2 \\<turnstile>res RES res s \\<surd>\"\n    and outs: \"outs_\\<I> \\<I>1 = UNIV\"\n  shows \"conv \\<rhd> RES res s = RES (apply_wiring fg res) s\"", "lemma wiring_id_converter [simp, wiring_intro]: \"wiring \\<I> \\<I> 1\\<^sub>C (id, id)\"", "lemma apply_wiring_id [simp]: \"apply_wiring (id, id) res = res\"", "lemma attach_wiring_simps: \"attach_wiring (f, g) = map_fun id (map_fun f (map_gpv (map_prod g id) id))\"", "lemma comp_wiring_converter_of_callee:\n  assumes wiring: \"wiring \\<I>1 \\<I>2 conv w\"\n    and WT: \"\\<I>2, \\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<surd>\"\n  shows \"\\<I>1, \\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim> CNV (attach_wiring w callee) s\"", "lemma comp_wiring_simps: \"comp_wiring (f, g) (f', g') = (f' \\<circ> f, g \\<circ> g')\"", "lemma wiring_comp_converterI [wiring_intro]:\n  \"wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')\" if \"wiring \\<I> \\<I>' conv1 fg\" \"wiring \\<I>' \\<I>'' conv2 fg'\"", "lemma parallel2_wiring_simps:\n  \"parallel2_wiring (f, g) (f', g') = (map_sum f f', map_sum g g')\"", "lemma wiring_parallel_converter2 [simp, wiring_intro]:\n  assumes \"wiring \\<I>1 \\<I>1' conv1 fg\"\n    and \"wiring \\<I>2 \\<I>2' conv2 fg'\"\n  shows \"wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2) (fg |\\<^sub>w fg')\"", "lemma apply_parallel2 [simp]:\n  \"apply_wiring (fg |\\<^sub>w fg') (res1 \\<oplus>\\<^sub>O res2) = (apply_wiring fg res1 \\<oplus>\\<^sub>O apply_wiring fg' res2)\"", "lemma apply_comp_wiring [simp]: \"apply_wiring (fg \\<circ>\\<^sub>w fg') res = apply_wiring fg (apply_wiring fg' res)\"", "lemma wiring_lassocr [simp, wiring_intro]:\n  \"wiring ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) lassocr\\<^sub>C lassocr\\<^sub>w\"", "lemma wiring_rassocl [simp, wiring_intro]:\n  \"wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) rassocl\\<^sub>C rassocl\\<^sub>w\"", "lemma wiring_swap [simp, wiring_intro]: \"wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C swap\\<^sub>w\"", "lemma apply_lassocr\\<^sub>w [simp]: \"apply_wiring lassocr\\<^sub>w (res1 \\<oplus>\\<^sub>O res2 \\<oplus>\\<^sub>O res3) = (res1 \\<oplus>\\<^sub>O res2) \\<oplus>\\<^sub>O res3\"", "lemma apply_rassocl\\<^sub>w [simp]: \"apply_wiring rassocl\\<^sub>w ((res1 \\<oplus>\\<^sub>O res2) \\<oplus>\\<^sub>O res3) = res1 \\<oplus>\\<^sub>O res2 \\<oplus>\\<^sub>O res3\"", "lemma apply_swap\\<^sub>w [simp]: \"apply_wiring swap\\<^sub>w (res1 \\<oplus>\\<^sub>O res2) = res2 \\<oplus>\\<^sub>O res1\""], "translations": [["", "lemma WT_lassocr\\<^sub>C [WT_intro]: \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3, \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C lassocr\\<^sub>C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3,\n    \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    lassocr\\<^sub>C \\<surd>", "by(coinduction)(auto simp add: lassocr\\<^sub>C_def)"], ["", "lemma WT_rassocl\\<^sub>C [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3 \\<turnstile>\\<^sub>C rassocl\\<^sub>C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3),\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    \\<I>3 \\<turnstile>\\<^sub>C\n    rassocl\\<^sub>C \\<surd>", "by(coinduction)(auto simp add: rassocl\\<^sub>C_def)"], ["", "lemma WT_swap\\<^sub>C [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1 \\<turnstile>\\<^sub>C swap\\<^sub>C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2,\n    \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1 \\<turnstile>\\<^sub>C\n    swap\\<^sub>C \\<surd>", "by(coinduction)(auto simp add: swap\\<^sub>C_def)"], ["", "lemma WT_swap_lassocr [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), \\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C swap_lassocr \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3),\n    \\<I>2 \\<oplus>\\<^sub>\\<I>\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<surd>", "unfolding swap_lassocr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3),\n    \\<I>2 \\<oplus>\\<^sub>\\<I>\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    rassocl\\<^sub>C \\<odot>\n    (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C \\<surd>", "by(rule WT_converter_comp WT_lassocr\\<^sub>C WT_rassocl\\<^sub>C WT_converter_parallel_converter2 WT_converter_id WT_swap\\<^sub>C)+"], ["", "lemma WT_swap_rassocl [WT_intro]: \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3, (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>\\<^sub>C swap_rassocl \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3,\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n    \\<I>2 \\<turnstile>\\<^sub>C\n    swap_rassocl \\<surd>", "unfolding swap_rassocl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3,\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n    \\<I>2 \\<turnstile>\\<^sub>C\n    lassocr\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap\\<^sub>C) \\<odot> rassocl\\<^sub>C \\<surd>", "by(rule WT_converter_comp WT_lassocr\\<^sub>C WT_rassocl\\<^sub>C WT_converter_parallel_converter2 WT_converter_id WT_swap\\<^sub>C)+"], ["", "lemma WT_parallel_wiring [WT_intro]:\n  \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4), (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C parallel_wiring \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4),\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<surd>", "unfolding parallel_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4),\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    lassocr\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C \\<surd>", "by(rule WT_converter_comp WT_lassocr\\<^sub>C WT_rassocl\\<^sub>C WT_converter_parallel_converter2 WT_converter_id WT_swap_lassocr)+"], ["", "lemma map_swap_sum_plus_oracle: includes lifting_syntax shows\n  \"(id ---> swap_sum ---> map_spmf (map_prod swap_sum id)) (oracle1 \\<oplus>\\<^sub>O oracle2) =\n   (oracle2 \\<oplus>\\<^sub>O oracle1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> swap_sum ---> map_spmf (map_prod swap_sum id))\n     (oracle1 \\<oplus>\\<^sub>O oracle2) =\n    oracle2 \\<oplus>\\<^sub>O oracle1", "proof ((rule ext)+; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> swap_sum ---> map_spmf (map_prod swap_sum id))\n        (oracle1 \\<oplus>\\<^sub>O oracle2) x xa =\n       (oracle2 \\<oplus>\\<^sub>O oracle1) x xa", "case (1 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (id ---> swap_sum ---> map_spmf (map_prod swap_sum id))\n        (oracle1 \\<oplus>\\<^sub>O oracle2) x xa =\n       (oracle2 \\<oplus>\\<^sub>O oracle1) x xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id ---> swap_sum ---> map_spmf (map_prod swap_sum id))\n     (oracle1 \\<oplus>\\<^sub>O oracle2) s q =\n    (oracle2 \\<oplus>\\<^sub>O oracle1) s q", "by (cases q) (simp_all add: spmf.map_comp o_def apfst_def prod.map_comp id_def)"], ["proof (state)\nthis:\n  (id ---> swap_sum ---> map_spmf (map_prod swap_sum id))\n   (oracle1 \\<oplus>\\<^sub>O oracle2) s q =\n  (oracle2 \\<oplus>\\<^sub>O oracle1) s q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_\\<I>_rsuml_lsumr [simp]: \"map_\\<I> rsuml lsumr (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) = ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> rsuml lsumr\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) =\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3", "proof(rule \\<I>_eqI[OF Set.set_eqI], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> rsuml lsumr\n                   (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                    (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))) =\n       (x \\<in> outs_\\<I>\n                 ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                  \\<I>3))\n 2. \\<And>x.\n       x \\<in> outs_\\<I>\n                ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                 \\<I>3) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> rsuml lsumr\n          (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))\n        x =\n       responses_\\<I>\n        ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) x", "case (1 x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> rsuml lsumr\n                   (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                    (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))) =\n       (x \\<in> outs_\\<I>\n                 ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                  \\<I>3))\n 2. \\<And>x.\n       x \\<in> outs_\\<I>\n                ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                 \\<I>3) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> rsuml lsumr\n          (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))\n        x =\n       responses_\\<I>\n        ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> outs_\\<I>\n              (map_\\<I> rsuml lsumr\n                (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                 (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))) =\n    (x \\<in> outs_\\<I>\n              ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3))", "by(cases x rule: rsuml.cases) auto"], ["proof (state)\nthis:\n  (x \\<in> outs_\\<I>\n            (map_\\<I> rsuml lsumr\n              (\\<I>1 \\<oplus>\\<^sub>\\<I>\n               (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))) =\n  (x \\<in> outs_\\<I>\n            ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> outs_\\<I>\n                ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                 \\<I>3) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> rsuml lsumr\n          (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))\n        x =\n       responses_\\<I>\n        ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) x", "qed (auto simp add: image_image)"], ["", "lemma map_\\<I>_lsumr_rsuml [simp]: \"map_\\<I> lsumr rsuml ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) = (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> lsumr rsuml\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) =\n    \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)", "proof(rule \\<I>_eqI[OF Set.set_eqI], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> lsumr rsuml\n                   ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                    \\<I>3))) =\n       (x \\<in> outs_\\<I>\n                 (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                  (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))\n 2. \\<And>x.\n       x \\<in> outs_\\<I>\n                (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                 (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> lsumr rsuml\n          ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3))\n        x =\n       responses_\\<I>\n        (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) x", "case (1 x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> lsumr rsuml\n                   ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                    \\<I>3))) =\n       (x \\<in> outs_\\<I>\n                 (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                  (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))\n 2. \\<And>x.\n       x \\<in> outs_\\<I>\n                (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                 (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> lsumr rsuml\n          ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3))\n        x =\n       responses_\\<I>\n        (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> outs_\\<I>\n              (map_\\<I> lsumr rsuml\n                ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n                 \\<I>3))) =\n    (x \\<in> outs_\\<I>\n              (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))", "by(cases x rule: lsumr.cases) auto"], ["proof (state)\nthis:\n  (x \\<in> outs_\\<I>\n            (map_\\<I> lsumr rsuml\n              ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n               \\<I>3))) =\n  (x \\<in> outs_\\<I>\n            (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> outs_\\<I>\n                (\\<I>1 \\<oplus>\\<^sub>\\<I>\n                 (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> lsumr rsuml\n          ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3))\n        x =\n       responses_\\<I>\n        (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) x", "qed (auto simp add: image_image)"], ["", "lemma map_\\<I>_swap_sum [simp]: \"map_\\<I> swap_sum swap_sum (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) = \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> swap_sum swap_sum (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) =\n    \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1", "proof(rule \\<I>_eqI[OF Set.set_eqI], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> swap_sum swap_sum\n                   (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n       (x \\<in> outs_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1))\n 2. \\<And>x.\n       x \\<in> outs_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> swap_sum swap_sum (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)) x =\n       responses_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) x", "case (1 x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (x \\<in> outs_\\<I>\n                 (map_\\<I> swap_sum swap_sum\n                   (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n       (x \\<in> outs_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1))\n 2. \\<And>x.\n       x \\<in> outs_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> swap_sum swap_sum (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)) x =\n       responses_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> outs_\\<I>\n              (map_\\<I> swap_sum swap_sum\n                (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n    (x \\<in> outs_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1))", "by(cases x) auto"], ["proof (state)\nthis:\n  (x \\<in> outs_\\<I>\n            (map_\\<I> swap_sum swap_sum\n              (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2))) =\n  (x \\<in> outs_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> outs_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) \\<Longrightarrow>\n       responses_\\<I>\n        (map_\\<I> swap_sum swap_sum (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)) x =\n       responses_\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) x", "qed (auto simp add: image_image)"], ["", "definition parallel_resource1_wiring :: \"('a + ('b + 'c), 'd + ('e + 'f), 'b + ('a + 'c), 'e + ('d + 'f)) converter\" where\n  \"parallel_resource1_wiring = swap_lassocr\""], ["", "lemma WT_parallel_resource1_wiring [WT_intro]: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), \\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C parallel_resource1_wiring \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3),\n    \\<I>2 \\<oplus>\\<^sub>\\<I>\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    parallel_resource1_wiring \\<surd>", "unfolding parallel_resource1_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3),\n    \\<I>2 \\<oplus>\\<^sub>\\<I>\n    (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<surd>", "by(rule WT_swap_lassocr)"], ["", "lemma plossless_rassocl\\<^sub>C [plossless_intro]: \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) rassocl\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     rassocl\\<^sub>C", "by coinduction (auto simp add: rassocl\\<^sub>C_def)"], ["", "lemma plossless_lassocr\\<^sub>C [plossless_intro]: \"plossless_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) lassocr\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     lassocr\\<^sub>C", "by coinduction (auto simp add: lassocr\\<^sub>C_def)"], ["", "lemma plossless_swap\\<^sub>C [plossless_intro]: \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C", "by coinduction (auto simp add: swap\\<^sub>C_def)"], ["", "lemma plossless_swap_lassocr [plossless_intro]:\n  \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3)) swap_lassocr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     swap_lassocr", "unfolding swap_lassocr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     (rassocl\\<^sub>C \\<odot>\n      (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C)", "by(rule plossless_intro WT_intro)+"], ["", "lemma rsuml_lsumr_parallel_converter2:\n  \"map_converter id id rsuml lsumr ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3) = \n   map_converter rsuml lsumr id id (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id rsuml lsumr\n     ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3) =\n    map_converter rsuml lsumr id id (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3)", "by(coinduction arbitrary: conv1 conv2 conv3, clarsimp split!: sum.split simp add: rel_fun_def map_gpv_conv_map_gpv'[symmetric])\n    ((subst left_gpv_map[where h=id] | subst right_gpv_map[where h=id])+\n      , simp add:gpv.map_comp sum.map_id0 o_def prod.map_comp id_def[symmetric]\n      , subst map_gpv'_map_gpv_swap, (subst rsuml_lsumr_left_gpv_left_gpv | subst rsuml_lsumr_left_gpv_right_gpv | subst rsuml_lsumr_right_gpv)\n      , auto 4 4 intro!: gpv.rel_refl_strong simp add: gpv.rel_map)+"], ["", "lemma comp_lassocr\\<^sub>C: \"((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3) \\<odot> lassocr\\<^sub>C = lassocr\\<^sub>C \\<odot> (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3) \\<odot> lassocr\\<^sub>C =\n    lassocr\\<^sub>C \\<odot> (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3)", "unfolding lassocr\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3) \\<odot>\n    map_converter rsuml lsumr id id 1\\<^sub>C =\n    map_converter rsuml lsumr id id 1\\<^sub>C \\<odot>\n    (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3)", "by(subst comp_converter_map_converter2)\n    (simp add: comp_converter_id_right comp_converter_map1_out comp_converter_id_left rsuml_lsumr_parallel_converter2)"], ["", "lemmas comp_lassocr\\<^sub>C' = comp_converter_eqs[OF comp_lassocr\\<^sub>C]"], ["", "lemma lsumr_rsuml_parallel_converter2:\n  \"map_converter id id lsumr rsuml (conv1 |\\<^sub>= (conv2 |\\<^sub>= conv3)) = \n   map_converter lsumr rsuml id id ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id lsumr rsuml\n     (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) =\n    map_converter lsumr rsuml id id\n     ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3)", "by(coinduction arbitrary: conv1 conv2 conv3, clarsimp split!: sum.split simp add: rel_fun_def map_gpv_conv_map_gpv'[symmetric])\n    ((subst left_gpv_map[where h=id] | subst right_gpv_map[where h=id])+\n      , simp add:gpv.map_comp sum.map_id0 o_def prod.map_comp id_def[symmetric]\n      , subst map_gpv'_map_gpv_swap, (subst lsumr_rsuml_left_gpv | subst lsumr_rsuml_right_gpv_left_gpv | subst lsumr_rsuml_right_gpv_right_gpv)\n      , auto 4 4 intro!: gpv.rel_refl_strong simp add: gpv.rel_map)+"], ["", "lemma comp_rassocl\\<^sub>C:\n  \"(conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) \\<odot> rassocl\\<^sub>C = rassocl\\<^sub>C \\<odot> ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) \\<odot> rassocl\\<^sub>C =\n    rassocl\\<^sub>C \\<odot> ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3)", "unfolding rassocl\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) \\<odot>\n    map_converter lsumr rsuml id id 1\\<^sub>C =\n    map_converter lsumr rsuml id id 1\\<^sub>C \\<odot>\n    ((conv1 |\\<^sub>= conv2) |\\<^sub>= conv3)", "by(subst comp_converter_map_converter2)\n    (simp add: comp_converter_id_right comp_converter_map1_out comp_converter_id_left lsumr_rsuml_parallel_converter2)"], ["", "lemmas comp_rassocl\\<^sub>C' = comp_converter_eqs[OF comp_rassocl\\<^sub>C]"], ["", "lemma swap_sum_right_gpv:\n  \"map_gpv' id swap_sum swap_sum (right_gpv gpv) = left_gpv gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id swap_sum swap_sum (right_gpv gpv) = left_gpv gpv", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split: sum.split intro: exI[where x=Fail])"], ["", "lemma swap_sum_left_gpv:\n  \"map_gpv' id swap_sum swap_sum (left_gpv gpv) = right_gpv gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' id swap_sum swap_sum (left_gpv gpv) = right_gpv gpv", "by(coinduction arbitrary: gpv)\n    (auto 4 3 simp add: spmf_rel_map generat.rel_map intro!: rel_spmf_reflI rel_generat_reflI rel_funI split: sum.split intro: exI[where x=Fail])"], ["", "lemma swap_sum_parallel_converter2:\n  \"map_converter id id swap_sum swap_sum (conv1 |\\<^sub>= conv2) =\n   map_converter swap_sum swap_sum id id (conv2 |\\<^sub>= conv1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id swap_sum swap_sum (conv1 |\\<^sub>= conv2) =\n    map_converter swap_sum swap_sum id id (conv2 |\\<^sub>= conv1)", "by(coinduction arbitrary: conv1 conv2, clarsimp simp add: rel_fun_def map_gpv_conv_map_gpv'[symmetric] split!: sum.split)\n    (subst map_gpv'_map_gpv_swap, (subst swap_sum_right_gpv | subst swap_sum_left_gpv), \n      auto 4 4 intro!: gpv.rel_refl_strong simp add: gpv.rel_map)+"], ["", "lemma comp_swap\\<^sub>C: \"(conv1 |\\<^sub>= conv2) \\<odot> swap\\<^sub>C = swap\\<^sub>C \\<odot> (conv2 |\\<^sub>= conv1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (conv1 |\\<^sub>= conv2) \\<odot> swap\\<^sub>C =\n    swap\\<^sub>C \\<odot> (conv2 |\\<^sub>= conv1)", "unfolding swap\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (conv1 |\\<^sub>= conv2) \\<odot>\n    map_converter swap_sum swap_sum id id 1\\<^sub>C =\n    map_converter swap_sum swap_sum id id 1\\<^sub>C \\<odot>\n    (conv2 |\\<^sub>= conv1)", "by(subst comp_converter_map_converter2)\n    (simp add: comp_converter_id_right comp_converter_map1_out comp_converter_id_left swap_sum_parallel_converter2)"], ["", "lemmas comp_swap\\<^sub>C' = comp_converter_eqs[OF comp_swap\\<^sub>C]"], ["", "lemma comp_swap_lassocr: \"(conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) \\<odot> swap_lassocr = swap_lassocr \\<odot> (conv2 |\\<^sub>= conv1 |\\<^sub>= conv3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (conv1 |\\<^sub>= conv2 |\\<^sub>= conv3) \\<odot> swap_lassocr =\n    swap_lassocr \\<odot> (conv2 |\\<^sub>= conv1 |\\<^sub>= conv3)", "unfolding swap_lassocr_def comp_rassocl\\<^sub>C' comp_converter_assoc comp_converter_parallel2' comp_swap\\<^sub>C' comp_converter_id_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. rassocl\\<^sub>C \\<odot>\n    (swap\\<^sub>C \\<odot> (conv2 |\\<^sub>= conv1) |\\<^sub>= conv3) \\<odot>\n    lassocr\\<^sub>C =\n    rassocl\\<^sub>C \\<odot>\n    (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n    lassocr\\<^sub>C \\<odot> (conv2 |\\<^sub>= conv1 |\\<^sub>= conv3)", "by(subst (9) comp_converter_id_left[symmetric], subst comp_converter_parallel2[symmetric])\n    (simp add: comp_converter_assoc comp_lassocr\\<^sub>C)"], ["", "lemmas comp_swap_lassocr' = comp_converter_eqs[OF comp_swap_lassocr]"], ["", "lemma comp_parallel_wiring:\n  \"((C1 |\\<^sub>= C2) |\\<^sub>= (C3 |\\<^sub>= C4)) \\<odot> parallel_wiring = parallel_wiring \\<odot> ((C1 |\\<^sub>= C3) |\\<^sub>= (C2 |\\<^sub>= C4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((C1 |\\<^sub>= C2) |\\<^sub>= C3 |\\<^sub>= C4) \\<odot> parallel_wiring =\n    parallel_wiring \\<odot> ((C1 |\\<^sub>= C3) |\\<^sub>= C2 |\\<^sub>= C4)", "unfolding parallel_wiring_def comp_lassocr\\<^sub>C' comp_converter_assoc comp_converter_parallel2' comp_swap_lassocr'"], ["proof (prove)\ngoal (1 subgoal):\n 1. lassocr\\<^sub>C \\<odot>\n    (C1 \\<odot> 1\\<^sub>C |\\<^sub>=\n     swap_lassocr \\<odot> (C3 |\\<^sub>= C2 |\\<^sub>= C4)) \\<odot>\n    rassocl\\<^sub>C =\n    lassocr\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot>\n    rassocl\\<^sub>C \\<odot> ((C1 |\\<^sub>= C3) |\\<^sub>= C2 |\\<^sub>= C4)", "by(subst comp_converter_id_right[THEN trans, OF comp_converter_id_left[symmetric]], subst comp_converter_parallel2[symmetric])\n    (simp add: comp_converter_assoc comp_rassocl\\<^sub>C)"], ["", "lemmas comp_parallel_wiring' = comp_converter_eqs[OF comp_parallel_wiring]"], ["", "lemma attach_converter_of_resource_conv_parallel_resource:\n  \"converter_of_resource res |\\<^sub>\\<propto> 1\\<^sub>C \\<rhd> res' = res \\<parallel> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_resource res |\\<^sub>\\<propto> 1\\<^sub>C \\<rhd> res' =\n    res \\<parallel> res'", "by(coinduction arbitrary: res res')\n    (auto 4 3 simp add: rel_fun_def map_lift_spmf spmf.map_comp o_def prod.map_comp spmf_rel_map bind_map_spmf map_spmf_conv_bind_spmf[symmetric] split_def split!: sum.split intro!: rel_spmf_reflI)"], ["", "lemma attach_converter_of_resource_conv_parallel_resource2:\n  \" 1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res \\<rhd> res' = res' \\<parallel> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res \\<rhd> res' =\n    res' \\<parallel> res", "by(coinduction arbitrary: res res')\n    (auto 4 3 simp add: rel_fun_def map_lift_spmf spmf.map_comp o_def prod.map_comp spmf_rel_map bind_map_spmf map_spmf_conv_bind_spmf[symmetric] split_def split!: sum.split intro!: rel_spmf_reflI)"], ["", "lemma plossless_parallel_wiring [plossless_intro]:\n  \"plossless_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4)) parallel_wiring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n      (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n      (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     parallel_wiring", "unfolding parallel_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n      (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n      (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     (lassocr\\<^sub>C \\<odot>\n      (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C)", "by(rule plossless_intro WT_intro)+"], ["", "lemma run_converter_lassocr [simp]:\n  \"run_converter lassocr\\<^sub>C x = Pause (rsuml x) (\\<lambda>x. Done (lsumr x, lassocr\\<^sub>C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter lassocr\\<^sub>C x =\n    Pause (rsuml x) (\\<lambda>x. Done (lsumr x, lassocr\\<^sub>C))", "by(simp add: lassocr\\<^sub>C_def o_def)"], ["", "lemma run_converter_rassocl [simp]:\n  \"run_converter rassocl\\<^sub>C x = Pause (lsumr x) (\\<lambda>x. Done (rsuml x, rassocl\\<^sub>C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter rassocl\\<^sub>C x =\n    Pause (lsumr x) (\\<lambda>x. Done (rsuml x, rassocl\\<^sub>C))", "by(simp add: rassocl\\<^sub>C_def o_def)"], ["", "lemma run_converter_swap [simp]: \"run_converter swap\\<^sub>C x = Pause (swap_sum x) (\\<lambda>x. Done (swap_sum x, swap\\<^sub>C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter swap\\<^sub>C x =\n    Pause (swap_sum x) (\\<lambda>x. Done (swap_sum x, swap\\<^sub>C))", "by(simp add: swap\\<^sub>C_def o_def)"], ["", "definition lassocr_swap_sum where \"lassocr_swap_sum = rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr\""], ["", "lemma run_converter_swap_lassocr [simp]:\n  \"run_converter swap_lassocr x = Pause (lassocr_swap_sum x) (\n     case lsumr x of Inl _ \\<Rightarrow> (\\<lambda>y. case lsumr y of Inl _ \\<Rightarrow> Done (lassocr_swap_sum y, swap_lassocr) | _ \\<Rightarrow> Fail)\n          | Inr _ \\<Rightarrow> (\\<lambda>y. case lsumr y of Inl _ \\<Rightarrow> Fail | Inr _ \\<Rightarrow> Done (lassocr_swap_sum y, swap_lassocr)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter swap_lassocr x =\n    Pause (lassocr_swap_sum x)\n     (case lsumr x of\n      Inl x \\<Rightarrow>\n        \\<lambda>y.\n           case lsumr y of\n           Inl x \\<Rightarrow> Done (lassocr_swap_sum y, swap_lassocr)\n           | Inr b \\<Rightarrow> Fail\n      | Inr x \\<Rightarrow>\n          \\<lambda>y.\n             case lsumr y of Inl x \\<Rightarrow> Fail\n             | Inr x \\<Rightarrow> Done (lassocr_swap_sum y, swap_lassocr))", "by(subst sum.case_distrib[where h=\"\\<lambda>x. inline _ x _\"] |\n      simp add: bind_rpv_def inline_map_gpv split_def map_gpv_conv_bind[symmetric] swap_lassocr_def o_def cong del: sum.case_cong)+\n    (cases x rule: lsumr.cases, simp_all add: o_def lassocr_swap_sum_def gpv.map_comp fun_eq_iff cong: sum.case_cong split: sum.split)"], ["", "definition parallel_sum_wiring where \"parallel_sum_wiring = lsumr \\<circ> map_sum id lassocr_swap_sum \\<circ> rsuml\""], ["", "(* TODO: simplify the case distinctions *)"], ["", "lemma run_converter_parallel_wiring:\n  \"run_converter parallel_wiring x = Pause (parallel_sum_wiring x) (\n    case rsuml x of Inl _ \\<Rightarrow> (\\<lambda>y. case rsuml y of Inl _ \\<Rightarrow> Done (parallel_sum_wiring y, parallel_wiring) | _ \\<Rightarrow> Fail)\n                | Inr x \\<Rightarrow> (case lsumr x of Inl _ \\<Rightarrow> (\\<lambda>y. case rsuml y of Inl _ \\<Rightarrow> Fail | Inr x \\<Rightarrow> (case lsumr x of Inl _ \\<Rightarrow> Done (parallel_sum_wiring y, parallel_wiring) | Inr _ \\<Rightarrow> Fail))\n                                          | Inr _ \\<Rightarrow> (\\<lambda>y. case rsuml y of Inl _ \\<Rightarrow> Fail | Inr x \\<Rightarrow> (case lsumr x of Inl _ \\<Rightarrow> Fail | Inr _ \\<Rightarrow> Done (parallel_sum_wiring y, parallel_wiring)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter parallel_wiring x =\n    Pause (parallel_sum_wiring x)\n     (case rsuml x of\n      Inl x \\<Rightarrow>\n        \\<lambda>y.\n           case rsuml y of\n           Inl x \\<Rightarrow> Done (parallel_sum_wiring y, parallel_wiring)\n           | Inr b \\<Rightarrow> Fail\n      | Inr x \\<Rightarrow>\n          case lsumr x of\n          Inl x \\<Rightarrow>\n            \\<lambda>y.\n               case rsuml y of Inl x \\<Rightarrow> Fail\n               | Inr x \\<Rightarrow>\n                   case lsumr x of\n                   Inl x \\<Rightarrow>\n                     Done (parallel_sum_wiring y, parallel_wiring)\n                   | Inr x \\<Rightarrow> Fail\n          | Inr x \\<Rightarrow>\n              \\<lambda>y.\n                 case rsuml y of Inl x \\<Rightarrow> Fail\n                 | Inr x \\<Rightarrow>\n                     case lsumr x of Inl x \\<Rightarrow> Fail\n                     | Inr x \\<Rightarrow>\n                         Done (parallel_sum_wiring y, parallel_wiring))", "by(simp add: parallel_wiring_def o_def cong del: sum.case_cong add: split_def map_gpv_conv_bind[symmetric])\n    (subst sum.case_distrib[where h=\"\\<lambda>x. right_rpv x _\"] |\n      subst sum.case_distrib[where h=\"\\<lambda>x. inline _ x _\"] |\n      subst sum.case_distrib[where h=right_gpv] |\n      (auto simp add: inline_map_gpv bind_rpv_def  gpv.map_comp fun_eq_iff parallel_sum_wiring_def \n        parallel_wiring_def[symmetric] sum.case_distrib o_def intro: sym cong del: sum.case_cong split!: sum.split))+"], ["", "lemma bound_lassocr\\<^sub>C [interaction_bound]: \"interaction_any_bounded_converter lassocr\\<^sub>C 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter lassocr\\<^sub>C 1", "unfolding lassocr\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (map_converter rsuml lsumr id id 1\\<^sub>C) 1", "by interaction_bound_converter simp"], ["", "lemma bound_rassocl\\<^sub>C [interaction_bound]: \"interaction_any_bounded_converter rassocl\\<^sub>C 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter rassocl\\<^sub>C 1", "unfolding rassocl\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (map_converter lsumr rsuml id id 1\\<^sub>C) 1", "by interaction_bound_converter simp"], ["", "lemma bound_swap\\<^sub>C [interaction_bound]: \"interaction_any_bounded_converter swap\\<^sub>C 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter swap\\<^sub>C 1", "unfolding swap\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (map_converter swap_sum swap_sum id id 1\\<^sub>C) 1", "by interaction_bound_converter simp"], ["", "lemma bound_swap_rassocl [interaction_bound]: \"interaction_any_bounded_converter swap_rassocl 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter swap_rassocl 1", "unfolding swap_rassocl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (lassocr\\<^sub>C \\<odot>\n      (1\\<^sub>C |\\<^sub>= swap\\<^sub>C) \\<odot> rassocl\\<^sub>C)\n     1", "by interaction_bound_converter simp"], ["", "lemma bound_swap_lassocr [interaction_bound]: \"interaction_any_bounded_converter swap_lassocr 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter swap_lassocr 1", "unfolding swap_lassocr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (rassocl\\<^sub>C \\<odot>\n      (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C)\n     1", "by interaction_bound_converter simp"], ["", "lemma bound_parallel_wiring [interaction_bound]: \"interaction_any_bounded_converter parallel_wiring 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter parallel_wiring 1", "unfolding parallel_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (lassocr\\<^sub>C \\<odot>\n      (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C)\n     1", "by interaction_bound_converter simp"], ["", "subsection \\<open>Characterization of wirings\\<close>"], ["", "type_synonym ('a, 'b, 'c, 'd) wiring = \"('a \\<Rightarrow> 'c) \\<times> ('d \\<Rightarrow> 'b)\""], ["", "inductive wiring :: \"('a, 'b) \\<I> \\<Rightarrow> ('c, 'd) \\<I> \\<Rightarrow> ('a, 'b, 'c, 'd) converter \\<Rightarrow> ('a, 'b, 'c, 'd) wiring \\<Rightarrow> bool\"\n  for \\<I> \\<I>' cnv\n  where\n    wiring:\n    \"wiring \\<I> \\<I>' cnv (f, g)\" if\n    \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim> map_converter id id f g 1\\<^sub>C\"\n    \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\""], ["", "lemmas wiringI = wiring"], ["", "hide_fact wiring"], ["", "lemma wiringD:\n  assumes \"wiring \\<I> \\<I>' cnv (f, g)\"\n  shows wiringD_eq: \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim> map_converter id id f g 1\\<^sub>C\"\n    and wiringD_WT: \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim>\n    map_converter id id f g 1\\<^sub>C &&&\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  wiring \\<I> \\<I>' cnv (f, g)\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim>\n    map_converter id id f g 1\\<^sub>C &&&\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>", "by(cases, blast)+"], ["", "named_theorems wiring_intro \"introduction rules for wiring\""], ["", "definition apply_wiring :: \"('a, 'b, 'c, 'd) wiring \\<Rightarrow> ('s, 'c, 'd) oracle' \\<Rightarrow> ('s, 'a, 'b) oracle'\"\n  where \"apply_wiring = (\\<lambda>(f, g). map_fun id (map_fun f (map_spmf (map_prod g id))))\""], ["", "lemma apply_wiring_simps: \"apply_wiring (f, g) = map_fun id (map_fun f (map_spmf (map_prod g id)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring (f, g) = map_fun id (map_fun f (map_spmf (map_prod g id)))", "by(simp add: apply_wiring_def)"], ["", "lemma attach_wiring_resource_of_oracle:\n  assumes wiring: \"wiring \\<I>1 \\<I>2 conv fg\"\n    and WT: \"\\<I>2 \\<turnstile>res RES res s \\<surd>\"\n    and outs: \"outs_\\<I> \\<I>1 = UNIV\"\n  shows \"conv \\<rhd> RES res s = RES (apply_wiring fg res) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "using wiring"], ["proof (prove)\nusing this:\n  wiring \\<I>1 \\<I>2 conv fg\n\ngoal (1 subgoal):\n 1. conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>fg = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "case (wiring f g)"], ["proof (state)\nthis:\n  fg = (f, g)\n  \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>fg = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "have \"\\<I>_full,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim> map_converter id id f g 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n    map_converter id id f g 1\\<^sub>C", "using wiring(2)"], ["proof (prove)\nusing this:\n  \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>_full,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n    map_converter id id f g 1\\<^sub>C", "by(rule eq_\\<I>_converter_mono)(simp_all add: le_\\<I>_def outs)"], ["proof (state)\nthis:\n  \\<I>_full,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>fg = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "with WT"], ["proof (chain)\npicking this:\n  \\<I>2 \\<turnstile>res RES res s \\<surd>\n  \\<I>_full,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C", "have \"conv \\<rhd> RES res s = map_converter id id f g 1\\<^sub>C \\<rhd> RES res s\""], ["proof (prove)\nusing this:\n  \\<I>2 \\<turnstile>res RES res s \\<surd>\n  \\<I>_full,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. conv \\<rhd> RES res s =\n    map_converter id id f g 1\\<^sub>C \\<rhd> RES res s", "by(rule eq_\\<I>_attach)"], ["proof (state)\nthis:\n  conv \\<rhd> RES res s = map_converter id id f g 1\\<^sub>C \\<rhd> RES res s\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>fg = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "also"], ["proof (state)\nthis:\n  conv \\<rhd> RES res s = map_converter id id f g 1\\<^sub>C \\<rhd> RES res s\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>fg = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "have \"\\<dots> = RES (apply_wiring fg res) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id f g 1\\<^sub>C \\<rhd> RES res s =\n    RES (apply_wiring fg res) s", "by(simp add: attach_map_converter map_resource_resource_of_oracle prod.map_id0 option.map_id0 map_fun_id apply_wiring_def wiring(1))"], ["proof (state)\nthis:\n  map_converter id id f g 1\\<^sub>C \\<rhd> RES res s =\n  RES (apply_wiring fg res) s\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>fg = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "finally"], ["proof (chain)\npicking this:\n  conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "show ?thesis"], ["proof (prove)\nusing this:\n  conv \\<rhd> RES res s = RES (apply_wiring fg res) s\n\ngoal (1 subgoal):\n 1. conv \\<rhd> RES res s = RES (apply_wiring fg res) s", "."], ["proof (state)\nthis:\n  conv \\<rhd> RES res s = RES (apply_wiring fg res) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wiring_id_converter [simp, wiring_intro]: \"wiring \\<I> \\<I> 1\\<^sub>C (id, id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I> 1\\<^sub>C (id, id)", "using wiring.intros[of \\<I> \\<I> \"1\\<^sub>C\" id id]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<I>,\\<I> \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim>\n           map_converter id id id id 1\\<^sub>C;\n   \\<I>, \\<I> \\<turnstile>\\<^sub>C 1\\<^sub>C \\<surd>\\<rbrakk>\n  \\<Longrightarrow> wiring \\<I> \\<I> 1\\<^sub>C (id, id)\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I> 1\\<^sub>C (id, id)", "by(simp add: eq_\\<I>_converter_reflI)"], ["", "lemma apply_wiring_id [simp]: \"apply_wiring (id, id) res = res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring (id, id) res = res", "by(simp add: apply_wiring_simps prod.map_id0 option.map_id0 map_fun_id)"], ["", "definition attach_wiring :: \"('a, 'b, 'c, 'd) wiring \\<Rightarrow> ('s \\<Rightarrow> 'c \\<Rightarrow> ('d \\<times> 's, 'e, 'f) gpv) \\<Rightarrow> ('s \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 's, 'e, 'f) gpv)\"\n  where \"attach_wiring = (\\<lambda>(f, g). map_fun id (map_fun f (map_gpv (map_prod g id) id)))\""], ["", "lemma attach_wiring_simps: \"attach_wiring (f, g) = map_fun id (map_fun f (map_gpv (map_prod g id) id))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_wiring (f, g) =\n    map_fun id (map_fun f (map_gpv (map_prod g id) id))", "by(simp add: attach_wiring_def)"], ["", "lemma comp_wiring_converter_of_callee:\n  assumes wiring: \"wiring \\<I>1 \\<I>2 conv w\"\n    and WT: \"\\<I>2, \\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<surd>\"\n  shows \"\\<I>1, \\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim> CNV (attach_wiring w callee) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n    CNV (attach_wiring w callee) s", "using wiring"], ["proof (prove)\nusing this:\n  wiring \\<I>1 \\<I>2 conv w\n\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n    CNV (attach_wiring w callee) s", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         conv \\<odot> CNV callee s \\<sim>\n                         CNV (attach_wiring w callee) s", "case (wiring f g)"], ["proof (state)\nthis:\n  w = (f, g)\n  \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         conv \\<odot> CNV callee s \\<sim>\n                         CNV (attach_wiring w callee) s", "from wiring(2)"], ["proof (chain)\npicking this:\n  \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C", "have \"\\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim> map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s\""], ["proof (prove)\nusing this:\n  \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n    map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s", "by(rule eq_\\<I>_comp_cong)(rule eq_\\<I>_converter_reflI[OF WT])"], ["proof (state)\nthis:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n  map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         conv \\<odot> CNV callee s \\<sim>\n                         CNV (attach_wiring w callee) s", "also"], ["proof (state)\nthis:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n  map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         conv \\<odot> CNV callee s \\<sim>\n                         CNV (attach_wiring w callee) s", "have \"map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s = map_converter f g id id (CNV callee s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s =\n    map_converter f g id id (CNV callee s)", "by(subst comp_converter_map_converter1)(simp add: comp_converter_id_left)"], ["proof (state)\nthis:\n  map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s =\n  map_converter f g id id (CNV callee s)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         conv \\<odot> CNV callee s \\<sim>\n                         CNV (attach_wiring w callee) s", "also"], ["proof (state)\nthis:\n  map_converter id id f g 1\\<^sub>C \\<odot> CNV callee s =\n  map_converter f g id id (CNV callee s)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         conv \\<odot> CNV callee s \\<sim>\n                         CNV (attach_wiring w callee) s", "have \"\\<dots> = CNV (attach_wiring w callee) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter f g id id (CNV callee s) = CNV (attach_wiring w callee) s", "by(simp add: map_converter_of_callee attach_wiring_simps wiring(1) map_gpv_conv_map_gpv')"], ["proof (state)\nthis:\n  map_converter f g id id (CNV callee s) = CNV (attach_wiring w callee) s\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         conv \\<odot> CNV callee s \\<sim>\n                         CNV (attach_wiring w callee) s", "finally"], ["proof (chain)\npicking this:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n  CNV (attach_wiring w callee) s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n  CNV (attach_wiring w callee) s\n\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n    CNV (attach_wiring w callee) s", "."], ["proof (state)\nthis:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C conv \\<odot> CNV callee s \\<sim>\n  CNV (attach_wiring w callee) s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition comp_wiring :: \"('a, 'b, 'c, 'd) wiring \\<Rightarrow> ('c, 'd, 'e, 'f) wiring \\<Rightarrow> ('a, 'b, 'e, 'f) wiring\" (infixl \"\\<circ>\\<^sub>w\" 55)\n  where \"comp_wiring = (\\<lambda>(f, g) (f', g'). (f' \\<circ> f, g \\<circ> g'))\""], ["", "lemma comp_wiring_simps: \"comp_wiring (f, g) (f', g') = (f' \\<circ> f, g \\<circ> g')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<circ>\\<^sub>w (f', g') = (f' \\<circ> f, g \\<circ> g')", "by(simp add: comp_wiring_def)"], ["", "lemma wiring_comp_converterI [wiring_intro]:\n  \"wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')\" if \"wiring \\<I> \\<I>' conv1 fg\" \"wiring \\<I>' \\<I>'' conv2 fg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "from that(1)"], ["proof (chain)\npicking this:\n  wiring \\<I> \\<I>' conv1 fg", "obtain f g\n    where conv1: \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> map_converter id id f g 1\\<^sub>C\"\n      and WT1: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n      and [simp]: \"fg = (f, g)\""], ["proof (prove)\nusing this:\n  wiring \\<I> \\<I>' conv1 fg\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim>\n                 map_converter id id f g 1\\<^sub>C;\n         \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n         fg = (f, g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim>\n  map_converter id id f g 1\\<^sub>C\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  fg = (f, g)\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "from that(2)"], ["proof (chain)\npicking this:\n  wiring \\<I>' \\<I>'' conv2 fg'", "obtain f' g' \n    where conv2: \"\\<I>',\\<I>'' \\<turnstile>\\<^sub>C conv2 \\<sim> map_converter id id f' g' 1\\<^sub>C\"\n      and WT2: \"\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n      and [simp]: \"fg' = (f', g')\""], ["proof (prove)\nusing this:\n  wiring \\<I>' \\<I>'' conv2 fg'\n\ngoal (1 subgoal):\n 1. (\\<And>f' g'.\n        \\<lbrakk>\\<I>',\\<I>'' \\<turnstile>\\<^sub>C conv2 \\<sim>\n                 map_converter id id f' g' 1\\<^sub>C;\n         \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n         fg' = (f', g')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  \\<I>',\\<I>'' \\<turnstile>\\<^sub>C conv2 \\<sim>\n  map_converter id id f' g' 1\\<^sub>C\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  fg' = (f', g')\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "have *: \"(fg \\<circ>\\<^sub>w fg') = (f' \\<circ> f, g \\<circ> g')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fg \\<circ>\\<^sub>w fg' = (f' \\<circ> f, g \\<circ> g')", "by(simp add: comp_wiring_simps)"], ["proof (state)\nthis:\n  fg \\<circ>\\<^sub>w fg' = (f' \\<circ> f, g \\<circ> g')\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "have \"\\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim> map_converter id id f g 1\\<^sub>C \\<odot> map_converter id id f' g' 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim>\n    map_converter id id f g 1\\<^sub>C \\<odot>\n    map_converter id id f' g' 1\\<^sub>C", "using conv1 conv2"], ["proof (prove)\nusing this:\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim>\n  map_converter id id f g 1\\<^sub>C\n  \\<I>',\\<I>'' \\<turnstile>\\<^sub>C conv2 \\<sim>\n  map_converter id id f' g' 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim>\n    map_converter id id f g 1\\<^sub>C \\<odot>\n    map_converter id id f' g' 1\\<^sub>C", "by(rule eq_\\<I>_comp_cong)"], ["proof (state)\nthis:\n  \\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim>\n  map_converter id id f g 1\\<^sub>C \\<odot>\n  map_converter id id f' g' 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "also"], ["proof (state)\nthis:\n  \\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim>\n  map_converter id id f g 1\\<^sub>C \\<odot>\n  map_converter id id f' g' 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "have \"map_converter id id f g 1\\<^sub>C \\<odot> map_converter id id f' g' 1\\<^sub>C = map_converter id id (f' \\<circ> f) (g \\<circ> g') 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id f g 1\\<^sub>C \\<odot>\n    map_converter id id f' g' 1\\<^sub>C =\n    map_converter id id (f' \\<circ> f) (g \\<circ> g') 1\\<^sub>C", "by(simp add: comp_converter_map_converter2 comp_converter_id_right)"], ["proof (state)\nthis:\n  map_converter id id f g 1\\<^sub>C \\<odot>\n  map_converter id id f' g' 1\\<^sub>C =\n  map_converter id id (f' \\<circ> f) (g \\<circ> g') 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "also"], ["proof (state)\nthis:\n  map_converter id id f g 1\\<^sub>C \\<odot>\n  map_converter id id f' g' 1\\<^sub>C =\n  map_converter id id (f' \\<circ> f) (g \\<circ> g') 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "have \"\\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<surd>", "using WT1 WT2"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<surd>", "by(rule WT_converter_comp)"], ["proof (state)\nthis:\n  \\<I>, \\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "ultimately"], ["proof (chain)\npicking this:\n  \\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim>\n  map_converter id id (f' \\<circ> f) (g \\<circ> g') 1\\<^sub>C\n  \\<I>, \\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim>\n  map_converter id id (f' \\<circ> f) (g \\<circ> g') 1\\<^sub>C\n  \\<I>, \\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')", "unfolding *"], ["proof (prove)\nusing this:\n  \\<I>,\\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<sim>\n  map_converter id id (f' \\<circ> f) (g \\<circ> g') 1\\<^sub>C\n  \\<I>, \\<I>'' \\<turnstile>\\<^sub>C conv1 \\<odot> conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (f' \\<circ> f, g \\<circ> g')", ".."], ["proof (state)\nthis:\n  wiring \\<I> \\<I>'' (conv1 \\<odot> conv2) (fg \\<circ>\\<^sub>w fg')\n\ngoal:\nNo subgoals!", "qed"], ["", "definition parallel2_wiring\n  :: \"('a, 'b, 'c, 'd) wiring \\<Rightarrow> ('a', 'b', 'c', 'd') wiring\n   \\<Rightarrow> ('a + 'a', 'b + 'b', 'c + 'c', 'd + 'd') wiring\" (infix \"|\\<^sub>w\" 501) where\n  \"parallel2_wiring = (\\<lambda>(f, g) (f', g'). (map_sum f f', map_sum g g'))\""], ["", "lemma parallel2_wiring_simps:\n  \"parallel2_wiring (f, g) (f', g') = (map_sum f f', map_sum g g')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) |\\<^sub>w (f', g') = (map_sum f f', map_sum g g')", "by(simp add: parallel2_wiring_def)"], ["", "lemma wiring_parallel_converter2 [simp, wiring_intro]:\n  assumes \"wiring \\<I>1 \\<I>1' conv1 fg\"\n    and \"wiring \\<I>2 \\<I>2' conv2 fg'\"\n  shows \"wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2) (fg |\\<^sub>w fg')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "from assms(1)"], ["proof (chain)\npicking this:\n  wiring \\<I>1 \\<I>1' conv1 fg", "obtain f1 g1\n    where conv1: \"\\<I>1,\\<I>1' \\<turnstile>\\<^sub>C conv1 \\<sim> map_converter id id f1 g1 1\\<^sub>C\"\n      and WT1: \"\\<I>1, \\<I>1' \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n      and [simp]: \"fg = (f1, g1)\""], ["proof (prove)\nusing this:\n  wiring \\<I>1 \\<I>1' conv1 fg\n\ngoal (1 subgoal):\n 1. (\\<And>f1 g1.\n        \\<lbrakk>\\<I>1,\\<I>1' \\<turnstile>\\<^sub>C conv1 \\<sim>\n                 map_converter id id f1 g1 1\\<^sub>C;\n         \\<I>1, \\<I>1' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n         fg = (f1, g1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  \\<I>1,\\<I>1' \\<turnstile>\\<^sub>C conv1 \\<sim>\n  map_converter id id f1 g1 1\\<^sub>C\n  \\<I>1, \\<I>1' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  fg = (f1, g1)\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "from assms(2)"], ["proof (chain)\npicking this:\n  wiring \\<I>2 \\<I>2' conv2 fg'", "obtain f2 g2 \n    where conv2: \"\\<I>2,\\<I>2' \\<turnstile>\\<^sub>C conv2 \\<sim> map_converter id id f2 g2 1\\<^sub>C\"\n      and WT2: \"\\<I>2, \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n      and [simp]: \"fg' = (f2, g2)\""], ["proof (prove)\nusing this:\n  wiring \\<I>2 \\<I>2' conv2 fg'\n\ngoal (1 subgoal):\n 1. (\\<And>f2 g2.\n        \\<lbrakk>\\<I>2,\\<I>2' \\<turnstile>\\<^sub>C conv2 \\<sim>\n                 map_converter id id f2 g2 1\\<^sub>C;\n         \\<I>2, \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n         fg' = (f2, g2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  \\<I>2,\\<I>2' \\<turnstile>\\<^sub>C conv2 \\<sim>\n  map_converter id id f2 g2 1\\<^sub>C\n  \\<I>2, \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  fg' = (f2, g2)\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "from eq_\\<I>_converterD_WT1[OF conv1 WT1]"], ["proof (chain)\npicking this:\n  \\<I>1, \\<I>1' \\<turnstile>\\<^sub>C\n  map_converter id id f1 g1 1\\<^sub>C \\<surd>", "have \\<I>1: \"\\<I>1 \\<le> map_\\<I> f1 g1 \\<I>1'\""], ["proof (prove)\nusing this:\n  \\<I>1, \\<I>1' \\<turnstile>\\<^sub>C\n  map_converter id id f1 g1 1\\<^sub>C \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<le> map_\\<I> f1 g1 \\<I>1'", "by(rule WT_map_converter_idD)"], ["proof (state)\nthis:\n  \\<I>1 \\<le> map_\\<I> f1 g1 \\<I>1'\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "from eq_\\<I>_converterD_WT1[OF conv2 WT2]"], ["proof (chain)\npicking this:\n  \\<I>2, \\<I>2' \\<turnstile>\\<^sub>C\n  map_converter id id f2 g2 1\\<^sub>C \\<surd>", "have \\<I>2: \"\\<I>2 \\<le> map_\\<I> f2 g2 \\<I>2'\""], ["proof (prove)\nusing this:\n  \\<I>2, \\<I>2' \\<turnstile>\\<^sub>C\n  map_converter id id f2 g2 1\\<^sub>C \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>2 \\<le> map_\\<I> f2 g2 \\<I>2'", "by(rule WT_map_converter_idD)"], ["proof (state)\nthis:\n  \\<I>2 \\<le> map_\\<I> f2 g2 \\<I>2'\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "have WT': \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2,\n    \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n    map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C \\<surd>", "by(auto intro!: WT_converter_map_converter WT_converter_mono[OF WT_converter_id order_refl] \\<I>1 \\<I>2)"], ["proof (state)\nthis:\n  \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2,\n  \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C \\<surd>\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "have \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C conv1 |\\<^sub>= conv2 \\<sim> map_converter id id f1 g1 1\\<^sub>C |\\<^sub>= map_converter id id f2 g2 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n    conv1 |\\<^sub>= conv2 \\<sim>\n    map_converter id id f1 g1 1\\<^sub>C |\\<^sub>=\n    map_converter id id f2 g2 1\\<^sub>C", "using conv1 conv2"], ["proof (prove)\nusing this:\n  \\<I>1,\\<I>1' \\<turnstile>\\<^sub>C conv1 \\<sim>\n  map_converter id id f1 g1 1\\<^sub>C\n  \\<I>2,\\<I>2' \\<turnstile>\\<^sub>C conv2 \\<sim>\n  map_converter id id f2 g2 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n    conv1 |\\<^sub>= conv2 \\<sim>\n    map_converter id id f1 g1 1\\<^sub>C |\\<^sub>=\n    map_converter id id f2 g2 1\\<^sub>C", "by(rule parallel_converter2_eq_\\<I>_cong)"], ["proof (state)\nthis:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n  conv1 |\\<^sub>= conv2 \\<sim>\n  map_converter id id f1 g1 1\\<^sub>C |\\<^sub>=\n  map_converter id id f2 g2 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "also"], ["proof (state)\nthis:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n  conv1 |\\<^sub>= conv2 \\<sim>\n  map_converter id id f1 g1 1\\<^sub>C |\\<^sub>=\n  map_converter id id f2 g2 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "have \"map_converter id id f1 g1 1\\<^sub>C |\\<^sub>= map_converter id id f2 g2 1\\<^sub>C = (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id f1 g1 1\\<^sub>C |\\<^sub>=\n    map_converter id id f2 g2 1\\<^sub>C =\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n    map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C", "by(simp add: parallel_converter2_map2_out parallel_converter2_map1_out map_sum.comp sum.map_id0 comp_converter_map_converter2[of _ id id, simplified] comp_converter_id_right)"], ["proof (state)\nthis:\n  map_converter id id f1 g1 1\\<^sub>C |\\<^sub>=\n  map_converter id id f2 g2 1\\<^sub>C =\n  (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "also"], ["proof (state)\nthis:\n  map_converter id id f1 g1 1\\<^sub>C |\\<^sub>=\n  map_converter id id f2 g2 1\\<^sub>C =\n  (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "have \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C \\<dots> \\<sim> 1\\<^sub>C \\<odot> map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n    map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C \\<sim>\n    1\\<^sub>C \\<odot>\n    map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C", "by(rule eq_\\<I>_comp_cong[OF parallel_converter2_id_id])(rule eq_\\<I>_converter_reflI[OF WT'])"], ["proof (state)\nthis:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n  (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C \\<sim>\n  1\\<^sub>C \\<odot>\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "finally"], ["proof (chain)\npicking this:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n  conv1 |\\<^sub>= conv2 \\<sim>\n  1\\<^sub>C \\<odot>\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n  conv1 |\\<^sub>= conv2 \\<sim>\n  1\\<^sub>C \\<odot>\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "using WT1 WT2"], ["proof (prove)\nusing this:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n  conv1 |\\<^sub>= conv2 \\<sim>\n  1\\<^sub>C \\<odot>\n  map_converter id id (map_sum f1 f2) (map_sum g1 g2) 1\\<^sub>C\n  \\<I>1, \\<I>1' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>2, \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n     (fg |\\<^sub>w fg')", "by(auto simp add: parallel2_wiring_simps comp_converter_id_left intro!: wiringI WT_converter_parallel_converter2)"], ["proof (state)\nthis:\n  wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n   (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\n   (fg |\\<^sub>w fg')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_parallel2 [simp]:\n  \"apply_wiring (fg |\\<^sub>w fg') (res1 \\<oplus>\\<^sub>O res2) = (apply_wiring fg res1 \\<oplus>\\<^sub>O apply_wiring fg' res2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring (fg |\\<^sub>w fg') (res1 \\<oplus>\\<^sub>O res2) =\n    apply_wiring fg res1 \\<oplus>\\<^sub>O apply_wiring fg' res2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. apply_wiring (fg |\\<^sub>w fg') (res1 \\<oplus>\\<^sub>O res2) =\n    apply_wiring fg res1 \\<oplus>\\<^sub>O apply_wiring fg' res2", "have[simp]: \"fg = (f1, g1) \\<Longrightarrow> fg' = (f2, g2) \\<Longrightarrow>\n       map_spmf (map_prod (map_sum g1 g2) id) ((res1 \\<oplus>\\<^sub>O res2) s (map_sum f1 f2 q)) =\n       ((\\<lambda>s q. map_spmf (map_prod g1 id) (res1 s (f1 q))) \\<oplus>\\<^sub>O (\\<lambda>s q. map_spmf (map_prod g2 id) (res2 s (f2 q)))) s q\" for f1 g1 f2 g2 s q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fg = (f1, g1); fg' = (f2, g2)\\<rbrakk>\n    \\<Longrightarrow> map_spmf (map_prod (map_sum g1 g2) id)\n                       ((res1 \\<oplus>\\<^sub>O res2) s (map_sum f1 f2 q)) =\n                      ((\\<lambda>s q.\n                           map_spmf (map_prod g1 id)\n                            (res1 s (f1 q))) \\<oplus>\\<^sub>O\n                       (\\<lambda>s q.\n                           map_spmf (map_prod g2 id) (res2 s (f2 q))))\n                       s q", "by(cases q)(simp_all add: spmf.map_comp o_def apfst_def prod.map_comp split!:sum.splits)"], ["proof (state)\nthis:\n  \\<lbrakk>fg = (?f1.0, ?g1.0); fg' = (?f2.0, ?g2.0)\\<rbrakk>\n  \\<Longrightarrow> map_spmf (map_prod (map_sum ?g1.0 ?g2.0) id)\n                     ((res1 \\<oplus>\\<^sub>O res2) ?s\n                       (map_sum ?f1.0 ?f2.0 ?q)) =\n                    ((\\<lambda>s q.\n                         map_spmf (map_prod ?g1.0 id)\n                          (res1 s (?f1.0 q))) \\<oplus>\\<^sub>O\n                     (\\<lambda>s q.\n                         map_spmf (map_prod ?g2.0 id) (res2 s (?f2.0 q))))\n                     ?s ?q\n\ngoal (1 subgoal):\n 1. apply_wiring (fg |\\<^sub>w fg') (res1 \\<oplus>\\<^sub>O res2) =\n    apply_wiring fg res1 \\<oplus>\\<^sub>O apply_wiring fg' res2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring (fg |\\<^sub>w fg') (res1 \\<oplus>\\<^sub>O res2) =\n    apply_wiring fg res1 \\<oplus>\\<^sub>O apply_wiring fg' res2", "by(cases fg; cases fg') (clarsimp simp add: parallel2_wiring_simps apply_wiring_simps fun_eq_iff map_fun_def o_def)"], ["proof (state)\nthis:\n  apply_wiring (fg |\\<^sub>w fg') (res1 \\<oplus>\\<^sub>O res2) =\n  apply_wiring fg res1 \\<oplus>\\<^sub>O apply_wiring fg' res2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_comp_wiring [simp]: \"apply_wiring (fg \\<circ>\\<^sub>w fg') res = apply_wiring fg (apply_wiring fg' res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring (fg \\<circ>\\<^sub>w fg') res =\n    apply_wiring fg (apply_wiring fg' res)", "by(cases fg; cases fg')(simp add: comp_wiring_simps apply_wiring_simps map_fun_def fun_eq_iff spmf.map_comp prod.map_comp o_def id_def)"], ["", "definition lassocr\\<^sub>w :: \"(('a + 'b) + 'c, ('d + 'e) + 'f, 'a + ('b + 'c), 'd + ('e + 'f)) wiring\" \n  where \"lassocr\\<^sub>w = (rsuml, lsumr)\""], ["", "definition rassocl\\<^sub>w :: \"('a + ('b + 'c), 'd + ('e + 'f), ('a + 'b) + 'c, ('d + 'e) + 'f) wiring\" \n  where \"rassocl\\<^sub>w = (lsumr, rsuml)\""], ["", "definition swap\\<^sub>w :: \"('a + 'b, 'c + 'd, 'b + 'a, 'd + 'c) wiring\" where \n  \"swap\\<^sub>w = (swap_sum, swap_sum)\""], ["", "lemma wiring_lassocr [simp, wiring_intro]:\n  \"wiring ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) lassocr\\<^sub>C lassocr\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     lassocr\\<^sub>C lassocr\\<^sub>w", "unfolding lassocr\\<^sub>C_def lassocr\\<^sub>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     (map_converter rsuml lsumr id id 1\\<^sub>C) (rsuml, lsumr)", "by(subst map_converter_id_move_right)(auto intro!: wiringI eq_\\<I>_converter_reflI WT_converter_map_converter)"], ["", "lemma wiring_rassocl [simp, wiring_intro]:\n  \"wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) rassocl\\<^sub>C rassocl\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     rassocl\\<^sub>C rassocl\\<^sub>w", "unfolding rassocl\\<^sub>C_def rassocl\\<^sub>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     (map_converter lsumr rsuml id id 1\\<^sub>C) (lsumr, rsuml)", "by(subst map_converter_id_move_right)(auto intro!: wiringI eq_\\<I>_converter_reflI WT_converter_map_converter)"], ["", "lemma wiring_swap [simp, wiring_intro]: \"wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C swap\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C swap\\<^sub>w", "unfolding swap\\<^sub>C_def swap\\<^sub>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1)\n     (map_converter swap_sum swap_sum id id 1\\<^sub>C) (swap_sum, swap_sum)", "by(subst map_converter_id_move_right)(auto intro!: wiringI eq_\\<I>_converter_reflI WT_converter_map_converter)"], ["", "lemma apply_lassocr\\<^sub>w [simp]: \"apply_wiring lassocr\\<^sub>w (res1 \\<oplus>\\<^sub>O res2 \\<oplus>\\<^sub>O res3) = (res1 \\<oplus>\\<^sub>O res2) \\<oplus>\\<^sub>O res3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring lassocr\\<^sub>w\n     (res1 \\<oplus>\\<^sub>O res2 \\<oplus>\\<^sub>O res3) =\n    (res1 \\<oplus>\\<^sub>O res2) \\<oplus>\\<^sub>O res3", "by(simp add: apply_wiring_def lassocr\\<^sub>w_def map_rsuml_plus_oracle)"], ["", "lemma apply_rassocl\\<^sub>w [simp]: \"apply_wiring rassocl\\<^sub>w ((res1 \\<oplus>\\<^sub>O res2) \\<oplus>\\<^sub>O res3) = res1 \\<oplus>\\<^sub>O res2 \\<oplus>\\<^sub>O res3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring rassocl\\<^sub>w\n     ((res1 \\<oplus>\\<^sub>O res2) \\<oplus>\\<^sub>O res3) =\n    res1 \\<oplus>\\<^sub>O res2 \\<oplus>\\<^sub>O res3", "by(simp add: apply_wiring_def rassocl\\<^sub>w_def map_lsumr_plus_oracle)"], ["", "lemma apply_swap\\<^sub>w [simp]: \"apply_wiring swap\\<^sub>w (res1 \\<oplus>\\<^sub>O res2) = res2 \\<oplus>\\<^sub>O res1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring swap\\<^sub>w (res1 \\<oplus>\\<^sub>O res2) =\n    res2 \\<oplus>\\<^sub>O res1", "by(simp add: apply_wiring_def swap\\<^sub>w_def map_swap_sum_plus_oracle)"], ["", "end"]]}