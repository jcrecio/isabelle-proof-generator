{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Random_System.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma trace_callee_eqI:\n  assumes \"\\<And>xs x. \\<lbrakk> set xs \\<subseteq> A \\<times> UNIV; x \\<in> A \\<rbrakk>\n    \\<Longrightarrow> trace_callee callee1 p xs x = trace_callee callee2 q xs x\"\n  shows \"trace_callee_eq callee1 callee2 A p q\"", "lemma trace_callee_eqD:\n  assumes \"trace_callee_eq callee1 callee2 A p q\"\n    and \"set xs \\<subseteq> A \\<times> UNIV\" \"x \\<in> A\"\n  shows \"trace_callee callee1 p xs x = trace_callee callee2 q xs x\"", "lemma cond_spmf_fst_None [simp]: \"cond_spmf_fst (return_pmf None) x = return_pmf None\"", "lemma trace_callee_None [simp]:\n  \"trace_callee callee (return_pmf None) xs x = return_pmf None\"", "lemma trace_callee_conv_trace_callee_aux:\n  \"trace_callee callee p xs a = bind_spmf (trace_callee_aux callee p xs) (\\<lambda>s. map_spmf fst (callee s a))\"", "lemma trace_callee_aux_append:\n  \"trace_callee_aux callee p (xs @ ys) = trace_callee_aux callee (trace_callee_aux callee p xs) ys\"", "lemma trace_callee_closure_start: \"trace_callee_closure callee1 callee2 A p q p q\"", "lemma trace_callee_closure_step:\n  assumes \"trace_callee_eq callee1 callee2 A p q\"\n    and \"trace_callee_closure callee1 callee2 A p q p' q'\"\n    and \"a \\<in> A\"\n  shows \"bind_spmf p' (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q' (\\<lambda>s. map_spmf fst (callee2 s a))\"", "lemma trace_callee_closure_sim:\n  assumes \"trace_callee_closure callee1 callee2 A p q p' q'\"\n    and \"a \\<in> A\"\n  shows \"trace_callee_closure callee1 callee2 A p q\n     (cond_spmf_fst (bind_spmf p' (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (bind_spmf q' (\\<lambda>s. callee2 s a)) b)\"", "lemma set_spmf_cond_spmf_fst: \"set_spmf (cond_spmf_fst p a) = snd ` (set_spmf p \\<inter> {a} \\<times> UNIV)\"", "lemma trace_callee_eq_run_gpv:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes trace_eq: \"trace_callee_eq callee1 callee2 A p q\"\n    and inv1: \"callee_invariant_on callee1 I1 \\<I>\"\n    and inv1: \"callee_invariant_on callee2 I2 \\<I>\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and out: \"outs_gpv \\<I> gpv \\<subseteq> A\"\n    and pq: \"lossless_spmf p\" \"lossless_spmf q\"\n    and I1: \"\\<forall>x\\<in>set_spmf p. I1 x\"\n    and I2: \"\\<forall>y\\<in>set_spmf q. I2 y\"\n  shows \"bind_spmf p (run_gpv callee1 gpv) = bind_spmf q (run_gpv callee2 gpv)\"", "lemma trace_callee_eq'_run_gpv:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes trace_eq: \"A \\<turnstile>\\<^sub>C callee1(s1) \\<approx> callee2(s2)\"\n    and inv1: \"callee_invariant_on callee1 I1 \\<I>\"\n    and inv1: \"callee_invariant_on callee2 I2 \\<I>\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and out: \"outs_gpv \\<I> gpv \\<subseteq> A\"\n    and I1: \"I1 s1\"\n    and I2: \"I2 s2\"\n  shows \"run_gpv callee1 gpv s1 = run_gpv callee2 gpv s2\"", "lemma trace_callee_resource_of_oracle2:\n  \"trace_callee run_resource (map_spmf (resource_of_oracle callee) p) xs x =\n   trace_callee callee p xs x\"", "lemma trace_callee_resource_of_oracle [simp]:\n  \"trace_callee run_resource (return_spmf (resource_of_oracle callee s)) xs x =\n   trace_callee callee (return_spmf s) xs x\"", "lemma trace_eq'_resource_of_oracle [simp]:\n  \"A \\<turnstile>\\<^sub>R resource_of_oracle callee1 s1 \\<approx> resource_of_oracle callee2 s2 =\n   A \\<turnstile>\\<^sub>C callee1(s1) \\<approx> callee2(s2)\""], "translations": [["", "lemma trace_callee_eqI:\n  assumes \"\\<And>xs x. \\<lbrakk> set xs \\<subseteq> A \\<times> UNIV; x \\<in> A \\<rbrakk>\n    \\<Longrightarrow> trace_callee callee1 p xs x = trace_callee callee2 q xs x\"\n  shows \"trace_callee_eq callee1 callee2 A p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?xs \\<subseteq> A \\<times> UNIV; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> trace_callee callee1 p ?xs ?x =\n                    trace_callee callee2 q ?xs ?x\n\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "by(simp add: trace_callee_eq_def)"], ["", "lemma trace_callee_eqD:\n  assumes \"trace_callee_eq callee1 callee2 A p q\"\n    and \"set xs \\<subseteq> A \\<times> UNIV\" \"x \\<in> A\"\n  shows \"trace_callee callee1 p xs x = trace_callee callee2 q xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee1 p xs x = trace_callee callee2 q xs x", "using assms"], ["proof (prove)\nusing this:\n  trace_callee_eq callee1 callee2 A p q\n  set xs \\<subseteq> A \\<times> UNIV\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p xs x = trace_callee callee2 q xs x", "by(simp add: trace_callee_eq_def)"], ["", "lemma cond_spmf_fst_None [simp]: \"cond_spmf_fst (return_pmf None) x = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (return_pmf None) x = return_pmf None", "by(simp)"], ["", "lemma trace_callee_None [simp]:\n  \"trace_callee callee (return_pmf None) xs x = return_pmf None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee (return_pmf None) xs x = return_pmf None", "by(induction xs)(auto)"], ["", "proposition trace'_eqI_sim:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes start: \"S p q\"\n    and step: \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and sim: \"\\<And>p q a res b s'. \\<lbrakk> S p q; a \\<in> A; res \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res a) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\"\n  shows \"trace_callee_eq callee1 callee2 A p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "proof(rule trace_callee_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p xs x =\n                         trace_callee callee2 q xs x", "fix xs :: \"('a \\<times> 'b) list\" and z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p xs x =\n                         trace_callee callee2 q xs x", "assume xs: \"set xs \\<subseteq> A \\<times> UNIV\" and z: \"z \\<in> A\""], ["proof (state)\nthis:\n  set xs \\<subseteq> A \\<times> UNIV\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p xs x =\n                         trace_callee callee2 q xs x", "from start"], ["proof (chain)\npicking this:\n  S p q", "show \"trace_callee callee1 p xs z = trace_callee callee2 q xs z\""], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p xs z = trace_callee callee2 q xs z", "using xs"], ["proof (prove)\nusing this:\n  S p q\n  set xs \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p xs z = trace_callee callee2 q xs z", "proof(induction xs arbitrary: p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>S p q; set [] \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p [] z =\n                         trace_callee callee2 q [] z\n 2. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "case Nil"], ["proof (state)\nthis:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>S p q; set [] \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p [] z =\n                         trace_callee callee2 q [] z\n 2. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "then"], ["proof (chain)\npicking this:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p [] z = trace_callee callee2 q [] z", "using z"], ["proof (prove)\nusing this:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p [] z = trace_callee callee2 q [] z", "by(simp add: step)"], ["proof (state)\nthis:\n  trace_callee callee1 p [] z = trace_callee callee2 q [] z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "case (Cons xy xs)"], ["proof (state)\nthis:\n  \\<lbrakk>S ?p ?q; set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n  \\<Longrightarrow> trace_callee callee1 ?p xs z =\n                    trace_callee callee2 ?q xs z\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "obtain x y where xy [simp]: \"xy = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. xy = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xy)"], ["proof (state)\nthis:\n  xy = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "have \"trace_callee callee1 p (xy # xs) z = \n      trace_callee callee1 (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y) xs z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee1 p (xy # xs) z =\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z", "by(simp add: bind_map_spmf split_def o_def)"], ["proof (state)\nthis:\n  trace_callee callee1 p (xy # xs) z =\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "also"], ["proof (state)\nthis:\n  trace_callee callee1 p (xy # xs) z =\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "have \"\\<dots> = trace_callee callee2 (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y) xs z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "proof(cases \"\\<exists>s \\<in> set_spmf q. \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "case True"], ["proof (state)\nthis:\n  \\<exists>s\\<in>set_spmf q.\n     \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)\n\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "then"], ["proof (chain)\npicking this:\n  \\<exists>s\\<in>set_spmf q.\n     \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)", "obtain s s' where \"s \\<in> set_spmf q\" \"(y, s') \\<in> set_spmf (callee2 s x)\""], ["proof (prove)\nusing this:\n  \\<exists>s\\<in>set_spmf q.\n     \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)\n\ngoal (1 subgoal):\n 1. (\\<And>s s'.\n        \\<lbrakk>s \\<in> set_spmf q;\n         (y, s') \\<in> set_spmf (callee2 s x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> set_spmf q\n  (y, s') \\<in> set_spmf (callee2 s x)\n\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "from sim[OF \\<open>S p q\\<close> _ this]"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Longrightarrow>\n  S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow>\n  S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y)\n\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "using Cons.prems"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow>\n  S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y)\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "by (auto intro: Cons.IH)"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))", "have \"cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y = return_pmf None\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None", "by(auto simp add: bind_eq_return_pmf_None)"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "from step[OF \\<open>S p q\\<close>, of x, THEN arg_cong[where f=set_spmf], THEN eq_refl] Cons.prems False"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Longrightarrow>\n  set_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s x)))\n  \\<subseteq> set_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s x)))\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))", "have \"cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y = return_pmf None\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow>\n  set_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s x)))\n  \\<subseteq> set_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s x)))\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None", "by(clarsimp simp add: bind_eq_return_pmf_None)(rule ccontr; fastforce)"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "ultimately"], ["proof (chain)\npicking this:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "by(simp del: cond_spmf_fst_eq_return_None)"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "also"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "have \"\\<dots> = trace_callee callee2 q (xy # xs) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z =\n    trace_callee callee2 q (xy # xs) z", "by(simp add: split_def o_def)"], ["proof (state)\nthis:\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z =\n  trace_callee callee2 q (xy # xs) z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "finally"], ["proof (chain)\npicking this:\n  trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z", "show ?case"], ["proof (prove)\nusing this:\n  trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z", "."], ["proof (state)\nthis:\n  trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_callee callee1 p xs z = trace_callee callee2 q xs z\n\ngoal:\nNo subgoals!", "qed"], ["", "fun trace_callee_aux :: \"('a, 'b, 's) callee \\<Rightarrow> 's spmf \\<Rightarrow> ('a \\<times> 'b) list \\<Rightarrow> 's spmf\" where\n  \"trace_callee_aux callee p [] = p\"\n| \"trace_callee_aux callee p ((x, y) # xs) = trace_callee_aux callee (cond_spmf_fst (bind_spmf p (\\<lambda>res. callee res x)) y) xs\""], ["", "lemma trace_callee_conv_trace_callee_aux:\n  \"trace_callee callee p xs a = bind_spmf (trace_callee_aux callee p xs) (\\<lambda>s. map_spmf fst (callee s a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee p xs a =\n    trace_callee_aux callee p xs \\<bind>\n    (\\<lambda>s. map_spmf fst (callee s a))", "by(induction xs arbitrary: p)(auto simp add: split_def)"], ["", "lemma trace_callee_aux_append:\n  \"trace_callee_aux callee p (xs @ ys) = trace_callee_aux callee (trace_callee_aux callee p xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_aux callee p (xs @ ys) =\n    trace_callee_aux callee (trace_callee_aux callee p xs) ys", "by(induction xs arbitrary: p)(auto simp add: split_def)"], ["", "inductive trace_callee_closure :: \"('a, 'b, 's1) callee \\<Rightarrow> ('a, 'b, 's2) callee \\<Rightarrow> 'a set \\<Rightarrow> 's1 spmf \\<Rightarrow> 's2 spmf \\<Rightarrow> 's1 spmf \\<Rightarrow> 's2 spmf \\<Rightarrow> bool\"\n  for callee1 callee2 A p q where\n    \"trace_callee_closure callee1 callee2 A p q (trace_callee_aux callee1 p xs) (trace_callee_aux callee2 q xs)\" if \"set xs \\<subseteq> A \\<times> UNIV\""], ["", "lemma trace_callee_closure_start: \"trace_callee_closure callee1 callee2 A p q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_closure callee1 callee2 A p q p q", "by(simp add: trace_callee_closure.simps exI[where x=\"[]\"])"], ["", "lemma trace_callee_closure_step:\n  assumes \"trace_callee_eq callee1 callee2 A p q\"\n    and \"trace_callee_closure callee1 callee2 A p q p' q'\"\n    and \"a \\<in> A\"\n  shows \"bind_spmf p' (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q' (\\<lambda>s. map_spmf fst (callee2 s a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q' \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p' \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q' \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))", "from assms(2)"], ["proof (chain)\npicking this:\n  trace_callee_closure callee1 callee2 A p q p' q'", "obtain xs where xs: \"set xs \\<subseteq> A \\<times> UNIV\" \n    and p: \"p' = trace_callee_aux callee1 p xs\" and q: \"q' = trace_callee_aux callee2 q xs\""], ["proof (prove)\nusing this:\n  trace_callee_closure callee1 callee2 A p q p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV;\n         p' = trace_callee_aux callee1 p xs;\n         q' = trace_callee_aux callee2 q xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases)"], ["proof (state)\nthis:\n  set xs \\<subseteq> A \\<times> UNIV\n  p' = trace_callee_aux callee1 p xs\n  q' = trace_callee_aux callee2 q xs\n\ngoal (1 subgoal):\n 1. p' \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q' \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))", "from trace_callee_eqD[OF assms(1) xs assms(3)] p q"], ["proof (chain)\npicking this:\n  trace_callee callee1 p xs a = trace_callee callee2 q xs a\n  p' = trace_callee_aux callee1 p xs\n  q' = trace_callee_aux callee2 q xs", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_callee callee1 p xs a = trace_callee callee2 q xs a\n  p' = trace_callee_aux callee1 p xs\n  q' = trace_callee_aux callee2 q xs\n\ngoal (1 subgoal):\n 1. p' \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q' \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))", "by(simp add: trace_callee_conv_trace_callee_aux)"], ["proof (state)\nthis:\n  p' \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n  q' \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_callee_closure_sim:\n  assumes \"trace_callee_closure callee1 callee2 A p q p' q'\"\n    and \"a \\<in> A\"\n  shows \"trace_callee_closure callee1 callee2 A p q\n     (cond_spmf_fst (bind_spmf p' (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (bind_spmf q' (\\<lambda>s. callee2 s a)) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_closure callee1 callee2 A p q\n     (cond_spmf_fst (p' \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s. callee2 s a)) b)", "using assms"], ["proof (prove)\nusing this:\n  trace_callee_closure callee1 callee2 A p q p' q'\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. trace_callee_closure callee1 callee2 A p q\n     (cond_spmf_fst (p' \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s. callee2 s a)) b)", "proof (cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>a \\<in> A; p' = trace_callee_aux callee1 p xs;\n        q' = trace_callee_aux callee2 q xs;\n        set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee_closure callee1 callee2 A p q\n                          (cond_spmf_fst\n                            (p' \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q' \\<bind> (\\<lambda>s. callee2 s a)) b)", "case (1 xs)"], ["proof (state)\nthis:\n  p' = trace_callee_aux callee1 p xs\n  q' = trace_callee_aux callee2 q xs\n  set xs \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>a \\<in> A; p' = trace_callee_aux callee1 p xs;\n        q' = trace_callee_aux callee2 q xs;\n        set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee_closure callee1 callee2 A p q\n                          (cond_spmf_fst\n                            (p' \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q' \\<bind> (\\<lambda>s. callee2 s a)) b)", "then"], ["proof (chain)\npicking this:\n  p' = trace_callee_aux callee1 p xs\n  q' = trace_callee_aux callee2 q xs\n  set xs \\<subseteq> A \\<times> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  p' = trace_callee_aux callee1 p xs\n  q' = trace_callee_aux callee2 q xs\n  set xs \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. trace_callee_closure callee1 callee2 A p q\n     (cond_spmf_fst (p' \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s. callee2 s a)) b)", "by \n      (auto simp add:trace_callee_closure.simps assms trace_callee_aux_append split_def map_spmf_conv_bind_spmf intro!: exI[where x=\"xs @ [(a, b)]\"])"], ["proof (state)\nthis:\n  trace_callee_closure callee1 callee2 A p q\n   (cond_spmf_fst (p' \\<bind> (\\<lambda>s. callee1 s a)) b)\n   (cond_spmf_fst (q' \\<bind> (\\<lambda>s. callee2 s a)) b)\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition trace_callee_eq_complete:\n  assumes \"trace_callee_eq callee1 callee2 A p q\"\n  obtains S\n  where \"S p q\"                          \n    and \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and \"\\<And>p q a s b s'. \\<lbrakk> S p q; a \\<in> A; s \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 s a) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S p q;\n         \\<And>p q a.\n            \\<lbrakk>S p q; a \\<in> A\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s. map_spmf fst (callee1 s a)) =\n                              q \\<bind>\n                              (\\<lambda>s. map_spmf fst (callee2 s a));\n         \\<And>p q a s b s'.\n            \\<lbrakk>S p q; a \\<in> A; s \\<in> set_spmf q;\n             (b, s') \\<in> set_spmf (callee2 s a)\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                               (cond_spmf_fst\n                                 (q \\<bind> (\\<lambda>s. callee2 s a))\n                                 b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule that[where S=\"trace_callee_closure callee1 callee2 A p q\"])\n    (auto intro: trace_callee_closure_start trace_callee_closure_step[OF assms] trace_callee_closure_sim)"], ["", "lemma set_spmf_cond_spmf_fst: \"set_spmf (cond_spmf_fst p a) = snd ` (set_spmf p \\<inter> {a} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (cond_spmf_fst p a) =\n    snd ` (set_spmf p \\<inter> {a} \\<times> UNIV)", "by(simp add: cond_spmf_fst_def)"], ["", "lemma trace_callee_eq_run_gpv:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes trace_eq: \"trace_callee_eq callee1 callee2 A p q\"\n    and inv1: \"callee_invariant_on callee1 I1 \\<I>\"\n    and inv1: \"callee_invariant_on callee2 I2 \\<I>\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and out: \"outs_gpv \\<I> gpv \\<subseteq> A\"\n    and pq: \"lossless_spmf p\" \"lossless_spmf q\"\n    and I1: \"\\<forall>x\\<in>set_spmf p. I1 x\"\n    and I2: \"\\<forall>y\\<in>set_spmf q. I2 y\"\n  shows \"bind_spmf p (run_gpv callee1 gpv) = bind_spmf q (run_gpv callee2 gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> run_gpv callee1 gpv = q \\<bind> run_gpv callee2 gpv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bind> run_gpv callee1 gpv = q \\<bind> run_gpv callee2 gpv", "from trace_eq"], ["proof (chain)\npicking this:\n  trace_callee_eq callee1 callee2 A p q", "obtain S where start: \"S p q\"\n    and sim: \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and S: \"\\<And>p q a s b s'. \\<lbrakk> S p q; a \\<in> A; s \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 s a) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\""], ["proof (prove)\nusing this:\n  trace_callee_eq callee1 callee2 A p q\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S p q;\n         \\<And>p q a.\n            \\<lbrakk>S p q; a \\<in> A\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s. map_spmf fst (callee1 s a)) =\n                              q \\<bind>\n                              (\\<lambda>s. map_spmf fst (callee2 s a));\n         \\<And>p q a s b s'.\n            \\<lbrakk>S p q; a \\<in> A; s \\<in> set_spmf q;\n             (b, s') \\<in> set_spmf (callee2 s a)\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                               (cond_spmf_fst\n                                 (q \\<bind> (\\<lambda>s. callee2 s a))\n                                 b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule trace_callee_eq_complete) blast"], ["proof (state)\nthis:\n  S p q\n  \\<lbrakk>S ?p ?q; ?a \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s ?a)) =\n                    ?q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s ?a))\n  \\<lbrakk>S ?p ?q; ?a \\<in> A; ?s \\<in> set_spmf ?q;\n   (?b, ?s') \\<in> set_spmf (callee2 ?s ?a)\\<rbrakk>\n  \\<Longrightarrow> S (cond_spmf_fst (?p \\<bind> (\\<lambda>s. callee1 s ?a))\n                        ?b)\n                     (cond_spmf_fst (?q \\<bind> (\\<lambda>s. callee2 s ?a))\n                       ?b)\n\ngoal (1 subgoal):\n 1. p \\<bind> run_gpv callee1 gpv = q \\<bind> run_gpv callee2 gpv", "interpret I1: callee_invariant_on callee1 I1 \\<I>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on callee1 I1 \\<I>", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bind> run_gpv callee1 gpv = q \\<bind> run_gpv callee2 gpv", "interpret I2: callee_invariant_on callee2 I2 \\<I>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on callee2 I2 \\<I>", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<bind> run_gpv callee1 gpv = q \\<bind> run_gpv callee2 gpv", "from \\<open>S p q\\<close> out pq WT I1 I2"], ["proof (chain)\npicking this:\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>x\\<in>set_spmf p. I1 x\n  \\<forall>y\\<in>set_spmf q. I2 y", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>x\\<in>set_spmf p. I1 x\n  \\<forall>y\\<in>set_spmf q. I2 y\n\ngoal (1 subgoal):\n 1. p \\<bind> run_gpv callee1 gpv = q \\<bind> run_gpv callee2 gpv", "proof(induction arbitrary: p q gpv rule: parallel_fixp_induct_2_2[OF partial_function_definitions_spmf partial_function_definitions_spmf exec_gpv.mono exec_gpv.mono exec_gpv_def exec_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            S xa xb \\<longrightarrow>\n            (\\<forall>xc.\n                outs_gpv \\<I> xc \\<subseteq> A \\<longrightarrow>\n                lossless_spmf xa \\<longrightarrow>\n                lossless_spmf xb \\<longrightarrow>\n                \\<I> \\<turnstile>g xc \\<surd> \\<longrightarrow>\n                Ball (set_spmf xa) I1 \\<longrightarrow>\n                Ball (set_spmf xb) I2 \\<longrightarrow>\n                xa \\<bind> (\\<lambda>s. map_spmf fst (curry (fst x) xc s)) =\n                xb \\<bind> (\\<lambda>s. map_spmf fst (curry (snd x) xc s))))\n 2. \\<And>p q gpv.\n       \\<lbrakk>S p q; outs_gpv \\<I> gpv \\<subseteq> A; lossless_spmf p;\n        lossless_spmf q; \\<I> \\<turnstile>g gpv \\<surd>;\n        Ball (set_spmf p) I1; Ball (set_spmf q) I2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (lub_spmf {})) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (lub_spmf {}))\n 3. \\<And>f g p q gpv.\n       \\<lbrakk>\\<And>p q gpv.\n                   \\<lbrakk>S p q; outs_gpv \\<I> gpv \\<subseteq> A;\n                    lossless_spmf p; lossless_spmf q;\n                    \\<I> \\<turnstile>g gpv \\<surd>; Ball (set_spmf p) I1;\n                    Ball (set_spmf q) I2\\<rbrakk>\n                   \\<Longrightarrow> p \\<bind>\n                                     (\\<lambda>s. map_spmf fst (f gpv s)) =\n                                     q \\<bind>\n                                     (\\<lambda>s. map_spmf fst (g gpv s));\n        S p q; outs_gpv \\<I> gpv \\<subseteq> A; lossless_spmf p;\n        lossless_spmf q; \\<I> \\<turnstile>g gpv \\<surd>;\n        Ball (set_spmf p) I1; Ball (set_spmf q) I2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              (the_gpv gpv \\<bind>\n                               case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    callee1 s out \\<bind>\n                                    (\\<lambda>(x, y). f (c x) y)))) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              (the_gpv gpv \\<bind>\n                               case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    callee2 s out \\<bind>\n                                    (\\<lambda>(x, y). g (c x) y))))", "case (step exec_gpv' g)"], ["proof (state)\nthis:\n  \\<lbrakk>S ?p ?q; outs_gpv \\<I> ?gpv \\<subseteq> A; lossless_spmf ?p;\n   lossless_spmf ?q; \\<I> \\<turnstile>g ?gpv \\<surd>;\n   \\<forall>a\\<in>set_spmf ?p. I1 a;\n   \\<forall>a\\<in>set_spmf ?q. I2 a\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind>\n                    (\\<lambda>s. map_spmf fst (exec_gpv' ?gpv s)) =\n                    ?q \\<bind> (\\<lambda>s. map_spmf fst (g ?gpv s))\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>a\\<in>set_spmf p. I1 a\n  \\<forall>a\\<in>set_spmf q. I2 a\n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            S xa xb \\<longrightarrow>\n            (\\<forall>xc.\n                outs_gpv \\<I> xc \\<subseteq> A \\<longrightarrow>\n                lossless_spmf xa \\<longrightarrow>\n                lossless_spmf xb \\<longrightarrow>\n                \\<I> \\<turnstile>g xc \\<surd> \\<longrightarrow>\n                Ball (set_spmf xa) I1 \\<longrightarrow>\n                Ball (set_spmf xb) I2 \\<longrightarrow>\n                xa \\<bind> (\\<lambda>s. map_spmf fst (curry (fst x) xc s)) =\n                xb \\<bind> (\\<lambda>s. map_spmf fst (curry (snd x) xc s))))\n 2. \\<And>p q gpv.\n       \\<lbrakk>S p q; outs_gpv \\<I> gpv \\<subseteq> A; lossless_spmf p;\n        lossless_spmf q; \\<I> \\<turnstile>g gpv \\<surd>;\n        Ball (set_spmf p) I1; Ball (set_spmf q) I2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (lub_spmf {})) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (lub_spmf {}))\n 3. \\<And>f g p q gpv.\n       \\<lbrakk>\\<And>p q gpv.\n                   \\<lbrakk>S p q; outs_gpv \\<I> gpv \\<subseteq> A;\n                    lossless_spmf p; lossless_spmf q;\n                    \\<I> \\<turnstile>g gpv \\<surd>; Ball (set_spmf p) I1;\n                    Ball (set_spmf q) I2\\<rbrakk>\n                   \\<Longrightarrow> p \\<bind>\n                                     (\\<lambda>s. map_spmf fst (f gpv s)) =\n                                     q \\<bind>\n                                     (\\<lambda>s. map_spmf fst (g gpv s));\n        S p q; outs_gpv \\<I> gpv \\<subseteq> A; lossless_spmf p;\n        lossless_spmf q; \\<I> \\<turnstile>g gpv \\<surd>;\n        Ball (set_spmf p) I1; Ball (set_spmf q) I2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              (the_gpv gpv \\<bind>\n                               case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    callee1 s out \\<bind>\n                                    (\\<lambda>(x, y). f (c x) y)))) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              (the_gpv gpv \\<bind>\n                               case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    callee2 s out \\<bind>\n                                    (\\<lambda>(x, y). g (c x) y))))", "have[simp]: \"generat \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n         p \\<bind> (\\<lambda>xa. map_spmf fst (case generat of \n             Pure x \\<Rightarrow> return_spmf (x, xa)\n           | IO out c \\<Rightarrow> callee1 xa out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n         q \\<bind> (\\<lambda>xa. map_spmf fst (case generat of \n             Pure x \\<Rightarrow> return_spmf (x, xa)\n           | IO out c \\<Rightarrow> callee2 xa out \\<bind> (\\<lambda>(x, y). g (c x) y)))\" for generat"], ["proof (prove)\ngoal (1 subgoal):\n 1. generat \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n    p \\<bind>\n    (\\<lambda>xa.\n        map_spmf fst\n         (case generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n          | IO out c \\<Rightarrow>\n              callee1 xa out \\<bind>\n              (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n    q \\<bind>\n    (\\<lambda>xa.\n        map_spmf fst\n         (case generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n          | IO out c \\<Rightarrow>\n              callee2 xa out \\<bind> (\\<lambda>(x, y). g (c x) y)))", "proof (cases generat, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = Pure x1\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = IO x21 x22\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))", "case (2 out rpv)"], ["proof (state)\nthis:\n  generat \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = Pure x1\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = IO x21 x22\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))", "have [simp]: \"IO out rpv \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow> generat = IO out rpv \\<Longrightarrow>\n        map_spmf fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) = map_spmf fst (q \\<bind> (\\<lambda>xa. callee2 xa out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv);\n     generat = IO out rpv\\<rbrakk>\n    \\<Longrightarrow> map_spmf fst\n                       (p \\<bind> (\\<lambda>xa. callee1 xa out)) =\n                      map_spmf fst (q \\<bind> (\\<lambda>xa. callee2 xa out))", "unfolding map_bind_spmf o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv);\n     generat = IO out rpv\\<rbrakk>\n    \\<Longrightarrow> p \\<bind> (\\<lambda>x. map_spmf fst (callee1 x out)) =\n                      q \\<bind> (\\<lambda>x. map_spmf fst (callee2 x out))", "by (rule sim) (use step.prems in \\<open>auto intro: outs_gpv.IO\\<close>)"], ["proof (state)\nthis:\n  \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv);\n   generat = IO out rpv\\<rbrakk>\n  \\<Longrightarrow> map_spmf fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) =\n                    map_spmf fst (q \\<bind> (\\<lambda>xa. callee2 xa out))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = Pure x1\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = IO x21 x22\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))", "have[simp]: \"\\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv; x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk> \\<Longrightarrow>\n       cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a \\<bind> (\\<lambda>x. map_spmf fst (exec_gpv' (rpv a) x)) =\n       cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a \\<bind> (\\<lambda>x. map_spmf fst (g (rpv a) x))\" for a b x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> cond_spmf_fst\n                       (p \\<bind> (\\<lambda>xa. callee1 xa out)) a \\<bind>\n                      (\\<lambda>x. map_spmf fst (exec_gpv' (rpv a) x)) =\n                      cond_spmf_fst\n                       (q \\<bind> (\\<lambda>xa. callee2 xa out)) a \\<bind>\n                      (\\<lambda>x. map_spmf fst (g (rpv a) x))", "proof (rule step.IH, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> outs_gpv \\<I> (rpv a) \\<subseteq> A\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 6. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 7. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "case 1"], ["proof (state)\nthis:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (7 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> outs_gpv \\<I> (rpv a) \\<subseteq> A\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 6. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 7. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "then"], ["proof (chain)\npicking this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)", "show ?case"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)", "using step.prems"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>a\\<in>set_spmf p. I1 a\n  \\<forall>a\\<in>set_spmf q. I2 a\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)", "by(auto intro!: S intro: outs_gpv.IO)"], ["proof (state)\nthis:\n  S (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> outs_gpv \\<I> (rpv a) \\<subseteq> A\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 6. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> outs_gpv \\<I> (rpv a) \\<subseteq> A\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 6. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "case 2"], ["proof (state)\nthis:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> outs_gpv \\<I> (rpv a) \\<subseteq> A\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 6. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "then"], ["proof (chain)\npicking this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)", "show ?case"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. outs_gpv \\<I> (rpv a) \\<subseteq> A", "using step.prems"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>a\\<in>set_spmf p. I1 a\n  \\<forall>a\\<in>set_spmf q. I2 a\n\ngoal (1 subgoal):\n 1. outs_gpv \\<I> (rpv a) \\<subseteq> A", "by(force intro: outs_gpv.Cont dest: WT_calleeD[OF I2.WT_callee] WT_gpvD[OF step.prems(5)])"], ["proof (state)\nthis:\n  outs_gpv \\<I> (rpv a) \\<subseteq> A\n\ngoal (5 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "case 3"], ["proof (state)\nthis:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 5. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "then"], ["proof (chain)\npicking this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)", "show ?case"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)", "using sim[OF \\<open>S p q\\<close>, of out] step.prems(2)"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n  out \\<in> A \\<Longrightarrow>\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s out)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s out))\n  outs_gpv \\<I> gpv \\<subseteq> A\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)", "by(force simp add: bind_UNION image_Union intro: rev_image_eqI intro: outs_gpv.IO dest: arg_cong[where f=\"set_spmf\"])"], ["proof (state)\nthis:\n  lossless_spmf (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "case 4"], ["proof (state)\nthis:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 4. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "then"], ["proof (chain)\npicking this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)", "show ?case"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)", "by(auto 4 3 simp add: bind_UNION image_Union intro: rev_image_eqI)"], ["proof (state)\nthis:\n  lossless_spmf (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "case 5"], ["proof (state)\nthis:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv a \\<surd>\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 3. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "then"], ["proof (chain)\npicking this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)", "show ?case"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g rpv a \\<surd>", "using step.prems"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>a\\<in>set_spmf p. I1 a\n  \\<forall>a\\<in>set_spmf q. I2 a\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g rpv a \\<surd>", "by(auto 4 3 dest: WT_calleeD[OF I2.WT_callee] intro: WT_gpvD)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g rpv a \\<surd>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "case 6"], ["proof (state)\nthis:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out)) a).\n                         I1 a\n 2. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "then"], ["proof (chain)\npicking this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)", "show ?case"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set_spmf\n                    (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out))\n                      a).\n       I1 a", "using step.prems"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>a\\<in>set_spmf p. I1 a\n  \\<forall>a\\<in>set_spmf q. I2 a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set_spmf\n                    (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out))\n                      a).\n       I1 a", "by(auto simp add: bind_UNION image_Union set_spmf_cond_spmf_fst intro: I1.callee_invariant WT_gpvD)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set_spmf\n                  (cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out))\n                    a).\n     I1 a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "case 7"], ["proof (state)\nthis:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n     x \\<in> set_spmf q; (a, b) \\<in> set_spmf (callee2 x out)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set_spmf\n(cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out)) a).\n                         I2 a", "then"], ["proof (chain)\npicking this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)", "show ?case"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set_spmf\n                    (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out))\n                      a).\n       I2 a", "using step.prems"], ["proof (prove)\nusing this:\n  IO out rpv \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n  x \\<in> set_spmf q\n  (a, b) \\<in> set_spmf (callee2 x out)\n  S p q\n  outs_gpv \\<I> gpv \\<subseteq> A\n  lossless_spmf p\n  lossless_spmf q\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>a\\<in>set_spmf p. I1 a\n  \\<forall>a\\<in>set_spmf q. I2 a\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set_spmf\n                    (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out))\n                      a).\n       I2 a", "by(auto simp add: bind_UNION image_Union set_spmf_cond_spmf_fst intro: I2.callee_invariant WT_gpvD)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set_spmf\n                  (cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out))\n                    a).\n     I2 a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>IO out rpv \\<in> set_spmf (the_gpv gpv); generat = IO out rpv;\n   ?x \\<in> set_spmf q; (?a, ?b) \\<in> set_spmf (callee2 ?x out)\\<rbrakk>\n  \\<Longrightarrow> cond_spmf_fst (p \\<bind> (\\<lambda>xa. callee1 xa out))\n                     ?a \\<bind>\n                    (\\<lambda>x. map_spmf fst (exec_gpv' (rpv ?a) x)) =\n                    cond_spmf_fst (q \\<bind> (\\<lambda>xa. callee2 xa out))\n                     ?a \\<bind>\n                    (\\<lambda>x. map_spmf fst (g (rpv ?a) x))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = Pure x1\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = IO x21 x22\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))", "from 2"], ["proof (chain)\npicking this:\n  generat \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv", "show ?case"], ["proof (prove)\nusing this:\n  generat \\<in> set_spmf (the_gpv gpv)\n  generat = IO out rpv\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>xa.\n        map_spmf fst\n         (case generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n          | IO out c \\<Rightarrow>\n              callee1 xa out \\<bind>\n              (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n    q \\<bind>\n    (\\<lambda>xa.\n        map_spmf fst\n         (case generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n          | IO out c \\<Rightarrow>\n              callee2 xa out \\<bind> (\\<lambda>(x, y). g (c x) y)))", "by(simp add: map_bind_spmf o_def)\n          (subst (1 2) bind_spmf_assoc[symmetric]\n            , rewrite in \"bind_spmf \\<hole> _ = _\" cond_spmf_fst_inverse[symmetric]\n            , rewrite in \"_ = bind_spmf \\<hole> _\" cond_spmf_fst_inverse[symmetric]\n            , subst (1 2) bind_spmf_assoc\n            , auto simp add: bind_map_spmf o_def intro!: bind_spmf_cong)"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>xa.\n      map_spmf fst\n       (case generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n        | IO out c \\<Rightarrow>\n            callee1 xa out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n  q \\<bind>\n  (\\<lambda>xa.\n      map_spmf fst\n       (case generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n        | IO out c \\<Rightarrow>\n            callee2 xa out \\<bind> (\\<lambda>(x, y). g (c x) y)))\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       \\<lbrakk>generat \\<in> set_spmf (the_gpv gpv);\n        generat = Pure x1\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee1 xa out \\<bind>\n                                   (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n                         q \\<bind>\n                         (\\<lambda>xa.\n                             map_spmf fst\n                              (case generat of\n                               Pure x \\<Rightarrow> return_spmf (x, xa)\n                               | IO out c \\<Rightarrow>\n                                   callee2 xa out \\<bind>\n                                   (\\<lambda>(x, y). g (c x) y)))", "qed (simp add: bind_spmf_const lossless_weight_spmfD step.prems)"], ["proof (state)\nthis:\n  ?generat \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  p \\<bind>\n  (\\<lambda>xa.\n      map_spmf fst\n       (case ?generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n        | IO out c \\<Rightarrow>\n            callee1 xa out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y))) =\n  q \\<bind>\n  (\\<lambda>xa.\n      map_spmf fst\n       (case ?generat of Pure x \\<Rightarrow> return_spmf (x, xa)\n        | IO out c \\<Rightarrow>\n            callee2 xa out \\<bind> (\\<lambda>(x, y). g (c x) y)))\n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            S xa xb \\<longrightarrow>\n            (\\<forall>xc.\n                outs_gpv \\<I> xc \\<subseteq> A \\<longrightarrow>\n                lossless_spmf xa \\<longrightarrow>\n                lossless_spmf xb \\<longrightarrow>\n                \\<I> \\<turnstile>g xc \\<surd> \\<longrightarrow>\n                Ball (set_spmf xa) I1 \\<longrightarrow>\n                Ball (set_spmf xb) I2 \\<longrightarrow>\n                xa \\<bind> (\\<lambda>s. map_spmf fst (curry (fst x) xc s)) =\n                xb \\<bind> (\\<lambda>s. map_spmf fst (curry (snd x) xc s))))\n 2. \\<And>p q gpv.\n       \\<lbrakk>S p q; outs_gpv \\<I> gpv \\<subseteq> A; lossless_spmf p;\n        lossless_spmf q; \\<I> \\<turnstile>g gpv \\<surd>;\n        Ball (set_spmf p) I1; Ball (set_spmf q) I2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (lub_spmf {})) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (lub_spmf {}))\n 3. \\<And>f g p q gpv.\n       \\<lbrakk>\\<And>p q gpv.\n                   \\<lbrakk>S p q; outs_gpv \\<I> gpv \\<subseteq> A;\n                    lossless_spmf p; lossless_spmf q;\n                    \\<I> \\<turnstile>g gpv \\<surd>; Ball (set_spmf p) I1;\n                    Ball (set_spmf q) I2\\<rbrakk>\n                   \\<Longrightarrow> p \\<bind>\n                                     (\\<lambda>s. map_spmf fst (f gpv s)) =\n                                     q \\<bind>\n                                     (\\<lambda>s. map_spmf fst (g gpv s));\n        S p q; outs_gpv \\<I> gpv \\<subseteq> A; lossless_spmf p;\n        lossless_spmf q; \\<I> \\<turnstile>g gpv \\<surd>;\n        Ball (set_spmf p) I1; Ball (set_spmf q) I2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              (the_gpv gpv \\<bind>\n                               case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    callee1 s out \\<bind>\n                                    (\\<lambda>(x, y). f (c x) y)))) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              (the_gpv gpv \\<bind>\n                               case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    callee2 s out \\<bind>\n                                    (\\<lambda>(x, y). g (c x) y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         (the_gpv gpv \\<bind>\n          (\\<lambda>a.\n              case a of Pure x \\<Rightarrow> return_spmf (x, s)\n              | IO out c \\<Rightarrow>\n                  callee1 s out \\<bind>\n                  (\\<lambda>a.\n                      case a of (x, y) \\<Rightarrow> exec_gpv' (c x) y)))) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         (the_gpv gpv \\<bind>\n          (\\<lambda>a.\n              case a of Pure x \\<Rightarrow> return_spmf (x, s)\n              | IO out c \\<Rightarrow>\n                  callee2 s out \\<bind>\n                  (\\<lambda>a. case a of (x, y) \\<Rightarrow> g (c x) y))))", "unfolding map_bind_spmf o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        the_gpv gpv \\<bind>\n        (\\<lambda>x.\n            map_spmf fst\n             (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n              | IO out c \\<Rightarrow>\n                  callee1 s out \\<bind>\n                  (\\<lambda>(x, y). exec_gpv' (c x) y)))) =\n    q \\<bind>\n    (\\<lambda>s.\n        the_gpv gpv \\<bind>\n        (\\<lambda>x.\n            map_spmf fst\n             (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n              | IO out c \\<Rightarrow>\n                  callee2 s out \\<bind> (\\<lambda>(x, y). g (c x) y))))", "by(subst (1 2) bind_commute_spmf) (auto intro: bind_spmf_cong[OF refl])"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       (the_gpv gpv \\<bind>\n        (\\<lambda>a.\n            case a of Pure x \\<Rightarrow> return_spmf (x, s)\n            | IO out c \\<Rightarrow>\n                callee1 s out \\<bind>\n                (\\<lambda>a.\n                    case a of (x, y) \\<Rightarrow> exec_gpv' (c x) y)))) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       (the_gpv gpv \\<bind>\n        (\\<lambda>a.\n            case a of Pure x \\<Rightarrow> return_spmf (x, s)\n            | IO out c \\<Rightarrow>\n                callee2 s out \\<bind>\n                (\\<lambda>a. case a of (x, y) \\<Rightarrow> g (c x) y))))\n\ngoal (2 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            S xa xb \\<longrightarrow>\n            (\\<forall>xc.\n                outs_gpv \\<I> xc \\<subseteq> A \\<longrightarrow>\n                lossless_spmf xa \\<longrightarrow>\n                lossless_spmf xb \\<longrightarrow>\n                \\<I> \\<turnstile>g xc \\<surd> \\<longrightarrow>\n                Ball (set_spmf xa) I1 \\<longrightarrow>\n                Ball (set_spmf xb) I2 \\<longrightarrow>\n                xa \\<bind> (\\<lambda>s. map_spmf fst (curry (fst x) xc s)) =\n                xb \\<bind> (\\<lambda>s. map_spmf fst (curry (snd x) xc s))))\n 2. \\<And>p q gpv.\n       \\<lbrakk>S p q; outs_gpv \\<I> gpv \\<subseteq> A; lossless_spmf p;\n        lossless_spmf q; \\<I> \\<turnstile>g gpv \\<surd>;\n        Ball (set_spmf p) I1; Ball (set_spmf q) I2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (lub_spmf {})) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (lub_spmf {}))", "qed simp_all"], ["proof (state)\nthis:\n  p \\<bind> run_gpv callee1 gpv = q \\<bind> run_gpv callee2 gpv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_callee_eq'_run_gpv:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes trace_eq: \"A \\<turnstile>\\<^sub>C callee1(s1) \\<approx> callee2(s2)\"\n    and inv1: \"callee_invariant_on callee1 I1 \\<I>\"\n    and inv1: \"callee_invariant_on callee2 I2 \\<I>\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and out: \"outs_gpv \\<I> gpv \\<subseteq> A\"\n    and I1: \"I1 s1\"\n    and I2: \"I2 s2\"\n  shows \"run_gpv callee1 gpv s1 = run_gpv callee2 gpv s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_gpv callee1 gpv s1 = run_gpv callee2 gpv s2", "using trace_callee_eq_run_gpv[OF assms(1-5)] assms(6-)"], ["proof (prove)\nusing this:\n  \\<lbrakk>lossless_spmf (return_spmf s1); lossless_spmf (return_spmf s2);\n   \\<forall>x\\<in>set_spmf (return_spmf s1). I1 x;\n   \\<forall>y\\<in>set_spmf (return_spmf s2). I2 y\\<rbrakk>\n  \\<Longrightarrow> return_spmf s1 \\<bind> run_gpv callee1 gpv =\n                    return_spmf s2 \\<bind> run_gpv callee2 gpv\n  I1 s1\n  I2 s2\n\ngoal (1 subgoal):\n 1. run_gpv callee1 gpv s1 = run_gpv callee2 gpv s2", "by simp"], ["", "abbreviation trace_eq :: \"'a set \\<Rightarrow> ('a, 'b) resource spmf \\<Rightarrow> ('a, 'b) resource spmf \\<Rightarrow> bool\" where\n  \"trace_eq \\<equiv> trace_callee_eq run_resource run_resource\""], ["", "abbreviation trace_eq' :: \"'a set \\<Rightarrow> ('a, 'b) resource \\<Rightarrow> ('a, 'b) resource \\<Rightarrow> bool\" (\"(_) \\<turnstile>\\<^sub>R/ (_)/ \\<approx> (_)\" [90, 90, 90] 91) where\n  \"A \\<turnstile>\\<^sub>R res \\<approx> res' \\<equiv> trace_eq A (return_spmf res) (return_spmf res')\""], ["", "lemma trace_callee_resource_of_oracle2:\n  \"trace_callee run_resource (map_spmf (resource_of_oracle callee) p) xs x =\n   trace_callee callee p xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (resource_of_oracle callee) p) xs\n     x =\n    trace_callee callee p xs x", "proof(induction xs arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       trace_callee run_resource (map_spmf (resource_of_oracle callee) p) []\n        x =\n       trace_callee callee p [] x\n 2. \\<And>a xs p.\n       (\\<And>p.\n           trace_callee run_resource\n            (map_spmf (resource_of_oracle callee) p) xs x =\n           trace_callee callee p xs x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (resource_of_oracle callee) p)\n        (a # xs) x =\n       trace_callee callee p (a # xs) x", "case (Cons xy xs)"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (resource_of_oracle callee) ?p) xs x =\n  trace_callee callee ?p xs x\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       trace_callee run_resource (map_spmf (resource_of_oracle callee) p) []\n        x =\n       trace_callee callee p [] x\n 2. \\<And>a xs p.\n       (\\<And>p.\n           trace_callee run_resource\n            (map_spmf (resource_of_oracle callee) p) xs x =\n           trace_callee callee p xs x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (resource_of_oracle callee) p)\n        (a # xs) x =\n       trace_callee callee p (a # xs) x", "then"], ["proof (chain)\npicking this:\n  trace_callee run_resource (map_spmf (resource_of_oracle callee) ?p) xs x =\n  trace_callee callee ?p xs x", "show ?case"], ["proof (prove)\nusing this:\n  trace_callee run_resource (map_spmf (resource_of_oracle callee) ?p) xs x =\n  trace_callee callee ?p xs x\n\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (resource_of_oracle callee) p)\n     (xy # xs) x =\n    trace_callee callee p (xy # xs) x", "by (cases xy) (simp add: bind_map_spmf o_def Cons.IH[symmetric] cond_spmf_fst_def map_bind_spmf[symmetric, unfolded o_def] spmf.map_comp map_prod_vimage)"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (resource_of_oracle callee) p)\n   (xy # xs) x =\n  trace_callee callee p (xy # xs) x\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       trace_callee run_resource (map_spmf (resource_of_oracle callee) p) []\n        x =\n       trace_callee callee p [] x", "qed (simp add: map_bind_spmf bind_map_spmf o_def spmf.map_comp)"], ["", "lemma trace_callee_resource_of_oracle [simp]:\n  \"trace_callee run_resource (return_spmf (resource_of_oracle callee s)) xs x =\n   trace_callee callee (return_spmf s) xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource (return_spmf (resource_of_oracle callee s)) xs\n     x =\n    trace_callee callee (return_spmf s) xs x", "using trace_callee_resource_of_oracle2[of callee \"return_spmf s\" xs x]"], ["proof (prove)\nusing this:\n  trace_callee run_resource\n   (map_spmf (resource_of_oracle callee) (return_spmf s)) xs x =\n  trace_callee callee (return_spmf s) xs x\n\ngoal (1 subgoal):\n 1. trace_callee run_resource (return_spmf (resource_of_oracle callee s)) xs\n     x =\n    trace_callee callee (return_spmf s) xs x", "by simp"], ["", "lemma trace_eq'_resource_of_oracle [simp]:\n  \"A \\<turnstile>\\<^sub>R resource_of_oracle callee1 s1 \\<approx> resource_of_oracle callee2 s2 =\n   A \\<turnstile>\\<^sub>C callee1(s1) \\<approx> callee2(s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R resource_of_oracle callee1 s1\n    \\<approx> resource_of_oracle callee2 s2 = A \\<turnstile>\\<^sub>C\n    callee1(s1) \\<approx> callee2(s2)", "by(simp add: trace_callee_eq_def)"], ["", "end"]]}