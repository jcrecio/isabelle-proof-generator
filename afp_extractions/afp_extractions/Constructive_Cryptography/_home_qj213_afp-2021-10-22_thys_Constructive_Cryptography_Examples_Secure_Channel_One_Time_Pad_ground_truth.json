{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Examples/Secure_Channel/One_Time_Pad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma resources_indistinguishable: \n  shows \"(UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R \n    RES (callee_sec_channel sim \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.recv_oracle) (None :: bool list option, (), Void) \n    \\<approx> \n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O key_channel_send \\<oplus>\\<^sub>O key_channel_recv) (None :: bool list option, Void)\" \n    (is \"?A \\<turnstile>\\<^sub>R RES (?L1 \\<oplus>\\<^sub>O ?L2 \\<oplus>\\<^sub>O ?L3) ?SL \\<approx> RES (?R1 \\<oplus>\\<^sub>O ?R2 \\<oplus>\\<^sub>O ?R3) ?SR\")", "lemma real_resource_wiring: \n  shows \"cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) \n    = RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O key_channel_send \\<oplus>\\<^sub>O key_channel_recv) (None, Void)\"", "lemma ideal_resource_wiring: \n  shows \"(CNV callee s) |\\<^sub>= 1\\<^sub>C \\<rhd> channel.res sec_channel.sec_oracle \n    = RES (callee_sec_channel callee \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.recv_oracle ) (s, (), Void)\"  (is \"?L1 \\<rhd> _ = ?R\")", "lemma eq_\\<I>_gpv_Done1:\n  \"eq_\\<I>_gpv A \\<I> (Done x) gpv \\<longleftrightarrow> lossless_spmf (the_gpv gpv) \\<and> (\\<forall>a\\<in>set_spmf (the_gpv gpv). eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>) (Pure x) a)\"", "lemma eq_\\<I>_gpv_Done2:\n  \"eq_\\<I>_gpv A \\<I> gpv (Done x) \\<longleftrightarrow> lossless_spmf (the_gpv gpv) \\<and> (\\<forall>a\\<in>set_spmf (the_gpv gpv). eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>) a (Pure x))\"", "lemma one_time_pad:\n  defines \"\\<I>_real \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))\"\n    and \"\\<I>_ideal \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform UNIV {None, Some \\<eta>}\"\n    and \"\\<I>_common \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))\"\n  shows\n    \"constructive_security2 CIPHER.res (\\<lambda>_. S_CHAN.res) (\\<lambda>_. CNV sim None)\n     \\<I>_real \\<I>_ideal \\<I>_common (\\<lambda>_. \\<infinity>) False (\\<lambda>_. auth_sec_wiring)\""], "translations": [["", "lemma resources_indistinguishable: \n  shows \"(UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R \n    RES (callee_sec_channel sim \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.recv_oracle) (None :: bool list option, (), Void) \n    \\<approx> \n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O key_channel_send \\<oplus>\\<^sub>O key_channel_recv) (None :: bool list option, Void)\" \n    (is \"?A \\<turnstile>\\<^sub>R RES (?L1 \\<oplus>\\<^sub>O ?L2 \\<oplus>\\<^sub>O ?L3) ?SL \\<approx> RES (?R1 \\<oplus>\\<^sub>O ?R2 \\<oplus>\\<^sub>O ?R3) ?SR\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n    RES (callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (None, (), Void)\n    \\<approx> RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                   key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n               (None, Void)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n    RES (callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (None, (), Void)\n    \\<approx> RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                   key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n               (None, Void)", "note [simp] = \n    exec_gpv_bind spmf.map_comp o_def map_bind_spmf bind_map_spmf bind_spmf_const\n    sec_channel.sec_oracle.simps auth_channel.auth_oracle.simps\n    channel.send_oracle.simps key_channel_send_def\n    channel.recv_oracle.simps key_channel_recv_def\n    key.key_oracle.simps dec_def key_def enc_def"], ["proof (state)\nthis:\n  exec_gpv ?callee (?c \\<bind> ?f) ?s =\n  exec_gpv ?callee ?c ?s \\<bind>\n  (\\<lambda>xa. case xa of (x, s') \\<Rightarrow> exec_gpv ?callee (?f x) s')\n  map_spmf ?f (map_spmf ?g ?p) = map_spmf (?f \\<circ> ?g) ?p\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  map_spmf ?f (?p \\<bind> ?g) = ?p \\<bind> map_spmf ?f \\<circ> ?g\n  map_spmf ?f ?p \\<bind> ?g = ?p \\<bind> ?g \\<circ> ?f\n  ?p \\<bind> (\\<lambda>x. ?q) = scale_spmf (weight_spmf ?p) ?q\n  sec_channel.sec_oracle (Store ?m) Forward =\n  return_spmf (None, cstate.Collect ?m)\n  sec_channel.sec_oracle (Store ?m) Drop = return_spmf (None, cstate.Fail)\n  sec_channel.sec_oracle (Store ?m) Look =\n  return_spmf (Some (length ?m), Store ?m)\n  sec_channel.sec_oracle Void ?uu = return_spmf (None, Void)\n  sec_channel.sec_oracle cstate.Fail ?uu = return_spmf (None, cstate.Fail)\n  sec_channel.sec_oracle (cstate.Collect ?v) ?uu =\n  return_spmf (None, cstate.Collect ?v)\n  sec_channel.sec_oracle Void Look = return_spmf (None, Void)\n  sec_channel.sec_oracle cstate.Fail Look = return_spmf (None, cstate.Fail)\n  sec_channel.sec_oracle (cstate.Collect ?v) Look =\n  return_spmf (None, cstate.Collect ?v)\n  sec_channel.sec_oracle Void Drop = return_spmf (None, Void)\n  sec_channel.sec_oracle cstate.Fail Drop = return_spmf (None, cstate.Fail)\n  sec_channel.sec_oracle (cstate.Collect ?v) Drop =\n  return_spmf (None, cstate.Collect ?v)\n  auth_channel.auth_oracle (Store ?m) Forward =\n  return_spmf (None, cstate.Collect ?m)\n  auth_channel.auth_oracle (Store ?m) Drop = return_spmf (None, cstate.Fail)\n  auth_channel.auth_oracle (Store ?m) Look = return_spmf (Some ?m, Store ?m)\n  auth_channel.auth_oracle Void ?uu = return_spmf (None, Void)\n  auth_channel.auth_oracle cstate.Fail ?uu = return_spmf (None, cstate.Fail)\n  auth_channel.auth_oracle (cstate.Collect ?v) ?uu =\n  return_spmf (None, cstate.Collect ?v)\n  auth_channel.auth_oracle Void Look = return_spmf (None, Void)\n  auth_channel.auth_oracle cstate.Fail Look =\n  return_spmf (None, cstate.Fail)\n  auth_channel.auth_oracle (cstate.Collect ?v) Look =\n  return_spmf (None, cstate.Collect ?v)\n  auth_channel.auth_oracle Void Drop = return_spmf (None, Void)\n  auth_channel.auth_oracle cstate.Fail Drop =\n  return_spmf (None, cstate.Fail)\n  auth_channel.auth_oracle (cstate.Collect ?v) Drop =\n  return_spmf (None, cstate.Collect ?v)\n  channel.send_oracle Void ?m = return_spmf ((), Store ?m)\n  channel.send_oracle cstate.Fail ?m = return_spmf ((), cstate.Fail)\n  channel.send_oracle (Store ?v) ?m = return_spmf ((), Store ?v)\n  channel.send_oracle (cstate.Collect ?v) ?m =\n  return_spmf ((), cstate.Collect ?v)\n  key_channel_send ?s ?m \\<equiv>\n  (key.key_oracle (key \\<eta>))\\<dagger> ?s () \\<bind>\n  (\\<lambda>(k, s).\n      enc \\<eta> k ?m \\<bind>\n      (\\<lambda>c.\n          \\<dagger>channel.send_oracle s c \\<bind>\n          (\\<lambda>(uu_, s). return_spmf ((), s))))\n  channel.recv_oracle (cstate.Collect ?m) () =\n  return_spmf (Some ?m, cstate.Fail)\n  channel.recv_oracle Void () = return_spmf (None, Void)\n  channel.recv_oracle cstate.Fail () = return_spmf (None, cstate.Fail)\n  channel.recv_oracle (Store ?v) () = return_spmf (None, Store ?v)\n  key_channel_recv ?s ?m \\<equiv>\n  \\<dagger>channel.recv_oracle ?s () \\<bind>\n  (\\<lambda>(c, s).\n      case c of None \\<Rightarrow> return_spmf (None, s)\n      | Some c' \\<Rightarrow>\n          (key.key_oracle (key \\<eta>))\\<dagger> s () \\<bind>\n          (\\<lambda>(k, s). return_spmf (dec \\<eta> k c', s)))\n  key.key_oracle ?key_gen None () =\n  ?key_gen \\<bind> (\\<lambda>k. return_spmf (k, Some k))\n  key.key_oracle ?key_gen (Some ?x) () = return_spmf (?x, Some ?x)\n  dec ?\\<eta> ?k ?c \\<equiv> Some (?k [\\<oplus>] ?c)\n  key ?\\<eta> \\<equiv> spmf_of_set (nlists UNIV ?\\<eta>)\n  enc ?\\<eta> ?k ?m \\<equiv> return_spmf (?k [\\<oplus>] ?m)\n\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n    RES (callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (None, (), Void)\n    \\<approx> RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                   key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n               (None, Void)", "have *: \"?A \\<turnstile>\\<^sub>C ?L1 \\<oplus>\\<^sub>O ?L2 \\<oplus>\\<^sub>O ?L3(?SL) \\<approx> ?R1 \\<oplus>\\<^sub>O ?R2 \\<oplus>\\<^sub>O ?R3(?SR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>C\n    callee_sec_channel sim \\<oplus>\\<^sub>O\n    \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n    \\<dagger>\\<dagger>channel.recv_oracle((None, (), Void)) \\<approx>\n    \\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n    key_channel_send \\<oplus>\\<^sub>O key_channel_recv((None, Void))", "proof(rule trace'_eqI_sim[where S=S], goal_cases Init_OK Output_OK State_OK)"], ["proof (state)\ngoal (3 subgoals):\n 1. S (return_spmf (None, (), Void)) (return_spmf (None, Void))\n 2. \\<And>p q a.\n       \\<lbrakk>S p q;\n        a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s a))\n 3. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "case Init_OK"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. S (return_spmf (None, (), Void)) (return_spmf (None, Void))\n 2. \\<And>p q a.\n       \\<lbrakk>S p q;\n        a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s a))\n 3. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (return_spmf (None, (), Void)) (return_spmf (None, Void))", "by (simp add: S.simps)"], ["proof (state)\nthis:\n  S (return_spmf (None, (), Void)) (return_spmf (None, Void))\n\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S p q;\n        a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S p q;\n        a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "case (Output_OK p q query)"], ["proof (state)\nthis:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S p q;\n        a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "proof (cases query)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       query = Inl a \\<Longrightarrow>\n       p \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query)) =\n       q \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              s query))\n 2. \\<And>b.\n       query = Inr b \\<Longrightarrow>\n       p \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query)) =\n       q \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              s query))", "case (Inl adv_query)"], ["proof (state)\nthis:\n  query = Inl adv_query\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       query = Inl a \\<Longrightarrow>\n       p \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query)) =\n       q \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              s query))\n 2. \\<And>b.\n       query = Inr b \\<Longrightarrow>\n       p \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query)) =\n       q \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              s query))", "with Output_OK"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inl adv_query", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inl adv_query\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "proof (cases adv_query)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>x2.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = ForwardOrEdit x2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Drop\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))", "case Look"], ["proof (state)\nthis:\n  adv_query = Look\n\ngoal (3 subgoals):\n 1. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>x2.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = ForwardOrEdit x2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Drop\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))", "with Output_OK Inl"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inl adv_query\n  adv_query = Look", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inl adv_query\n  adv_query = Look\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "proof cases"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "case Store_State_Channel: (2 plain)"], ["proof (state)\nthis:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "have*: \"length plain = id' \\<eta> \\<Longrightarrow> \n            map_spmf (\\<lambda>x. Inl (Some x)) (spmf_of_set (nlists UNIV (id' \\<eta>))) =\n            map_spmf (\\<lambda>x. Inl (Some x)) (map_spmf (\\<lambda>x. x [\\<oplus>] plain) (spmf_of_set (nlists UNIV \\<eta>)))\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length plain = id' \\<eta> \\<Longrightarrow>\n    map_spmf (\\<lambda>x. Inl (Some x))\n     (spmf_of_set (nlists UNIV (id' \\<eta>))) =\n    map_spmf (\\<lambda>x. Inl (Some x))\n     (map_spmf (\\<lambda>x. x [\\<oplus>] plain)\n       (spmf_of_set (nlists UNIV \\<eta>)))", "unfolding id'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length plain = id \\<eta> \\<Longrightarrow>\n    map_spmf (\\<lambda>x. Inl (Some x))\n     (spmf_of_set (nlists UNIV (id \\<eta>))) =\n    map_spmf (\\<lambda>x. Inl (Some x))\n     (map_spmf (\\<lambda>x. x [\\<oplus>] plain)\n       (spmf_of_set (nlists UNIV \\<eta>)))", "by (subst xor_list_commute, subst one_time_pad[where xs=plain, symmetric]) simp_all"], ["proof (state)\nthis:\n  length plain = id' ?\\<eta>2 \\<Longrightarrow>\n  map_spmf (\\<lambda>x. Inl (Some x))\n   (spmf_of_set (nlists UNIV (id' ?\\<eta>2))) =\n  map_spmf (\\<lambda>x. Inl (Some x))\n   (map_spmf (\\<lambda>x. x [\\<oplus>] plain)\n     (spmf_of_set (nlists UNIV ?\\<eta>2)))\n\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "from Store_State_Channel"], ["proof (chain)\npicking this:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "using Output_OK(2-) Inl Look"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inl adv_query\n  adv_query = Look\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "by(simp add: sim_def, simp add: map_spmf_conv_bind_spmf[symmetric])\n              (subst (2) spmf.map_comp[where f=\"\\<lambda>x. Inl (Some x)\", symmetric, unfolded o_def], simp only: *)"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n         s query)) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n         s query))\n\ngoal (6 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 5. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 6. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "qed (auto simp add: sim_def)"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n         s query)) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n         s query))\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inl adv_query; adv_query = ForwardOrEdit x2\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 2. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inl adv_query; adv_query = Drop\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))", "qed (auto simp add: sim_def id'_def elim: S.cases)"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n         s query)) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n         s query))\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       query = Inr b \\<Longrightarrow>\n       p \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query)) =\n       q \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              s query))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       query = Inr b \\<Longrightarrow>\n       p \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query)) =\n       q \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              s query))", "case Snd_Rcv: (Inr query')"], ["proof (state)\nthis:\n  query = Inr query'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       query = Inr b \\<Longrightarrow>\n       p \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query)) =\n       q \\<bind>\n       (\\<lambda>s.\n           map_spmf fst\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              s query))", "with Output_OK"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inr query'", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inr query'\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "proof (cases query')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inl a\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 2. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr b\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "case (Inr rcv_query)"], ["proof (state)\nthis:\n  query' = Inr rcv_query\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inl a\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 2. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr b\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "with Output_OK Snd_Rcv"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inr query'\n  query' = Inr rcv_query", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inr query'\n  query' = Inr rcv_query\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "proof cases"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "case Collect_State_Channel: (3 plain)"], ["proof (state)\nthis:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "then"], ["proof (chain)\npicking this:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "using Output_OK(2-) Snd_Rcv Inr"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  query = Inr query'\n  query' = Inr rcv_query\n\ngoal (1 subgoal):\n 1. p \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((callee_sec_channel sim \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n           \\<dagger>\\<dagger>channel.recv_oracle)\n           s query)) =\n    q \\<bind>\n    (\\<lambda>s.\n        map_spmf fst\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))", "by (simp cong: bind_spmf_cong_simp add: in_nlists_UNIV id'_def)"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n         s query)) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n         s query))\n\ngoal (6 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 3. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))\n 5. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> p \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                             \\<dagger>\\<dagger>channel.recv_oracle)\n                             s query)) =\n                      q \\<bind>\n                      (\\<lambda>s.\n                          map_spmf fst\n                           ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                             key_channel_send \\<oplus>\\<^sub>O\n                             key_channel_recv)\n                             s query))\n 6. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "qed simp_all"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n         s query)) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n         s query))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        query = Inr query'; query' = Inl a\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst\n                              ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                key_channel_send \\<oplus>\\<^sub>O\n                                key_channel_recv)\n                                s query))", "qed (auto elim: S.cases)"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n         s query)) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n         s query))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n         s query)) =\n  q \\<bind>\n  (\\<lambda>s.\n      map_spmf fst\n       ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n         s query))\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "case (State_OK p q query state answer state')"], ["proof (state)\nthis:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S p q; a \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        res \\<in> set_spmf q;\n        (b, s')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 res a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s a))\n                             b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)", "show ?case"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "proof (cases query)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl a\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 2. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "case (Inl adv_query)"], ["proof (state)\nthis:\n  query = Inl adv_query\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl a\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 2. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "with State_OK"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inl adv_query", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inl adv_query\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "proof (cases adv_query)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>x2.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = ForwardOrEdit x2\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Drop\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)", "case Look"], ["proof (state)\nthis:\n  adv_query = Look\n\ngoal (3 subgoals):\n 1. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>x2.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = ForwardOrEdit x2\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Drop\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)", "with State_OK Inl"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inl adv_query\n  adv_query = Look", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inl adv_query\n  adv_query = Look\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "proof cases"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "case Store_State_Channel: (2 plain)"], ["proof (state)\nthis:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "have *: \"length plain = id' \\<eta> \\<Longrightarrow> key \\<in> nlists UNIV \\<eta>  \\<Longrightarrow> \n            S (cond_spmf_fst (map_spmf (\\<lambda>x. (Inl (Some x), Some x, (), Store plain))\n               (spmf_of_set (nlists UNIV (id' \\<eta>)))) (Inl (Some (key [\\<oplus>] plain))))\n            (cond_spmf_fst  (map_spmf (\\<lambda>x. (Inl (Some (x [\\<oplus>] plain)), Some x, Store (x [\\<oplus>] plain)))\n               (spmf_of_set (nlists UNIV \\<eta>))) (Inl (Some (key [\\<oplus>] plain))))\" for key"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (map_spmf\n                            (\\<lambda>x.\n                                (Inl (Some x), Some x, (), Store plain))\n                            (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                          (Inl (Some (key [\\<oplus>] plain))))\n                       (cond_spmf_fst\n                         (map_spmf\n                           (\\<lambda>x.\n                               (Inl (Some (x [\\<oplus>] plain)), Some x,\n                                Store (x [\\<oplus>] plain)))\n                           (spmf_of_set (nlists UNIV \\<eta>)))\n                         (Inl (Some (key [\\<oplus>] plain))))", "proof(subst (1 2) cond_spmf_fst_map_Pair1, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                       (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 4. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n 5. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          (Some\n                            (inv_into\n                              (set_spmf\n                                (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                              (\\<lambda>x. Inl (Some x))\n                              (Inl (Some (key [\\<oplus>] plain)))),\n                           (), Store plain))\n                       (return_spmf\n                         (Some\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain)))),\n                          Store\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n                            plain)))", "case 2"], ["proof (state)\nthis:\n  length plain = id' \\<eta>\n  key \\<in> nlists UNIV \\<eta>\n\ngoal (5 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                       (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 4. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n 5. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          (Some\n                            (inv_into\n                              (set_spmf\n                                (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                              (\\<lambda>x. Inl (Some x))\n                              (Inl (Some (key [\\<oplus>] plain)))),\n                           (), Store plain))\n                       (return_spmf\n                         (Some\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain)))),\n                          Store\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n                            plain)))", "note inj_onD[OF inj_on_xor_list_nlists, rotated, simplified xor_list_commute]"], ["proof (state)\nthis:\n  \\<lbrakk>?x [\\<oplus>] ?xs1 = ?y [\\<oplus>] ?xs1;\n   ?x \\<in> nlists UNIV ?n1; ?y \\<in> nlists UNIV ?n1;\n   ?n1 \\<le> length ?xs1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (5 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                       (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 4. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n 5. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          (Some\n                            (inv_into\n                              (set_spmf\n                                (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                              (\\<lambda>x. Inl (Some x))\n                              (Inl (Some (key [\\<oplus>] plain)))),\n                           (), Store plain))\n                       (return_spmf\n                         (Some\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain)))),\n                          Store\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n                            plain)))", "with 2"], ["proof (chain)\npicking this:\n  length plain = id' \\<eta>\n  key \\<in> nlists UNIV \\<eta>\n  \\<lbrakk>?x [\\<oplus>] ?xs1 = ?y [\\<oplus>] ?xs1;\n   ?x \\<in> nlists UNIV ?n1; ?y \\<in> nlists UNIV ?n1;\n   ?n1 \\<le> length ?xs1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y", "show ?case"], ["proof (prove)\nusing this:\n  length plain = id' \\<eta>\n  key \\<in> nlists UNIV \\<eta>\n  \\<lbrakk>?x [\\<oplus>] ?xs1 = ?y [\\<oplus>] ?xs1;\n   ?x \\<in> nlists UNIV ?n1; ?y \\<in> nlists UNIV ?n1;\n   ?n1 \\<le> length ?xs1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n     (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))", "unfolding inj_on_def"], ["proof (prove)\nusing this:\n  length plain = id' \\<eta>\n  key \\<in> nlists UNIV \\<eta>\n  \\<lbrakk>?x [\\<oplus>] ?xs1 = ?y [\\<oplus>] ?xs1;\n   ?x \\<in> nlists UNIV ?n1; ?y \\<in> nlists UNIV ?n1;\n   ?n1 \\<le> length ?xs1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_spmf (spmf_of_set (nlists UNIV \\<eta>)).\n       \\<forall>y\\<in>set_spmf (spmf_of_set (nlists UNIV \\<eta>)).\n          Inl (Some (x [\\<oplus>] plain)) =\n          Inl (Some (y [\\<oplus>] plain)) \\<longrightarrow>\n          x = y", "by (auto simp add: id'_def)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n   (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n 4. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          (Some\n                            (inv_into\n                              (set_spmf\n                                (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                              (\\<lambda>x. Inl (Some x))\n                              (Inl (Some (key [\\<oplus>] plain)))),\n                           (), Store plain))\n                       (return_spmf\n                         (Some\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain)))),\n                          Store\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n                            plain)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n 4. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          (Some\n                            (inv_into\n                              (set_spmf\n                                (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                              (\\<lambda>x. Inl (Some x))\n                              (Inl (Some (key [\\<oplus>] plain)))),\n                           (), Store plain))\n                       (return_spmf\n                         (Some\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain)))),\n                          Store\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n                            plain)))", "case 5"], ["proof (state)\nthis:\n  length plain = id' \\<eta>\n  key \\<in> nlists UNIV \\<eta>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n 4. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          (Some\n                            (inv_into\n                              (set_spmf\n                                (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                              (\\<lambda>x. Inl (Some x))\n                              (Inl (Some (key [\\<oplus>] plain)))),\n                           (), Store plain))\n                       (return_spmf\n                         (Some\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain)))),\n                          Store\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n                            plain)))", "note inj_onD[OF inj_on_xor_list_nlists, rotated, simplified xor_list_commute]"], ["proof (state)\nthis:\n  \\<lbrakk>?x [\\<oplus>] ?xs1 = ?y [\\<oplus>] ?xs1;\n   ?x \\<in> nlists UNIV ?n1; ?y \\<in> nlists UNIV ?n1;\n   ?n1 \\<le> length ?xs1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (4 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n 4. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          (Some\n                            (inv_into\n                              (set_spmf\n                                (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                              (\\<lambda>x. Inl (Some x))\n                              (Inl (Some (key [\\<oplus>] plain)))),\n                           (), Store plain))\n                       (return_spmf\n                         (Some\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain)))),\n                          Store\n                           (inv_into\n                             (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n                             (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n                             (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n                            plain)))", "with 5"], ["proof (chain)\npicking this:\n  length plain = id' \\<eta>\n  key \\<in> nlists UNIV \\<eta>\n  \\<lbrakk>?x [\\<oplus>] ?xs1 = ?y [\\<oplus>] ?xs1;\n   ?x \\<in> nlists UNIV ?n1; ?y \\<in> nlists UNIV ?n1;\n   ?n1 \\<le> length ?xs1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y", "show ?case"], ["proof (prove)\nusing this:\n  length plain = id' \\<eta>\n  key \\<in> nlists UNIV \\<eta>\n  \\<lbrakk>?x [\\<oplus>] ?xs1 = ?y [\\<oplus>] ?xs1;\n   ?x \\<in> nlists UNIV ?n1; ?y \\<in> nlists UNIV ?n1;\n   ?n1 \\<le> length ?xs1\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. S (return_spmf\n        (Some\n          (inv_into (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n            (\\<lambda>x. Inl (Some x)) (Inl (Some (key [\\<oplus>] plain)))),\n         (), Store plain))\n     (return_spmf\n       (Some\n         (inv_into (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n           (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n           (Inl (Some (key [\\<oplus>] plain)))),\n        Store\n         (inv_into (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n           (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n           (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n          plain)))", "by (subst (1 2 3) inv_into_f_f)\n                ((clarsimp simp add: inj_on_def), (auto simp add: S.simps id'_def inj_on_def in_nlists_UNIV ))"], ["proof (state)\nthis:\n  S (return_spmf\n      (Some\n        (inv_into (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))\n          (\\<lambda>x. Inl (Some x)) (Inl (Some (key [\\<oplus>] plain)))),\n       (), Store plain))\n   (return_spmf\n     (Some\n       (inv_into (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n         (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n         (Inl (Some (key [\\<oplus>] plain)))),\n      Store\n       (inv_into (set_spmf (spmf_of_set (nlists UNIV \\<eta>)))\n         (\\<lambda>x. Inl (Some (x [\\<oplus>] plain)))\n         (Inl (Some (key [\\<oplus>] plain))) [\\<oplus>]\n        plain)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key \\<in> set_spmf (spmf_of_set (nlists UNIV \\<eta>))\n 2. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> key [\\<oplus>] plain\n                      \\<in> set_spmf\n                             (spmf_of_set (nlists UNIV (id' \\<eta>)))\n 3. \\<lbrakk>length plain = id' \\<eta>;\n     key \\<in> nlists UNIV \\<eta>\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>x. Inl (Some x))\n                       (set_spmf (spmf_of_set (nlists UNIV (id' \\<eta>))))", "qed (simp_all add: id'_def in_nlists_UNIV min_def inj_on_def)"], ["proof (state)\nthis:\n  \\<lbrakk>length plain = id' \\<eta>;\n   ?key2 \\<in> nlists UNIV \\<eta>\\<rbrakk>\n  \\<Longrightarrow> S (cond_spmf_fst\n                        (map_spmf\n                          (\\<lambda>x.\n                              (Inl (Some x), Some x, (), Store plain))\n                          (spmf_of_set (nlists UNIV (id' \\<eta>))))\n                        (Inl (Some (?key2 [\\<oplus>] plain))))\n                     (cond_spmf_fst\n                       (map_spmf\n                         (\\<lambda>x.\n                             (Inl (Some (x [\\<oplus>] plain)), Some x,\n                              Store (x [\\<oplus>] plain)))\n                         (spmf_of_set (nlists UNIV \\<eta>)))\n                       (Inl (Some (?key2 [\\<oplus>] plain))))\n\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "from Store_State_Channel"], ["proof (chain)\npicking this:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "using State_OK(2-) Inl Look"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), Store plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inl adv_query\n  adv_query = Look\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "by (clarsimp simp add: sim_def) (simp add: map_spmf_conv_bind_spmf[symmetric] * )"], ["proof (state)\nthis:\n  S (cond_spmf_fst\n      (p \\<bind>\n       (\\<lambda>s.\n           (callee_sec_channel sim \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.recv_oracle)\n            s query))\n      answer)\n   (cond_spmf_fst\n     (q \\<bind>\n      (\\<lambda>s.\n          (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))\n     answer)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 5. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Look;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 6. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = Look;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "qed (auto simp add: sim_def map_spmf_conv_bind_spmf[symmetric] S.simps)"], ["proof (state)\nthis:\n  S (cond_spmf_fst\n      (p \\<bind>\n       (\\<lambda>s.\n           (callee_sec_channel sim \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.recv_oracle)\n            s query))\n      answer)\n   (cond_spmf_fst\n     (q \\<bind>\n      (\\<lambda>s.\n          (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))\n     answer)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inl adv_query; adv_query = ForwardOrEdit x2\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 2. \\<lbrakk>S p q; query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inl adv_query; adv_query = Drop\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)", "qed (erule S.cases; (simp add: sim_def, auto simp add: map_spmf_conv_bind_spmf[symmetric] S.simps))+"], ["proof (state)\nthis:\n  S (cond_spmf_fst\n      (p \\<bind>\n       (\\<lambda>s.\n           (callee_sec_channel sim \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.recv_oracle)\n            s query))\n      answer)\n   (cond_spmf_fst\n     (q \\<bind>\n      (\\<lambda>s.\n          (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))\n     answer)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "case Snd_Rcv: (Inr query')"], ["proof (state)\nthis:\n  query = Inr query'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "with State_OK"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inr query'", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inr query'\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "proof (cases query')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inl a\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 2. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr b\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "case (Inr rcv_query)"], ["proof (state)\nthis:\n  query' = Inr rcv_query\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inl a\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 2. \\<And>b.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr b\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "with State_OK Snd_Rcv"], ["proof (chain)\npicking this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inr query'\n  query' = Inr rcv_query", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inr query'\n  query' = Inr rcv_query\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "proof cases"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "case Collect_State_Channel: (3 plain)"], ["proof (state)\nthis:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (7 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), cstate.Collect plain);\n        q =\n        map_spmf\n         (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 5. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 6. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 7. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "then"], ["proof (chain)\npicking this:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "using State_OK(2-) Snd_Rcv Inr"], ["proof (prove)\nusing this:\n  p = return_spmf (None, (), cstate.Collect plain)\n  q =\n  map_spmf (\\<lambda>key. (Some key, cstate.Collect (key [\\<oplus>] plain)))\n   (spmf_of_set (nlists UNIV \\<eta>))\n  length plain = id' \\<eta>\n  query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n  state \\<in> set_spmf q\n  (answer, state')\n  \\<in> set_spmf\n         ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           state query)\n  query = Inr query'\n  query' = Inr rcv_query\n\ngoal (1 subgoal):\n 1. S (cond_spmf_fst\n        (p \\<bind>\n         (\\<lambda>s.\n             (callee_sec_channel sim \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n              \\<dagger>\\<dagger>channel.recv_oracle)\n              s query))\n        answer)\n     (cond_spmf_fst\n       (q \\<bind>\n        (\\<lambda>s.\n            (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n             key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             s query))\n       answer)", "by clarsimp (simp add: S.simps in_nlists_UNIV id'_def map_spmf_conv_bind_spmf[symmetric] cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  S (cond_spmf_fst\n      (p \\<bind>\n       (\\<lambda>s.\n           (callee_sec_channel sim \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.recv_oracle)\n            s query))\n      answer)\n   (cond_spmf_fst\n     (q \\<bind>\n      (\\<lambda>s.\n          (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))\n     answer)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), Void); q = return_spmf (None, Void)\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 2. \\<And>plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (None, (), Store plain);\n        q =\n        map_spmf (\\<lambda>key. (Some key, Store (key [\\<oplus>] plain)))\n         (spmf_of_set (nlists UNIV \\<eta>));\n        length plain = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 3. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), Store plain);\n        q = return_spmf (Some key, Store (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 4. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p =\n        return_spmf (Some (key [\\<oplus>] plain), (), cstate.Collect plain);\n        q = return_spmf (Some key, cstate.Collect (key [\\<oplus>] plain));\n        length plain = id' \\<eta>; length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)\n 5. \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n     state \\<in> set_spmf q;\n     (answer, state')\n     \\<in> set_spmf\n            ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n              key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n              state query);\n     query = Inr query'; query' = Inr rcv_query;\n     p = return_spmf (None, (), cstate.Fail);\n     q =\n     map_spmf (\\<lambda>x. (Some x, cstate.Fail))\n      (spmf_of_set (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> S (cond_spmf_fst\n                          (p \\<bind>\n                           (\\<lambda>s.\n                               (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                \\<dagger>\\<dagger>channel.recv_oracle)\n                                s query))\n                          answer)\n                       (cond_spmf_fst\n                         (q \\<bind>\n                          (\\<lambda>s.\n                              (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                               key_channel_send \\<oplus>\\<^sub>O\n                               key_channel_recv)\n                               s query))\n                         answer)\n 6. \\<And>key plain.\n       \\<lbrakk>query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inr rcv_query;\n        p = return_spmf (Some (key [\\<oplus>] plain), (), cstate.Fail);\n        q = return_spmf (Some key, cstate.Fail); length plain = id' \\<eta>;\n        length key = id' \\<eta>\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "qed (simp add: sim_def, auto simp add: map_spmf_conv_bind_spmf[symmetric] S.simps)"], ["proof (state)\nthis:\n  S (cond_spmf_fst\n      (p \\<bind>\n       (\\<lambda>s.\n           (callee_sec_channel sim \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.recv_oracle)\n            s query))\n      answer)\n   (cond_spmf_fst\n     (q \\<bind>\n      (\\<lambda>s.\n          (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))\n     answer)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>S p q;\n        query \\<in> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV;\n        state \\<in> set_spmf q;\n        (answer, state')\n        \\<in> set_spmf\n               ((\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n                 state query);\n        query = Inr query'; query' = Inl a\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind>\n                              (\\<lambda>s.\n                                  (callee_sec_channel sim \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n                                   \\<dagger>\\<dagger>channel.recv_oracle)\n                                   s query))\n                             answer)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s.\n                                 (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                                  key_channel_send \\<oplus>\\<^sub>O\n                                  key_channel_recv)\n                                  s query))\n                            answer)", "qed (erule S.cases, \n          (simp add: sim_def, auto simp add: map_spmf_conv_bind_spmf[symmetric] S.simps  in_nlists_UNIV))"], ["proof (state)\nthis:\n  S (cond_spmf_fst\n      (p \\<bind>\n       (\\<lambda>s.\n           (callee_sec_channel sim \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.recv_oracle)\n            s query))\n      answer)\n   (cond_spmf_fst\n     (q \\<bind>\n      (\\<lambda>s.\n          (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))\n     answer)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S (cond_spmf_fst\n      (p \\<bind>\n       (\\<lambda>s.\n           (callee_sec_channel sim \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n            \\<dagger>\\<dagger>channel.recv_oracle)\n            s query))\n      answer)\n   (cond_spmf_fst\n     (q \\<bind>\n      (\\<lambda>s.\n          (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n           key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n           s query))\n     answer)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>C\n  callee_sec_channel sim \\<oplus>\\<^sub>O\n  \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n  \\<dagger>\\<dagger>channel.recv_oracle((None, (), Void)) \\<approx>\n  \\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n  key_channel_send \\<oplus>\\<^sub>O key_channel_recv((None, Void))\n\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n    RES (callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (None, (), Void)\n    \\<approx> RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                   key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n               (None, Void)", "from *"], ["proof (chain)\npicking this:\n  (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>C\n  callee_sec_channel sim \\<oplus>\\<^sub>O\n  \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n  \\<dagger>\\<dagger>channel.recv_oracle((None, (), Void)) \\<approx>\n  \\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n  key_channel_send \\<oplus>\\<^sub>O key_channel_recv((None, Void))", "show ?thesis"], ["proof (prove)\nusing this:\n  (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>C\n  callee_sec_channel sim \\<oplus>\\<^sub>O\n  \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n  \\<dagger>\\<dagger>channel.recv_oracle((None, (), Void)) \\<approx>\n  \\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n  key_channel_send \\<oplus>\\<^sub>O key_channel_recv((None, Void))\n\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n    RES (callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (None, (), Void)\n    \\<approx> RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                   key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n               (None, Void)", "by simp"], ["proof (state)\nthis:\n  (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n  RES (callee_sec_channel sim \\<oplus>\\<^sub>O\n       \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n       \\<dagger>\\<dagger>channel.recv_oracle)\n   (None, (), Void)\n  \\<approx> RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n                 key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n             (None, Void)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_resource_wiring: \n  shows \"cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) \n    = RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O key_channel_send \\<oplus>\\<^sub>O key_channel_recv) (None, Void)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) =\n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n     (None, Void)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) =\n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n     (None, Void)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) =\n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n     (None, Void)", "note[simp]= Rel_def prod.rel_eq[symmetric] split_def split_beta o_def exec_gpv_bind bind_map_spmf \n    resource_of_oracle_rprodl rprodl_extend_state_oracle\n    conv_callee_parallel[symmetric] extend_state_oracle_plus_oracle[symmetric]  \n    attach_CNV_RES attach_callee_parallel_intercept attach_stateless_callee"], ["proof (state)\nthis:\n  Transfer.Rel ?r \\<equiv> ?r\n  (=) = rel_prod (=) (=)\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n  (case ?prod of (x, xa) \\<Rightarrow> ?f x xa) = ?f (fst ?prod) (snd ?prod)\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  exec_gpv ?callee (?c \\<bind> ?f) ?s =\n  exec_gpv ?callee ?c ?s \\<bind>\n  (\\<lambda>xa. case xa of (x, s') \\<Rightarrow> exec_gpv ?callee (?f x) s')\n  map_spmf ?f ?p \\<bind> ?g = ?p \\<bind> ?g \\<circ> ?f\n  RES ((rprodl ---> id ---> map_spmf (map_prod id lprodr)) ?oracle)\n   ((?s1.0, ?s2.0), ?s3.0) =\n  RES ?oracle (?s1.0, ?s2.0, ?s3.0)\n  (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n   \\<dagger>\\<dagger>?oracle =\n  \\<dagger>?oracle\n  CNV ?callee1.0 ?s |\\<^sub>= CNV ?callee2.0 ?s' =\n  CNV (?callee1.0 \\<ddagger>\\<^sub>I ?callee2.0) (?s, ?s')\n  \\<dagger>?oracle1.0 \\<oplus>\\<^sub>O \\<dagger>?oracle2.0 =\n  \\<dagger>(?oracle1.0 \\<oplus>\\<^sub>O ?oracle2.0)\n  CNV ?callee ?s \\<rhd> RES ?res ?s' =\n  RES (attach_callee ?callee ?res) (?s, ?s')\n  attach_callee (?callee1.0 \\<ddagger>\\<^sub>I ?callee2.0)\n   (?oracle1.0 \\<oplus>\\<^sub>O ?oracle2.0) =\n  (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n   (lift_state_oracle extend_state_oracle\n     (attach_callee ?callee1.0 ?oracle1.0) \\<oplus>\\<^sub>O\n    \\<dagger>(attach_callee ?callee2.0 ?oracle2.0))\n  attach_callee (stateless_callee ?callee) ?oracle =\n  \\<dagger>(\\<lambda>s q. exec_gpv ?oracle (?callee q) s)\n\ngoal (1 subgoal):\n 1. cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) =\n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n     (None, Void)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) =\n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n     (None, Void)", "unfolding channel.res_def cipher.res_def  cipher.routing_def cipher.enc_def cipher.dec_def \n      interface_wiring cipher.\\<pi>E_def key.res_def key_channel_send_def key_channel_recv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>C |\\<^sub>=\n    CNV (stateless_callee\n          (\\<lambda>m.\n              Pause (Inl ()) Done \\<bind>\n              (\\<lambda>k.\n                  lift_spmf (enc \\<eta> (projl k) m) \\<bind>\n                  (\\<lambda>c.\n                      Pause (Inr c) Done \\<bind> (\\<lambda>_. Done ())))))\n     () |\\<^sub>=\n    CNV (stateless_callee\n          (\\<lambda>_.\n              Pause (Inr ())\n               (case_sum (\\<lambda>a. Done None)\n                 (case_option (Done None)\n                   (\\<lambda>c.\n                       Pause (Inl ()) Done \\<bind>\n                       (\\<lambda>k. Done (dec \\<eta> (projl k) c)))))))\n     () \\<rhd>\n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         ((key.key_oracle (key \\<eta>))\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>channel.send_oracle) \\<oplus>\\<^sub>O\n         (key.key_oracle (key \\<eta>))\\<dagger> \\<oplus>\\<^sub>O\n         \\<dagger>channel.recv_oracle)\n     (None, Void) =\n    RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n         (\\<lambda>s m.\n             (key.key_oracle (key \\<eta>))\\<dagger> s () \\<bind>\n             (\\<lambda>(k, s).\n                 enc \\<eta> k m \\<bind>\n                 (\\<lambda>c.\n                     \\<dagger>channel.send_oracle s c \\<bind>\n                     (\\<lambda>(uu_, s).\n                         return_spmf ((), s))))) \\<oplus>\\<^sub>O\n         (\\<lambda>s m.\n             \\<dagger>channel.recv_oracle s () \\<bind>\n             (\\<lambda>(c, s).\n                 case c of None \\<Rightarrow> return_spmf (None, s)\n                 | Some c' \\<Rightarrow>\n                     (key.key_oracle (key \\<eta>))\\<dagger> s () \\<bind>\n                     (\\<lambda>(k, s). return_spmf (dec \\<eta> k c', s)))))\n     (None, Void)", "by (simp add: conv_callee_parallel_id_left[where s=\"()\", symmetric])\n      ((auto cong: option.case_cong simp add: option.case_distrib[where h=\"\\<lambda>gpv. exec_gpv _ gpv _\"] \n          intro!: extend_state_oracle_parametric ) | subst lift_state_oracle_extend_state_oracle)+"], ["proof (state)\nthis:\n  cipher.res (key \\<eta>) (enc \\<eta>) (dec \\<eta>) =\n  RES (\\<dagger>auth_channel.auth_oracle \\<oplus>\\<^sub>O\n       key_channel_send \\<oplus>\\<^sub>O key_channel_recv)\n   (None, Void)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ideal_resource_wiring: \n  shows \"(CNV callee s) |\\<^sub>= 1\\<^sub>C \\<rhd> channel.res sec_channel.sec_oracle \n    = RES (callee_sec_channel callee \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O \\<dagger>\\<dagger>channel.recv_oracle ) (s, (), Void)\"  (is \"?L1 \\<rhd> _ = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    channel.res sec_channel.sec_oracle =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    channel.res sec_channel.sec_oracle =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "have[simp]: \"\\<I>_full, \\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>\\<^sub>C ?L1 \\<sim> ?L1\" (is \"_, ?I \\<turnstile>\\<^sub>C _ \\<sim> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full,\\<I>_full \\<oplus>\\<^sub>\\<I>\n              (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>\\<^sub>C\n    CNV callee s |\\<^sub>= 1\\<^sub>C \\<sim> CNV callee s |\\<^sub>= 1\\<^sub>C", "by(rule eq_\\<I>_converter_mono)\n      (rule parallel_converter2_eq_\\<I>_cong eq_\\<I>_converter_reflI WT_converter_\\<I>_full \\<I>_full_le_plus_\\<I> order_refl plus_\\<I>_mono)+"], ["proof (state)\nthis:\n  \\<I>_full,\\<I>_full \\<oplus>\\<^sub>\\<I>\n            (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>\\<^sub>C\n  CNV callee s |\\<^sub>= 1\\<^sub>C \\<sim> CNV callee s |\\<^sub>= 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    channel.res sec_channel.sec_oracle =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "have[simp]: \"?I \\<turnstile>c (sec_channel.sec_oracle \\<oplus>\\<^sub>O channel.send_oracle \\<oplus>\\<^sub>O channel.recv_oracle) s \\<surd>\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>c\n    (sec_channel.sec_oracle \\<oplus>\\<^sub>O\n     channel.send_oracle \\<oplus>\\<^sub>O channel.recv_oracle)\n     s \\<surd>", "by(rule WT_plus_oracleI WT_parallel_oracle WT_callee_full; (unfold split_paired_all)?)+"], ["proof (state)\nthis:\n  \\<I>_full \\<oplus>\\<^sub>\\<I>\n  (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>c\n  (sec_channel.sec_oracle \\<oplus>\\<^sub>O\n   channel.send_oracle \\<oplus>\\<^sub>O channel.recv_oracle)\n   ?s1 \\<surd>\n\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    channel.res sec_channel.sec_oracle =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "have[simp]: \"?L1 \\<rhd> RES (sec_channel.sec_oracle \\<oplus>\\<^sub>O channel.send_oracle \\<oplus>\\<^sub>O channel.recv_oracle) Void = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (sec_channel.sec_oracle \\<oplus>\\<^sub>O\n         channel.send_oracle \\<oplus>\\<^sub>O channel.recv_oracle)\n     Void =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "by(simp add: conv_callee_parallel_id_right[where s'=\"()\", symmetric] attach_CNV_RES \n        attach_callee_parallel_intercept resource_of_oracle_rprodl extend_state_oracle_plus_oracle)"], ["proof (state)\nthis:\n  CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n  RES (sec_channel.sec_oracle \\<oplus>\\<^sub>O\n       channel.send_oracle \\<oplus>\\<^sub>O channel.recv_oracle)\n   Void =\n  RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n       \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n       \\<dagger>\\<dagger>channel.recv_oracle)\n   (s, (), Void)\n\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    channel.res sec_channel.sec_oracle =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    channel.res sec_channel.sec_oracle =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "unfolding channel.res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (sec_channel.sec_oracle \\<oplus>\\<^sub>O\n         channel.send_oracle \\<oplus>\\<^sub>O channel.recv_oracle)\n     Void =\n    RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>channel.recv_oracle)\n     (s, (), Void)", "by (subst eq_\\<I>_attach[OF WT_resource_of_oracle, where ?\\<I>' = \"?I\" and ?conv=\"?L1\" and ?conv'=\"?L1\"]) simp_all"], ["proof (state)\nthis:\n  CNV callee s |\\<^sub>= 1\\<^sub>C \\<rhd>\n  channel.res sec_channel.sec_oracle =\n  RES (callee_sec_channel callee \\<oplus>\\<^sub>O\n       \\<dagger>\\<dagger>channel.send_oracle \\<oplus>\\<^sub>O\n       \\<dagger>\\<dagger>channel.recv_oracle)\n   (s, (), Void)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma eq_\\<I>_gpv_Done1:\n  \"eq_\\<I>_gpv A \\<I> (Done x) gpv \\<longleftrightarrow> lossless_spmf (the_gpv gpv) \\<and> (\\<forall>a\\<in>set_spmf (the_gpv gpv). eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>) (Pure x) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (Done x) gpv =\n    (lossless_spmf (the_gpv gpv) \\<and>\n     (\\<forall>a\\<in>set_spmf (the_gpv gpv).\n         eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>) (Pure x) a))", "by(auto intro: eq_\\<I>_gpv.intros simp add: rel_spmf_return_spmf1 elim: eq_\\<I>_gpv.cases)"], ["", "lemma eq_\\<I>_gpv_Done2:\n  \"eq_\\<I>_gpv A \\<I> gpv (Done x) \\<longleftrightarrow> lossless_spmf (the_gpv gpv) \\<and> (\\<forall>a\\<in>set_spmf (the_gpv gpv). eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>) a (Pure x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv (Done x) =\n    (lossless_spmf (the_gpv gpv) \\<and>\n     (\\<forall>a\\<in>set_spmf (the_gpv gpv).\n         eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>) a (Pure x)))", "by(auto intro: eq_\\<I>_gpv.intros simp add: rel_spmf_return_spmf2 elim: eq_\\<I>_gpv.cases)"], ["", "context begin"], ["", "interpretation CIPHER: cipher \"key \\<eta>\" \"enc \\<eta>\" \"dec \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation S_CHAN: sec_channel"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma one_time_pad:\n  defines \"\\<I>_real \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))\"\n    and \"\\<I>_ideal \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform UNIV {None, Some \\<eta>}\"\n    and \"\\<I>_common \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))\"\n  shows\n    \"constructive_security2 CIPHER.res (\\<lambda>_. S_CHAN.res) (\\<lambda>_. CNV sim None)\n     \\<I>_real \\<I>_ideal \\<I>_common (\\<lambda>_. \\<infinity>) False (\\<lambda>_. auth_sec_wiring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constructive_security2 CIPHER.res (\\<lambda>_. S_CHAN.res)\n     (\\<lambda>_. CNV sim None) \\<I>_real \\<I>_ideal \\<I>_common\n     (\\<lambda>_. \\<infinity>) False (\\<lambda>_. (id, map_option length))", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "let ?\\<I>_key = \"\\<lambda>\\<eta>. \\<I>_uniform UNIV (nlists UNIV \\<eta>)\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "let ?\\<I>_enc = \"\\<lambda>\\<eta>. \\<I>_uniform (nlists UNIV \\<eta>) UNIV\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "let ?\\<I>_dec = \"\\<lambda>\\<eta>. \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have i1 [WT_intro]: \"\\<I>_uniform (nlists UNIV \\<eta>) UNIV, ?\\<I>_key \\<eta> \\<oplus>\\<^sub>\\<I> ?\\<I>_enc \\<eta> \\<turnstile>\\<^sub>C CIPHER.enc \\<eta> \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV,\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<turnstile>\\<^sub>C\n    CIPHER.enc \\<eta> \\<surd>", "unfolding CIPHER.enc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV,\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<turnstile>\\<^sub>C\n    CNV (stateless_callee\n          (\\<lambda>m.\n              Pause (Inl ()) Done \\<bind>\n              (\\<lambda>k.\n                  lift_spmf (enc \\<eta> (projl k) m) \\<bind>\n                  (\\<lambda>c.\n                      Pause (Inr c) Done \\<bind> (\\<lambda>_. Done ())))))\n     () \\<surd>", "by(rule WT_converter_of_callee)(auto simp add: stateless_callee_def enc_def in_nlists_UNIV)"], ["proof (state)\nthis:\n  \\<I>_uniform (nlists UNIV ?\\<eta>4) UNIV,\n  \\<I>_uniform UNIV (nlists UNIV ?\\<eta>4) \\<oplus>\\<^sub>\\<I>\n  \\<I>_uniform (nlists UNIV ?\\<eta>4) UNIV \\<turnstile>\\<^sub>C\n  CIPHER.enc ?\\<eta>4 \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have i2 [WT_intro]: \"?\\<I>_dec \\<eta>, ?\\<I>_key \\<eta> \\<oplus>\\<^sub>\\<I> ?\\<I>_dec \\<eta> \\<turnstile>\\<^sub>C CIPHER.dec \\<eta> \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV\n     (insert None (Some ` nlists UNIV \\<eta>)) \\<turnstile>\\<^sub>C\n    CIPHER.dec \\<eta> \\<surd>", "unfolding CIPHER.dec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV\n     (insert None (Some ` nlists UNIV \\<eta>)) \\<turnstile>\\<^sub>C\n    CNV (stateless_callee\n          (\\<lambda>_.\n              Pause (Inr ())\n               (\\<lambda>c'.\n                   case c' of Inl a \\<Rightarrow> Done None\n                   | Inr None \\<Rightarrow> Done None\n                   | Inr (Some c) \\<Rightarrow>\n                       Pause (Inl ()) Done \\<bind>\n                       (\\<lambda>k. Done (dec \\<eta> (projl k) c)))))\n     () \\<surd>", "by(rule WT_converter_of_callee)(auto simp add: stateless_callee_def dec_def in_nlists_UNIV)"], ["proof (state)\nthis:\n  \\<I>_uniform UNIV (insert None (Some ` nlists UNIV ?\\<eta>4)),\n  \\<I>_uniform UNIV (nlists UNIV ?\\<eta>4) \\<oplus>\\<^sub>\\<I>\n  \\<I>_uniform UNIV\n   (insert None (Some ` nlists UNIV ?\\<eta>4)) \\<turnstile>\\<^sub>C\n  CIPHER.dec ?\\<eta>4 \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have [WT_intro]: \"\\<I>_common \\<eta>, (?\\<I>_key \\<eta> \\<oplus>\\<^sub>\\<I> ?\\<I>_enc \\<eta>) \\<oplus>\\<^sub>\\<I> (?\\<I>_key \\<eta> \\<oplus>\\<^sub>\\<I> ?\\<I>_dec \\<eta>) \\<turnstile>\\<^sub>C CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta> \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_common \\<eta>,\n    (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (nlists UNIV \\<eta>) UNIV) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform UNIV\n      (insert None (Some ` nlists UNIV \\<eta>))) \\<turnstile>\\<^sub>C\n    CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta> \\<surd>", "unfolding \\<I>_common_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (nlists UNIV \\<eta>) UNIV) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform UNIV\n      (insert None (Some ` nlists UNIV \\<eta>))) \\<turnstile>\\<^sub>C\n    CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta> \\<surd>", "by(rule WT_intro)+"], ["proof (state)\nthis:\n  \\<I>_common ?\\<eta>4,\n  (\\<I>_uniform UNIV (nlists UNIV ?\\<eta>4) \\<oplus>\\<^sub>\\<I>\n   \\<I>_uniform (nlists UNIV ?\\<eta>4) UNIV) \\<oplus>\\<^sub>\\<I>\n  (\\<I>_uniform UNIV (nlists UNIV ?\\<eta>4) \\<oplus>\\<^sub>\\<I>\n   \\<I>_uniform UNIV\n    (insert None (Some ` nlists UNIV ?\\<eta>4))) \\<turnstile>\\<^sub>C\n  CIPHER.enc ?\\<eta>4 |\\<^sub>= CIPHER.dec ?\\<eta>4 \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have key: \"callee_invariant_on (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O CIPHER.KEY.key_oracle \\<eta>) (pred_option (\\<lambda>x. length x = \\<eta>))\n     (?\\<I>_key \\<eta> \\<oplus>\\<^sub>\\<I> ?\\<I>_key \\<eta>)\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on\n     (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n      CIPHER.KEY.key_oracle \\<eta>)\n     (pred_option (\\<lambda>x. length x = \\<eta>))\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (nlists UNIV \\<eta>))", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                         CIPHER.KEY.key_oracle \\<eta>)\n                         s x);\n        pred_option (\\<lambda>x. length x = \\<eta>) s;\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n                  \\<I>_uniform UNIV (nlists UNIV \\<eta>))\\<rbrakk>\n       \\<Longrightarrow> pred_option (\\<lambda>x. length x = \\<eta>) s'\n 2. \\<And>s.\n       pred_option (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s')\n             \\<in> set_spmf\n                    ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                      CIPHER.KEY.key_oracle \\<eta>)\n                      s x);\n     pred_option (\\<lambda>x. length x = \\<eta>) s;\n     x \\<in> outs_\\<I>\n              (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n               \\<I>_uniform UNIV (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> pred_option (\\<lambda>x. length x = \\<eta>) s'", "by(cases s; cases x)(auto simp add: option.pred_set, simp_all add: key_def in_nlists_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_option (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c\n    (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n     CIPHER.KEY.key_oracle \\<eta>)\n     s \\<surd>", "by(cases s)(auto intro!: WT_calleeI, simp_all add: key_def in_nlists_UNIV)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  callee_invariant_on\n   (CIPHER.KEY.key_oracle ?\\<eta>4 \\<oplus>\\<^sub>O\n    CIPHER.KEY.key_oracle ?\\<eta>4)\n   (pred_option (\\<lambda>x. length x = ?\\<eta>4))\n   (\\<I>_uniform UNIV (nlists UNIV ?\\<eta>4) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV ?\\<eta>4))\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have i3: \"?\\<I>_key \\<eta> \\<oplus>\\<^sub>\\<I> ?\\<I>_key \\<eta> \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n    \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>", "unfolding CIPHER.KEY.res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n    \\<turnstile>res RES (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                         CIPHER.KEY.key_oracle \\<eta>)\n                     None \\<surd>", "by(rule callee_invariant_on.WT_resource_of_oracle[OF key]) simp"], ["proof (state)\nthis:\n  \\<I>_uniform UNIV (nlists UNIV ?\\<eta>4) \\<oplus>\\<^sub>\\<I>\n  \\<I>_uniform UNIV (nlists UNIV ?\\<eta>4) \n  \\<turnstile>res CIPHER.KEY.res ?\\<eta>4 \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "let ?I = \"\\<lambda>\\<eta>. pred_cstate (\\<lambda>x. length x = \\<eta>)\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have WT_auth: \"\\<I>_real \\<eta> \\<turnstile>c CIPHER.AUTH.auth_oracle s \\<surd>\" if \"?I \\<eta> s\" for \\<eta> s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<turnstile>c CIPHER.AUTH.auth_oracle s \\<surd>", "apply(rule WT_calleeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> (\\<I>_real \\<eta>);\n        (ret, sa) \\<in> set_spmf (CIPHER.AUTH.auth_oracle s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> (\\<I>_real \\<eta>) call", "subgoal for x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I> (\\<I>_real \\<eta>);\n     (y, s') \\<in> set_spmf (CIPHER.AUTH.auth_oracle s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I> (\\<I>_real \\<eta>) x", "using that"], ["proof (prove)\nusing this:\n  pred_cstate (\\<lambda>x. length x = \\<eta>) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I> (\\<I>_real \\<eta>);\n     (y, s') \\<in> set_spmf (CIPHER.AUTH.auth_oracle s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I> (\\<I>_real \\<eta>) x", "by(cases \"(s, x)\" rule: CIPHER.AUTH.auth_oracle.cases)(auto simp add: \\<I>_real_def in_nlists_UNIV intro!: imageI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pred_cstate (\\<lambda>x. length x = ?\\<eta>5) ?s5 \\<Longrightarrow>\n  \\<I>_real ?\\<eta>5 \\<turnstile>c CIPHER.AUTH.auth_oracle ?s5 \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have WT_recv: \"?\\<I>_dec \\<eta> \\<turnstile>c S_CHAN.recv_oracle s \\<surd>\" if \"pred_cstate (\\<lambda>x. length x = \\<eta>) s\" for \\<eta> s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV\n     (insert None (Some ` nlists UNIV \\<eta>)) \\<turnstile>c\n    S_CHAN.recv_oracle s \\<surd>", "using that"], ["proof (prove)\nusing this:\n  pred_cstate (\\<lambda>x. length x = \\<eta>) s\n\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV\n     (insert None (Some ` nlists UNIV \\<eta>)) \\<turnstile>c\n    S_CHAN.recv_oracle s \\<surd>", "by(cases s)(auto intro!: WT_calleeI simp add: in_nlists_UNIV)"], ["proof (state)\nthis:\n  pred_cstate (\\<lambda>x. length x = ?\\<eta>6) ?s6 \\<Longrightarrow>\n  \\<I>_uniform UNIV\n   (insert None (Some ` nlists UNIV ?\\<eta>6)) \\<turnstile>c\n  S_CHAN.recv_oracle ?s6 \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have WT_send: \"?\\<I>_enc \\<eta> \\<turnstile>c S_CHAN.send_oracle s \\<surd>\" for \\<eta> s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<turnstile>c\n    S_CHAN.send_oracle s \\<surd>", "by(rule WT_calleeI)(auto)"], ["proof (state)\nthis:\n  \\<I>_uniform (nlists UNIV ?\\<eta>7) UNIV \\<turnstile>c\n  S_CHAN.send_oracle ?s7 \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have *: \"callee_invariant_on (CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle) (?I \\<eta>)\n     (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on\n     (CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n      S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n     (pred_cstate (\\<lambda>x. length x = \\<eta>))\n     (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.send_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.recv_oracle)\n                         s x);\n        pred_cstate (\\<lambda>x. length x = \\<eta>) s;\n        x \\<in> outs_\\<I>\n                 (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I>\n                  \\<I>_common \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> pred_cstate (\\<lambda>x. length x = \\<eta>) s'\n 2. \\<And>s.\n       pred_cstate (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>c\n       (CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n        S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n        s \\<surd>", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s')\n             \\<in> set_spmf\n                    ((CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n                      S_CHAN.send_oracle \\<oplus>\\<^sub>O\n                      S_CHAN.recv_oracle)\n                      s x);\n     pred_cstate (\\<lambda>x. length x = \\<eta>) s;\n     x \\<in> outs_\\<I>\n              (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I>\n               \\<I>_common \\<eta>)\\<rbrakk>\n    \\<Longrightarrow> pred_cstate (\\<lambda>x. length x = \\<eta>) s'", "by(cases x; cases \"(s, projl x)\" rule: CIPHER.AUTH.auth_oracle.cases; cases \"projr x\")(auto simp add: \\<I>_common_def in_nlists_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_cstate (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>c\n       (CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n        S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n        s \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_cstate (\\<lambda>x. length x = \\<eta>) s_ \\<Longrightarrow>\n    \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>c\n    (CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n     S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n     s_ \\<surd>", "by(auto simp add: \\<I>_common_def WT_auth WT_recv intro: WT_calleeI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  callee_invariant_on\n   (CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n    S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n   (pred_cstate (\\<lambda>x. length x = ?\\<eta>7))\n   (\\<I>_real ?\\<eta>7 \\<oplus>\\<^sub>\\<I> \\<I>_common ?\\<eta>7)\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have i4 [unfolded \\<I>_common_def, WT_intro]: \"\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>res CIPHER.AUTH.res \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CIPHER.AUTH.res \\<surd>", "unfolding CIPHER.AUTH.res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res RES (CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.send_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.recv_oracle)\n                     Void \\<surd>", "by(rule callee_invariant_on.WT_resource_of_oracle[OF *]) simp"], ["proof (state)\nthis:\n  \\<I>_real ?\\<eta>7 \\<oplus>\\<^sub>\\<I>\n  (\\<I>_uniform (nlists UNIV ?\\<eta>7) UNIV \\<oplus>\\<^sub>\\<I>\n   \\<I>_uniform UNIV (insert None (Some ` nlists UNIV ?\\<eta>7))) \n  \\<turnstile>res CIPHER.AUTH.res \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 3. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 4. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 5. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "show cipher: \"\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>res CIPHER.res \\<eta> \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CIPHER.res \\<eta> \\<surd>", "unfolding CIPHER.res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res 1\\<^sub>C |\\<^sub>=\n                    CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta> \\<rhd>\n                    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n                    parallel_resource1_wiring \\<rhd>\n                    CIPHER.KEY.res \\<eta> \\<parallel>\n                    CIPHER.AUTH.res \\<surd>", "by(rule WT_intro i3)+"], ["proof (state)\nthis:\n  \\<I>_real ?\\<eta>7 \\<oplus>\\<^sub>\\<I> \\<I>_common ?\\<eta>7 \n  \\<turnstile>res CIPHER.res ?\\<eta>7 \\<surd>\n\ngoal (4 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n       \\<turnstile>res S_CHAN.res \\<surd>\n 2. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 3. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 4. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "show secure: \"\\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>res S_CHAN.res \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res S_CHAN.res \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res S_CHAN.res \\<surd>", "have[simp]:\"\\<I>_ideal \\<eta> \\<turnstile>c S_CHAN.sec_oracle s \\<surd>\" if \"?I \\<eta> s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<turnstile>c S_CHAN.sec_oracle s \\<surd>", "proof (cases rule: WT_calleeI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> (\\<I>_ideal \\<eta>);\n        (ret, sa) \\<in> set_spmf (S_CHAN.sec_oracle s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> (\\<I>_ideal \\<eta>) call", "case (1 call ret s')"], ["proof (state)\nthis:\n  call \\<in> outs_\\<I> (\\<I>_ideal \\<eta>)\n  (ret, s') \\<in> set_spmf (S_CHAN.sec_oracle s call)\n\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call \\<in> outs_\\<I> (\\<I>_ideal \\<eta>);\n        (ret, sa) \\<in> set_spmf (S_CHAN.sec_oracle s call)\\<rbrakk>\n       \\<Longrightarrow> ret \\<in> responses_\\<I> (\\<I>_ideal \\<eta>) call", "then"], ["proof (chain)\npicking this:\n  call \\<in> outs_\\<I> (\\<I>_ideal \\<eta>)\n  (ret, s') \\<in> set_spmf (S_CHAN.sec_oracle s call)", "show ?case"], ["proof (prove)\nusing this:\n  call \\<in> outs_\\<I> (\\<I>_ideal \\<eta>)\n  (ret, s') \\<in> set_spmf (S_CHAN.sec_oracle s call)\n\ngoal (1 subgoal):\n 1. ret \\<in> responses_\\<I> (\\<I>_ideal \\<eta>) call", "using that"], ["proof (prove)\nusing this:\n  call \\<in> outs_\\<I> (\\<I>_ideal \\<eta>)\n  (ret, s') \\<in> set_spmf (S_CHAN.sec_oracle s call)\n  pred_cstate (\\<lambda>x. length x = \\<eta>) s\n\ngoal (1 subgoal):\n 1. ret \\<in> responses_\\<I> (\\<I>_ideal \\<eta>) call", "by (cases \"(s, call)\" rule: S_CHAN.sec_oracle.cases) (simp_all add: \\<I>_ideal_def)"], ["proof (state)\nthis:\n  ret \\<in> responses_\\<I> (\\<I>_ideal \\<eta>) call\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pred_cstate (\\<lambda>x. length x = \\<eta>) ?s8 \\<Longrightarrow>\n  \\<I>_ideal \\<eta> \\<turnstile>c S_CHAN.sec_oracle ?s8 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res S_CHAN.res \\<surd>", "have[simp]: \"\\<I>_common \\<eta> \\<turnstile>c (S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle) s \\<surd>\" \n      if \"pred_cstate (\\<lambda>x. length x = \\<eta>) s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_common \\<eta> \\<turnstile>c\n    (S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle) s \\<surd>", "unfolding \\<I>_common_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV\n     (insert None (Some ` nlists UNIV \\<eta>)) \\<turnstile>c\n    (S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle) s \\<surd>", "by(rule WT_plus_oracleI WT_send WT_recv that)+"], ["proof (state)\nthis:\n  pred_cstate (\\<lambda>x. length x = \\<eta>) ?s8 \\<Longrightarrow>\n  \\<I>_common \\<eta> \\<turnstile>c\n  (S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle) ?s8 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res S_CHAN.res \\<surd>", "have *: \"callee_invariant_on (S_CHAN.sec_oracle \\<oplus>\\<^sub>O S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle) (?I \\<eta>) (\\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on\n     (S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n      S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n     (pred_cstate (\\<lambda>x. length x = \\<eta>))\n     (\\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.send_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.recv_oracle)\n                         s x);\n        pred_cstate (\\<lambda>x. length x = \\<eta>) s;\n        x \\<in> outs_\\<I>\n                 (\\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I>\n                  \\<I>_common \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> pred_cstate (\\<lambda>x. length x = \\<eta>) s'\n 2. \\<And>s.\n       pred_cstate (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I>\n       \\<I>_common \\<eta> \\<turnstile>c\n       (S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n        S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n        s \\<surd>", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s')\n             \\<in> set_spmf\n                    ((S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n                      S_CHAN.send_oracle \\<oplus>\\<^sub>O\n                      S_CHAN.recv_oracle)\n                      s x);\n     pred_cstate (\\<lambda>x. length x = \\<eta>) s;\n     x \\<in> outs_\\<I>\n              (\\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I>\n               \\<I>_common \\<eta>)\\<rbrakk>\n    \\<Longrightarrow> pred_cstate (\\<lambda>x. length x = \\<eta>) s'", "by(cases \"(s, projl x)\" rule: S_CHAN.sec_oracle.cases; cases \"projr x\")(auto simp add: \\<I>_common_def in_nlists_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_cstate (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I>\n       \\<I>_common \\<eta> \\<turnstile>c\n       (S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n        S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n        s \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_cstate (\\<lambda>x. length x = \\<eta>) s_ \\<Longrightarrow>\n    \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>c\n    (S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n     S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n     s_ \\<surd>", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  callee_invariant_on\n   (S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n    S_CHAN.send_oracle \\<oplus>\\<^sub>O S_CHAN.recv_oracle)\n   (pred_cstate (\\<lambda>x. length x = \\<eta>))\n   (\\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res S_CHAN.res \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res S_CHAN.res \\<surd>", "unfolding S_CHAN.res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res RES (S_CHAN.sec_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.send_oracle \\<oplus>\\<^sub>O\n                         S_CHAN.recv_oracle)\n                     Void \\<surd>", "by(rule callee_invariant_on.WT_resource_of_oracle[OF *]) simp"], ["proof (state)\nthis:\n  \\<I>_ideal \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n  \\<turnstile>res S_CHAN.res \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<I>_ideal ?\\<eta>7 \\<oplus>\\<^sub>\\<I> \\<I>_common ?\\<eta>7 \n  \\<turnstile>res S_CHAN.res \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 2. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 3. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have sim [WT_intro]: \"\\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C CNV sim s \\<surd>\" if \"s \\<noteq> None \\<longrightarrow> length (the s) = \\<eta>\" for s \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n    CNV sim s \\<surd>", "using that"], ["proof (prove)\nusing this:\n  s \\<noteq> None \\<longrightarrow> length (the s) = \\<eta>\n\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n    CNV sim s \\<surd>", "by(coinduction arbitrary: s)(auto simp add: sim_def \\<I>_ideal_def \\<I>_real_def in_nlists_UNIV)"], ["proof (state)\nthis:\n  ?s7 \\<noteq> None \\<longrightarrow>\n  length (the ?s7) = ?\\<eta>7 \\<Longrightarrow>\n  \\<I>_real ?\\<eta>7, \\<I>_ideal ?\\<eta>7 \\<turnstile>\\<^sub>C\n  CNV sim ?s7 \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n       CNV sim None \\<surd>\n 2. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 3. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "show \"\\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C CNV sim None \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n    CNV sim None \\<surd>", "by(rule sim) simp"], ["proof (state)\nthis:\n  \\<I>_real ?\\<eta>7, \\<I>_ideal ?\\<eta>7 \\<turnstile>\\<^sub>C\n  CNV sim None \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 2. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "{"], ["proof (state)\nthis:\n  \\<I>_real ?\\<eta>7, \\<I>_ideal ?\\<eta>7 \\<turnstile>\\<^sub>C\n  CNV sim None \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 2. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "fix \\<A> :: \"security \\<Rightarrow> (auth_query + bool list + unit, bool list option + unit + bool list option) distinguisher\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 2. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "assume WT: \"\\<And>\\<eta>. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>g \\<A> \\<eta> \\<surd>\"\n      and bound: \"\\<And>\\<eta>. interaction_bounded_by (\\<lambda>_. True) (\\<A> \\<eta>) \\<infinity>\""], ["proof (state)\nthis:\n  \\<I>_real ?\\<eta>7 \\<oplus>\\<^sub>\\<I> \\<I>_common ?\\<eta>7\n  \\<turnstile>g \\<A> ?\\<eta>7 \\<surd>\n  interaction_any_bounded_by (\\<A> ?\\<eta>7) \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 2. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have \"connect (\\<A> \\<eta>) (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res) = connect (\\<A> \\<eta>) (CIPHER.res \\<eta>)\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. connect (\\<A> \\<eta>)\n     (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res) =\n    connect (\\<A> \\<eta>) (CIPHER.res \\<eta>)", "using _ WT"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<I>_real ?\\<eta>7 \\<oplus>\\<^sub>\\<I> \\<I>_common ?\\<eta>7\n  \\<turnstile>g \\<A> ?\\<eta>7 \\<surd>\n\ngoal (1 subgoal):\n 1. connect (\\<A> \\<eta>)\n     (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res) =\n    connect (\\<A> \\<eta>) (CIPHER.res \\<eta>)", "proof(rule connect_cong_trace)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?A \\<turnstile>\\<^sub>R\n    CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res\n    \\<approx> CIPHER.res \\<eta>\n 2. outs_gpv (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n     (\\<A> \\<eta>)\n    \\<subseteq> ?A\n 3. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                    S_CHAN.res \\<surd>\n 4. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CIPHER.res \\<eta> \\<surd>", "show \"(UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res \\<approx> CIPHER.res \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n    CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res\n    \\<approx> CIPHER.res \\<eta>", "unfolding ideal_resource_wiring real_resource_wiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n    RES (??.One_Time_Pad.callee_sec_channel sim \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>S_CHAN.send_oracle \\<oplus>\\<^sub>O\n         \\<dagger>\\<dagger>S_CHAN.recv_oracle)\n     (None, (), Void)\n    \\<approx> RES (\\<dagger>CIPHER.AUTH.auth_oracle \\<oplus>\\<^sub>O\n                   ??.One_Time_Pad.key_channel_send \\<eta> \\<oplus>\\<^sub>O\n                   ??.One_Time_Pad.key_channel_recv \\<eta>)\n               (None, Void)", "by(rule resources_indistinguishable)"], ["proof (state)\nthis:\n  (UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV) \\<turnstile>\\<^sub>R\n  CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res\n  \\<approx> CIPHER.res \\<eta>\n\ngoal (3 subgoals):\n 1. outs_gpv (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n     (\\<A> \\<eta>)\n    \\<subseteq> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n 2. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                    S_CHAN.res \\<surd>\n 3. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CIPHER.res \\<eta> \\<surd>", "show \"outs_gpv (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>) (\\<A> \\<eta>) \\<subseteq> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_gpv (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n     (\\<A> \\<eta>)\n    \\<subseteq> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV", "using WT[of \\<eta>, THEN WT_gpv_outs_gpv]"], ["proof (prove)\nusing this:\n  outs_gpv (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n   (\\<A> \\<eta>)\n  \\<subseteq> outs_\\<I>\n               (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n\ngoal (1 subgoal):\n 1. outs_gpv (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n     (\\<A> \\<eta>)\n    \\<subseteq> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV", "by(auto simp add: \\<I>_real_def \\<I>_common_def id'_def)"], ["proof (state)\nthis:\n  outs_gpv (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n   (\\<A> \\<eta>)\n  \\<subseteq> UNIV <+> nlists UNIV (id' \\<eta>) <+> UNIV\n\ngoal (2 subgoals):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                    S_CHAN.res \\<surd>\n 2. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CIPHER.res \\<eta> \\<surd>", "show \"\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>res CIPHER.res \\<eta> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CIPHER.res \\<eta> \\<surd>", "by(rule cipher)"], ["proof (state)\nthis:\n  \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n  \\<turnstile>res CIPHER.res \\<eta> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                    S_CHAN.res \\<surd>", "show \"\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \\<turnstile>res CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n    \\<turnstile>res CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                    S_CHAN.res \\<surd>", "by(rule WT_intro secure | simp)+"], ["proof (state)\nthis:\n  \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta> \n  \\<turnstile>res CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  connect (\\<A> ?\\<eta>7)\n   (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res) =\n  connect (\\<A> ?\\<eta>7) (CIPHER.res ?\\<eta>7)\n\ngoal (2 subgoals):\n 1. \\<And>\\<A>.\n       \\<lbrakk>\\<And>\\<eta>.\n                   \\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>\n                   \\<turnstile>g \\<A> \\<eta> \\<surd>;\n        \\<And>\\<eta>. interaction_any_bounded_by (\\<A> \\<eta>) \\<infinity>;\n        \\<And>\\<eta>.\n           False \\<Longrightarrow>\n           plossless_gpv\n            (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n            (\\<A> \\<eta>)\\<rbrakk>\n       \\<Longrightarrow> Negligible.negligible\n                          (\\<lambda>\\<eta>.\n                              advantage (\\<A> \\<eta>)\n                               (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd>\n                                S_CHAN.res)\n                               (CIPHER.res \\<eta>))\n 2. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "then"], ["proof (chain)\npicking this:\n  connect (\\<A> ?\\<eta>7)\n   (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res) =\n  connect (\\<A> ?\\<eta>7) (CIPHER.res ?\\<eta>7)", "show \"negligible (\\<lambda>\\<eta>. advantage (\\<A> \\<eta>) (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res) (CIPHER.res \\<eta>))\""], ["proof (prove)\nusing this:\n  connect (\\<A> ?\\<eta>7)\n   (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res) =\n  connect (\\<A> ?\\<eta>7) (CIPHER.res ?\\<eta>7)\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>.\n         advantage (\\<A> \\<eta>)\n          (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res)\n          (CIPHER.res \\<eta>))", "by(simp add: advantage_def)"], ["proof (state)\nthis:\n  Negligible.negligible\n   (\\<lambda>\\<eta>.\n       advantage (\\<A> \\<eta>)\n        (CNV sim None |\\<^sub>= 1\\<^sub>C \\<rhd> S_CHAN.res)\n        (CIPHER.res \\<eta>))\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "let ?cnv = \"map_converter id id auth_query_of sec_response_of 1\\<^sub>C \n      :: (auth_query, nat option, auth_query, bool list option) converter\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have [simp]: \"\\<I>_full, map_\\<I> id (map_option length) \\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full,\n    map_\\<I> id (map_option length) \\<I>_full \\<turnstile>\\<^sub>C\n    1\\<^sub>C \\<surd>", "using WT_converter_id order_refl"], ["proof (prove)\nusing this:\n  ?\\<I>, ?\\<I> \\<turnstile>\\<^sub>C 1\\<^sub>C \\<surd>\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<I>_full,\n    map_\\<I> id (map_option length) \\<I>_full \\<turnstile>\\<^sub>C\n    1\\<^sub>C \\<surd>", "by(rule WT_converter_mono)(simp add: le_\\<I>_def)"], ["proof (state)\nthis:\n  \\<I>_full, map_\\<I> id (map_option length) \\<I>_full \\<turnstile>\\<^sub>C\n  1\\<^sub>C \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have WT [WT_intro]: \"\\<I>_ideal \\<eta>, \\<I>_real \\<eta> \\<turnstile>\\<^sub>C ?cnv \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta>, \\<I>_real \\<eta> \\<turnstile>\\<^sub>C\n    map_converter id id id (map_option length) 1\\<^sub>C \\<surd>", "by(rule WT_converter_map_converter)(auto simp add: \\<I>_ideal_def \\<I>_real_def intro!: WT_converter_mono[OF WT_converter_id order_refl] simp add: le_\\<I>_def in_nlists_UNIV)"], ["proof (state)\nthis:\n  \\<I>_ideal ?\\<eta>8, \\<I>_real ?\\<eta>8 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "with eq_\\<I>_converter_reflI[OF this]"], ["proof (chain)\npicking this:\n  \\<I>_ideal ?\\<eta>9,\\<I>_real ?\\<eta>9 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<sim>\n  map_converter id id id (map_option length) 1\\<^sub>C\n  \\<I>_ideal ?\\<eta>8, \\<I>_real ?\\<eta>8 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<surd>", "have \"wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) ?cnv auth_sec_wiring\" for \\<eta>"], ["proof (prove)\nusing this:\n  \\<I>_ideal ?\\<eta>9,\\<I>_real ?\\<eta>9 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<sim>\n  map_converter id id id (map_option length) 1\\<^sub>C\n  \\<I>_ideal ?\\<eta>8, \\<I>_real ?\\<eta>8 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<surd>\n\ngoal (1 subgoal):\n 1. wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>)\n     (map_converter id id id (map_option length) 1\\<^sub>C)\n     (id, map_option length)", ".."], ["proof (state)\nthis:\n  wiring (\\<I>_ideal ?\\<eta>8) (\\<I>_real ?\\<eta>8)\n   (map_converter id id id (map_option length) 1\\<^sub>C)\n   (id, map_option length)\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "moreover"], ["proof (state)\nthis:\n  wiring (\\<I>_ideal ?\\<eta>8) (\\<I>_real ?\\<eta>8)\n   (map_converter id id id (map_option length) 1\\<^sub>C)\n   (id, map_option length)\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have eq: \"\\<I>_ideal \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C map_converter id (map_option length) id id (CNV sim s) \\<sim> 1\\<^sub>C\"\n      if \"s \\<noteq> None \\<longrightarrow> length (the s) = \\<eta>\" for \\<eta> and s :: \"bool list option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta>,\\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n    map_converter id (map_option length) id id (CNV sim s) \\<sim> 1\\<^sub>C", "unfolding map_converter_of_callee map_gpv_conv_map_gpv'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta>,\\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n    CNV (map_fun id\n          (map_fun id (map_gpv (map_prod (map_option length) id) id)) sim)\n     s \\<sim>\n    1\\<^sub>C", "using that"], ["proof (prove)\nusing this:\n  s \\<noteq> None \\<longrightarrow> length (the s) = \\<eta>\n\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta>,\\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n    CNV (map_fun id\n          (map_fun id (map_gpv (map_prod (map_option length) id) id)) sim)\n     s \\<sim>\n    1\\<^sub>C", "by(coinduction arbitrary: s)\n        (fastforce intro!: eq_\\<I>_gpv_Pause simp add: \\<I>_ideal_def in_nlists_UNIV eq_\\<I>_gpv_Done2 gpv.map_sel eq_onp_same_args sim_def map_gpv_conv_bind[symmetric] id_def[symmetric] split!: option.split if_split_asm)"], ["proof (state)\nthis:\n  ?s8 \\<noteq> None \\<longrightarrow>\n  length (the ?s8) = ?\\<eta>8 \\<Longrightarrow>\n  \\<I>_ideal ?\\<eta>8,\\<I>_ideal ?\\<eta>8 \\<turnstile>\\<^sub>C\n  map_converter id (map_option length) id id (CNV sim ?s8) \\<sim> 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "have \"\\<I>_ideal \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C ?cnv \\<odot> CNV sim None \\<surd>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<eta>, \\<I>_ideal \\<eta> \\<turnstile>\\<^sub>C\n    map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n    CNV sim None \\<surd>", "by(rule WT WT_intro)+ simp"], ["proof (state)\nthis:\n  \\<I>_ideal ?\\<eta>8, \\<I>_ideal ?\\<eta>8 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n  CNV sim None \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "with _"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<I>_ideal ?\\<eta>8, \\<I>_ideal ?\\<eta>8 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n  CNV sim None \\<surd>", "have \"wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>) (?cnv \\<odot> CNV sim None) (id, id)\" for \\<eta>"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<I>_ideal ?\\<eta>8, \\<I>_ideal ?\\<eta>8 \\<turnstile>\\<^sub>C\n  map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n  CNV sim None \\<surd>\n\ngoal (1 subgoal):\n 1. wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n     (map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n      CNV sim None)\n     (id, id)", "by(rule wiring.intros)(auto  simp add: comp_converter_map_converter1 comp_converter_id_left eq)"], ["proof (state)\nthis:\n  wiring (\\<I>_ideal ?\\<eta>8) (\\<I>_ideal ?\\<eta>8)\n   (map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n    CNV sim None)\n   (id, id)\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "ultimately"], ["proof (chain)\npicking this:\n  wiring (\\<I>_ideal ?\\<eta>8) (\\<I>_real ?\\<eta>8)\n   (map_converter id id id (map_option length) 1\\<^sub>C)\n   (id, map_option length)\n  wiring (\\<I>_ideal ?\\<eta>8) (\\<I>_ideal ?\\<eta>8)\n   (map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n    CNV sim None)\n   (id, id)", "show \"\\<exists>cnv. \\<forall>\\<eta>. wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>) auth_sec_wiring \\<and>\n              wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>) (cnv \\<eta> \\<odot> CNV sim None) (id, id)\""], ["proof (prove)\nusing this:\n  wiring (\\<I>_ideal ?\\<eta>8) (\\<I>_real ?\\<eta>8)\n   (map_converter id id id (map_option length) 1\\<^sub>C)\n   (id, map_option length)\n  wiring (\\<I>_ideal ?\\<eta>8) (\\<I>_ideal ?\\<eta>8)\n   (map_converter id id id (map_option length) 1\\<^sub>C \\<odot>\n    CNV sim None)\n   (id, id)\n\ngoal (1 subgoal):\n 1. \\<exists>cnv.\n       \\<forall>\\<eta>.\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n           (id, map_option length) \\<and>\n          wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n           (cnv \\<eta> \\<odot> CNV sim None) (id, id)", "by meson"], ["proof (state)\nthis:\n  \\<exists>cnv.\n     \\<forall>\\<eta>.\n        wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n         (id, map_option length) \\<and>\n        wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n         (cnv \\<eta> \\<odot> CNV sim None) (id, id)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<exists>cnv.\n     \\<forall>\\<eta>.\n        wiring (\\<I>_ideal \\<eta>) (\\<I>_real \\<eta>) (cnv \\<eta>)\n         (id, map_option length) \\<and>\n        wiring (\\<I>_ideal \\<eta>) (\\<I>_ideal \\<eta>)\n         (cnv \\<eta> \\<odot> CNV sim None) (id, id)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}