{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Examples/Secure_Channel/System_Construction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma res_alt_def: \"res = ((1\\<^sub>C |\\<^sub>= enc |\\<^sub>= dec) \\<odot> (1\\<^sub>C |\\<^sub>= parallel_wiring)) \\<rhd> parallel_resource1_wiring \\<rhd> (KEY.res \\<parallel> AUTH.res)\"", "lemma interface_wiring:\n  \"(cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv) \\<rhd> (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<rhd> parallel_resource1_wiring \\<rhd> \n  (RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel> RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv) res1_s)\n  =\n  cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n  RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O (res2_send\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_send) \\<oplus>\\<^sub>O res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv) (res2_s, res1_s)\"\n  (is \"_ \\<rhd> ?L1 \\<rhd> ?L2 \\<rhd> ?L3 = _ \\<rhd> ?R\")"], "translations": [["", "lemma res_alt_def: \"res = ((1\\<^sub>C |\\<^sub>= enc |\\<^sub>= dec) \\<odot> (1\\<^sub>C |\\<^sub>= parallel_wiring)) \\<rhd> parallel_resource1_wiring \\<rhd> (KEY.res \\<parallel> AUTH.res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res =\n    (1\\<^sub>C |\\<^sub>= enc |\\<^sub>= dec) \\<odot>\n    (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<rhd>\n    parallel_resource1_wiring \\<rhd> KEY.res \\<parallel> AUTH.res", "by(simp add: res_def attach_compose)"], ["", "end"], ["", "subsection \\<open>Message authentication converter\\<close>"], ["", "locale macode = \n  INSEC: insec_channel + RO: rorc range \n  for   range :: \"'r set\" +\n  fixes mac_alg :: \"'r \\<Rightarrow> 'm \\<Rightarrow> 'a spmf\"\nbegin"], ["", "definition enm :: \"('m, unit, 'm + ('a \\<times> 'm), 'r + unit) converter\" where\n  \"enm \\<equiv> CNV (\\<lambda>bs m. if bs \n    then Done ((), True)\n    else do {\n      r \\<leftarrow> Pause (Inl m) Done;\n      a \\<leftarrow> lift_spmf (mac_alg (projl r) m);\n      (_ :: 'r + unit) \\<leftarrow> Pause (Inr (a, m)) Done;\n      Done ((), True)\n    }) False\""], ["", "definition dem :: \"(unit, 'm option, 'm + unit, 'r + ('a \\<times> 'm) option) converter\" where\n  \"dem \\<equiv> CNV (stateless_callee (\\<lambda>_. Pause (Inr ()) (\\<lambda>am'. \n    case am' of Inr (Some (a, m)) \\<Rightarrow> (do {\n      r \\<leftarrow> Pause (Inl m) Done;\n      a' \\<leftarrow> lift_spmf (mac_alg (projl r) m);    \n      Done (if a' = a then Some m else None) })\n    | _ \\<Rightarrow> Done None)\n  )) ()\""], ["", "definition \\<pi>E :: \"(('a \\<times> 'm) insec_query, ('a \\<times> 'm) option, ('a \\<times> 'm) insec_query, ('a \\<times> 'm) option) converter\" (\"\\<pi>\\<^sup>E\") where\n  \"\\<pi>\\<^sup>E \\<equiv> 1\\<^sub>C\""], ["", "definition \"routing \\<equiv> (1\\<^sub>C |\\<^sub>= lassocr\\<^sub>C) \\<odot> swap_lassocr \\<odot> (1\\<^sub>C |\\<^sub>= (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> swap_lassocr) \\<odot> rassocl\\<^sub>C\""], ["", "definition \"res = (1\\<^sub>C |\\<^sub>= enm |\\<^sub>= dem) \\<rhd> (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<rhd> parallel_resource1_wiring \\<rhd> (RO.res \\<parallel> INSEC.res)\""], ["", "end"], ["", "lemma interface_wiring:\n  \"(cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv) \\<rhd> (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<rhd> parallel_resource1_wiring \\<rhd> \n  (RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel> RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv) res1_s)\n  =\n  cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n  RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O (res2_send\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_send) \\<oplus>\\<^sub>O res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv) (res2_s, res1_s)\"\n  (is \"_ \\<rhd> ?L1 \\<rhd> ?L2 \\<rhd> ?L3 = _ \\<rhd> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "let ?wiring = \"(id, id) |\\<^sub>w  (lassocr\\<^sub>w \\<circ>\\<^sub>w ((id, id) |\\<^sub>w (rassocl\\<^sub>w \\<circ>\\<^sub>w (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w lassocr\\<^sub>w)) \n    \\<circ>\\<^sub>w rassocl\\<^sub>w)) \\<circ>\\<^sub>w (rassocl\\<^sub>w \\<circ>\\<^sub>w (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w lassocr\\<^sub>w))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "have \"?L1 \\<rhd> ?L2 \\<rhd> ?L3 = ?L1 \\<odot> ?L2 \\<rhd>\n    RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O res2_recv\\<dagger>) \\<oplus>\\<^sub>O \\<dagger>res1_advr \\<oplus>\\<^sub>O \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv) (res2_s, res1_s)\" (is \"_ = _ \\<rhd> RES(?O) ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n    parallel_resource1_wiring \\<rhd>\n    RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n          res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n         \\<dagger>res1_advr \\<oplus>\\<^sub>O\n         \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "unfolding attach_compose[symmetric] resource_of_parallel_oracle[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n    parallel_resource1_wiring \\<rhd>\n    RES ((res2_send \\<oplus>\\<^sub>O res2_recv) \\<ddagger>\\<^sub>O\n         res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     (res2_s, res1_s) =\n    (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n    parallel_resource1_wiring \\<rhd>\n    RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n          res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n         \\<dagger>res1_advr \\<oplus>\\<^sub>O\n         \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "by (simp only: parallel_oracle_conv_plus_oracle extend_state_oracle_plus_oracle extend_state_oracle2_plus_oracle)"], ["proof (state)\nthis:\n  1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n  parallel_resource1_wiring \\<rhd>\n  RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n  RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n   res1_s =\n  (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n  parallel_resource1_wiring \\<rhd>\n  RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n        res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n       \\<dagger>res1_advr \\<oplus>\\<^sub>O\n       \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s)\n\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "also"], ["proof (state)\nthis:\n  1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n  parallel_resource1_wiring \\<rhd>\n  RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n  RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n   res1_s =\n  (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n  parallel_resource1_wiring \\<rhd>\n  RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n        res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n       \\<dagger>res1_advr \\<oplus>\\<^sub>O\n       \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s)\n\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "have \"\\<dots> = RES(apply_wiring ?wiring ?O) ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n    parallel_resource1_wiring \\<rhd>\n    RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n          res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n         \\<dagger>res1_advr \\<oplus>\\<^sub>O\n         \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s) =\n    RES (apply_wiring\n          ((id, id) |\\<^sub>w\n           (lassocr\\<^sub>w \\<circ>\\<^sub>w\n            ((id, id) |\\<^sub>w\n             (rassocl\\<^sub>w \\<circ>\\<^sub>w\n              (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n               lassocr\\<^sub>w)) \\<circ>\\<^sub>w\n             rassocl\\<^sub>w)) \\<circ>\\<^sub>w\n           (rassocl\\<^sub>w \\<circ>\\<^sub>w\n            (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n             lassocr\\<^sub>w)))\n          ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n            res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n           \\<dagger>res1_advr \\<oplus>\\<^sub>O\n           \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv))\n     (res2_s, res1_s)", "by (rule attach_wiring_resource_of_oracle, simp only: parallel_wiring_def parallel_resource1_wiring_def swap_lassocr_def)\n      ((rule wiring_intro WT_resource_of_oracle WT_plus_oracleI WT_callee_full)+, simp_all)"], ["proof (state)\nthis:\n  (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n  parallel_resource1_wiring \\<rhd>\n  RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n        res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n       \\<dagger>res1_advr \\<oplus>\\<^sub>O\n       \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s) =\n  RES (apply_wiring\n        ((id, id) |\\<^sub>w\n         (lassocr\\<^sub>w \\<circ>\\<^sub>w\n          ((id, id) |\\<^sub>w\n           (rassocl\\<^sub>w \\<circ>\\<^sub>w\n            (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n             lassocr\\<^sub>w)) \\<circ>\\<^sub>w\n           rassocl\\<^sub>w)) \\<circ>\\<^sub>w\n         (rassocl\\<^sub>w \\<circ>\\<^sub>w\n          (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n           lassocr\\<^sub>w)))\n        ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n          res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n         \\<dagger>res1_advr \\<oplus>\\<^sub>O\n         \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv))\n   (res2_s, res1_s)\n\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "also"], ["proof (state)\nthis:\n  (1\\<^sub>C |\\<^sub>= parallel_wiring) \\<odot>\n  parallel_resource1_wiring \\<rhd>\n  RES ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n        res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n       \\<dagger>res1_advr \\<oplus>\\<^sub>O\n       \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s) =\n  RES (apply_wiring\n        ((id, id) |\\<^sub>w\n         (lassocr\\<^sub>w \\<circ>\\<^sub>w\n          ((id, id) |\\<^sub>w\n           (rassocl\\<^sub>w \\<circ>\\<^sub>w\n            (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n             lassocr\\<^sub>w)) \\<circ>\\<^sub>w\n           rassocl\\<^sub>w)) \\<circ>\\<^sub>w\n         (rassocl\\<^sub>w \\<circ>\\<^sub>w\n          (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n           lassocr\\<^sub>w)))\n        ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n          res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n         \\<dagger>res1_advr \\<oplus>\\<^sub>O\n         \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv))\n   (res2_s, res1_s)\n\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "have \"\\<dots> = ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (apply_wiring\n          ((id, id) |\\<^sub>w\n           (lassocr\\<^sub>w \\<circ>\\<^sub>w\n            ((id, id) |\\<^sub>w\n             (rassocl\\<^sub>w \\<circ>\\<^sub>w\n              (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n               lassocr\\<^sub>w)) \\<circ>\\<^sub>w\n             rassocl\\<^sub>w)) \\<circ>\\<^sub>w\n           (rassocl\\<^sub>w \\<circ>\\<^sub>w\n            (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n             lassocr\\<^sub>w)))\n          ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n            res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n           \\<dagger>res1_advr \\<oplus>\\<^sub>O\n           \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv))\n     (res2_s, res1_s) =\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "by simp"], ["proof (state)\nthis:\n  RES (apply_wiring\n        ((id, id) |\\<^sub>w\n         (lassocr\\<^sub>w \\<circ>\\<^sub>w\n          ((id, id) |\\<^sub>w\n           (rassocl\\<^sub>w \\<circ>\\<^sub>w\n            (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n             lassocr\\<^sub>w)) \\<circ>\\<^sub>w\n           rassocl\\<^sub>w)) \\<circ>\\<^sub>w\n         (rassocl\\<^sub>w \\<circ>\\<^sub>w\n          (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n           lassocr\\<^sub>w)))\n        ((res2_send\\<dagger> \\<oplus>\\<^sub>O\n          res2_recv\\<dagger>) \\<oplus>\\<^sub>O\n         \\<dagger>res1_advr \\<oplus>\\<^sub>O\n         \\<dagger>res1_send \\<oplus>\\<^sub>O \\<dagger>res1_recv))\n   (res2_s, res1_s) =\n  RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n       (res2_send\\<dagger> \\<oplus>\\<^sub>O\n        \\<dagger>res1_send) \\<oplus>\\<^sub>O\n       res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s)\n\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "finally"], ["proof (chain)\npicking this:\n  1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n  parallel_resource1_wiring \\<rhd>\n  RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n  RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n   res1_s =\n  RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n       (res2_send\\<dagger> \\<oplus>\\<^sub>O\n        \\<dagger>res1_send) \\<oplus>\\<^sub>O\n       res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s)", "show ?thesis"], ["proof (prove)\nusing this:\n  1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n  parallel_resource1_wiring \\<rhd>\n  RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n  RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n   res1_s =\n  RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n       (res2_send\\<dagger> \\<oplus>\\<^sub>O\n        \\<dagger>res1_send) \\<oplus>\\<^sub>O\n       res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s)\n\ngoal (1 subgoal):\n 1. cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n    parallel_resource1_wiring \\<rhd>\n    RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n    RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n     res1_s =\n    cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n    RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n         (res2_send\\<dagger> \\<oplus>\\<^sub>O\n          \\<dagger>res1_send) \\<oplus>\\<^sub>O\n         res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n     (res2_s, res1_s)", "by (rule arg_cong2[where f=\"attach\", OF refl])"], ["proof (state)\nthis:\n  cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n  1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n  parallel_resource1_wiring \\<rhd>\n  RES (res2_send \\<oplus>\\<^sub>O res2_recv) res2_s \\<parallel>\n  RES (res1_advr \\<oplus>\\<^sub>O res1_send \\<oplus>\\<^sub>O res1_recv)\n   res1_s =\n  cnv_advr |\\<^sub>= cnv_send |\\<^sub>= cnv_recv \\<rhd>\n  RES (\\<dagger>res1_advr \\<oplus>\\<^sub>O\n       (res2_send\\<dagger> \\<oplus>\\<^sub>O\n        \\<dagger>res1_send) \\<oplus>\\<^sub>O\n       res2_recv\\<dagger> \\<oplus>\\<^sub>O \\<dagger>res1_recv)\n   (res2_s, res1_s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* prevent the simplifier from rewriting id and restructuring the equations *)"], ["", "definition id' where \"id' = id\""], ["", "end"]]}