{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Resource.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma case_resource_conv_run_resource: \"case_resource f res = f (run_resource res)\"", "lemma map_resource_sel [simp]:\n  \"run_resource (map_resource res) a' = map_spmf (map_prod b map_resource) (run_resource res (a a'))\"", "lemma map_resource_ctr [simp, code]:\n  \"map_resource (Resource f) = Resource (map_spmf (map_prod b map_resource) \\<circ> f \\<circ> a)\"", "lemma map_resource_id1: \"map_resource id f res = map_resource' f res\"", "lemma map_resource_id [simp]: \"map_resource id id res = res\"", "lemma map_resource_compose [simp]:\n  \"map_resource a b (map_resource a' b' res) = map_resource (a' \\<circ> a) (b \\<circ> b') res\"", "lemma rel_resource_coinduct [consumes 1, case_names rel_resource, coinduct pred: rel_resource]:\n  assumes \"X res1 res2\"\n    and \"\\<And>res1 res2. X res1 res2 \\<Longrightarrow>\n         rel_fun A (rel_spmf (rel_prod B (\\<lambda>res1 res2. X res1 res2 \\<or> rel_resource A B res1 res2)))\n            (run_resource res1) (run_resource res2)\"\n  shows \"rel_resource A B res1 res2\"", "lemma rel_resource_simps [simp, code]:\n  \"rel_resource A B (Resource f) (Resource g) \\<longleftrightarrow> rel_fun A (rel_spmf (rel_prod B (rel_resource A B))) f g\"", "lemma rel_resourceD:\n  \"rel_resource A B res1 res2 \\<Longrightarrow> rel_fun A (rel_spmf (rel_prod B (rel_resource A B))) (run_resource res1) (run_resource res2)\"", "lemma rel_resource_eq1: \"rel_resource (=) = rel_resource'\"", "lemma rel_resource_eq: (* [relator_eq] *) \"rel_resource (=) (=) = (=)\"", "lemma rel_resource_mono:\n  assumes \"A' \\<le> A\" \"B \\<le> B'\"\n  shows \"rel_resource A B \\<le> rel_resource A' B'\"", "lemma rel_resource_conversep: \"rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> = (rel_resource A B)\\<inverse>\\<inverse>\"", "lemma rel_resource_map_resource'1:\n  \"rel_resource A B (map_resource' f res1) res2 = rel_resource A (\\<lambda>x. B (f x)) res1 res2\"\n  (is \"?lhs = ?rhs\")", "lemma rel_resource_map_resource'2:\n  \"rel_resource A B res1 (map_resource' f res2) = rel_resource A (\\<lambda>x y. B x (f y)) res1 res2\"", "lemmas resource_rel_map' = rel_resource_map_resource'1[abs_def] rel_resource_map_resource'2", "lemma rel_resource_pos_distr:\n  \"rel_resource A B OO rel_resource A' B' \\<le> rel_resource (A OO A') (B OO B')\"", "lemma left_unique_rel_resource:\n  \"\\<lbrakk> left_total A; left_unique B \\<rbrakk> \\<Longrightarrow> left_unique (rel_resource A B)\"", "lemma right_unique_rel_resource:\n  \"\\<lbrakk> right_total A; right_unique B \\<rbrakk> \\<Longrightarrow> right_unique (rel_resource A B)\"", "lemma bi_unique_rel_resource [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique B \\<rbrakk> \\<Longrightarrow> bi_unique (rel_resource A B)\"", "lemma rel_witness_resource_sel [simp]:\n  \"run_resource (rel_witness_resource A A' B (res1, res2)) =\n   map_spmf (map_prod id (rel_witness_resource A A' B) \\<circ> rel_witness_prod) \\<circ> \n   rel_witness_spmf (rel_prod B (rel_resource (A OO A') B)) \\<circ> \n   rel_witness_fun A A' (run_resource res1, run_resource res2)\"", "lemma assumes \"rel_resource (A OO A') B res res'\"\n  and A: \"left_unique A\" \"right_total A\"\n  and A': \"right_unique A'\" \"left_total A'\"\nshows rel_witness_resource1: \"rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res (rel_witness_resource A A' B (res, res'))\" (is \"?thesis1\")\n  and rel_witness_resource2: \"rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c') (rel_witness_resource A A' B (res, res')) res'\" (is \"?thesis2\")", "lemma rel_resource_neg_distr:\n  assumes A: \"left_unique A\" \"right_total A\"\n    and A': \"right_unique A'\" \"left_total A'\"\n  shows \"rel_resource (A OO A') (B OO B') \\<le> rel_resource A B OO rel_resource A' B'\"", "lemma left_total_rel_resource:\n  \"\\<lbrakk> left_unique A; right_total A; left_total B \\<rbrakk> \\<Longrightarrow> left_total (rel_resource A B)\"", "lemma right_total_rel_resource:\n  \"\\<lbrakk> right_unique A; left_total A; right_total B \\<rbrakk> \\<Longrightarrow> right_total (rel_resource A B)\"", "lemma bi_total_rel_resource [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique A; bi_total B \\<rbrakk> \\<Longrightarrow> bi_total (rel_resource A B)\"", "lemma Resource_parametric [transfer_rule]:\n  \"((A ===> rel_spmf (rel_prod B (rel_resource A B))) ===> rel_resource A B) Resource Resource\"", "lemma run_resource_parametric [transfer_rule]:\n  \"(rel_resource A B ===> A ===> rel_spmf (rel_prod B (rel_resource A B))) run_resource run_resource\"", "lemma corec_resource_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_spmf (rel_prod B (rel_sum (rel_resource A B) S))) ===> S ===> rel_resource A B)\n   corec_resource corec_resource\"", "lemma map_resource_parametric [transfer_rule]:\n  \"((A' ===> A) ===> (B ===> B') ===> rel_resource A B ===> rel_resource A' B') map_resource map_resource\"", "lemma map_resource'_parametric [transfer_rule]:\n  \"((B ===> B') ===> rel_resource (=) B ===> rel_resource (=) B') map_resource' map_resource'\"", "lemma case_resource_parametric [transfer_rule]:\n  \"(((A ===> rel_spmf (rel_prod B (rel_resource A B))) ===> C) ===> rel_resource A B ===> C)\n  case_resource case_resource\"", "lemma rel_resource_Grp:\n  \"rel_resource (conversep (BNF_Def.Grp UNIV f)) (BNF_Def.Grp UNIV g) = BNF_Def.Grp UNIV (map_resource f g)\"", "lemma lossless_resource_coinduct [consumes 1, case_names lossless_resource, case_conclusion lossless_resource lossless step, coinduct pred: lossless_resource]:\n  assumes \"X res\"\n    and \"\\<And>res a. \\<lbrakk> X res; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> lossless_spmf (run_resource res a) \\<and>\n          (\\<forall>(b, res') \\<in> set_spmf (run_resource res a). X res' \\<or> lossless_resource \\<I> res')\"\n  shows \"lossless_resource \\<I> res\"", "lemma lossless_resourceD:\n  \"\\<lbrakk> lossless_resource \\<I> res; a \\<in> outs_\\<I> \\<I> \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (run_resource res a) \\<and> (\\<forall>(x, res')\\<in>set_spmf (run_resource res a). lossless_resource \\<I> res')\"", "lemma lossless_resource_mono:\n  assumes \"lossless_resource \\<I>' res\"\n    and le: \"outs_\\<I> \\<I> \\<subseteq> outs_\\<I> \\<I>'\"\n  shows \"lossless_resource \\<I> res\"", "lemma lossless_resource_mono': \n  \"\\<lbrakk> lossless_resource \\<I>' res; \\<I> \\<le> \\<I>' \\<rbrakk> \\<Longrightarrow> lossless_resource \\<I> res\"", "lemma resource_of_oracle_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((S ===> A ===> rel_spmf (rel_prod B S)) ===> S ===> rel_resource A B) resource_of_oracle resource_of_oracle\"", "lemma map_resource_resource_of_oracle:\n  \"map_resource f g (resource_of_oracle oracle s) = resource_of_oracle (map_fun id (map_fun f (map_spmf (map_prod g id))) oracle) s\"\n  for s :: 's", "lemma (in callee_invariant_on) lossless_resource_of_oracle:\n  assumes *: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and \"I s\" \n  shows \"lossless_resource \\<I> (resource_of_oracle callee s)\"", "lemma resource_of_oracle_rprodl: includes lifting_syntax shows\n  \"resource_of_oracle ((rprodl ---> id ---> map_spmf (map_prod id lprodr)) oracle) ((s1, s2), s3) = \n    resource_of_oracle oracle (s1, s2, s3)\"", "lemma resource_of_oracle_extend_state_oracle [simp]:\n  \"resource_of_oracle (extend_state_oracle oracle) (s', s) = resource_of_oracle oracle s\"", "lemma exec_gpv_resource_of_oracle:\n  \"exec_gpv run_resource gpv (resource_of_oracle oracle s) = map_spmf (map_prod id (resource_of_oracle oracle)) (exec_gpv oracle gpv s)\"", "lemma parallel_resource_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_resource A B ===> rel_resource C D ===> rel_resource (rel_sum A C) (rel_sum B D))\n   parallel_resource parallel_resource\"", "lemma resource_of_parallel_oracle:\n  \"resource_of_oracle (parallel_oracle oracle1 oracle2) (s1, s2) =\n   parallel_resource (resource_of_oracle oracle1 s1) (resource_of_oracle oracle2 s2)\"", "lemma parallel_resource_assoc: \\<comment> \\<open>There's still an ugly map operation in there to rebalance the interface trees, but well...\\<close>\n  \"parallel_resource (parallel_resource res1 res2) res3 = \n   map_resource rsuml lsumr (parallel_resource res1 (parallel_resource res2 res3))\"", "lemma lossless_parallel_resource:\n  assumes \"lossless_resource \\<I> res1\" \"lossless_resource \\<I>' res2\"\n  shows \"lossless_resource (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (parallel_resource res1 res2)\"", "lemma WT_resource_coinduct [consumes 1, case_names WT_resource, case_conclusion WT_resource response WT_resource, coinduct pred: WT_resource]:\n  assumes \"X res\"\n    and \"\\<And>res q r res'. \\<lbrakk> X res; q \\<in> outs_\\<I> \\<I>; (r, res') \\<in> set_spmf (run_resource res q) \\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> (X res' \\<or> \\<I> \\<turnstile>res res' \\<surd>)\"\n  shows \"\\<I> \\<turnstile>res res \\<surd>\"", "lemma WT_resourceD:\n  assumes \"\\<I> \\<turnstile>res res \\<surd>\" \"q \\<in> outs_\\<I> \\<I>\" \"(r, res') \\<in> set_spmf (run_resource res q)\"\n  shows \"r \\<in> responses_\\<I> \\<I> q \\<and> \\<I> \\<turnstile>res res' \\<surd>\"", "lemma WT_resource_of_oracle [simp]:\n  assumes \"\\<And>s. \\<I> \\<turnstile>c oracle s \\<surd>\"\n  shows \"\\<I> \\<turnstile>res resource_of_oracle oracle s \\<surd>\"", "lemma WT_resource_bot [simp]: \"bot \\<turnstile>res res \\<surd>\"", "lemma WT_resource_full: \"\\<I>_full \\<turnstile>res res \\<surd>\"", "lemma (in callee_invariant_on) WT_resource_of_oracle:\n  \"I s \\<Longrightarrow> \\<I> \\<turnstile>res resource_of_oracle callee s \\<surd>\"", "lemmas [WT_intro] = WT_gpv_map_gpv' WT_gpv_map_gpv", "lemma WT_parallel_resource [WT_intro]:\n  assumes \"\\<I>1 \\<turnstile>res res1 \\<surd>\"\n    and \"\\<I>2 \\<turnstile>res res2 \\<surd>\"\n  shows \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>res parallel_resource res1 res2 \\<surd>\"", "lemma callee_invariant_run_resource: \"callee_invariant_on run_resource (\\<lambda>res.  \\<I> \\<turnstile>res res \\<surd>) \\<I>\"", "lemma callee_invariant_run_lossless_resource:\n  \"callee_invariant_on run_resource (\\<lambda>res. lossless_resource \\<I> res \\<and> \\<I> \\<turnstile>res res \\<surd>) \\<I>\""], "translations": [["", "lemma case_resource_conv_run_resource: \"case_resource f res = f (run_resource res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case res of Resource x \\<Rightarrow> f x) = f (run_resource res)", "by(fact resource.case_eq_if)"], ["", "subsection \\<open>Functor\\<close>"], ["", "context \n  fixes a :: \"'a \\<Rightarrow> 'a'\"\n    and b :: \"'b \\<Rightarrow> 'b'\"\nbegin"], ["", "primcorec map_resource :: \"('a', 'b) resource \\<Rightarrow> ('a, 'b') resource\" where\n  \"run_resource (map_resource res) = map_spmf (map_prod b map_resource) \\<circ> (run_resource res) \\<circ> a\""], ["", "lemma map_resource_sel [simp]:\n  \"run_resource (map_resource res) a' = map_spmf (map_prod b map_resource) (run_resource res (a a'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_resource (local.map_resource res) a' =\n    map_spmf (map_prod b local.map_resource) (run_resource res (a a'))", "by simp"], ["", "declare map_resource.sel [simp del]"], ["", "lemma map_resource_ctr [simp, code]:\n  \"map_resource (Resource f) = Resource (map_spmf (map_prod b map_resource) \\<circ> f \\<circ> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_resource (Resource f) =\n    Resource (map_spmf (map_prod b local.map_resource) \\<circ> f \\<circ> a)", "by(rule resource.expand; simp add: fun_eq_iff)"], ["", "end"], ["", "lemma map_resource_id1: \"map_resource id f res = map_resource' f res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_resource id f res = map_resource' f res", "by(coinduction arbitrary: res)(auto simp add: rel_fun_def spmf_rel_map resource.map_sel intro!: rel_spmf_reflI)"], ["", "lemma map_resource_id [simp]: \"map_resource id id res = res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_resource id id res = res", "by(simp add: map_resource_id1 resource.map_id)"], ["", "lemma map_resource_compose [simp]:\n  \"map_resource a b (map_resource a' b' res) = map_resource (a' \\<circ> a) (b \\<circ> b') res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_resource a b (map_resource a' b' res) =\n    map_resource (a' \\<circ> a) (b \\<circ> b') res", "by(coinduction arbitrary: res)(auto 4 3 intro!: rel_funI rel_spmf_reflI simp add: spmf_rel_map)"], ["", "functor resource: map_resource"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g h i.\n        map_resource f g \\<circ> map_resource h i =\n        map_resource (h \\<circ> f) (g \\<circ> i)) &&&\n    map_resource id id = id", "by(simp_all add: o_def fun_eq_iff)"], ["", "subsection \\<open>Relator\\<close>"], ["", "coinductive rel_resource :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('c \\<Rightarrow> 'd \\<Rightarrow> bool) \\<Rightarrow> ('a, 'c) resource \\<Rightarrow> ('b, 'd) resource \\<Rightarrow> bool\"\n  for A B where\n    rel_resourceI:\n    \"rel_fun A (rel_spmf (rel_prod B (rel_resource A B))) (run_resource res1) (run_resource res2) \n  \\<Longrightarrow> rel_resource A B res1 res2\""], ["", "lemma rel_resource_coinduct [consumes 1, case_names rel_resource, coinduct pred: rel_resource]:\n  assumes \"X res1 res2\"\n    and \"\\<And>res1 res2. X res1 res2 \\<Longrightarrow>\n         rel_fun A (rel_spmf (rel_prod B (\\<lambda>res1 res2. X res1 res2 \\<or> rel_resource A B res1 res2)))\n            (run_resource res1) (run_resource res2)\"\n  shows \"rel_resource A B res1 res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B res1 res2", "using assms(1)"], ["proof (prove)\nusing this:\n  X res1 res2\n\ngoal (1 subgoal):\n 1. rel_resource A B res1 res2", "by(rule rel_resource.coinduct)(simp add: assms(2))"], ["", "lemma rel_resource_simps [simp, code]:\n  \"rel_resource A B (Resource f) (Resource g) \\<longleftrightarrow> rel_fun A (rel_spmf (rel_prod B (rel_resource A B))) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B (Resource f) (Resource g) =\n    rel_fun A (rel_spmf (rel_prod B (rel_resource A B))) f g", "by(subst rel_resource.simps) simp"], ["", "lemma rel_resourceD:\n  \"rel_resource A B res1 res2 \\<Longrightarrow> rel_fun A (rel_spmf (rel_prod B (rel_resource A B))) (run_resource res1) (run_resource res2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B res1 res2 \\<Longrightarrow>\n    rel_fun A (rel_spmf (rel_prod B (rel_resource A B))) (run_resource res1)\n     (run_resource res2)", "by(blast elim: rel_resource.cases)"], ["", "lemma rel_resource_eq1: \"rel_resource (=) = rel_resource'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource (=) = rel_resource'", "proof(intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       rel_resource (=) x xa xb \\<Longrightarrow> rel_resource' x xa xb\n 2. \\<And>x xa xb.\n       rel_resource' x xa xb \\<Longrightarrow> rel_resource (=) x xa xb", "show \"rel_resource' B res1 res2\" if \"rel_resource (=) B res1 res2\" for B res1 res2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource' B res1 res2", "using that"], ["proof (prove)\nusing this:\n  rel_resource (=) B res1 res2\n\ngoal (1 subgoal):\n 1. rel_resource' B res1 res2", "by(coinduction arbitrary: res1 res2)(auto elim: rel_resource.cases)"], ["proof (state)\nthis:\n  rel_resource (=) ?B1 ?res1.1 ?res2.1 \\<Longrightarrow>\n  rel_resource' ?B1 ?res1.1 ?res2.1\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       rel_resource' x xa xb \\<Longrightarrow> rel_resource (=) x xa xb", "show \"rel_resource (=) B res1 res2\" if \"rel_resource' B res1 res2\" for B res1 res2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource (=) B res1 res2", "using that"], ["proof (prove)\nusing this:\n  rel_resource' B res1 res2\n\ngoal (1 subgoal):\n 1. rel_resource (=) B res1 res2", "by(coinduction arbitrary: res1 res2)(auto 4 4 elim: resource.rel_cases intro: spmf_rel_mono_strong simp add: rel_fun_def)"], ["proof (state)\nthis:\n  rel_resource' ?B2 ?res1.2 ?res2.2 \\<Longrightarrow>\n  rel_resource (=) ?B2 ?res1.2 ?res2.2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_resource_eq: (* [relator_eq] *) \"rel_resource (=) (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource (=) (=) = (=)", "by(simp add: rel_resource_eq1 resource.rel_eq)"], ["", "lemma rel_resource_mono:\n  assumes \"A' \\<le> A\" \"B \\<le> B'\"\n  shows \"rel_resource A B \\<le> rel_resource A' B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B \\<le> rel_resource A' B'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. rel_resource A B x y \\<Longrightarrow> rel_resource A' B' x y", "show \"rel_resource A' B' res1 res2\" if \"rel_resource A B res1 res2\" for res1 res2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A' B' res1 res2", "using that"], ["proof (prove)\nusing this:\n  rel_resource A B res1 res2\n\ngoal (1 subgoal):\n 1. rel_resource A' B' res1 res2", "by(coinduct)(auto dest: rel_resourceD elim!: rel_spmf_mono prod.rel_mono_strong rel_fun_mono intro: assms[THEN predicate2D])"], ["proof (state)\nthis:\n  rel_resource A B ?res1.0 ?res2.0 \\<Longrightarrow>\n  rel_resource A' B' ?res1.0 ?res2.0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_resource_conversep: \"rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> = (rel_resource A B)\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> =\n    (rel_resource A B)\\<inverse>\\<inverse>", "proof(intro ext iffI; simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x\n        xa \\<Longrightarrow>\n       rel_resource A B xa x\n 2. \\<And>x xa.\n       rel_resource A B xa x \\<Longrightarrow>\n       rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x xa", "show \"rel_resource A B res1 res2\" if \"rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> res2 res1\"\n    for A :: \"'a1 \\<Rightarrow> 'a2 \\<Rightarrow> bool\" and B :: \"'c1 \\<Rightarrow> 'c2 \\<Rightarrow> bool\" and res1 res2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B res1 res2", "using that"], ["proof (prove)\nusing this:\n  rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> res2 res1\n\ngoal (1 subgoal):\n 1. rel_resource A B res1 res2", "by(coinduct)\n      (drule rel_resourceD, rewrite in \\<hole> conversep_iff[symmetric] \n        , subst rel_fun_conversep[symmetric], subst spmf_rel_conversep[symmetric], erule rel_fun_mono\n        , auto simp add: prod.rel_conversep[symmetric] rel_fun_def conversep_iff[abs_def]  elim:rel_spmf_mono prod.rel_mono_strong)"], ["proof (state)\nthis:\n  rel_resource ?A1\\<inverse>\\<inverse> ?B1\\<inverse>\\<inverse> ?res2.1\n   ?res1.1 \\<Longrightarrow>\n  rel_resource ?A1 ?B1 ?res1.1 ?res2.1\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_resource A B xa x \\<Longrightarrow>\n       rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x xa", "from this[of \"A\\<inverse>\\<inverse>\" \"B\\<inverse>\\<inverse>\"]"], ["proof (chain)\npicking this:\n  rel_resource A\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   B\\<inverse>\\<inverse>\\<inverse>\\<inverse> ?res2.1\n   ?res1.1 \\<Longrightarrow>\n  rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> ?res1.1 ?res2.1", "show \"rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> res2 res1\" if \"rel_resource A B res1 res2\" for res1 res2"], ["proof (prove)\nusing this:\n  rel_resource A\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   B\\<inverse>\\<inverse>\\<inverse>\\<inverse> ?res2.1\n   ?res1.1 \\<Longrightarrow>\n  rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> ?res1.1 ?res2.1\n\ngoal (1 subgoal):\n 1. rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> res2 res1", "using that"], ["proof (prove)\nusing this:\n  rel_resource A\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   B\\<inverse>\\<inverse>\\<inverse>\\<inverse> ?res2.1\n   ?res1.1 \\<Longrightarrow>\n  rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> ?res1.1 ?res2.1\n  rel_resource A B res1 res2\n\ngoal (1 subgoal):\n 1. rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> res2 res1", "by simp"], ["proof (state)\nthis:\n  rel_resource A B ?res1.1 ?res2.1 \\<Longrightarrow>\n  rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> ?res2.1 ?res1.1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_resource_map_resource'1:\n  \"rel_resource A B (map_resource' f res1) res2 = rel_resource A (\\<lambda>x. B (f x)) res1 res2\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B (map_resource' f res1) res2 =\n    rel_resource A (\\<lambda>x. B (f x)) res1 res2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_resource A B (map_resource' f res1) res2 \\<Longrightarrow>\n    rel_resource A (\\<lambda>x. B (f x)) res1 res2\n 2. rel_resource A (\\<lambda>x. B (f x)) res1 res2 \\<Longrightarrow>\n    rel_resource A B (map_resource' f res1) res2", "show ?rhs if ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A (\\<lambda>x. B (f x)) res1 res2", "using that"], ["proof (prove)\nusing this:\n  rel_resource A B (map_resource' f res1) res2\n\ngoal (1 subgoal):\n 1. rel_resource A (\\<lambda>x. B (f x)) res1 res2", "by(coinduction arbitrary: res1 res2)\n      (drule rel_resourceD, auto simp add: map_resource.sel map_resource_id1[symmetric] rel_fun_comp spmf_rel_map prod.rel_map[abs_def]\n        elim!: rel_fun_mono rel_spmf_mono prod.rel_mono[THEN predicate2D, rotated -1])"], ["proof (state)\nthis:\n  rel_resource A B (map_resource' f res1) res2 \\<Longrightarrow>\n  rel_resource A (\\<lambda>x. B (f x)) res1 res2\n\ngoal (1 subgoal):\n 1. rel_resource A (\\<lambda>x. B (f x)) res1 res2 \\<Longrightarrow>\n    rel_resource A B (map_resource' f res1) res2", "show ?lhs if ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B (map_resource' f res1) res2", "using that"], ["proof (prove)\nusing this:\n  rel_resource A (\\<lambda>x. B (f x)) res1 res2\n\ngoal (1 subgoal):\n 1. rel_resource A B (map_resource' f res1) res2", "by(coinduction arbitrary: res1 res2)\n      (drule rel_resourceD, auto simp add: map_resource.sel map_resource_id1[symmetric] rel_fun_comp spmf_rel_map prod.rel_map[abs_def]\n        elim!: rel_fun_mono rel_spmf_mono prod.rel_mono[THEN predicate2D, rotated -1])"], ["proof (state)\nthis:\n  rel_resource A (\\<lambda>x. B (f x)) res1 res2 \\<Longrightarrow>\n  rel_resource A B (map_resource' f res1) res2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_resource_map_resource'2:\n  \"rel_resource A B res1 (map_resource' f res2) = rel_resource A (\\<lambda>x y. B x (f y)) res1 res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B res1 (map_resource' f res2) =\n    rel_resource A (\\<lambda>x y. B x (f y)) res1 res2", "using rel_resource_map_resource'1[of \"conversep A\" \"conversep B\" f res2 res1]"], ["proof (prove)\nusing this:\n  rel_resource A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n   (map_resource' f res2) res1 =\n  rel_resource A\\<inverse>\\<inverse>\n   (\\<lambda>x. B\\<inverse>\\<inverse> (f x)) res2 res1\n\ngoal (1 subgoal):\n 1. rel_resource A B res1 (map_resource' f res2) =\n    rel_resource A (\\<lambda>x y. B x (f y)) res1 res2", "by(rewrite in \"\\<hole> = _\" conversep_iff[symmetric]\n      , rewrite in \"_ = \\<hole>\" conversep_iff[symmetric])\n    (simp only: rel_resource_conversep[symmetric]\n      , simp only: conversep_iff[abs_def])"], ["", "lemmas resource_rel_map' = rel_resource_map_resource'1[abs_def] rel_resource_map_resource'2"], ["", "lemma rel_resource_pos_distr:\n  \"rel_resource A B OO rel_resource A' B' \\<le> rel_resource (A OO A') (B OO B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B OO rel_resource A' B'\n    \\<le> rel_resource (A OO A') (B OO B')", "proof(rule predicate2I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (rel_resource A B OO rel_resource A' B') x y \\<Longrightarrow>\n       rel_resource (A OO A') (B OO B') x y", "show \"rel_resource (A OO A') (B OO B') res1 res3\"\n    if \"(rel_resource A B OO rel_resource A' B') res1 res3\"\n    for res1 res3"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource (A OO A') (B OO B') res1 res3", "using that"], ["proof (prove)\nusing this:\n  (rel_resource A B OO rel_resource A' B') res1 res3\n\ngoal (1 subgoal):\n 1. rel_resource (A OO A') (B OO B') res1 res3", "apply(coinduction arbitrary: res1 res3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>res1a__ res3.\n       (rel_resource A B OO rel_resource A' B') res1a__\n        res3 \\<Longrightarrow>\n       rel_fun (A OO A')\n        (rel_spmf\n          (rel_prod (B OO B')\n            (\\<lambda>res1 res2.\n                (\\<exists>res1a__ res3.\n                    res1 = res1a__ \\<and>\n                    res2 = res3 \\<and>\n                    (rel_resource A B OO rel_resource A' B') res1a__\n                     res3) \\<or>\n                rel_resource (A OO A') (B OO B') res1 res2)))\n        (run_resource res1a__) (run_resource res3)", "apply(erule relcomppE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>res1a__ res3 b.\n       \\<lbrakk>rel_resource A B res1a__ b;\n        rel_resource A' B' b res3\\<rbrakk>\n       \\<Longrightarrow> rel_fun (A OO A')\n                          (rel_spmf\n                            (rel_prod (B OO B')\n                              (\\<lambda>res1 res2.\n                                  (\\<exists>res1a__ res3.\nres1 = res1a__ \\<and>\nres2 = res3 \\<and>\n(rel_resource A B OO rel_resource A' B') res1a__ res3) \\<or>\n                                  rel_resource (A OO A') (B OO B') res1\n                                   res2)))\n                          (run_resource res1a__) (run_resource res3)", "apply(drule rel_resourceD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>res1a__ res3 b.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3)\\<rbrakk>\n       \\<Longrightarrow> rel_fun (A OO A')\n                          (rel_spmf\n                            (rel_prod (B OO B')\n                              (\\<lambda>res1 res2.\n                                  (\\<exists>res1a__ res3.\nres1 = res1a__ \\<and>\nres2 = res3 \\<and>\n(rel_resource A B OO rel_resource A' B') res1a__ res3) \\<or>\n                                  rel_resource (A OO A') (B OO B') res1\n                                   res2)))\n                          (run_resource res1a__) (run_resource res3)", "apply(rule rel_fun_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>res1a__ res3 b.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3)\\<rbrakk>\n       \\<Longrightarrow> rel_fun (?X9 res1a__ res3 b) (?A9 res1a__ res3 b)\n                          (run_resource res1a__) (run_resource res3)\n 2. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3)\\<rbrakk>\n       \\<Longrightarrow> (A OO A') x y \\<longrightarrow>\n                         ?X9 res1a__ res3 b x y\n 3. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3);\n        ?A9 res1a__ res3 b x y\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (B OO B')\n                            (\\<lambda>res1 res2.\n                                (\\<exists>res1a__ res3.\n                                    res1 = res1a__ \\<and>\n                                    res2 = res3 \\<and>\n                                    (rel_resource A B OO rel_resource A' B')\n                                     res1a__ res3) \\<or>\n                                rel_resource (A OO A') (B OO B') res1 res2))\n                          x y", "apply(rule pos_fun_distr[THEN predicate2D])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>res1a__ res3 b.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3)\\<rbrakk>\n       \\<Longrightarrow> (rel_fun (?R14 res1a__ res3 b)\n                           (?S14 res1a__ res3 b) OO\n                          rel_fun (?R'14 res1a__ res3 b)\n                           (?S'14 res1a__ res3 b))\n                          (run_resource res1a__) (run_resource res3)\n 2. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3)\\<rbrakk>\n       \\<Longrightarrow> (A OO A') x y \\<longrightarrow>\n                         (?R14 res1a__ res3 b OO ?R'14 res1a__ res3 b) x y\n 3. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3);\n        (?S14 res1a__ res3 b OO ?S'14 res1a__ res3 b) x y\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (B OO B')\n                            (\\<lambda>res1 res2.\n                                (\\<exists>res1a__ res3.\n                                    res1 = res1a__ \\<and>\n                                    res2 = res3 \\<and>\n                                    (rel_resource A B OO rel_resource A' B')\n                                     res1a__ res3) \\<or>\n                                rel_resource (A OO A') (B OO B') res1 res2))\n                          x y", "apply(erule (1) relcomppI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3)\\<rbrakk>\n       \\<Longrightarrow> (A OO A') x y \\<longrightarrow> (A OO A') x y\n 2. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3);\n        (rel_spmf (rel_prod B (rel_resource A B)) OO\n         rel_spmf (rel_prod B' (rel_resource A' B')))\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (B OO B')\n                            (\\<lambda>res1 res2.\n                                (\\<exists>res1a__ res3.\n                                    res1 = res1a__ \\<and>\n                                    res2 = res3 \\<and>\n                                    (rel_resource A B OO rel_resource A' B')\n                                     res1a__ res3) \\<or>\n                                rel_resource (A OO A') (B OO B') res1 res2))\n                          x y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3);\n        (rel_spmf (rel_prod B (rel_resource A B)) OO\n         rel_spmf (rel_prod B' (rel_resource A' B')))\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (B OO B')\n                            (\\<lambda>res1 res2.\n                                (\\<exists>res1a__ res3.\n                                    res1 = res1a__ \\<and>\n                                    res2 = res3 \\<and>\n                                    (rel_resource A B OO rel_resource A' B')\n                                     res1a__ res3) \\<or>\n                                rel_resource (A OO A') (B OO B') res1 res2))\n                          x y", "apply(rule rel_spmf_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>res1a__ res3 b x y.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3);\n        (rel_spmf (rel_prod B (rel_resource A B)) OO\n         rel_spmf (rel_prod B' (rel_resource A' B')))\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (?A18 res1a__ res3 b x y) x y\n 2. \\<And>res1a__ res3 b x y xa ya.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3);\n        (rel_spmf (rel_prod B (rel_resource A B)) OO\n         rel_spmf (rel_prod B' (rel_resource A' B')))\n         x y;\n        ?A18 res1a__ res3 b x y xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod (B OO B')\n                          (\\<lambda>res1 res2.\n                              (\\<exists>res1a__ res3.\n                                  res1 = res1a__ \\<and>\n                                  res2 = res3 \\<and>\n                                  (rel_resource A B OO rel_resource A' B')\n                                   res1a__ res3) \\<or>\n                              rel_resource (A OO A') (B OO B') res1 res2)\n                          xa ya", "apply(erule rel_spmf_pos_distr[THEN predicate2D])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>res1a__ res3 b x y xa ya.\n       \\<lbrakk>rel_fun A (rel_spmf (rel_prod B (rel_resource A B)))\n                 (run_resource res1a__) (run_resource b);\n        rel_fun A' (rel_spmf (rel_prod B' (rel_resource A' B')))\n         (run_resource b) (run_resource res3);\n        (rel_spmf (rel_prod B (rel_resource A B)) OO\n         rel_spmf (rel_prod B' (rel_resource A' B')))\n         x y;\n        (rel_prod B (rel_resource A B) OO rel_prod B' (rel_resource A' B'))\n         xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod (B OO B')\n                          (\\<lambda>res1 res2.\n                              (\\<exists>res1a__ res3.\n                                  res1 = res1a__ \\<and>\n                                  res2 = res3 \\<and>\n                                  (rel_resource A B OO rel_resource A' B')\n                                   res1a__ res3) \\<or>\n                              rel_resource (A OO A') (B OO B') res1 res2)\n                          xa ya", "apply(auto simp add: prod.rel_compp[symmetric] elim: prod.rel_mono[THEN predicate2D, rotated -1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (rel_resource A B OO rel_resource A' B') ?res1.0 ?res3.0 \\<Longrightarrow>\n  rel_resource (A OO A') (B OO B') ?res1.0 ?res3.0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_unique_rel_resource:\n  \"\\<lbrakk> left_total A; left_unique B \\<rbrakk> \\<Longrightarrow> left_unique (rel_resource A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total A; left_unique B\\<rbrakk>\n    \\<Longrightarrow> left_unique (rel_resource A B)", "unfolding left_unique_alt_def left_total_alt_def rel_resource_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A OO A\\<inverse>\\<inverse>;\n     B OO B\\<inverse>\\<inverse> \\<le> (=)\\<rbrakk>\n    \\<Longrightarrow> rel_resource A B OO\n                      rel_resource A\\<inverse>\\<inverse>\n                       B\\<inverse>\\<inverse>\n                      \\<le> (=)", "apply(subst rel_resource_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A OO A\\<inverse>\\<inverse>;\n     B OO B\\<inverse>\\<inverse> \\<le> (=)\\<rbrakk>\n    \\<Longrightarrow> rel_resource A B OO\n                      rel_resource A\\<inverse>\\<inverse>\n                       B\\<inverse>\\<inverse>\n                      \\<le> rel_resource (=) (=)", "apply(rule order_trans[OF rel_resource_pos_distr])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A OO A\\<inverse>\\<inverse>;\n     B OO B\\<inverse>\\<inverse> \\<le> (=)\\<rbrakk>\n    \\<Longrightarrow> rel_resource (A OO A\\<inverse>\\<inverse>)\n                       (B OO B\\<inverse>\\<inverse>)\n                      \\<le> rel_resource (=) (=)", "apply(erule (1) rel_resource_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma right_unique_rel_resource:\n  \"\\<lbrakk> right_total A; right_unique B \\<rbrakk> \\<Longrightarrow> right_unique (rel_resource A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_total A; right_unique B\\<rbrakk>\n    \\<Longrightarrow> right_unique (rel_resource A B)", "unfolding right_unique_alt_def right_total_alt_def rel_resource_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A\\<inverse>\\<inverse> OO A;\n     B\\<inverse>\\<inverse> OO B \\<le> (=)\\<rbrakk>\n    \\<Longrightarrow> rel_resource A\\<inverse>\\<inverse>\n                       B\\<inverse>\\<inverse> OO\n                      rel_resource A B\n                      \\<le> (=)", "apply(subst rel_resource_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A\\<inverse>\\<inverse> OO A;\n     B\\<inverse>\\<inverse> OO B \\<le> (=)\\<rbrakk>\n    \\<Longrightarrow> rel_resource A\\<inverse>\\<inverse>\n                       B\\<inverse>\\<inverse> OO\n                      rel_resource A B\n                      \\<le> rel_resource (=) (=)", "apply(rule order_trans[OF rel_resource_pos_distr])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A\\<inverse>\\<inverse> OO A;\n     B\\<inverse>\\<inverse> OO B \\<le> (=)\\<rbrakk>\n    \\<Longrightarrow> rel_resource (A\\<inverse>\\<inverse> OO A)\n                       (B\\<inverse>\\<inverse> OO B)\n                      \\<le> rel_resource (=) (=)", "apply(erule (1) rel_resource_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bi_unique_rel_resource [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique B \\<rbrakk> \\<Longrightarrow> bi_unique (rel_resource A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total A; bi_unique B\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel_resource A B)", "unfolding bi_unique_alt_def bi_total_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total A \\<and> right_total A;\n     left_unique B \\<and> right_unique B\\<rbrakk>\n    \\<Longrightarrow> left_unique (rel_resource A B) \\<and>\n                      right_unique (rel_resource A B)", "by(blast intro: left_unique_rel_resource right_unique_rel_resource)"], ["", "definition rel_witness_resource :: \"('a \\<Rightarrow> 'e \\<Rightarrow> bool) \\<Rightarrow> ('e \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'd \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) resource \\<times> ('c, 'd) resource \\<Rightarrow> ('e, 'b \\<times> 'd) resource\" where\n  \"rel_witness_resource A A' B = corec_resource (\\<lambda>(res1, res2).\n   map_spmf (map_prod id Inr \\<circ> rel_witness_prod) \\<circ> \n   rel_witness_spmf (rel_prod B (rel_resource (A OO A') B)) \\<circ> \n   rel_witness_fun A A' (run_resource res1, run_resource res2))\""], ["", "lemma rel_witness_resource_sel [simp]:\n  \"run_resource (rel_witness_resource A A' B (res1, res2)) =\n   map_spmf (map_prod id (rel_witness_resource A A' B) \\<circ> rel_witness_prod) \\<circ> \n   rel_witness_spmf (rel_prod B (rel_resource (A OO A') B)) \\<circ> \n   rel_witness_fun A A' (run_resource res1, run_resource res2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_resource (rel_witness_resource A A' B (res1, res2)) =\n    map_spmf\n     (map_prod id (rel_witness_resource A A' B) \\<circ>\n      rel_witness_prod) \\<circ>\n    rel_witness_spmf (rel_prod B (rel_resource (A OO A') B)) \\<circ>\n    rel_witness_fun A A' (run_resource res1, run_resource res2)", "by(auto simp add: rel_witness_resource_def o_def fun_eq_iff spmf.map_comp intro!: map_spmf_cong)"], ["", "lemma assumes \"rel_resource (A OO A') B res res'\"\n  and A: \"left_unique A\" \"right_total A\"\n  and A': \"right_unique A'\" \"left_total A'\"\nshows rel_witness_resource1: \"rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res (rel_witness_resource A A' B (res, res'))\" (is \"?thesis1\")\n  and rel_witness_resource2: \"rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c') (rel_witness_resource A A' B (res, res')) res'\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res\n     (rel_witness_resource A A' B (res, res')) &&&\n    rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (rel_witness_resource A A' B (res, res')) res'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res\n     (rel_witness_resource A A' B (res, res'))\n 2. rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (rel_witness_resource A A' B (res, res')) res'", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res\n     (rel_witness_resource A A' B (res, res'))", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_resource (A OO A') B res res'\n\ngoal (1 subgoal):\n 1. rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res\n     (rel_witness_resource A A' B (res, res'))", "proof(coinduction arbitrary: res res')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>res res'.\n       rel_resource (A OO A') B res res' \\<Longrightarrow>\n       rel_fun A\n        (rel_spmf\n          (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n            (\\<lambda>res1 res2.\n                (\\<exists>res res'.\n                    res1 = res \\<and>\n                    res2 = rel_witness_resource A A' B (res, res') \\<and>\n                    rel_resource (A OO A') B res res') \\<or>\n                rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n                 res1 res2)))\n        (run_resource res)\n        (run_resource (rel_witness_resource A A' B (res, res')))", "case rel_resource"], ["proof (state)\nthis:\n  rel_resource (A OO A') B res res'\n\ngoal (1 subgoal):\n 1. \\<And>res res'.\n       rel_resource (A OO A') B res res' \\<Longrightarrow>\n       rel_fun A\n        (rel_spmf\n          (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n            (\\<lambda>res1 res2.\n                (\\<exists>res res'.\n                    res1 = res \\<and>\n                    res2 = rel_witness_resource A A' B (res, res') \\<and>\n                    rel_resource (A OO A') B res res') \\<or>\n                rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n                 res1 res2)))\n        (run_resource res)\n        (run_resource (rel_witness_resource A A' B (res, res')))", "from this[THEN rel_resourceD]"], ["proof (chain)\npicking this:\n  rel_fun (A OO A') (rel_spmf (rel_prod B (rel_resource (A OO A') B)))\n   (run_resource res) (run_resource res')", "show ?case"], ["proof (prove)\nusing this:\n  rel_fun (A OO A') (rel_spmf (rel_prod B (rel_resource (A OO A') B)))\n   (run_resource res) (run_resource res')\n\ngoal (1 subgoal):\n 1. rel_fun A\n     (rel_spmf\n       (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n         (\\<lambda>res1 res2.\n             (\\<exists>res res'.\n                 res1 = res \\<and>\n                 res2 = rel_witness_resource A A' B (res, res') \\<and>\n                 rel_resource (A OO A') B res res') \\<or>\n             rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res1\n              res2)))\n     (run_resource res)\n     (run_resource (rel_witness_resource A A' B (res, res')))", "by(simp add: rel_fun_comp)\n        (erule rel_fun_mono[OF rel_witness_fun1[OF _ A A']]\n          , auto simp add: spmf_rel_map elim!: rel_spmf_mono[OF rel_witness_spmf1])"], ["proof (state)\nthis:\n  rel_fun A\n   (rel_spmf\n     (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n       (\\<lambda>res1 res2.\n           (\\<exists>res res'.\n               res1 = res \\<and>\n               res2 = rel_witness_resource A A' B (res, res') \\<and>\n               rel_resource (A OO A') B res res') \\<or>\n           rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res1\n            res2)))\n   (run_resource res)\n   (run_resource (rel_witness_resource A A' B (res, res')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_resource A (\\<lambda>b (b', c). b = b' \\<and> B b' c) res\n   (rel_witness_resource A A' B (res, res'))\n\ngoal (1 subgoal):\n 1. rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (rel_witness_resource A A' B (res, res')) res'", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (rel_witness_resource A A' B (res, res')) res'", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_resource (A OO A') B res res'\n\ngoal (1 subgoal):\n 1. rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (rel_witness_resource A A' B (res, res')) res'", "proof(coinduction arbitrary: res res')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>res res'.\n       rel_resource (A OO A') B res res' \\<Longrightarrow>\n       rel_fun A'\n        (rel_spmf\n          (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n            (\\<lambda>res1 res2.\n                (\\<exists>res res'.\n                    res1 = rel_witness_resource A A' B (res, res') \\<and>\n                    res2 = res' \\<and>\n                    rel_resource (A OO A') B res res') \\<or>\n                rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n                 res1 res2)))\n        (run_resource (rel_witness_resource A A' B (res, res')))\n        (run_resource res')", "case rel_resource"], ["proof (state)\nthis:\n  rel_resource (A OO A') B res res'\n\ngoal (1 subgoal):\n 1. \\<And>res res'.\n       rel_resource (A OO A') B res res' \\<Longrightarrow>\n       rel_fun A'\n        (rel_spmf\n          (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n            (\\<lambda>res1 res2.\n                (\\<exists>res res'.\n                    res1 = rel_witness_resource A A' B (res, res') \\<and>\n                    res2 = res' \\<and>\n                    rel_resource (A OO A') B res res') \\<or>\n                rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n                 res1 res2)))\n        (run_resource (rel_witness_resource A A' B (res, res')))\n        (run_resource res')", "from this[THEN rel_resourceD]"], ["proof (chain)\npicking this:\n  rel_fun (A OO A') (rel_spmf (rel_prod B (rel_resource (A OO A') B)))\n   (run_resource res) (run_resource res')", "show ?case"], ["proof (prove)\nusing this:\n  rel_fun (A OO A') (rel_spmf (rel_prod B (rel_resource (A OO A') B)))\n   (run_resource res) (run_resource res')\n\ngoal (1 subgoal):\n 1. rel_fun A'\n     (rel_spmf\n       (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n         (\\<lambda>res1 res2.\n             (\\<exists>res res'.\n                 res1 = rel_witness_resource A A' B (res, res') \\<and>\n                 res2 = res' \\<and> rel_resource (A OO A') B res res') \\<or>\n             rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c') res1\n              res2)))\n     (run_resource (rel_witness_resource A A' B (res, res')))\n     (run_resource res')", "by(simp add: rel_fun_comp)\n        (erule rel_fun_mono[OF rel_witness_fun2[OF _ A A']]\n          , auto simp add: spmf_rel_map elim!: rel_spmf_mono[OF rel_witness_spmf2])"], ["proof (state)\nthis:\n  rel_fun A'\n   (rel_spmf\n     (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n       (\\<lambda>res1 res2.\n           (\\<exists>res res'.\n               res1 = rel_witness_resource A A' B (res, res') \\<and>\n               res2 = res' \\<and> rel_resource (A OO A') B res res') \\<or>\n           rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c') res1\n            res2)))\n   (run_resource (rel_witness_resource A A' B (res, res')))\n   (run_resource res')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n   (rel_witness_resource A A' B (res, res')) res'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_resource_neg_distr:\n  assumes A: \"left_unique A\" \"right_total A\"\n    and A': \"right_unique A'\" \"left_total A'\"\n  shows \"rel_resource (A OO A') (B OO B') \\<le> rel_resource A B OO rel_resource A' B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource (A OO A') (B OO B')\n    \\<le> rel_resource A B OO rel_resource A' B'", "proof(rule predicate2I relcomppI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A B x (?b2 x y)\n 2. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A' B' (?b2 x y) y", "fix res res''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A B x (?b2 x y)\n 2. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A' B' (?b2 x y) y", "assume *: \"rel_resource (A OO A') (B OO B') res res''\""], ["proof (state)\nthis:\n  rel_resource (A OO A') (B OO B') res res''\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A B x (?b2 x y)\n 2. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A' B' (?b2 x y) y", "let ?res' = \"map_resource' (relcompp_witness B B') (rel_witness_resource A A' (B OO B') (res, res''))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A B x (?b2 x y)\n 2. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A' B' (?b2 x y) y", "show \"rel_resource A B res ?res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A B res\n     (map_resource' (relcompp_witness B B')\n       (rel_witness_resource A A' (B OO B') (res, res'')))", "using rel_witness_resource1[OF * A A']"], ["proof (prove)\nusing this:\n  rel_resource A (\\<lambda>b (b', c). b = b' \\<and> (B OO B') b' c) res\n   (rel_witness_resource A A' (B OO B') (res, res''))\n\ngoal (1 subgoal):\n 1. rel_resource A B res\n     (map_resource' (relcompp_witness B B')\n       (rel_witness_resource A A' (B OO B') (res, res'')))", "unfolding resource_rel_map'"], ["proof (prove)\nusing this:\n  rel_resource A (\\<lambda>b (b', c). b = b' \\<and> (B OO B') b' c) res\n   (rel_witness_resource A A' (B OO B') (res, res''))\n\ngoal (1 subgoal):\n 1. rel_resource A (\\<lambda>x y. B x (relcompp_witness B B' y)) res\n     (rel_witness_resource A A' (B OO B') (res, res''))", "by(rule rel_resource_mono[THEN predicate2D, rotated -1]; clarify del: relcomppE elim!: relcompp_witness)"], ["proof (state)\nthis:\n  rel_resource A B res\n   (map_resource' (relcompp_witness B B')\n     (rel_witness_resource A A' (B OO B') (res, res'')))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_resource (A OO A') (B OO B') x y \\<Longrightarrow>\n       rel_resource A' B'\n        (map_resource' (relcompp_witness B B')\n          (rel_witness_resource A A' (B OO B') (x, y)))\n        y", "show \"rel_resource A' B' ?res' res''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource A' B'\n     (map_resource' (relcompp_witness B B')\n       (rel_witness_resource A A' (B OO B') (res, res'')))\n     res''", "using rel_witness_resource2[OF * A A']"], ["proof (prove)\nusing this:\n  rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> (B OO B') b c')\n   (rel_witness_resource A A' (B OO B') (res, res'')) res''\n\ngoal (1 subgoal):\n 1. rel_resource A' B'\n     (map_resource' (relcompp_witness B B')\n       (rel_witness_resource A A' (B OO B') (res, res'')))\n     res''", "unfolding resource_rel_map'"], ["proof (prove)\nusing this:\n  rel_resource A' (\\<lambda>(b, c') c. c = c' \\<and> (B OO B') b c')\n   (rel_witness_resource A A' (B OO B') (res, res'')) res''\n\ngoal (1 subgoal):\n 1. rel_resource A' (\\<lambda>x. B' (relcompp_witness B B' x))\n     (rel_witness_resource A A' (B OO B') (res, res'')) res''", "by(rule rel_resource_mono[THEN predicate2D, rotated -1]; clarify del: relcomppE elim!: relcompp_witness)"], ["proof (state)\nthis:\n  rel_resource A' B'\n   (map_resource' (relcompp_witness B B')\n     (rel_witness_resource A A' (B OO B') (res, res'')))\n   res''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_total_rel_resource:\n  \"\\<lbrakk> left_unique A; right_total A; left_total B \\<rbrakk> \\<Longrightarrow> left_total (rel_resource A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_unique A; right_total A; left_total B\\<rbrakk>\n    \\<Longrightarrow> left_total (rel_resource A B)", "unfolding left_unique_alt_def left_total_alt_def rel_resource_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>\\<rbrakk>\n    \\<Longrightarrow> (=)\n                      \\<le> rel_resource A B OO\n                            rel_resource A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse>", "apply(subst rel_resource_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>\\<rbrakk>\n    \\<Longrightarrow> rel_resource (=) (=)\n                      \\<le> rel_resource A B OO\n                            rel_resource A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse>", "apply(rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> rel_resource A B OO\n                               rel_resource A\\<inverse>\\<inverse>\n                                B\\<inverse>\\<inverse>\n 2. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>\\<rbrakk>\n    \\<Longrightarrow> rel_resource (=) (=) \\<le> ?y", "apply(rule rel_resource_neg_distr; simp add: left_unique_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>\\<rbrakk>\n    \\<Longrightarrow> rel_resource (=) (=)\n                      \\<le> rel_resource (A OO A\\<inverse>\\<inverse>)\n                             (B OO B\\<inverse>\\<inverse>)", "apply(rule rel_resource_mono; assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma right_total_rel_resource:\n  \"\\<lbrakk> right_unique A; left_total A; right_total B \\<rbrakk> \\<Longrightarrow> right_total (rel_resource A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_unique A; left_total A; right_total B\\<rbrakk>\n    \\<Longrightarrow> right_total (rel_resource A B)", "unfolding right_unique_alt_def right_total_alt_def rel_resource_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B\\<rbrakk>\n    \\<Longrightarrow> (=)\n                      \\<le> rel_resource A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse> OO\n                            rel_resource A B", "apply(subst rel_resource_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B\\<rbrakk>\n    \\<Longrightarrow> rel_resource (=) (=)\n                      \\<le> rel_resource A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse> OO\n                            rel_resource A B", "apply(rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> rel_resource A\\<inverse>\\<inverse>\n                                B\\<inverse>\\<inverse> OO\n                               rel_resource A B\n 2. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B\\<rbrakk>\n    \\<Longrightarrow> rel_resource (=) (=) \\<le> ?y", "apply(rule rel_resource_neg_distr; simp add: right_unique_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B\\<rbrakk>\n    \\<Longrightarrow> rel_resource (=) (=)\n                      \\<le> rel_resource (A\\<inverse>\\<inverse> OO A)\n                             (B\\<inverse>\\<inverse> OO B)", "apply(rule rel_resource_mono; assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bi_total_rel_resource [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique A; bi_total B \\<rbrakk> \\<Longrightarrow> bi_total (rel_resource A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total A; bi_unique A; bi_total B\\<rbrakk>\n    \\<Longrightarrow> bi_total (rel_resource A B)", "unfolding bi_total_alt_def bi_unique_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total A \\<and> right_total A;\n     left_unique A \\<and> right_unique A;\n     left_total B \\<and> right_total B\\<rbrakk>\n    \\<Longrightarrow> left_total (rel_resource A B) \\<and>\n                      right_total (rel_resource A B)", "by(blast intro: left_total_rel_resource right_total_rel_resource)"], ["", "context includes lifting_syntax begin"], ["", "lemma Resource_parametric [transfer_rule]:\n  \"((A ===> rel_spmf (rel_prod B (rel_resource A B))) ===> rel_resource A B) Resource Resource\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> rel_spmf (rel_prod B (rel_resource A B))) ===>\n     rel_resource A B)\n     Resource Resource", "by(rule rel_funI)(simp)"], ["", "lemma run_resource_parametric [transfer_rule]:\n  \"(rel_resource A B ===> A ===> rel_spmf (rel_prod B (rel_resource A B))) run_resource run_resource\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_resource A B ===> A ===> rel_spmf (rel_prod B (rel_resource A B)))\n     run_resource run_resource", "by(rule rel_funI)(auto dest: rel_resourceD)"], ["", "lemma corec_resource_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_spmf (rel_prod B (rel_sum (rel_resource A B) S))) ===> S ===> rel_resource A B)\n   corec_resource corec_resource\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===>\n      A ===> rel_spmf (rel_prod B (rel_sum (rel_resource A B) S))) ===>\n     S ===> rel_resource A B)\n     corec_resource corec_resource", "proof((rule rel_funI)+, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(S ===>\n                 A ===>\n                 rel_spmf (rel_prod B (rel_sum (rel_resource A B) S)))\n                 x y;\n        S xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_resource A B (corec_resource x xa)\n                          (corec_resource y ya)", "case (1 f g s1 s2)"], ["proof (state)\nthis:\n  (S ===> A ===> rel_spmf (rel_prod B (rel_sum (rel_resource A B) S))) f g\n  S s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(S ===>\n                 A ===>\n                 rel_spmf (rel_prod B (rel_sum (rel_resource A B) S)))\n                 x y;\n        S xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_resource A B (corec_resource x xa)\n                          (corec_resource y ya)", "then"], ["proof (chain)\npicking this:\n  (S ===> A ===> rel_spmf (rel_prod B (rel_sum (rel_resource A B) S))) f g\n  S s1 s2", "show ?case"], ["proof (prove)\nusing this:\n  (S ===> A ===> rel_spmf (rel_prod B (rel_sum (rel_resource A B) S))) f g\n  S s1 s2\n\ngoal (1 subgoal):\n 1. rel_resource A B (corec_resource f s1) (corec_resource g s2)", "using 1(2)"], ["proof (prove)\nusing this:\n  (S ===> A ===> rel_spmf (rel_prod B (rel_sum (rel_resource A B) S))) f g\n  S s1 s2\n  S s1 s2\n\ngoal (1 subgoal):\n 1. rel_resource A B (corec_resource f s1) (corec_resource g s2)", "by (coinduction arbitrary: s1 s2)\n      (drule 1(1)[THEN rel_funD], auto 4 4 simp add: rel_fun_comp spmf_rel_map prod.rel_map[abs_def] split: sum.split elim!: rel_fun_mono rel_spmf_mono elim: prod.rel_mono[THEN predicate2D, rotated -1])"], ["proof (state)\nthis:\n  rel_resource A B (corec_resource f s1) (corec_resource g s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_resource_parametric [transfer_rule]:\n  \"((A' ===> A) ===> (B ===> B') ===> rel_resource A B ===> rel_resource A' B') map_resource map_resource\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A' ===> A) ===>\n     (B ===> B') ===> rel_resource A B ===> rel_resource A' B')\n     map_resource map_resource", "unfolding map_resource_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A' ===> A) ===>\n     (B ===> B') ===> rel_resource A B ===> rel_resource A' B')\n     (\\<lambda>a b.\n         corec_resource\n          (\\<lambda>res.\n              map_spmf (map_prod b Inr) \\<circ> run_resource res \\<circ> a))\n     (\\<lambda>a b.\n         corec_resource\n          (\\<lambda>res.\n              map_spmf (map_prod b Inr) \\<circ> run_resource res \\<circ> a))", "by(transfer_prover)"], ["", "lemma map_resource'_parametric [transfer_rule]:\n  \"((B ===> B') ===> rel_resource (=) B ===> rel_resource (=) B') map_resource' map_resource'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> B') ===> rel_resource (=) B ===> rel_resource (=) B')\n     map_resource' map_resource'", "unfolding map_resource_id1[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> B') ===> rel_resource (=) B ===> rel_resource (=) B')\n     (map_resource id) (map_resource id)", "by transfer_prover"], ["", "lemma case_resource_parametric [transfer_rule]:\n  \"(((A ===> rel_spmf (rel_prod B (rel_resource A B))) ===> C) ===> rel_resource A B ===> C)\n  case_resource case_resource\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((A ===> rel_spmf (rel_prod B (rel_resource A B))) ===> C) ===>\n     rel_resource A B ===> C)\n     case_resource case_resource", "unfolding case_resource_conv_run_resource"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((A ===> rel_spmf (rel_prod B (rel_resource A B))) ===> C) ===>\n     rel_resource A B ===> C)\n     (\\<lambda>f res. f (run_resource res))\n     (\\<lambda>f res. f (run_resource res))", "by transfer_prover"], ["", "end"], ["", "lemma rel_resource_Grp:\n  \"rel_resource (conversep (BNF_Def.Grp UNIV f)) (BNF_Def.Grp UNIV g) = BNF_Def.Grp UNIV (map_resource f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV g) =\n    BNF_Def.Grp UNIV (map_resource f g)", "proof((rule ext iffI)+, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa \\<Longrightarrow>\n       BNF_Def.Grp UNIV (map_resource f g) x xa\n 2. \\<And>x xa.\n       BNF_Def.Grp UNIV (map_resource f g) x xa \\<Longrightarrow>\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa", "case (1 res res')"], ["proof (state)\nthis:\n  rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV g)\n   res res'\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa \\<Longrightarrow>\n       BNF_Def.Grp UNIV (map_resource f g) x xa\n 2. \\<And>x xa.\n       BNF_Def.Grp UNIV (map_resource f g) x xa \\<Longrightarrow>\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa", "have *: \"rel_resource (\\<lambda>a b. b = f a)\\<inverse>\\<inverse> (\\<lambda>a b. b = g a) res res' \\<Longrightarrow> res' = map_resource f g res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_resource (\\<lambda>a b. b = f a)\\<inverse>\\<inverse>\n     (\\<lambda>a b. b = g a) res res' \\<Longrightarrow>\n    res' = map_resource f g res", "by(rule sym, subst (3) map_resource_id[symmetric], subst rel_resource_eq[symmetric])\n      (erule map_resource_parametric[THEN rel_funD, THEN rel_funD, THEN rel_funD, rotated -1]\n        , auto simp add: rel_fun_def)"], ["proof (state)\nthis:\n  rel_resource (\\<lambda>a b. b = f a)\\<inverse>\\<inverse>\n   (\\<lambda>a b. b = g a) res res' \\<Longrightarrow>\n  res' = map_resource f g res\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa \\<Longrightarrow>\n       BNF_Def.Grp UNIV (map_resource f g) x xa\n 2. \\<And>x xa.\n       BNF_Def.Grp UNIV (map_resource f g) x xa \\<Longrightarrow>\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa", "from 1"], ["proof (chain)\npicking this:\n  rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV g)\n   res res'", "show ?case"], ["proof (prove)\nusing this:\n  rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV g)\n   res res'\n\ngoal (1 subgoal):\n 1. BNF_Def.Grp UNIV (map_resource f g) res res'", "unfolding Grp_def"], ["proof (prove)\nusing this:\n  rel_resource\n   (\\<lambda>a b. b = f a \\<and> a \\<in> UNIV)\\<inverse>\\<inverse>\n   (\\<lambda>a b. b = g a \\<and> a \\<in> UNIV) res res'\n\ngoal (1 subgoal):\n 1. res' = map_resource f g res \\<and> res \\<in> UNIV", "using *"], ["proof (prove)\nusing this:\n  rel_resource\n   (\\<lambda>a b. b = f a \\<and> a \\<in> UNIV)\\<inverse>\\<inverse>\n   (\\<lambda>a b. b = g a \\<and> a \\<in> UNIV) res res'\n  rel_resource (\\<lambda>a b. b = f a)\\<inverse>\\<inverse>\n   (\\<lambda>a b. b = g a) res res' \\<Longrightarrow>\n  res' = map_resource f g res\n\ngoal (1 subgoal):\n 1. res' = map_resource f g res \\<and> res \\<in> UNIV", "by (clarsimp simp add: * simp del: conversep_iff)"], ["proof (state)\nthis:\n  BNF_Def.Grp UNIV (map_resource f g) res res'\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp UNIV (map_resource f g) x xa \\<Longrightarrow>\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp UNIV (map_resource f g) x xa \\<Longrightarrow>\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa", "case (2 _ _)"], ["proof (state)\nthis:\n  BNF_Def.Grp UNIV (map_resource f g) x_ xa_\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp UNIV (map_resource f g) x xa \\<Longrightarrow>\n       rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV g) x xa", "then"], ["proof (chain)\npicking this:\n  BNF_Def.Grp UNIV (map_resource f g) x_ xa_", "show ?case"], ["proof (prove)\nusing this:\n  BNF_Def.Grp UNIV (map_resource f g) x_ xa_\n\ngoal (1 subgoal):\n 1. rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV g) x_ xa_", "by(clarsimp simp add: Grp_iff, subst map_resource_id[symmetric])\n      (rule map_resource_parametric[THEN rel_funD, THEN rel_funD, THEN rel_funD, rotated -1]\n        , subst rel_resource_eq, auto simp add: Grp_iff rel_fun_def)"], ["proof (state)\nthis:\n  rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV g)\n   x_ xa_\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Losslessness\\<close>"], ["", "coinductive lossless_resource :: \"('a, 'b) \\<I> \\<Rightarrow> ('a, 'b) resource \\<Rightarrow> bool\"\n  for \\<I> where\n    lossless_resourceI: \"lossless_resource \\<I> res\" if\n    \"\\<And>a. a \\<in> outs_\\<I> \\<I> \\<Longrightarrow> lossless_spmf (run_resource res a)\"\n    \"\\<And>a b res'. \\<lbrakk> a \\<in> outs_\\<I> \\<I>; (b, res') \\<in> set_spmf (run_resource res a) \\<rbrakk> \\<Longrightarrow> lossless_resource \\<I> res'\""], ["", "lemma lossless_resource_coinduct [consumes 1, case_names lossless_resource, case_conclusion lossless_resource lossless step, coinduct pred: lossless_resource]:\n  assumes \"X res\"\n    and \"\\<And>res a. \\<lbrakk> X res; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> lossless_spmf (run_resource res a) \\<and>\n          (\\<forall>(b, res') \\<in> set_spmf (run_resource res a). X res' \\<or> lossless_resource \\<I> res')\"\n  shows \"lossless_resource \\<I> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource \\<I> res", "using assms(1)"], ["proof (prove)\nusing this:\n  X res\n\ngoal (1 subgoal):\n 1. lossless_resource \\<I> res", "by(rule lossless_resource.coinduct)(auto dest: assms(2))"], ["", "lemma lossless_resourceD:\n  \"\\<lbrakk> lossless_resource \\<I> res; a \\<in> outs_\\<I> \\<I> \\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (run_resource res a) \\<and> (\\<forall>(x, res')\\<in>set_spmf (run_resource res a). lossless_resource \\<I> res')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_resource \\<I> res; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf (run_resource res a) \\<and>\n                      (\\<forall>(x, res')\\<in>set_spmf (run_resource res a).\n                          lossless_resource \\<I> res')", "by(auto elim: lossless_resource.cases)"], ["", "lemma lossless_resource_mono:\n  assumes \"lossless_resource \\<I>' res\"\n    and le: \"outs_\\<I> \\<I> \\<subseteq> outs_\\<I> \\<I>'\"\n  shows \"lossless_resource \\<I> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource \\<I> res", "using assms(1)"], ["proof (prove)\nusing this:\n  lossless_resource \\<I>' res\n\ngoal (1 subgoal):\n 1. lossless_resource \\<I> res", "by(coinduction arbitrary: res)(auto dest: lossless_resourceD intro: subsetD[OF le])"], ["", "lemma lossless_resource_mono': \n  \"\\<lbrakk> lossless_resource \\<I>' res; \\<I> \\<le> \\<I>' \\<rbrakk> \\<Longrightarrow> lossless_resource \\<I> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_resource \\<I>' res; \\<I> \\<le> \\<I>'\\<rbrakk>\n    \\<Longrightarrow> lossless_resource \\<I> res", "by(erule lossless_resource_mono)(simp add: le_\\<I>_def)"], ["", "subsection \\<open>Operations\\<close>"], ["", "context fixes \"oracle\" :: \"'s \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 's) spmf\" begin"], ["", "primcorec resource_of_oracle :: \"'s \\<Rightarrow> ('a, 'b) resource\" where\n  \"run_resource (resource_of_oracle s) = (\\<lambda>a. map_spmf (map_prod id resource_of_oracle) (oracle s a))\""], ["", "end"], ["", "lemma resource_of_oracle_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((S ===> A ===> rel_spmf (rel_prod B S)) ===> S ===> rel_resource A B) resource_of_oracle resource_of_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_spmf (rel_prod B S)) ===> S ===> rel_resource A B)\n     resource_of_oracle resource_of_oracle", "unfolding resource_of_oracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_spmf (rel_prod B S)) ===> S ===> rel_resource A B)\n     (\\<lambda>oracle.\n         corec_resource\n          (\\<lambda>s a. map_spmf (map_prod id Inr) (oracle s a)))\n     (\\<lambda>oracle.\n         corec_resource\n          (\\<lambda>s a. map_spmf (map_prod id Inr) (oracle s a)))", "by transfer_prover"], ["", "lemma map_resource_resource_of_oracle:\n  \"map_resource f g (resource_of_oracle oracle s) = resource_of_oracle (map_fun id (map_fun f (map_spmf (map_prod g id))) oracle) s\"\n  for s :: 's"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_resource f g (resource_of_oracle oracle s) =\n    resource_of_oracle\n     (map_fun id (map_fun f (map_spmf (map_prod g id))) oracle) s", "using resource_of_oracle_parametric[of \"BNF_Def.Grp UNIV (id :: 's \\<Rightarrow> _)\" \"conversep (BNF_Def.Grp UNIV f)\" \"BNF_Def.Grp UNIV g\"]"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_fun (BNF_Def.Grp UNIV id)\n     (rel_fun (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n       (rel_spmf (rel_prod (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV id)))))\n   (rel_fun (BNF_Def.Grp UNIV id)\n     (rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n       (BNF_Def.Grp UNIV g)))\n   resource_of_oracle resource_of_oracle\n\ngoal (1 subgoal):\n 1. map_resource f g (resource_of_oracle oracle s) =\n    resource_of_oracle\n     (map_fun id (map_fun f (map_spmf (map_prod g id))) oracle) s", "unfolding prod.rel_Grp option.rel_Grp pmf.rel_Grp rel_fun_Grp rel_resource_Grp"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_fun (BNF_Def.Grp UNIV id)\n     (BNF_Def.Grp\n       {fa.\n        fa ` range f\n        \\<subseteq> {x. set_pmf x\n                        \\<subseteq> {x. set_option x\n  \\<subseteq> {x. Basic_BNFs.fsts x \\<subseteq> UNIV \\<and>\n                  Basic_BNFs.snds x \\<subseteq> UNIV}}}}\n       (map_fun f (map_spmf (map_prod g id)))))\n   (rel_fun (BNF_Def.Grp UNIV id) (BNF_Def.Grp UNIV (map_resource f g)))\n   resource_of_oracle resource_of_oracle\n\ngoal (1 subgoal):\n 1. map_resource f g (resource_of_oracle oracle s) =\n    resource_of_oracle\n     (map_fun id (map_fun f (map_spmf (map_prod g id))) oracle) s", "by simp\n    (subst (asm) (1 2) eq_alt[symmetric]\n      , subst (asm) (1 2) conversep_eq[symmetric]\n      , subst (asm) (1 2) eq_alt\n      , unfold rel_fun_Grp, simp add: rel_fun_Grp rel_fun_def Grp_iff)"], ["", "lemma (in callee_invariant_on) lossless_resource_of_oracle:\n  assumes *: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n    and \"I s\" \n  shows \"lossless_resource \\<I> (resource_of_oracle callee s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource \\<I> (resource_of_oracle callee s)", "using \\<open>I s\\<close>"], ["proof (prove)\nusing this:\n  I s\n\ngoal (1 subgoal):\n 1. lossless_resource \\<I> (resource_of_oracle callee s)", "by(coinduction arbitrary: s)(auto intro: * dest: callee_invariant)"], ["", "context includes lifting_syntax begin"], ["", "lemma resource_of_oracle_rprodl: includes lifting_syntax shows\n  \"resource_of_oracle ((rprodl ---> id ---> map_spmf (map_prod id lprodr)) oracle) ((s1, s2), s3) = \n    resource_of_oracle oracle (s1, s2, s3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resource_of_oracle\n     ((rprodl ---> id ---> map_spmf (map_prod id lprodr)) oracle)\n     ((s1, s2), s3) =\n    resource_of_oracle oracle (s1, s2, s3)", "by(rule resource_of_oracle_parametric[of \"BNF_Def.Grp UNIV rprodl\" \"(=)\" \"(=)\", THEN rel_funD, THEN rel_funD, unfolded rel_resource_eq])\n    (auto simp add: Grp_iff rel_fun_def spmf_rel_map intro!: rel_spmf_reflI)"], ["", "lemma resource_of_oracle_extend_state_oracle [simp]:\n  \"resource_of_oracle (extend_state_oracle oracle) (s', s) = resource_of_oracle oracle s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resource_of_oracle \\<dagger>oracle (s', s) = resource_of_oracle oracle s", "by(rule resource_of_oracle_parametric[of \"conversep (BNF_Def.Grp UNIV (\\<lambda>s. (s', s)))\" \"(=)\" \"(=)\", THEN rel_funD, THEN rel_funD, unfolded rel_resource_eq])\n    (auto simp add: Grp_iff rel_fun_def spmf_rel_map intro!: rel_spmf_reflI)"], ["", "end"], ["", "lemma exec_gpv_resource_of_oracle:\n  \"exec_gpv run_resource gpv (resource_of_oracle oracle s) = map_spmf (map_prod id (resource_of_oracle oracle)) (exec_gpv oracle gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv run_resource gpv (resource_of_oracle oracle s) =\n    map_spmf (map_prod id (resource_of_oracle oracle))\n     (exec_gpv oracle gpv s)", "by(subst spmf.map_id[symmetric], fold pmf.rel_eq)\n    (rule pmf.map_transfer[THEN rel_funD, THEN rel_funD, rotated]\n      , rule exec_gpv_parametric[where S=\"\\<lambda>res s. res = resource_of_oracle oracle s\" and CALL=\"(=)\" and A=\"(=)\", THEN rel_funD, THEN rel_funD, THEN rel_funD]\n      , auto simp add: gpv.rel_eq rel_fun_def spmf_rel_map elim: option.rel_cases intro!: rel_spmf_reflI)"], ["", "primcorec parallel_resource :: \"('a, 'b) resource \\<Rightarrow> ('c, 'd) resource \\<Rightarrow> ('a + 'c, 'b + 'd) resource\" where\n  \"run_resource (parallel_resource res1 res2) = \n   (\\<lambda>ac. case ac of Inl a \\<Rightarrow> map_spmf (map_prod Inl (\\<lambda>res1'. parallel_resource res1' res2)) (run_resource res1 a)\n         | Inr c \\<Rightarrow> map_spmf (map_prod Inr (\\<lambda>res2'. parallel_resource res1 res2')) (run_resource res2 c))\""], ["", "lemma parallel_resource_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_resource A B ===> rel_resource C D ===> rel_resource (rel_sum A C) (rel_sum B D))\n   parallel_resource parallel_resource\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_resource A B ===>\n     rel_resource C D ===> rel_resource (rel_sum A C) (rel_sum B D))\n     parallel_resource parallel_resource", "unfolding parallel_resource_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_resource A B ===>\n     rel_resource C D ===> rel_resource (rel_sum A C) (rel_sum B D))\n     (\\<lambda>uu uua.\n         corec_resource\n          (\\<lambda>(res1, res2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_spmf (map_prod Inl (\\<lambda>uu. Inr (uu, res2)))\n                 (run_resource res1 a)\n              | Inr c \\<Rightarrow>\n                  map_spmf (map_prod Inr (\\<lambda>uu. Inr (res1, uu)))\n                   (run_resource res2 c))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_resource\n          (\\<lambda>(res1, res2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_spmf (map_prod Inl (\\<lambda>uu. Inr (uu, res2)))\n                 (run_resource res1 a)\n              | Inr c \\<Rightarrow>\n                  map_spmf (map_prod Inr (\\<lambda>uu. Inr (res1, uu)))\n                   (run_resource res2 c))\n          (uu, uua))", "by transfer_prover"], ["", "text \\<open>\n  We cannot define the analogue of @{term plus_oracle} because we no longer have access to the state,\n  so state sharing is not possible!  So we can only compose resources, but we cannot build one\n  resource with several interfaces this way!\n\\<close>"], ["", "lemma resource_of_parallel_oracle:\n  \"resource_of_oracle (parallel_oracle oracle1 oracle2) (s1, s2) =\n   parallel_resource (resource_of_oracle oracle1 s1) (resource_of_oracle oracle2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resource_of_oracle (parallel_oracle oracle1 oracle2) (s1, s2) =\n    parallel_resource (resource_of_oracle oracle1 s1)\n     (resource_of_oracle oracle2 s2)", "by(coinduction arbitrary: s1 s2)\n    (auto 4 3 simp add: rel_fun_def spmf_rel_map split: sum.split intro!: rel_spmf_reflI)"], ["", "lemma parallel_resource_assoc: \\<comment> \\<open>There's still an ugly map operation in there to rebalance the interface trees, but well...\\<close>\n  \"parallel_resource (parallel_resource res1 res2) res3 = \n   map_resource rsuml lsumr (parallel_resource res1 (parallel_resource res2 res3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_resource (parallel_resource res1 res2) res3 =\n    map_resource rsuml lsumr\n     (parallel_resource res1 (parallel_resource res2 res3))", "by(coinduction arbitrary: res1 res2 res3)\n    (auto 4 5 intro!: rel_funI rel_spmf_reflI simp add: spmf_rel_map split: sum.split)"], ["", "lemma lossless_parallel_resource:\n  assumes \"lossless_resource \\<I> res1\" \"lossless_resource \\<I>' res2\"\n  shows \"lossless_resource (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (parallel_resource res1 res2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n     (parallel_resource res1 res2)", "using assms"], ["proof (prove)\nusing this:\n  lossless_resource \\<I> res1\n  lossless_resource \\<I>' res2\n\ngoal (1 subgoal):\n 1. lossless_resource (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n     (parallel_resource res1 res2)", "by(coinduction arbitrary: res1 res2)(clarsimp; erule PlusE; simp; frule (1) lossless_resourceD; auto 4 3)"], ["", "subsection \\<open>Well-typing\\<close>"], ["", "coinductive WT_resource :: \"('a, 'b) \\<I> \\<Rightarrow> ('a, 'b) resource \\<Rightarrow> bool\" (\"_ /\\<turnstile>res _ \\<surd>\" [100, 0] 99)\n  for \\<I> where\n    WT_resourceI: \"\\<I> \\<turnstile>res res \\<surd>\"\n  if \"\\<And>q r res'. \\<lbrakk> q \\<in> outs_\\<I> \\<I>; (r, res') \\<in> set_spmf (run_resource res q) \\<rbrakk> \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> \\<I> \\<turnstile>res res' \\<surd>\""], ["", "lemma WT_resource_coinduct [consumes 1, case_names WT_resource, case_conclusion WT_resource response WT_resource, coinduct pred: WT_resource]:\n  assumes \"X res\"\n    and \"\\<And>res q r res'. \\<lbrakk> X res; q \\<in> outs_\\<I> \\<I>; (r, res') \\<in> set_spmf (run_resource res q) \\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> (X res' \\<or> \\<I> \\<turnstile>res res' \\<surd>)\"\n  shows \"\\<I> \\<turnstile>res res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>res res \\<surd>", "using assms(1)"], ["proof (prove)\nusing this:\n  X res\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>res res \\<surd>", "by(rule WT_resource.coinduct)(blast dest: assms(2))"], ["", "lemma WT_resourceD:\n  assumes \"\\<I> \\<turnstile>res res \\<surd>\" \"q \\<in> outs_\\<I> \\<I>\" \"(r, res') \\<in> set_spmf (run_resource res q)\"\n  shows \"r \\<in> responses_\\<I> \\<I> q \\<and> \\<I> \\<turnstile>res res' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> responses_\\<I> \\<I> q \\<and> \\<I> \\<turnstile>res res' \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>res res \\<surd>\n  q \\<in> outs_\\<I> \\<I>\n  (r, res') \\<in> set_spmf (run_resource res q)\n\ngoal (1 subgoal):\n 1. r \\<in> responses_\\<I> \\<I> q \\<and> \\<I> \\<turnstile>res res' \\<surd>", "by(auto elim: WT_resource.cases)"], ["", "lemma WT_resource_of_oracle [simp]:\n  assumes \"\\<And>s. \\<I> \\<turnstile>c oracle s \\<surd>\"\n  shows \"\\<I> \\<turnstile>res resource_of_oracle oracle s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>res resource_of_oracle oracle s \\<surd>", "by(coinduction arbitrary: s)(auto dest: WT_calleeD[OF assms])"], ["", "lemma WT_resource_bot [simp]: \"bot \\<turnstile>res res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<turnstile>res res \\<surd>", "by(rule WT_resource.intros)auto"], ["", "lemma WT_resource_full: \"\\<I>_full \\<turnstile>res res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<turnstile>res res \\<surd>", "by(coinduction arbitrary: res)(auto)"], ["", "lemma (in callee_invariant_on) WT_resource_of_oracle:\n  \"I s \\<Longrightarrow> \\<I> \\<turnstile>res resource_of_oracle callee s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I s \\<Longrightarrow>\n    \\<I> \\<turnstile>res resource_of_oracle callee s \\<surd>", "by(coinduction arbitrary: s)(auto dest: callee_invariant')"], ["", "named_theorems WT_intro \"Interface typing introduction rules\""], ["", "lemmas [WT_intro] = WT_gpv_map_gpv' WT_gpv_map_gpv"], ["", "lemma WT_parallel_resource [WT_intro]:\n  assumes \"\\<I>1 \\<turnstile>res res1 \\<surd>\"\n    and \"\\<I>2 \\<turnstile>res res2 \\<surd>\"\n  shows \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>res parallel_resource res1 res2 \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \n    \\<turnstile>res parallel_resource res1 res2 \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I>1 \\<turnstile>res res1 \\<surd>\n  \\<I>2 \\<turnstile>res res2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \n    \\<turnstile>res parallel_resource res1 res2 \\<surd>", "by(coinduction arbitrary: res1 res2)(auto 4 4 intro!: imageI dest: WT_resourceD)"], ["", "lemma callee_invariant_run_resource: \"callee_invariant_on run_resource (\\<lambda>res.  \\<I> \\<turnstile>res res \\<surd>) \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on run_resource (WT_resource \\<I>) \\<I>", "by(unfold_locales)(auto dest: WT_resourceD intro: WT_calleeI)"], ["", "lemma callee_invariant_run_lossless_resource:\n  \"callee_invariant_on run_resource (\\<lambda>res. lossless_resource \\<I> res \\<and> \\<I> \\<turnstile>res res \\<surd>) \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on run_resource\n     (\\<lambda>res.\n         lossless_resource \\<I> res \\<and> \\<I> \\<turnstile>res res \\<surd>)\n     \\<I>", "by(unfold_locales)(auto dest: WT_resourceD lossless_resourceD intro: WT_calleeI)"], ["", "interpretation run_lossless_resource:\n  callee_invariant_on run_resource \"\\<lambda>res. lossless_resource \\<I> res \\<and> \\<I> \\<turnstile>res res \\<surd>\" \\<I> for \\<I>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on run_resource\n     (\\<lambda>res.\n         lossless_resource \\<I> res \\<and> \\<I> \\<turnstile>res res \\<surd>)\n     \\<I>", "by(rule callee_invariant_run_lossless_resource)"], ["", "end"]]}