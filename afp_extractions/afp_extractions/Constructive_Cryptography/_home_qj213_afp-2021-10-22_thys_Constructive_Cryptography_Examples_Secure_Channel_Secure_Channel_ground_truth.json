{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Examples/Secure_Channel/Secure_Channel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma plossless_enc [plossless_intro]:\n  \"plossless_converter (\\<I>_uniform (nlists UNIV \\<eta>) UNIV) (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform (nlists UNIV \\<eta>) UNIV) (CIPHER.enc \\<eta>)\"", "lemma plossless_dec [plossless_intro]:\n  \"plossless_converter (\\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))) (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))) (CIPHER.dec \\<eta>)\"", "lemma callee_invariant_on_key_oracle:\n  \"callee_invariant_on\n     (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O CIPHER.KEY.key_oracle \\<eta>)\n     (\\<lambda>x. case x of None \\<Rightarrow> True | Some x' \\<Rightarrow> length x' = \\<eta>)\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_full)\"", "lemma WT_enc [WT_intro]: \"\\<I>_uniform (nlists UNIV \\<eta>) UNIV,\n  \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform (vld \\<eta>) UNIV \\<turnstile>\\<^sub>C CIPHER.enc \\<eta> \\<surd>\"", "lemma WT_dec [WT_intro]: \"\\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>)) \\<turnstile>\\<^sub>C\n    CIPHER.dec \\<eta> \\<surd>\"", "lemma bound_enc [interaction_bound]: \"interaction_any_bounded_converter (CIPHER.enc \\<eta>) (enat 2)\"", "lemma bound_dec [interaction_bound]: \"interaction_any_bounded_converter (CIPHER.dec \\<eta>) (enat 2)\"", "theorem mac_otp:\n  defines \"\\<I>_real \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform {x. valid_mac_query \\<eta> x} UNIV\"\n    and \"\\<I>_ideal \\<equiv> \\<lambda>_. \\<I>_full\"\n    and \"\\<I>_common \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_full\"\n  shows\n    \"constructive_security\n      (\\<lambda>\\<eta>. 1\\<^sub>C |\\<^sub>= (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot> parallel_wiring \\<rhd>\n            parallel_resource1_wiring \\<rhd>\n            CIPHER.KEY.res \\<eta> \\<parallel>\n            (1\\<^sub>C |\\<^sub>= MAC.enm \\<eta> |\\<^sub>= MAC.dem \\<eta> \\<rhd>\n             1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n             parallel_resource1_wiring \\<rhd> MAC.RO.res \\<eta> \\<parallel> INSEC.res))\n      (\\<lambda>_. SEC.res)\n      (\\<lambda>\\<eta>. CNV Message_Authentication_Code.sim (Inl None) \\<odot> CNV One_Time_Pad.sim None)\n      (\\<lambda>\\<eta>. \\<I>_uniform (Set.Collect (valid_mac_query \\<eta>)) (insert None (Some ` (nlists UNIV \\<eta> \\<times> nlists UNIV \\<eta>))))\n      (\\<lambda>\\<eta>. \\<I>_uniform UNIV {None, Some \\<eta>})\n      (\\<lambda>\\<eta>. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n      (\\<lambda>_. enat q) True (\\<lambda>\\<eta>. (id, map_option length) \\<circ>\\<^sub>w (insec_query_of, map_option snd))\""], "translations": [["", "lemma plossless_enc [plossless_intro]:\n  \"plossless_converter (\\<I>_uniform (nlists UNIV \\<eta>) UNIV) (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform (nlists UNIV \\<eta>) UNIV) (CIPHER.enc \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter (\\<I>_uniform (nlists UNIV \\<eta>) UNIV)\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (nlists UNIV \\<eta>) UNIV)\n     (CIPHER.enc \\<eta>)", "unfolding CIPHER.enc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter (\\<I>_uniform (nlists UNIV \\<eta>) UNIV)\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (nlists UNIV \\<eta>) UNIV)\n     (CNV (stateless_callee\n            (\\<lambda>m.\n                Pause (Inl ()) Done \\<bind>\n                (\\<lambda>k.\n                    lift_spmf (enc \\<eta> (projl k) m) \\<bind>\n                    (\\<lambda>c.\n                        Pause (Inr c) Done \\<bind> (\\<lambda>_. Done ())))))\n       ())", "by(rule plossless_converter_of_callee) (auto simp add: stateless_callee_def enc_def in_nlists_UNIV)"], ["", "lemma plossless_dec [plossless_intro]:\n  \"plossless_converter (\\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))) (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))) (CIPHER.dec \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     (\\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n     (CIPHER.dec \\<eta>)", "unfolding CIPHER.dec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     (\\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n     (CNV (stateless_callee\n            (\\<lambda>_.\n                Pause (Inr ())\n                 (\\<lambda>c'.\n                     case c' of Inl a \\<Rightarrow> Done None\n                     | Inr None \\<Rightarrow> Done None\n                     | Inr (Some c) \\<Rightarrow>\n                         Pause (Inl ()) Done \\<bind>\n                         (\\<lambda>k. Done (dec \\<eta> (projl k) c)))))\n       ())", "by(rule plossless_converter_of_callee) (auto simp add: stateless_callee_def dec_def in_nlists_UNIV split: option.split)"], ["", "lemma callee_invariant_on_key_oracle:\n  \"callee_invariant_on\n     (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O CIPHER.KEY.key_oracle \\<eta>)\n     (\\<lambda>x. case x of None \\<Rightarrow> True | Some x' \\<Rightarrow> length x' = \\<eta>)\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_full)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on\n     (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n      CIPHER.KEY.key_oracle \\<eta>)\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> True\n         | Some x' \\<Rightarrow> length x' = \\<eta>)\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_full)", "proof(unfold_locales, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                         CIPHER.KEY.key_oracle \\<eta>)\n                         s x);\n        case s of None \\<Rightarrow> True\n        | Some x' \\<Rightarrow> length x' = \\<eta>;\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n                  \\<I>_full)\\<rbrakk>\n       \\<Longrightarrow> case s' of None \\<Rightarrow> True\n                         | Some x' \\<Rightarrow> length x' = \\<eta>\n 2. \\<And>s.\n       case s of None \\<Rightarrow> True\n       | Some x' \\<Rightarrow> length x' = \\<eta> \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_full \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "case (1 s x y s')"], ["proof (state)\nthis:\n  (y, s')\n  \\<in> set_spmf\n         ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n           CIPHER.KEY.key_oracle \\<eta>)\n           s x)\n  case s of None \\<Rightarrow> True\n  | Some x' \\<Rightarrow> length x' = \\<eta>\n  x \\<in> outs_\\<I>\n           (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n            \\<I>_full)\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                         CIPHER.KEY.key_oracle \\<eta>)\n                         s x);\n        case s of None \\<Rightarrow> True\n        | Some x' \\<Rightarrow> length x' = \\<eta>;\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n                  \\<I>_full)\\<rbrakk>\n       \\<Longrightarrow> case s' of None \\<Rightarrow> True\n                         | Some x' \\<Rightarrow> length x' = \\<eta>\n 2. \\<And>s.\n       case s of None \\<Rightarrow> True\n       | Some x' \\<Rightarrow> length x' = \\<eta> \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_full \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (y, s')\n  \\<in> set_spmf\n         ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n           CIPHER.KEY.key_oracle \\<eta>)\n           s x)\n  case s of None \\<Rightarrow> True\n  | Some x' \\<Rightarrow> length x' = \\<eta>\n  x \\<in> outs_\\<I>\n           (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n            \\<I>_full)", "show ?case"], ["proof (prove)\nusing this:\n  (y, s')\n  \\<in> set_spmf\n         ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n           CIPHER.KEY.key_oracle \\<eta>)\n           s x)\n  case s of None \\<Rightarrow> True\n  | Some x' \\<Rightarrow> length x' = \\<eta>\n  x \\<in> outs_\\<I>\n           (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n            \\<I>_full)\n\ngoal (1 subgoal):\n 1. case s' of None \\<Rightarrow> True\n    | Some x' \\<Rightarrow> length x' = \\<eta>", "by(cases x; clarsimp split: option.splits; simp add: key_def in_nlists_UNIV)"], ["proof (state)\nthis:\n  case s' of None \\<Rightarrow> True\n  | Some x' \\<Rightarrow> length x' = \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       case s of None \\<Rightarrow> True\n       | Some x' \\<Rightarrow> length x' = \\<eta> \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_full \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       case s of None \\<Rightarrow> True\n       | Some x' \\<Rightarrow> length x' = \\<eta> \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_full \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "case (2 s)"], ["proof (state)\nthis:\n  case s of None \\<Rightarrow> True\n  | Some x' \\<Rightarrow> length x' = \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       case s of None \\<Rightarrow> True\n       | Some x' \\<Rightarrow> length x' = \\<eta> \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_full \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "then"], ["proof (chain)\npicking this:\n  case s of None \\<Rightarrow> True\n  | Some x' \\<Rightarrow> length x' = \\<eta>", "show ?case"], ["proof (prove)\nusing this:\n  case s of None \\<Rightarrow> True\n  | Some x' \\<Rightarrow> length x' = \\<eta>\n\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_full \\<turnstile>c\n    (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n     CIPHER.KEY.key_oracle \\<eta>)\n     s \\<surd>", "by(clarsimp intro!: WT_calleeI split: option.split_asm)(simp_all add: in_nlists_UNIV key_def)"], ["proof (state)\nthis:\n  \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n  \\<I>_full \\<turnstile>c\n  (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n   CIPHER.KEY.key_oracle \\<eta>)\n   s \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation key: callee_invariant_on\n  \"CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O CIPHER.KEY.key_oracle \\<eta>\"\n  \"\\<lambda>x. case x of None \\<Rightarrow> True | Some x' \\<Rightarrow> length x' = \\<eta>\"\n  \"\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_full\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on\n     (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n      CIPHER.KEY.key_oracle \\<eta>)\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> True\n         | Some x' \\<Rightarrow> length x' = \\<eta>)\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_full)", "by(rule callee_invariant_on_key_oracle)"], ["", "lemma WT_enc [WT_intro]: \"\\<I>_uniform (nlists UNIV \\<eta>) UNIV,\n  \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform (vld \\<eta>) UNIV \\<turnstile>\\<^sub>C CIPHER.enc \\<eta> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV,\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform (vld \\<eta>) UNIV \\<turnstile>\\<^sub>C\n    CIPHER.enc \\<eta> \\<surd>", "unfolding CIPHER.enc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV,\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform (vld \\<eta>) UNIV \\<turnstile>\\<^sub>C\n    CNV (stateless_callee\n          (\\<lambda>m.\n              Pause (Inl ()) Done \\<bind>\n              (\\<lambda>k.\n                  lift_spmf (enc \\<eta> (projl k) m) \\<bind>\n                  (\\<lambda>c.\n                      Pause (Inr c) Done \\<bind> (\\<lambda>_. Done ())))))\n     () \\<surd>", "by (rule WT_converter_of_callee) (simp_all add: stateless_callee_def vld_def enc_def in_nlists_UNIV)"], ["", "lemma WT_dec [WT_intro]: \"\\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>)) \\<turnstile>\\<^sub>C\n    CIPHER.dec \\<eta> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>)) \\<turnstile>\\<^sub>C\n    CIPHER.dec \\<eta> \\<surd>", "unfolding CIPHER.dec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>)) \\<turnstile>\\<^sub>C\n    CNV (stateless_callee\n          (\\<lambda>_.\n              Pause (Inr ())\n               (\\<lambda>c'.\n                   case c' of Inl a \\<Rightarrow> Done None\n                   | Inr None \\<Rightarrow> Done None\n                   | Inr (Some c) \\<Rightarrow>\n                       Pause (Inl ()) Done \\<bind>\n                       (\\<lambda>k. Done (dec \\<eta> (projl k) c)))))\n     () \\<surd>", "by(rule WT_converter_of_callee)(auto simp add: stateless_callee_def dec_def vld_def in_nlists_UNIV)"], ["", "lemma bound_enc [interaction_bound]: \"interaction_any_bounded_converter (CIPHER.enc \\<eta>) (enat 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (CIPHER.enc \\<eta>) (enat 2)", "unfolding CIPHER.enc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (CNV (stateless_callee\n            (\\<lambda>m.\n                Pause (Inl ()) Done \\<bind>\n                (\\<lambda>k.\n                    lift_spmf (enc \\<eta> (projl k) m) \\<bind>\n                    (\\<lambda>c.\n                        Pause (Inr c) Done \\<bind> (\\<lambda>_. Done ())))))\n       ())\n     (enat 2)", "by (rule interaction_any_bounded_converter_of_callee) \n    (auto simp add: stateless_callee_def map_gpv_id_bind_gpv zero_enat_def one_enat_def)"], ["", "lemma bound_dec [interaction_bound]: \"interaction_any_bounded_converter (CIPHER.dec \\<eta>) (enat 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (CIPHER.dec \\<eta>) (enat 2)", "unfolding CIPHER.dec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     (CNV (stateless_callee\n            (\\<lambda>_.\n                Pause (Inr ())\n                 (\\<lambda>c'.\n                     case c' of Inl a \\<Rightarrow> Done None\n                     | Inr None \\<Rightarrow> Done None\n                     | Inr (Some c) \\<Rightarrow>\n                         Pause (Inl ()) Done \\<bind>\n                         (\\<lambda>k. Done (dec \\<eta> (projl k) c)))))\n       ())\n     (enat 2)", "by (rule interaction_any_bounded_converter_of_callee)\n    (auto simp add: stateless_callee_def map_gpv_id_bind_gpv zero_enat_def one_enat_def split: sum.split option.split)"], ["", "theorem mac_otp:\n  defines \"\\<I>_real \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform {x. valid_mac_query \\<eta> x} UNIV\"\n    and \"\\<I>_ideal \\<equiv> \\<lambda>_. \\<I>_full\"\n    and \"\\<I>_common \\<equiv> \\<lambda>\\<eta>. \\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_full\"\n  shows\n    \"constructive_security\n      (\\<lambda>\\<eta>. 1\\<^sub>C |\\<^sub>= (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot> parallel_wiring \\<rhd>\n            parallel_resource1_wiring \\<rhd>\n            CIPHER.KEY.res \\<eta> \\<parallel>\n            (1\\<^sub>C |\\<^sub>= MAC.enm \\<eta> |\\<^sub>= MAC.dem \\<eta> \\<rhd>\n             1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n             parallel_resource1_wiring \\<rhd> MAC.RO.res \\<eta> \\<parallel> INSEC.res))\n      (\\<lambda>_. SEC.res)\n      (\\<lambda>\\<eta>. CNV Message_Authentication_Code.sim (Inl None) \\<odot> CNV One_Time_Pad.sim None)\n      (\\<lambda>\\<eta>. \\<I>_uniform (Set.Collect (valid_mac_query \\<eta>)) (insert None (Some ` (nlists UNIV \\<eta> \\<times> nlists UNIV \\<eta>))))\n      (\\<lambda>\\<eta>. \\<I>_uniform UNIV {None, Some \\<eta>})\n      (\\<lambda>\\<eta>. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n      (\\<lambda>_. enat q) True (\\<lambda>\\<eta>. (id, map_option length) \\<circ>\\<^sub>w (insec_query_of, map_option snd))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constructive_security\n     (\\<lambda>\\<eta>.\n         1\\<^sub>C |\\<^sub>=\n         (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring \\<rhd>\n         parallel_resource1_wiring \\<rhd>\n         CIPHER.KEY.res \\<eta> \\<parallel>\n         (1\\<^sub>C |\\<^sub>= MAC.enm \\<eta> |\\<^sub>= MAC.dem \\<eta> \\<rhd>\n          1\\<^sub>C |\\<^sub>= parallel_wiring \\<rhd>\n          parallel_resource1_wiring \\<rhd>\n          MAC.RO.res \\<eta> \\<parallel> INSEC.res))\n     (\\<lambda>_. SEC.res)\n     (\\<lambda>\\<eta>.\n         CNV Message_Authentication_Code.sim (Inl None) \\<odot>\n         CNV One_Time_Pad.sim None)\n     (\\<lambda>\\<eta>.\n         \\<I>_uniform (Set.Collect (valid_mac_query \\<eta>))\n          (insert None\n            (Some ` (nlists UNIV \\<eta> \\<times> nlists UNIV \\<eta>))))\n     (\\<lambda>\\<eta>. \\<I>_uniform UNIV {None, Some \\<eta>})\n     (\\<lambda>\\<eta>.\n         \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n     (\\<lambda>_. enat q) True\n     (\\<lambda>\\<eta>.\n         (id, map_option length) \\<circ>\\<^sub>w\n         (insec_query_of, map_option snd))", "proof(rule composability[OF one_time_pad[THEN constructive_security2.constructive_security, unfolded CIPHER.res_alt_def comp_converter_parallel2 comp_converter_id_left]\n  secure_mac[unfolded MAC.res_def, \n        THEN constructive_security.parallel_resource1,\n        THEN constructive_security.lifting],\n      where ?\\<I>_res2=\"\\<lambda>\\<eta>. \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (nlists UNIV \\<eta>)\" and ?bound_conv1=\"\\<lambda>_. 2\" and ?q3 = \"2 * q\" and bound_sim = \"\\<lambda>_. \\<infinity>\",\nsimplified]\n    , goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n       \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       lossless_resource\n        (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n        (CIPHER.KEY.res \\<eta>)\n 3. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 4. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 5. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 6. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "case (1 \\<eta>)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n       \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       lossless_resource\n        (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n        (CIPHER.KEY.res \\<eta>)\n 3. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 4. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 5. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 6. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "have [simp]: \"\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c CIPHER.KEY.key_oracle \\<eta> s \\<surd>\"\n    if \"pred_option (\\<lambda>x. length x = \\<eta>) s\" for s \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c\n    CIPHER.KEY.key_oracle \\<eta> s \\<surd>", "apply(rule WT_calleeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I> (\\<I>_uniform UNIV (nlists UNIV \\<eta>));\n        (ret, sa)\n        \\<in> set_spmf (CIPHER.KEY.key_oracle \\<eta> s call)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (\\<I>_uniform UNIV (nlists UNIV \\<eta>))\n                                call", "subgoal for call"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>call \\<in> outs_\\<I> (\\<I>_uniform UNIV (nlists UNIV \\<eta>));\n     (ret_, sa_)\n     \\<in> set_spmf (CIPHER.KEY.key_oracle \\<eta> s call)\\<rbrakk>\n    \\<Longrightarrow> ret_\n                      \\<in> responses_\\<I>\n                             (\\<I>_uniform UNIV (nlists UNIV \\<eta>)) call", "using that"], ["proof (prove)\nusing this:\n  pred_option (\\<lambda>x. length x = \\<eta>) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>call \\<in> outs_\\<I> (\\<I>_uniform UNIV (nlists UNIV \\<eta>));\n     (ret_, sa_)\n     \\<in> set_spmf (CIPHER.KEY.key_oracle \\<eta> s call)\\<rbrakk>\n    \\<Longrightarrow> ret_\n                      \\<in> responses_\\<I>\n                             (\\<I>_uniform UNIV (nlists UNIV \\<eta>)) call", "by(cases s; cases call; clarsimp; auto simp add: key_def in_nlists_UNIV)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pred_option (\\<lambda>x. length x = ?\\<eta>1) ?s1 \\<Longrightarrow>\n  \\<I>_uniform UNIV (nlists UNIV ?\\<eta>1) \\<turnstile>c\n  CIPHER.KEY.key_oracle ?\\<eta>1 ?s1 \\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n       \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       lossless_resource\n        (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n        (CIPHER.KEY.res \\<eta>)\n 3. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 4. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 5. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 6. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "have *: \"callee_invariant_on (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O CIPHER.KEY.key_oracle \\<eta>) (pred_option (\\<lambda>x. length x = \\<eta>))\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (nlists UNIV \\<eta>))\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on\n     (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n      CIPHER.KEY.key_oracle \\<eta>)\n     (pred_option (\\<lambda>x. length x = \\<eta>))\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (nlists UNIV \\<eta>))", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s')\n                \\<in> set_spmf\n                       ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                         CIPHER.KEY.key_oracle \\<eta>)\n                         s x);\n        pred_option (\\<lambda>x. length x = \\<eta>) s;\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n                  \\<I>_uniform UNIV (nlists UNIV \\<eta>))\\<rbrakk>\n       \\<Longrightarrow> pred_option (\\<lambda>x. length x = \\<eta>) s'\n 2. \\<And>s.\n       pred_option (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s')\n             \\<in> set_spmf\n                    ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                      CIPHER.KEY.key_oracle \\<eta>)\n                      s x);\n     pred_option (\\<lambda>x. length x = \\<eta>) s;\n     x \\<in> outs_\\<I>\n              (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n               \\<I>_uniform UNIV (nlists UNIV \\<eta>))\\<rbrakk>\n    \\<Longrightarrow> pred_option (\\<lambda>x. length x = \\<eta>) s'", "by(cases s; cases x; clarsimp; auto simp add: key_def in_nlists_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_option (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c\n       (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n        CIPHER.KEY.key_oracle \\<eta>)\n        s \\<surd>", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option (\\<lambda>x. length x = \\<eta>) s \\<Longrightarrow>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<turnstile>c\n    (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n     CIPHER.KEY.key_oracle \\<eta>)\n     s \\<surd>", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  callee_invariant_on\n   (CIPHER.KEY.key_oracle ?\\<eta>1 \\<oplus>\\<^sub>O\n    CIPHER.KEY.key_oracle ?\\<eta>1)\n   (pred_option (\\<lambda>x. length x = ?\\<eta>1))\n   (\\<I>_uniform UNIV (nlists UNIV ?\\<eta>1) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV ?\\<eta>1))\n\ngoal (6 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n       \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>\n 2. \\<And>\\<eta>.\n       lossless_resource\n        (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n        (CIPHER.KEY.res \\<eta>)\n 3. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 4. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 5. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 6. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "then"], ["proof (chain)\npicking this:\n  callee_invariant_on\n   (CIPHER.KEY.key_oracle ?\\<eta>1 \\<oplus>\\<^sub>O\n    CIPHER.KEY.key_oracle ?\\<eta>1)\n   (pred_option (\\<lambda>x. length x = ?\\<eta>1))\n   (\\<I>_uniform UNIV (nlists UNIV ?\\<eta>1) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV ?\\<eta>1))", "show ?case"], ["proof (prove)\nusing this:\n  callee_invariant_on\n   (CIPHER.KEY.key_oracle ?\\<eta>1 \\<oplus>\\<^sub>O\n    CIPHER.KEY.key_oracle ?\\<eta>1)\n   (pred_option (\\<lambda>x. length x = ?\\<eta>1))\n   (\\<I>_uniform UNIV (nlists UNIV ?\\<eta>1) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV ?\\<eta>1))\n\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n    \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>", "unfolding CIPHER.KEY.res_def"], ["proof (prove)\nusing this:\n  callee_invariant_on\n   (CIPHER.KEY.key_oracle ?\\<eta>1 \\<oplus>\\<^sub>O\n    CIPHER.KEY.key_oracle ?\\<eta>1)\n   (pred_option (\\<lambda>x. length x = ?\\<eta>1))\n   (\\<I>_uniform UNIV (nlists UNIV ?\\<eta>1) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV ?\\<eta>1))\n\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n    \\<turnstile>res RES (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                         CIPHER.KEY.key_oracle \\<eta>)\n                     None \\<surd>", "by(rule callee_invariant_on.WT_resource_of_oracle) simp"], ["proof (state)\nthis:\n  \\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n  \\<I>_uniform UNIV (nlists UNIV \\<eta>) \n  \\<turnstile>res CIPHER.KEY.res \\<eta> \\<surd>\n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       lossless_resource\n        (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n        (CIPHER.KEY.res \\<eta>)\n 2. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 3. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 4. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 5. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "case (2 \\<eta>)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>\\<eta>.\n       lossless_resource\n        (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n        (CIPHER.KEY.res \\<eta>)\n 2. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 3. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 4. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 5. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n     (CIPHER.KEY.res \\<eta>)", "unfolding CIPHER.KEY.res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource\n     (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n     (RES (CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n           CIPHER.KEY.key_oracle \\<eta>)\n       None)", "apply(rule callee_invariant_on.lossless_resource_of_oracle[OF *])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I>\n                         (\\<I>_uniform UNIV\n                           (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n                          \\<I>_uniform UNIV (nlists UNIV \\<eta>));\n        pred_option (\\<lambda>x. length x = \\<eta>) s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                            CIPHER.KEY.key_oracle \\<eta>)\n                            s x)\n 2. pred_option (\\<lambda>x. length x = \\<eta>) None", "subgoal for s x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I>\n                      (\\<I>_uniform UNIV\n                        (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n                       \\<I>_uniform UNIV (nlists UNIV \\<eta>));\n     pred_option (\\<lambda>x. length x = \\<eta>) s\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf\n                       ((CIPHER.KEY.key_oracle \\<eta> \\<oplus>\\<^sub>O\n                         CIPHER.KEY.key_oracle \\<eta>)\n                         s x)", "by(cases s; cases x)(auto split: plus_oracle_split; simp add: key_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option (\\<lambda>x. length x = \\<eta>) None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option (\\<lambda>x. length x = \\<eta>) None", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lossless_resource\n   (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (nlists UNIV \\<eta>))\n   (CIPHER.KEY.res \\<eta>)\n\ngoal (4 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 2. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 3. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 4. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "case (3 \\<eta>)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>\\<eta>.\n       \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n       (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform UNIV\n         (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n       (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n       parallel_wiring \\<surd>\n 2. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 3. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 4. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n    (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform UNIV\n      (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n    (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n    parallel_wiring \\<surd>", "by(rule WT_intro)+"], ["proof (state)\nthis:\n  \\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n  \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)),\n  (\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n   \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n  (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n   \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))) \\<turnstile>\\<^sub>C\n  (CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n  parallel_wiring \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 2. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 3. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "case (4 \\<eta>)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>\\<eta>.\n       interaction_any_bounded_converter\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)\n        2\n 2. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 3. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter\n     ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n      parallel_wiring)\n     2", "by interaction_bound_converter code_simp"], ["proof (state)\nthis:\n  interaction_any_bounded_converter\n   ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot> parallel_wiring)\n   2\n\ngoal (2 subgoals):\n 1. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 2. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "case (5 \\<eta>)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>\\<eta>. enat q * 2 \\<le> enat (2 * q)\n 2. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat q * 2 \\<le> enat (2 * q)", "by (simp add: mult_2_right)"], ["proof (state)\nthis:\n  enat q * 2 \\<le> enat (2 * q)\n\ngoal (1 subgoal):\n 1. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "case (6 \\<eta>)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>\\<eta>.\n       plossless_converter\n        (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n        ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n         (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n          \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n        ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n         parallel_wiring)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n     ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n     ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n      parallel_wiring)", "unfolding vld_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter\n     (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n     ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>))))\n     ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot>\n      parallel_wiring)", "by(rule plossless_intro WT_intro[unfolded vld_def])+"], ["proof (state)\nthis:\n  plossless_converter\n   (\\<I>_uniform (nlists UNIV \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (insert None (Some ` nlists UNIV \\<eta>)))\n   ((\\<I>_uniform UNIV (nlists UNIV \\<eta>) \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform UNIV (nlists UNIV \\<eta>)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_uniform (vld \\<eta>) UNIV \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform UNIV (insert None (Some ` vld \\<eta>))))\n   ((CIPHER.enc \\<eta> |\\<^sub>= CIPHER.dec \\<eta>) \\<odot> parallel_wiring)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}