{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Converter_Rewrite.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma eq_resource_on_coinduct [consumes 1, case_names eq_resource_on, coinduct pred: eq_resource_on]:\n  assumes \"X res res'\"\n    and \"\\<And>res res' a. \\<lbrakk> X res res'; a \\<in> A \\<rbrakk>\n      \\<Longrightarrow> rel_spmf (rel_prod (=) (\\<lambda>res res'. X res res' \\<or> A \\<turnstile>\\<^sub>R res \\<sim> res')) (run_resource res a) (run_resource res' a)\"\n  shows \"A \\<turnstile>\\<^sub>R res \\<sim> res'\"", "lemma eq_resource_onD:\n  assumes \"A \\<turnstile>\\<^sub>R res \\<sim> res'\" \"a \\<in> A\"\n  shows \"rel_spmf (rel_prod (=) (eq_resource_on A)) (run_resource res a) (run_resource res' a)\"", "lemma eq_resource_on_refl [simp]: \"A \\<turnstile>\\<^sub>R res \\<sim> res\"", "lemma eq_resource_on_reflI: \"res = res' \\<Longrightarrow> A \\<turnstile>\\<^sub>R res \\<sim> res'\"", "lemma eq_resource_on_sym: \"A \\<turnstile>\\<^sub>R res \\<sim> res'\" if \"A \\<turnstile>\\<^sub>R res' \\<sim> res\"", "lemma eq_resource_on_trans [trans]: \"A \\<turnstile>\\<^sub>R res \\<sim> res''\" if \"A \\<turnstile>\\<^sub>R res \\<sim> res'\" \"A \\<turnstile>\\<^sub>R res' \\<sim> res''\"", "lemma eq_resource_on_UNIV_D [simp]: \"res = res'\" if \"UNIV \\<turnstile>\\<^sub>R res \\<sim> res'\"", "lemma eq_resource_on_UNIV_iff: \"UNIV \\<turnstile>\\<^sub>R res \\<sim> res' \\<longleftrightarrow> res = res'\"", "lemma eq_resource_on_mono: \"\\<lbrakk> A' \\<turnstile>\\<^sub>R res \\<sim> res'; A \\<subseteq> A' \\<rbrakk> \\<Longrightarrow> A \\<turnstile>\\<^sub>R res \\<sim> res'\"", "lemma eq_resource_on_empty [simp]: \"{} \\<turnstile>\\<^sub>R res \\<sim> res'\"", "lemma eq_resource_on_resource_of_oracleI:\n  includes lifting_syntax \n  fixes S\n  assumes sim: \"(S ===> eq_on A ===> rel_spmf (rel_prod (=) S)) r1 r2\"\n    and S: \"S s1 s2\"\n  shows \"A \\<turnstile>\\<^sub>R resource_of_oracle r1 s1 \\<sim> resource_of_oracle r2 s2\"", "lemma exec_gpv_eq_resource_on:\n  assumes \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'\"\n    and \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"\\<I> \\<turnstile>res res \\<surd>\"\n  shows \"rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>))) (exec_gpv run_resource gpv res) (exec_gpv run_resource gpv res')\"", "lemma eq_\\<I>_generat_mono':\n  \"\\<lbrakk> eq_\\<I>_generat A \\<I> D x y; \\<And>x y. A x y \\<Longrightarrow> A' x y; \\<And>x y. D x y \\<Longrightarrow> D' x y; \\<I> \\<le> \\<I>' \\<rbrakk>\n  \\<Longrightarrow> eq_\\<I>_generat A' \\<I>' D' x y\"", "lemma eq_\\<I>_generat_mono: \"eq_\\<I>_generat A \\<I> D \\<le> eq_\\<I>_generat A' \\<I>' D'\" if \"A \\<le> A'\" \"D \\<le> D'\" \"\\<I> \\<le> \\<I>'\"", "lemma eq_\\<I>_generat_mono'' [mono]:\n  \"\\<lbrakk> \\<And>x y. A x y \\<longrightarrow> A' x y; \\<And>x y. D x y \\<longrightarrow> D' x y \\<rbrakk>\n  \\<Longrightarrow> eq_\\<I>_generat A \\<I> D x y \\<longrightarrow> eq_\\<I>_generat A' \\<I> D' x y\"", "lemma eq_\\<I>_generat_conversep: \"eq_\\<I>_generat A\\<inverse>\\<inverse> \\<I> D\\<inverse>\\<inverse> = (eq_\\<I>_generat A \\<I> D)\\<inverse>\\<inverse>\"", "lemma eq_\\<I>_generat_reflI:\n  assumes  \"\\<And>x. x \\<in> generat_pures generat \\<Longrightarrow> A x x\"\n    and \"\\<And>out c. generat = IO out c \\<Longrightarrow> out \\<in> outs_\\<I> \\<I> \\<and> (\\<forall>input\\<in>responses_\\<I> \\<I> out. D (c input) (c input))\"\n  shows \"eq_\\<I>_generat A \\<I> D generat generat\"", "lemma eq_\\<I>_generat_relcompp:\n  \"eq_\\<I>_generat A \\<I> D OO eq_\\<I>_generat A' \\<I> D' = eq_\\<I>_generat (A OO A') \\<I> (D OO D')\"", "lemma eq_\\<I>_generat_map1:\n  \"eq_\\<I>_generat A \\<I> D (map_generat f id ((\\<circ>) g) generat) generat' \\<longleftrightarrow>\n   eq_\\<I>_generat (\\<lambda>x. A (f x)) \\<I> (\\<lambda>x. D (g x)) generat generat'\"", "lemma eq_\\<I>_generat_map2:\n  \"eq_\\<I>_generat A \\<I> D generat (map_generat f id ((\\<circ>) g) generat') \\<longleftrightarrow>\n   eq_\\<I>_generat (\\<lambda>x y. A x (f y)) \\<I> (\\<lambda>x y. D x (g y)) generat generat'\"", "lemmas eq_\\<I>_generat_map [simp] = \n  eq_\\<I>_generat_map1[abs_def] eq_\\<I>_generat_map2\n  eq_\\<I>_generat_map1[where g=id, unfolded fun.map_id0, abs_def] eq_\\<I>_generat_map2[where g=id, unfolded fun.map_id0]", "lemma eq_\\<I>_generat_into_rel_generat:\n  \"eq_\\<I>_generat A \\<I>_full D generat generat' \\<Longrightarrow> rel_generat A (=) (rel_fun (=) D) generat generat'\"", "lemma eq_\\<I>_gpv_coinduct [consumes 1, case_names eq_\\<I>_gpv, coinduct pred: eq_\\<I>_gpv]:\n  assumes \"X gpv gpv'\"\n    and \"\\<And>gpv gpv'. X gpv gpv'\n      \\<Longrightarrow> rel_spmf (eq_\\<I>_generat A \\<I> (\\<lambda>gpv gpv'. X gpv gpv' \\<or> eq_\\<I>_gpv A \\<I> gpv gpv')) (the_gpv gpv) (the_gpv gpv')\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv'\"", "lemma eq_\\<I>_gpvD:\n  \"eq_\\<I>_gpv A \\<I> gpv gpv' \\<Longrightarrow> rel_spmf (eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>)) (the_gpv gpv) (the_gpv gpv')\"", "lemma eq_\\<I>_gpv_Done [intro!]: \"A x y \\<Longrightarrow> eq_\\<I>_gpv A \\<I> (Done x) (Done y)\"", "lemma eq_\\<I>_gpv_Done_iff [simp]: \"eq_\\<I>_gpv A \\<I> (Done x) (Done y) \\<longleftrightarrow> A x y\"", "lemma eq_\\<I>_gpv_Pause:\n  \"\\<lbrakk> out \\<in> outs_\\<I> \\<I>; \\<And>input. input \\<in> responses_\\<I> \\<I> out \\<Longrightarrow> eq_\\<I>_gpv A \\<I> (rpv input) (rpv' input) \\<rbrakk>\n  \\<Longrightarrow> eq_\\<I>_gpv A \\<I> (Pause out rpv) (Pause out rpv')\"", "lemma eq_\\<I>_gpv_mono: \"eq_\\<I>_gpv A \\<I> \\<le> eq_\\<I>_gpv A' \\<I>'\" if A: \"A \\<le> A'\" \"\\<I> \\<le> \\<I>'\"", "lemma eq_\\<I>_gpv_mono':\n  \"\\<lbrakk> eq_\\<I>_gpv A \\<I> gpv gpv'; \\<And>x y. A x y \\<Longrightarrow> A' x y; \\<I> \\<le> \\<I>' \\<rbrakk> \\<Longrightarrow> eq_\\<I>_gpv A' \\<I>' gpv gpv'\"", "lemma eq_\\<I>_gpv_mono'' [mono]:\n  \"eq_\\<I>_gpv A \\<I> gpv gpv' \\<longrightarrow> eq_\\<I>_gpv A' \\<I> gpv gpv'\" if \"\\<And>x y. A x y \\<longrightarrow> A' x y\"", "lemma eq_\\<I>_gpv_conversep: \"eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> = (eq_\\<I>_gpv A \\<I>)\\<inverse>\\<inverse>\"", "lemma eq_\\<I>_gpv_reflI:\n  \"\\<lbrakk> \\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> A x x; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> eq_\\<I>_gpv A \\<I> gpv gpv\"", "lemma eq_\\<I>_gpv_into_rel_gpv: \"eq_\\<I>_gpv A \\<I>_full gpv gpv' \\<Longrightarrow> rel_gpv A (=) gpv gpv'\"", "lemma eq_\\<I>_gpv_relcompp: \"eq_\\<I>_gpv (A OO A') \\<I> = eq_\\<I>_gpv A \\<I> OO eq_\\<I>_gpv A' \\<I>\" (is \"?lhs = ?rhs\")", "lemma eq_\\<I>_gpv_map_gpv1: \"eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv' \\<longleftrightarrow> eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma eq_\\<I>_gpv_map_gpv2: \"eq_\\<I>_gpv A \\<I> gpv (map_gpv f id gpv') = eq_\\<I>_gpv (\\<lambda>x y. A x (f y)) \\<I> gpv gpv'\"", "lemmas eq_\\<I>_gpv_map_gpv [simp] = eq_\\<I>_gpv_map_gpv1[abs_def] eq_\\<I>_gpv_map_gpv2", "lemma (in callee_invariant_on) eq_\\<I>_exec_gpv:\n  \"\\<lbrakk> eq_\\<I>_gpv A \\<I> gpv gpv'; I s \\<rbrakk> \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I)) (exec_gpv callee gpv s) (exec_gpv callee gpv' s)\"", "lemma eq_\\<I>_gpv_coinduct_bind [consumes 1, case_names eq_\\<I>_gpv]:\n  fixes gpv :: \"('a, 'out, 'in) gpv\" and gpv' :: \"('a', 'out, 'in) gpv\"\n  assumes X: \"X gpv gpv'\"\n    and step: \"\\<And>gpv gpv'. X gpv gpv'\n      \\<Longrightarrow> rel_spmf (eq_\\<I>_generat A \\<I> (\\<lambda>gpv gpv'. X gpv gpv' \\<or> eq_\\<I>_gpv A \\<I> gpv gpv' \\<or> \n      (\\<exists>gpv'' gpv''' (B :: 'b \\<Rightarrow> 'b' \\<Rightarrow> bool) f g. gpv = bind_gpv gpv'' f \\<and> gpv' = bind_gpv gpv''' g \\<and> eq_\\<I>_gpv B \\<I> gpv'' gpv''' \\<and> (rel_fun B X) f g))) (the_gpv gpv) (the_gpv gpv')\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv'\"", "lemma eq_\\<I>_gpv_inline1:\n  includes lifting_syntax\n  assumes \"S s1 s2\" \"eq_\\<I>_gpv A \\<I> gpv1 gpv2\"\n  shows \"rel_spmf (rel_sum (rel_prod A S) \n      (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2'). q = q' \\<and> q' \\<in> outs_\\<I> \\<I>' \\<and> (\\<exists>q'' \\<in> outs_\\<I> \\<I>. \n          (\\<forall>r \\<in> responses_\\<I> \\<I>' q'. eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S) \\<I>' (rpv1 r) (rpv1' r)) \\<and> \n          (\\<forall>r' \\<in> responses_\\<I> \\<I> q''. eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n     (inline1 callee1 gpv1 s1) (inline1 callee2 gpv2 s2)\"", "lemma eq_\\<I>_gpv_inline:\n  assumes S: \"S s1 s2\"\n    and gpv: \"eq_\\<I>_gpv A \\<I> gpv1 gpv2\"\n  shows \"eq_\\<I>_gpv (rel_prod A S) \\<I>' (inline callee1 gpv1 s1) (inline callee2 gpv2 s2)\"", "lemma eq_\\<I>_gpv_left_gpv_cong:\n  \"eq_\\<I>_gpv A \\<I> gpv gpv' \\<Longrightarrow> eq_\\<I>_gpv A (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (left_gpv gpv) (left_gpv gpv')\"", "lemma eq_\\<I>_gpv_right_gpv_cong:\n  \"eq_\\<I>_gpv A \\<I>' gpv gpv' \\<Longrightarrow> eq_\\<I>_gpv A (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (right_gpv gpv) (right_gpv gpv')\"", "lemma eq_\\<I>_gpvD_WT1: \"\\<lbrakk> eq_\\<I>_gpv A \\<I> gpv gpv'; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I> \\<turnstile>g gpv' \\<surd>\"", "lemma eq_\\<I>_gpvD_results_gpv2: \n  assumes \"eq_\\<I>_gpv A \\<I> gpv gpv'\" \"y \\<in> results_gpv \\<I> gpv'\"\n  shows \"\\<exists>x \\<in> results_gpv \\<I> gpv. A x y\"", "lemma eq_\\<I>_converter_coinduct [consumes 1, case_names eq_\\<I>_converter, coinduct pred: eq_\\<I>_converter]:\n  assumes \"X conv conv'\"\n    and \"\\<And>conv conv' q. \\<lbrakk> X conv conv'; q \\<in> outs_\\<I> \\<I> \\<rbrakk>\n     \\<Longrightarrow> eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)) (\\<lambda>conv conv'. X conv conv' \\<or> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv')) \\<I>'\n           (run_converter conv q) (run_converter conv' q)\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\"", "lemma eq_\\<I>_converterD: \n  \"eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)) (eq_\\<I>_converter \\<I> \\<I>')) \\<I>' (run_converter conv q) (run_converter conv' q)\"\n  if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\" \"q \\<in> outs_\\<I> \\<I>\"", "lemma eq_\\<I>_converter_reflI: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv\" if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"", "lemma eq_\\<I>_converter_sym [sym]: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\" if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<sim> conv\"", "lemma eq_\\<I>_converter_trans [trans]:\n  \"\\<lbrakk> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'; \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<sim> conv'' \\<rbrakk> \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv''\"", "lemma eq_\\<I>_converter_mono:\n  assumes *: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<sim> conv'\"\n    and le: \"\\<I>1' \\<le> \\<I>1\" \"\\<I>2 \\<le> \\<I>2'\"\n  shows \"\\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv \\<sim> conv'\"", "lemma eq_\\<I>_converter_eq: \"conv1 = conv2\" if \"\\<I>_full, \\<I>_full \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\"", "lemma eq_\\<I>_attach_on: (* TODO: generalise to eq_resource_on *)\n  assumes \"\\<I>' \\<turnstile>res res \\<surd>\" \"\\<I>_uniform A UNIV, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\"\n  shows \"A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res\"", "lemma eq_\\<I>_attach_on':\n  assumes \"\\<I>' \\<turnstile>res res \\<surd>\" \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\" \"A \\<subseteq> outs_\\<I> \\<I>\"\n  shows \"A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res\"", "lemma eq_\\<I>_attach:\n  \"\\<lbrakk> \\<I>' \\<turnstile>res res \\<surd>; \\<I>_full, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv' \\<rbrakk> \\<Longrightarrow> attach conv res = attach conv' res\"", "lemma eq_\\<I>_comp_cong:\n  \"\\<lbrakk> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'; \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<sim> conv2' \\<rbrakk>\n  \\<Longrightarrow> \\<I>1, \\<I>3 \\<turnstile>\\<^sub>C comp_converter conv1 conv2 \\<sim> comp_converter conv1' conv2'\"", "lemma comp_converter_cong: \"comp_converter conv1 conv2 = comp_converter conv1' conv2'\"\n  if \"\\<I>_full, \\<I> \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'\" \"\\<I>, \\<I>_full \\<turnstile>\\<^sub>C conv2 \\<sim> conv2'\"", "lemma parallel_converter2_id_id: \n  \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>\\<^sub>C parallel_converter2 id_converter id_converter \\<sim> id_converter\"", "lemma parallel_converter2_eq_\\<I>_cong:\n  \"\\<lbrakk> \\<I>1, \\<I>1' \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'; \\<I>2, \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<sim> conv2' \\<rbrakk>\n  \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C parallel_converter2 conv1 conv2 \\<sim> parallel_converter2 conv1' conv2'\"", "lemma id_converter_eq_self: \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C id_converter \\<sim> id_converter\" if \"\\<I> \\<le> \\<I>'\"", "lemma eq_\\<I>_converterD_WT1:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\" and \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\"", "lemma eq_\\<I>_converterD_WT:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<longleftrightarrow> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\"", "lemma eq_\\<I>_gpv_Fail [simp]: \"eq_\\<I>_gpv A \\<I> Fail Fail\"", "lemma eq_\\<I>_restrict_gpv:\n  assumes \"eq_\\<I>_gpv A \\<I> gpv gpv'\"\n  shows \"eq_\\<I>_gpv A \\<I> (restrict_gpv \\<I> gpv) gpv'\"", "lemma eq_\\<I>_restrict_converter:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\"\n    and \"outs_\\<I> \\<I> \\<subseteq> A\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<sim> cnv\"", "lemma eq_\\<I>_restrict_gpv_full:\n  \"eq_\\<I>_gpv A \\<I>_full (restrict_gpv \\<I> gpv) (restrict_gpv \\<I> gpv')\"\n  if \"eq_\\<I>_gpv A \\<I> gpv gpv'\"", "lemma eq_\\<I>_restrict_converter_cong:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim> cnv'\"\n    and \"A \\<subseteq> outs_\\<I> \\<I>\"\n  shows \"restrict_converter A \\<I>' cnv = restrict_converter A \\<I>' cnv'\""], "translations": [["", "lemma eq_resource_on_coinduct [consumes 1, case_names eq_resource_on, coinduct pred: eq_resource_on]:\n  assumes \"X res res'\"\n    and \"\\<And>res res' a. \\<lbrakk> X res res'; a \\<in> A \\<rbrakk>\n      \\<Longrightarrow> rel_spmf (rel_prod (=) (\\<lambda>res res'. X res res' \\<or> A \\<turnstile>\\<^sub>R res \\<sim> res')) (run_resource res a) (run_resource res' a)\"\n  shows \"A \\<turnstile>\\<^sub>R res \\<sim> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res \\<sim> res'", "using assms(1)"], ["proof (prove)\nusing this:\n  X res res'\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res \\<sim> res'", "by(rule eq_resource_on.coinduct)(auto dest: assms(2))"], ["", "lemma eq_resource_onD:\n  assumes \"A \\<turnstile>\\<^sub>R res \\<sim> res'\" \"a \\<in> A\"\n  shows \"rel_spmf (rel_prod (=) (eq_resource_on A)) (run_resource res a) (run_resource res' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) (eq_resource_on A)) (run_resource res a)\n     (run_resource res' a)", "using assms"], ["proof (prove)\nusing this:\n  A \\<turnstile>\\<^sub>R res \\<sim> res'\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) (eq_resource_on A)) (run_resource res a)\n     (run_resource res' a)", "by(auto elim: eq_resource_on.cases)"], ["", "lemma eq_resource_on_refl [simp]: \"A \\<turnstile>\\<^sub>R res \\<sim> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res \\<sim> res", "by(coinduction arbitrary: res)(auto intro: rel_spmf_reflI)"], ["", "lemma eq_resource_on_reflI: \"res = res' \\<Longrightarrow> A \\<turnstile>\\<^sub>R res \\<sim> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res = res' \\<Longrightarrow> A \\<turnstile>\\<^sub>R res \\<sim> res'", "by(simp add: eq_resource_on_refl)"], ["", "lemma eq_resource_on_sym: \"A \\<turnstile>\\<^sub>R res \\<sim> res'\" if \"A \\<turnstile>\\<^sub>R res' \\<sim> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res \\<sim> res'", "using that"], ["proof (prove)\nusing this:\n  A \\<turnstile>\\<^sub>R res' \\<sim> res\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res \\<sim> res'", "by(coinduction arbitrary: res res')\n    (drule (1) eq_resource_onD, rewrite in \"\\<hole>\" conversep_iff[symmetric]\n      , auto simp add: spmf_rel_conversep[symmetric] elim!: rel_spmf_mono)"], ["", "lemma eq_resource_on_trans [trans]: \"A \\<turnstile>\\<^sub>R res \\<sim> res''\" if \"A \\<turnstile>\\<^sub>R res \\<sim> res'\" \"A \\<turnstile>\\<^sub>R res' \\<sim> res''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res \\<sim> res''", "using that"], ["proof (prove)\nusing this:\n  A \\<turnstile>\\<^sub>R res \\<sim> res'\n  A \\<turnstile>\\<^sub>R res' \\<sim> res''\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res \\<sim> res''", "by(coinduction arbitrary: res res' res'')\n    ((drule (1) eq_resource_onD)+, drule (1) rel_spmf_OO_trans, auto elim!:rel_spmf_mono)"], ["", "lemma eq_resource_on_UNIV_D [simp]: \"res = res'\" if \"UNIV \\<turnstile>\\<^sub>R res \\<sim> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res = res'", "using that"], ["proof (prove)\nusing this:\n  UNIV \\<turnstile>\\<^sub>R res \\<sim> res'\n\ngoal (1 subgoal):\n 1. res = res'", "by(coinduction arbitrary: res res')(auto dest: eq_resource_onD)"], ["", "lemma eq_resource_on_UNIV_iff: \"UNIV \\<turnstile>\\<^sub>R res \\<sim> res' \\<longleftrightarrow> res = res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<turnstile>\\<^sub>R res \\<sim> res' = (res = res')", "by(auto dest: eq_resource_on_UNIV_D)"], ["", "lemma eq_resource_on_mono: \"\\<lbrakk> A' \\<turnstile>\\<^sub>R res \\<sim> res'; A \\<subseteq> A' \\<rbrakk> \\<Longrightarrow> A \\<turnstile>\\<^sub>R res \\<sim> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A' \\<turnstile>\\<^sub>R res \\<sim> res';\n     A \\<subseteq> A'\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile>\\<^sub>R res \\<sim> res'", "by(coinduction arbitrary: res res')(auto dest: eq_resource_onD elim!: rel_spmf_mono)"], ["", "lemma eq_resource_on_empty [simp]: \"{} \\<turnstile>\\<^sub>R res \\<sim> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<turnstile>\\<^sub>R res \\<sim> res'", "by(rule eq_resource_onI; simp)"], ["", "lemma eq_resource_on_resource_of_oracleI:\n  includes lifting_syntax \n  fixes S\n  assumes sim: \"(S ===> eq_on A ===> rel_spmf (rel_prod (=) S)) r1 r2\"\n    and S: \"S s1 s2\"\n  shows \"A \\<turnstile>\\<^sub>R resource_of_oracle r1 s1 \\<sim> resource_of_oracle r2 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R resource_of_oracle r1 s1 \\<sim>\n    resource_of_oracle r2 s2", "using S"], ["proof (prove)\nusing this:\n  S s1 s2\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R resource_of_oracle r1 s1 \\<sim>\n    resource_of_oracle r2 s2", "by(coinduction arbitrary: s1 s2)\n    (drule sim[THEN rel_funD, THEN rel_funD], simp add: eq_on_def\n      , fastforce simp add: eq_on_def spmf_rel_map elim: rel_spmf_mono)"], ["", "lemma exec_gpv_eq_resource_on:\n  assumes \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'\"\n    and \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"\\<I> \\<turnstile>res res \\<surd>\"\n  shows \"rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>))) (exec_gpv run_resource gpv res) (exec_gpv run_resource gpv res')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n     (exec_gpv run_resource gpv res) (exec_gpv run_resource gpv res')", "using assms"], ["proof (prove)\nusing this:\n  outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<I> \\<turnstile>res res \\<surd>\n\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n     (exec_gpv run_resource gpv res) (exec_gpv run_resource gpv res')", "proof(induction arbitrary: res res' gpv rule: exec_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            outs_\\<I> \\<I> \\<turnstile>\\<^sub>R x \\<sim>\n            xa \\<longrightarrow>\n            (\\<forall>xb.\n                \\<I> \\<turnstile>g xb \\<surd> \\<longrightarrow>\n                \\<I> \\<turnstile>res x \\<surd> \\<longrightarrow>\n                rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                 (f (xb, x)) (f (xb, xa))))\n 2. \\<And>res res' gpv.\n       \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res';\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                          (return_pmf None) (return_pmf None)\n 3. \\<And>exec_gpv res res' gpv.\n       \\<lbrakk>\\<And>res res' gpv.\n                   \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                            res';\n                    \\<I> \\<turnstile>g gpv \\<surd>;\n                    \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>))) (exec_gpv gpv res)\n(exec_gpv gpv res');\n        outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res';\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, res))\n                            (\\<lambda>out c.\n                                run_resource res out \\<bind>\n                                (\\<lambda>(x, y). exec_gpv (c x) y)))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, res'))\n                            (\\<lambda>out c.\n                                run_resource res' out \\<bind>\n                                (\\<lambda>(x, y). exec_gpv (c x) y)))", "case (step exec_gpv')"], ["proof (state)\nthis:\n  \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R ?res \\<sim> ?res';\n   \\<I> \\<turnstile>g ?gpv \\<surd>;\n   \\<I> \\<turnstile>res ?res \\<surd>\\<rbrakk>\n  \\<Longrightarrow> rel_spmf\n                     (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                     (exec_gpv' ?gpv ?res) (exec_gpv' ?gpv ?res')\n  outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<I> \\<turnstile>res res \\<surd>\n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            outs_\\<I> \\<I> \\<turnstile>\\<^sub>R x \\<sim>\n            xa \\<longrightarrow>\n            (\\<forall>xb.\n                \\<I> \\<turnstile>g xb \\<surd> \\<longrightarrow>\n                \\<I> \\<turnstile>res x \\<surd> \\<longrightarrow>\n                rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                 (f (xb, x)) (f (xb, xa))))\n 2. \\<And>res res' gpv.\n       \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res';\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                          (return_pmf None) (return_pmf None)\n 3. \\<And>exec_gpv res res' gpv.\n       \\<lbrakk>\\<And>res res' gpv.\n                   \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                            res';\n                    \\<I> \\<turnstile>g gpv \\<surd>;\n                    \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>))) (exec_gpv gpv res)\n(exec_gpv gpv res');\n        outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res';\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, res))\n                            (\\<lambda>out c.\n                                run_resource res out \\<bind>\n                                (\\<lambda>(x, y). exec_gpv (c x) y)))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, res'))\n                            (\\<lambda>out c.\n                                run_resource res' out \\<bind>\n                                (\\<lambda>(x, y). exec_gpv (c x) y)))", "have[simp]: \"\\<lbrakk>(s, r1) \\<in> set_spmf (run_resource res g1); (s, r2) \\<in> set_spmf (run_resource res' g1);\n    IO g1 g2 \\<in> set_spmf (the_gpv gpv); outs_\\<I> \\<I> \\<turnstile>\\<^sub>R r1 \\<sim> r2\\<rbrakk> \\<Longrightarrow> rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>))) \n        (exec_gpv' (g2 s) r1) (exec_gpv' (g2 s) r2)\" for g1 g2 r1 s r2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, r1) \\<in> set_spmf (run_resource res g1);\n     (s, r2) \\<in> set_spmf (run_resource res' g1);\n     IO g1 g2 \\<in> set_spmf (the_gpv gpv);\n     outs_\\<I> \\<I> \\<turnstile>\\<^sub>R r1 \\<sim> r2\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                       (exec_gpv' (g2 s) r1) (exec_gpv' (g2 s) r2)", "by(rule step.IH, simp, rule WT_gpv_ContD[OF step.prems(2)], assumption)\n      (auto elim: outs_gpv.IO WT_calleeD[OF run_resource.WT_callee, OF step.prems(3)]\n        dest!: WT_resourceD[OF step.prems(3), rotated 1] intro: WT_gpv_outs_gpv[THEN subsetD, OF step.prems(2)])"], ["proof (state)\nthis:\n  \\<lbrakk>(?s, ?r1.0) \\<in> set_spmf (run_resource res ?g1.0);\n   (?s, ?r2.0) \\<in> set_spmf (run_resource res' ?g1.0);\n   IO ?g1.0 ?g2.0 \\<in> set_spmf (the_gpv gpv);\n   outs_\\<I> \\<I> \\<turnstile>\\<^sub>R ?r1.0 \\<sim> ?r2.0\\<rbrakk>\n  \\<Longrightarrow> rel_spmf\n                     (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                     (exec_gpv' (?g2.0 ?s) ?r1.0)\n                     (exec_gpv' (?g2.0 ?s) ?r2.0)\n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            outs_\\<I> \\<I> \\<turnstile>\\<^sub>R x \\<sim>\n            xa \\<longrightarrow>\n            (\\<forall>xb.\n                \\<I> \\<turnstile>g xb \\<surd> \\<longrightarrow>\n                \\<I> \\<turnstile>res x \\<surd> \\<longrightarrow>\n                rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                 (f (xb, x)) (f (xb, xa))))\n 2. \\<And>res res' gpv.\n       \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res';\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                          (return_pmf None) (return_pmf None)\n 3. \\<And>exec_gpv res res' gpv.\n       \\<lbrakk>\\<And>res res' gpv.\n                   \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                            res';\n                    \\<I> \\<turnstile>g gpv \\<surd>;\n                    \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>))) (exec_gpv gpv res)\n(exec_gpv gpv res');\n        outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res';\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, res))\n                            (\\<lambda>out c.\n                                run_resource res out \\<bind>\n                                (\\<lambda>(x, y). exec_gpv (c x) y)))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, res'))\n                            (\\<lambda>out c.\n                                run_resource res' out \\<bind>\n                                (\\<lambda>(x, y). exec_gpv (c x) y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n     (the_gpv gpv \\<bind>\n      case_generat (\\<lambda>x. return_spmf (x, res))\n       (\\<lambda>out c.\n           run_resource res out \\<bind>\n           (\\<lambda>(x, y). exec_gpv' (c x) y)))\n     (the_gpv gpv \\<bind>\n      case_generat (\\<lambda>x. return_spmf (x, res'))\n       (\\<lambda>out c.\n           run_resource res' out \\<bind>\n           (\\<lambda>(x, y). exec_gpv' (c x) y)))", "by(clarsimp intro!: rel_spmf_bind_reflI step.prems split!: generat.split)\n      (rule rel_spmf_bindI', rule eq_resource_onD[OF step.prems(1)]\n        , auto elim: outs_gpv.IO intro:  eq_resource_onD[OF step.prems(1)] WT_gpv_outs_gpv[THEN subsetD, OF step.prems(2)])"], ["proof (state)\nthis:\n  rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n   (the_gpv gpv \\<bind>\n    case_generat (\\<lambda>x. return_spmf (x, res))\n     (\\<lambda>out c.\n         run_resource res out \\<bind> (\\<lambda>(x, y). exec_gpv' (c x) y)))\n   (the_gpv gpv \\<bind>\n    case_generat (\\<lambda>x. return_spmf (x, res'))\n     (\\<lambda>out c.\n         run_resource res' out \\<bind>\n         (\\<lambda>(x, y). exec_gpv' (c x) y)))\n\ngoal (2 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            outs_\\<I> \\<I> \\<turnstile>\\<^sub>R x \\<sim>\n            xa \\<longrightarrow>\n            (\\<forall>xb.\n                \\<I> \\<turnstile>g xb \\<surd> \\<longrightarrow>\n                \\<I> \\<turnstile>res x \\<surd> \\<longrightarrow>\n                rel_spmf (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                 (f (xb, x)) (f (xb, xa))))\n 2. \\<And>res res' gpv.\n       \\<lbrakk>outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res';\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        \\<I> \\<turnstile>res res \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=) (eq_resource_on (outs_\\<I> \\<I>)))\n                          (return_pmf None) (return_pmf None)", "qed simp_all"], ["", "inductive eq_\\<I>_generat :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('out, 'in) \\<I> \\<Rightarrow> ('c \\<Rightarrow> 'd \\<Rightarrow> bool) \\<Rightarrow> ('a, 'out, 'in \\<Rightarrow> 'c) generat \\<Rightarrow> ('b, 'out, 'in \\<Rightarrow> 'd) generat \\<Rightarrow> bool\"\n  for A \\<I> D where\n    Pure: \"eq_\\<I>_generat A \\<I> D (Pure x) (Pure y)\" if \"A x y\"\n  | IO: \"eq_\\<I>_generat A \\<I> D (IO out c) (IO out c')\" if \"out \\<in> outs_\\<I> \\<I>\" \"\\<And>input. input \\<in> responses_\\<I> \\<I> out \\<Longrightarrow> D (c input) (c' input)\""], ["", "hide_fact (open) Pure IO"], ["", "inductive_simps eq_\\<I>_generat_simps [simp, code]:\n  \"eq_\\<I>_generat A \\<I> D (Pure x) (Pure y)\"\n  \"eq_\\<I>_generat A \\<I> D (IO out c) (Pure y)\"\n  \"eq_\\<I>_generat A \\<I> D (Pure x) (IO out' c')\"\n  \"eq_\\<I>_generat A \\<I> D (IO out c) (IO out' c')\""], ["", "inductive_simps eq_\\<I>_generat_iff1:\n  \"eq_\\<I>_generat A \\<I> D (Pure x) g'\"\n  \"eq_\\<I>_generat A \\<I> D (IO out c) g'\""], ["", "inductive_simps eq_\\<I>_generat_iff2:\n  \"eq_\\<I>_generat A \\<I> D g (Pure x)\"\n  \"eq_\\<I>_generat A \\<I> D g (IO out c)\""], ["", "lemma eq_\\<I>_generat_mono':\n  \"\\<lbrakk> eq_\\<I>_generat A \\<I> D x y; \\<And>x y. A x y \\<Longrightarrow> A' x y; \\<And>x y. D x y \\<Longrightarrow> D' x y; \\<I> \\<le> \\<I>' \\<rbrakk>\n  \\<Longrightarrow> eq_\\<I>_generat A' \\<I>' D' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_generat A \\<I> D x y;\n     \\<And>x y. A x y \\<Longrightarrow> A' x y;\n     \\<And>x y. D x y \\<Longrightarrow> D' x y; \\<I> \\<le> \\<I>'\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat A' \\<I>' D' x y", "by(auto 4 4 elim!: eq_\\<I>_generat.cases simp add: le_\\<I>_def)"], ["", "lemma eq_\\<I>_generat_mono: \"eq_\\<I>_generat A \\<I> D \\<le> eq_\\<I>_generat A' \\<I>' D'\" if \"A \\<le> A'\" \"D \\<le> D'\" \"\\<I> \\<le> \\<I>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I> D \\<le> eq_\\<I>_generat A' \\<I>' D'", "using that"], ["proof (prove)\nusing this:\n  A \\<le> A'\n  D \\<le> D'\n  \\<I> \\<le> \\<I>'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I> D \\<le> eq_\\<I>_generat A' \\<I>' D'", "by(auto elim!: eq_\\<I>_generat_mono' dest: predicate2D)"], ["", "lemma eq_\\<I>_generat_mono'' [mono]:\n  \"\\<lbrakk> \\<And>x y. A x y \\<longrightarrow> A' x y; \\<And>x y. D x y \\<longrightarrow> D' x y \\<rbrakk>\n  \\<Longrightarrow> eq_\\<I>_generat A \\<I> D x y \\<longrightarrow> eq_\\<I>_generat A' \\<I> D' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. A x y \\<longrightarrow> A' x y;\n     \\<And>x y. D x y \\<longrightarrow> D' x y\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat A \\<I> D x y \\<longrightarrow>\n                      eq_\\<I>_generat A' \\<I> D' x y", "by(auto elim: eq_\\<I>_generat_mono')"], ["", "lemma eq_\\<I>_generat_conversep: \"eq_\\<I>_generat A\\<inverse>\\<inverse> \\<I> D\\<inverse>\\<inverse> = (eq_\\<I>_generat A \\<I> D)\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A\\<inverse>\\<inverse> \\<I> D\\<inverse>\\<inverse> =\n    (eq_\\<I>_generat A \\<I> D)\\<inverse>\\<inverse>", "by(fastforce elim: eq_\\<I>_generat.cases)"], ["", "lemma eq_\\<I>_generat_reflI:\n  assumes  \"\\<And>x. x \\<in> generat_pures generat \\<Longrightarrow> A x x\"\n    and \"\\<And>out c. generat = IO out c \\<Longrightarrow> out \\<in> outs_\\<I> \\<I> \\<and> (\\<forall>input\\<in>responses_\\<I> \\<I> out. D (c input) (c input))\"\n  shows \"eq_\\<I>_generat A \\<I> D generat generat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I> D generat generat", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> generat_pures generat \\<Longrightarrow> A ?x ?x\n  generat = IO ?out ?c \\<Longrightarrow>\n  ?out \\<in> outs_\\<I> \\<I> \\<and>\n  (\\<forall>input\\<in>responses_\\<I> \\<I> ?out. D (?c input) (?c input))\n\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I> D generat generat", "by(cases generat) auto"], ["", "lemma eq_\\<I>_generat_relcompp:\n  \"eq_\\<I>_generat A \\<I> D OO eq_\\<I>_generat A' \\<I> D' = eq_\\<I>_generat (A OO A') \\<I> (D OO D')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I> D OO eq_\\<I>_generat A' \\<I> D' =\n    eq_\\<I>_generat (A OO A') \\<I> (D OO D')", "by(auto 4 3 intro!: ext elim!: eq_\\<I>_generat.cases simp add: eq_\\<I>_generat_iff1 eq_\\<I>_generat_iff2 relcompp.simps) metis"], ["", "lemma eq_\\<I>_generat_map1:\n  \"eq_\\<I>_generat A \\<I> D (map_generat f id ((\\<circ>) g) generat) generat' \\<longleftrightarrow>\n   eq_\\<I>_generat (\\<lambda>x. A (f x)) \\<I> (\\<lambda>x. D (g x)) generat generat'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I> D (map_generat f id ((\\<circ>) g) generat)\n     generat' =\n    eq_\\<I>_generat (\\<lambda>x. A (f x)) \\<I> (\\<lambda>x. D (g x)) generat\n     generat'", "by(cases generat; cases generat') auto"], ["", "lemma eq_\\<I>_generat_map2:\n  \"eq_\\<I>_generat A \\<I> D generat (map_generat f id ((\\<circ>) g) generat') \\<longleftrightarrow>\n   eq_\\<I>_generat (\\<lambda>x y. A x (f y)) \\<I> (\\<lambda>x y. D x (g y)) generat generat'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I> D generat\n     (map_generat f id ((\\<circ>) g) generat') =\n    eq_\\<I>_generat (\\<lambda>x y. A x (f y)) \\<I> (\\<lambda>x y. D x (g y))\n     generat generat'", "by(cases generat; cases generat') auto"], ["", "lemmas eq_\\<I>_generat_map [simp] = \n  eq_\\<I>_generat_map1[abs_def] eq_\\<I>_generat_map2\n  eq_\\<I>_generat_map1[where g=id, unfolded fun.map_id0, abs_def] eq_\\<I>_generat_map2[where g=id, unfolded fun.map_id0]"], ["", "lemma eq_\\<I>_generat_into_rel_generat:\n  \"eq_\\<I>_generat A \\<I>_full D generat generat' \\<Longrightarrow> rel_generat A (=) (rel_fun (=) D) generat generat'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_generat A \\<I>_full D generat generat' \\<Longrightarrow>\n    rel_generat A (=) (rel_fun (=) D) generat generat'", "by(erule eq_\\<I>_generat.cases) auto"], ["", "coinductive eq_\\<I>_gpv :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('out, 'in) \\<I> \\<Rightarrow> ('a, 'out, 'in) gpv \\<Rightarrow> ('b, 'out, 'in) gpv \\<Rightarrow> bool\"\n  for A \\<I> where\n    eq_\\<I>_gpvI: \"eq_\\<I>_gpv A \\<I> gpv gpv'\" \n  if \"rel_spmf (eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>)) (the_gpv gpv) (the_gpv gpv')\""], ["", "lemma eq_\\<I>_gpv_coinduct [consumes 1, case_names eq_\\<I>_gpv, coinduct pred: eq_\\<I>_gpv]:\n  assumes \"X gpv gpv'\"\n    and \"\\<And>gpv gpv'. X gpv gpv'\n      \\<Longrightarrow> rel_spmf (eq_\\<I>_generat A \\<I> (\\<lambda>gpv gpv'. X gpv gpv' \\<or> eq_\\<I>_gpv A \\<I> gpv gpv')) (the_gpv gpv) (the_gpv gpv')\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "using assms(1)"], ["proof (prove)\nusing this:\n  X gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "by(rule eq_\\<I>_gpv.coinduct)(blast dest: assms(2))"], ["", "lemma eq_\\<I>_gpvD:\n  \"eq_\\<I>_gpv A \\<I> gpv gpv' \\<Longrightarrow> rel_spmf (eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>)) (the_gpv gpv) (the_gpv gpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv' \\<Longrightarrow>\n    rel_spmf (eq_\\<I>_generat A \\<I> (eq_\\<I>_gpv A \\<I>)) (the_gpv gpv)\n     (the_gpv gpv')", "by(blast elim!: eq_\\<I>_gpv.cases)"], ["", "lemma eq_\\<I>_gpv_Done [intro!]: \"A x y \\<Longrightarrow> eq_\\<I>_gpv A \\<I> (Done x) (Done y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A x y \\<Longrightarrow>\n    eq_\\<I>_gpv A \\<I> (Generative_Probabilistic_Value.Done x)\n     (Generative_Probabilistic_Value.Done y)", "by(rule eq_\\<I>_gpvI) simp"], ["", "lemma eq_\\<I>_gpv_Done_iff [simp]: \"eq_\\<I>_gpv A \\<I> (Done x) (Done y) \\<longleftrightarrow> A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (Generative_Probabilistic_Value.Done x)\n     (Generative_Probabilistic_Value.Done y) =\n    A x y", "by(auto dest: eq_\\<I>_gpvD)"], ["", "lemma eq_\\<I>_gpv_Pause:\n  \"\\<lbrakk> out \\<in> outs_\\<I> \\<I>; \\<And>input. input \\<in> responses_\\<I> \\<I> out \\<Longrightarrow> eq_\\<I>_gpv A \\<I> (rpv input) (rpv' input) \\<rbrakk>\n  \\<Longrightarrow> eq_\\<I>_gpv A \\<I> (Pause out rpv) (Pause out rpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>out \\<in> outs_\\<I> \\<I>;\n     \\<And>input.\n        input \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n        eq_\\<I>_gpv A \\<I> (rpv input) (rpv' input)\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv A \\<I>\n                       (Generative_Probabilistic_Value.Pause out rpv)\n                       (Generative_Probabilistic_Value.Pause out rpv')", "by(rule eq_\\<I>_gpvI) simp"], ["", "lemma eq_\\<I>_gpv_mono: \"eq_\\<I>_gpv A \\<I> \\<le> eq_\\<I>_gpv A' \\<I>'\" if A: \"A \\<le> A'\" \"\\<I> \\<le> \\<I>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> \\<le> eq_\\<I>_gpv A' \\<I>'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       eq_\\<I>_gpv A \\<I> x y \\<Longrightarrow> eq_\\<I>_gpv A' \\<I>' x y", "show \"eq_\\<I>_gpv A' \\<I>' gpv gpv'\" if \"eq_\\<I>_gpv A \\<I> gpv gpv'\" for gpv gpv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A' \\<I>' gpv gpv'", "using that"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A' \\<I>' gpv gpv'", "by(coinduction arbitrary: gpv gpv')\n      (drule eq_\\<I>_gpvD, auto dest: eq_\\<I>_gpvD elim: rel_spmf_mono eq_\\<I>_generat_mono[OF A(1) _ A(2), THEN predicate2D, rotated -1])"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A \\<I> ?gpv ?gpv' \\<Longrightarrow>\n  eq_\\<I>_gpv A' \\<I>' ?gpv ?gpv'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_gpv_mono':\n  \"\\<lbrakk> eq_\\<I>_gpv A \\<I> gpv gpv'; \\<And>x y. A x y \\<Longrightarrow> A' x y; \\<I> \\<le> \\<I>' \\<rbrakk> \\<Longrightarrow> eq_\\<I>_gpv A' \\<I>' gpv gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv';\n     \\<And>x y. A x y \\<Longrightarrow> A' x y; \\<I> \\<le> \\<I>'\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv A' \\<I>' gpv gpv'", "by(blast intro: eq_\\<I>_gpv_mono[THEN predicate2D])"], ["", "lemma eq_\\<I>_gpv_mono'' [mono]:\n  \"eq_\\<I>_gpv A \\<I> gpv gpv' \\<longrightarrow> eq_\\<I>_gpv A' \\<I> gpv gpv'\" if \"\\<And>x y. A x y \\<longrightarrow> A' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv' \\<longrightarrow>\n    eq_\\<I>_gpv A' \\<I> gpv gpv'", "using that"], ["proof (prove)\nusing this:\n  A ?x ?y \\<longrightarrow> A' ?x ?y\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv' \\<longrightarrow>\n    eq_\\<I>_gpv A' \\<I> gpv gpv'", "by(blast intro: eq_\\<I>_gpv_mono')"], ["", "lemma eq_\\<I>_gpv_conversep: \"eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> = (eq_\\<I>_gpv A \\<I>)\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> =\n    (eq_\\<I>_gpv A \\<I>)\\<inverse>\\<inverse>", "proof(intro ext iffI; simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A \\<I> xa x\n 2. \\<And>x xa.\n       eq_\\<I>_gpv A \\<I> xa x \\<Longrightarrow>\n       eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> x xa", "show \"eq_\\<I>_gpv A \\<I> gpv gpv'\" if \"eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> gpv' gpv\" for A and gpv gpv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "using that"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> gpv' gpv\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "by(coinduction arbitrary: gpv gpv')\n      (drule eq_\\<I>_gpvD, rewrite in \\<hole> conversep_iff[symmetric]\n        , auto simp add: pmf.rel_conversep[symmetric] option.rel_conversep[symmetric] eq_\\<I>_generat_conversep[symmetric] elim: eq_\\<I>_generat_mono' rel_spmf_mono)"], ["proof (state)\nthis:\n  eq_\\<I>_gpv ?A1\\<inverse>\\<inverse> \\<I> ?gpv'1 ?gpv1 \\<Longrightarrow>\n  eq_\\<I>_gpv ?A1 \\<I> ?gpv1 ?gpv'1\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv A \\<I> xa x \\<Longrightarrow>\n       eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> x xa", "from this[of \"conversep A\"]"], ["proof (chain)\npicking this:\n  eq_\\<I>_gpv A\\<inverse>\\<inverse>\\<inverse>\\<inverse> \\<I> ?gpv'1\n   ?gpv1 \\<Longrightarrow>\n  eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> ?gpv1 ?gpv'1", "show \"eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> gpv' gpv\" if \"eq_\\<I>_gpv A \\<I> gpv gpv'\" for gpv gpv'"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A\\<inverse>\\<inverse>\\<inverse>\\<inverse> \\<I> ?gpv'1\n   ?gpv1 \\<Longrightarrow>\n  eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> ?gpv1 ?gpv'1\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> gpv' gpv", "using that"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A\\<inverse>\\<inverse>\\<inverse>\\<inverse> \\<I> ?gpv'1\n   ?gpv1 \\<Longrightarrow>\n  eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> ?gpv1 ?gpv'1\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> gpv' gpv", "by simp"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A \\<I> ?gpv1 ?gpv'1 \\<Longrightarrow>\n  eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> ?gpv'1 ?gpv1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_gpv_reflI:\n  \"\\<lbrakk> \\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> A x x; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> eq_\\<I>_gpv A \\<I> gpv gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> A x x;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv A \\<I> gpv gpv", "by(coinduction arbitrary: gpv)(auto intro!: rel_spmf_reflI eq_\\<I>_generat_reflI elim!: generat.set_cases intro: results_gpv.intros dest: WT_gpvD)"], ["", "lemma eq_\\<I>_gpv_into_rel_gpv: \"eq_\\<I>_gpv A \\<I>_full gpv gpv' \\<Longrightarrow> rel_gpv A (=) gpv gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I>_full gpv gpv' \\<Longrightarrow>\n    rel_gpv A (=) gpv gpv'", "by(coinduction arbitrary: gpv gpv')\n    (drule eq_\\<I>_gpvD, auto elim: spmf_rel_mono_strong generat.rel_mono_strong dest: eq_\\<I>_generat_into_rel_generat )"], ["", "lemma eq_\\<I>_gpv_relcompp: \"eq_\\<I>_gpv (A OO A') \\<I> = eq_\\<I>_gpv A \\<I> OO eq_\\<I>_gpv A' \\<I>\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (A OO A') \\<I> = eq_\\<I>_gpv A \\<I> OO eq_\\<I>_gpv A' \\<I>", "proof(intro ext iffI relcomppI; (elim relcomppE)?)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A \\<I> x (?b4 x xa)\n 2. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A' \\<I> (?b4 x xa) xa\n 3. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "fix gpv gpv''"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A \\<I> x (?b4 x xa)\n 2. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A' \\<I> (?b4 x xa) xa\n 3. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "assume *: \"?lhs gpv gpv''\""], ["proof (state)\nthis:\n  eq_\\<I>_gpv (A OO A') \\<I> gpv gpv''\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A \\<I> x (?b4 x xa)\n 2. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A' \\<I> (?b4 x xa) xa\n 3. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "define middle where \"middle = corec_gpv (\\<lambda>(gpv, gpv'').\n    map_spmf (map_generat (relcompp_witness A A') (relcompp_witness (=) (=)) ((\\<circ>) Inr \\<circ> rel_witness_fun (=) (=)) \\<circ> \n              rel_witness_generat)\n    (rel_witness_spmf (eq_\\<I>_generat (A OO A') \\<I> (eq_\\<I>_gpv (A OO A') \\<I>)) (the_gpv gpv, the_gpv gpv'')))\""], ["proof (state)\nthis:\n  middle =\n  corec_gpv\n   (\\<lambda>(gpv, gpv'').\n       map_spmf\n        (map_generat (relcompp_witness A A') (relcompp_witness (=) (=))\n          ((\\<circ>) Inr \\<circ> rel_witness_fun (=) (=)) \\<circ>\n         rel_witness_generat)\n        (rel_witness_spmf\n          (eq_\\<I>_generat (A OO A') \\<I> (eq_\\<I>_gpv (A OO A') \\<I>))\n          (the_gpv gpv, the_gpv gpv'')))\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A \\<I> x (?b4 x xa)\n 2. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A' \\<I> (?b4 x xa) xa\n 3. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "have middle_sel [simp]: \"the_gpv (middle (gpv, gpv'')) = \n     map_spmf (map_generat (relcompp_witness A A') (relcompp_witness (=) (=)) ((\\<circ>) middle \\<circ> rel_witness_fun (=) (=)) \\<circ> \n              rel_witness_generat)\n    (rel_witness_spmf (eq_\\<I>_generat (A OO A') \\<I> (eq_\\<I>_gpv (A OO A') \\<I>)) (the_gpv gpv, the_gpv gpv''))\"\n    for gpv gpv''"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_gpv (middle (gpv, gpv'')) =\n    map_spmf\n     (map_generat (relcompp_witness A A') (relcompp_witness (=) (=))\n       ((\\<circ>) middle \\<circ> rel_witness_fun (=) (=)) \\<circ>\n      rel_witness_generat)\n     (rel_witness_spmf\n       (eq_\\<I>_generat (A OO A') \\<I> (eq_\\<I>_gpv (A OO A') \\<I>))\n       (the_gpv gpv, the_gpv gpv''))", "by(auto simp add: middle_def spmf.map_comp o_def generat.map_comp)"], ["proof (state)\nthis:\n  the_gpv (middle (?gpv, ?gpv'')) =\n  map_spmf\n   (map_generat (relcompp_witness A A') (relcompp_witness (=) (=))\n     ((\\<circ>) middle \\<circ> rel_witness_fun (=) (=)) \\<circ>\n    rel_witness_generat)\n   (rel_witness_spmf\n     (eq_\\<I>_generat (A OO A') \\<I> (eq_\\<I>_gpv (A OO A') \\<I>))\n     (the_gpv ?gpv, the_gpv ?gpv''))\n\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A \\<I> x (?b4 x xa)\n 2. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A' \\<I> (?b4 x xa) xa\n 3. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "show \"eq_\\<I>_gpv A \\<I> gpv (middle (gpv, gpv''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv (middle (gpv, gpv''))", "using *"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv (A OO A') \\<I> gpv gpv''\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv (middle (gpv, gpv''))", "by(coinduction arbitrary: gpv gpv'')\n      (drule eq_\\<I>_gpvD, simp add: spmf_rel_map, erule rel_witness_spmf1[THEN rel_spmf_mono]\n        , auto 4 3 del: relcomppE elim!: relcompp_witness eq_\\<I>_generat.cases)"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A \\<I> gpv (middle (gpv, gpv''))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       eq_\\<I>_gpv (A OO A') \\<I> x xa \\<Longrightarrow>\n       eq_\\<I>_gpv A' \\<I>\n        (corec_gpv\n          (\\<lambda>(gpv, gpv'').\n              map_spmf\n               (map_generat (relcompp_witness A A')\n                 (relcompp_witness (=) (=))\n                 ((\\<circ>) Inr \\<circ> rel_witness_fun (=) (=)) \\<circ>\n                rel_witness_generat)\n               (rel_witness_spmf\n                 (eq_\\<I>_generat (A OO A') \\<I>\n                   (eq_\\<I>_gpv (A OO A') \\<I>))\n                 (the_gpv gpv, the_gpv gpv'')))\n          (x, xa))\n        xa\n 2. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "show \"eq_\\<I>_gpv A' \\<I> (middle (gpv, gpv'')) gpv''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A' \\<I> (middle (gpv, gpv'')) gpv''", "using *"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv (A OO A') \\<I> gpv gpv''\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A' \\<I> (middle (gpv, gpv'')) gpv''", "by(coinduction arbitrary: gpv gpv'')\n      (drule eq_\\<I>_gpvD, simp add: spmf_rel_map, erule rel_witness_spmf2[THEN rel_spmf_mono]\n        , auto 4 3 del: relcomppE elim: rel_witness_spmf2[THEN rel_spmf_mono] elim!: relcompp_witness eq_\\<I>_generat.cases)"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A' \\<I> (middle (gpv, gpv'')) gpv''\n\ngoal (1 subgoal):\n 1. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa b.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> x b; eq_\\<I>_gpv A' \\<I> b xa\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> x xa", "show \"?lhs gpv gpv''\" if \"eq_\\<I>_gpv A \\<I> gpv gpv'\" and \"eq_\\<I>_gpv A' \\<I> gpv' gpv''\" for gpv gpv' gpv''"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (A OO A') \\<I> gpv gpv''", "using that"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n  eq_\\<I>_gpv A' \\<I> gpv' gpv''\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (A OO A') \\<I> gpv gpv''", "by(coinduction arbitrary: gpv gpv' gpv'')\n      ((drule eq_\\<I>_gpvD)+, simp, drule (1) rel_spmf_OO_trans, erule rel_spmf_mono\n        , auto simp add: eq_\\<I>_generat_relcompp elim: eq_\\<I>_generat_mono')"], ["proof (state)\nthis:\n  \\<lbrakk>eq_\\<I>_gpv A \\<I> ?gpv ?gpv';\n   eq_\\<I>_gpv A' \\<I> ?gpv' ?gpv''\\<rbrakk>\n  \\<Longrightarrow> eq_\\<I>_gpv (A OO A') \\<I> ?gpv ?gpv''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_gpv_map_gpv1: \"eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv' \\<longleftrightarrow> eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv' =\n    eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv' \\<Longrightarrow>\n    eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'\n 2. eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv' \\<Longrightarrow>\n    eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv'", "show ?rhs if ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'", "using that"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'", "by(coinduction arbitrary: gpv gpv')\n      (drule eq_\\<I>_gpvD, auto simp add: gpv.map_sel spmf_rel_map elim!: rel_spmf_mono eq_\\<I>_generat_mono')"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv' \\<Longrightarrow>\n  eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv' \\<Longrightarrow>\n    eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv'", "show ?lhs if ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv'", "using that"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv'", "by(coinduction arbitrary: gpv gpv')\n      (drule eq_\\<I>_gpvD, auto simp add: gpv.map_sel spmf_rel_map elim!: rel_spmf_mono eq_\\<I>_generat_mono')"], ["proof (state)\nthis:\n  eq_\\<I>_gpv (\\<lambda>x. A (f x)) \\<I> gpv gpv' \\<Longrightarrow>\n  eq_\\<I>_gpv A \\<I> (map_gpv f id gpv) gpv'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_gpv_map_gpv2: \"eq_\\<I>_gpv A \\<I> gpv (map_gpv f id gpv') = eq_\\<I>_gpv (\\<lambda>x y. A x (f y)) \\<I> gpv gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv (map_gpv f id gpv') =\n    eq_\\<I>_gpv (\\<lambda>x y. A x (f y)) \\<I> gpv gpv'", "using eq_\\<I>_gpv_map_gpv1[of \"conversep A\" \\<I> f gpv' gpv]"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A\\<inverse>\\<inverse> \\<I> (map_gpv f id gpv') gpv =\n  eq_\\<I>_gpv (\\<lambda>x. A\\<inverse>\\<inverse> (f x)) \\<I> gpv' gpv\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv (map_gpv f id gpv') =\n    eq_\\<I>_gpv (\\<lambda>x y. A x (f y)) \\<I> gpv gpv'", "by(rewrite in \"_ = \\<hole>\" conversep_iff[symmetric] , simp add: eq_\\<I>_gpv_conversep[symmetric])\n    (subst (asm) eq_\\<I>_gpv_conversep , simp add: conversep_iff[abs_def])"], ["", "lemmas eq_\\<I>_gpv_map_gpv [simp] = eq_\\<I>_gpv_map_gpv1[abs_def] eq_\\<I>_gpv_map_gpv2"], ["", "lemma (in callee_invariant_on) eq_\\<I>_exec_gpv:\n  \"\\<lbrakk> eq_\\<I>_gpv A \\<I> gpv gpv'; I s \\<rbrakk> \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I)) (exec_gpv callee gpv s) (exec_gpv callee gpv' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n    \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n                       (exec_gpv callee gpv s) (exec_gpv callee gpv' s)", "proof(induction arbitrary: s gpv gpv' rule: parallel_fixp_induct_2_2[OF partial_function_definitions_spmf partial_function_definitions_spmf exec_gpv.mono exec_gpv.mono exec_gpv_def exec_gpv_def, unfolded lub_spmf_empty, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc.\n            eq_\\<I>_gpv A \\<I> xb xc \\<longrightarrow>\n            I xa \\<longrightarrow>\n            rel_spmf (rel_prod A (eq_onp I)) (curry (fst x) xb xa)\n             (curry (snd x) xc xa))\n 2. \\<And>s gpv gpv'.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I)) (return_pmf None)\n                          (return_pmf None)\n 3. \\<And>f g s gpv gpv'.\n       \\<lbrakk>\\<And>s gpv gpv'.\n                   \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n(f gpv s) (g gpv' s);\n        eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). f (c x) y)))\n                          (the_gpv gpv' \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). g (c x) y)))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc.\n            eq_\\<I>_gpv A \\<I> xb xc \\<longrightarrow>\n            I xa \\<longrightarrow>\n            rel_spmf (rel_prod A (eq_onp I)) (curry (fst x) xb xa)\n             (curry (snd x) xc xa))\n 2. \\<And>s gpv gpv'.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I)) (return_pmf None)\n                          (return_pmf None)\n 3. \\<And>f g s gpv gpv'.\n       \\<lbrakk>\\<And>s gpv gpv'.\n                   \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n(f gpv s) (g gpv' s);\n        eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). f (c x) y)))\n                          (the_gpv gpv' \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). g (c x) y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc.\n            eq_\\<I>_gpv A \\<I> xb xc \\<longrightarrow>\n            I xa \\<longrightarrow>\n            rel_spmf (rel_prod A (eq_onp I)) (curry (fst x) xb xa)\n             (curry (snd x) xc xa))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xb xc.\n          eq_\\<I>_gpv A \\<I> xb xc \\<longrightarrow>\n          I xa \\<longrightarrow>\n          rel_spmf (rel_prod A (eq_onp I)) (curry (fst x) xb xa)\n           (curry (snd x) xc xa))\n\ngoal (2 subgoals):\n 1. \\<And>s gpv gpv'.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I)) (return_pmf None)\n                          (return_pmf None)\n 2. \\<And>f g s gpv gpv'.\n       \\<lbrakk>\\<And>s gpv gpv'.\n                   \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n(f gpv s) (g gpv' s);\n        eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). f (c x) y)))\n                          (the_gpv gpv' \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). g (c x) y)))", "case bottom"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>s gpv gpv'.\n       \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I)) (return_pmf None)\n                          (return_pmf None)\n 2. \\<And>f g s gpv gpv'.\n       \\<lbrakk>\\<And>s gpv gpv'.\n                   \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n(f gpv s) (g gpv' s);\n        eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). f (c x) y)))\n                          (the_gpv gpv' \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). g (c x) y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod A (eq_onp I)) (return_pmf None) (return_pmf None)", "by simp"], ["proof (state)\nthis:\n  rel_spmf (rel_prod A (eq_onp I)) (return_pmf None) (return_pmf None)\n\ngoal (1 subgoal):\n 1. \\<And>f g s gpv gpv'.\n       \\<lbrakk>\\<And>s gpv gpv'.\n                   \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n(f gpv s) (g gpv' s);\n        eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). f (c x) y)))\n                          (the_gpv gpv' \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). g (c x) y)))", "case (step exec_gpv' exec_gpv'')"], ["proof (state)\nthis:\n  \\<lbrakk>eq_\\<I>_gpv A \\<I> ?gpv ?gpv'; I ?s\\<rbrakk>\n  \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I)) (exec_gpv' ?gpv ?s)\n                     (exec_gpv'' ?gpv' ?s)\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>f g s gpv gpv'.\n       \\<lbrakk>\\<And>s gpv gpv'.\n                   \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n(f gpv s) (g gpv' s);\n        eq_\\<I>_gpv A \\<I> gpv gpv'; I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod A (eq_onp I))\n                          (the_gpv gpv \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). f (c x) y)))\n                          (the_gpv gpv' \\<bind>\n                           case_generat (\\<lambda>x. return_spmf (x, s))\n                            (\\<lambda>out c.\n                                callee s out \\<bind>\n                                (\\<lambda>(x, y). g (c x) y)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod A (eq_onp I))\n     (the_gpv gpv \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, s)\n          | IO out c \\<Rightarrow>\n              callee s out \\<bind>\n              (\\<lambda>a.\n                  case a of (x, y) \\<Rightarrow> exec_gpv' (c x) y)))\n     (the_gpv gpv' \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, s)\n          | IO out c \\<Rightarrow>\n              callee s out \\<bind>\n              (\\<lambda>a.\n                  case a of (x, y) \\<Rightarrow> exec_gpv'' (c x) y)))", "using step.prems"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n  I s\n\ngoal (1 subgoal):\n 1. rel_spmf (rel_prod A (eq_onp I))\n     (the_gpv gpv \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, s)\n          | IO out c \\<Rightarrow>\n              callee s out \\<bind>\n              (\\<lambda>a.\n                  case a of (x, y) \\<Rightarrow> exec_gpv' (c x) y)))\n     (the_gpv gpv' \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, s)\n          | IO out c \\<Rightarrow>\n              callee s out \\<bind>\n              (\\<lambda>a.\n                  case a of (x, y) \\<Rightarrow> exec_gpv'' (c x) y)))", "by - (drule eq_\\<I>_gpvD, erule rel_spmf_bindI\n        , auto split!: generat.split simp add: eq_onp_same_args \n        intro: WT_callee[THEN WT_calleeD] callee_invariant step.IH intro!: rel_spmf_bind_reflI)"], ["proof (state)\nthis:\n  rel_spmf (rel_prod A (eq_onp I))\n   (the_gpv gpv \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (x, s)\n        | IO out c \\<Rightarrow>\n            callee s out \\<bind>\n            (\\<lambda>a. case a of (x, y) \\<Rightarrow> exec_gpv' (c x) y)))\n   (the_gpv gpv' \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (x, s)\n        | IO out c \\<Rightarrow>\n            callee s out \\<bind>\n            (\\<lambda>a.\n                case a of (x, y) \\<Rightarrow> exec_gpv'' (c x) y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_gpv_coinduct_bind [consumes 1, case_names eq_\\<I>_gpv]:\n  fixes gpv :: \"('a, 'out, 'in) gpv\" and gpv' :: \"('a', 'out, 'in) gpv\"\n  assumes X: \"X gpv gpv'\"\n    and step: \"\\<And>gpv gpv'. X gpv gpv'\n      \\<Longrightarrow> rel_spmf (eq_\\<I>_generat A \\<I> (\\<lambda>gpv gpv'. X gpv gpv' \\<or> eq_\\<I>_gpv A \\<I> gpv gpv' \\<or> \n      (\\<exists>gpv'' gpv''' (B :: 'b \\<Rightarrow> 'b' \\<Rightarrow> bool) f g. gpv = bind_gpv gpv'' f \\<and> gpv' = bind_gpv gpv''' g \\<and> eq_\\<I>_gpv B \\<I> gpv'' gpv''' \\<and> (rel_fun B X) f g))) (the_gpv gpv) (the_gpv gpv')\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "define gpv'' :: \"('b, 'out, 'in) gpv\" where \"gpv'' \\<equiv> Done x\""], ["proof (state)\nthis:\n  gpv'' \\<equiv> Generative_Probabilistic_Value.Done x\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "define f :: \"'b \\<Rightarrow> ('a, 'out, 'in) gpv\" where \"f \\<equiv> \\<lambda>_. gpv\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>_. gpv\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "define gpv''' :: \"('b', 'out, 'in) gpv\" where \"gpv''' \\<equiv> Done y\""], ["proof (state)\nthis:\n  gpv''' \\<equiv> Generative_Probabilistic_Value.Done y\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "define g :: \"'b' \\<Rightarrow> ('a', 'out, 'in) gpv\" where \"g \\<equiv> \\<lambda>_. gpv'\""], ["proof (state)\nthis:\n  g \\<equiv> \\<lambda>_. gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "have \"eq_\\<I>_gpv (\\<lambda>x y. X (f x) (g y)) \\<I> gpv'' gpv'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (\\<lambda>x y. X (f x) (g y)) \\<I> gpv'' gpv'''", "using X"], ["proof (prove)\nusing this:\n  X gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (\\<lambda>x y. X (f x) (g y)) \\<I> gpv'' gpv'''", "by(simp add: f_def g_def gpv''_def gpv'''_def)"], ["proof (state)\nthis:\n  eq_\\<I>_gpv (\\<lambda>x y. X (f x) (g y)) \\<I> gpv'' gpv'''\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "then"], ["proof (chain)\npicking this:\n  eq_\\<I>_gpv (\\<lambda>x y. X (f x) (g y)) \\<I> gpv'' gpv'''", "have \"eq_\\<I>_gpv A \\<I> (bind_gpv gpv'' f) (bind_gpv gpv''' g)\""], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv (\\<lambda>x y. X (f x) (g y)) \\<I> gpv'' gpv'''\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (gpv'' \\<bind> f) (gpv''' \\<bind> g)", "by(coinduction arbitrary: gpv'' f gpv''' g)\n      (drule eq_\\<I>_gpvD, (clarsimp simp add: bind_gpv.sel spmf_rel_map simp del: bind_gpv_sel' elim!: rel_spmf_bindI split!: generat.split dest!: step)\n        , erule rel_spmf_mono, (erule eq_\\<I>_generat.cases; clarsimp), (erule meta_allE, erule (1) meta_impE)\n        , (fastforce | force intro: exI[where x=\"Done _\"] elim!: eq_\\<I>_gpv_mono' dest: rel_funD)+)"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A \\<I> (gpv'' \\<bind> f) (gpv''' \\<bind> g)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "then"], ["proof (chain)\npicking this:\n  eq_\\<I>_gpv A \\<I> (gpv'' \\<bind> f) (gpv''' \\<bind> g)", "show ?thesis"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> (gpv'' \\<bind> f) (gpv''' \\<bind> g)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "unfolding gpv''_def gpv'''_def f_def g_def"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I>\n   (Generative_Probabilistic_Value.Done x \\<bind> (\\<lambda>_. gpv))\n   (Generative_Probabilistic_Value.Done y \\<bind> (\\<lambda>_. gpv'))\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv'", "by simp"], ["proof (state)\nthis:\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes S :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n    and callee1 :: \"'s1 \\<Rightarrow> 'out \\<Rightarrow> ('in \\<times> 's1, 'out', 'in') gpv\"\n    and callee2 :: \"'s2 \\<Rightarrow> 'out \\<Rightarrow> ('in \\<times> 's2, 'out', 'in') gpv\"\n    and \\<I> :: \"('out, 'in) \\<I>\"\n    and \\<I>' :: \"('out', 'in') \\<I>\"\n  assumes callee: \"\\<And>s1 s2 q. \\<lbrakk> S s1 s2; q \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)) S) \\<I>' (callee1 s1 q) (callee2 s2 q)\"\nbegin"], ["", "lemma eq_\\<I>_gpv_inline1:\n  includes lifting_syntax\n  assumes \"S s1 s2\" \"eq_\\<I>_gpv A \\<I> gpv1 gpv2\"\n  shows \"rel_spmf (rel_sum (rel_prod A S) \n      (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2'). q = q' \\<and> q' \\<in> outs_\\<I> \\<I>' \\<and> (\\<exists>q'' \\<in> outs_\\<I> \\<I>. \n          (\\<forall>r \\<in> responses_\\<I> \\<I>' q'. eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S) \\<I>' (rpv1 r) (rpv1' r)) \\<and> \n          (\\<forall>r' \\<in> responses_\\<I> \\<I> q''. eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n     (inline1 callee1 gpv1 s1) (inline1 callee2 gpv2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_sum (rel_prod A S)\n       (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n           q = q' \\<and>\n           q' \\<in> outs_\\<I> \\<I>' \\<and>\n           (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n               (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                   eq_\\<I>_gpv\n                    (rel_prod\n                      (eq_onp\n                        (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q''))\n                      S)\n                    \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n               (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                   eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n     (inline1 callee1 gpv1 s1) (inline1 callee2 gpv2 s2)", "using assms"], ["proof (prove)\nusing this:\n  S s1 s2\n  eq_\\<I>_gpv A \\<I> gpv1 gpv2\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_sum (rel_prod A S)\n       (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n           q = q' \\<and>\n           q' \\<in> outs_\\<I> \\<I>' \\<and>\n           (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n               (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                   eq_\\<I>_gpv\n                    (rel_prod\n                      (eq_onp\n                        (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q''))\n                      S)\n                    \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n               (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                   eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n     (inline1 callee1 gpv1 s1) (inline1 callee2 gpv2 s2)", "proof(induction arbitrary: gpv1 gpv2 s1 s2 rule: parallel_fixp_induct_2_2[OF partial_function_definitions_spmf partial_function_definitions_spmf inline1.mono inline1.mono inline1_def inline1_def, unfolded lub_spmf_empty, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc xd.\n            S xc xd \\<longrightarrow>\n            eq_\\<I>_gpv A \\<I> xa xb \\<longrightarrow>\n            rel_spmf\n             (rel_sum (rel_prod A S)\n               (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                   q = q' \\<and>\n                   q' \\<in> outs_\\<I> \\<I>' \\<and>\n                   (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                       (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                           eq_\\<I>_gpv\n                            (rel_prod\n                              (eq_onp\n                                (\\<lambda>r'.\n                                    r' \\<in> responses_\\<I> \\<I> q''))\n                              S)\n                            \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                       (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                           eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n             (curry (fst x) xa xc) (curry (snd x) xb xd))\n 2. \\<And>gpv1 gpv2 s1 s2.\n       \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (return_pmf None) (return_pmf None)\n 3. \\<And>f g gpv1 gpv2 s1 s2.\n       \\<lbrakk>\\<And>gpv1 gpv2 s1 s2.\n                   \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_sum (rel_prod A S)\n  (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n      q = q' \\<and>\n      q' \\<in> outs_\\<I> \\<I>' \\<and>\n      (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n          (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n              eq_\\<I>_gpv\n               (rel_prod\n                 (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n               \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n          (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n              eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n(f gpv1 s1) (g gpv2 s2);\n        S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (the_gpv gpv1 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s1)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee1 s1 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). f (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))\n                          (the_gpv gpv2 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s2)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee2 s2 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). g (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc xd.\n            S xc xd \\<longrightarrow>\n            eq_\\<I>_gpv A \\<I> xa xb \\<longrightarrow>\n            rel_spmf\n             (rel_sum (rel_prod A S)\n               (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                   q = q' \\<and>\n                   q' \\<in> outs_\\<I> \\<I>' \\<and>\n                   (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                       (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                           eq_\\<I>_gpv\n                            (rel_prod\n                              (eq_onp\n                                (\\<lambda>r'.\n                                    r' \\<in> responses_\\<I> \\<I> q''))\n                              S)\n                            \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                       (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                           eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n             (curry (fst x) xa xc) (curry (snd x) xb xd))\n 2. \\<And>gpv1 gpv2 s1 s2.\n       \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (return_pmf None) (return_pmf None)\n 3. \\<And>f g gpv1 gpv2 s1 s2.\n       \\<lbrakk>\\<And>gpv1 gpv2 s1 s2.\n                   \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_sum (rel_prod A S)\n  (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n      q = q' \\<and>\n      q' \\<in> outs_\\<I> \\<I>' \\<and>\n      (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n          (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n              eq_\\<I>_gpv\n               (rel_prod\n                 (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n               \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n          (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n              eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n(f gpv1 s1) (g gpv2 s2);\n        S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (the_gpv gpv1 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s1)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee1 s1 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). f (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))\n                          (the_gpv gpv2 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s2)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee2 s2 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). g (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xaa xaaa xaaaa.\n            S xaaa xaaaa \\<longrightarrow>\n            eq_\\<I>_gpv A \\<I> xa xaa \\<longrightarrow>\n            rel_spmf\n             (rel_sum (rel_prod A S)\n               (\\<lambda>a.\n                   case a of\n                   (q, a) \\<Rightarrow>\n                     case a of\n                     (rpv1, rpv2) \\<Rightarrow>\n                       \\<lambda>a.\n                          case a of\n                          (q', rpv1', rpv2') \\<Rightarrow>\n                            q = q' \\<and>\n                            q' \\<in> outs_\\<I> \\<I>' \\<and>\n                            (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                                    eq_\\<I>_gpv\n                                     (rel_prod\n (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n                                     \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                                    eq_\\<I>_gpv A \\<I> (rpv2 r')\n                                     (rpv2' r')))))\n             (curry (fst x) xa xaaa) (curry (snd x) xaa xaaaa))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xaa xaaa xaaaa.\n          S xaaa xaaaa \\<longrightarrow>\n          eq_\\<I>_gpv A \\<I> xa xaa \\<longrightarrow>\n          rel_spmf\n           (rel_sum (rel_prod A S)\n             (\\<lambda>a.\n                 case a of\n                 (q, a) \\<Rightarrow>\n                   case a of\n                   (rpv1, rpv2) \\<Rightarrow>\n                     \\<lambda>a.\n                        case a of\n                        (q', rpv1', rpv2') \\<Rightarrow>\n                          q = q' \\<and>\n                          q' \\<in> outs_\\<I> \\<I>' \\<and>\n                          (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                              (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                                  eq_\\<I>_gpv\n                                   (rel_prod\n                                     (eq_onp\n (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q''))\n                                     S)\n                                   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                              (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                                  eq_\\<I>_gpv A \\<I> (rpv2 r')\n                                   (rpv2' r')))))\n           (curry (fst x) xa xaaa) (curry (snd x) xaa xaaaa))\n\ngoal (2 subgoals):\n 1. \\<And>gpv1 gpv2 s1 s2.\n       \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (return_pmf None) (return_pmf None)\n 2. \\<And>f g gpv1 gpv2 s1 s2.\n       \\<lbrakk>\\<And>gpv1 gpv2 s1 s2.\n                   \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_sum (rel_prod A S)\n  (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n      q = q' \\<and>\n      q' \\<in> outs_\\<I> \\<I>' \\<and>\n      (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n          (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n              eq_\\<I>_gpv\n               (rel_prod\n                 (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n               \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n          (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n              eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n(f gpv1 s1) (g gpv2 s2);\n        S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (the_gpv gpv1 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s1)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee1 s1 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). f (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))\n                          (the_gpv gpv2 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s2)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee2 s2 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). g (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))", "case bottom"], ["proof (state)\nthis:\n  S s1 s2\n  eq_\\<I>_gpv A \\<I> gpv1 gpv2\n\ngoal (2 subgoals):\n 1. \\<And>gpv1 gpv2 s1 s2.\n       \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (return_pmf None) (return_pmf None)\n 2. \\<And>f g gpv1 gpv2 s1 s2.\n       \\<lbrakk>\\<And>gpv1 gpv2 s1 s2.\n                   \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_sum (rel_prod A S)\n  (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n      q = q' \\<and>\n      q' \\<in> outs_\\<I> \\<I>' \\<and>\n      (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n          (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n              eq_\\<I>_gpv\n               (rel_prod\n                 (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n               \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n          (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n              eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n(f gpv1 s1) (g gpv2 s2);\n        S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (the_gpv gpv1 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s1)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee1 s1 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). f (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))\n                          (the_gpv gpv2 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s2)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee2 s2 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). g (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_sum (rel_prod A S)\n       (\\<lambda>a.\n           case a of\n           (q, a) \\<Rightarrow>\n             case a of\n             (rpv1, rpv2) \\<Rightarrow>\n               \\<lambda>a.\n                  case a of\n                  (q', rpv1', rpv2') \\<Rightarrow>\n                    q = q' \\<and>\n                    q' \\<in> outs_\\<I> \\<I>' \\<and>\n                    (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                        (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                            eq_\\<I>_gpv\n                             (rel_prod\n                               (eq_onp\n                                 (\\<lambda>r'.\n                                     r' \\<in> responses_\\<I> \\<I> q''))\n                               S)\n                             \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                        (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                            eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n     (return_pmf None) (return_pmf None)", "by simp"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_sum (rel_prod A S)\n     (\\<lambda>a.\n         case a of\n         (q, a) \\<Rightarrow>\n           case a of\n           (rpv1, rpv2) \\<Rightarrow>\n             \\<lambda>a.\n                case a of\n                (q', rpv1', rpv2') \\<Rightarrow>\n                  q = q' \\<and>\n                  q' \\<in> outs_\\<I> \\<I>' \\<and>\n                  (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                      (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                          eq_\\<I>_gpv\n                           (rel_prod\n                             (eq_onp\n                               (\\<lambda>r'.\n                                   r' \\<in> responses_\\<I> \\<I> q''))\n                             S)\n                           \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                      (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                          eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n   (return_pmf None) (return_pmf None)\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv1 gpv2 s1 s2.\n       \\<lbrakk>\\<And>gpv1 gpv2 s1 s2.\n                   \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_sum (rel_prod A S)\n  (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n      q = q' \\<and>\n      q' \\<in> outs_\\<I> \\<I>' \\<and>\n      (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n          (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n              eq_\\<I>_gpv\n               (rel_prod\n                 (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n               \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n          (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n              eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n(f gpv1 s1) (g gpv2 s2);\n        S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (the_gpv gpv1 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s1)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee1 s1 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). f (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))\n                          (the_gpv gpv2 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s2)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee2 s2 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). g (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))", "case (step inline1' inline1'')"], ["proof (state)\nthis:\n  \\<lbrakk>S ?s1.0 ?s2.0; eq_\\<I>_gpv A \\<I> ?gpv1.0 ?gpv2.0\\<rbrakk>\n  \\<Longrightarrow> rel_spmf\n                     (rel_sum (rel_prod A S)\n                       (\\<lambda>a.\n                           case a of\n                           (q, a) \\<Rightarrow>\n                             case a of\n                             (rpv1, rpv2) \\<Rightarrow>\n                               \\<lambda>a.\n                                  case a of\n                                  (q', rpv1', rpv2') \\<Rightarrow>\n                                    q = q' \\<and>\n                                    q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                    (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n  (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n      eq_\\<I>_gpv\n       (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n       \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n  (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n      eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                     (inline1' ?gpv1.0 ?s1.0) (inline1'' ?gpv2.0 ?s2.0)\n  S s1 s2\n  eq_\\<I>_gpv A \\<I> gpv1 gpv2\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv1 gpv2 s1 s2.\n       \\<lbrakk>\\<And>gpv1 gpv2 s1 s2.\n                   \\<lbrakk>S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n                   \\<Longrightarrow> rel_spmf\n(rel_sum (rel_prod A S)\n  (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n      q = q' \\<and>\n      q' \\<in> outs_\\<I> \\<I>' \\<and>\n      (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n          (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n              eq_\\<I>_gpv\n               (rel_prod\n                 (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n               \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n          (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n              eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n(f gpv1 s1) (g gpv2 s2);\n        S s1 s2; eq_\\<I>_gpv A \\<I> gpv1 gpv2\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_sum (rel_prod A S)\n                            (\\<lambda>(q, rpv1, rpv2) (q', rpv1', rpv2').\n                                q = q' \\<and>\n                                q' \\<in> outs_\\<I> \\<I>' \\<and>\n                                (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                                    (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r'. r' \\<in> responses_\\<I> \\<I> q'')) S)\n   \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                                    (\\<forall>r'\n        \\<in>responses_\\<I> \\<I> q''.\n  eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n                          (the_gpv gpv1 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s1)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee1 s1 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). f (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))\n                          (the_gpv gpv2 \\<bind>\n                           case_generat\n                            (\\<lambda>x. return_spmf (Inl (x, s2)))\n                            (\\<lambda>out rpv.\n                                the_gpv (callee2 s2 out) \\<bind>\n                                case_generat (\\<lambda>(x, y). g (rpv x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf (Inr (out, rpv', rpv)))))", "from step.prems"], ["proof (chain)\npicking this:\n  S s1 s2\n  eq_\\<I>_gpv A \\<I> gpv1 gpv2", "show ?case"], ["proof (prove)\nusing this:\n  S s1 s2\n  eq_\\<I>_gpv A \\<I> gpv1 gpv2\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_sum (rel_prod A S)\n       (\\<lambda>a.\n           case a of\n           (q, a) \\<Rightarrow>\n             case a of\n             (rpv1, rpv2) \\<Rightarrow>\n               \\<lambda>a.\n                  case a of\n                  (q', rpv1', rpv2') \\<Rightarrow>\n                    q = q' \\<and>\n                    q' \\<in> outs_\\<I> \\<I>' \\<and>\n                    (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                        (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                            eq_\\<I>_gpv\n                             (rel_prod\n                               (eq_onp\n                                 (\\<lambda>r'.\n                                     r' \\<in> responses_\\<I> \\<I> q''))\n                               S)\n                             \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                        (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                            eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n     (the_gpv gpv1 \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s1))\n          | IO out rpv \\<Rightarrow>\n              the_gpv (callee1 s1 out) \\<bind>\n              (\\<lambda>a.\n                  case a of Pure (x, y) \\<Rightarrow> inline1' (rpv x) y\n                  | IO out rpv' \\<Rightarrow>\n                      return_spmf (Inr (out, rpv', rpv)))))\n     (the_gpv gpv2 \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s2))\n          | IO out rpv \\<Rightarrow>\n              the_gpv (callee2 s2 out) \\<bind>\n              (\\<lambda>a.\n                  case a of Pure (x, y) \\<Rightarrow> inline1'' (rpv x) y\n                  | IO out rpv' \\<Rightarrow>\n                      return_spmf (Inr (out, rpv', rpv)))))", "by - (erule eq_\\<I>_gpvD[THEN rel_spmf_bindI]\n        , clarsimp split!: generat.split\n        , erule eq_\\<I>_gpvD[OF callee(1), THEN rel_spmf_bindI]\n        , auto simp add: eq_onp_def intro: step.IH[THEN rel_spmf_mono] elim: eq_\\<I>_gpvD[OF callee(1), THEN rel_spmf_bindI] split!: generat.split)"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_sum (rel_prod A S)\n     (\\<lambda>a.\n         case a of\n         (q, a) \\<Rightarrow>\n           case a of\n           (rpv1, rpv2) \\<Rightarrow>\n             \\<lambda>a.\n                case a of\n                (q', rpv1', rpv2') \\<Rightarrow>\n                  q = q' \\<and>\n                  q' \\<in> outs_\\<I> \\<I>' \\<and>\n                  (\\<exists>q''\\<in>outs_\\<I> \\<I>.\n                      (\\<forall>r\\<in>responses_\\<I> \\<I>' q'.\n                          eq_\\<I>_gpv\n                           (rel_prod\n                             (eq_onp\n                               (\\<lambda>r'.\n                                   r' \\<in> responses_\\<I> \\<I> q''))\n                             S)\n                           \\<I>' (rpv1 r) (rpv1' r)) \\<and>\n                      (\\<forall>r'\\<in>responses_\\<I> \\<I> q''.\n                          eq_\\<I>_gpv A \\<I> (rpv2 r') (rpv2' r')))))\n   (the_gpv gpv1 \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s1))\n        | IO out rpv \\<Rightarrow>\n            the_gpv (callee1 s1 out) \\<bind>\n            (\\<lambda>a.\n                case a of Pure (x, y) \\<Rightarrow> inline1' (rpv x) y\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', rpv)))))\n   (the_gpv gpv2 \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (Inl (x, s2))\n        | IO out rpv \\<Rightarrow>\n            the_gpv (callee2 s2 out) \\<bind>\n            (\\<lambda>a.\n                case a of Pure (x, y) \\<Rightarrow> inline1'' (rpv x) y\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', rpv)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_gpv_inline:\n  assumes S: \"S s1 s2\"\n    and gpv: \"eq_\\<I>_gpv A \\<I> gpv1 gpv2\"\n  shows \"eq_\\<I>_gpv (rel_prod A S) \\<I>' (inline callee1 gpv1 s1) (inline callee2 gpv2 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (rel_prod A S) \\<I>' (inline callee1 gpv1 s1)\n     (inline callee2 gpv2 s2)", "using S gpv"], ["proof (prove)\nusing this:\n  S s1 s2\n  eq_\\<I>_gpv A \\<I> gpv1 gpv2\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (rel_prod A S) \\<I>' (inline callee1 gpv1 s1)\n     (inline callee2 gpv2 s2)", "by (coinduction arbitrary: gpv1 gpv2 s1 s2 rule: eq_\\<I>_gpv_coinduct_bind)\n    (clarsimp simp add: inline_sel spmf_rel_map, drule (1) eq_\\<I>_gpv_inline1\n      , fastforce split!: generat.split sum.split del: disjCI intro!: disjI2 rel_funI elim: rel_spmf_mono simp add: eq_onp_def)"], ["", "end"], ["", "lemma eq_\\<I>_gpv_left_gpv_cong:\n  \"eq_\\<I>_gpv A \\<I> gpv gpv' \\<Longrightarrow> eq_\\<I>_gpv A (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (left_gpv gpv) (left_gpv gpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv' \\<Longrightarrow>\n    eq_\\<I>_gpv A (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (left_gpv gpv)\n     (left_gpv gpv')", "by(coinduction arbitrary: gpv gpv')\n    (drule eq_\\<I>_gpvD, auto 4 4 simp add: spmf_rel_map elim!: rel_spmf_mono eq_\\<I>_generat.cases)"], ["", "lemma eq_\\<I>_gpv_right_gpv_cong:\n  \"eq_\\<I>_gpv A \\<I>' gpv gpv' \\<Longrightarrow> eq_\\<I>_gpv A (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (right_gpv gpv) (right_gpv gpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I>' gpv gpv' \\<Longrightarrow>\n    eq_\\<I>_gpv A (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (right_gpv gpv)\n     (right_gpv gpv')", "by(coinduction arbitrary: gpv gpv')\n    (drule eq_\\<I>_gpvD, auto 4 4 simp add: spmf_rel_map elim!: rel_spmf_mono eq_\\<I>_generat.cases)"], ["", "lemma eq_\\<I>_gpvD_WT1: \"\\<lbrakk> eq_\\<I>_gpv A \\<I> gpv gpv'; \\<I> \\<turnstile>g gpv \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I> \\<turnstile>g gpv' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv A \\<I> gpv gpv';\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g gpv' \\<surd>", "by(coinduction arbitrary: gpv gpv')(fastforce simp add: eq_\\<I>_generat_iff2 dest: WT_gpv_ContD eq_\\<I>_gpvD dest!: rel_setD2 set_spmf_parametric[THEN rel_funD])"], ["", "lemma eq_\\<I>_gpvD_results_gpv2: \n  assumes \"eq_\\<I>_gpv A \\<I> gpv gpv'\" \"y \\<in> results_gpv \\<I> gpv'\"\n  shows \"\\<exists>x \\<in> results_gpv \\<I> gpv. A x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>results_gpv \\<I> gpv. A x y", "using assms(2,1)"], ["proof (prove)\nusing this:\n  y \\<in> results_gpv \\<I> gpv'\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>results_gpv \\<I> gpv. A x y", "by(induction arbitrary: gpv)\n    (fastforce dest!: set_spmf_parametric[THEN rel_funD] rel_setD2 dest: eq_\\<I>_gpvD simp add: eq_\\<I>_generat_iff2 intro: results_gpv.intros)+"], ["", "coinductive eq_\\<I>_converter :: \"('a, 'b) \\<I> \\<Rightarrow> ('out, 'in) \\<I> \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<Rightarrow> bool\"\n  (\"_,_ \\<turnstile>\\<^sub>C/ _ \\<sim>/ _\" [100, 0, 99, 99] 99)\n  for \\<I> \\<I>' where\n    eq_\\<I>_converterI: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\" if\n    \"\\<And>q. q \\<in> outs_\\<I> \\<I> \\<Longrightarrow> eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)) (eq_\\<I>_converter \\<I> \\<I>')) \\<I>' (run_converter conv q) (run_converter conv' q)\""], ["", "lemma eq_\\<I>_converter_coinduct [consumes 1, case_names eq_\\<I>_converter, coinduct pred: eq_\\<I>_converter]:\n  assumes \"X conv conv'\"\n    and \"\\<And>conv conv' q. \\<lbrakk> X conv conv'; q \\<in> outs_\\<I> \\<I> \\<rbrakk>\n     \\<Longrightarrow> eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)) (\\<lambda>conv conv'. X conv conv' \\<or> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv')) \\<I>'\n           (run_converter conv q) (run_converter conv' q)\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'", "using assms(1)"], ["proof (prove)\nusing this:\n  X conv conv'\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'", "by(rule eq_\\<I>_converter.coinduct)(blast dest: assms(2))"], ["", "lemma eq_\\<I>_converterD: \n  \"eq_\\<I>_gpv (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)) (eq_\\<I>_converter \\<I> \\<I>')) \\<I>' (run_converter conv q) (run_converter conv' q)\"\n  if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\" \"q \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n       (eq_\\<I>_converter \\<I> \\<I>'))\n     \\<I>' (run_converter conv q) (run_converter conv' q)", "using that"], ["proof (prove)\nusing this:\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n       (eq_\\<I>_converter \\<I> \\<I>'))\n     \\<I>' (run_converter conv q) (run_converter conv' q)", "by(blast elim: eq_\\<I>_converter.cases)"], ["", "lemma eq_\\<I>_converter_reflI: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv\" if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv", "using that"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv", "by(coinduction arbitrary: conv)(auto intro!: eq_\\<I>_gpv_reflI dest: WT_converterD simp add: eq_onp_same_args)"], ["", "lemma eq_\\<I>_converter_sym [sym]: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\" if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<sim> conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'", "using that"], ["proof (prove)\nusing this:\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv' \\<sim> conv\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'", "by(coinduction arbitrary: conv conv')\n    (drule (1) eq_\\<I>_converterD, rewrite in \\<hole> conversep_iff[symmetric]\n      ,  auto simp add: eq_\\<I>_gpv_conversep[symmetric] eq_onp_def elim: eq_\\<I>_gpv_mono')"], ["", "lemma eq_\\<I>_converter_trans [trans]:\n  \"\\<lbrakk> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'; \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<sim> conv'' \\<rbrakk> \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv';\n     \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv' \\<sim> conv''\\<rbrakk>\n    \\<Longrightarrow> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv''", "by(coinduction arbitrary: conv conv' conv'')\n    ((drule (1) eq_\\<I>_converterD)+, drule (1) eq_\\<I>_gpv_relcompp[THEN fun_cong, THEN fun_cong, THEN iffD2, OF relcomppI]\n      , auto simp add: eq_OO prod.rel_compp[symmetric] eq_onp_def elim!: eq_\\<I>_gpv_mono')"], ["", "lemma eq_\\<I>_converter_mono:\n  assumes *: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<sim> conv'\"\n    and le: \"\\<I>1' \\<le> \\<I>1\" \"\\<I>2 \\<le> \\<I>2'\"\n  shows \"\\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv \\<sim> conv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1',\\<I>2' \\<turnstile>\\<^sub>C conv \\<sim> conv'", "using *"], ["proof (prove)\nusing this:\n  \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<sim> conv'\n\ngoal (1 subgoal):\n 1. \\<I>1',\\<I>2' \\<turnstile>\\<^sub>C conv \\<sim> conv'", "by(coinduction arbitrary: conv conv')\n    (auto simp add: eq_onp_def dest!:eq_\\<I>_converterD  intro: responses_\\<I>_mono[THEN subsetD, OF le(1)] \n      elim!: eq_\\<I>_gpv_mono'[OF _ _ le(2)] outs_\\<I>_mono[THEN subsetD, OF le(1)])"], ["", "lemma eq_\\<I>_converter_eq: \"conv1 = conv2\" if \"\\<I>_full, \\<I>_full \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv1 = conv2", "using that"], ["proof (prove)\nusing this:\n  \\<I>_full,\\<I>_full \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\n\ngoal (1 subgoal):\n 1. conv1 = conv2", "by(coinduction arbitrary: conv1 conv2)\n    (auto simp add: eq_\\<I>_gpv_into_rel_gpv eq_onp_def intro!: rel_funI elim!: gpv.rel_mono_strong eq_\\<I>_gpv_into_rel_gpv dest:eq_\\<I>_converterD)"], ["", "lemma eq_\\<I>_attach_on: (* TODO: generalise to eq_resource_on *)\n  assumes \"\\<I>' \\<turnstile>res res \\<surd>\" \"\\<I>_uniform A UNIV, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\"\n  shows \"A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res", "using assms"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>res res \\<surd>\n  \\<I>_uniform A UNIV,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res", "by(coinduction arbitrary: conv conv' res)\n    (auto 4 4 simp add: eq_onp_def spmf_rel_map dest: eq_\\<I>_converterD intro!: rel_funI run_resource.eq_\\<I>_exec_gpv[THEN rel_spmf_mono])"], ["", "lemma eq_\\<I>_attach_on':\n  assumes \"\\<I>' \\<turnstile>res res \\<surd>\" \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\" \"A \\<subseteq> outs_\\<I> \\<I>\"\n  shows \"A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res", "using assms(1) assms(2)[THEN eq_\\<I>_converter_mono]"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>res res \\<surd>\n  \\<lbrakk>?\\<I>1' \\<le> \\<I>; \\<I>' \\<le> ?\\<I>2'\\<rbrakk>\n  \\<Longrightarrow> ?\\<I>1',?\\<I>2' \\<turnstile>\\<^sub>C conv \\<sim> conv'\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R attach conv res \\<sim> attach conv' res", "by(rule eq_\\<I>_attach_on)(use assms(3) in \\<open>auto simp add: le_\\<I>_def\\<close>)"], ["", "lemma eq_\\<I>_attach:\n  \"\\<lbrakk> \\<I>' \\<turnstile>res res \\<surd>; \\<I>_full, \\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv' \\<rbrakk> \\<Longrightarrow> attach conv res = attach conv' res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>res res \\<surd>;\n     \\<I>_full,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'\\<rbrakk>\n    \\<Longrightarrow> attach conv res = attach conv' res", "by(rule eq_resource_on_UNIV_D)(simp add: eq_\\<I>_attach_on)"], ["", "lemma eq_\\<I>_comp_cong:\n  \"\\<lbrakk> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'; \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<sim> conv2' \\<rbrakk>\n  \\<Longrightarrow> \\<I>1, \\<I>3 \\<turnstile>\\<^sub>C comp_converter conv1 conv2 \\<sim> comp_converter conv1' conv2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv1 \\<sim> conv1';\n     \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv2 \\<sim> conv2'\\<rbrakk>\n    \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                      comp_converter conv1 conv2 \\<sim>\n                      comp_converter conv1' conv2'", "by(coinduction arbitrary: conv1 conv2 conv1' conv2')\n    (clarsimp, rule eq_\\<I>_gpv_mono'[OF eq_\\<I>_gpv_inline[where S=\"eq_\\<I>_converter \\<I>2 \\<I>3\"]]\n      , (fastforce elim!: eq_\\<I>_converterD)+)"], ["", "lemma comp_converter_cong: \"comp_converter conv1 conv2 = comp_converter conv1' conv2'\"\n  if \"\\<I>_full, \\<I> \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'\" \"\\<I>, \\<I>_full \\<turnstile>\\<^sub>C conv2 \\<sim> conv2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter conv1 conv2 = comp_converter conv1' conv2'", "by(rule eq_\\<I>_converter_eq)(rule eq_\\<I>_comp_cong[OF that])"], ["", "lemma parallel_converter2_id_id: \n  \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>\\<^sub>C parallel_converter2 id_converter id_converter \\<sim> id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    \\<I>2,\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2 \\<turnstile>\\<^sub>C\n    parallel_converter2 id_converter id_converter \\<sim> id_converter", "by(coinduction)(auto split: sum.split intro!: eq_\\<I>_gpv_Pause simp add: eq_onp_same_args)"], ["", "lemma parallel_converter2_eq_\\<I>_cong:\n  \"\\<lbrakk> \\<I>1, \\<I>1' \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'; \\<I>2, \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<sim> conv2' \\<rbrakk>\n  \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C parallel_converter2 conv1 conv2 \\<sim> parallel_converter2 conv1' conv2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1,\\<I>1' \\<turnstile>\\<^sub>C conv1 \\<sim> conv1';\n     \\<I>2,\\<I>2' \\<turnstile>\\<^sub>C conv2 \\<sim> conv2'\\<rbrakk>\n    \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I>\n                      \\<I>2,\\<I>1' \\<oplus>\\<^sub>\\<I>\n                            \\<I>2' \\<turnstile>\\<^sub>C\n                      parallel_converter2 conv1 conv2 \\<sim>\n                      parallel_converter2 conv1' conv2'", "by(coinduction arbitrary: conv1 conv2 conv1' conv2')\n    (fastforce intro!: eq_\\<I>_gpv_left_gpv_cong eq_\\<I>_gpv_right_gpv_cong dest: eq_\\<I>_converterD elim!: eq_\\<I>_gpv_mono' simp add: eq_onp_def)"], ["", "lemma id_converter_eq_self: \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C id_converter \\<sim> id_converter\" if \"\\<I> \\<le> \\<I>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C id_converter \\<sim> id_converter", "by(rule eq_\\<I>_converter_mono[OF _ order_refl that])(rule eq_\\<I>_converter_reflI[OF WT_converter_id])"], ["", "lemma eq_\\<I>_converterD_WT1:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\" and \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>", "by(coinduction arbitrary: conv1 conv2)\n    (drule (1) eq_\\<I>_converterD, auto 4 3 dest: eq_\\<I>_converterD eq_\\<I>_gpvD_WT1 WT_converterD_WT WT_converterD_results eq_\\<I>_gpvD_results_gpv2 simp add: eq_onp_def)"], ["", "lemma eq_\\<I>_converterD_WT:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<longleftrightarrow> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> = \\<I>,\n    \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>", "proof(rule iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<Longrightarrow>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\n 2. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<Longrightarrow>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "case 1"], ["proof (state)\nthis:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n\ngoal (2 subgoals):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<Longrightarrow>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\n 2. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<Longrightarrow>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "then"], ["proof (chain)\npicking this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "show ?case"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>", "by (auto intro: eq_\\<I>_converterD_WT1)"], ["proof (state)\nthis:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<Longrightarrow>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<Longrightarrow>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "case 2"], ["proof (state)\nthis:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<Longrightarrow>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "then"], ["proof (chain)\npicking this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>", "show ?case"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "using assms[symmetric]"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv2 \\<sim> conv1\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>", "by (auto intro: eq_\\<I>_converterD_WT1)"], ["proof (state)\nthis:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_gpv_Fail [simp]: \"eq_\\<I>_gpv A \\<I> Fail Fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> Fail Fail", "by(rule eq_\\<I>_gpv.intros) simp"], ["", "lemma eq_\\<I>_restrict_gpv:\n  assumes \"eq_\\<I>_gpv A \\<I> gpv gpv'\"\n  shows \"eq_\\<I>_gpv A \\<I> (restrict_gpv \\<I> gpv) gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (restrict_gpv \\<I> gpv) gpv'", "using assms"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (restrict_gpv \\<I> gpv) gpv'", "by(coinduction arbitrary: gpv gpv')\n    (fastforce dest: eq_\\<I>_gpvD simp add: spmf_rel_map pmf.rel_map option_rel_Some1 eq_\\<I>_generat_iff1 elim!: pmf.rel_mono_strong eq_\\<I>_generat_mono' split: option.split generat.split)"], ["", "lemma eq_\\<I>_restrict_converter:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\"\n    and \"outs_\\<I> \\<I> \\<subseteq> A\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<sim> cnv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<sim>\n    cnv", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<sim>\n    cnv", "by(coinduction arbitrary: cnv)\n    (use assms(2) in \\<open>auto intro!: eq_\\<I>_gpv_reflI eq_\\<I>_restrict_gpv simp add: eq_onp_def dest: WT_converterD\\<close>)"], ["", "lemma eq_\\<I>_restrict_gpv_full:\n  \"eq_\\<I>_gpv A \\<I>_full (restrict_gpv \\<I> gpv) (restrict_gpv \\<I> gpv')\"\n  if \"eq_\\<I>_gpv A \\<I> gpv gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I>_full (restrict_gpv \\<I> gpv) (restrict_gpv \\<I> gpv')", "using that"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> gpv gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I>_full (restrict_gpv \\<I> gpv) (restrict_gpv \\<I> gpv')", "by(coinduction arbitrary: gpv gpv')\n    (fastforce dest: eq_\\<I>_gpvD simp add: pmf.rel_map in_set_spmf[symmetric] elim!: pmf.rel_mono_strong split!: option.split generat.split)"], ["", "lemma eq_\\<I>_restrict_converter_cong:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim> cnv'\"\n    and \"A \\<subseteq> outs_\\<I> \\<I>\"\n  shows \"restrict_converter A \\<I>' cnv = restrict_converter A \\<I>' cnv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_converter A \\<I>' cnv = restrict_converter A \\<I>' cnv'", "using assms"], ["proof (prove)\nusing this:\n  \\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<sim> cnv'\n  A \\<subseteq> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. restrict_converter A \\<I>' cnv = restrict_converter A \\<I>' cnv'", "by(coinduction arbitrary: cnv cnv')\n    (fastforce intro: eq_\\<I>_gpv_into_rel_gpv eq_\\<I>_restrict_gpv_full elim!: eq_\\<I>_gpv_mono' simp add: eq_onp_def rel_fun_def gpv.rel_map dest: eq_\\<I>_converterD)"], ["", "end"]]}