{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography/Converter.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography", "problem_names": ["lemma case_converter_conv_run_converter: \"case_converter f conv = f (run_converter conv)\"", "lemma map_converter_sel [simp]:\n  \"run_converter (map_converter conv) a' = map_gpv' (map_prod b map_converter) out inn (run_converter conv (a a'))\"", "lemma map_converter_ctr [simp, code]:\n  \"map_converter (Converter f) = Converter (map_fun a (map_gpv' (map_prod b map_converter) out inn) f)\"", "lemma map_converter_id14: \"map_converter id b out id res = map_converter' b out res\"", "lemma map_converter_id [simp]: \"map_converter id id id id conv = conv\"", "lemma map_converter_compose [simp]:\n  \"map_converter a b f g (map_converter a' b' f' g' conv) = map_converter (a' \\<circ> a) (b \\<circ> b') (f \\<circ> f') (g' \\<circ> g) conv\"", "lemma outsp_converter_outs_converter_eq [pred_set_conv]: \"Converter.outsp_converter \\<I> \\<I>' x = (\\<lambda>conv. x \\<in> outs_converter \\<I> \\<I>' conv)\"", "lemmas intros [intro?] = outsp_converter.intros[to_set]\n  and Out = outsp_converter.Out[to_set]\n  and Cont = outsp_converter.Cont[to_set]\n  and induct [consumes 1, case_names Out Cont, induct set: outs_converter] = outsp_converter.induct[to_set]\n  and cases [consumes 1, case_names Out Cont, cases set: outs_converter] = outsp_converter.cases[to_set]\n  and simps = outsp_converter.simps[to_set]", "lemma resultsp_converter_results_converter_eq [pred_set_conv]:\n  \"Converter.resultsp_converter \\<I> \\<I>' x = (\\<lambda>conv. x \\<in> results_converter \\<I> \\<I>' conv)\"", "lemmas intros [intro?] = resultsp_converter.intros[to_set]\n  and Result = resultsp_converter.Result[to_set]\n  and Cont = resultsp_converter.Cont[to_set]\n  and induct [consumes 1, case_names Result Cont, induct set: results_converter] = resultsp_converter.induct[to_set]\n  and cases [consumes 1, case_names Result Cont, cases set: results_converter] = resultsp_converter.cases[to_set]\n  and simps = resultsp_converter.simps[to_set]", "lemma rel_converter_coinduct [consumes 1, case_names rel_converter, coinduct pred: rel_converter]:\n  assumes \"X conv1 conv2\"\n    and \"\\<And>conv1 conv2. X conv1 conv2 \\<Longrightarrow>\n         rel_fun A (rel_gpv'' (rel_prod B (\\<lambda>conv1 conv2. X conv1 conv2 \\<or> rel_converter A B C R conv1 conv2)) C R)\n            (run_converter conv1) (run_converter conv2)\"\n  shows \"rel_converter A B C R conv1 conv2\"", "lemma rel_converter_simps [simp, code]:\n  \"rel_converter A B C R (Converter f) (Converter g) \\<longleftrightarrow> \n  rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) f g\"", "lemma rel_converterD:\n  \"rel_converter A B C R conv1 conv2 \n  \\<Longrightarrow> rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) (run_converter conv1) (run_converter conv2)\"", "lemma rel_converter_eq14: \"rel_converter (=) B C (=) = rel_converter' B C\" (is \"?lhs = ?rhs\")", "lemma rel_converter_eq [relator_eq]: \"rel_converter (=) (=) (=) (=) = (=)\"", "lemma rel_converter_mono [relator_mono]:\n  assumes \"A' \\<le> A\" \"B \\<le> B'\" \"C \\<le> C'\" \"R' \\<le> R\"\n  shows \"rel_converter A B C R \\<le> rel_converter A' B' C' R'\"", "lemma rel_converter_conversep: \"rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> = (rel_converter A B C R)\\<inverse>\\<inverse>\"", "lemma rel_converter_map_converter'1:\n  \"rel_converter A B C R (map_converter' f g conv1) conv2 = rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1 conv2\"\n  (is \"?lhs = ?rhs\")", "lemma rel_converter_map_converter'2:\n  \"rel_converter A B C R conv1 (map_converter' f g conv2) = rel_converter A (\\<lambda>x y. B x (f y)) (\\<lambda>x y. C x (g y)) R conv1 conv2\"", "lemmas converter_rel_map' = rel_converter_map_converter'1[abs_def] rel_converter_map_converter'2", "lemma rel_converter_pos_distr [relator_distr]:\n  \"rel_converter A B C R OO rel_converter A' B' C' R' \\<le> rel_converter (A OO A') (B OO B') (C OO C') (R OO R')\"", "lemma left_unique_rel_converter:\n  \"\\<lbrakk> left_total A; left_unique B; left_unique C; left_total R \\<rbrakk> \\<Longrightarrow> left_unique (rel_converter A B C R)\"", "lemma right_unique_rel_converter:\n  \"\\<lbrakk> right_total A; right_unique B; right_unique C; right_total R \\<rbrakk> \\<Longrightarrow> right_unique (rel_converter A B C R)\"", "lemma bi_unique_rel_converter [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique B; bi_unique C; bi_total R \\<rbrakk> \\<Longrightarrow> bi_unique (rel_converter A B C R)\"", "lemma rel_witness_converter_sel [simp]:\n  \"run_converter (rel_witness_converter A A' B C R R' (conv1, conv2)) =\n   map_gpv (map_prod id (rel_witness_converter A A' B C R R') \\<circ> rel_witness_prod) id \\<circ> \n   rel_witness_gpv (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R R' \\<circ> \n   rel_witness_fun A A' (run_converter conv1, run_converter conv2)\"", "lemma assumes \"rel_converter (A OO A') B C (R OO R') conv conv'\"\n  and A: \"left_unique A\" \"right_total A\"\n  and A': \"right_unique A'\" \"left_total A'\"\n  and R: \"left_unique R\" \"right_total R\"\n  and R': \"right_unique R'\" \"left_total R'\"\nshows rel_witness_converter1: \"rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c) (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv (rel_witness_converter A A' B C R R' (conv, conv'))\" (is \"?thesis1\")\n  and rel_witness_converter2: \"rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c') (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' (rel_witness_converter A A' B C R R' (conv, conv')) conv'\" (is \"?thesis2\")", "lemma rel_converter_neg_distr [relator_distr]:\n  assumes A: \"left_unique A\" \"right_total A\"\n    and A': \"right_unique A'\" \"left_total A'\"\n    and R: \"left_unique R\" \"right_total R\"\n    and R': \"right_unique R'\" \"left_total R'\"\n  shows \"rel_converter (A OO A') (B OO B') (C OO C') (R OO R') \\<le> rel_converter A B C R OO rel_converter A' B' C' R'\"", "lemma left_total_rel_converter:\n  \"\\<lbrakk> left_unique A; right_total A; left_total B; left_total C; left_unique R; right_total R \\<rbrakk>\n  \\<Longrightarrow> left_total (rel_converter A B C R)\"", "lemma right_total_rel_converter:\n  \"\\<lbrakk> right_unique A; left_total A; right_total B; right_total C; right_unique R; left_total R \\<rbrakk>\n   \\<Longrightarrow> right_total (rel_converter A B C R)\"", "lemma bi_total_rel_converter [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique A; bi_total B; bi_total C; bi_total R; bi_unique R \\<rbrakk> \n  \\<Longrightarrow> bi_total (rel_converter A B C R)\"", "lemma pred_gpv'_mono_weak: (* TODO: Generalize to R' \\<subseteq> R *)\n  \"pred_gpv' A C R \\<le> pred_gpv' A' C' R\" if \"A \\<le> A'\" \"C \\<le> C'\"", "lemma Domainp_rel_converter_le:\n  \"Domainp (rel_converter A B C R) \\<le> pred_converter (Collect (Domainp A)) (Domainp B) (Domainp C) (Collect (Domainp R))\"\n  (is \"?lhs \\<le> ?rhs\")", "lemma rel_converter_Grp:\n  \"rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g) (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> =\n   BNF_Def.Grp {conv. results_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv \\<subseteq> B \\<and> \n    outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv \\<subseteq> C}\n    (map_converter f g h k)\"\n  (is \"?lhs = ?rhs\")", "lemma Converter_parametric [transfer_rule]:\n  \"((A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) ===> rel_converter A B C R) Converter Converter\"", "lemma run_converter_parametric [transfer_rule]:\n  \"(rel_converter A B C R ===> A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n  run_converter run_converter\"", "lemma corec_converter_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S)) C R) ===> S ===> rel_converter A B C R)\n   corec_converter corec_converter\"", "lemma map_converter_parametric [transfer_rule]:\n  \"((A' ===> A) ===> (B ===> B') ===> (C ===> C') ===> (R' ===> R) ===> rel_converter A B C R ===> rel_converter A' B' C' R')\n  map_converter map_converter\"", "lemma map_converter'_parametric [transfer_rule]:\n  \"((B ===> B') ===> (C ===> C') ===> rel_converter (=) B C (=) ===> rel_converter (=) B' C' (=))\n  map_converter' map_converter'\"", "lemma case_converter_parametric [transfer_rule]:\n  \"(((A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) ===> X) ===> rel_converter A B C R ===> X)\n  case_converter case_converter\"", "lemma WT_converter_coinduct[consumes 1, case_names WT_converter, case_conclusion WT_converter WT_gpv results_gpv, coinduct pred: WT_converter]:\n  assumes \"X conv\"\n    and \"\\<And>conv q r conv'. \\<lbrakk> X conv; q \\<in> outs_\\<I> \\<I> \\<rbrakk>\n  \\<Longrightarrow> \\<I>' \\<turnstile>g run_converter conv q \\<surd> \\<and>\n      ((r, conv') \\<in> results_gpv \\<I>' (run_converter conv q) \\<longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> (X conv' \\<or> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"", "lemma WT_converterD:\n  assumes \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"q \\<in> outs_\\<I> \\<I>\"\n  shows WT_converterD_WT: \"\\<I>' \\<turnstile>g run_converter conv q \\<surd>\"\n    and WT_converterD_results: \"(r, conv') \\<in> results_gpv \\<I>' (run_converter conv q) \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>\"", "lemma WT_converterD':\n  assumes \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"q \\<in> outs_\\<I> \\<I>\"\n  shows \"\\<I>' \\<turnstile>g run_converter conv q \\<surd> \\<and> (\\<forall>(r, conv') \\<in> results_gpv \\<I>' (run_converter conv q). r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)\"", "lemma WT_converter_bot1 [simp]: \"bot, \\<I> \\<turnstile>\\<^sub>C conv \\<surd>\"", "lemma WT_converter_mono: \n  \"\\<lbrakk> \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>; \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2' \\<rbrakk>  \\<Longrightarrow> \\<I>1',\\<I>2' \\<turnstile>\\<^sub>C conv \\<surd> \"", "lemma callee_invariant_on_run_resource [simp]: \"callee_invariant_on run_resource (WT_resource \\<I>) \\<I>\"", "lemma raw_converter_invariant_run_converter: \"raw_converter_invariant \\<I> \\<I>' run_converter (WT_converter \\<I> \\<I>')\"", "lemma WT_converter_\\<I>_full: \"\\<I>_full, \\<I>_full \\<turnstile>\\<^sub>C conv \\<surd>\"", "lemma WT_converter_map_converter [WT_intro]:\n  \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv \\<surd>\" if \n  *: \"map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"\n  and f: \"inj f\" and g: \"surj g\"", "lemma plossless_converter_coinduct[consumes 1, case_names plossless_converter, case_conclusion plossless_converter plossless step, coinduct pred: plossless_converter]:\n  assumes \"X conv\"\n    and step: \"\\<And>conv a. \\<lbrakk> X conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). X conv' \\<or> plossless_converter \\<I> \\<I>' conv')\"\n  shows \"plossless_converter \\<I> \\<I>' conv\"", "lemma plossless_converterD:\n  \"\\<lbrakk> plossless_converter \\<I> \\<I>' conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \n  \\<Longrightarrow> plossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). plossless_converter \\<I> \\<I>' conv')\"", "lemma plossless_converter_bot1 [simp]: \"plossless_converter bot \\<I> conv\"", "lemma plossless_converter_mono:\n  assumes *: \"plossless_converter \\<I>1 \\<I>2 conv\"\n    and le: \"outs_\\<I> \\<I>1' \\<subseteq> outs_\\<I> \\<I>1\" \"\\<I>2 \\<le> \\<I>2'\"\n    and WT: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"plossless_converter \\<I>1' \\<I>2' conv\"", "lemma raw_converter_invariant_run_plossless_converter: \"raw_converter_invariant \\<I> \\<I>' run_converter (\\<lambda>conv. plossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)\"", "lemma converter_of_callee_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((S ===> A ===> rel_gpv'' (rel_prod B S) C R) ===> S ===> rel_converter A B C R)\n  converter_of_callee converter_of_callee\"", "lemma map_converter_of_callee:\n  \"map_converter f g h k (converter_of_callee callee s) =\n   converter_of_callee (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee) s\"", "lemma WT_converter_of_callee:\n  assumes WT: \"\\<And>s q. q \\<in> outs_\\<I> \\<I> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s q \\<surd>\"\n    and res: \"\\<And>s q r s'. \\<lbrakk> q \\<in> outs_\\<I> \\<I>; (r, s') \\<in> results_gpv \\<I>' (callee s q) \\<rbrakk> \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_callee callee s \\<surd>\"", "lemma parallel_callee_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter A' B' C R ===> rel_converter (rel_sum A A') (rel_sum B B') C R)\n   parallel_converter parallel_converter\"", "lemma parallel_converter_assoc:\n  \"parallel_converter (parallel_converter conv1 conv2) conv3 =\n   map_converter rsuml lsumr id id (parallel_converter conv1 (parallel_converter conv2 conv3))\"", "lemma plossless_parallel_converter [plossless_intro]:\n  \"\\<lbrakk> plossless_converter \\<I>1 \\<I> conv1; plossless_converter \\<I>2 \\<I> conv2; \\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<surd>; \\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<surd> \\<rbrakk>\n  \\<Longrightarrow> plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<I> (parallel_converter conv1 conv2)\"", "lemma id_converter_parametric [transfer_rule]: \"rel_converter A B A B id_converter id_converter\"", "lemma converter_of_callee_id_oracle [simp]:\n  \"converter_of_callee id_oracle s = id_converter\"", "lemma conv_callee_plus_id_left: \"converter_of_callee (plus_intercept id_oracle callee) s =\n  parallel_converter id_converter (converter_of_callee callee s) \"", "lemma conv_callee_plus_id_right: \"converter_of_callee (plus_intercept callee id_oracle) s =\n  parallel_converter (converter_of_callee callee s) id_converter\"", "lemma plossless_id_converter [simp, plossless_intro]: \"plossless_converter \\<I> \\<I> id_converter\"", "lemma WT_converter_id [simp, intro, WT_intro]: \"\\<I>, \\<I> \\<turnstile>\\<^sub>C id_converter \\<surd>\"", "lemma WT_map_converter_idD:\n  \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C map_converter id id f g id_converter \\<surd> \\<Longrightarrow> \\<I> \\<le> map_\\<I> f g \\<I>'\"", "lemma fail_converter_sel [simp]: \"run_converter fail_converter a = Fail\"", "lemma fail_converter_parametric [transfer_rule]: \"rel_converter A B C R fail_converter fail_converter\"", "lemma plossless_fail_converter [simp]: \"plossless_converter \\<I> \\<I>' fail_converter \\<longleftrightarrow> \\<I> = bot\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma plossless_fail_converterI [plossless_intro]: \"plossless_converter bot \\<I>' fail_converter\"", "lemma WT_fail_converter [simp, WT_intro]: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C fail_converter \\<surd>\"", "lemma map_converter_id_move_left:\n  \"map_converter f g f' g' id_converter = map_converter (f' \\<circ> f) (g \\<circ> g') id id id_converter\"", "lemma map_converter_id_move_right:\n  \"map_converter f g f' g' id_converter = map_converter id id (f' \\<circ> f) (g \\<circ> g') id_converter\"", "lemma parallel_converter2_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter A' B' C' R' \n   ===> rel_converter (rel_sum A A') (rel_sum B B') (rel_sum C C') (rel_sum R R'))\n  parallel_converter2 parallel_converter2\"", "lemma map_converter_parallel_converter2:\n  \"map_converter (map_sum f f') (map_sum g g') (map_sum h h') (map_sum k k') (parallel_converter2 conv1 conv2) =\n   parallel_converter2 (map_converter f g h k conv1) (map_converter f' g' h' k' conv2)\"", "lemma WT_converter_parallel_converter2 [WT_intro]:\n  assumes \"\\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n    and \"\\<I>1',\\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n  shows \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C parallel_converter2 conv1 conv2 \\<surd>\"", "lemma plossless_parallel_converter2 [plossless_intro]:\n  assumes \"plossless_converter \\<I>1 \\<I>1' conv1\"\n    and \"plossless_converter \\<I>2 \\<I>2' conv2\"\n  shows \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (parallel_converter2 conv1 conv2)\"", "lemma parallel_converter2_map1_out:\n  \"parallel_converter2 (map_converter f g h k conv1) conv2 =\n   map_converter (map_sum f id) (map_sum g id) (map_sum h id) (map_sum k id) (parallel_converter2 conv1 conv2)\"", "lemma parallel_converter2_map2_out:\n  \"parallel_converter2 conv1 (map_converter f g h k conv2) =\n   map_converter (map_sum id f) (map_sum id g) (map_sum id h) (map_sum id k) (parallel_converter2 conv1 conv2)\"", "lemma left_interface_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter A B (rel_sum C C') (rel_sum R R')) left_interface left_interface\"", "lemma right_interface_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C' R' ===> rel_converter A B (rel_sum C C') (rel_sum R R')) right_interface right_interface\"", "lemma parallel_converter2_alt_def:\n  \"parallel_converter2 conv1 conv2 = parallel_converter (left_interface conv1) (right_interface conv2)\"", "lemma conv_callee_parallel_id_left: \"converter_of_callee (parallel_intercept id_oracle callee) (s, s') =\n  parallel_converter2 (id_converter) (converter_of_callee callee s')\"", "lemma conv_callee_parallel_id_right: \"converter_of_callee (parallel_intercept callee id_oracle) (s, s') =\n  parallel_converter2 (converter_of_callee callee s) (id_converter)\"", "lemma conv_callee_parallel: \"converter_of_callee (parallel_intercept callee1 callee2) (s,s') \n  = parallel_converter2 (converter_of_callee callee1 s) (converter_of_callee callee2 s')\"", "lemma WT_converter_parallel_converter [WT_intro]:\n  assumes \"\\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n    and \"\\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n  shows \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I> \\<turnstile>\\<^sub>C parallel_converter conv1 conv2 \\<surd>\"", "lemma WT_converter_of_resource [WT_intro]:\n  assumes \"\\<I> \\<turnstile>res res \\<surd>\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_resource res \\<surd>\"", "lemma plossless_converter_of_resource [plossless_intro]:\n  assumes \"lossless_resource \\<I> res\"\n  shows \"plossless_converter \\<I> \\<I>' (converter_of_resource res)\"", "lemma plossless_converter_of_callee:\n  assumes \"\\<And>s x. x \\<in> outs_\\<I> \\<I>1 \\<Longrightarrow> plossless_gpv \\<I>2 (callee s x) \\<and> (\\<forall>(y, s')\\<in>results_gpv \\<I>2 (callee s x). y \\<in> responses_\\<I> \\<I>1 x)\"\n  shows \"plossless_converter \\<I>1 \\<I>2 (converter_of_callee callee s)\"", "lemma WT_restrict_converter [WT_intro]:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<surd>\"", "lemma pgen_lossless_restrict_gpv [simp]:\n  \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> pgen_lossless_gpv b \\<I> (restrict_gpv \\<I> gpv) = pgen_lossless_gpv b \\<I> gpv\"", "lemma plossless_restrict_converter [simp]:\n  assumes \"plossless_converter \\<I> \\<I>' conv\"\n    and \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"\n    and \"outs_\\<I> \\<I> \\<subseteq> A\"\n  shows \"plossless_converter \\<I> \\<I>' (restrict_converter A \\<I>' conv)\"", "lemma plossless_map_converter:\n  \"plossless_converter \\<I> \\<I>' (map_converter f g h k conv)\"\n  if \"plossless_converter (map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>) (map_\\<I> h k \\<I>') conv\" \"inj f\"", "lemma attach_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_resource C R ===> rel_resource A B) attach attach\"", "lemma attach_map_converter:\n  \"attach (map_converter f g h k conv) res = map_resource f g (attach conv (map_resource h k res))\"", "lemma WT_resource_attach [WT_intro]: \"\\<lbrakk> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>; \\<I>' \\<turnstile>res res \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I> \\<turnstile>res attach conv res \\<surd>\"", "lemma lossless_attach [plossless_intro]:\n  assumes \"plossless_converter \\<I> \\<I>' conv\"\n    and \"lossless_resource \\<I>' res\"\n    and \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"\\<I>' \\<turnstile>res res \\<surd>\"\n  shows \"lossless_resource \\<I> (attach conv res)\"", "lemma attach_callee_simps [simp]:\n  \"attach_callee callee oracle (s, s') q = map_spmf rprodl (exec_gpv oracle (callee s q) s')\"", "lemma attach_CNV_RES:\n  \"attach (converter_of_callee callee s) (resource_of_oracle res s') = \n   resource_of_oracle (attach_callee callee res) (s, s')\"", "lemma attach_stateless_callee:\n  \"attach_callee (stateless_callee callee) oracle = extend_state_oracle (\\<lambda>s q. exec_gpv oracle (callee q) s)\"", "lemma attach_id_converter [simp]: \"attach id_converter res = res\"", "lemma attach_callee_parallel_intercept: includes lifting_syntax shows\n  \"attach_callee (parallel_intercept callee1 callee2) (plus_oracle oracle1 oracle2) =\n   (rprodl ---> id ---> map_spmf (map_prod id lprodr)) (plus_oracle (lift_state_oracle extend_state_oracle (attach_callee callee1 oracle1)) (extend_state_oracle (attach_callee callee2 oracle2)))\"", "lemma attach_callee_id_oracle [simp]:\n  \"attach_callee id_oracle oracle = extend_state_oracle oracle\"", "lemma attach_parallel2: \"attach (parallel_converter2 conv1 conv2) (parallel_resource res1 res2)\n  = parallel_resource (attach conv1 res1) (attach conv2 res2)\"", "lemma comp_converter_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter C R C' R' ===> rel_converter A B C' R')\n  comp_converter comp_converter\"", "lemma comp_converter_map_converter1:\n  fixes conv' :: \"('a, 'b, 'out, 'in) converter\" shows\n    \"comp_converter (map_converter f g h k conv) conv' = map_converter f g id id (comp_converter conv (map_converter h k id id conv'))\"", "lemma comp_converter_map_converter2:\n  fixes conv :: \"('a, 'b, 'out, 'in) converter\" shows\n    \"comp_converter conv (map_converter f g h k conv') = map_converter id id h k (comp_converter (map_converter id id f g conv) conv')\"", "lemma attach_compose:\n  \"attach (comp_converter conv1 conv2) res = attach conv1 (attach conv2 res)\"", "lemma comp_converter_assoc:\n  \"comp_converter (comp_converter conv1 conv2) conv3 = comp_converter conv1 (comp_converter conv2 conv3)\"", "lemma comp_converter_assoc_left:\n  assumes \"comp_converter conv1 conv2 = conv3\"\n  shows \"comp_converter conv1 (comp_converter conv2 conv) = comp_converter conv3 conv\"", "lemma comp_converter_attach_left:\n  assumes \"comp_converter conv1 conv2 = conv3\"\n  shows \"attach conv1 (attach conv2 res) = attach conv3 res\"", "lemmas comp_converter_eqs = \n  asm_rl[where psi=\"x = y\" for x y :: \"(_, _, _, _) converter\"]\n  comp_converter_assoc_left\n  comp_converter_attach_left", "lemma WT_converter_comp [WT_intro]:\n  \"\\<lbrakk> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>; \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I>, \\<I>'' \\<turnstile>\\<^sub>C comp_converter conv conv' \\<surd>\"", "lemma plossless_comp_converter [plossless_intro]:\n  assumes \"plossless_converter \\<I> \\<I>' conv\"\n    and \"plossless_converter \\<I>' \\<I>'' conv'\"\n    and \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\"\n  shows \"plossless_converter \\<I> \\<I>'' (comp_converter conv conv')\"", "lemma comp_converter_id_left: \"comp_converter id_converter conv = conv\"", "lemma comp_converter_id_right: \"comp_converter conv id_converter = conv\"", "lemma comp_coverter_of_callee: \"comp_converter (converter_of_callee callee1 s1) (converter_of_callee callee2 s2)\n  = converter_of_callee (\\<lambda>(s1, s2) q. map_gpv rprodl id (inline callee2 (callee1 s1 q) s2)) (s1, s2)\"", "lemmas comp_converter_of_callee' = comp_converter_eqs[OF comp_coverter_of_callee]", "lemma comp_converter_parallel2: \"comp_converter (parallel_converter2 conv1l conv1r) (parallel_converter2 conv2l conv2r) =\n  parallel_converter2 (comp_converter conv1l conv2l) (comp_converter conv1r conv2r)\"", "lemmas comp_converter_parallel2' = comp_converter_eqs[OF comp_converter_parallel2]", "lemma comp_converter_map1_out:\n  \"comp_converter (map_converter f g id id conv) conv' = map_converter f g id id (comp_converter conv conv')\"", "lemma parallel_converter2_comp1_out:\n  \"parallel_converter2 (comp_converter conv conv') conv'' = comp_converter (parallel_converter2 conv id_converter) (parallel_converter2 conv' conv'')\"", "lemma parallel_converter2_comp2_out:\n  \"parallel_converter2 conv'' (comp_converter conv conv') = comp_converter (parallel_converter2 id_converter conv) (parallel_converter2 conv'' conv')\"", "lemma interaction_any_bounded_converterD:\n  assumes \"interaction_any_bounded_converter conv n\"\n  shows \"interaction_any_bounded_by (run_converter conv a) n \\<and> (\\<forall>(b, conv')\\<in>results'_gpv (run_converter conv a). interaction_any_bounded_converter conv' n)\"", "lemma interaction_any_bounded_converter_mono:\n  assumes \"interaction_any_bounded_converter conv n\"\n    and \"n \\<le> m\"\n  shows \"interaction_any_bounded_converter conv m\"", "lemma interaction_any_bounded_converter_trivial [simp]: \"interaction_any_bounded_converter conv \\<infinity>\"", "lemmas interaction_any_bounded_converter_start = \n  interaction_any_bounded_converter_mono\n  interaction_bounded_by_mono", "lemma interaction_any_bounded_converter_id [interaction_bound]:\n  \"interaction_any_bounded_converter id_converter 1\"", "lemma raw_converter_invariant_interaction_any_bounded_converter:\n  \"raw_converter_invariant \\<I>_full \\<I>_full run_converter (\\<lambda>conv. interaction_any_bounded_converter conv n)\"", "lemma interaction_bounded_by_left_gpv [interaction_bound]:\n  assumes \"interaction_bounded_by consider gpv n\"\n    and \"\\<And>x. consider' (Inl x) \\<Longrightarrow> consider x\"\n  shows \"interaction_bounded_by consider' (left_gpv gpv) n\"", "lemma interaction_bounded_by_right_gpv [interaction_bound]:\n  assumes \"interaction_bounded_by consider gpv n\"\n    and \"\\<And>x. consider' (Inr x) \\<Longrightarrow> consider x\"\n  shows \"interaction_bounded_by consider' (right_gpv gpv) n\"", "lemma interaction_any_bounded_converter_parallel_converter2:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 n\"\n  shows \"interaction_any_bounded_converter (parallel_converter2 conv1 conv2) n\"", "lemma interaction_any_bounded_converter_parallel_converter2' [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 m\"\n  shows \"interaction_any_bounded_converter (parallel_converter2 conv1 conv2) (max n m)\"", "lemma interaction_any_bounded_converter_compose [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 m\"\n  shows \"interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)\"", "lemma interaction_any_bounded_converter_of_callee [interaction_bound]:\n  assumes \"\\<And>s x. interaction_any_bounded_by (conv s x) n\"\n  shows \"interaction_any_bounded_converter (converter_of_callee conv s) n\"", "lemma interaction_any_bounded_converter_map_converter [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv n\"\n    and \"surj k\"\n  shows \"interaction_any_bounded_converter (map_converter f g h k conv) n\"", "lemma interaction_any_bounded_converter_parallel_converter:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 n\"\n  shows \"interaction_any_bounded_converter (parallel_converter conv1 conv2) n\"", "lemma interaction_any_bounded_converter_parallel_converter' [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 m\"\n  shows \"interaction_any_bounded_converter (parallel_converter conv1 conv2) (max n m)\"", "lemma interaction_any_bounded_converter_converter_of_resource:\n  \"interaction_any_bounded_converter (converter_of_resource res) n\"", "lemma interaction_any_bounded_converter_converter_of_resource' [interaction_bound]:\n  \"interaction_any_bounded_converter (converter_of_resource res) 0\"", "lemma interaction_any_bounded_converter_restrict_converter [interaction_bound]:\n  \"interaction_any_bounded_converter (restrict_converter A \\<I> cnv) bound\"\n  if \"interaction_any_bounded_converter cnv bound\""], "translations": [["", "lemma case_converter_conv_run_converter: \"case_converter f conv = f (run_converter conv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case conv of Converter x \\<Rightarrow> f x) = f (run_converter conv)", "by(fact converter.case_eq_if)"], ["", "subsection \\<open>Functor\\<close>"], ["", "context \n  fixes a :: \"'a \\<Rightarrow> 'a'\"\n    and b :: \"'b \\<Rightarrow> 'b'\"\n    and out :: \"'out \\<Rightarrow> 'out'\"\n    and \"inn\" :: \"'in \\<Rightarrow> 'in'\"\nbegin"], ["", "primcorec map_converter :: \"('a', 'b, 'out, 'in') converter \\<Rightarrow> ('a, 'b', 'out', 'in) converter\" where\n  \"run_converter (map_converter conv) = \n   map_gpv (map_prod b map_converter) out \\<circ> map_gpv' id id inn \\<circ> run_converter conv \\<circ> a\""], ["", "lemma map_converter_sel [simp]:\n  \"run_converter (map_converter conv) a' = map_gpv' (map_prod b map_converter) out inn (run_converter conv (a a'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter (local.map_converter conv) a' =\n    map_gpv' (map_prod b local.map_converter) out inn\n     (run_converter conv (a a'))", "by(simp add: map_gpv_conv_map_gpv' map_gpv'_comp)"], ["", "declare map_converter.sel [simp del]"], ["", "lemma map_converter_ctr [simp, code]:\n  \"map_converter (Converter f) = Converter (map_fun a (map_gpv' (map_prod b map_converter) out inn) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map_converter (Converter f) =\n    Converter\n     (map_fun a (map_gpv' (map_prod b local.map_converter) out inn) f)", "by(rule converter.expand; simp add: fun_eq_iff)"], ["", "end"], ["", "lemma map_converter_id14: \"map_converter id b out id res = map_converter' b out res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id b out id res = map_converter' b out res", "by(coinduction arbitrary: res)\n    (auto 4 3 intro!: rel_funI simp add: converter.map_sel gpv.rel_map map_gpv_conv_map_gpv'[symmetric] intro!: gpv.rel_refl_strong)"], ["", "lemma map_converter_id [simp]: \"map_converter id id id id conv = conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id id id conv = conv", "by(simp add: map_converter_id14 converter.map_id)"], ["", "lemma map_converter_compose [simp]:\n  \"map_converter a b f g (map_converter a' b' f' g' conv) = map_converter (a' \\<circ> a) (b \\<circ> b') (f \\<circ> f') (g' \\<circ> g) conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter a b f g (map_converter a' b' f' g' conv) =\n    map_converter (a' \\<circ> a) (b \\<circ> b') (f \\<circ> f')\n     (g' \\<circ> g) conv", "by(coinduction arbitrary: conv)\n    (auto 4 3 intro!: rel_funI gpv.rel_refl_strong simp add: rel_gpv_map_gpv' map_gpv'_comp o_def prod.map_comp)"], ["", "functor converter: map_converter"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g h i j k l m.\n        map_converter f g h i \\<circ> map_converter j k l m =\n        map_converter (j \\<circ> f) (g \\<circ> k) (h \\<circ> l)\n         (m \\<circ> i)) &&&\n    map_converter id id id id = id", "by(simp_all add: o_def fun_eq_iff)"], ["", "subsection \\<open>Set functions with interfaces\\<close>"], ["", "context fixes \\<I> :: \"('a, 'b) \\<I>\" and \\<I>' :: \"('out, 'in) \\<I>\" begin"], ["", "qualified"], ["", "inductive outsp_converter :: \"'out \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<Rightarrow> bool\" for out where\n  Out: \"outsp_converter out conv\" if \"out \\<in> outs_gpv \\<I>' (run_converter conv a)\" \"a \\<in> outs_\\<I> \\<I>\"\n| Cont: \"outsp_converter out conv\" \nif \"(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a)\" \"outsp_converter out conv'\" \"a \\<in> outs_\\<I> \\<I>\""], ["", "definition outs_converter :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> 'out set\"\n  where \"outs_converter conv \\<equiv> {x. outsp_converter x conv}\""], ["", "qualified"], ["", "inductive resultsp_converter :: \"'b \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<Rightarrow> bool\" for b where\n  Result: \"resultsp_converter b conv\"\nif \"(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a)\" \"a \\<in> outs_\\<I> \\<I>\"\n| Cont: \"resultsp_converter b conv\"\nif \"(b', conv') \\<in> results_gpv \\<I>' (run_converter conv a)\" \"resultsp_converter b conv'\" \"a \\<in> outs_\\<I> \\<I>\""], ["", "definition results_converter :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> 'b set\"\n  where \"results_converter conv = {b. resultsp_converter b conv}\""], ["", "end"], ["", "lemma outsp_converter_outs_converter_eq [pred_set_conv]: \"Converter.outsp_converter \\<I> \\<I>' x = (\\<lambda>conv. x \\<in> outs_converter \\<I> \\<I>' conv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Converter.outsp_converter \\<I> \\<I>' x =\n    (\\<lambda>conv. x \\<in> outs_converter \\<I> \\<I>' conv)", "by(simp add: outs_converter_def)"], ["", "context begin"], ["", "local_setup \\<open>Local_Theory.map_background_naming (Name_Space.mandatory_path \"outs_converter\")\\<close>"], ["", "lemmas intros [intro?] = outsp_converter.intros[to_set]\n  and Out = outsp_converter.Out[to_set]\n  and Cont = outsp_converter.Cont[to_set]\n  and induct [consumes 1, case_names Out Cont, induct set: outs_converter] = outsp_converter.induct[to_set]\n  and cases [consumes 1, case_names Out Cont, cases set: outs_converter] = outsp_converter.cases[to_set]\n  and simps = outsp_converter.simps[to_set]"], ["", "end"], ["", "inductive_simps outs_converter_Converter [to_set, simp]: \"Converter.outsp_converter \\<I> \\<I>' x (Converter conv)\""], ["", "lemma resultsp_converter_results_converter_eq [pred_set_conv]:\n  \"Converter.resultsp_converter \\<I> \\<I>' x = (\\<lambda>conv. x \\<in> results_converter \\<I> \\<I>' conv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Converter.resultsp_converter \\<I> \\<I>' x =\n    (\\<lambda>conv. x \\<in> results_converter \\<I> \\<I>' conv)", "by(simp add: results_converter_def)"], ["", "context begin"], ["", "local_setup \\<open>Local_Theory.map_background_naming (Name_Space.mandatory_path \"results_converter\")\\<close>"], ["", "lemmas intros [intro?] = resultsp_converter.intros[to_set]\n  and Result = resultsp_converter.Result[to_set]\n  and Cont = resultsp_converter.Cont[to_set]\n  and induct [consumes 1, case_names Result Cont, induct set: results_converter] = resultsp_converter.induct[to_set]\n  and cases [consumes 1, case_names Result Cont, cases set: results_converter] = resultsp_converter.cases[to_set]\n  and simps = resultsp_converter.simps[to_set]"], ["", "end"], ["", "inductive_simps results_converter_Converter [to_set, simp]: \"Converter.resultsp_converter \\<I> \\<I>' x (Converter conv)\""], ["", "subsection \\<open>Relator\\<close>"], ["", "coinductive rel_converter \n  :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('c \\<Rightarrow> 'd \\<Rightarrow> bool) \\<Rightarrow> ('out \\<Rightarrow> 'out' \\<Rightarrow> bool) \\<Rightarrow> ('in \\<Rightarrow> 'in' \\<Rightarrow> bool) \n  \\<Rightarrow> ('a, 'c, 'out, 'in) converter \\<Rightarrow> ('b, 'd, 'out', 'in') converter \\<Rightarrow> bool\"\n  for A B C R where\n    rel_converterI:\n    \"rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) (run_converter conv1) (run_converter conv2) \n  \\<Longrightarrow> rel_converter A B C R conv1 conv2\""], ["", "lemma rel_converter_coinduct [consumes 1, case_names rel_converter, coinduct pred: rel_converter]:\n  assumes \"X conv1 conv2\"\n    and \"\\<And>conv1 conv2. X conv1 conv2 \\<Longrightarrow>\n         rel_fun A (rel_gpv'' (rel_prod B (\\<lambda>conv1 conv2. X conv1 conv2 \\<or> rel_converter A B C R conv1 conv2)) C R)\n            (run_converter conv1) (run_converter conv2)\"\n  shows \"rel_converter A B C R conv1 conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R conv1 conv2", "using assms(1)"], ["proof (prove)\nusing this:\n  X conv1 conv2\n\ngoal (1 subgoal):\n 1. rel_converter A B C R conv1 conv2", "by(rule rel_converter.coinduct)(simp add: assms(2))"], ["", "lemma rel_converter_simps [simp, code]:\n  \"rel_converter A B C R (Converter f) (Converter g) \\<longleftrightarrow> \n  rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R (Converter f) (Converter g) =\n    rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) f g", "by(subst rel_converter.simps) simp"], ["", "lemma rel_converterD:\n  \"rel_converter A B C R conv1 conv2 \n  \\<Longrightarrow> rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) (run_converter conv1) (run_converter conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R conv1 conv2 \\<Longrightarrow>\n    rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n     (run_converter conv1) (run_converter conv2)", "by(blast elim: rel_converter.cases)"], ["", "lemma rel_converter_eq14: \"rel_converter (=) B C (=) = rel_converter' B C\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter (=) B C (=) = rel_converter' B C", "proof(intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_converter (=) B C (=) x xa \\<Longrightarrow>\n       rel_converter' B C x xa\n 2. \\<And>x xa.\n       rel_converter' B C x xa \\<Longrightarrow>\n       rel_converter (=) B C (=) x xa", "show \"?rhs conv1 conv2\" if \"?lhs conv1 conv2\" for conv1 conv2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter' B C conv1 conv2", "using that"], ["proof (prove)\nusing this:\n  rel_converter (=) B C (=) conv1 conv2\n\ngoal (1 subgoal):\n 1. rel_converter' B C conv1 conv2", "by(coinduction arbitrary: conv1 conv2)(auto elim: rel_converter.cases simp add: rel_gpv_conv_rel_gpv'')"], ["proof (state)\nthis:\n  rel_converter (=) B C (=) ?conv1.0 ?conv2.0 \\<Longrightarrow>\n  rel_converter' B C ?conv1.0 ?conv2.0\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_converter' B C x xa \\<Longrightarrow>\n       rel_converter (=) B C (=) x xa", "show \"?lhs conv1 conv2\" if \"?rhs conv1 conv2\" for conv1 conv2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter (=) B C (=) conv1 conv2", "using that"], ["proof (prove)\nusing this:\n  rel_converter' B C conv1 conv2\n\ngoal (1 subgoal):\n 1. rel_converter (=) B C (=) conv1 conv2", "by(coinduction arbitrary: conv1 conv2)\n      (auto 4 4 elim: converter.rel_cases intro: gpv.rel_mono_strong simp add: rel_fun_def rel_gpv_conv_rel_gpv''[symmetric])"], ["proof (state)\nthis:\n  rel_converter' B C ?conv1.0 ?conv2.0 \\<Longrightarrow>\n  rel_converter (=) B C (=) ?conv1.0 ?conv2.0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_converter_eq [relator_eq]: \"rel_converter (=) (=) (=) (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter (=) (=) (=) (=) = (=)", "by(simp add: rel_converter_eq14 converter.rel_eq)"], ["", "lemma rel_converter_mono [relator_mono]:\n  assumes \"A' \\<le> A\" \"B \\<le> B'\" \"C \\<le> C'\" \"R' \\<le> R\"\n  shows \"rel_converter A B C R \\<le> rel_converter A' B' C' R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R \\<le> rel_converter A' B' C' R'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_converter A B C R x y \\<Longrightarrow>\n       rel_converter A' B' C' R' x y", "show \"rel_converter A' B' C' R' conv1 conv2\" if \"rel_converter A B C R conv1 conv2\" for conv1 conv2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A' B' C' R' conv1 conv2", "using that"], ["proof (prove)\nusing this:\n  rel_converter A B C R conv1 conv2\n\ngoal (1 subgoal):\n 1. rel_converter A' B' C' R' conv1 conv2", "by(coinduct)(auto dest: rel_converterD elim!: rel_gpv''_mono[THEN predicate2D, rotated -1] prod.rel_mono_strong rel_fun_mono intro: assms[THEN predicate2D])"], ["proof (state)\nthis:\n  rel_converter A B C R ?conv1.0 ?conv2.0 \\<Longrightarrow>\n  rel_converter A' B' C' R' ?conv1.0 ?conv2.0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_converter_conversep: \"rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> = (rel_converter A B C R)\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n     C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> =\n    (rel_converter A B C R)\\<inverse>\\<inverse>", "proof(intro ext iffI; simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n        C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> x xa \\<Longrightarrow>\n       rel_converter A B C R xa x\n 2. \\<And>x xa.\n       rel_converter A B C R xa x \\<Longrightarrow>\n       rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n        C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> x xa", "show \"rel_converter A B C R conv1 conv2\" if \"rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2 conv1\"\n    for A :: \"'a1 \\<Rightarrow> 'a2 \\<Rightarrow> bool\" and B :: \"'b1 \\<Rightarrow> 'b2 \\<Rightarrow> bool\" and C :: \"'c1 \\<Rightarrow> 'c2 \\<Rightarrow> bool\" and R :: \"'r1 \\<Rightarrow> 'r2 \\<Rightarrow> bool\"\n      and conv2 conv1"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R conv1 conv2", "using that"], ["proof (prove)\nusing this:\n  rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2 conv1\n\ngoal (1 subgoal):\n 1. rel_converter A B C R conv1 conv2", "apply(coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2.\n       rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n        C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2\n        conv1 \\<Longrightarrow>\n       rel_fun A\n        (rel_gpv''\n          (rel_prod B\n            (\\<lambda>conv1 conv2.\n                rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n                 C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2\n                 conv1 \\<or>\n                rel_converter A B C R conv1 conv2))\n          C R)\n        (run_converter conv1) (run_converter conv2)", "apply(drule rel_converterD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2.\n       rel_fun A\\<inverse>\\<inverse>\n        (rel_gpv''\n          (rel_prod B\\<inverse>\\<inverse>\n            (rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n              C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>))\n          C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>)\n        (run_converter conv2) (run_converter conv1) \\<Longrightarrow>\n       rel_fun A\n        (rel_gpv''\n          (rel_prod B\n            (\\<lambda>conv1 conv2.\n                rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n                 C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2\n                 conv1 \\<or>\n                rel_converter A B C R conv1 conv2))\n          C R)\n        (run_converter conv1) (run_converter conv2)", "apply(rewrite in \\<hole> conversep_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2.\n       rel_fun A\\<inverse>\\<inverse>\n        (rel_gpv''\n          (rel_prod B\\<inverse>\\<inverse>\n            (rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n              C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>))\n          C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>)\n        (run_converter conv2) (run_converter conv1) \\<Longrightarrow>\n       (rel_fun A\n         (rel_gpv''\n           (rel_prod B\n             (\\<lambda>conv1 conv2.\n                 rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n                  C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2\n                  conv1 \\<or>\n                 rel_converter A B C R conv1 conv2))\n           C R))\\<inverse>\\<inverse>\n        (run_converter conv2) (run_converter conv1)", "apply(subst rel_fun_conversep[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2.\n       rel_fun A\\<inverse>\\<inverse>\n        (rel_gpv''\n          (rel_prod B\\<inverse>\\<inverse>\n            (rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n              C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>))\n          C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>)\n        (run_converter conv2) (run_converter conv1) \\<Longrightarrow>\n       rel_fun A\\<inverse>\\<inverse>\n        (rel_gpv''\n          (rel_prod B\n            (\\<lambda>conv1 conv2.\n                rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n                 C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2\n                 conv1 \\<or>\n                rel_converter A B C R conv1 conv2))\n          C R)\\<inverse>\\<inverse>\n        (run_converter conv2) (run_converter conv1)", "apply(subst rel_gpv''_conversep[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2.\n       rel_fun A\\<inverse>\\<inverse>\n        (rel_gpv''\n          (rel_prod B\\<inverse>\\<inverse>\n            (rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n              C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>))\n          C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>)\n        (run_converter conv2) (run_converter conv1) \\<Longrightarrow>\n       rel_fun A\\<inverse>\\<inverse>\n        (rel_gpv''\n          (rel_prod B\n            (\\<lambda>conv1 conv2.\n                rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n                 C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2\n                 conv1 \\<or>\n                rel_converter A B C R conv1 conv2))\\<inverse>\\<inverse>\n          C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>)\n        (run_converter conv2) (run_converter conv1)", "apply(erule rel_fun_mono, blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 x y.\n       rel_gpv''\n        (rel_prod B\\<inverse>\\<inverse>\n          (rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n            C\\<inverse>\\<inverse> R\\<inverse>\\<inverse>))\n        C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> x y \\<Longrightarrow>\n       rel_gpv''\n        (rel_prod B\n          (\\<lambda>conv1 conv2.\n              rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n               C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2 conv1 \\<or>\n              rel_converter A B C R conv1 conv2))\\<inverse>\\<inverse>\n        C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> x y", "by(auto simp add: prod.rel_conversep[symmetric] rel_fun_def conversep_iff[abs_def]\n        elim: prod.rel_mono_strong rel_gpv''_mono[THEN predicate2D, rotated -1])"], ["proof (state)\nthis:\n  rel_converter ?A1\\<inverse>\\<inverse> ?B1\\<inverse>\\<inverse>\n   ?C1\\<inverse>\\<inverse> ?R1\\<inverse>\\<inverse> ?conv2.1\n   ?conv1.1 \\<Longrightarrow>\n  rel_converter ?A1 ?B1 ?C1 ?R1 ?conv1.1 ?conv2.1\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_converter A B C R xa x \\<Longrightarrow>\n       rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n        C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> x xa", "from this[of \"A\\<inverse>\\<inverse>\" \"B\\<inverse>\\<inverse>\" \"C\\<inverse>\\<inverse>\" \"R\\<inverse>\\<inverse>\"]"], ["proof (chain)\npicking this:\n  rel_converter A\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   B\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   R\\<inverse>\\<inverse>\\<inverse>\\<inverse> ?conv2.1\n   ?conv1.1 \\<Longrightarrow>\n  rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> ?conv1.1 ?conv2.1", "show \"rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2 conv1\" if \"rel_converter A B C R conv1 conv2\" for conv1 conv2"], ["proof (prove)\nusing this:\n  rel_converter A\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   B\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   R\\<inverse>\\<inverse>\\<inverse>\\<inverse> ?conv2.1\n   ?conv1.1 \\<Longrightarrow>\n  rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> ?conv1.1 ?conv2.1\n\ngoal (1 subgoal):\n 1. rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n     C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2 conv1", "using that"], ["proof (prove)\nusing this:\n  rel_converter A\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   B\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n   R\\<inverse>\\<inverse>\\<inverse>\\<inverse> ?conv2.1\n   ?conv1.1 \\<Longrightarrow>\n  rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> ?conv1.1 ?conv2.1\n  rel_converter A B C R conv1 conv2\n\ngoal (1 subgoal):\n 1. rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n     C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> conv2 conv1", "by simp"], ["proof (state)\nthis:\n  rel_converter A B C R ?conv1.1 ?conv2.1 \\<Longrightarrow>\n  rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> ?conv2.1 ?conv1.1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_converter_map_converter'1:\n  \"rel_converter A B C R (map_converter' f g conv1) conv2 = rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1 conv2\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R (map_converter' f g conv1) conv2 =\n    rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1\n     conv2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_converter A B C R (map_converter' f g conv1) conv2 \\<Longrightarrow>\n    rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1\n     conv2\n 2. rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1\n     conv2 \\<Longrightarrow>\n    rel_converter A B C R (map_converter' f g conv1) conv2", "show ?rhs if ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1\n     conv2", "using that"], ["proof (prove)\nusing this:\n  rel_converter A B C R (map_converter' f g conv1) conv2\n\ngoal (1 subgoal):\n 1. rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1\n     conv2", "by(coinduction arbitrary: conv1 conv2)\n      (drule rel_converterD, auto intro: prod.rel_mono elim!: rel_fun_mono rel_gpv''_mono[THEN predicate2D, rotated -1]\n        simp add: map_gpv'_id rel_gpv''_map_gpv map_converter.sel map_converter_id14[symmetric] rel_fun_comp spmf_rel_map prod.rel_map[abs_def])"], ["proof (state)\nthis:\n  rel_converter A B C R (map_converter' f g conv1) conv2 \\<Longrightarrow>\n  rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1 conv2\n\ngoal (1 subgoal):\n 1. rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1\n     conv2 \\<Longrightarrow>\n    rel_converter A B C R (map_converter' f g conv1) conv2", "show ?lhs if ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R (map_converter' f g conv1) conv2", "using that"], ["proof (prove)\nusing this:\n  rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1 conv2\n\ngoal (1 subgoal):\n 1. rel_converter A B C R (map_converter' f g conv1) conv2", "by(coinduction arbitrary: conv1 conv2)\n      (drule rel_converterD, auto intro: prod.rel_mono elim!: rel_fun_mono rel_gpv''_mono[THEN predicate2D, rotated -1]\n        simp add: map_gpv'_id rel_gpv''_map_gpv map_converter.sel map_converter_id14[symmetric] rel_fun_comp spmf_rel_map prod.rel_map[abs_def])"], ["proof (state)\nthis:\n  rel_converter A (\\<lambda>x. B (f x)) (\\<lambda>x. C (g x)) R conv1\n   conv2 \\<Longrightarrow>\n  rel_converter A B C R (map_converter' f g conv1) conv2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_converter_map_converter'2:\n  \"rel_converter A B C R conv1 (map_converter' f g conv2) = rel_converter A (\\<lambda>x y. B x (f y)) (\\<lambda>x y. C x (g y)) R conv1 conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R conv1 (map_converter' f g conv2) =\n    rel_converter A (\\<lambda>x y. B x (f y)) (\\<lambda>x y. C x (g y)) R\n     conv1 conv2", "using rel_converter_map_converter'1[of \"conversep A\" \"conversep B\" \"conversep C\" \"conversep R\" f g conv2 conv1]"], ["proof (prove)\nusing this:\n  rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n   C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> (map_converter' f g conv2)\n   conv1 =\n  rel_converter A\\<inverse>\\<inverse>\n   (\\<lambda>x. B\\<inverse>\\<inverse> (f x))\n   (\\<lambda>x. C\\<inverse>\\<inverse> (g x)) R\\<inverse>\\<inverse> conv2\n   conv1\n\ngoal (1 subgoal):\n 1. rel_converter A B C R conv1 (map_converter' f g conv2) =\n    rel_converter A (\\<lambda>x y. B x (f y)) (\\<lambda>x y. C x (g y)) R\n     conv1 conv2", "apply(rewrite in \"\\<hole> = _\" conversep_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n     C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> (map_converter' f g conv2)\n     conv1 =\n    rel_converter A\\<inverse>\\<inverse>\n     (\\<lambda>x. B\\<inverse>\\<inverse> (f x))\n     (\\<lambda>x. C\\<inverse>\\<inverse> (g x)) R\\<inverse>\\<inverse> conv2\n     conv1 \\<Longrightarrow>\n    (rel_converter A B C R)\\<inverse>\\<inverse> (map_converter' f g conv2)\n     conv1 =\n    rel_converter A (\\<lambda>x y. B x (f y)) (\\<lambda>x y. C x (g y)) R\n     conv1 conv2", "apply(rewrite in \"_ = \\<hole>\" conversep_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n     C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> (map_converter' f g conv2)\n     conv1 =\n    rel_converter A\\<inverse>\\<inverse>\n     (\\<lambda>x. B\\<inverse>\\<inverse> (f x))\n     (\\<lambda>x. C\\<inverse>\\<inverse> (g x)) R\\<inverse>\\<inverse> conv2\n     conv1 \\<Longrightarrow>\n    (rel_converter A B C R)\\<inverse>\\<inverse> (map_converter' f g conv2)\n     conv1 =\n    (rel_converter A (\\<lambda>x y. B x (f y)) (\\<lambda>x y. C x (g y))\n      R)\\<inverse>\\<inverse>\n     conv2 conv1", "apply(simp only: rel_converter_conversep[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>\n     C\\<inverse>\\<inverse> R\\<inverse>\\<inverse> (map_converter' f g conv2)\n     conv1 =\n    rel_converter A\\<inverse>\\<inverse>\n     (\\<lambda>x. B\\<inverse>\\<inverse> (f x))\n     (\\<lambda>x. C\\<inverse>\\<inverse> (g x)) R\\<inverse>\\<inverse> conv2\n     conv1 \\<Longrightarrow>\n    rel_converter A\\<inverse>\\<inverse>\n     (\\<lambda>x. B\\<inverse>\\<inverse> (f x))\n     (\\<lambda>x. C\\<inverse>\\<inverse> (g x)) R\\<inverse>\\<inverse> conv2\n     conv1 =\n    rel_converter A\\<inverse>\\<inverse>\n     (\\<lambda>x y. B x (f y))\\<inverse>\\<inverse>\n     (\\<lambda>x y. C x (g y))\\<inverse>\\<inverse> R\\<inverse>\\<inverse>\n     conv2 conv1", "apply(simp only: conversep_iff[abs_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas converter_rel_map' = rel_converter_map_converter'1[abs_def] rel_converter_map_converter'2"], ["", "lemma rel_converter_pos_distr [relator_distr]:\n  \"rel_converter A B C R OO rel_converter A' B' C' R' \\<le> rel_converter (A OO A') (B OO B') (C OO C') (R OO R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R OO rel_converter A' B' C' R'\n    \\<le> rel_converter (A OO A') (B OO B') (C OO C') (R OO R')", "proof(rule predicate2I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (rel_converter A B C R OO rel_converter A' B' C' R') x\n        y \\<Longrightarrow>\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x y", "show \"rel_converter (A OO A') (B OO B') (C OO C') (R OO R') conv1 conv3\"\n    if \"(rel_converter A B C R OO rel_converter A' B' C' R') conv1 conv3\"\n    for conv1 conv3"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter (A OO A') (B OO B') (C OO C') (R OO R') conv1 conv3", "using that"], ["proof (prove)\nusing this:\n  (rel_converter A B C R OO rel_converter A' B' C' R') conv1 conv3\n\ngoal (1 subgoal):\n 1. rel_converter (A OO A') (B OO B') (C OO C') (R OO R') conv1 conv3", "apply(coinduction arbitrary: conv1 conv3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1a__ conv3.\n       (rel_converter A B C R OO rel_converter A' B' C' R') conv1a__\n        conv3 \\<Longrightarrow>\n       rel_fun (A OO A')\n        (rel_gpv''\n          (rel_prod (B OO B')\n            (\\<lambda>conv1 conv2.\n                (\\<exists>conv1a__ conv3.\n                    conv1 = conv1a__ \\<and>\n                    conv2 = conv3 \\<and>\n                    (rel_converter A B C R OO rel_converter A' B' C' R')\n                     conv1a__ conv3) \\<or>\n                rel_converter (A OO A') (B OO B') (C OO C') (R OO R') conv1\n                 conv2))\n          (C OO C') (R OO R'))\n        (run_converter conv1a__) (run_converter conv3)", "apply(erule relcomppE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1a__ conv3 b.\n       \\<lbrakk>rel_converter A B C R conv1a__ b;\n        rel_converter A' B' C' R' b conv3\\<rbrakk>\n       \\<Longrightarrow> rel_fun (A OO A')\n                          (rel_gpv''\n                            (rel_prod (B OO B')\n                              (\\<lambda>conv1 conv2.\n                                  (\\<exists>conv1a__ conv3.\nconv1 = conv1a__ \\<and>\nconv2 = conv3 \\<and>\n(rel_converter A B C R OO rel_converter A' B' C' R') conv1a__ conv3) \\<or>\n                                  rel_converter (A OO A') (B OO B')\n                                   (C OO C') (R OO R') conv1 conv2))\n                            (C OO C') (R OO R'))\n                          (run_converter conv1a__) (run_converter conv3)", "apply(drule rel_converterD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1a__ conv3 b.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3)\\<rbrakk>\n       \\<Longrightarrow> rel_fun (A OO A')\n                          (rel_gpv''\n                            (rel_prod (B OO B')\n                              (\\<lambda>conv1 conv2.\n                                  (\\<exists>conv1a__ conv3.\nconv1 = conv1a__ \\<and>\nconv2 = conv3 \\<and>\n(rel_converter A B C R OO rel_converter A' B' C' R') conv1a__ conv3) \\<or>\n                                  rel_converter (A OO A') (B OO B')\n                                   (C OO C') (R OO R') conv1 conv2))\n                            (C OO C') (R OO R'))\n                          (run_converter conv1a__) (run_converter conv3)", "apply(rule rel_fun_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conv1a__ conv3 b.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3)\\<rbrakk>\n       \\<Longrightarrow> rel_fun (?X9 conv1a__ conv3 b)\n                          (?A9 conv1a__ conv3 b) (run_converter conv1a__)\n                          (run_converter conv3)\n 2. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3)\\<rbrakk>\n       \\<Longrightarrow> (A OO A') x y \\<longrightarrow>\n                         ?X9 conv1a__ conv3 b x y\n 3. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        ?A9 conv1a__ conv3 b x y\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (B OO B')\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv1a__ conv3.\n                                    conv1 = conv1a__ \\<and>\n                                    conv2 = conv3 \\<and>\n                                    (rel_converter A B C R OO\n                                     rel_converter A' B' C' R')\n                                     conv1a__ conv3) \\<or>\n                                rel_converter (A OO A') (B OO B') (C OO C')\n                                 (R OO R') conv1 conv2))\n                          (C OO C') (R OO R') x y", "apply(rule pos_fun_distr[THEN predicate2D])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conv1a__ conv3 b.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3)\\<rbrakk>\n       \\<Longrightarrow> (rel_fun (?R14 conv1a__ conv3 b)\n                           (?S14 conv1a__ conv3 b) OO\n                          rel_fun (?R'14 conv1a__ conv3 b)\n                           (?S'14 conv1a__ conv3 b))\n                          (run_converter conv1a__) (run_converter conv3)\n 2. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3)\\<rbrakk>\n       \\<Longrightarrow> (A OO A') x y \\<longrightarrow>\n                         (?R14 conv1a__ conv3 b OO ?R'14 conv1a__ conv3 b) x\n                          y\n 3. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (?S14 conv1a__ conv3 b OO ?S'14 conv1a__ conv3 b) x y\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (B OO B')\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv1a__ conv3.\n                                    conv1 = conv1a__ \\<and>\n                                    conv2 = conv3 \\<and>\n                                    (rel_converter A B C R OO\n                                     rel_converter A' B' C' R')\n                                     conv1a__ conv3) \\<or>\n                                rel_converter (A OO A') (B OO B') (C OO C')\n                                 (R OO R') conv1 conv2))\n                          (C OO C') (R OO R') x y", "apply(erule (1) relcomppI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3)\\<rbrakk>\n       \\<Longrightarrow> (A OO A') x y \\<longrightarrow> (A OO A') x y\n 2. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (B OO B')\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv1a__ conv3.\n                                    conv1 = conv1a__ \\<and>\n                                    conv2 = conv3 \\<and>\n                                    (rel_converter A B C R OO\n                                     rel_converter A' B' C' R')\n                                     conv1a__ conv3) \\<or>\n                                rel_converter (A OO A') (B OO B') (C OO C')\n                                 (R OO R') conv1 conv2))\n                          (C OO C') (R OO R') x y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (B OO B')\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv1a__ conv3.\n                                    conv1 = conv1a__ \\<and>\n                                    conv2 = conv3 \\<and>\n                                    (rel_converter A B C R OO\n                                     rel_converter A' B' C' R')\n                                     conv1a__ conv3) \\<or>\n                                rel_converter (A OO A') (B OO B') (C OO C')\n                                 (R OO R') conv1 conv2))\n                          (C OO C') (R OO R') x y", "apply(rule rel_gpv''_mono[THEN predicate2D, rotated -1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_gpv'' (?A19 conv1a__ conv3 b x y)\n                          (?C19 conv1a__ conv3 b x y)\n                          (?R19 conv1a__ conv3 b x y) x y\n 2. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> ?A19 conv1a__ conv3 b x y\n                         \\<le> rel_prod (B OO B')\n                                (\\<lambda>conv1 conv2.\n                                    (\\<exists>conv1a__ conv3.\n  conv1 = conv1a__ \\<and>\n  conv2 = conv3 \\<and>\n  (rel_converter A B C R OO rel_converter A' B' C' R') conv1a__ conv3) \\<or>\n                                    rel_converter (A OO A') (B OO B')\n                                     (C OO C') (R OO R') conv1 conv2)\n 3. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> ?C19 conv1a__ conv3 b x y \\<le> C OO C'\n 4. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> R OO R' \\<le> ?R19 conv1a__ conv3 b x y", "apply(erule rel_gpv''_pos_distr[THEN predicate2D])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_prod B (rel_converter A B C R) OO\n                         rel_prod B' (rel_converter A' B' C' R')\n                         \\<le> rel_prod (B OO B')\n                                (\\<lambda>conv1 conv2.\n                                    (\\<exists>conv1a__ conv3.\n  conv1 = conv1a__ \\<and>\n  conv2 = conv3 \\<and>\n  (rel_converter A B C R OO rel_converter A' B' C' R') conv1a__ conv3) \\<or>\n                                    rel_converter (A OO A') (B OO B')\n                                     (C OO C') (R OO R') conv1 conv2)\n 2. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> C OO C' \\<le> C OO C'\n 3. \\<And>conv1a__ conv3 b x y.\n       \\<lbrakk>rel_fun A\n                 (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n                 (run_converter conv1a__) (run_converter b);\n        rel_fun A'\n         (rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         (run_converter b) (run_converter conv3);\n        (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R OO\n         rel_gpv'' (rel_prod B' (rel_converter A' B' C' R')) C' R')\n         x y\\<rbrakk>\n       \\<Longrightarrow> R OO R' \\<le> R OO R'", "by(auto simp add:  prod.rel_compp[symmetric] intro: prod.rel_mono)"], ["proof (state)\nthis:\n  (rel_converter A B C R OO rel_converter A' B' C' R') ?conv1.0\n   ?conv3.0 \\<Longrightarrow>\n  rel_converter (A OO A') (B OO B') (C OO C') (R OO R') ?conv1.0 ?conv3.0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_unique_rel_converter:\n  \"\\<lbrakk> left_total A; left_unique B; left_unique C; left_total R \\<rbrakk> \\<Longrightarrow> left_unique (rel_converter A B C R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total A; left_unique B; left_unique C;\n     left_total R\\<rbrakk>\n    \\<Longrightarrow> left_unique (rel_converter A B C R)", "unfolding left_unique_alt_def left_total_alt_def rel_converter_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A OO A\\<inverse>\\<inverse>;\n     B OO B\\<inverse>\\<inverse> \\<le> (=);\n     C OO C\\<inverse>\\<inverse> \\<le> (=);\n     (=) \\<le> R OO R\\<inverse>\\<inverse>\\<rbrakk>\n    \\<Longrightarrow> rel_converter A B C R OO\n                      rel_converter A\\<inverse>\\<inverse>\n                       B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                       R\\<inverse>\\<inverse>\n                      \\<le> (=)", "by(subst rel_converter_eq[symmetric], rule order_trans[OF rel_converter_pos_distr], erule (3) rel_converter_mono)"], ["", "lemma right_unique_rel_converter:\n  \"\\<lbrakk> right_total A; right_unique B; right_unique C; right_total R \\<rbrakk> \\<Longrightarrow> right_unique (rel_converter A B C R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_total A; right_unique B; right_unique C;\n     right_total R\\<rbrakk>\n    \\<Longrightarrow> right_unique (rel_converter A B C R)", "unfolding right_unique_alt_def right_total_alt_def rel_converter_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(=) \\<le> A\\<inverse>\\<inverse> OO A;\n     B\\<inverse>\\<inverse> OO B \\<le> (=);\n     C\\<inverse>\\<inverse> OO C \\<le> (=);\n     (=) \\<le> R\\<inverse>\\<inverse> OO R\\<rbrakk>\n    \\<Longrightarrow> rel_converter A\\<inverse>\\<inverse>\n                       B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                       R\\<inverse>\\<inverse> OO\n                      rel_converter A B C R\n                      \\<le> (=)", "by(subst rel_converter_eq[symmetric], rule order_trans[OF rel_converter_pos_distr], erule (3) rel_converter_mono)"], ["", "lemma bi_unique_rel_converter [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique B; bi_unique C; bi_total R \\<rbrakk> \\<Longrightarrow> bi_unique (rel_converter A B C R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total A; bi_unique B; bi_unique C; bi_total R\\<rbrakk>\n    \\<Longrightarrow> bi_unique (rel_converter A B C R)", "unfolding bi_unique_alt_def bi_total_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total A \\<and> right_total A;\n     left_unique B \\<and> right_unique B;\n     left_unique C \\<and> right_unique C;\n     left_total R \\<and> right_total R\\<rbrakk>\n    \\<Longrightarrow> left_unique (rel_converter A B C R) \\<and>\n                      right_unique (rel_converter A B C R)", "by(blast intro: left_unique_rel_converter right_unique_rel_converter)"], ["", "definition rel_witness_converter :: \"('a \\<Rightarrow> 'e \\<Rightarrow> bool) \\<Rightarrow> ('e \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'd \\<Rightarrow> bool) \\<Rightarrow> ('out \\<Rightarrow> 'out' \\<Rightarrow> bool) \\<Rightarrow> ('in \\<Rightarrow> 'in'' \\<Rightarrow> bool) \\<Rightarrow> ('in'' \\<Rightarrow> 'in' \\<Rightarrow> bool)\n  \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<times> ('c, 'd, 'out', 'in') converter \\<Rightarrow> ('e, 'b \\<times> 'd, 'out \\<times> 'out', 'in'') converter\" where\n  \"rel_witness_converter A A' B C R R' = corec_converter (\\<lambda>(conv1, conv2).\n   map_gpv (map_prod id Inr \\<circ> rel_witness_prod) id \\<circ> \n   rel_witness_gpv (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R R' \\<circ> \n   rel_witness_fun A A' (run_converter conv1, run_converter conv2))\""], ["", "lemma rel_witness_converter_sel [simp]:\n  \"run_converter (rel_witness_converter A A' B C R R' (conv1, conv2)) =\n   map_gpv (map_prod id (rel_witness_converter A A' B C R R') \\<circ> rel_witness_prod) id \\<circ> \n   rel_witness_gpv (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R R' \\<circ> \n   rel_witness_fun A A' (run_converter conv1, run_converter conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter (rel_witness_converter A A' B C R R' (conv1, conv2)) =\n    map_gpv\n     (map_prod id (rel_witness_converter A A' B C R R') \\<circ>\n      rel_witness_prod)\n     id \\<circ>\n    rel_witness_gpv (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R\n     R' \\<circ>\n    rel_witness_fun A A' (run_converter conv1, run_converter conv2)", "by(auto simp add: rel_witness_converter_def o_def fun_eq_iff gpv.map_comp intro!: gpv.map_cong)"], ["", "lemma assumes \"rel_converter (A OO A') B C (R OO R') conv conv'\"\n  and A: \"left_unique A\" \"right_total A\"\n  and A': \"right_unique A'\" \"left_total A'\"\n  and R: \"left_unique R\" \"right_total R\"\n  and R': \"right_unique R'\" \"left_total R'\"\nshows rel_witness_converter1: \"rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c) (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv (rel_witness_converter A A' B C R R' (conv, conv'))\" (is \"?thesis1\")\n  and rel_witness_converter2: \"rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c') (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' (rel_witness_converter A A' B C R R' (conv, conv')) conv'\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv\n     (rel_witness_converter A A' B C R R' (conv, conv')) &&&\n    rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n     (rel_witness_converter A A' B C R R' (conv, conv')) conv'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv\n     (rel_witness_converter A A' B C R R' (conv, conv'))\n 2. rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n     (rel_witness_converter A A' B C R R' (conv, conv')) conv'", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv\n     (rel_witness_converter A A' B C R R' (conv, conv'))", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_converter (A OO A') B C (R OO R') conv conv'\n\ngoal (1 subgoal):\n 1. rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv\n     (rel_witness_converter A A' B C R R' (conv, conv'))", "proof(coinduction arbitrary: conv conv')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       rel_converter (A OO A') B C (R OO R') conv conv' \\<Longrightarrow>\n       rel_fun A\n        (rel_gpv''\n          (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n            (\\<lambda>conv1 conv2.\n                (\\<exists>conv conv'.\n                    conv1 = conv \\<and>\n                    conv2 =\n                    rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n                    rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n                rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n                 (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv1 conv2))\n          (\\<lambda>c (c', d). c = c' \\<and> C c' d) R)\n        (run_converter conv)\n        (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))", "case rel_converter"], ["proof (state)\nthis:\n  rel_converter (A OO A') B C (R OO R') conv conv'\n\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       rel_converter (A OO A') B C (R OO R') conv conv' \\<Longrightarrow>\n       rel_fun A\n        (rel_gpv''\n          (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n            (\\<lambda>conv1 conv2.\n                (\\<exists>conv conv'.\n                    conv1 = conv \\<and>\n                    conv2 =\n                    rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n                    rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n                rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n                 (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv1 conv2))\n          (\\<lambda>c (c', d). c = c' \\<and> C c' d) R)\n        (run_converter conv)\n        (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))", "from this[THEN rel_converterD]"], ["proof (chain)\npicking this:\n  rel_fun (A OO A')\n   (rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n     (R OO R'))\n   (run_converter conv) (run_converter conv')", "show ?case"], ["proof (prove)\nusing this:\n  rel_fun (A OO A')\n   (rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n     (R OO R'))\n   (run_converter conv) (run_converter conv')\n\ngoal (1 subgoal):\n 1. rel_fun A\n     (rel_gpv''\n       (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n         (\\<lambda>conv1 conv2.\n             (\\<exists>conv conv'.\n                 conv1 = conv \\<and>\n                 conv2 =\n                 rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n                 rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n             rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n              (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv1 conv2))\n       (\\<lambda>c (c', d). c = c' \\<and> C c' d) R)\n     (run_converter conv)\n     (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))", "apply(simp add: rel_fun_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (A OO A')\n     (rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n       (R OO R'))\n     (run_converter conv) (run_converter conv') \\<Longrightarrow>\n    rel_fun A\n     (\\<lambda>x y.\n         rel_gpv''\n          (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n            (\\<lambda>conv1 conv2.\n                (\\<exists>conv'.\n                    conv2 =\n                    rel_witness_converter A A' B C R R'\n                     (conv1, conv') \\<and>\n                    rel_converter (A OO A') B C (R OO R') conv1 conv') \\<or>\n                rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n                 (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv1 conv2))\n          (\\<lambda>c (c', d). c = c' \\<and> C c' d) R x\n          (map_gpv\n            (map_prod id (rel_witness_converter A A' B C R R') \\<circ>\n             rel_witness_prod)\n            id (rel_witness_gpv\n                 (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R R'\n                 y)))\n     (run_converter conv)\n     (rel_witness_fun A A' (run_converter conv, run_converter conv'))", "apply(erule rel_fun_mono[OF rel_witness_fun1[OF _ A A']]; clarsimp simp add: rel_gpv''_map_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n        (R OO R') a b \\<Longrightarrow>\n       rel_gpv''\n        (\\<lambda>a b.\n            rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n             (\\<lambda>conv1 conv2.\n                 (\\<exists>conv'.\n                     conv2 =\n                     rel_witness_converter A A' B C R R'\n                      (conv1, conv') \\<and>\n                     rel_converter (A OO A') B C (R OO R') conv1\n                      conv') \\<or>\n                 rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n                  (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv1 conv2)\n             a (map_prod id (rel_witness_converter A A' B C R R')\n                 (rel_witness_prod b)))\n        (\\<lambda>c (c', d). c = c' \\<and> C c' d) R a\n        (rel_witness_gpv\n          (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R R'\n          (a, b))", "apply(erule rel_gpv''_mono[THEN predicate2D, rotated -1, OF rel_witness_gpv1[OF _ R R']]; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_fun A\n   (rel_gpv''\n     (rel_prod (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n       (\\<lambda>conv1 conv2.\n           (\\<exists>conv conv'.\n               conv1 = conv \\<and>\n               conv2 =\n               rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n               rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n           rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n            (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv1 conv2))\n     (\\<lambda>c (c', d). c = c' \\<and> C c' d) R)\n   (run_converter conv)\n   (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_converter A (\\<lambda>b (b', c). b = b' \\<and> B b' c)\n   (\\<lambda>c (c', d). c = c' \\<and> C c' d) R conv\n   (rel_witness_converter A A' B C R R' (conv, conv'))\n\ngoal (1 subgoal):\n 1. rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n     (rel_witness_converter A A' B C R R' (conv, conv')) conv'", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n     (rel_witness_converter A A' B C R R' (conv, conv')) conv'", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_converter (A OO A') B C (R OO R') conv conv'\n\ngoal (1 subgoal):\n 1. rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n     (rel_witness_converter A A' B C R R' (conv, conv')) conv'", "proof(coinduction arbitrary: conv conv')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       rel_converter (A OO A') B C (R OO R') conv conv' \\<Longrightarrow>\n       rel_fun A'\n        (rel_gpv''\n          (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n            (\\<lambda>conv1 conv2.\n                (\\<exists>conv conv'.\n                    conv1 =\n                    rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n                    conv2 = conv' \\<and>\n                    rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n                rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n                 (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' conv1 conv2))\n          (\\<lambda>(c, d') d. d = d' \\<and> C c d') R')\n        (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))\n        (run_converter conv')", "case rel_converter"], ["proof (state)\nthis:\n  rel_converter (A OO A') B C (R OO R') conv conv'\n\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       rel_converter (A OO A') B C (R OO R') conv conv' \\<Longrightarrow>\n       rel_fun A'\n        (rel_gpv''\n          (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n            (\\<lambda>conv1 conv2.\n                (\\<exists>conv conv'.\n                    conv1 =\n                    rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n                    conv2 = conv' \\<and>\n                    rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n                rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n                 (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' conv1 conv2))\n          (\\<lambda>(c, d') d. d = d' \\<and> C c d') R')\n        (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))\n        (run_converter conv')", "from this[THEN rel_converterD]"], ["proof (chain)\npicking this:\n  rel_fun (A OO A')\n   (rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n     (R OO R'))\n   (run_converter conv) (run_converter conv')", "show ?case"], ["proof (prove)\nusing this:\n  rel_fun (A OO A')\n   (rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n     (R OO R'))\n   (run_converter conv) (run_converter conv')\n\ngoal (1 subgoal):\n 1. rel_fun A'\n     (rel_gpv''\n       (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n         (\\<lambda>conv1 conv2.\n             (\\<exists>conv conv'.\n                 conv1 =\n                 rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n                 conv2 = conv' \\<and>\n                 rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n             rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n              (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' conv1 conv2))\n       (\\<lambda>(c, d') d. d = d' \\<and> C c d') R')\n     (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))\n     (run_converter conv')", "apply(simp add: rel_fun_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (A OO A')\n     (rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n       (R OO R'))\n     (run_converter conv) (run_converter conv') \\<Longrightarrow>\n    rel_fun A'\n     (\\<lambda>x.\n         rel_gpv''\n          (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n            (\\<lambda>conv1 conv2.\n                (\\<exists>conv.\n                    conv1 =\n                    rel_witness_converter A A' B C R R' (conv, conv2) \\<and>\n                    rel_converter (A OO A') B C (R OO R') conv conv2) \\<or>\n                rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n                 (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' conv1 conv2))\n          (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n          (map_gpv\n            (map_prod id (rel_witness_converter A A' B C R R') \\<circ>\n             rel_witness_prod)\n            id (rel_witness_gpv\n                 (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R R'\n                 x)))\n     (rel_witness_fun A A' (run_converter conv, run_converter conv'))\n     (run_converter conv')", "apply(erule rel_fun_mono[OF rel_witness_fun2[OF _ A A']]; clarsimp simp add: rel_gpv''_map_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       rel_gpv'' (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C\n        (R OO R') a b \\<Longrightarrow>\n       rel_gpv''\n        (\\<lambda>a.\n            rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n             (\\<lambda>conv1 conv2.\n                 (\\<exists>conv.\n                     conv1 =\n                     rel_witness_converter A A' B C R R'\n                      (conv, conv2) \\<and>\n                     rel_converter (A OO A') B C (R OO R') conv conv2) \\<or>\n                 rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n                  (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' conv1 conv2)\n             (map_prod id (rel_witness_converter A A' B C R R')\n               (rel_witness_prod a)))\n        (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n        (rel_witness_gpv\n          (rel_prod B (rel_converter (A OO A') B C (R OO R'))) C R R'\n          (a, b))\n        b", "apply(erule rel_gpv''_mono[THEN predicate2D, rotated -1, OF rel_witness_gpv2[OF _ R R']]; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_fun A'\n   (rel_gpv''\n     (rel_prod (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n       (\\<lambda>conv1 conv2.\n           (\\<exists>conv conv'.\n               conv1 =\n               rel_witness_converter A A' B C R R' (conv, conv') \\<and>\n               conv2 = conv' \\<and>\n               rel_converter (A OO A') B C (R OO R') conv conv') \\<or>\n           rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n            (\\<lambda>(c, d') d. d = d' \\<and> C c d') R' conv1 conv2))\n     (\\<lambda>(c, d') d. d = d' \\<and> C c d') R')\n   (run_converter (rel_witness_converter A A' B C R R' (conv, conv')))\n   (run_converter conv')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> B b c')\n   (\\<lambda>(c, d') d. d = d' \\<and> C c d') R'\n   (rel_witness_converter A A' B C R R' (conv, conv')) conv'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_converter_neg_distr [relator_distr]:\n  assumes A: \"left_unique A\" \"right_total A\"\n    and A': \"right_unique A'\" \"left_total A'\"\n    and R: \"left_unique R\" \"right_total R\"\n    and R': \"right_unique R'\" \"left_total R'\"\n  shows \"rel_converter (A OO A') (B OO B') (C OO C') (R OO R') \\<le> rel_converter A B C R OO rel_converter A' B' C' R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter (A OO A') (B OO B') (C OO C') (R OO R')\n    \\<le> rel_converter A B C R OO rel_converter A' B' C' R'", "proof(rule predicate2I relcomppI)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A B C R x (?b2 x y)\n 2. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A' B' C' R' (?b2 x y) y", "fix conv conv''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A B C R x (?b2 x y)\n 2. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A' B' C' R' (?b2 x y) y", "assume *: \"rel_converter (A OO A') (B OO B') (C OO C') (R OO R') conv conv''\""], ["proof (state)\nthis:\n  rel_converter (A OO A') (B OO B') (C OO C') (R OO R') conv conv''\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A B C R x (?b2 x y)\n 2. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A' B' C' R' (?b2 x y) y", "let ?conv' = \"map_converter' (relcompp_witness B B') (relcompp_witness C C') (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv''))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A B C R x (?b2 x y)\n 2. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A' B' C' R' (?b2 x y) y", "show \"rel_converter A B C R conv ?conv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R conv\n     (map_converter' (relcompp_witness B B') (relcompp_witness C C')\n       (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv'')))", "using rel_witness_converter1[OF * A A' R R']"], ["proof (prove)\nusing this:\n  rel_converter A (\\<lambda>b (b', c). b = b' \\<and> (B OO B') b' c)\n   (\\<lambda>c (c', d). c = c' \\<and> (C OO C') c' d) R conv\n   (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv''))\n\ngoal (1 subgoal):\n 1. rel_converter A B C R conv\n     (map_converter' (relcompp_witness B B') (relcompp_witness C C')\n       (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv'')))", "unfolding converter_rel_map'"], ["proof (prove)\nusing this:\n  rel_converter A (\\<lambda>b (b', c). b = b' \\<and> (B OO B') b' c)\n   (\\<lambda>c (c', d). c = c' \\<and> (C OO C') c' d) R conv\n   (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv''))\n\ngoal (1 subgoal):\n 1. rel_converter A (\\<lambda>x y. B x (relcompp_witness B B' y))\n     (\\<lambda>x y. C x (relcompp_witness C C' y)) R conv\n     (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv''))", "by(rule rel_converter_mono[THEN predicate2D, rotated -1]; clarify del: relcomppE elim!: relcompp_witness)"], ["proof (state)\nthis:\n  rel_converter A B C R conv\n   (map_converter' (relcompp_witness B B') (relcompp_witness C C')\n     (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv'')))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_converter (A OO A') (B OO B') (C OO C') (R OO R') x\n        y \\<Longrightarrow>\n       rel_converter A' B' C' R'\n        (map_converter' (relcompp_witness B B') (relcompp_witness C C')\n          (rel_witness_converter A A' (B OO B') (C OO C') R R' (x, y)))\n        y", "show \"rel_converter A' B' C' R' ?conv' conv''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A' B' C' R'\n     (map_converter' (relcompp_witness B B') (relcompp_witness C C')\n       (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv'')))\n     conv''", "using rel_witness_converter2[OF * A A' R R']"], ["proof (prove)\nusing this:\n  rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> (B OO B') b c')\n   (\\<lambda>(c, d') d. d = d' \\<and> (C OO C') c d') R'\n   (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv''))\n   conv''\n\ngoal (1 subgoal):\n 1. rel_converter A' B' C' R'\n     (map_converter' (relcompp_witness B B') (relcompp_witness C C')\n       (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv'')))\n     conv''", "unfolding converter_rel_map'"], ["proof (prove)\nusing this:\n  rel_converter A' (\\<lambda>(b, c') c. c = c' \\<and> (B OO B') b c')\n   (\\<lambda>(c, d') d. d = d' \\<and> (C OO C') c d') R'\n   (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv''))\n   conv''\n\ngoal (1 subgoal):\n 1. rel_converter A' (\\<lambda>x. B' (relcompp_witness B B' x))\n     (\\<lambda>x. C' (relcompp_witness C C' x)) R'\n     (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv''))\n     conv''", "by(rule rel_converter_mono[THEN predicate2D, rotated -1]; clarify del: relcomppE elim!: relcompp_witness)"], ["proof (state)\nthis:\n  rel_converter A' B' C' R'\n   (map_converter' (relcompp_witness B B') (relcompp_witness C C')\n     (rel_witness_converter A A' (B OO B') (C OO C') R R' (conv, conv'')))\n   conv''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_total_rel_converter:\n  \"\\<lbrakk> left_unique A; right_total A; left_total B; left_total C; left_unique R; right_total R \\<rbrakk>\n  \\<Longrightarrow> left_total (rel_converter A B C R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_unique A; right_total A; left_total B; left_total C;\n     left_unique R; right_total R\\<rbrakk>\n    \\<Longrightarrow> left_total (rel_converter A B C R)", "unfolding left_unique_alt_def left_total_alt_def rel_converter_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>;\n     (=) \\<le> C OO C\\<inverse>\\<inverse>;\n     R OO R\\<inverse>\\<inverse> \\<le> (=); right_total R\\<rbrakk>\n    \\<Longrightarrow> (=)\n                      \\<le> rel_converter A B C R OO\n                            rel_converter A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                             R\\<inverse>\\<inverse>", "apply(subst rel_converter_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>;\n     (=) \\<le> C OO C\\<inverse>\\<inverse>;\n     R OO R\\<inverse>\\<inverse> \\<le> (=); right_total R\\<rbrakk>\n    \\<Longrightarrow> rel_converter (=) (=) (=) (=)\n                      \\<le> rel_converter A B C R OO\n                            rel_converter A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                             R\\<inverse>\\<inverse>", "apply(rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>;\n     (=) \\<le> C OO C\\<inverse>\\<inverse>;\n     R OO R\\<inverse>\\<inverse> \\<le> (=); right_total R\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> rel_converter A B C R OO\n                               rel_converter A\\<inverse>\\<inverse>\n                                B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                                R\\<inverse>\\<inverse>\n 2. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>;\n     (=) \\<le> C OO C\\<inverse>\\<inverse>;\n     R OO R\\<inverse>\\<inverse> \\<le> (=); right_total R\\<rbrakk>\n    \\<Longrightarrow> rel_converter (=) (=) (=) (=) \\<le> ?y", "apply(rule rel_converter_neg_distr; simp add: left_unique_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A OO A\\<inverse>\\<inverse> \\<le> (=); right_total A;\n     (=) \\<le> B OO B\\<inverse>\\<inverse>;\n     (=) \\<le> C OO C\\<inverse>\\<inverse>;\n     R OO R\\<inverse>\\<inverse> \\<le> (=); right_total R\\<rbrakk>\n    \\<Longrightarrow> rel_converter (=) (=) (=) (=)\n                      \\<le> rel_converter (A OO A\\<inverse>\\<inverse>)\n                             (B OO B\\<inverse>\\<inverse>)\n                             (C OO C\\<inverse>\\<inverse>)\n                             (R OO R\\<inverse>\\<inverse>)", "apply(rule rel_converter_mono; assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma right_total_rel_converter:\n  \"\\<lbrakk> right_unique A; left_total A; right_total B; right_total C; right_unique R; left_total R \\<rbrakk>\n   \\<Longrightarrow> right_total (rel_converter A B C R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>right_unique A; left_total A; right_total B; right_total C;\n     right_unique R; left_total R\\<rbrakk>\n    \\<Longrightarrow> right_total (rel_converter A B C R)", "unfolding right_unique_alt_def right_total_alt_def rel_converter_conversep[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B;\n     (=) \\<le> C\\<inverse>\\<inverse> OO C;\n     R\\<inverse>\\<inverse> OO R \\<le> (=); left_total R\\<rbrakk>\n    \\<Longrightarrow> (=)\n                      \\<le> rel_converter A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                             R\\<inverse>\\<inverse> OO\n                            rel_converter A B C R", "apply(subst rel_converter_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B;\n     (=) \\<le> C\\<inverse>\\<inverse> OO C;\n     R\\<inverse>\\<inverse> OO R \\<le> (=); left_total R\\<rbrakk>\n    \\<Longrightarrow> rel_converter (=) (=) (=) (=)\n                      \\<le> rel_converter A\\<inverse>\\<inverse>\n                             B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                             R\\<inverse>\\<inverse> OO\n                            rel_converter A B C R", "apply(rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B;\n     (=) \\<le> C\\<inverse>\\<inverse> OO C;\n     R\\<inverse>\\<inverse> OO R \\<le> (=); left_total R\\<rbrakk>\n    \\<Longrightarrow> ?y \\<le> rel_converter A\\<inverse>\\<inverse>\n                                B\\<inverse>\\<inverse> C\\<inverse>\\<inverse>\n                                R\\<inverse>\\<inverse> OO\n                               rel_converter A B C R\n 2. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B;\n     (=) \\<le> C\\<inverse>\\<inverse> OO C;\n     R\\<inverse>\\<inverse> OO R \\<le> (=); left_total R\\<rbrakk>\n    \\<Longrightarrow> rel_converter (=) (=) (=) (=) \\<le> ?y", "apply(rule rel_converter_neg_distr; simp add: right_unique_alt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A\\<inverse>\\<inverse> OO A \\<le> (=); left_total A;\n     (=) \\<le> B\\<inverse>\\<inverse> OO B;\n     (=) \\<le> C\\<inverse>\\<inverse> OO C;\n     R\\<inverse>\\<inverse> OO R \\<le> (=); left_total R\\<rbrakk>\n    \\<Longrightarrow> rel_converter (=) (=) (=) (=)\n                      \\<le> rel_converter (A\\<inverse>\\<inverse> OO A)\n                             (B\\<inverse>\\<inverse> OO B)\n                             (C\\<inverse>\\<inverse> OO C)\n                             (R\\<inverse>\\<inverse> OO R)", "apply(rule rel_converter_mono; assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bi_total_rel_converter [transfer_rule]:\n  \"\\<lbrakk> bi_total A; bi_unique A; bi_total B; bi_total C; bi_total R; bi_unique R \\<rbrakk> \n  \\<Longrightarrow> bi_total (rel_converter A B C R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bi_total A; bi_unique A; bi_total B; bi_total C; bi_total R;\n     bi_unique R\\<rbrakk>\n    \\<Longrightarrow> bi_total (rel_converter A B C R)", "unfolding bi_total_alt_def bi_unique_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>left_total A \\<and> right_total A;\n     left_unique A \\<and> right_unique A; left_total B \\<and> right_total B;\n     left_total C \\<and> right_total C; left_total R \\<and> right_total R;\n     left_unique R \\<and> right_unique R\\<rbrakk>\n    \\<Longrightarrow> left_total (rel_converter A B C R) \\<and>\n                      right_total (rel_converter A B C R)", "by(blast intro: left_total_rel_converter right_total_rel_converter)"], ["", "inductive pred_converter :: \"'a set \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow> ('out \\<Rightarrow> bool) \\<Rightarrow> 'in set \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<Rightarrow> bool\"\n  for A B C R conv where\n    \"pred_converter A B C R conv\" if\n    \"\\<forall>x\\<in>results_converter (\\<I>_uniform A UNIV) (\\<I>_uniform UNIV R) conv. B x\" \n    \"\\<forall>out\\<in>outs_converter (\\<I>_uniform A UNIV) (\\<I>_uniform UNIV R) conv. C out\""], ["", "lemma pred_gpv'_mono_weak: (* TODO: Generalize to R' \\<subseteq> R *)\n  \"pred_gpv' A C R \\<le> pred_gpv' A' C' R\" if \"A \\<le> A'\" \"C \\<le> C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_gpv' A C R \\<le> pred_gpv' A' C' R", "using that"], ["proof (prove)\nusing this:\n  A \\<le> A'\n  C \\<le> C'\n\ngoal (1 subgoal):\n 1. pred_gpv' A C R \\<le> pred_gpv' A' C' R", "by(auto 4 3 simp add: pred_gpv'.simps)"], ["", "lemma Domainp_rel_converter_le:\n  \"Domainp (rel_converter A B C R) \\<le> pred_converter (Collect (Domainp A)) (Domainp B) (Domainp C) (Collect (Domainp R))\"\n  (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (rel_converter A B C R)\n    \\<le> pred_converter (Collect (Domainp A)) (Domainp B) (Domainp C)\n           (Collect (Domainp R))", "proof(intro predicate1I pred_converter.intros strip)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        xa \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                  (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp B xa\n 2. \\<And>x out.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        out\n        \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n               (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp C out", "fix conv"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        xa \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                  (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp B xa\n 2. \\<And>x out.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        out\n        \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n               (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp C out", "assume *: \"?lhs conv\""], ["proof (state)\nthis:\n  Domainp (rel_converter A B C R) conv\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        xa \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                  (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp B xa\n 2. \\<And>x out.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        out\n        \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n               (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp C out", "let ?\\<I> = \"\\<I>_uniform (Collect (Domainp A)) UNIV\" and ?\\<I>' = \"\\<I>_uniform UNIV (Collect (Domainp R))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        xa \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                  (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp B xa\n 2. \\<And>x out.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        out\n        \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n               (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp C out", "show \"Domainp B x\" if \"x \\<in> results_converter ?\\<I> ?\\<I>' conv\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp B x", "using that *"], ["proof (prove)\nusing this:\n  x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n           (\\<I>_uniform UNIV (Collect (Domainp R))) conv\n  Domainp (rel_converter A B C R) conv\n\ngoal (1 subgoal):\n 1. Domainp B x", "apply(induction)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv' conv a.\n       \\<lbrakk>(x, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x\n 2. \\<And>b' conv' conv a.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv' conv a b ba.\n       \\<lbrakk>(x, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        A a b; rel_converter A B C R conv ba\\<rbrakk>\n       \\<Longrightarrow> Domainp B x\n 2. \\<And>b' conv' conv a.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(erule rel_converter.cases; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv' a b conv1 conv2.\n       \\<lbrakk>(x, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        A a b;\n        rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n         (run_converter conv1) (run_converter conv2)\\<rbrakk>\n       \\<Longrightarrow> Domainp B x\n 2. \\<And>b' conv' conv a.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(drule (1) rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv' a b conv1 conv2.\n       \\<lbrakk>(x, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        A a b;\n        rel_gpv'' (rel_prod B (rel_converter A B C R)) C R\n         (run_converter conv1 a) (run_converter conv2 b)\\<rbrakk>\n       \\<Longrightarrow> Domainp B x\n 2. \\<And>b' conv' conv a.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(drule Domainp_rel_gpv''_le[THEN predicate1D, OF DomainPI])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv' a b conv1 conv2.\n       \\<lbrakk>(x, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        A a b;\n        pred_gpv' (Domainp (rel_prod B (rel_converter A B C R))) (Domainp C)\n         {x. Domainp R x} (run_converter conv1 a)\\<rbrakk>\n       \\<Longrightarrow> Domainp B x\n 2. \\<And>b' conv' conv a.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(erule pred_gpv'.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv' a b conv1 conv2.\n       \\<lbrakk>(x, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        A a b;\n        \\<And>x.\n           x \\<in> results_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                    (run_converter conv1 a) \\<Longrightarrow>\n           Domainp (rel_prod B (rel_converter A B C R)) x;\n        \\<And>out.\n           out\n           \\<in> outs_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                  (run_converter conv1 a) \\<Longrightarrow>\n           Domainp C out\\<rbrakk>\n       \\<Longrightarrow> Domainp B x\n 2. \\<And>b' conv' conv a.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b' conv' conv a.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b' conv' conv a b ba.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        A a b; rel_converter A B C R conv ba\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(erule rel_converter.cases; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b' conv' a b conv1 conv2.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        A a b;\n        rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n         (run_converter conv1) (run_converter conv2)\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(drule (1) rel_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b' conv' a b conv1 conv2.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        A a b;\n        rel_gpv'' (rel_prod B (rel_converter A B C R)) C R\n         (run_converter conv1 a) (run_converter conv2 b)\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(drule Domainp_rel_gpv''_le[THEN predicate1D, OF DomainPI])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b' conv' a b conv1 conv2.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        A a b;\n        pred_gpv' (Domainp (rel_prod B (rel_converter A B C R))) (Domainp C)\n         {x. Domainp R x} (run_converter conv1 a)\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply(erule pred_gpv'.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b' conv' a b conv1 conv2.\n       \\<lbrakk>(b', conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp B x;\n        A a b;\n        \\<And>x.\n           x \\<in> results_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                    (run_converter conv1 a) \\<Longrightarrow>\n           Domainp (rel_prod B (rel_converter A B C R)) x;\n        \\<And>out.\n           out\n           \\<in> outs_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                  (run_converter conv1 a) \\<Longrightarrow>\n           Domainp C out\\<rbrakk>\n       \\<Longrightarrow> Domainp B x", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x1\n  \\<in> results_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n         (\\<I>_uniform UNIV (Collect (Domainp R))) conv \\<Longrightarrow>\n  Domainp B ?x1\n\ngoal (1 subgoal):\n 1. \\<And>x out.\n       \\<lbrakk>Domainp (rel_converter A B C R) x;\n        out\n        \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n               (\\<I>_uniform UNIV (Collect (Domainp R))) x\\<rbrakk>\n       \\<Longrightarrow> Domainp C out", "show \"Domainp C x\" if \"x \\<in> outs_converter ?\\<I> ?\\<I>' conv\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp C x", "using that *"], ["proof (prove)\nusing this:\n  x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n           (\\<I>_uniform UNIV (Collect (Domainp R))) conv\n  Domainp (rel_converter A B C R) conv\n\ngoal (1 subgoal):\n 1. Domainp C x", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv a.\n       \\<lbrakk>x \\<in> outs_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                         (run_converter conv a);\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x\n 2. \\<And>b conv' conv a.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv a b ba.\n       \\<lbrakk>x \\<in> outs_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                         (run_converter conv a);\n        A a b; rel_converter A B C R conv ba\\<rbrakk>\n       \\<Longrightarrow> Domainp C x\n 2. \\<And>b conv' conv a.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(erule rel_converter.cases; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b conv1 conv2.\n       \\<lbrakk>x \\<in> outs_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                         (run_converter conv1 a);\n        A a b;\n        rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n         (run_converter conv1) (run_converter conv2)\\<rbrakk>\n       \\<Longrightarrow> Domainp C x\n 2. \\<And>b conv' conv a.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(drule (1) rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b conv1 conv2.\n       \\<lbrakk>x \\<in> outs_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                         (run_converter conv1 a);\n        A a b;\n        rel_gpv'' (rel_prod B (rel_converter A B C R)) C R\n         (run_converter conv1 a) (run_converter conv2 b)\\<rbrakk>\n       \\<Longrightarrow> Domainp C x\n 2. \\<And>b conv' conv a.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(drule Domainp_rel_gpv''_le[THEN predicate1D, OF DomainPI])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b conv1 conv2.\n       \\<lbrakk>x \\<in> outs_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                         (run_converter conv1 a);\n        A a b;\n        pred_gpv' (Domainp (rel_prod B (rel_converter A B C R))) (Domainp C)\n         {x. Domainp R x} (run_converter conv1 a)\\<rbrakk>\n       \\<Longrightarrow> Domainp C x\n 2. \\<And>b conv' conv a.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(erule pred_gpv'.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b conv1 conv2.\n       \\<lbrakk>x \\<in> outs_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                         (run_converter conv1 a);\n        A a b;\n        \\<And>x.\n           x \\<in> results_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                    (run_converter conv1 a) \\<Longrightarrow>\n           Domainp (rel_prod B (rel_converter A B C R)) x;\n        \\<And>out.\n           out\n           \\<in> outs_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                  (run_converter conv1 a) \\<Longrightarrow>\n           Domainp C out\\<rbrakk>\n       \\<Longrightarrow> Domainp C x\n 2. \\<And>b conv' conv a.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b conv' conv a.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        a \\<in> outs_\\<I> (\\<I>_uniform (Collect (Domainp A)) UNIV);\n        Domainp (rel_converter A B C R) conv\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b conv' conv a ba bb.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        A a ba; rel_converter A B C R conv bb\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(erule rel_converter.cases; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b conv' a ba conv1 conv2.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        A a ba;\n        rel_fun A (rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n         (run_converter conv1) (run_converter conv2)\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(drule (1) rel_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b conv' a ba conv1 conv2.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        A a ba;\n        rel_gpv'' (rel_prod B (rel_converter A B C R)) C R\n         (run_converter conv1 a) (run_converter conv2 ba)\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(drule Domainp_rel_gpv''_le[THEN predicate1D, OF DomainPI])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b conv' a ba conv1 conv2.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        A a ba;\n        pred_gpv' (Domainp (rel_prod B (rel_converter A B C R))) (Domainp C)\n         {x. Domainp R x} (run_converter conv1 a)\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply(erule pred_gpv'.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b conv' a ba conv1 conv2.\n       \\<lbrakk>(b, conv')\n                \\<in> results_gpv (\\<I>_uniform UNIV (Collect (Domainp R)))\n                       (run_converter conv1 a);\n        x \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n                 (\\<I>_uniform UNIV (Collect (Domainp R))) conv';\n        Domainp (rel_converter A B C R) conv' \\<Longrightarrow> Domainp C x;\n        A a ba;\n        \\<And>x.\n           x \\<in> results_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                    (run_converter conv1 a) \\<Longrightarrow>\n           Domainp (rel_prod B (rel_converter A B C R)) x;\n        \\<And>out.\n           out\n           \\<in> outs_gpv (\\<I>_uniform UNIV {x. Domainp R x})\n                  (run_converter conv1 a) \\<Longrightarrow>\n           Domainp C out\\<rbrakk>\n       \\<Longrightarrow> Domainp C x", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x1\n  \\<in> outs_converter (\\<I>_uniform (Collect (Domainp A)) UNIV)\n         (\\<I>_uniform UNIV (Collect (Domainp R))) conv \\<Longrightarrow>\n  Domainp C ?x1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_converter_Grp:\n  \"rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g) (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> =\n   BNF_Def.Grp {conv. results_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv \\<subseteq> B \\<and> \n    outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv \\<subseteq> C}\n    (map_converter f g h k)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n     (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> =\n    BNF_Def.Grp\n     {conv.\n      results_converter (\\<I>_uniform (range f) UNIV)\n       (\\<I>_uniform UNIV (range k)) conv\n      \\<subseteq> B \\<and>\n      outs_converter (\\<I>_uniform (range f) UNIV)\n       (\\<I>_uniform UNIV (range k)) conv\n      \\<subseteq> C}\n     (map_converter f g h k)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n     (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> =\n    BNF_Def.Grp\n     {conv.\n      results_converter (\\<I>_uniform (range f) UNIV)\n       (\\<I>_uniform UNIV (range k)) conv\n      \\<subseteq> B \\<and>\n      outs_converter (\\<I>_uniform (range f) UNIV)\n       (\\<I>_uniform UNIV (range k)) conv\n      \\<subseteq> C}\n     (map_converter f g h k)", "proof(intro ext GrpI iffI CollectI conjI subsetI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa \\<Longrightarrow>\n       map_converter f g h k x = xa\n 2. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> results_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B\n 3. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> C\n 4. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "let ?\\<I> = \"\\<I>_uniform (range f) UNIV\" and ?\\<I>' = \"\\<I>_uniform UNIV (range k)\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa \\<Longrightarrow>\n       map_converter f g h k x = xa\n 2. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> results_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B\n 3. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> C\n 4. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "fix conv conv'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa \\<Longrightarrow>\n       map_converter f g h k x = xa\n 2. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> results_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B\n 3. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> C\n 4. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "assume *: \"?lhs conv conv'\""], ["proof (state)\nthis:\n  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n   (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'\n\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa \\<Longrightarrow>\n       map_converter f g h k x = xa\n 2. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> results_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B\n 3. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> C\n 4. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "then"], ["proof (chain)\npicking this:\n  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n   (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'", "show \"map_converter f g h k conv = conv'\""], ["proof (prove)\nusing this:\n  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n   (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'\n\ngoal (1 subgoal):\n 1. map_converter f g h k conv = conv'", "apply(coinduction arbitrary: conv conv')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv\n        conv' \\<Longrightarrow>\n       ((=) ===>\n        rel_gpv\n         (rel_prod (=)\n           (\\<lambda>converter__ converter'__.\n               \\<exists>conv conv'.\n                  converter__ = map_converter f g h k conv \\<and>\n                  converter'__ = conv' \\<and>\n                  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                   (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                   (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n         (=))\n        (run_converter (map_converter f g h k conv)) (run_converter conv')", "apply(drule rel_converterD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n        rel_gpv''\n         (rel_prod (BNF_Def.Grp B g)\n           (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n             (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n             (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n         (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n        (run_converter conv) (run_converter conv') \\<Longrightarrow>\n       ((=) ===>\n        rel_gpv\n         (rel_prod (=)\n           (\\<lambda>converter__ converter'__.\n               \\<exists>conv conv'.\n                  converter__ = map_converter f g h k conv \\<and>\n                  converter'__ = conv' \\<and>\n                  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                   (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                   (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n         (=))\n        (run_converter (map_converter f g h k conv)) (run_converter conv')", "apply(unfold map_converter.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n        rel_gpv''\n         (rel_prod (BNF_Def.Grp B g)\n           (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n             (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n             (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n         (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n        (run_converter conv) (run_converter conv') \\<Longrightarrow>\n       ((=) ===>\n        rel_gpv\n         (rel_prod (=)\n           (\\<lambda>converter__ converter'__.\n               \\<exists>conv conv'.\n                  converter__ = map_converter f g h k conv \\<and>\n                  converter'__ = conv' \\<and>\n                  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                   (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                   (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n         (=))\n        (map_gpv (map_prod g (map_converter f g h k)) h \\<circ>\n         map_gpv' id id k \\<circ>\n         run_converter conv \\<circ>\n         f)\n        (run_converter conv')", "apply(subst (2) map_fun_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n        rel_gpv''\n         (rel_prod (BNF_Def.Grp B g)\n           (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n             (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n             (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n         (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n        (run_converter conv) (run_converter conv') \\<Longrightarrow>\n       ((=) ===>\n        rel_gpv\n         (rel_prod (=)\n           (\\<lambda>converter__ converter'__.\n               \\<exists>conv conv'.\n                  converter__ = map_converter f g h k conv \\<and>\n                  converter'__ = conv' \\<and>\n                  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                   (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                   (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n         (=))\n        ((f --->\n          map_gpv (map_prod g (map_converter f g h k)) h \\<circ>\n          map_gpv' id id k)\n          (run_converter conv))\n        (run_converter conv')", "apply(subst map_fun2_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n        rel_gpv''\n         (rel_prod (BNF_Def.Grp B g)\n           (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n             (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n             (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n         (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n        (run_converter conv) (run_converter conv') \\<Longrightarrow>\n       ((=) ===>\n        rel_gpv\n         (rel_prod (=)\n           (\\<lambda>converter__ converter'__.\n               \\<exists>conv conv'.\n                  converter__ = map_converter f g h k conv \\<and>\n                  converter'__ = conv' \\<and>\n                  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                   (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                   (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n         (=))\n        (map_gpv (map_prod g (map_converter f g h k)) h \\<circ>\n         map_gpv' id id k \\<circ>\n         (f ---> id) (run_converter conv))\n        (run_converter conv')", "apply(subst rel_fun_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n        rel_gpv''\n         (rel_prod (BNF_Def.Grp B g)\n           (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n             (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n             (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n         (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n        (run_converter conv) (run_converter conv') \\<Longrightarrow>\n       ((=) ===>\n        (\\<lambda>x.\n            rel_gpv\n             (rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv conv'.\n                      converter__ = map_converter f g h k conv \\<and>\n                      converter'__ = conv' \\<and>\n                      rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                       (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                       (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n             (=)\n             ((map_gpv (map_prod g (map_converter f g h k)) h \\<circ>\n               map_gpv' id id k)\n               x)))\n        ((f ---> id) (run_converter conv)) (run_converter conv')", "apply(rule rel_fun_map_fun1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv'.\n       ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n        rel_gpv''\n         (rel_prod (BNF_Def.Grp B g)\n           (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n             (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n             (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n         (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n        (run_converter conv) (run_converter conv') \\<Longrightarrow>\n       ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n        (\\<lambda>x.\n            rel_gpv\n             (rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv conv'.\n                      converter__ = map_converter f g h k conv \\<and>\n                      converter'__ = conv' \\<and>\n                      rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                       (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                       (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n             (=)\n             ((map_gpv (map_prod g (map_converter f g h k)) h \\<circ>\n               map_gpv' id id k)\n               x)))\n        (run_converter conv) (run_converter conv')", "apply(erule rel_fun_mono, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv conv' x y.\n       rel_gpv''\n        (rel_prod (BNF_Def.Grp B g)\n          (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n            (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n        (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x\n        y \\<Longrightarrow>\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv conv'.\n                 converter__ = map_converter f g h k conv \\<and>\n                 converter'__ = conv' \\<and>\n                 rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                  (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                  (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'))\n        (=)\n        ((map_gpv (map_prod g (map_converter f g h k)) h \\<circ>\n          map_gpv' id id k)\n          x)\n        y", "apply(simp add: gpv.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_gpv''\n        (rel_prod (BNF_Def.Grp B g)\n          (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n            (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n        (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x\n        y \\<Longrightarrow>\n       rel_gpv\n        (\\<lambda>x.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv.\n                    converter__ = map_converter f g h k conv \\<and>\n                    rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                     (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                     (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv\n                     converter'__)\n             (map_prod g (map_converter f g h k) x))\n        (\\<lambda>x. (=) (h x)) (map_gpv' id id k x) y", "by (auto simp add: rel_gpv_conv_rel_gpv'' prod.rel_map intro!: predicate2I rel_gpv''_map_gpv'1\n        elim!: rel_gpv''_mono[THEN predicate2D, rotated -1] prod.rel_mono_strong GrpE)"], ["proof (state)\nthis:\n  map_converter f g h k conv = conv'\n\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> results_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> B\n 2. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> C\n 3. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "show \"b \\<in> B\" if \"b \\<in> results_converter ?\\<I> ?\\<I>' conv\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> B", "using * that"], ["proof (prove)\nusing this:\n  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n   (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'\n  b \\<in> results_converter (\\<I>_uniform (range f) UNIV)\n           (\\<I>_uniform UNIV (range k)) conv\n\ngoal (1 subgoal):\n 1. b \\<in> B", "by - (drule Domainp_rel_converter_le[THEN predicate1D, OF DomainPI]\n        , auto simp add: Domainp_conversep Rangep_Grp iff: Grp_iff elim: pred_converter.cases)"], ["proof (state)\nthis:\n  ?b1\n  \\<in> results_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv \\<Longrightarrow>\n  ?b1 \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa;\n        xb \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n                  (\\<I>_uniform UNIV (range k)) x\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> C\n 2. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "show \"out \\<in> C\" if \"out \\<in> outs_converter ?\\<I> ?\\<I>' conv\" for out"], ["proof (prove)\ngoal (1 subgoal):\n 1. out \\<in> C", "using * that"], ["proof (prove)\nusing this:\n  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n   (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'\n  out\n  \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n\ngoal (1 subgoal):\n 1. out \\<in> C", "by - (drule Domainp_rel_converter_le[THEN predicate1D, OF DomainPI]\n        , auto simp add: Domainp_conversep Rangep_Grp iff: Grp_iff elim: pred_converter.cases)"], ["proof (state)\nthis:\n  ?out1\n  \\<in> outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv \\<Longrightarrow>\n  ?out1 \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "let ?abr1=\"\\<lambda>conv. results_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv \\<subseteq> B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "let ?abr2=\"\\<lambda>conv. outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv \\<subseteq> C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "fix conv conv'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "assume \"?rhs conv conv'\""], ["proof (state)\nthis:\n  BNF_Def.Grp\n   {conv.\n    results_converter (\\<I>_uniform (range f) UNIV)\n     (\\<I>_uniform UNIV (range k)) conv\n    \\<subseteq> B \\<and>\n    outs_converter (\\<I>_uniform (range f) UNIV)\n     (\\<I>_uniform UNIV (range k)) conv\n    \\<subseteq> C}\n   (map_converter f g h k) conv conv'\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "hence  *: \"conv' = map_converter f g h k conv\" and f1: \"?abr1 conv\" and f2: \"?abr2 conv\""], ["proof (prove)\nusing this:\n  BNF_Def.Grp\n   {conv.\n    results_converter (\\<I>_uniform (range f) UNIV)\n     (\\<I>_uniform UNIV (range k)) conv\n    \\<subseteq> B \\<and>\n    outs_converter (\\<I>_uniform (range f) UNIV)\n     (\\<I>_uniform UNIV (range k)) conv\n    \\<subseteq> C}\n   (map_converter f g h k) conv conv'\n\ngoal (1 subgoal):\n 1. conv' = map_converter f g h k conv &&&\n    results_converter (\\<I>_uniform (range f) UNIV)\n     (\\<I>_uniform UNIV (range k)) conv\n    \\<subseteq> B &&&\n    outs_converter (\\<I>_uniform (range f) UNIV)\n     (\\<I>_uniform UNIV (range k)) conv\n    \\<subseteq> C", "by(auto simp add: Grp_iff)"], ["proof (state)\nthis:\n  conv' = map_converter f g h k conv\n  results_converter (\\<I>_uniform (range f) UNIV)\n   (\\<I>_uniform UNIV (range k)) conv\n  \\<subseteq> B\n  outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k))\n   conv\n  \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "have[intro]: \"?abr1 conv \\<Longrightarrow> ?abr2 conv \\<Longrightarrow> z \\<in> run_converter conv ` range f \\<Longrightarrow>\n       out \\<in> outs_gpv (\\<I>_uniform UNIV (range k)) z \\<Longrightarrow> BNF_Def.Grp C h out (h out)\" for conv z out"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n              (\\<I>_uniform UNIV (range k)) conv\n             \\<subseteq> B;\n     outs_converter (\\<I>_uniform (range f) UNIV)\n      (\\<I>_uniform UNIV (range k)) conv\n     \\<subseteq> C;\n     z \\<in> run_converter conv ` range f;\n     out \\<in> outs_gpv (\\<I>_uniform UNIV (range k)) z\\<rbrakk>\n    \\<Longrightarrow> BNF_Def.Grp C h out (h out)", "by(auto simp add: Grp_iff elim:  outs_converter.Out elim!: subsetD)"], ["proof (state)\nthis:\n  \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n            (\\<I>_uniform UNIV (range k)) ?conv2\n           \\<subseteq> B;\n   outs_converter (\\<I>_uniform (range f) UNIV)\n    (\\<I>_uniform UNIV (range k)) ?conv2\n   \\<subseteq> C;\n   ?z2 \\<in> run_converter ?conv2 ` range f;\n   ?out2 \\<in> outs_gpv (\\<I>_uniform UNIV (range k)) ?z2\\<rbrakk>\n  \\<Longrightarrow> BNF_Def.Grp C h ?out2 (h ?out2)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> B \\<and>\n         outs_converter (\\<I>_uniform (range f) UNIV)\n          (\\<I>_uniform UNIV (range k)) conv\n         \\<subseteq> C}\n        (map_converter f g h k) x xa \\<Longrightarrow>\n       rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n        (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x xa", "from f1 f2"], ["proof (chain)\npicking this:\n  results_converter (\\<I>_uniform (range f) UNIV)\n   (\\<I>_uniform UNIV (range k)) conv\n  \\<subseteq> B\n  outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k))\n   conv\n  \\<subseteq> C", "show \"?lhs conv conv'\""], ["proof (prove)\nusing this:\n  results_converter (\\<I>_uniform (range f) UNIV)\n   (\\<I>_uniform UNIV (range k)) conv\n  \\<subseteq> B\n  outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k))\n   conv\n  \\<subseteq> C\n\ngoal (1 subgoal):\n 1. rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n     (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'", "unfolding *"], ["proof (prove)\nusing this:\n  results_converter (\\<I>_uniform (range f) UNIV)\n   (\\<I>_uniform UNIV (range k)) conv\n  \\<subseteq> B\n  outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k))\n   conv\n  \\<subseteq> C\n\ngoal (1 subgoal):\n 1. rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n     (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv\n     (map_converter f g h k conv)", "apply(coinduction arbitrary: conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n                          rel_gpv''\n                           (rel_prod (BNF_Def.Grp B g)\n                             (\\<lambda>conv1 conv2.\n                                 (\\<exists>conv.\n                                     conv1 = conv \\<and>\n                                     conv2 =\n                                     map_converter f g h k conv \\<and>\n                                     results_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> B \\<and>\n                                     outs_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> C) \\<or>\n                                 rel_converter\n                                  (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                  (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                  (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                  conv1 conv2))\n                           (BNF_Def.Grp C h)\n                           (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n                          (run_converter conv)\n                          (run_converter (map_converter f g h k conv))", "apply(unfold map_converter.sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n                          rel_gpv''\n                           (rel_prod (BNF_Def.Grp B g)\n                             (\\<lambda>conv1 conv2.\n                                 (\\<exists>conv.\n                                     conv1 = conv \\<and>\n                                     conv2 =\n                                     map_converter f g h k conv \\<and>\n                                     results_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> B \\<and>\n                                     outs_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> C) \\<or>\n                                 rel_converter\n                                  (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                  (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                  (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                  conv1 conv2))\n                           (BNF_Def.Grp C h)\n                           (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n                          (run_converter conv)\n                          (map_gpv (map_prod g (map_converter f g h k))\n                            h \\<circ>\n                           map_gpv' id id k \\<circ>\n                           run_converter conv \\<circ>\n                           f)", "apply(subst (2) map_fun_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n                          rel_gpv''\n                           (rel_prod (BNF_Def.Grp B g)\n                             (\\<lambda>conv1 conv2.\n                                 (\\<exists>conv.\n                                     conv1 = conv \\<and>\n                                     conv2 =\n                                     map_converter f g h k conv \\<and>\n                                     results_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> B \\<and>\n                                     outs_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> C) \\<or>\n                                 rel_converter\n                                  (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                  (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                  (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                  conv1 conv2))\n                           (BNF_Def.Grp C h)\n                           (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n                          (run_converter conv)\n                          ((f --->\n                            map_gpv (map_prod g (map_converter f g h k))\n                             h \\<circ>\n                            map_gpv' id id k)\n                            (run_converter conv))", "apply(subst map_fun2_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n                          rel_gpv''\n                           (rel_prod (BNF_Def.Grp B g)\n                             (\\<lambda>conv1 conv2.\n                                 (\\<exists>conv.\n                                     conv1 = conv \\<and>\n                                     conv2 =\n                                     map_converter f g h k conv \\<and>\n                                     results_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> B \\<and>\n                                     outs_converter\n(\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k)) conv\n                                     \\<subseteq> C) \\<or>\n                                 rel_converter\n                                  (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                  (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                  (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                  conv1 conv2))\n                           (BNF_Def.Grp C h)\n                           (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n                          (run_converter conv)\n                          (map_gpv (map_prod g (map_converter f g h k))\n                            h \\<circ>\n                           map_gpv' id id k \\<circ>\n                           (f ---> id) (run_converter conv))", "apply(subst rel_fun_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> ((BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> ===>\n                          (\\<lambda>x y.\n                              rel_gpv''\n                               (rel_prod (BNF_Def.Grp B g)\n                                 (\\<lambda>conv1 conv2.\n                                     (\\<exists>conv.\n   conv1 = conv \\<and>\n   conv2 = map_converter f g h k conv \\<and>\n   results_converter (\\<I>_uniform (range f) UNIV)\n    (\\<I>_uniform UNIV (range k)) conv\n   \\<subseteq> B \\<and>\n   outs_converter (\\<I>_uniform (range f) UNIV)\n    (\\<I>_uniform UNIV (range k)) conv\n   \\<subseteq> C) \\<or>\n                                     rel_converter\n(BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n(BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv1 conv2))\n                               (BNF_Def.Grp C h)\n                               (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x\n                               ((map_gpv\n                                  (map_prod g (map_converter f g h k))\n                                  h \\<circ>\n                                 map_gpv' id id k)\n                                 y)))\n                          (run_converter conv)\n                          ((f ---> id) (run_converter conv))", "apply(rule rel_fun_map_fun2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> (eq_on (range f) ===>\n                          (\\<lambda>x y.\n                              rel_gpv''\n                               (rel_prod (BNF_Def.Grp B g)\n                                 (\\<lambda>conv1 conv2.\n                                     (\\<exists>conv.\n   conv1 = conv \\<and>\n   conv2 = map_converter f g h k conv \\<and>\n   results_converter (\\<I>_uniform (range f) UNIV)\n    (\\<I>_uniform UNIV (range k)) conv\n   \\<subseteq> B \\<and>\n   outs_converter (\\<I>_uniform (range f) UNIV)\n    (\\<I>_uniform UNIV (range k)) conv\n   \\<subseteq> C) \\<or>\n                                     rel_converter\n(BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n(BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv1 conv2))\n                               (BNF_Def.Grp C h)\n                               (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x\n                               ((map_gpv\n                                  (map_prod g (map_converter f g h k))\n                                  h \\<circ>\n                                 map_gpv' id id k)\n                                 y)))\n                          (run_converter conv) (run_converter conv)", "apply(rule rel_fun_refl_eq_onp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv z.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (BNF_Def.Grp B g)\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv.\n                                    conv1 = conv \\<and>\n                                    conv2 =\n                                    map_converter f g h k conv \\<and>\n                                    results_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> B \\<and>\n                                    outs_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> C) \\<or>\n                                rel_converter\n                                 (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                 conv1 conv2))\n                          (BNF_Def.Grp C h)\n                          (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> z\n                          ((map_gpv (map_prod g (map_converter f g h k))\n                             h \\<circ>\n                            map_gpv' id id k)\n                            z)", "apply(unfold map_gpv_conv_map_gpv' gpv.comp comp_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv z.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (BNF_Def.Grp B g)\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv.\n                                    conv1 = conv \\<and>\n                                    conv2 =\n                                    map_converter f g h k conv \\<and>\n                                    results_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> B \\<and>\n                                    outs_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> C) \\<or>\n                                rel_converter\n                                 (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                 conv1 conv2))\n                          (BNF_Def.Grp C h)\n                          (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> z\n                          (map_gpv' (map_prod g (map_converter f g h k)) h k\n                            z)", "apply(subst map_gpv'_id12)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv z.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (BNF_Def.Grp B g)\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv.\n                                    conv1 = conv \\<and>\n                                    conv2 =\n                                    map_converter f g h k conv \\<and>\n                                    results_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> B \\<and>\n                                    outs_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> C) \\<or>\n                                rel_converter\n                                 (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                 conv1 conv2))\n                          (BNF_Def.Grp C h)\n                          (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> z\n                          (map_gpv' id id k\n                            (map_gpv (map_prod g (map_converter f g h k)) h\n                              z))", "apply(rule rel_gpv''_map_gpv'2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv z.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (rel_prod (BNF_Def.Grp B g)\n                            (\\<lambda>conv1 conv2.\n                                (\\<exists>conv.\n                                    conv1 = conv \\<and>\n                                    conv2 =\n                                    map_converter f g h k conv \\<and>\n                                    results_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> B \\<and>\n                                    outs_converter\n                                     (\\<I>_uniform (range f) UNIV)\n                                     (\\<I>_uniform UNIV (range k)) conv\n                                    \\<subseteq> C) \\<or>\n                                rel_converter\n                                 (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                 (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                 (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                 conv1 conv2))\n                          (BNF_Def.Grp C h) (eq_on (range k)) z\n                          (map_gpv (map_prod g (map_converter f g h k)) h z)", "apply(unfold rel_gpv''_map_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv z.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f\\<rbrakk>\n       \\<Longrightarrow> rel_gpv''\n                          (\\<lambda>a b.\n                              rel_prod (BNF_Def.Grp B g)\n                               (\\<lambda>conv1 conv2.\n                                   (\\<exists>conv.\n conv1 = conv \\<and>\n conv2 = map_converter f g h k conv \\<and>\n results_converter (\\<I>_uniform (range f) UNIV)\n  (\\<I>_uniform UNIV (range k)) conv\n \\<subseteq> B \\<and>\n outs_converter (\\<I>_uniform (range f) UNIV) (\\<I>_uniform UNIV (range k))\n  conv\n \\<subseteq> C) \\<or>\n                                   rel_converter\n                                    (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                                    (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                                    (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                                    conv1 conv2)\n                               a (map_prod g (map_converter f g h k) b))\n                          (\\<lambda>c d. BNF_Def.Grp C h c (h d))\n                          (eq_on (range k)) z z", "apply(rule rel_gpv''_refl_eq_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv z x.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        x \\<in> results_gpv (\\<I>_uniform UNIV (range k)) z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (BNF_Def.Grp B g)\n                          (\\<lambda>conv1 conv2.\n                              (\\<exists>conv.\n                                  conv1 = conv \\<and>\n                                  conv2 = map_converter f g h k conv \\<and>\n                                  results_converter\n                                   (\\<I>_uniform (range f) UNIV)\n                                   (\\<I>_uniform UNIV (range k)) conv\n                                  \\<subseteq> B \\<and>\n                                  outs_converter\n                                   (\\<I>_uniform (range f) UNIV)\n                                   (\\<I>_uniform UNIV (range k)) conv\n                                  \\<subseteq> C) \\<or>\n                              rel_converter\n                               (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                               (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                               (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n                               conv1 conv2)\n                          x (map_prod g (map_converter f g h k) x)\n 2. \\<And>conv z out.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        out \\<in> outs_gpv (\\<I>_uniform UNIV (range k)) z\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp C h out (h out)", "apply(simp add: prod.rel_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv z x.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        x \\<in> results_gpv (\\<I>_uniform UNIV (range k)) z\\<rbrakk>\n       \\<Longrightarrow> rel_prod (\\<lambda>x y. BNF_Def.Grp B g x (g y))\n                          (\\<lambda>x y.\n                              map_converter f g h k y =\n                              map_converter f g h k x \\<and>\n                              results_converter\n                               (\\<I>_uniform (range f) UNIV)\n                               (\\<I>_uniform UNIV (range k)) x\n                              \\<subseteq> B \\<and>\n                              outs_converter (\\<I>_uniform (range f) UNIV)\n                               (\\<I>_uniform UNIV (range k)) x\n                              \\<subseteq> C \\<or>\n                              rel_converter\n                               (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                               (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                               (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> x\n                               (map_converter f g h k y))\n                          x x\n 2. \\<And>conv z out.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        out \\<in> outs_gpv (\\<I>_uniform UNIV (range k)) z\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp C h out (h out)", "apply(rule prod.rel_refl_strong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conv z x z1.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        x \\<in> results_gpv (\\<I>_uniform UNIV (range k)) z;\n        z1 \\<in> Basic_BNFs.fsts x\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp B g z1 (g z1)\n 2. \\<And>conv z x z2.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        x \\<in> results_gpv (\\<I>_uniform UNIV (range k)) z;\n        z2 \\<in> Basic_BNFs.snds x\\<rbrakk>\n       \\<Longrightarrow> map_converter f g h k z2 =\n                         map_converter f g h k z2 \\<and>\n                         results_converter (\\<I>_uniform (range f) UNIV)\n                          (\\<I>_uniform UNIV (range k)) z2\n                         \\<subseteq> B \\<and>\n                         outs_converter (\\<I>_uniform (range f) UNIV)\n                          (\\<I>_uniform UNIV (range k)) z2\n                         \\<subseteq> C \\<or>\n                         rel_converter\n                          (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                          (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                          (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> z2\n                          (map_converter f g h k z2)\n 3. \\<And>conv z out.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        out \\<in> outs_gpv (\\<I>_uniform UNIV (range k)) z\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp C h out (h out)", "apply(clarsimp simp add: Grp_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conv a b xa.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        (a, b)\n        \\<in> results_gpv (\\<I>_uniform UNIV (range k))\n               (run_converter conv (f xa))\\<rbrakk>\n       \\<Longrightarrow> a \\<in> B\n 2. \\<And>conv z x z2.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        x \\<in> results_gpv (\\<I>_uniform UNIV (range k)) z;\n        z2 \\<in> Basic_BNFs.snds x\\<rbrakk>\n       \\<Longrightarrow> map_converter f g h k z2 =\n                         map_converter f g h k z2 \\<and>\n                         results_converter (\\<I>_uniform (range f) UNIV)\n                          (\\<I>_uniform UNIV (range k)) z2\n                         \\<subseteq> B \\<and>\n                         outs_converter (\\<I>_uniform (range f) UNIV)\n                          (\\<I>_uniform UNIV (range k)) z2\n                         \\<subseteq> C \\<or>\n                         rel_converter\n                          (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n                          (BNF_Def.Grp B g) (BNF_Def.Grp C h)\n                          (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> z2\n                          (map_converter f g h k z2)\n 3. \\<And>conv z out.\n       \\<lbrakk>results_converter (\\<I>_uniform (range f) UNIV)\n                 (\\<I>_uniform UNIV (range k)) conv\n                \\<subseteq> B;\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> C;\n        z \\<in> run_converter conv ` range f;\n        out \\<in> outs_gpv (\\<I>_uniform UNIV (range k)) z\\<rbrakk>\n       \\<Longrightarrow> BNF_Def.Grp C h out (h out)", "by (auto intro: results_converter.Result results_converter.Cont outs_converter.Cont elim!: subsetD)"], ["proof (state)\nthis:\n  rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp B g)\n   (BNF_Def.Grp C h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> conv conv'\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  includes lifting_syntax \n  notes [transfer_rule] = map_gpv_parametric'\nbegin"], ["", "lemma Converter_parametric [transfer_rule]:\n  \"((A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) ===> rel_converter A B C R) Converter Converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) ===>\n     rel_converter A B C R)\n     Converter Converter", "by(rule rel_funI)(simp)"], ["", "lemma run_converter_parametric [transfer_rule]:\n  \"(rel_converter A B C R ===> A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n  run_converter run_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R)\n     run_converter run_converter", "by(rule rel_funI)(auto dest: rel_converterD)"], ["", "lemma corec_converter_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S)) C R) ===> S ===> rel_converter A B C R)\n   corec_converter corec_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===>\n      A ===>\n      rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S)) C R) ===>\n     S ===> rel_converter A B C R)\n     corec_converter corec_converter", "proof((rule rel_funI)+, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(S ===>\n                 A ===>\n                 rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S))\n                  C R)\n                 x y;\n        S xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_converter A B C R (corec_converter x xa)\n                          (corec_converter y ya)", "case (1 f g s1 s2)"], ["proof (state)\nthis:\n  (S ===>\n   A ===> rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S)) C R)\n   f g\n  S s1 s2\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(S ===>\n                 A ===>\n                 rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S))\n                  C R)\n                 x y;\n        S xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_converter A B C R (corec_converter x xa)\n                          (corec_converter y ya)", "then"], ["proof (chain)\npicking this:\n  (S ===>\n   A ===> rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S)) C R)\n   f g\n  S s1 s2", "show ?case"], ["proof (prove)\nusing this:\n  (S ===>\n   A ===> rel_gpv'' (rel_prod B (rel_sum (rel_converter A B C R) S)) C R)\n   f g\n  S s1 s2\n\ngoal (1 subgoal):\n 1. rel_converter A B C R (corec_converter f s1) (corec_converter g s2)", "by(coinduction arbitrary: s1 s2)\n      (drule 1(1)[THEN rel_funD]\n        , auto 4 4 simp add: rel_fun_comp prod.rel_map[abs_def] rel_gpv''_map_gpv prod.rel_map split: sum.split \n        intro: prod.rel_mono elim!: rel_fun_mono rel_gpv''_mono[THEN predicate2D, rotated -1])"], ["proof (state)\nthis:\n  rel_converter A B C R (corec_converter f s1) (corec_converter g s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_converter_parametric [transfer_rule]:\n  \"((A' ===> A) ===> (B ===> B') ===> (C ===> C') ===> (R' ===> R) ===> rel_converter A B C R ===> rel_converter A' B' C' R')\n  map_converter map_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A' ===> A) ===>\n     (B ===> B') ===>\n     (C ===> C') ===>\n     (R' ===> R) ===> rel_converter A B C R ===> rel_converter A' B' C' R')\n     map_converter map_converter", "unfolding map_converter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A' ===> A) ===>\n     (B ===> B') ===>\n     (C ===> C') ===>\n     (R' ===> R) ===> rel_converter A B C R ===> rel_converter A' B' C' R')\n     (\\<lambda>a b out inn.\n         corec_converter\n          (\\<lambda>conv.\n              map_gpv (map_prod b Inr) out \\<circ>\n              map_gpv' id id inn \\<circ>\n              run_converter conv \\<circ>\n              a))\n     (\\<lambda>a b out inn.\n         corec_converter\n          (\\<lambda>conv.\n              map_gpv (map_prod b Inr) out \\<circ>\n              map_gpv' id id inn \\<circ>\n              run_converter conv \\<circ>\n              a))", "by(transfer_prover)"], ["", "lemma map_converter'_parametric [transfer_rule]:\n  \"((B ===> B') ===> (C ===> C') ===> rel_converter (=) B C (=) ===> rel_converter (=) B' C' (=))\n  map_converter' map_converter'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> B') ===>\n     (C ===> C') ===>\n     rel_converter (=) B C (=) ===> rel_converter (=) B' C' (=))\n     map_converter' map_converter'", "unfolding map_converter_id14[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> B') ===>\n     (C ===> C') ===>\n     rel_converter (=) B C (=) ===> rel_converter (=) B' C' (=))\n     (\\<lambda>b out. map_converter id b out id)\n     (\\<lambda>b out. map_converter id b out id)", "by transfer_prover"], ["", "lemma case_converter_parametric [transfer_rule]:\n  \"(((A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) ===> X) ===> rel_converter A B C R ===> X)\n  case_converter case_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) ===>\n      X) ===>\n     rel_converter A B C R ===> X)\n     case_converter case_converter", "unfolding case_converter_conv_run_converter"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((A ===> rel_gpv'' (rel_prod B (rel_converter A B C R)) C R) ===>\n      X) ===>\n     rel_converter A B C R ===> X)\n     (\\<lambda>f conv. f (run_converter conv))\n     (\\<lambda>f conv. f (run_converter conv))", "by transfer_prover"], ["", "end"], ["", "subsection \\<open>Well-typing\\<close>"], ["", "coinductive WT_converter :: \"('a, 'b) \\<I> \\<Rightarrow> ('out, 'in) \\<I> \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<Rightarrow> bool\"\n  (\"_,/ _ \\<turnstile>\\<^sub>C/ _ \\<surd>\" [100, 0, 0] 99)\n  for \\<I> \\<I>' where\n    WT_converterI: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" if\n    \"\\<And>q. q \\<in> outs_\\<I> \\<I> \\<Longrightarrow> \\<I>' \\<turnstile>g run_converter conv q \\<surd>\"\n    \"\\<And>q r conv'. \\<lbrakk> q \\<in> outs_\\<I> \\<I>; (r, conv') \\<in> results_gpv \\<I>' (run_converter conv q) \\<rbrakk> \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>\""], ["", "lemma WT_converter_coinduct[consumes 1, case_names WT_converter, case_conclusion WT_converter WT_gpv results_gpv, coinduct pred: WT_converter]:\n  assumes \"X conv\"\n    and \"\\<And>conv q r conv'. \\<lbrakk> X conv; q \\<in> outs_\\<I> \\<I> \\<rbrakk>\n  \\<Longrightarrow> \\<I>' \\<turnstile>g run_converter conv q \\<surd> \\<and>\n      ((r, conv') \\<in> results_gpv \\<I>' (run_converter conv q) \\<longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> (X conv' \\<or> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "using assms(1)"], ["proof (prove)\nusing this:\n  X conv\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "by(rule WT_converter.coinduct)(blast dest: assms(2))"], ["", "lemma WT_converterD:\n  assumes \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"q \\<in> outs_\\<I> \\<I>\"\n  shows WT_converterD_WT: \"\\<I>' \\<turnstile>g run_converter conv q \\<surd>\"\n    and WT_converterD_results: \"(r, conv') \\<in> results_gpv \\<I>' (run_converter conv q) \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g run_converter conv q \\<surd> &&&\n    ((r, conv')\n     \\<in> results_gpv \\<I>' (run_converter conv q) \\<Longrightarrow>\n     r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n     conv' \\<surd>)", "using assms"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g run_converter conv q \\<surd> &&&\n    ((r, conv')\n     \\<in> results_gpv \\<I>' (run_converter conv q) \\<Longrightarrow>\n     r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n     conv' \\<surd>)", "by(auto elim: WT_converter.cases)"], ["", "lemma WT_converterD':\n  assumes \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"q \\<in> outs_\\<I> \\<I>\"\n  shows \"\\<I>' \\<turnstile>g run_converter conv q \\<surd> \\<and> (\\<forall>(r, conv') \\<in> results_gpv \\<I>' (run_converter conv q). r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g run_converter conv q \\<surd> \\<and>\n    (\\<forall>(r, conv')\\<in>results_gpv \\<I>' (run_converter conv q).\n        r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>,\n        \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)", "using assms"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g run_converter conv q \\<surd> \\<and>\n    (\\<forall>(r, conv')\\<in>results_gpv \\<I>' (run_converter conv q).\n        r \\<in> responses_\\<I> \\<I> q \\<and> \\<I>,\n        \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)", "by(auto elim: WT_converter.cases)"], ["", "lemma WT_converter_bot1 [simp]: \"bot, \\<I> \\<turnstile>\\<^sub>C conv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom>, \\<I> \\<turnstile>\\<^sub>C conv \\<surd>", "by(rule WT_converter.intros) auto"], ["", "lemma WT_converter_mono: \n  \"\\<lbrakk> \\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>; \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2' \\<rbrakk>  \\<Longrightarrow> \\<I>1',\\<I>2' \\<turnstile>\\<^sub>C conv \\<surd> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'\\<rbrakk>\n    \\<Longrightarrow> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv \\<surd>", "apply(coinduction arbitrary: conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> \\<I>2'\n                         \\<turnstile>g run_converter conva q \\<surd> \\<and>\n                         ((r, conv')\n                          \\<in> results_gpv \\<I>2'\n                                 (run_converter conva q) \\<longrightarrow>\n                          r \\<in> responses_\\<I> \\<I>1' q \\<and>\n                          ((\\<exists>conv.\n                               conv' = conv \\<and>\n                               \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                               conv \\<surd> \\<and>\n                               \\<I>1' \\<le> \\<I>1 \\<and>\n                               \\<I>2 \\<le> \\<I>2') \\<or>\n                           \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C\n                           conv' \\<surd>))", "apply(auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> \\<I>2' \\<turnstile>g run_converter conva q \\<surd>\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(drule WT_converterD_WT)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q conva.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> ?q8 q conva \\<in> outs_\\<I> \\<I>1\n 2. \\<And>q conva.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1';\n        \\<I>2\n        \\<turnstile>g run_converter conva (?q8 q conva) \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>2' \\<turnstile>g run_converter conva q \\<surd>\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 4. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule (1) outs_\\<I>_mono[THEN subsetD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q conva.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1';\n        \\<I>2 \\<turnstile>g run_converter conva q \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>2' \\<turnstile>g run_converter conva q \\<surd>\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule WT_gpv_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q conva.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> outs_\\<I> \\<I>2 \\<subseteq> outs_\\<I> \\<I>2'\n 2. \\<And>q conva x.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1'; x \\<in> outs_\\<I> \\<I>2\\<rbrakk>\n       \\<Longrightarrow> responses_\\<I> \\<I>2' x\n                         \\<subseteq> responses_\\<I> \\<I>2 x\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 4. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule outs_\\<I>_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q conva x.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2';\n        q \\<in> outs_\\<I> \\<I>1'; x \\<in> outs_\\<I> \\<I>2\\<rbrakk>\n       \\<Longrightarrow> responses_\\<I> \\<I>2' x\n                         \\<subseteq> responses_\\<I> \\<I>2 x\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule (1) responses_\\<I>_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(frule WT_converterD_results)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> ?q20 q r conv' conva \\<in> outs_\\<I> \\<I>1\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> (?r20 q r conv' conva, ?conv'20 q r conv' conva)\n                         \\<in> results_gpv \\<I>2\n                                (run_converter conva (?q20 q r conv' conva))\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        ?r20 q r conv' conva\n        \\<in> responses_\\<I> \\<I>1 (?q20 q r conv' conva) \\<and>\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n        ?conv'20 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 4. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule (1) outs_\\<I>_mono[THEN subsetD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> (?r20 q r conv' conva, ?conv'20 q r conv' conva)\n                         \\<in> results_gpv \\<I>2 (run_converter conva q)\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        ?r20 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'20 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule results_gpv_mono[THEN subsetD])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<turnstile>g run_converter conva q \\<surd>\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> (?r20 q r conv' conva, ?conv'20 q r conv' conva)\n                         \\<in> results_gpv \\<I>2' (run_converter conva q)\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        ?r20 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'20 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 4. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule WT_converterD_WT)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> outs_\\<I> \\<I>1\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> (?r20 q r conv' conva, ?conv'20 q r conv' conva)\n                         \\<in> results_gpv \\<I>2' (run_converter conva q)\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        ?r20 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'20 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 4. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule (1) outs_\\<I>_mono[THEN subsetD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q)\\<rbrakk>\n       \\<Longrightarrow> (?r20 q r conv' conva, ?conv'20 q r conv' conva)\n                         \\<in> results_gpv \\<I>2' (run_converter conva q)\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        ?r20 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'20 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        r \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        r \\<in> responses_\\<I> \\<I>1 q;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>1' q\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule (2) responses_\\<I>_mono[THEN subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(frule WT_converterD_results)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> ?q43 q r conv' conva \\<in> outs_\\<I> \\<I>1\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (?r43 q r conv' conva, ?conv'43 q r conv' conva)\n                         \\<in> results_gpv \\<I>2\n                                (run_converter conva (?q43 q r conv' conva))\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        ?r43 q r conv' conva\n        \\<in> responses_\\<I> \\<I>1 (?q43 q r conv' conva) \\<and>\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n        ?conv'43 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule (1) outs_\\<I>_mono[THEN subsetD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (?r43 q r conv' conva, ?conv'43 q r conv' conva)\n                         \\<in> results_gpv \\<I>2 (run_converter conva q)\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        ?r43 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'43 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule results_gpv_mono[THEN subsetD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<turnstile>g run_converter conva q \\<surd>\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (?r43 q r conv' conva, ?conv'43 q r conv' conva)\n                         \\<in> results_gpv \\<I>2' (run_converter conva q)\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        ?r43 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'43 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule WT_converterD_WT)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> q \\<in> outs_\\<I> \\<I>1\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (?r43 q r conv' conva, ?conv'43 q r conv' conva)\n                         \\<in> results_gpv \\<I>2' (run_converter conva q)\n 3. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        ?r43 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'43 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply(erule (1) outs_\\<I>_mono[THEN subsetD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (?r43 q r conv' conva, ?conv'43 q r conv' conva)\n                         \\<in> results_gpv \\<I>2' (run_converter conva q)\n 2. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        ?r43 q r conv' conva \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C ?conv'43 q r conv' conva \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>1' \\<le> \\<I>1; \\<I>2 \\<le> \\<I>2'; q \\<in> outs_\\<I> \\<I>1';\n        (r, conv') \\<in> results_gpv \\<I>2' (run_converter conva q);\n        \\<not> \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        r \\<in> responses_\\<I> \\<I>1 q \\<and> \\<I>1,\n        \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma callee_invariant_on_run_resource [simp]: \"callee_invariant_on run_resource (WT_resource \\<I>) \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on run_resource (WT_resource \\<I>) \\<I>", "by(unfold_locales)(auto dest: WT_resourceD intro: WT_calleeI)"], ["", "interpretation run_resource: callee_invariant_on run_resource \"WT_resource \\<I>\" \\<I> for \\<I>"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on run_resource (WT_resource \\<I>) \\<I>", "by simp"], ["", "lemma raw_converter_invariant_run_converter: \"raw_converter_invariant \\<I> \\<I>' run_converter (WT_converter \\<I> \\<I>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (WT_converter \\<I> \\<I>')", "by(unfold_locales)(auto dest: WT_converterD)"], ["", "interpretation run_converter: raw_converter_invariant \\<I> \\<I>' run_converter \"WT_converter \\<I> \\<I>'\" for \\<I> \\<I>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (WT_converter \\<I> \\<I>')", "by(rule raw_converter_invariant_run_converter)"], ["", "lemma WT_converter_\\<I>_full: \"\\<I>_full, \\<I>_full \\<turnstile>\\<^sub>C conv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full, \\<I>_full \\<turnstile>\\<^sub>C conv \\<surd>", "by(coinduction arbitrary: conv)(auto)"], ["", "lemma WT_converter_map_converter [WT_intro]:\n  \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv \\<surd>\" if \n  *: \"map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"\n  and f: \"inj f\" and g: \"surj g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv \\<surd>", "using *"], ["proof (prove)\nusing this:\n  map_\\<I> (inv f) (inv g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n  conv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv \\<surd>", "proof(coinduction arbitrary: conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>map_\\<I> (inv f) (inv g) \\<I>,\n                map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>'\n                         \\<turnstile>g run_converter\n  (map_converter f g f' g' conva) q \\<surd> \\<and>\n                         ((r, conv')\n                          \\<in> results_gpv \\<I>'\n                                 (run_converter\n                                   (map_converter f g f' g' conva)\n                                   q) \\<longrightarrow>\n                          r \\<in> responses_\\<I> \\<I> q \\<and>\n                          ((\\<exists>conv.\n                               conv' = map_converter f g f' g' conv \\<and>\n                               map_\\<I> (inv f) (inv g) \\<I>,\n                               map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                               conv \\<surd>) \\<or>\n                           \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))", "case (WT_converter q r conv' conv)"], ["proof (state)\nthis:\n  map_\\<I> (inv f) (inv g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n  conv \\<surd>\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>map_\\<I> (inv f) (inv g) \\<I>,\n                map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>'\n                         \\<turnstile>g run_converter\n  (map_converter f g f' g' conva) q \\<surd> \\<and>\n                         ((r, conv')\n                          \\<in> results_gpv \\<I>'\n                                 (run_converter\n                                   (map_converter f g f' g' conva)\n                                   q) \\<longrightarrow>\n                          r \\<in> responses_\\<I> \\<I> q \\<and>\n                          ((\\<exists>conv.\n                               conv' = map_converter f g f' g' conv \\<and>\n                               map_\\<I> (inv f) (inv g) \\<I>,\n                               map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                               conv \\<surd>) \\<or>\n                           \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))", "have \"?WT_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>'\n    \\<turnstile>g run_converter (map_converter f g f' g' conv) q \\<surd>", "using WT_converter"], ["proof (prove)\nusing this:\n  map_\\<I> (inv f) (inv g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n  conv \\<surd>\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<I>'\n    \\<turnstile>g run_converter (map_converter f g f' g' conv) q \\<surd>", "by(auto intro!: WT_gpv_map_gpv' elim: WT_converterD_WT simp add: inv_into_f_f[OF f])"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g run_converter (map_converter f g f' g' conv) q \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>map_\\<I> (inv f) (inv g) \\<I>,\n                map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>'\n                         \\<turnstile>g run_converter\n  (map_converter f g f' g' conva) q \\<surd> \\<and>\n                         ((r, conv')\n                          \\<in> results_gpv \\<I>'\n                                 (run_converter\n                                   (map_converter f g f' g' conva)\n                                   q) \\<longrightarrow>\n                          r \\<in> responses_\\<I> \\<I> q \\<and>\n                          ((\\<exists>conv.\n                               conv' = map_converter f g f' g' conv \\<and>\n                               map_\\<I> (inv f) (inv g) \\<I>,\n                               map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                               conv \\<surd>) \\<or>\n                           \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))", "moreover"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g run_converter (map_converter f g f' g' conv) q \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>map_\\<I> (inv f) (inv g) \\<I>,\n                map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>'\n                         \\<turnstile>g run_converter\n  (map_converter f g f' g' conva) q \\<surd> \\<and>\n                         ((r, conv')\n                          \\<in> results_gpv \\<I>'\n                                 (run_converter\n                                   (map_converter f g f' g' conva)\n                                   q) \\<longrightarrow>\n                          r \\<in> responses_\\<I> \\<I> q \\<and>\n                          ((\\<exists>conv.\n                               conv' = map_converter f g f' g' conv \\<and>\n                               map_\\<I> (inv f) (inv g) \\<I>,\n                               map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                               conv \\<surd>) \\<or>\n                           \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))", "have \"?results_gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<longrightarrow>\n    r \\<in> responses_\\<I> \\<I> q \\<and>\n    ((\\<exists>conv.\n         conv' = map_converter f g f' g' conv \\<and>\n         map_\\<I> (inv f) (inv g) \\<I>,\n         map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>) \\<or>\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)", "proof(intro strip conjI disjI1)"], ["proof (state)\ngoal (2 subgoals):\n 1. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    r \\<in> responses_\\<I> \\<I> q\n 2. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "assume \"(r, conv') \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) q)\""], ["proof (state)\nthis:\n  (r, conv')\n  \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) q)\n\ngoal (2 subgoals):\n 1. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    r \\<in> responses_\\<I> \\<I> q\n 2. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "then"], ["proof (chain)\npicking this:\n  (r, conv')\n  \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) q)", "obtain r' conv''\n      where results: \"(r', conv'') \\<in> results_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f q))\"\n        and r: \"r = g r'\"\n        and conv': \"conv' = map_converter f g f' g' conv''\""], ["proof (prove)\nusing this:\n  (r, conv')\n  \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) q)\n\ngoal (1 subgoal):\n 1. (\\<And>r' conv''.\n        \\<lbrakk>(r', conv'')\n                 \\<in> results_gpv (map_\\<I> f' g' \\<I>')\n                        (run_converter conv (f q));\n         r = g r'; conv' = map_converter f g f' g' conv''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (r', conv'')\n  \\<in> results_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f q))\n  r = g r'\n  conv' = map_converter f g f' g' conv''\n\ngoal (2 subgoals):\n 1. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    r \\<in> responses_\\<I> \\<I> q\n 2. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "from WT_converterD_results[OF WT_converter(1), of \"f q\"] WT_converter(2) results"], ["proof (chain)\npicking this:\n  \\<lbrakk>f q \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>);\n   (?r, ?conv')\n   \\<in> results_gpv (map_\\<I> f' g' \\<I>')\n          (run_converter conv (f q))\\<rbrakk>\n  \\<Longrightarrow> ?r \\<in> responses_\\<I> (map_\\<I> (inv f) (inv g) \\<I>)\n                              (f q) \\<and>\n                    map_\\<I> (inv f) (inv g) \\<I>,\n                    map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C ?conv' \\<surd>\n  q \\<in> outs_\\<I> \\<I>\n  (r', conv'')\n  \\<in> results_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f q))", "have r': \"r' \\<in> inv_into UNIV g ` responses_\\<I> \\<I> q\"\n      and WT': \"map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv'' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>f q \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>);\n   (?r, ?conv')\n   \\<in> results_gpv (map_\\<I> f' g' \\<I>')\n          (run_converter conv (f q))\\<rbrakk>\n  \\<Longrightarrow> ?r \\<in> responses_\\<I> (map_\\<I> (inv f) (inv g) \\<I>)\n                              (f q) \\<and>\n                    map_\\<I> (inv f) (inv g) \\<I>,\n                    map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C ?conv' \\<surd>\n  q \\<in> outs_\\<I> \\<I>\n  (r', conv'')\n  \\<in> results_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f q))\n\ngoal (1 subgoal):\n 1. r' \\<in> inv g ` responses_\\<I> \\<I> q &&&\n    map_\\<I> (inv f) (inv g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n    conv'' \\<surd>", "by(auto simp add: inv_into_f_f[OF f])"], ["proof (state)\nthis:\n  r' \\<in> inv g ` responses_\\<I> \\<I> q\n  map_\\<I> (inv f) (inv g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n  conv'' \\<surd>\n\ngoal (2 subgoals):\n 1. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    r \\<in> responses_\\<I> \\<I> q\n 2. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "from r' r"], ["proof (chain)\npicking this:\n  r' \\<in> inv g ` responses_\\<I> \\<I> q\n  r = g r'", "show \"r \\<in> responses_\\<I> \\<I> q\""], ["proof (prove)\nusing this:\n  r' \\<in> inv g ` responses_\\<I> \\<I> q\n  r = g r'\n\ngoal (1 subgoal):\n 1. r \\<in> responses_\\<I> \\<I> q", "by(auto simp add: surj_f_inv_f[OF g])"], ["proof (state)\nthis:\n  r \\<in> responses_\\<I> \\<I> q\n\ngoal (1 subgoal):\n 1. (r, conv')\n    \\<in> results_gpv \\<I>'\n           (run_converter (map_converter f g f' g' conv)\n             q) \\<Longrightarrow>\n    \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "show \"\\<exists>conv. conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "using conv' WT'"], ["proof (prove)\nusing this:\n  conv' = map_converter f g f' g' conv''\n  map_\\<I> (inv f) (inv g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n  conv'' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>conv.\n     conv' = map_converter f g f' g' conv \\<and>\n     map_\\<I> (inv f) (inv g) \\<I>,\n     map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (r, conv')\n  \\<in> results_gpv \\<I>'\n         (run_converter (map_converter f g f' g' conv) q) \\<longrightarrow>\n  r \\<in> responses_\\<I> \\<I> q \\<and>\n  ((\\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>) \\<or>\n   \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<And>q r conv' conva.\n       \\<lbrakk>map_\\<I> (inv f) (inv g) \\<I>,\n                map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>'\n                         \\<turnstile>g run_converter\n  (map_converter f g f' g' conva) q \\<surd> \\<and>\n                         ((r, conv')\n                          \\<in> results_gpv \\<I>'\n                                 (run_converter\n                                   (map_converter f g f' g' conva)\n                                   q) \\<longrightarrow>\n                          r \\<in> responses_\\<I> \\<I> q \\<and>\n                          ((\\<exists>conv.\n                               conv' = map_converter f g f' g' conv \\<and>\n                               map_\\<I> (inv f) (inv g) \\<I>,\n                               map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                               conv \\<surd>) \\<or>\n                           \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<I>' \\<turnstile>g run_converter (map_converter f g f' g' conv) q \\<surd>\n  (r, conv')\n  \\<in> results_gpv \\<I>'\n         (run_converter (map_converter f g f' g' conv) q) \\<longrightarrow>\n  r \\<in> responses_\\<I> \\<I> q \\<and>\n  ((\\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>) \\<or>\n   \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g run_converter (map_converter f g f' g' conv) q \\<surd>\n  (r, conv')\n  \\<in> results_gpv \\<I>'\n         (run_converter (map_converter f g f' g' conv) q) \\<longrightarrow>\n  r \\<in> responses_\\<I> \\<I> q \\<and>\n  ((\\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       map_\\<I> (inv f) (inv g) \\<I>,\n       map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>) \\<or>\n   \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<I>'\n    \\<turnstile>g run_converter (map_converter f g f' g' conv)\n                   q \\<surd> \\<and>\n    ((r, conv')\n     \\<in> results_gpv \\<I>'\n            (run_converter (map_converter f g f' g' conv)\n              q) \\<longrightarrow>\n     r \\<in> responses_\\<I> \\<I> q \\<and>\n     ((\\<exists>conv.\n          conv' = map_converter f g f' g' conv \\<and>\n          map_\\<I> (inv f) (inv g) \\<I>,\n          map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>) \\<or>\n      \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))", ".."], ["proof (state)\nthis:\n  \\<I>'\n  \\<turnstile>g run_converter (map_converter f g f' g' conv)\n                 q \\<surd> \\<and>\n  ((r, conv')\n   \\<in> results_gpv \\<I>'\n          (run_converter (map_converter f g f' g' conv) q) \\<longrightarrow>\n   r \\<in> responses_\\<I> \\<I> q \\<and>\n   ((\\<exists>conv.\n        conv' = map_converter f g f' g' conv \\<and>\n        map_\\<I> (inv f) (inv g) \\<I>,\n        map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>) \\<or>\n    \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Losslessness\\<close>"], ["", "coinductive plossless_converter :: \"('a, 'b) \\<I> \\<Rightarrow> ('out, 'in) \\<I> \\<Rightarrow> ('a, 'b, 'out, 'in) converter \\<Rightarrow> bool\"\n  for \\<I> \\<I>' where\n    plossless_converterI: \"plossless_converter \\<I> \\<I>' conv\" if\n    \"\\<And>a. a \\<in> outs_\\<I> \\<I> \\<Longrightarrow> plossless_gpv \\<I>' (run_converter conv a)\"\n    \"\\<And>a b conv'. \\<lbrakk> a \\<in> outs_\\<I> \\<I>; (b, conv') \\<in> results_gpv \\<I>' (run_converter conv a) \\<rbrakk> \\<Longrightarrow> plossless_converter \\<I> \\<I>' conv'\""], ["", "lemma plossless_converter_coinduct[consumes 1, case_names plossless_converter, case_conclusion plossless_converter plossless step, coinduct pred: plossless_converter]:\n  assumes \"X conv\"\n    and step: \"\\<And>conv a. \\<lbrakk> X conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> plossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). X conv' \\<or> plossless_converter \\<I> \\<I>' conv')\"\n  shows \"plossless_converter \\<I> \\<I>' conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' conv", "using assms(1)"], ["proof (prove)\nusing this:\n  X conv\n\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' conv", "by(rule plossless_converter.coinduct)(auto dest: step)"], ["", "lemma plossless_converterD:\n  \"\\<lbrakk> plossless_converter \\<I> \\<I>' conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \n  \\<Longrightarrow> plossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). plossless_converter \\<I> \\<I>' conv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n     a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I>' (run_converter conv a) \\<and>\n                      (\\<forall>(b, conv')\n                                \\<in>results_gpv \\<I>'\n(run_converter conv a).\n                          plossless_converter \\<I> \\<I>' conv')", "by(auto elim: plossless_converter.cases)"], ["", "lemma plossless_converter_bot1 [simp]: \"plossless_converter bot \\<I> conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<bottom> \\<I> conv", "by(rule plossless_converterI) auto"], ["", "lemma plossless_converter_mono:\n  assumes *: \"plossless_converter \\<I>1 \\<I>2 conv\"\n    and le: \"outs_\\<I> \\<I>1' \\<subseteq> outs_\\<I> \\<I>1\" \"\\<I>2 \\<le> \\<I>2'\"\n    and WT: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"plossless_converter \\<I>1' \\<I>2' conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I>1' \\<I>2' conv", "using * WT"], ["proof (prove)\nusing this:\n  plossless_converter \\<I>1 \\<I>2 conv\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal (1 subgoal):\n 1. plossless_converter \\<I>1' \\<I>2' conv", "apply(coinduction arbitrary: conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>plossless_converter \\<I>1 \\<I>2 conva;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 plossless_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             plossless_converter \\<I>1' \\<I>2' conv')", "apply(drule plossless_converterD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> ?a5 a conva \\<in> outs_\\<I> \\<I>1\n 2. \\<And>a conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1';\n        plossless_gpv \\<I>2 (run_converter conva (?a5 a conva)) \\<and>\n        (\\<forall>(b, conv')\n                  \\<in>results_gpv \\<I>2\n                        (run_converter conva (?a5 a conva)).\n            plossless_converter \\<I>1 \\<I>2 conv')\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 plossless_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             plossless_converter \\<I>1' \\<I>2' conv')", "apply(erule le(1)[THEN subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1';\n        plossless_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            plossless_converter \\<I>1 \\<I>2 conv')\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 plossless_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             plossless_converter \\<I>1' \\<I>2' conv')", "apply(drule WT_converterD')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        plossless_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            plossless_converter \\<I>1 \\<I>2 conv')\\<rbrakk>\n       \\<Longrightarrow> ?q9 a conva \\<in> outs_\\<I> \\<I>1\n 2. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        plossless_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            plossless_converter \\<I>1 \\<I>2 conv');\n        \\<I>2 \\<turnstile>g run_converter conva (?q9 a conva) \\<surd> \\<and>\n        (\\<forall>(r, conv')\n                  \\<in>results_gpv \\<I>2\n                        (run_converter conva (?q9 a conva)).\n            r \\<in> responses_\\<I> \\<I>1 (?q9 a conva) \\<and> \\<I>1,\n            \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>)\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 plossless_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             plossless_converter \\<I>1' \\<I>2' conv')", "apply(erule le(1)[THEN subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        plossless_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            plossless_converter \\<I>1 \\<I>2 conv');\n        \\<I>2 \\<turnstile>g run_converter conva a \\<surd> \\<and>\n        (\\<forall>(r, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            r \\<in> responses_\\<I> \\<I>1 a \\<and> \\<I>1,\n            \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>)\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 plossless_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             plossless_converter \\<I>1' \\<I>2' conv')", "using le(2)[THEN responses_\\<I>_mono]"], ["proof (prove)\nusing this:\n  ?x \\<in> outs_\\<I> \\<I>2 \\<Longrightarrow>\n  responses_\\<I> \\<I>2' ?x \\<subseteq> responses_\\<I> \\<I>2 ?x\n\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        plossless_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            plossless_converter \\<I>1 \\<I>2 conv');\n        \\<I>2 \\<turnstile>g run_converter conva a \\<surd> \\<and>\n        (\\<forall>(r, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            r \\<in> responses_\\<I> \\<I>1 a \\<and> \\<I>1,\n            \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>)\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 plossless_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             plossless_converter \\<I>1' \\<I>2' conv')", "by(auto intro: plossless_gpv_mono[OF _ le(2)] results_gpv_mono[OF le(2), THEN subsetD] dest: bspec)"], ["", "lemma raw_converter_invariant_run_plossless_converter: \"raw_converter_invariant \\<I> \\<I>' run_converter (\\<lambda>conv. plossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (\\<lambda>conv.\n         plossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\n         \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)", "by(unfold_locales)(auto dest: WT_converterD plossless_converterD)"], ["", "interpretation run_plossless_converter: raw_converter_invariant\n  \\<I> \\<I>' run_converter \"\\<lambda>conv. plossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" for \\<I> \\<I>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (\\<lambda>conv.\n         plossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\n         \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)", "by(rule raw_converter_invariant_run_plossless_converter)"], ["", "named_theorems plossless_intro \"Introduction rules for probabilistic losslessness\""], ["", "subsection \\<open>Operations\\<close>"], ["", "context\n  fixes callee :: \"'s \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 's, 'out, 'in) gpv\"\nbegin"], ["", "primcorec converter_of_callee :: \"'s \\<Rightarrow> ('a, 'b, 'out, 'in) converter\" where\n  \"run_converter (converter_of_callee s) = (\\<lambda>a. map_gpv (map_prod id converter_of_callee) id (callee s a))\""], ["", "end"], ["", "lemma converter_of_callee_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((S ===> A ===> rel_gpv'' (rel_prod B S) C R) ===> S ===> rel_converter A B C R)\n  converter_of_callee converter_of_callee\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_gpv'' (rel_prod B S) C R) ===>\n     S ===> rel_converter A B C R)\n     converter_of_callee converter_of_callee", "unfolding converter_of_callee_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_gpv'' (rel_prod B S) C R) ===>\n     S ===> rel_converter A B C R)\n     (\\<lambda>callee.\n         corec_converter\n          (\\<lambda>s a. map_gpv (map_prod id Inr) id (callee s a)))\n     (\\<lambda>callee.\n         corec_converter\n          (\\<lambda>s a. map_gpv (map_prod id Inr) id (callee s a)))", "supply map_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_gpv'' (rel_prod B S) C R) ===>\n     S ===> rel_converter A B C R)\n     (\\<lambda>callee.\n         corec_converter\n          (\\<lambda>s a. map_gpv (map_prod id Inr) id (callee s a)))\n     (\\<lambda>callee.\n         corec_converter\n          (\\<lambda>s a. map_gpv (map_prod id Inr) id (callee s a)))", "by transfer_prover"], ["", "lemma map_converter_of_callee:\n  \"map_converter f g h k (converter_of_callee callee s) =\n   converter_of_callee (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter f g h k (converter_of_callee callee s) =\n    converter_of_callee\n     (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee) s", "proof(coinduction arbitrary: s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>s.\n                   converter__ =\n                   map_converter f g h k\n                    (converter_of_callee callee s) \\<and>\n                   converter'__ =\n                   converter_of_callee\n                    (map_fun id (map_fun f (map_gpv' (map_prod g id) h k))\n                      callee)\n                    s))\n          (=))\n        (run_converter\n          (map_converter f g h k (converter_of_callee callee s)))\n        (run_converter\n          (converter_of_callee\n            (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee)\n            s))", "case Eq_converter"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>s.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>s.\n                   converter__ =\n                   map_converter f g h k\n                    (converter_of_callee callee s) \\<and>\n                   converter'__ =\n                   converter_of_callee\n                    (map_fun id (map_fun f (map_gpv' (map_prod g id) h k))\n                      callee)\n                    s))\n          (=))\n        (run_converter\n          (map_converter f g h k (converter_of_callee callee s)))\n        (run_converter\n          (converter_of_callee\n            (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee)\n            s))", "have *: \"map_gpv' (map_prod g id) h k gpv = map_gpv (map_prod g id) id (map_gpv' id h k gpv)\" for gpv"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' (map_prod g id) h k gpv =\n    map_gpv (map_prod g id) id (map_gpv' id h k gpv)", "by(simp add: map_gpv_conv_map_gpv' gpv.compositionality)"], ["proof (state)\nthis:\n  map_gpv' (map_prod g id) h k ?gpv1 =\n  map_gpv (map_prod g id) id (map_gpv' id h k ?gpv1)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>s.\n                   converter__ =\n                   map_converter f g h k\n                    (converter_of_callee callee s) \\<and>\n                   converter'__ =\n                   converter_of_callee\n                    (map_fun id (map_fun f (map_gpv' (map_prod g id) h k))\n                      callee)\n                    s))\n          (=))\n        (run_converter\n          (map_converter f g h k (converter_of_callee callee s)))\n        (run_converter\n          (converter_of_callee\n            (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee)\n            s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=)\n     (rel_gpv\n       (rel_prod (=)\n         (\\<lambda>converter__ converter'__.\n             \\<exists>s.\n                converter__ =\n                map_converter f g h k (converter_of_callee callee s) \\<and>\n                converter'__ =\n                converter_of_callee\n                 (map_fun id (map_fun f (map_gpv' (map_prod g id) h k))\n                   callee)\n                 s))\n       (=))\n     (run_converter (map_converter f g h k (converter_of_callee callee s)))\n     (run_converter\n       (converter_of_callee\n         (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee) s))", "by(auto simp add: rel_fun_def map_gpv'_map_gpv_swap gpv.rel_map * intro!: gpv.rel_refl_strong)"], ["proof (state)\nthis:\n  rel_fun (=)\n   (rel_gpv\n     (rel_prod (=)\n       (\\<lambda>converter__ converter'__.\n           \\<exists>s.\n              converter__ =\n              map_converter f g h k (converter_of_callee callee s) \\<and>\n              converter'__ =\n              converter_of_callee\n               (map_fun id (map_fun f (map_gpv' (map_prod g id) h k))\n                 callee)\n               s))\n     (=))\n   (run_converter (map_converter f g h k (converter_of_callee callee s)))\n   (run_converter\n     (converter_of_callee\n       (map_fun id (map_fun f (map_gpv' (map_prod g id) h k)) callee) s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WT_converter_of_callee:\n  assumes WT: \"\\<And>s q. q \\<in> outs_\\<I> \\<I> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s q \\<surd>\"\n    and res: \"\\<And>s q r s'. \\<lbrakk> q \\<in> outs_\\<I> \\<I>; (r, s') \\<in> results_gpv \\<I>' (callee s q) \\<rbrakk> \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_callee callee s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_callee callee s \\<surd>", "by(coinduction arbitrary: s)(auto simp add: WT res)"], ["", "text \\<open>\n  We can define two versions of parallel composition. One that attaches to the same interface \n  and one that attach to different interfaces. We choose the one variant where both attach to the same interface\n  because (1) this is more general and (2) we do not have to assume that the resource respects the parallel composition. \n\\<close>"], ["", "primcorec parallel_converter\n  :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> ('c, 'd, 'out, 'in) converter \\<Rightarrow> ('a + 'c, 'b + 'd, 'out, 'in) converter\"\n  where\n    \"run_converter (parallel_converter conv1 conv2) = (\\<lambda>ac. case ac of\n     Inl a \\<Rightarrow> map_gpv (map_prod Inl (\\<lambda>conv1'. parallel_converter conv1' conv2)) id (run_converter conv1 a)\n   | Inr b \\<Rightarrow> map_gpv (map_prod Inr (\\<lambda>conv2'. parallel_converter conv1 conv2')) id (run_converter conv2 b))\""], ["", "lemma parallel_callee_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter A' B' C R ===> rel_converter (rel_sum A A') (rel_sum B B') C R)\n   parallel_converter parallel_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A' B' C R ===>\n     rel_converter (rel_sum A A') (rel_sum B B') C R)\n     parallel_converter parallel_converter", "unfolding parallel_converter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A' B' C R ===>\n     rel_converter (rel_sum A A') (rel_sum B B') C R)\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (run_converter conv1 a)\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (run_converter conv2 b))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (run_converter conv1 a)\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (run_converter conv2 b))\n          (uu, uua))", "supply map_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A' B' C R ===>\n     rel_converter (rel_sum A A') (rel_sum B B') C R)\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (run_converter conv1 a)\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (run_converter conv2 b))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (run_converter conv1 a)\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (run_converter conv2 b))\n          (uu, uua))", "by transfer_prover"], ["", "lemma parallel_converter_assoc:\n  \"parallel_converter (parallel_converter conv1 conv2) conv3 =\n   map_converter rsuml lsumr id id (parallel_converter conv1 (parallel_converter conv2 conv3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_converter (parallel_converter conv1 conv2) conv3 =\n    map_converter rsuml lsumr id id\n     (parallel_converter conv1 (parallel_converter conv2 conv3))", "by(coinduction arbitrary: conv1 conv2 conv3)\n    (auto 4 5 intro!: rel_funI gpv.rel_refl_strong split: sum.split simp add: gpv.rel_map map_gpv'_id map_gpv_conv_map_gpv'[symmetric])"], ["", "lemma plossless_parallel_converter [plossless_intro]:\n  \"\\<lbrakk> plossless_converter \\<I>1 \\<I> conv1; plossless_converter \\<I>2 \\<I> conv2; \\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<surd>; \\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<surd> \\<rbrakk>\n  \\<Longrightarrow> plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<I> (parallel_converter conv1 conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>plossless_converter \\<I>1 \\<I> conv1;\n     plossless_converter \\<I>2 \\<I> conv2;\n     \\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<surd>\\<rbrakk>\n    \\<Longrightarrow> plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n                       \\<I> (parallel_converter conv1 conv2)", "by(coinduction arbitrary: conv1 conv2)\n    (clarsimp; erule PlusE; drule (1) plossless_converterD; drule (1) WT_converterD'; fastforce)"], ["", "primcorec id_converter :: \"('a, 'b, 'a, 'b) converter\" where\n  \"run_converter id_converter = (\\<lambda>a.\n   map_gpv (map_prod id (\\<lambda>_. id_converter)) id (Pause a (\\<lambda>b. Done (b, ()))))\""], ["", "lemma id_converter_parametric [transfer_rule]: \"rel_converter A B A B id_converter id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B A B id_converter id_converter", "unfolding id_converter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B A B\n     (corec_converter\n       (\\<lambda>x a.\n           map_gpv (map_prod id (\\<lambda>uu. Inr ())) id\n            (Generative_Probabilistic_Value.Pause a\n              (\\<lambda>b. Generative_Probabilistic_Value.Done (b, ()))))\n       ())\n     (corec_converter\n       (\\<lambda>x a.\n           map_gpv (map_prod id (\\<lambda>uu. Inr ())) id\n            (Generative_Probabilistic_Value.Pause a\n              (\\<lambda>b. Generative_Probabilistic_Value.Done (b, ()))))\n       ())", "supply map_gpv_parametric'[transfer_rule] Done_parametric'[transfer_rule] Pause_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B A B\n     (corec_converter\n       (\\<lambda>x a.\n           map_gpv (map_prod id (\\<lambda>uu. Inr ())) id\n            (Generative_Probabilistic_Value.Pause a\n              (\\<lambda>b. Generative_Probabilistic_Value.Done (b, ()))))\n       ())\n     (corec_converter\n       (\\<lambda>x a.\n           map_gpv (map_prod id (\\<lambda>uu. Inr ())) id\n            (Generative_Probabilistic_Value.Pause a\n              (\\<lambda>b. Generative_Probabilistic_Value.Done (b, ()))))\n       ())", "by transfer_prover"], ["", "lemma converter_of_callee_id_oracle [simp]:\n  \"converter_of_callee id_oracle s = id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_callee id_oracle s = id_converter", "by(coinduction) (auto simp add: id_oracle_def)"], ["", "lemma conv_callee_plus_id_left: \"converter_of_callee (plus_intercept id_oracle callee) s =\n  parallel_converter id_converter (converter_of_callee callee s) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_callee (plus_intercept id_oracle callee) s =\n    parallel_converter id_converter (converter_of_callee callee s)", "by (coinduction arbitrary: callee s)\n    (clarsimp split!: sum.split intro!: rel_funI\n      , force simp add: gpv.rel_map id_oracle_def, force simp add: gpv.rel_map intro!: gpv.rel_refl)"], ["", "lemma conv_callee_plus_id_right: \"converter_of_callee (plus_intercept callee id_oracle) s =\n  parallel_converter (converter_of_callee callee s) id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_callee (plus_intercept callee id_oracle) s =\n    parallel_converter (converter_of_callee callee s) id_converter", "by (coinduction arbitrary: callee s)\n    (clarsimp split!: sum.split intro!: rel_funI\n      , (force intro: gpv.rel_refl | simp add: gpv.rel_map id_oracle_def)+)"], ["", "lemma plossless_id_converter [simp, plossless_intro]: \"plossless_converter \\<I> \\<I> id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I> id_converter", "by(coinduction) auto"], ["", "lemma WT_converter_id [simp, intro, WT_intro]: \"\\<I>, \\<I> \\<turnstile>\\<^sub>C id_converter \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I> \\<turnstile>\\<^sub>C id_converter \\<surd>", "by(coinduction) auto"], ["", "lemma WT_map_converter_idD:\n  \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C map_converter id id f g id_converter \\<surd> \\<Longrightarrow> \\<I> \\<le> map_\\<I> f g \\<I>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n    map_converter id id f g id_converter \\<surd> \\<Longrightarrow>\n    \\<I> \\<le> map_\\<I> f g \\<I>'", "unfolding le_\\<I>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n    map_converter id id f g id_converter \\<surd> \\<Longrightarrow>\n    outs_\\<I> \\<I> \\<subseteq> outs_\\<I> (map_\\<I> f g \\<I>') \\<and>\n    (\\<forall>x\\<in>outs_\\<I> \\<I>.\n        responses_\\<I> (map_\\<I> f g \\<I>') x\n        \\<subseteq> responses_\\<I> \\<I> x)", "by(auto 4 3 dest: WT_converterD)"], ["", "definition fail_converter :: \"('a, 'b, 'out, 'in) converter\" where\n  \"fail_converter = Converter (\\<lambda>_. Fail)\""], ["", "lemma fail_converter_sel [simp]: \"run_converter fail_converter a = Fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter fail_converter a = Fail", "by(simp add: fail_converter_def)"], ["", "lemma fail_converter_parametric [transfer_rule]: \"rel_converter A B C R fail_converter fail_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R fail_converter fail_converter", "unfolding fail_converter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R (Converter (\\<lambda>_. Fail))\n     (Converter (\\<lambda>_. Fail))", "supply Fail_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_converter A B C R (Converter (\\<lambda>_. Fail))\n     (Converter (\\<lambda>_. Fail))", "by transfer_prover"], ["", "lemma plossless_fail_converter [simp]: \"plossless_converter \\<I> \\<I>' fail_converter \\<longleftrightarrow> \\<I> = bot\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' fail_converter = (\\<I> = \\<bottom>)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. plossless_converter \\<I> \\<I>' fail_converter \\<Longrightarrow>\n    \\<I> = \\<bottom>\n 2. \\<I> = \\<bottom> \\<Longrightarrow>\n    plossless_converter \\<I> \\<I>' fail_converter", "show ?rhs if ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> = \\<bottom>", "using that"], ["proof (prove)\nusing this:\n  plossless_converter \\<I> \\<I>' fail_converter\n\ngoal (1 subgoal):\n 1. \\<I> = \\<bottom>", "by(cases)(auto intro!: \\<I>_eqI)"], ["proof (state)\nthis:\n  plossless_converter \\<I> \\<I>' fail_converter \\<Longrightarrow>\n  \\<I> = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<I> = \\<bottom> \\<Longrightarrow>\n    plossless_converter \\<I> \\<I>' fail_converter", "qed simp"], ["", "lemma plossless_fail_converterI [plossless_intro]: \"plossless_converter bot \\<I>' fail_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<bottom> \\<I>' fail_converter", "by simp"], ["", "lemma WT_fail_converter [simp, WT_intro]: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C fail_converter \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C fail_converter \\<surd>", "by(rule WT_converter.intros) simp_all"], ["", "lemma map_converter_id_move_left:\n  \"map_converter f g f' g' id_converter = map_converter (f' \\<circ> f) (g \\<circ> g') id id id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter f g f' g' id_converter =\n    map_converter (f' \\<circ> f) (g \\<circ> g') id id id_converter", "by coinduction(simp add: rel_funI)"], ["", "lemma map_converter_id_move_right:\n  \"map_converter f g f' g' id_converter = map_converter id id (f' \\<circ> f) (g \\<circ> g') id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter f g f' g' id_converter =\n    map_converter id id (f' \\<circ> f) (g \\<circ> g') id_converter", "by coinduction(simp add: rel_funI)"], ["", "text \\<open>\n  And here is the version for parallel composition that assumes disjoint interfaces.\n\\<close>"], ["", "primcorec parallel_converter2\n  :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> ('c, 'd, 'out', 'in') converter \\<Rightarrow> ('a + 'c, 'b + 'd, 'out + 'out', 'in + 'in') converter\"\n  where\n    \"run_converter (parallel_converter2 conv1 conv2) = (\\<lambda>ac. case ac of\n     Inl a \\<Rightarrow> map_gpv (map_prod Inl (\\<lambda>conv1'. parallel_converter2 conv1' conv2)) id (left_gpv (run_converter conv1 a))\n   | Inr b \\<Rightarrow> map_gpv (map_prod Inr (\\<lambda>conv2'. parallel_converter2 conv1 conv2')) id (right_gpv (run_converter conv2 b)))\""], ["", "lemma parallel_converter2_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter A' B' C' R' \n   ===> rel_converter (rel_sum A A') (rel_sum B B') (rel_sum C C') (rel_sum R R'))\n  parallel_converter2 parallel_converter2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A' B' C' R' ===>\n     rel_converter (rel_sum A A') (rel_sum B B') (rel_sum C C')\n      (rel_sum R R'))\n     parallel_converter2 parallel_converter2", "unfolding parallel_converter2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A' B' C' R' ===>\n     rel_converter (rel_sum A A') (rel_sum B B') (rel_sum C C')\n      (rel_sum R R'))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (left_gpv (run_converter conv1 a))\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (right_gpv (run_converter conv2 b)))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (left_gpv (run_converter conv1 a))\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (right_gpv (run_converter conv2 b)))\n          (uu, uua))", "supply left_gpv_parametric'[transfer_rule] right_gpv_parametric'[transfer_rule] map_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A' B' C' R' ===>\n     rel_converter (rel_sum A A') (rel_sum B B') (rel_sum C C')\n      (rel_sum R R'))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (left_gpv (run_converter conv1 a))\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (right_gpv (run_converter conv2 b)))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) ac.\n              case ac of\n              Inl a \\<Rightarrow>\n                map_gpv (map_prod Inl (\\<lambda>uu. Inr (uu, conv2))) id\n                 (left_gpv (run_converter conv1 a))\n              | Inr b \\<Rightarrow>\n                  map_gpv (map_prod Inr (\\<lambda>uu. Inr (conv1, uu))) id\n                   (right_gpv (run_converter conv2 b)))\n          (uu, uua))", "by transfer_prover"], ["", "lemma map_converter_parallel_converter2:\n  \"map_converter (map_sum f f') (map_sum g g') (map_sum h h') (map_sum k k') (parallel_converter2 conv1 conv2) =\n   parallel_converter2 (map_converter f g h k conv1) (map_converter f' g' h' k' conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter (map_sum f f') (map_sum g g') (map_sum h h')\n     (map_sum k k') (parallel_converter2 conv1 conv2) =\n    parallel_converter2 (map_converter f g h k conv1)\n     (map_converter f' g' h' k' conv2)", "using parallel_converter2_parametric[of\n      \"conversep (BNF_Def.Grp UNIV f)\" \"BNF_Def.Grp UNIV g\"  \"BNF_Def.Grp UNIV h\"  \"conversep (BNF_Def.Grp UNIV k)\"\n      \"conversep (BNF_Def.Grp UNIV f')\" \"BNF_Def.Grp UNIV g'\"  \"BNF_Def.Grp UNIV h'\"  \"conversep (BNF_Def.Grp UNIV k')\"]"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV h)\n     (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n   (rel_fun\n     (rel_converter (BNF_Def.Grp UNIV f')\\<inverse>\\<inverse>\n       (BNF_Def.Grp UNIV g') (BNF_Def.Grp UNIV h')\n       (BNF_Def.Grp UNIV k')\\<inverse>\\<inverse>)\n     (rel_converter\n       (rel_sum (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n         (BNF_Def.Grp UNIV f')\\<inverse>\\<inverse>)\n       (rel_sum (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV g'))\n       (rel_sum (BNF_Def.Grp UNIV h) (BNF_Def.Grp UNIV h'))\n       (rel_sum (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n         (BNF_Def.Grp UNIV k')\\<inverse>\\<inverse>)))\n   parallel_converter2 parallel_converter2\n\ngoal (1 subgoal):\n 1. map_converter (map_sum f f') (map_sum g g') (map_sum h h')\n     (map_sum k k') (parallel_converter2 conv1 conv2) =\n    parallel_converter2 (map_converter f g h k conv1)\n     (map_converter f' g' h' k' conv2)", "unfolding sum.rel_conversep sum.rel_Grp"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV h)\n     (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n   (rel_fun\n     (rel_converter (BNF_Def.Grp UNIV f')\\<inverse>\\<inverse>\n       (BNF_Def.Grp UNIV g') (BNF_Def.Grp UNIV h')\n       (BNF_Def.Grp UNIV k')\\<inverse>\\<inverse>)\n     (rel_converter\n       (BNF_Def.Grp\n         {x. Basic_BNFs.setl x \\<subseteq> UNIV \\<and>\n             Basic_BNFs.setr x \\<subseteq> UNIV}\n         (map_sum f f'))\\<inverse>\\<inverse>\n       (BNF_Def.Grp\n         {x. Basic_BNFs.setl x \\<subseteq> UNIV \\<and>\n             Basic_BNFs.setr x \\<subseteq> UNIV}\n         (map_sum g g'))\n       (BNF_Def.Grp\n         {x. Basic_BNFs.setl x \\<subseteq> UNIV \\<and>\n             Basic_BNFs.setr x \\<subseteq> UNIV}\n         (map_sum h h'))\n       (BNF_Def.Grp\n         {x. Basic_BNFs.setl x \\<subseteq> UNIV \\<and>\n             Basic_BNFs.setr x \\<subseteq> UNIV}\n         (map_sum k k'))\\<inverse>\\<inverse>))\n   parallel_converter2 parallel_converter2\n\ngoal (1 subgoal):\n 1. map_converter (map_sum f f') (map_sum g g') (map_sum h h')\n     (map_sum k k') (parallel_converter2 conv1 conv2) =\n    parallel_converter2 (map_converter f g h k conv1)\n     (map_converter f' g' h' k' conv2)", "by(simp add: rel_converter_Grp rel_fun_def Grp_iff)"], ["", "lemma WT_converter_parallel_converter2 [WT_intro]:\n  assumes \"\\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n    and \"\\<I>1',\\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n  shows \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C parallel_converter2 conv1 conv2 \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n    \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n    parallel_converter2 conv1 conv2 \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n    \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n    parallel_converter2 conv1 conv2 \\<surd>", "apply(coinduction arbitrary: conv1 conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q r conv' conv1 conv2.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        q \\<in> outs_\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1')\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                         \\<turnstile>g run_converter\n  (parallel_converter2 conv1 conv2) q \\<surd> \\<and>\n                         ((r, conv')\n                          \\<in> results_gpv\n                                 (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2')\n                                 (run_converter\n                                   (parallel_converter2 conv1 conv2)\n                                   q) \\<longrightarrow>\n                          r \\<in> responses_\\<I>\n                                   (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1')\n                                   q \\<and>\n                          ((\\<exists>conv1 conv2.\n                               conv' =\n                               parallel_converter2 conv1 conv2 \\<and>\n                               \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                               conv1 \\<surd> \\<and> \\<I>1',\n                               \\<I>2' \\<turnstile>\\<^sub>C\n                               conv2 \\<surd>) \\<or>\n                           \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n                           \\<I>2 \\<oplus>\\<^sub>\\<I>\n                           \\<I>2' \\<turnstile>\\<^sub>C\n                           conv' \\<surd>))", "apply(clarsimp split!: sum.split)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>conv1 conv2 x1.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x1 \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                         \\<turnstile>g left_gpv\n  (run_converter conv1 x1) \\<surd>\n 2. \\<And>conv1 conv2 x1 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x1 \\<in> outs_\\<I> \\<I>1;\n        (x, y) \\<in> results_gpv \\<I>2 (run_converter conv1 x1)\\<rbrakk>\n       \\<Longrightarrow> Inl x \\<in> Inl ` responses_\\<I> \\<I>1 x1\n 3. \\<And>conv1 conv2 x1 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x1 \\<in> outs_\\<I> \\<I>1;\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 y conv2 \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2 (run_converter conv1 x1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2a.\n                            parallel_converter2 y conv2 =\n                            parallel_converter2 conv1 conv2a \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2a \\<surd>\n 4. \\<And>conv1 conv2 x2.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                         \\<turnstile>g right_gpv\n  (run_converter conv2 x2) \\<surd>\n 5. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> Inr x \\<in> Inr ` responses_\\<I> \\<I>1' x2\n 6. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 conv1 y \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1a conv2.\n                            parallel_converter2 conv1 y =\n                            parallel_converter2 conv1a conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1a \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1_ \\<surd>;\n     \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2_ \\<surd>;\n     x1_ \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n    \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                      \\<turnstile>g left_gpv\n                                     (run_converter conv1_ x1_) \\<surd>", "by(auto intro: WT_gpv_left_gpv dest: WT_converterD_WT)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>conv1 conv2 x1 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x1 \\<in> outs_\\<I> \\<I>1;\n        (x, y) \\<in> results_gpv \\<I>2 (run_converter conv1 x1)\\<rbrakk>\n       \\<Longrightarrow> Inl x \\<in> Inl ` responses_\\<I> \\<I>1 x1\n 2. \\<And>conv1 conv2 x1 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x1 \\<in> outs_\\<I> \\<I>1;\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 y conv2 \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2 (run_converter conv1 x1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2a.\n                            parallel_converter2 y conv2 =\n                            parallel_converter2 conv1 conv2a \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2a \\<surd>\n 3. \\<And>conv1 conv2 x2.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                         \\<turnstile>g right_gpv\n  (run_converter conv2 x2) \\<surd>\n 4. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> Inr x \\<in> Inr ` responses_\\<I> \\<I>1' x2\n 5. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 conv1 y \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1a conv2.\n                            parallel_converter2 conv1 y =\n                            parallel_converter2 conv1a conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1a \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1_ \\<surd>;\n     \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2_ \\<surd>;\n     x1_ \\<in> outs_\\<I> \\<I>1;\n     (x_, y_) \\<in> results_gpv \\<I>2 (run_converter conv1_ x1_)\\<rbrakk>\n    \\<Longrightarrow> Inl x_ \\<in> Inl ` responses_\\<I> \\<I>1 x1_", "by(auto dest: WT_converterD_results)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>conv1 conv2 x1 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x1 \\<in> outs_\\<I> \\<I>1;\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 y conv2 \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2 (run_converter conv1 x1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2a.\n                            parallel_converter2 y conv2 =\n                            parallel_converter2 conv1 conv2a \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2a \\<surd>\n 2. \\<And>conv1 conv2 x2.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                         \\<turnstile>g right_gpv\n  (run_converter conv2 x2) \\<surd>\n 3. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> Inr x \\<in> Inr ` responses_\\<I> \\<I>1' x2\n 4. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 conv1 y \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1a conv2.\n                            parallel_converter2 conv1 y =\n                            parallel_converter2 conv1a conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1a \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1_ \\<surd>;\n     \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2_ \\<surd>;\n     x1_ \\<in> outs_\\<I> \\<I>1;\n     \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n     \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n     parallel_converter2 y_ conv2_ \\<surd>;\n     (x_, y_) \\<in> results_gpv \\<I>2 (run_converter conv1_ x1_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>conv1 conv2.\n                         parallel_converter2 y_ conv2_ =\n                         parallel_converter2 conv1 conv2 \\<and>\n                         \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                         conv1 \\<surd> \\<and> \\<I>1',\n                         \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "by(auto dest: WT_converterD_results)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conv1 conv2 x2.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                         \\<turnstile>g right_gpv\n  (run_converter conv2 x2) \\<surd>\n 2. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> Inr x \\<in> Inr ` responses_\\<I> \\<I>1' x2\n 3. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 conv1 y \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1a conv2.\n                            parallel_converter2 conv1 y =\n                            parallel_converter2 conv1a conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1a \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1_ \\<surd>;\n     \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2_ \\<surd>;\n     x2_ \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n    \\<Longrightarrow> \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2'\n                      \\<turnstile>g right_gpv\n                                     (run_converter conv2_ x2_) \\<surd>", "by(auto intro: WT_gpv_right_gpv dest: WT_converterD_WT)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> Inr x \\<in> Inr ` responses_\\<I> \\<I>1' x2\n 2. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 conv1 y \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1a conv2.\n                            parallel_converter2 conv1 y =\n                            parallel_converter2 conv1a conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1a \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1_ \\<surd>;\n     \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2_ \\<surd>;\n     x2_ \\<in> outs_\\<I> \\<I>1';\n     (x_, y_) \\<in> results_gpv \\<I>2' (run_converter conv2_ x2_)\\<rbrakk>\n    \\<Longrightarrow> Inr x_ \\<in> Inr ` responses_\\<I> \\<I>1' x2_", "by(auto dest: WT_converterD_results)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 x2 x y.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        x2 \\<in> outs_\\<I> \\<I>1';\n        \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n        \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n        parallel_converter2 conv1 y \\<surd>;\n        (x, y) \\<in> results_gpv \\<I>2' (run_converter conv2 x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1a conv2.\n                            parallel_converter2 conv1 y =\n                            parallel_converter2 conv1a conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1a \\<surd> \\<and> \\<I>1',\n                            \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1_ \\<surd>;\n     \\<I>1', \\<I>2' \\<turnstile>\\<^sub>C conv2_ \\<surd>;\n     x2_ \\<in> outs_\\<I> \\<I>1';\n     \\<not> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>1',\n     \\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n     parallel_converter2 conv1_ y_ \\<surd>;\n     (x_, y_) \\<in> results_gpv \\<I>2' (run_converter conv2_ x2_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>conv1 conv2.\n                         parallel_converter2 conv1_ y_ =\n                         parallel_converter2 conv1 conv2 \\<and>\n                         \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                         conv1 \\<surd> \\<and> \\<I>1',\n                         \\<I>2' \\<turnstile>\\<^sub>C conv2 \\<surd>", "by(auto 4 3 dest: WT_converterD_results)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma plossless_parallel_converter2 [plossless_intro]:\n  assumes \"plossless_converter \\<I>1 \\<I>1' conv1\"\n    and \"plossless_converter \\<I>2 \\<I>2' conv2\"\n  shows \"plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (parallel_converter2 conv1 conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (parallel_converter2 conv1 conv2)", "using assms"], ["proof (prove)\nusing this:\n  plossless_converter \\<I>1 \\<I>1' conv1\n  plossless_converter \\<I>2 \\<I>2' conv2\n\ngoal (1 subgoal):\n 1. plossless_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (parallel_converter2 conv1 conv2)", "by(coinduction arbitrary: conv1 conv2)\n    ((rule exI conjI refl)+ | auto dest: plossless_converterD)+"], ["", "lemma parallel_converter2_map1_out:\n  \"parallel_converter2 (map_converter f g h k conv1) conv2 =\n   map_converter (map_sum f id) (map_sum g id) (map_sum h id) (map_sum k id) (parallel_converter2 conv1 conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_converter2 (map_converter f g h k conv1) conv2 =\n    map_converter (map_sum f id) (map_sum g id) (map_sum h id)\n     (map_sum k id) (parallel_converter2 conv1 conv2)", "by(simp add: map_converter_parallel_converter2)"], ["", "lemma parallel_converter2_map2_out:\n  \"parallel_converter2 conv1 (map_converter f g h k conv2) =\n   map_converter (map_sum id f) (map_sum id g) (map_sum id h) (map_sum id k) (parallel_converter2 conv1 conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_converter2 conv1 (map_converter f g h k conv2) =\n    map_converter (map_sum id f) (map_sum id g) (map_sum id h)\n     (map_sum id k) (parallel_converter2 conv1 conv2)", "by(simp add: map_converter_parallel_converter2)"], ["", "primcorec left_interface :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> ('a, 'b, 'out + 'out', 'in + 'in') converter\" where\n  \"run_converter (left_interface conv) = (\\<lambda>a. map_gpv (map_prod id left_interface) id (left_gpv (run_converter conv a)))\""], ["", "lemma left_interface_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter A B (rel_sum C C') (rel_sum R R')) left_interface left_interface\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A B (rel_sum C C') (rel_sum R R'))\n     left_interface left_interface", "unfolding left_interface_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A B (rel_sum C C') (rel_sum R R'))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (left_gpv (run_converter conv a))))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (left_gpv (run_converter conv a))))", "supply left_gpv_parametric'[transfer_rule] map_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter A B (rel_sum C C') (rel_sum R R'))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (left_gpv (run_converter conv a))))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (left_gpv (run_converter conv a))))", "by transfer_prover"], ["", "primcorec right_interface :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> ('a, 'b, 'out' + 'out, 'in' + 'in) converter\" where\n  \"run_converter (right_interface conv) = (\\<lambda>a. map_gpv (map_prod id right_interface) id (right_gpv (run_converter conv a)))\""], ["", "lemma right_interface_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C' R' ===> rel_converter A B (rel_sum C C') (rel_sum R R')) right_interface right_interface\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C' R' ===>\n     rel_converter A B (rel_sum C C') (rel_sum R R'))\n     right_interface right_interface", "unfolding right_interface_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C' R' ===>\n     rel_converter A B (rel_sum C C') (rel_sum R R'))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (right_gpv (run_converter conv a))))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (right_gpv (run_converter conv a))))", "supply right_gpv_parametric'[transfer_rule] map_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C' R' ===>\n     rel_converter A B (rel_sum C C') (rel_sum R R'))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (right_gpv (run_converter conv a))))\n     (corec_converter\n       (\\<lambda>conv a.\n           map_gpv (map_prod id Inr) id (right_gpv (run_converter conv a))))", "by transfer_prover"], ["", "lemma parallel_converter2_alt_def:\n  \"parallel_converter2 conv1 conv2 = parallel_converter (left_interface conv1) (right_interface conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_converter2 conv1 conv2 =\n    parallel_converter (left_interface conv1) (right_interface conv2)", "by(coinduction arbitrary: conv1 conv2 rule: converter.coinduct_strong)\n    (auto 4 5 intro!: rel_funI gpv.rel_refl_strong split: sum.split simp add: gpv.rel_map)"], ["", "lemma conv_callee_parallel_id_left: \"converter_of_callee (parallel_intercept id_oracle callee) (s, s') =\n  parallel_converter2 (id_converter) (converter_of_callee callee s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_callee (parallel_intercept id_oracle callee) (s, s') =\n    parallel_converter2 id_converter (converter_of_callee callee s')", "apply (coinduction arbitrary: callee s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee s'.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>callee s'.\n                   converter__ =\n                   converter_of_callee (parallel_intercept id_oracle callee)\n                    (s, s') \\<and>\n                   converter'__ =\n                   parallel_converter2 id_converter\n                    (converter_of_callee callee s')))\n          (=))\n        (run_converter\n          (converter_of_callee (parallel_intercept id_oracle callee)\n            (s, s')))\n        (run_converter\n          (parallel_converter2 id_converter\n            (converter_of_callee callee s')))", "apply (rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee s' x y.\n       x = y \\<Longrightarrow>\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee s'.\n                 converter__ =\n                 converter_of_callee (parallel_intercept id_oracle callee)\n                  (s, s') \\<and>\n                 converter'__ =\n                 parallel_converter2 id_converter\n                  (converter_of_callee callee s')))\n        (=)\n        (run_converter\n          (converter_of_callee (parallel_intercept id_oracle callee)\n            (s, s'))\n          x)\n        (run_converter\n          (parallel_converter2 id_converter (converter_of_callee callee s'))\n          y)", "apply (clarsimp simp add: gpv.rel_map left_gpv_map[of _ _ _ \"id\"] \n      right_gpv_map[of _ _ _ \"id\"] split!: sum.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee s' x1.\n       rel_gpv\n        (\\<lambda>x.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee s'.\n                    converter__ =\n                    converter_of_callee\n                     (parallel_intercept id_oracle callee) (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 id_converter\n                     (converter_of_callee callee s'))\n             (map_prod id\n               (converter_of_callee (parallel_intercept id_oracle callee))\n               (map_prod Inl (\\<lambda>s1'. (s1', s')) x)))\n        (\\<lambda>x. (=) (map_sum id id x)) (left_gpv (id_oracle s x1))\n        (Generative_Probabilistic_Value.Pause (Inl x1)\n          (map_gpv\n            (map_prod Inl\n              (\\<lambda>conv1'.\n                  parallel_converter2 conv1'\n                   (converter_of_callee callee s')))\n            id \\<circ>\n           case_sum\n            (\\<lambda>input'.\n                Generative_Probabilistic_Value.Done (input', id_converter))\n            (\\<lambda>b. Fail)))\n 2. \\<And>callee s' x2.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee s'.\n                    converter__ =\n                    converter_of_callee\n                     (parallel_intercept id_oracle callee) (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 id_converter\n                     (converter_of_callee callee s'))\n             (map_prod id\n               (converter_of_callee (parallel_intercept id_oracle callee))\n               (map_prod Inr (Pair s) x))\n             (map_prod Inr (parallel_converter2 id_converter)\n               (map_prod id (converter_of_callee callee) y)))\n        (\\<lambda>x y. map_sum id id x = map_sum id id y)\n        (right_gpv (callee s' x2)) (right_gpv (callee s' x2))", "apply (force simp add: id_oracle_def split!: sum.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee s' x2.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee s'.\n                    converter__ =\n                    converter_of_callee\n                     (parallel_intercept id_oracle callee) (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 id_converter\n                     (converter_of_callee callee s'))\n             (map_prod id\n               (converter_of_callee (parallel_intercept id_oracle callee))\n               (map_prod Inr (Pair s) x))\n             (map_prod Inr (parallel_converter2 id_converter)\n               (map_prod id (converter_of_callee callee) y)))\n        (\\<lambda>x y. map_sum id id x = map_sum id id y)\n        (right_gpv (callee s' x2)) (right_gpv (callee s' x2))", "apply (rule gpv.rel_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee s' x2 x.\n       rel_prod (=)\n        (\\<lambda>converter__ converter'__.\n            \\<exists>callee s'.\n               converter__ =\n               converter_of_callee (parallel_intercept id_oracle callee)\n                (s, s') \\<and>\n               converter'__ =\n               parallel_converter2 id_converter\n                (converter_of_callee callee s'))\n        (map_prod id\n          (converter_of_callee (parallel_intercept id_oracle callee))\n          (map_prod Inr (Pair s) x))\n        (map_prod Inr (parallel_converter2 id_converter)\n          (map_prod id (converter_of_callee callee) x))\n 2. \\<And>callee s' x2 x. map_sum id id x = map_sum id id x", "by force+"], ["", "lemma conv_callee_parallel_id_right: \"converter_of_callee (parallel_intercept callee id_oracle) (s, s') =\n  parallel_converter2 (converter_of_callee callee s) (id_converter)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_callee (parallel_intercept callee id_oracle) (s, s') =\n    parallel_converter2 (converter_of_callee callee s) id_converter", "apply (coinduction arbitrary: callee s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee s.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>callee s.\n                   converter__ =\n                   converter_of_callee (parallel_intercept callee id_oracle)\n                    (s, s') \\<and>\n                   converter'__ =\n                   parallel_converter2 (converter_of_callee callee s)\n                    id_converter))\n          (=))\n        (run_converter\n          (converter_of_callee (parallel_intercept callee id_oracle)\n            (s, s')))\n        (run_converter\n          (parallel_converter2 (converter_of_callee callee s) id_converter))", "apply (rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee s x y.\n       x = y \\<Longrightarrow>\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee s.\n                 converter__ =\n                 converter_of_callee (parallel_intercept callee id_oracle)\n                  (s, s') \\<and>\n                 converter'__ =\n                 parallel_converter2 (converter_of_callee callee s)\n                  id_converter))\n        (=)\n        (run_converter\n          (converter_of_callee (parallel_intercept callee id_oracle)\n            (s, s'))\n          x)\n        (run_converter\n          (parallel_converter2 (converter_of_callee callee s) id_converter)\n          y)", "apply (clarsimp simp add: gpv.rel_map left_gpv_map[of _ _ _ \"id\"] \n      right_gpv_map[of _ _ _ \"id\"] split!: sum.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee s x1.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee s.\n                    converter__ =\n                    converter_of_callee\n                     (parallel_intercept callee id_oracle) (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 (converter_of_callee callee s)\n                     id_converter)\n             (map_prod id\n               (converter_of_callee (parallel_intercept callee id_oracle))\n               (map_prod Inl (\\<lambda>s1'. (s1', s')) x))\n             (map_prod Inl\n               (\\<lambda>conv1'. parallel_converter2 conv1' id_converter)\n               (map_prod id (converter_of_callee callee) y)))\n        (\\<lambda>x y. map_sum id id x = map_sum id id y)\n        (left_gpv (callee s x1)) (left_gpv (callee s x1))\n 2. \\<And>callee s x2.\n       rel_gpv\n        (\\<lambda>x.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee s.\n                    converter__ =\n                    converter_of_callee\n                     (parallel_intercept callee id_oracle) (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 (converter_of_callee callee s)\n                     id_converter)\n             (map_prod id\n               (converter_of_callee (parallel_intercept callee id_oracle))\n               (map_prod Inr (Pair s) x)))\n        (\\<lambda>x. (=) (map_sum id id x)) (right_gpv (id_oracle s' x2))\n        (Generative_Probabilistic_Value.Pause (Inr x2)\n          (map_gpv\n            (map_prod Inr\n              (parallel_converter2 (converter_of_callee callee s)))\n            id \\<circ>\n           case_sum (\\<lambda>a. Fail)\n            (\\<lambda>input'.\n                Generative_Probabilistic_Value.Done\n                 (input', id_converter))))", "apply (rule gpv.rel_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>callee s x1 x.\n       rel_prod (=)\n        (\\<lambda>converter__ converter'__.\n            \\<exists>callee s.\n               converter__ =\n               converter_of_callee (parallel_intercept callee id_oracle)\n                (s, s') \\<and>\n               converter'__ =\n               parallel_converter2 (converter_of_callee callee s)\n                id_converter)\n        (map_prod id\n          (converter_of_callee (parallel_intercept callee id_oracle))\n          (map_prod Inl (\\<lambda>s1'. (s1', s')) x))\n        (map_prod Inl\n          (\\<lambda>conv1'. parallel_converter2 conv1' id_converter)\n          (map_prod id (converter_of_callee callee) x))\n 2. \\<And>callee s x1 x. map_sum id id x = map_sum id id x\n 3. \\<And>callee s x2.\n       rel_gpv\n        (\\<lambda>x.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee s.\n                    converter__ =\n                    converter_of_callee\n                     (parallel_intercept callee id_oracle) (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 (converter_of_callee callee s)\n                     id_converter)\n             (map_prod id\n               (converter_of_callee (parallel_intercept callee id_oracle))\n               (map_prod Inr (Pair s) x)))\n        (\\<lambda>x. (=) (map_sum id id x)) (right_gpv (id_oracle s' x2))\n        (Generative_Probabilistic_Value.Pause (Inr x2)\n          (map_gpv\n            (map_prod Inr\n              (parallel_converter2 (converter_of_callee callee s)))\n            id \\<circ>\n           case_sum (\\<lambda>a. Fail)\n            (\\<lambda>input'.\n                Generative_Probabilistic_Value.Done\n                 (input', id_converter))))", "by (force simp add: id_oracle_def  split!: sum.split)+"], ["", "lemma conv_callee_parallel: \"converter_of_callee (parallel_intercept callee1 callee2) (s,s') \n  = parallel_converter2 (converter_of_callee callee1 s) (converter_of_callee callee2 s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_callee (parallel_intercept callee1 callee2) (s, s') =\n    parallel_converter2 (converter_of_callee callee1 s)\n     (converter_of_callee callee2 s')", "apply (coinduction arbitrary: callee1 callee2 s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee1 callee2 s s'.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>callee1 callee2 s s'.\n                   converter__ =\n                   converter_of_callee (parallel_intercept callee1 callee2)\n                    (s, s') \\<and>\n                   converter'__ =\n                   parallel_converter2 (converter_of_callee callee1 s)\n                    (converter_of_callee callee2 s')))\n          (=))\n        (run_converter\n          (converter_of_callee (parallel_intercept callee1 callee2)\n            (s, s')))\n        (run_converter\n          (parallel_converter2 (converter_of_callee callee1 s)\n            (converter_of_callee callee2 s')))", "apply (clarsimp simp add: gpv.rel_map left_gpv_map[of _ _ _ \"id\"] right_gpv_map[of _ _ _ \"id\"] intro!: rel_funI split!: sum.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee1 callee2 s s' x1.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee1 callee2 s s'.\n                    converter__ =\n                    converter_of_callee (parallel_intercept callee1 callee2)\n                     (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 (converter_of_callee callee1 s)\n                     (converter_of_callee callee2 s'))\n             (map_prod id\n               (converter_of_callee (parallel_intercept callee1 callee2))\n               (map_prod Inl (\\<lambda>s1'. (s1', s')) x))\n             (map_prod Inl\n               (\\<lambda>conv1'.\n                   parallel_converter2 conv1'\n                    (converter_of_callee callee2 s'))\n               (map_prod id (converter_of_callee callee1) y)))\n        (\\<lambda>x y. map_sum id id x = map_sum id id y)\n        (left_gpv (callee1 s x1)) (left_gpv (callee1 s x1))\n 2. \\<And>callee1 callee2 s s' x2.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee1 callee2 s s'.\n                    converter__ =\n                    converter_of_callee (parallel_intercept callee1 callee2)\n                     (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 (converter_of_callee callee1 s)\n                     (converter_of_callee callee2 s'))\n             (map_prod id\n               (converter_of_callee (parallel_intercept callee1 callee2))\n               (map_prod Inr (Pair s) x))\n             (map_prod Inr\n               (parallel_converter2 (converter_of_callee callee1 s))\n               (map_prod id (converter_of_callee callee2) y)))\n        (\\<lambda>x y. map_sum id id x = map_sum id id y)\n        (right_gpv (callee2 s' x2)) (right_gpv (callee2 s' x2))", "apply (rule gpv.rel_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>callee1 callee2 s s' x1 x.\n       rel_prod (=)\n        (\\<lambda>converter__ converter'__.\n            \\<exists>callee1 callee2 s s'.\n               converter__ =\n               converter_of_callee (parallel_intercept callee1 callee2)\n                (s, s') \\<and>\n               converter'__ =\n               parallel_converter2 (converter_of_callee callee1 s)\n                (converter_of_callee callee2 s'))\n        (map_prod id\n          (converter_of_callee (parallel_intercept callee1 callee2))\n          (map_prod Inl (\\<lambda>s1'. (s1', s')) x))\n        (map_prod Inl\n          (\\<lambda>conv1'.\n              parallel_converter2 conv1' (converter_of_callee callee2 s'))\n          (map_prod id (converter_of_callee callee1) x))\n 2. \\<And>callee1 callee2 s s' x1 x. map_sum id id x = map_sum id id x\n 3. \\<And>callee1 callee2 s s' x2.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee1 callee2 s s'.\n                    converter__ =\n                    converter_of_callee (parallel_intercept callee1 callee2)\n                     (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 (converter_of_callee callee1 s)\n                     (converter_of_callee callee2 s'))\n             (map_prod id\n               (converter_of_callee (parallel_intercept callee1 callee2))\n               (map_prod Inr (Pair s) x))\n             (map_prod Inr\n               (parallel_converter2 (converter_of_callee callee1 s))\n               (map_prod id (converter_of_callee callee2) y)))\n        (\\<lambda>x y. map_sum id id x = map_sum id id y)\n        (right_gpv (callee2 s' x2)) (right_gpv (callee2 s' x2))", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee1 callee2 s s' x2.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee1 callee2 s s'.\n                    converter__ =\n                    converter_of_callee (parallel_intercept callee1 callee2)\n                     (s, s') \\<and>\n                    converter'__ =\n                    parallel_converter2 (converter_of_callee callee1 s)\n                     (converter_of_callee callee2 s'))\n             (map_prod id\n               (converter_of_callee (parallel_intercept callee1 callee2))\n               (map_prod Inr (Pair s) x))\n             (map_prod Inr\n               (parallel_converter2 (converter_of_callee callee1 s))\n               (map_prod id (converter_of_callee callee2) y)))\n        (\\<lambda>x y. map_sum id id x = map_sum id id y)\n        (right_gpv (callee2 s' x2)) (right_gpv (callee2 s' x2))", "apply (rule gpv.rel_refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee1 callee2 s s' x2 x.\n       rel_prod (=)\n        (\\<lambda>converter__ converter'__.\n            \\<exists>callee1 callee2 s s'.\n               converter__ =\n               converter_of_callee (parallel_intercept callee1 callee2)\n                (s, s') \\<and>\n               converter'__ =\n               parallel_converter2 (converter_of_callee callee1 s)\n                (converter_of_callee callee2 s'))\n        (map_prod id\n          (converter_of_callee (parallel_intercept callee1 callee2))\n          (map_prod Inr (Pair s) x))\n        (map_prod Inr (parallel_converter2 (converter_of_callee callee1 s))\n          (map_prod id (converter_of_callee callee2) x))\n 2. \\<And>callee1 callee2 s s' x2 x. map_sum id id x = map_sum id id x", "by force+"], ["", "lemma WT_converter_parallel_converter [WT_intro]:\n  assumes \"\\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<surd>\"\n    and \"\\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n  shows \"\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I> \\<turnstile>\\<^sub>C parallel_converter conv1 conv2 \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I> \\<turnstile>\\<^sub>C\n    parallel_converter conv1 conv2 \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I> \\<turnstile>\\<^sub>C\n    parallel_converter conv1 conv2 \\<surd>", "by(coinduction arbitrary: conv1 conv2)(auto 4 4 dest: WT_converterD intro!: imageI)"], ["", "primcorec converter_of_resource :: \"('a, 'b) resource \\<Rightarrow> ('a, 'b, 'c, 'd) converter\" where\n  \"run_converter (converter_of_resource res) = (\\<lambda>x. map_gpv (map_prod id converter_of_resource) id (lift_spmf (run_resource res x)))\""], ["", "lemma WT_converter_of_resource [WT_intro]:\n  assumes \"\\<I> \\<turnstile>res res \\<surd>\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_resource res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_resource res \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>res res \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_resource res \\<surd>", "by(coinduction arbitrary: res)(auto dest: WT_resourceD)"], ["", "lemma plossless_converter_of_resource [plossless_intro]:\n  assumes \"lossless_resource \\<I> res\"\n  shows \"plossless_converter \\<I> \\<I>' (converter_of_resource res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' (converter_of_resource res)", "using assms"], ["proof (prove)\nusing this:\n  lossless_resource \\<I> res\n\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' (converter_of_resource res)", "by(coinduction arbitrary: res)(auto 4 3 dest: lossless_resourceD)"], ["", "lemma plossless_converter_of_callee:\n  assumes \"\\<And>s x. x \\<in> outs_\\<I> \\<I>1 \\<Longrightarrow> plossless_gpv \\<I>2 (callee s x) \\<and> (\\<forall>(y, s')\\<in>results_gpv \\<I>2 (callee s x). y \\<in> responses_\\<I> \\<I>1 x)\"\n  shows \"plossless_converter \\<I>1 \\<I>2 (converter_of_callee callee s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I>1 \\<I>2 (converter_of_callee callee s)", "apply(coinduction arbitrary: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s.\n       a \\<in> outs_\\<I> \\<I>1 \\<Longrightarrow>\n       plossless_gpv \\<I>2\n        (run_converter (converter_of_callee callee s) a) \\<and>\n       (\\<forall>(b, conv')\n                 \\<in>results_gpv \\<I>2\n                       (run_converter (converter_of_callee callee s) a).\n           (\\<exists>s. conv' = converter_of_callee callee s) \\<or>\n           plossless_converter \\<I>1 \\<I>2 conv')", "subgoal for x s"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> outs_\\<I> \\<I>1 \\<Longrightarrow>\n    plossless_gpv \\<I>2\n     (run_converter (converter_of_callee callee s) x) \\<and>\n    (\\<forall>(b, conv')\n              \\<in>results_gpv \\<I>2\n                    (run_converter (converter_of_callee callee s) x).\n        (\\<exists>s. conv' = converter_of_callee callee s) \\<or>\n        plossless_converter \\<I>1 \\<I>2 conv')", "by(drule assms[where s=s]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context \n  fixes A :: \"'a set\"\n  and \\<I> :: \"('c, 'd) \\<I>\"\nbegin"], ["", "primcorec restrict_converter :: \"('a, 'b, 'c, 'd) converter \\<Rightarrow> ('a, 'b, 'c, 'd) converter\"\n  where \n  \"run_converter (restrict_converter cnv) = (\\<lambda>a. if a \\<in> A then\n     map_gpv (map_prod id (\\<lambda>cnv'. restrict_converter cnv')) id (restrict_gpv \\<I> (run_converter cnv a))\n   else Fail)\""], ["", "end"], ["", "lemma WT_restrict_converter [WT_intro]:\n  assumes \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\"\n  shows \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C cnv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C restrict_converter A \\<I>' cnv \\<surd>", "by(coinduction arbitrary: cnv)(auto dest: WT_converterD dest!: in_results_gpv_restrict_gpvD)"], ["", "lemma pgen_lossless_restrict_gpv [simp]:\n  \"\\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow> pgen_lossless_gpv b \\<I> (restrict_gpv \\<I> gpv) = pgen_lossless_gpv b \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    pgen_lossless_gpv b \\<I> (restrict_gpv \\<I> gpv) =\n    pgen_lossless_gpv b \\<I> gpv", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n    (expectation_gpv b \\<I> (\\<lambda>_. 1) (restrict_gpv \\<I> gpv) = 1) =\n    (expectation_gpv b \\<I> (\\<lambda>_. 1) gpv = 1)", "by(simp add: expectation_gpv_restrict_gpv)"], ["", "lemma plossless_restrict_converter [simp]:\n  assumes \"plossless_converter \\<I> \\<I>' conv\"\n    and \"\\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"\n    and \"outs_\\<I> \\<I> \\<subseteq> A\"\n  shows \"plossless_converter \\<I> \\<I>' (restrict_converter A \\<I>' conv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' (restrict_converter A \\<I>' conv)", "using assms"], ["proof (prove)\nusing this:\n  plossless_converter \\<I> \\<I>' conv\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  outs_\\<I> \\<I> \\<subseteq> A\n\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' (restrict_converter A \\<I>' conv)", "by(coinduction arbitrary: conv)\n    (auto dest!: in_results_gpv_restrict_gpvD WT_converterD' plossless_converterD)"], ["", "lemma plossless_map_converter:\n  \"plossless_converter \\<I> \\<I>' (map_converter f g h k conv)\"\n  if \"plossless_converter (map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>) (map_\\<I> h k \\<I>') conv\" \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' (map_converter f g h k conv)", "using that"], ["proof (prove)\nusing this:\n  plossless_converter (map_\\<I> (inv f) (inv g) \\<I>) (map_\\<I> h k \\<I>')\n   conv\n  inj f\n\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' (map_converter f g h k conv)", "by(coinduction arbitrary: conv)(auto dest!: plossless_converterD[where a=\"f _\"])"], ["", "subsection \\<open>Attaching converters to resources\\<close>"], ["", "primcorec \"attach\" :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> ('out, 'in) resource \\<Rightarrow> ('a, 'b) resource\" where\n  \"run_resource (attach conv res) = (\\<lambda>a. \n   map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res')) (exec_gpv run_resource (run_converter conv a) res))\""], ["", "lemma attach_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_resource C R ===> rel_resource A B) attach attach\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===> rel_resource C R ===> rel_resource A B)\n     attach attach", "unfolding attach_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===> rel_resource C R ===> rel_resource A B)\n     (\\<lambda>uu uua.\n         corec_resource\n          (\\<lambda>(conv, res) a.\n              map_spmf\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               (exec_gpv run_resource (run_converter conv a) res))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_resource\n          (\\<lambda>(conv, res) a.\n              map_spmf\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               (exec_gpv run_resource (run_converter conv a) res))\n          (uu, uua))", "supply exec_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===> rel_resource C R ===> rel_resource A B)\n     (\\<lambda>uu uua.\n         corec_resource\n          (\\<lambda>(conv, res) a.\n              map_spmf\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               (exec_gpv run_resource (run_converter conv a) res))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_resource\n          (\\<lambda>(conv, res) a.\n              map_spmf\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               (exec_gpv run_resource (run_converter conv a) res))\n          (uu, uua))", "by transfer_prover"], ["", "lemma attach_map_converter:\n  \"attach (map_converter f g h k conv) res = map_resource f g (attach conv (map_resource h k res))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach (map_converter f g h k conv) res =\n    map_resource f g (attach conv (map_resource h k res))", "using attach_parametric[of \"conversep (BNF_Def.Grp UNIV f)\" \"BNF_Def.Grp UNIV g\" \"BNF_Def.Grp UNIV h\" \"conversep (BNF_Def.Grp UNIV k)\"]"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV h)\n     (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n   (rel_fun\n     (rel_resource (BNF_Def.Grp UNIV h)\n       (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n     (rel_resource (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n       (BNF_Def.Grp UNIV g)))\n   attach attach\n\ngoal (1 subgoal):\n 1. attach (map_converter f g h k conv) res =\n    map_resource f g (attach conv (map_resource h k res))", "unfolding rel_converter_Grp rel_resource_Grp"], ["proof (prove)\nusing this:\n  rel_fun\n   (BNF_Def.Grp\n     {conv.\n      results_converter (\\<I>_uniform (range f) UNIV)\n       (\\<I>_uniform UNIV (range k)) conv\n      \\<subseteq> UNIV \\<and>\n      outs_converter (\\<I>_uniform (range f) UNIV)\n       (\\<I>_uniform UNIV (range k)) conv\n      \\<subseteq> UNIV}\n     (map_converter f g h k))\n   (rel_fun\n     (rel_resource (BNF_Def.Grp UNIV h)\n       (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n     (BNF_Def.Grp UNIV (map_resource f g)))\n   attach attach\n\ngoal (1 subgoal):\n 1. attach (map_converter f g h k conv) res =\n    map_resource f g (attach conv (map_resource h k res))", "by (simp, rewrite at \"rel_fun _ (rel_fun \\<hole> _)\" in asm conversep_iff[symmetric, abs_def])\n    (simp add: rel_resource_conversep[symmetric] rel_fun_def Grp_iff conversep_conversep rel_resource_Grp)"], ["", "lemma WT_resource_attach [WT_intro]: \"\\<lbrakk> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>; \\<I>' \\<turnstile>res res \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I> \\<turnstile>res attach conv res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>res attach conv res \\<surd>", "by(coinduction arbitrary: conv res)\n    (auto 4 3 intro!: exI dest: run_resource.in_set_spmf_exec_gpv_into_results_gpv WT_converterD intro: run_resource.exec_gpv_invariant)"], ["", "lemma lossless_attach [plossless_intro]:\n  assumes \"plossless_converter \\<I> \\<I>' conv\"\n    and \"lossless_resource \\<I>' res\"\n    and \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"\\<I>' \\<turnstile>res res \\<surd>\"\n  shows \"lossless_resource \\<I> (attach conv res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource \\<I> (attach conv res)", "using assms"], ["proof (prove)\nusing this:\n  plossless_converter \\<I> \\<I>' conv\n  lossless_resource \\<I>' res\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n\ngoal (1 subgoal):\n 1. lossless_resource \\<I> (attach conv res)", "proof(coinduction arbitrary: res conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a resa conv.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n        lossless_resource \\<I>' resa;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (run_resource (attach conv resa) a) \\<and>\n                         (\\<forall>(b, res')\n                                   \\<in>set_spmf\n   (run_resource (attach conv resa) a).\n                             (\\<exists>res conv.\n                                 res' = attach conv res \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 lossless_resource \\<I>' res \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res res \\<surd>) \\<or>\n                             lossless_resource \\<I> res')", "case (lossless_resource a res conv)"], ["proof (state)\nthis:\n  plossless_converter \\<I> \\<I>' conv\n  lossless_resource \\<I>' res\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>a resa conv.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n        lossless_resource \\<I>' resa;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (run_resource (attach conv resa) a) \\<and>\n                         (\\<forall>(b, res')\n                                   \\<in>set_spmf\n   (run_resource (attach conv resa) a).\n                             (\\<exists>res conv.\n                                 res' = attach conv res \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 lossless_resource \\<I>' res \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res res \\<surd>) \\<or>\n                             lossless_resource \\<I> res')", "from plossless_converterD[OF lossless_resource(1,5)]"], ["proof (chain)\npicking this:\n  plossless_gpv \\<I>' (run_converter conv a) \\<and>\n  (\\<forall>(b, conv')\\<in>results_gpv \\<I>' (run_converter conv a).\n      plossless_converter \\<I> \\<I>' conv')", "have lossless: \"plossless_gpv \\<I>' (run_converter conv a)\"\n    \"\\<And>b conv'. (b, conv') \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow> plossless_converter \\<I> \\<I>' conv'\""], ["proof (prove)\nusing this:\n  plossless_gpv \\<I>' (run_converter conv a) \\<and>\n  (\\<forall>(b, conv')\\<in>results_gpv \\<I>' (run_converter conv a).\n      plossless_converter \\<I> \\<I>' conv')\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (run_converter conv a) &&&\n    (\\<And>b conv'.\n        (b, conv')\n        \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow>\n        plossless_converter \\<I> \\<I>' conv')", "by auto"], ["proof (state)\nthis:\n  plossless_gpv \\<I>' (run_converter conv a)\n  (?b, ?conv')\n  \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow>\n  plossless_converter \\<I> \\<I>' ?conv'\n\ngoal (1 subgoal):\n 1. \\<And>a resa conv.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n        lossless_resource \\<I>' resa;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (run_resource (attach conv resa) a) \\<and>\n                         (\\<forall>(b, res')\n                                   \\<in>set_spmf\n   (run_resource (attach conv resa) a).\n                             (\\<exists>res conv.\n                                 res' = attach conv res \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 lossless_resource \\<I>' res \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res res \\<surd>) \\<or>\n                             lossless_resource \\<I> res')", "from WT_converterD'[OF lossless_resource(3,5)]"], ["proof (chain)\npicking this:\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd> \\<and>\n  (\\<forall>(r, conv')\\<in>results_gpv \\<I>' (run_converter conv a).\n      r \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n      conv' \\<surd>)", "have WT: \"\\<I>' \\<turnstile>g run_converter conv a \\<surd>\"\n    \"\\<And>b conv'. (b, conv') \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow> b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>\""], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd> \\<and>\n  (\\<forall>(r, conv')\\<in>results_gpv \\<I>' (run_converter conv a).\n      r \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n      conv' \\<surd>)\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g run_converter conv a \\<surd> &&&\n    (\\<And>b conv'.\n        (b, conv')\n        \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow>\n        b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>,\n        \\<I>' \\<turnstile>\\<^sub>C conv' \\<surd>)", "by auto"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd>\n  (?b, ?conv')\n  \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow>\n  ?b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n  ?conv' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>a resa conv.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n        lossless_resource \\<I>' resa;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (run_resource (attach conv resa) a) \\<and>\n                         (\\<forall>(b, res')\n                                   \\<in>set_spmf\n   (run_resource (attach conv resa) a).\n                             (\\<exists>res conv.\n                                 res' = attach conv res \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 lossless_resource \\<I>' res \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res res \\<surd>) \\<or>\n                             lossless_resource \\<I> res')", "have ?lossless"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (run_resource (attach conv res) a)", "using lossless(1) WT(1) lossless_resource(2,4)"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I>' (run_converter conv a)\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd>\n  lossless_resource \\<I>' res\n  \\<I>' \\<turnstile>res res \\<surd>\n\ngoal (1 subgoal):\n 1. lossless_spmf (run_resource (attach conv res) a)", "by(auto intro: run_lossless_resource.plossless_exec_gpv dest: lossless_resourceD)"], ["proof (state)\nthis:\n  lossless_spmf (run_resource (attach conv res) a)\n\ngoal (1 subgoal):\n 1. \\<And>a resa conv.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n        lossless_resource \\<I>' resa;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (run_resource (attach conv resa) a) \\<and>\n                         (\\<forall>(b, res')\n                                   \\<in>set_spmf\n   (run_resource (attach conv resa) a).\n                             (\\<exists>res conv.\n                                 res' = attach conv res \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 lossless_resource \\<I>' res \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res res \\<surd>) \\<or>\n                             lossless_resource \\<I> res')", "moreover"], ["proof (state)\nthis:\n  lossless_spmf (run_resource (attach conv res) a)\n\ngoal (1 subgoal):\n 1. \\<And>a resa conv.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n        lossless_resource \\<I>' resa;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (run_resource (attach conv resa) a) \\<and>\n                         (\\<forall>(b, res')\n                                   \\<in>set_spmf\n   (run_resource (attach conv resa) a).\n                             (\\<exists>res conv.\n                                 res' = attach conv res \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 lossless_resource \\<I>' res \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res res \\<surd>) \\<or>\n                             lossless_resource \\<I> res')", "have ?step (is \"\\<forall>(b, res')\\<in>?set. ?P b res' \\<or> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(b, res')\\<in>set_spmf (run_resource (attach conv res) a).\n       (\\<exists>res conv.\n           res' = attach conv res \\<and>\n           plossless_converter \\<I> \\<I>' conv \\<and>\n           lossless_resource \\<I>' res \\<and>\n           \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n           \\<turnstile>res res \\<surd>) \\<or>\n       lossless_resource \\<I> res'", "proof(safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in> set_spmf (run_resource (attach conv res) a);\n        \\<not> lossless_resource \\<I> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res conv.\n                            b = attach conv res \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            lossless_resource \\<I>' res \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>' \n                            \\<turnstile>res res \\<surd>", "fix b res''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in> set_spmf (run_resource (attach conv res) a);\n        \\<not> lossless_resource \\<I> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res conv.\n                            b = attach conv res \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            lossless_resource \\<I>' res \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>' \n                            \\<turnstile>res res \\<surd>", "assume \"(b, res'') \\<in> ?set\""], ["proof (state)\nthis:\n  (b, res'') \\<in> set_spmf (run_resource (attach conv res) a)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in> set_spmf (run_resource (attach conv res) a);\n        \\<not> lossless_resource \\<I> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res conv.\n                            b = attach conv res \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            lossless_resource \\<I>' res \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>' \n                            \\<turnstile>res res \\<surd>", "then"], ["proof (chain)\npicking this:\n  (b, res'') \\<in> set_spmf (run_resource (attach conv res) a)", "obtain conv' res' where *: \"((b, conv'), res') \\<in> set_spmf (exec_gpv run_resource (run_converter conv a) res)\"\n      and [simp]: \"res'' = attach conv' res'\""], ["proof (prove)\nusing this:\n  (b, res'') \\<in> set_spmf (run_resource (attach conv res) a)\n\ngoal (1 subgoal):\n 1. (\\<And>conv' res'.\n        \\<lbrakk>((b, conv'), res')\n                 \\<in> set_spmf\n                        (exec_gpv run_resource (run_converter conv a) res);\n         res'' = attach conv' res'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ((b, conv'), res')\n  \\<in> set_spmf (exec_gpv run_resource (run_converter conv a) res)\n  res'' = attach conv' res'\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in> set_spmf (run_resource (attach conv res) a);\n        \\<not> lossless_resource \\<I> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res conv.\n                            b = attach conv res \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            lossless_resource \\<I>' res \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>' \n                            \\<turnstile>res res \\<surd>", "from run_lossless_resource.in_set_spmf_exec_gpv_into_results_gpv[OF *, of \\<I>'] lossless_resource(2,4) WT"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<I>' \\<turnstile>g run_converter conv a \\<surd>;\n   lossless_resource \\<I>' res \\<and> \\<I>' \n   \\<turnstile>res res \\<surd>\\<rbrakk>\n  \\<Longrightarrow> (b, conv')\n                    \\<in> results_gpv \\<I>' (run_converter conv a)\n  lossless_resource \\<I>' res\n  \\<I>' \\<turnstile>res res \\<surd>\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd>\n  (?b, ?conv')\n  \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow>\n  ?b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n  ?conv' \\<surd>", "have conv': \"(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<I>' \\<turnstile>g run_converter conv a \\<surd>;\n   lossless_resource \\<I>' res \\<and> \\<I>' \n   \\<turnstile>res res \\<surd>\\<rbrakk>\n  \\<Longrightarrow> (b, conv')\n                    \\<in> results_gpv \\<I>' (run_converter conv a)\n  lossless_resource \\<I>' res\n  \\<I>' \\<turnstile>res res \\<surd>\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd>\n  (?b, ?conv')\n  \\<in> results_gpv \\<I>' (run_converter conv a) \\<Longrightarrow>\n  ?b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n  ?conv' \\<surd>\n\ngoal (1 subgoal):\n 1. (b, conv') \\<in> results_gpv \\<I>' (run_converter conv a)", "by auto"], ["proof (state)\nthis:\n  (b, conv') \\<in> results_gpv \\<I>' (run_converter conv a)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b) \\<in> set_spmf (run_resource (attach conv res) a);\n        \\<not> lossless_resource \\<I> b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>res conv.\n                            b = attach conv res \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            lossless_resource \\<I>' res \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>' \n                            \\<turnstile>res res \\<surd>", "from run_lossless_resource.exec_gpv_invariant[OF *, of \\<I>'] WT(2)[OF this] WT(1) lossless(2)[OF this] lossless_resource"], ["proof (chain)\npicking this:\n  \\<lbrakk>lossless_resource \\<I>' res \\<and> \\<I>' \n           \\<turnstile>res res \\<surd>;\n   \\<I>' \\<turnstile>g run_converter conv a \\<surd>\\<rbrakk>\n  \\<Longrightarrow> lossless_resource \\<I>' res' \\<and> \\<I>' \n                    \\<turnstile>res res' \\<surd>\n  b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n  conv' \\<surd>\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd>\n  plossless_converter \\<I> \\<I>' conv'\n  plossless_converter \\<I> \\<I>' conv\n  lossless_resource \\<I>' res\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n  a \\<in> outs_\\<I> \\<I>", "show \"?P b res''\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lossless_resource \\<I>' res \\<and> \\<I>' \n           \\<turnstile>res res \\<surd>;\n   \\<I>' \\<turnstile>g run_converter conv a \\<surd>\\<rbrakk>\n  \\<Longrightarrow> lossless_resource \\<I>' res' \\<and> \\<I>' \n                    \\<turnstile>res res' \\<surd>\n  b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n  conv' \\<surd>\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd>\n  plossless_converter \\<I> \\<I>' conv'\n  plossless_converter \\<I> \\<I>' conv\n  lossless_resource \\<I>' res\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<exists>res conv.\n       res'' = attach conv res \\<and>\n       plossless_converter \\<I> \\<I>' conv \\<and>\n       lossless_resource \\<I>' res \\<and>\n       \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n       \\<turnstile>res res \\<surd>", "by auto"], ["proof (state)\nthis:\n  \\<exists>res conv.\n     res'' = attach conv res \\<and>\n     plossless_converter \\<I> \\<I>' conv \\<and>\n     lossless_resource \\<I>' res \\<and>\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n     \\<turnstile>res res \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(b, res')\\<in>set_spmf (run_resource (attach conv res) a).\n     (\\<exists>res conv.\n         res' = attach conv res \\<and>\n         plossless_converter \\<I> \\<I>' conv \\<and>\n         lossless_resource \\<I>' res \\<and>\n         \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n         \\<turnstile>res res \\<surd>) \\<or>\n     lossless_resource \\<I> res'\n\ngoal (1 subgoal):\n 1. \\<And>a resa conv.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conv;\n        lossless_resource \\<I>' resa;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf\n                          (run_resource (attach conv resa) a) \\<and>\n                         (\\<forall>(b, res')\n                                   \\<in>set_spmf\n   (run_resource (attach conv resa) a).\n                             (\\<exists>res conv.\n                                 res' = attach conv res \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 lossless_resource \\<I>' res \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res res \\<surd>) \\<or>\n                             lossless_resource \\<I> res')", "ultimately"], ["proof (chain)\npicking this:\n  lossless_spmf (run_resource (attach conv res) a)\n  \\<forall>(b, res')\\<in>set_spmf (run_resource (attach conv res) a).\n     (\\<exists>res conv.\n         res' = attach conv res \\<and>\n         plossless_converter \\<I> \\<I>' conv \\<and>\n         lossless_resource \\<I>' res \\<and>\n         \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n         \\<turnstile>res res \\<surd>) \\<or>\n     lossless_resource \\<I> res'", "show ?case"], ["proof (prove)\nusing this:\n  lossless_spmf (run_resource (attach conv res) a)\n  \\<forall>(b, res')\\<in>set_spmf (run_resource (attach conv res) a).\n     (\\<exists>res conv.\n         res' = attach conv res \\<and>\n         plossless_converter \\<I> \\<I>' conv \\<and>\n         lossless_resource \\<I>' res \\<and>\n         \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n         \\<turnstile>res res \\<surd>) \\<or>\n     lossless_resource \\<I> res'\n\ngoal (1 subgoal):\n 1. lossless_spmf (run_resource (attach conv res) a) \\<and>\n    (\\<forall>(b, res')\\<in>set_spmf (run_resource (attach conv res) a).\n        (\\<exists>res conv.\n            res' = attach conv res \\<and>\n            plossless_converter \\<I> \\<I>' conv \\<and>\n            lossless_resource \\<I>' res \\<and>\n            \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n            \\<turnstile>res res \\<surd>) \\<or>\n        lossless_resource \\<I> res')", ".."], ["proof (state)\nthis:\n  lossless_spmf (run_resource (attach conv res) a) \\<and>\n  (\\<forall>(b, res')\\<in>set_spmf (run_resource (attach conv res) a).\n      (\\<exists>res conv.\n          res' = attach conv res \\<and>\n          plossless_converter \\<I> \\<I>' conv \\<and>\n          lossless_resource \\<I>' res \\<and>\n          \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n          \\<turnstile>res res \\<surd>) \\<or>\n      lossless_resource \\<I> res')\n\ngoal:\nNo subgoals!", "qed"], ["", "definition attach_callee\n  :: \"('s \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 's, 'out, 'in) gpv) \n  \\<Rightarrow> ('s' \\<Rightarrow> 'out \\<Rightarrow> ('in \\<times> 's') spmf)\n  \\<Rightarrow> ('s \\<times> 's' \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 's \\<times> 's') spmf)\" where\n  \"attach_callee callee oracle = (\\<lambda>(s, s') q. map_spmf rprodl (exec_gpv oracle (callee s q) s'))\""], ["", "lemma attach_callee_simps [simp]:\n  \"attach_callee callee oracle (s, s') q = map_spmf rprodl (exec_gpv oracle (callee s q) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_callee callee oracle (s, s') q =\n    map_spmf rprodl (exec_gpv oracle (callee s q) s')", "by(simp add: attach_callee_def)"], ["", "lemma attach_CNV_RES:\n  \"attach (converter_of_callee callee s) (resource_of_oracle res s') = \n   resource_of_oracle (attach_callee callee res) (s, s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach (converter_of_callee callee s) (resource_of_oracle res s') =\n    resource_of_oracle (attach_callee callee res) (s, s')", "by(coinduction arbitrary: s s')\n    (clarsimp simp add: spmf_rel_map rel_fun_def exec_gpv_map_gpv_id\n      , rule exec_gpv_parametric[where S=\"\\<lambda>l r. l = resource_of_oracle res r\" and A=\"(=)\" and CALL=\"(=)\", THEN rel_funD, THEN rel_funD, THEN rel_funD, THEN rel_spmf_mono]\n      , auto 4 3 simp add: rel_fun_def spmf_rel_map gpv.rel_eq intro!: rel_spmf_reflI)"], ["", "lemma attach_stateless_callee:\n  \"attach_callee (stateless_callee callee) oracle = extend_state_oracle (\\<lambda>s q. exec_gpv oracle (callee q) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_callee (stateless_callee callee) oracle =\n    \\<dagger>(\\<lambda>s q. exec_gpv oracle (callee q) s)", "by(simp add: attach_callee_def stateless_callee_def fun_eq_iff exec_gpv_map_gpv_id spmf.map_comp o_def split_def apfst_def map_prod_def)"], ["", "lemma attach_id_converter [simp]: \"attach id_converter res = res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach id_converter res = res", "by(coinduction arbitrary: res)(auto simp add: rel_fun_def spmf_rel_map split_def map_spmf_conv_bind_spmf[symmetric] intro!: rel_spmf_reflI)"], ["", "lemma attach_callee_parallel_intercept: includes lifting_syntax shows\n  \"attach_callee (parallel_intercept callee1 callee2) (plus_oracle oracle1 oracle2) =\n   (rprodl ---> id ---> map_spmf (map_prod id lprodr)) (plus_oracle (lift_state_oracle extend_state_oracle (attach_callee callee1 oracle1)) (extend_state_oracle (attach_callee callee2 oracle2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_callee (parallel_intercept callee1 callee2)\n     (oracle1 \\<oplus>\\<^sub>O oracle2) =\n    (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n     (lift_state_oracle extend_state_oracle\n       (attach_callee callee1 oracle1) \\<oplus>\\<^sub>O\n      \\<dagger>(attach_callee callee2 oracle2))", "proof ((rule ext)+, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba xa.\n       attach_callee (parallel_intercept callee1 callee2)\n        (oracle1 \\<oplus>\\<^sub>O oracle2) ((a, b), ba) xa =\n       (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n        (lift_state_oracle extend_state_oracle\n          (attach_callee callee1 oracle1) \\<oplus>\\<^sub>O\n         \\<dagger>(attach_callee callee2 oracle2))\n        ((a, b), ba) xa", "case (1 s1 s2 s q)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>a b ba xa.\n       attach_callee (parallel_intercept callee1 callee2)\n        (oracle1 \\<oplus>\\<^sub>O oracle2) ((a, b), ba) xa =\n       (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n        (lift_state_oracle extend_state_oracle\n          (attach_callee callee1 oracle1) \\<oplus>\\<^sub>O\n         \\<dagger>(attach_callee callee2 oracle2))\n        ((a, b), ba) xa", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_callee (parallel_intercept callee1 callee2)\n     (oracle1 \\<oplus>\\<^sub>O oracle2) ((s1, s2), s) q =\n    (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n     (lift_state_oracle extend_state_oracle\n       (attach_callee callee1 oracle1) \\<oplus>\\<^sub>O\n      \\<dagger>(attach_callee callee2 oracle2))\n     ((s1, s2), s) q", "by(cases q) (auto simp add: exec_gpv_plus_oracle_left exec_gpv_plus_oracle_right spmf.map_comp apfst_def o_def prod.map_comp split_def exec_gpv_map_gpv_id intro!: map_spmf_cong)"], ["proof (state)\nthis:\n  attach_callee (parallel_intercept callee1 callee2)\n   (oracle1 \\<oplus>\\<^sub>O oracle2) ((s1, s2), s) q =\n  (rprodl ---> id ---> map_spmf (map_prod id lprodr))\n   (lift_state_oracle extend_state_oracle\n     (attach_callee callee1 oracle1) \\<oplus>\\<^sub>O\n    \\<dagger>(attach_callee callee2 oracle2))\n   ((s1, s2), s) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma attach_callee_id_oracle [simp]:\n  \"attach_callee id_oracle oracle = extend_state_oracle oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_callee id_oracle oracle = \\<dagger>oracle", "by(clarsimp simp add: fun_eq_iff id_oracle_def map_spmf_conv_bind_spmf split_def)"], ["", "lemma attach_parallel2: \"attach (parallel_converter2 conv1 conv2) (parallel_resource res1 res2)\n  = parallel_resource (attach conv1 res1) (attach conv2 res2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach (parallel_converter2 conv1 conv2) (parallel_resource res1 res2) =\n    parallel_resource (attach conv1 res1) (attach conv2 res2)", "apply(coinduction arbitrary: conv1 conv2 res1 res2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res1 res2.\n       rel_fun (=)\n        (rel_spmf\n          (rel_prod (=)\n            (\\<lambda>resource__ resource'__.\n                \\<exists>conv1 conv2 res1 res2.\n                   resource__ =\n                   attach (parallel_converter2 conv1 conv2)\n                    (parallel_resource res1 res2) \\<and>\n                   resource'__ =\n                   parallel_resource (attach conv1 res1)\n                    (attach conv2 res2))))\n        (run_resource\n          (attach (parallel_converter2 conv1 conv2)\n            (parallel_resource res1 res2)))\n        (run_resource\n          (parallel_resource (attach conv1 res1) (attach conv2 res2)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res1 res2.\n       rel_fun (=)\n        (rel_spmf\n          (rel_prod (=)\n            (\\<lambda>resource__ resource'__.\n                \\<exists>conv1 conv2 res1 res2.\n                   resource__ =\n                   attach (parallel_converter2 conv1 conv2)\n                    (parallel_resource res1 res2) \\<and>\n                   resource'__ =\n                   parallel_resource (attach conv1 res1)\n                    (attach conv2 res2))))\n        (\\<lambda>a.\n            map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n             (exec_gpv run_resource\n               (case a of\n                Inl a \\<Rightarrow>\n                  map_gpv\n                   (map_prod Inl\n                     (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n                   id (left_gpv (run_converter conv1 a))\n                | Inr b \\<Rightarrow>\n                    map_gpv (map_prod Inr (parallel_converter2 conv1)) id\n                     (right_gpv (run_converter conv2 b)))\n               (parallel_resource res1 res2)))\n        (\\<lambda>ac.\n            case ac of\n            Inl a \\<Rightarrow>\n              map_spmf\n               (map_prod Inl\n                 (\\<lambda>res1'.\n                     parallel_resource res1' (attach conv2 res2)))\n               (run_resource (attach conv1 res1) a)\n            | Inr c \\<Rightarrow>\n                map_spmf\n                 (map_prod Inr (parallel_resource (attach conv1 res1)))\n                 (run_resource (attach conv2 res2) c))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res1 res2 x y.\n       x = y \\<Longrightarrow>\n       rel_spmf\n        (rel_prod (=)\n          (\\<lambda>resource__ resource'__.\n              \\<exists>conv1 conv2 res1 res2.\n                 resource__ =\n                 attach (parallel_converter2 conv1 conv2)\n                  (parallel_resource res1 res2) \\<and>\n                 resource'__ =\n                 parallel_resource (attach conv1 res1) (attach conv2 res2)))\n        (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n          (exec_gpv run_resource\n            (case x of\n             Inl a \\<Rightarrow>\n               map_gpv\n                (map_prod Inl\n                  (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n                id (left_gpv (run_converter conv1 a))\n             | Inr b \\<Rightarrow>\n                 map_gpv (map_prod Inr (parallel_converter2 conv1)) id\n                  (right_gpv (run_converter conv2 b)))\n            (parallel_resource res1 res2)))\n        (case y of\n         Inl a \\<Rightarrow>\n           map_spmf\n            (map_prod Inl\n              (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2)))\n            (run_resource (attach conv1 res1) a)\n         | Inr c \\<Rightarrow>\n             map_spmf (map_prod Inr (parallel_resource (attach conv1 res1)))\n              (run_resource (attach conv2 res2) c))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res1 res2 x.\n       rel_spmf\n        (rel_prod (=)\n          (\\<lambda>resource__ resource'__.\n              \\<exists>conv1 conv2 res1 res2.\n                 resource__ =\n                 attach (parallel_converter2 conv1 conv2)\n                  (parallel_resource res1 res2) \\<and>\n                 resource'__ =\n                 parallel_resource (attach conv1 res1) (attach conv2 res2)))\n        (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n          (exec_gpv run_resource\n            (case x of\n             Inl a \\<Rightarrow>\n               map_gpv\n                (map_prod Inl\n                  (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n                id (left_gpv (run_converter conv1 a))\n             | Inr b \\<Rightarrow>\n                 map_gpv (map_prod Inr (parallel_converter2 conv1)) id\n                  (right_gpv (run_converter conv2 b)))\n            (parallel_resource res1 res2)))\n        (case x of\n         Inl a \\<Rightarrow>\n           map_spmf\n            (map_prod Inl\n              (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2)))\n            (run_resource (attach conv1 res1) a)\n         | Inr c \\<Rightarrow>\n             map_spmf (map_prod Inr (parallel_resource (attach conv1 res1)))\n              (run_resource (attach conv2 res2) c))", "apply(simp split!: sum.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv1 conv2 res1 res2 x1.\n       rel_spmf\n        (rel_prod (=)\n          (\\<lambda>resource__ resource'__.\n              \\<exists>conv1 conv2 res1 res2.\n                 resource__ =\n                 attach (parallel_converter2 conv1 conv2)\n                  (parallel_resource res1 res2) \\<and>\n                 resource'__ =\n                 parallel_resource (attach conv1 res1) (attach conv2 res2)))\n        (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n          (exec_gpv run_resource\n            (map_gpv\n              (map_prod Inl\n                (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n              id (left_gpv (run_converter conv1 x1)))\n            (parallel_resource res1 res2)))\n        (map_spmf\n          (map_prod Inl\n            (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2)))\n          (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n            (exec_gpv run_resource (run_converter conv1 x1) res1)))\n 2. \\<And>conv1 conv2 res1 res2 x2.\n       rel_spmf\n        (rel_prod (=)\n          (\\<lambda>resource__ resource'__.\n              \\<exists>conv1 conv2 res1 res2.\n                 resource__ =\n                 attach (parallel_converter2 conv1 conv2)\n                  (parallel_resource res1 res2) \\<and>\n                 resource'__ =\n                 parallel_resource (attach conv1 res1) (attach conv2 res2)))\n        (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n          (exec_gpv run_resource\n            (map_gpv (map_prod Inr (parallel_converter2 conv1)) id\n              (right_gpv (run_converter conv2 x2)))\n            (parallel_resource res1 res2)))\n        (map_spmf (map_prod Inr (parallel_resource (attach conv1 res1)))\n          (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n            (exec_gpv run_resource (run_converter conv2 x2) res2)))", "subgoal for conv1 conv2 res1 res2 a"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=)\n       (\\<lambda>resource__ resource'__.\n           \\<exists>conv1 conv2 res1 res2.\n              resource__ =\n              attach (parallel_converter2 conv1 conv2)\n               (parallel_resource res1 res2) \\<and>\n              resource'__ =\n              parallel_resource (attach conv1 res1) (attach conv2 res2)))\n     (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n       (exec_gpv run_resource\n         (map_gpv\n           (map_prod Inl\n             (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n           id (left_gpv (run_converter conv1 a)))\n         (parallel_resource res1 res2)))\n     (map_spmf\n       (map_prod Inl\n         (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2)))\n       (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n         (exec_gpv run_resource (run_converter conv1 a) res1)))", "apply(simp add: exec_gpv_map_gpv_id spmf_rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>resource__ resource'__.\n              \\<exists>conv1 conv2 res1 res2.\n                 resource__ =\n                 attach (parallel_converter2 conv1 conv2)\n                  (parallel_resource res1 res2) \\<and>\n                 resource'__ =\n                 parallel_resource (attach conv1 res1) (attach conv2 res2))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n              map_prod Inl\n               (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n              x xa)\n          (map_prod Inl\n            (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2))\n            (case y of\n             (x, xa) \\<Rightarrow>\n               (case x of\n                (b, conv') \\<Rightarrow>\n                  \\<lambda>res'. (b, attach conv' res'))\n                xa)))\n     (exec_gpv run_resource (left_gpv (run_converter conv1 a))\n       (parallel_resource res1 res2))\n     (exec_gpv run_resource (run_converter conv1 a) res1)", "apply(rule rel_spmf_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_spmf ?A\n     (exec_gpv run_resource (left_gpv (run_converter conv1 a))\n       (parallel_resource res1 res2))\n     (exec_gpv run_resource (run_converter conv1 a) res1)\n 2. \\<And>x y.\n       ?A x y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inl\n             (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n            x xa)\n        (map_prod Inl\n          (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "apply(rule\n        exec_gpv_parametric'[where ?S = \"\\<lambda>res1res2 res1. res1res2 = parallel_resource res1 res2\" and\n          A=\"(=)\" and CALL=\"\\<lambda>l r. l = Inl r\" and R=\"\\<lambda>l r. l = Inl r\", \n          THEN rel_funD, THEN rel_funD, THEN rel_funD\n          ])"], ["proof (prove)\ngoal (4 subgoals):\n 1. rel_fun (\\<lambda>res1res2 res1. res1res2 = parallel_resource res1 res2)\n     (rel_fun (\\<lambda>l r. l = Inl r)\n       (rel_spmf\n         (rel_prod (\\<lambda>l r. l = Inl r)\n           (\\<lambda>res1res2 res1.\n               res1res2 = parallel_resource res1 res2))))\n     run_resource run_resource\n 2. rel_gpv'' (=) (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r)\n     (left_gpv (run_converter conv1 a)) (run_converter conv1 a)\n 3. parallel_resource res1 res2 = parallel_resource res1 res2\n 4. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res1. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inl\n             (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n            x xa)\n        (map_prod Inl\n          (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (\\<lambda>res1res2 res1. res1res2 = parallel_resource res1 res2)\n     (rel_fun (\\<lambda>l r. l = Inl r)\n       (rel_spmf\n         (rel_prod (\\<lambda>l r. l = Inl r)\n           (\\<lambda>res1res2 res1.\n               res1res2 = parallel_resource res1 res2))))\n     run_resource run_resource", "by(auto simp add: rel_fun_def spmf_rel_map intro!: rel_spmf_reflI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rel_gpv'' (=) (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r)\n     (left_gpv (run_converter conv1 a)) (run_converter conv1 a)\n 2. parallel_resource res1 res2 = parallel_resource res1 res2\n 3. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res1. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inl\n             (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n            x xa)\n        (map_prod Inl\n          (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv'' (=) (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r)\n     (left_gpv (run_converter conv1 a)) (run_converter conv1 a)", "by (simp add: left_gpv_Inl_transfer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parallel_resource res1 res2 = parallel_resource res1 res2\n 2. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res1. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inl\n             (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n            x xa)\n        (map_prod Inl\n          (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_resource res1 res2 = parallel_resource res1 res2", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res1. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inl\n             (\\<lambda>conv1'. parallel_converter2 conv1' conv2))\n            x xa)\n        (map_prod Inl\n          (\\<lambda>res1'. parallel_resource res1' (attach conv2 res2))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bb.\n       \\<exists>conv1 conv2 res1 res2.\n          attach (parallel_converter2 b conv2) (parallel_resource bb res2) =\n          attach (parallel_converter2 conv1 conv2)\n           (parallel_resource res1 res2) \\<and>\n          parallel_resource (attach b bb) (attach conv2 res2) =\n          parallel_resource (attach conv1 res1) (attach conv2 res2)", "apply(rule exI conjI refl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res1 res2 x2.\n       rel_spmf\n        (rel_prod (=)\n          (\\<lambda>resource__ resource'__.\n              \\<exists>conv1 conv2 res1 res2.\n                 resource__ =\n                 attach (parallel_converter2 conv1 conv2)\n                  (parallel_resource res1 res2) \\<and>\n                 resource'__ =\n                 parallel_resource (attach conv1 res1) (attach conv2 res2)))\n        (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n          (exec_gpv run_resource\n            (map_gpv (map_prod Inr (parallel_converter2 conv1)) id\n              (right_gpv (run_converter conv2 x2)))\n            (parallel_resource res1 res2)))\n        (map_spmf (map_prod Inr (parallel_resource (attach conv1 res1)))\n          (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n            (exec_gpv run_resource (run_converter conv2 x2) res2)))", "subgoal for conv1 conv2 res1 res2 a"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=)\n       (\\<lambda>resource__ resource'__.\n           \\<exists>conv1 conv2 res1 res2.\n              resource__ =\n              attach (parallel_converter2 conv1 conv2)\n               (parallel_resource res1 res2) \\<and>\n              resource'__ =\n              parallel_resource (attach conv1 res1) (attach conv2 res2)))\n     (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n       (exec_gpv run_resource\n         (map_gpv (map_prod Inr (parallel_converter2 conv1)) id\n           (right_gpv (run_converter conv2 a)))\n         (parallel_resource res1 res2)))\n     (map_spmf (map_prod Inr (parallel_resource (attach conv1 res1)))\n       (map_spmf (\\<lambda>((b, conv'), res'). (b, attach conv' res'))\n         (exec_gpv run_resource (run_converter conv2 a) res2)))", "apply(simp add: exec_gpv_map_gpv_id spmf_rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>resource__ resource'__.\n              \\<exists>conv1 conv2 res1 res2.\n                 resource__ =\n                 attach (parallel_converter2 conv1 conv2)\n                  (parallel_resource res1 res2) \\<and>\n                 resource'__ =\n                 parallel_resource (attach conv1 res1) (attach conv2 res2))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n              map_prod Inr (parallel_converter2 conv1))\n              x xa)\n          (map_prod Inr (parallel_resource (attach conv1 res1))\n            (case y of\n             (x, xa) \\<Rightarrow>\n               (case x of\n                (b, conv') \\<Rightarrow>\n                  \\<lambda>res'. (b, attach conv' res'))\n                xa)))\n     (exec_gpv run_resource (right_gpv (run_converter conv2 a))\n       (parallel_resource res1 res2))\n     (exec_gpv run_resource (run_converter conv2 a) res2)", "apply(rule rel_spmf_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_spmf ?A\n     (exec_gpv run_resource (right_gpv (run_converter conv2 a))\n       (parallel_resource res1 res2))\n     (exec_gpv run_resource (run_converter conv2 a) res2)\n 2. \\<And>x y.\n       ?A x y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inr (parallel_converter2 conv1))\n            x xa)\n        (map_prod Inr (parallel_resource (attach conv1 res1))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "apply(rule\n        exec_gpv_parametric'[where ?S = \"\\<lambda>res1res2 res2. res1res2 = parallel_resource res1 res2\" and\n          A=\"(=)\" and CALL=\"\\<lambda>l r. l = Inr r\" and R=\"\\<lambda>l r. l = Inr r\", \n          THEN rel_funD, THEN rel_funD, THEN rel_funD\n          ])"], ["proof (prove)\ngoal (4 subgoals):\n 1. rel_fun (\\<lambda>res1res2 res2. res1res2 = parallel_resource res1 res2)\n     (rel_fun (\\<lambda>l r. l = Inr r)\n       (rel_spmf\n         (rel_prod (\\<lambda>l r. l = Inr r)\n           (\\<lambda>res1res2 res2.\n               res1res2 = parallel_resource res1 res2))))\n     run_resource run_resource\n 2. rel_gpv'' (=) (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r)\n     (right_gpv (run_converter conv2 a)) (run_converter conv2 a)\n 3. parallel_resource res1 res2 = parallel_resource res1 res2\n 4. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res2. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inr (parallel_converter2 conv1))\n            x xa)\n        (map_prod Inr (parallel_resource (attach conv1 res1))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (\\<lambda>res1res2 res2. res1res2 = parallel_resource res1 res2)\n     (rel_fun (\\<lambda>l r. l = Inr r)\n       (rel_spmf\n         (rel_prod (\\<lambda>l r. l = Inr r)\n           (\\<lambda>res1res2 res2.\n               res1res2 = parallel_resource res1 res2))))\n     run_resource run_resource", "by(auto simp add: rel_fun_def spmf_rel_map intro: rel_spmf_reflI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rel_gpv'' (=) (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r)\n     (right_gpv (run_converter conv2 a)) (run_converter conv2 a)\n 2. parallel_resource res1 res2 = parallel_resource res1 res2\n 3. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res2. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inr (parallel_converter2 conv1))\n            x xa)\n        (map_prod Inr (parallel_resource (attach conv1 res1))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv'' (=) (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r)\n     (right_gpv (run_converter conv2 a)) (run_converter conv2 a)", "by (simp add: right_gpv_Inr_transfer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parallel_resource res1 res2 = parallel_resource res1 res2\n 2. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res2. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inr (parallel_converter2 conv1))\n            x xa)\n        (map_prod Inr (parallel_resource (attach conv1 res1))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_resource res1 res2 = parallel_resource res1 res2", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_prod (=)\n        (\\<lambda>res1res2 res2. res1res2 = parallel_resource res1 res2) x\n        y \\<Longrightarrow>\n       rel_prod (=)\n        (\\<lambda>resource__ resource'__.\n            \\<exists>conv1 conv2 res1 res2.\n               resource__ =\n               attach (parallel_converter2 conv1 conv2)\n                (parallel_resource res1 res2) \\<and>\n               resource'__ =\n               parallel_resource (attach conv1 res1) (attach conv2 res2))\n        (case x of\n         (x, xa) \\<Rightarrow>\n           ((\\<lambda>(b, conv') res'. (b, attach conv' res')) \\<circ>\n            map_prod Inr (parallel_converter2 conv1))\n            x xa)\n        (map_prod Inr (parallel_resource (attach conv1 res1))\n          (case y of\n           (x, xa) \\<Rightarrow>\n             (case x of\n              (b, conv') \\<Rightarrow>\n                \\<lambda>res'. (b, attach conv' res'))\n              xa))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bb.\n       \\<exists>conv1 conv2 res1 res2.\n          attach (parallel_converter2 conv1 b) (parallel_resource res1 bb) =\n          attach (parallel_converter2 conv1 conv2)\n           (parallel_resource res1 res2) \\<and>\n          parallel_resource (attach conv1 res1) (attach b bb) =\n          parallel_resource (attach conv1 res1) (attach conv2 res2)", "apply(rule exI conjI refl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Composing converters\\<close>"], ["", "primcorec comp_converter :: \"('a, 'b, 'out, 'in) converter \\<Rightarrow> ('out, 'in, 'out', 'in') converter \\<Rightarrow> ('a, 'b, 'out', 'in') converter\" where\n  \"run_converter (comp_converter conv1 conv2) = (\\<lambda>a.\n  map_gpv (\\<lambda>((b, conv1'), conv2'). (b, comp_converter conv1' conv2')) id (inline run_converter (run_converter conv1 a) conv2))\""], ["", "lemma comp_converter_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_converter A B C R ===> rel_converter C R C' R' ===> rel_converter A B C' R')\n  comp_converter comp_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter C R C' R' ===> rel_converter A B C' R')\n     comp_converter comp_converter", "unfolding comp_converter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter C R C' R' ===> rel_converter A B C' R')\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) a.\n              map_gpv\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               id (inline run_converter (run_converter conv1 a) conv2))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) a.\n              map_gpv\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               id (inline run_converter (run_converter conv1 a) conv2))\n          (uu, uua))", "supply inline_parametric'[transfer_rule] map_gpv_parametric'[transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_converter A B C R ===>\n     rel_converter C R C' R' ===> rel_converter A B C' R')\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) a.\n              map_gpv\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               id (inline run_converter (run_converter conv1 a) conv2))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_converter\n          (\\<lambda>(conv1, conv2) a.\n              map_gpv\n               (\\<lambda>uu.\n                   (id (fst (fst uu)), Inr (snd (fst uu), snd uu)))\n               id (inline run_converter (run_converter conv1 a) conv2))\n          (uu, uua))", "by transfer_prover"], ["", "lemma comp_converter_map_converter1:\n  fixes conv' :: \"('a, 'b, 'out, 'in) converter\" shows\n    \"comp_converter (map_converter f g h k conv) conv' = map_converter f g id id (comp_converter conv (map_converter h k id id conv'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "using comp_converter_parametric[of\n      \"conversep (BNF_Def.Grp UNIV f)\" \"BNF_Def.Grp UNIV g\" \"BNF_Def.Grp UNIV h\" \"conversep (BNF_Def.Grp UNIV k)\"\n      \"BNF_Def.Grp UNIV (id :: 'out \\<Rightarrow> _)\" \"conversep (BNF_Def.Grp UNIV (id :: 'in \\<Rightarrow> _))\"\n      ]"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV h)\n     (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n   (rel_fun\n     (rel_converter (BNF_Def.Grp UNIV h)\n       (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV id)\n       (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\n     (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n       (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV id)\n       (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>))\n   comp_converter comp_converter\n\ngoal (1 subgoal):\n 1. comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(unfold rel_converter_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (BNF_Def.Grp\n       {conv.\n        results_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> UNIV \\<and>\n        outs_converter (\\<I>_uniform (range f) UNIV)\n         (\\<I>_uniform UNIV (range k)) conv\n        \\<subseteq> UNIV}\n       (map_converter f g h k))\n     (rel_fun\n       (rel_converter (BNF_Def.Grp UNIV h)\n         (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV id)\n         (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\n       (BNF_Def.Grp\n         {conv.\n          results_converter (\\<I>_uniform (range f) UNIV)\n           (\\<I>_uniform UNIV (range id)) conv\n          \\<subseteq> UNIV \\<and>\n          outs_converter (\\<I>_uniform (range f) UNIV)\n           (\\<I>_uniform UNIV (range id)) conv\n          \\<subseteq> UNIV}\n         (map_converter f g id id)))\n     comp_converter comp_converter \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(simp add: rel_fun_def Grp_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       rel_converter (BNF_Def.Grp UNIV h)\n        (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV id)\n        (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> xa y \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(rewrite at \"\\<forall>_ _ _. \\<hole> \\<longrightarrow> _\" in asm conversep_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       (rel_converter (BNF_Def.Grp UNIV h)\n         (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV id)\n         (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\\<inverse>\\<inverse>\n        y xa \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(unfold rel_converter_conversep[symmetric] conversep_conversep eq_alt[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       rel_converter (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV k) (=)\\<inverse>\\<inverse> (=) y\n        xa \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(rewrite in \"rel_converter _ _ \\<hole> _\" in asm conversep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       rel_converter (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV k) (=) (=) y xa \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(rewrite in \"rel_converter _ _ _ \\<hole>\" in asm conversep_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       rel_converter (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV k) (=) (=)\\<inverse>\\<inverse> y\n        xa \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(rewrite in \"rel_converter _ _ \\<hole> _\" in asm eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       rel_converter (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV k) (BNF_Def.Grp UNIV id) (=)\\<inverse>\\<inverse> y\n        xa \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(rewrite in \"rel_converter _ _ _ \\<hole>\" in asm eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       rel_converter (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV k) (BNF_Def.Grp UNIV id)\n        (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> y xa \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(unfold rel_converter_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa y.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range h) UNIV)\n          (\\<I>_uniform UNIV (range id)) conv\n         \\<subseteq> UNIV \\<and>\n         outs_converter (\\<I>_uniform (range h) UNIV)\n          (\\<I>_uniform UNIV (range id)) conv\n         \\<subseteq> UNIV}\n        (map_converter h k id id) y xa \\<longrightarrow>\n       comp_converter (map_converter f g h k x) y =\n       map_converter f g id id (comp_converter x xa) \\<Longrightarrow>\n    comp_converter (map_converter f g h k conv) conv' =\n    map_converter f g id id\n     (comp_converter conv (map_converter h k id id conv'))", "apply(simp add: Grp_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma comp_converter_map_converter2:\n  fixes conv :: \"('a, 'b, 'out, 'in) converter\" shows\n    \"comp_converter conv (map_converter f g h k conv') = map_converter id id h k (comp_converter (map_converter id id f g conv) conv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "using comp_converter_parametric[of\n      \"BNF_Def.Grp UNIV (id :: 'a \\<Rightarrow> _)\" \"conversep (BNF_Def.Grp UNIV (id :: 'b \\<Rightarrow> _))\"\n      \"conversep (BNF_Def.Grp UNIV f)\" \"BNF_Def.Grp UNIV g\" \"BNF_Def.Grp UNIV h\" \"conversep (BNF_Def.Grp UNIV k)\"\n      ]"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_converter (BNF_Def.Grp UNIV id)\n     (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV g))\n   (rel_fun\n     (rel_converter (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n       (BNF_Def.Grp UNIV g) (BNF_Def.Grp UNIV h)\n       (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>)\n     (rel_converter (BNF_Def.Grp UNIV id)\n       (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV h)\n       (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n   comp_converter comp_converter\n\ngoal (1 subgoal):\n 1. comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(unfold rel_converter_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_converter (BNF_Def.Grp UNIV id)\n       (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\n       (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV g))\n     (rel_fun\n       (BNF_Def.Grp\n         {conv.\n          results_converter (\\<I>_uniform (range f) UNIV)\n           (\\<I>_uniform UNIV (range k)) conv\n          \\<subseteq> UNIV \\<and>\n          outs_converter (\\<I>_uniform (range f) UNIV)\n           (\\<I>_uniform UNIV (range k)) conv\n          \\<subseteq> UNIV}\n         (map_converter f g h k))\n       (rel_converter (BNF_Def.Grp UNIV id)\n         (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV h)\n         (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>))\n     comp_converter comp_converter \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(simp add: rel_fun_def Grp_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       rel_converter (BNF_Def.Grp UNIV id)\n        (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV g) x\n        y \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (BNF_Def.Grp UNIV id)\n            (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(rewrite at \"\\<forall>_ _. \\<hole> \\<longrightarrow> _\" in asm conversep_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (rel_converter (BNF_Def.Grp UNIV id)\n         (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\n         (BNF_Def.Grp UNIV f)\\<inverse>\\<inverse>\n         (BNF_Def.Grp UNIV g))\\<inverse>\\<inverse>\n        y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (BNF_Def.Grp UNIV id)\n            (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(unfold rel_converter_conversep[symmetric] conversep_conversep rel_converter_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp\n        {conv.\n         results_converter (\\<I>_uniform (range id) UNIV)\n          (\\<I>_uniform UNIV (range g)) conv\n         \\<subseteq> UNIV \\<and>\n         outs_converter (\\<I>_uniform (range id) UNIV)\n          (\\<I>_uniform UNIV (range g)) conv\n         \\<subseteq> UNIV}\n        (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (BNF_Def.Grp UNIV id)\n            (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp UNIV (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (BNF_Def.Grp UNIV id)\n            (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(unfold eq_alt[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp UNIV (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (=) (=)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(rewrite in \"rel_converter _ \\<hole>\" in asm conversep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp UNIV (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (=) (=) (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(rewrite in \"rel_converter \\<hole> _\" in asm conversep_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp UNIV (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (=)\\<inverse>\\<inverse> (=) (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(rewrite in \"rel_converter \\<hole> _\" in asm eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp UNIV (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (=)\n            (BNF_Def.Grp UNIV h) (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse>\n            (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(rewrite in \"rel_converter _ \\<hole>\" in asm eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp UNIV (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           rel_converter (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\n            (BNF_Def.Grp UNIV id) (BNF_Def.Grp UNIV h)\n            (BNF_Def.Grp UNIV k)\\<inverse>\\<inverse> (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(unfold rel_converter_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       BNF_Def.Grp UNIV (map_converter id id f g) y x \\<longrightarrow>\n       (\\<forall>xa.\n           BNF_Def.Grp\n            {conv.\n             results_converter (\\<I>_uniform (range id) UNIV)\n              (\\<I>_uniform UNIV (range k)) conv\n             \\<subseteq> UNIV \\<and>\n             outs_converter (\\<I>_uniform (range id) UNIV)\n              (\\<I>_uniform UNIV (range k)) conv\n             \\<subseteq> UNIV}\n            (map_converter id id h k) (comp_converter x xa)\n            (comp_converter y (map_converter f g h k xa))) \\<Longrightarrow>\n    comp_converter conv (map_converter f g h k conv') =\n    map_converter id id h k\n     (comp_converter (map_converter id id f g conv) conv')", "apply(simp add: Grp_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma attach_compose:\n  \"attach (comp_converter conv1 conv2) res = attach conv1 (attach conv2 res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach (comp_converter conv1 conv2) res =\n    attach conv1 (attach conv2 res)", "apply(coinduction arbitrary: conv1 conv2 res)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res.\n       rel_fun (=)\n        (rel_spmf\n          (rel_prod (=)\n            (\\<lambda>resource__ resource'__.\n                \\<exists>conv1 conv2 res.\n                   resource__ =\n                   attach (comp_converter conv1 conv2) res \\<and>\n                   resource'__ = attach conv1 (attach conv2 res))))\n        (run_resource (attach (comp_converter conv1 conv2) res))\n        (run_resource (attach conv1 (attach conv2 res)))", "apply(auto intro!: rel_funI simp add: spmf_rel_map exec_gpv_map_gpv_id exec_gpv_inline o_def split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res y.\n       rel_spmf\n        (\\<lambda>x y.\n            fst (fst x) = fst (fst y) \\<and>\n            (\\<exists>conv1 conv2 res.\n                attach (comp_converter (snd (fst x)) (fst (snd x)))\n                 (snd (snd x)) =\n                attach (comp_converter conv1 conv2) res \\<and>\n                attach (snd (fst y)) (snd y) =\n                attach conv1 (attach conv2 res)))\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n               (exec_gpv run_resource (run_converter s' y) s))\n          (run_converter conv1 y) (conv2, res))\n        (exec_gpv run_resource (run_converter conv1 y) (attach conv2 res))", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 res y.\n       rel_spmf\n        (\\<lambda>x y.\n            fst (fst x) = fst (fst y) \\<and>\n            (\\<exists>conv1 conv2 res.\n                attach (comp_converter (snd (fst x)) (fst (snd x)))\n                 (snd (snd x)) =\n                attach (comp_converter conv1 conv2) res \\<and>\n                attach (snd (fst y)) (snd y) =\n                attach conv1 (attach conv2 res)))\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n               (exec_gpv run_resource (run_converter s' y) s))\n          (run_converter conv1 y) (conv2, res))\n        (exec_gpv run_resource (run_converter conv1 y) (attach conv2 res))", "apply(rule rel_spmf_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv1 conv2 res y.\n       rel_spmf (?A3 conv1 conv2 res y)\n        (exec_gpv\n          (\\<lambda>(s', s) y.\n              map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n               (exec_gpv run_resource (run_converter s' y) s))\n          (run_converter conv1 y) (conv2, res))\n        (exec_gpv run_resource (run_converter conv1 y) (attach conv2 res))\n 2. \\<And>conv1 conv2 res y x ya.\n       ?A3 conv1 conv2 res y x ya \\<Longrightarrow>\n       fst (fst x) = fst (fst ya) \\<and>\n       (\\<exists>conv1 conv2 res.\n           attach (comp_converter (snd (fst x)) (fst (snd x)))\n            (snd (snd x)) =\n           attach (comp_converter conv1 conv2) res \\<and>\n           attach (snd (fst ya)) (snd ya) = attach conv1 (attach conv2 res))", "apply(rule exec_gpv_parametric[where A=\"(=)\" and CALL=\"(=)\" and S=\"\\<lambda>(l, r) s2. s2 = attach l r\", THEN rel_funD, THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>conv1 conv2 res y.\n       ((\\<lambda>(l, r) s2. s2 = attach l r) ===>\n        (=) ===>\n        rel_spmf (rel_prod (=) (\\<lambda>(l, r) s2. s2 = attach l r)))\n        (\\<lambda>(s', s) y.\n            map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n             (exec_gpv run_resource (run_converter s' y) s))\n        run_resource\n 2. \\<And>conv1 conv2 res y.\n       rel_gpv (=) (=) (run_converter conv1 y) (run_converter conv1 y)\n 3. \\<And>conv1 conv2 res y.\n       (case (conv2, res) of\n        (l, r) \\<Rightarrow> \\<lambda>s2. s2 = attach l r)\n        (attach conv2 res)\n 4. \\<And>conv1 conv2 res y x ya.\n       rel_prod (=) (\\<lambda>(l, r) s2. s2 = attach l r) x\n        ya \\<Longrightarrow>\n       fst (fst x) = fst (fst ya) \\<and>\n       (\\<exists>conv1 conv2 res.\n           attach (comp_converter (snd (fst x)) (fst (snd x)))\n            (snd (snd x)) =\n           attach (comp_converter conv1 conv2) res \\<and>\n           attach (snd (fst ya)) (snd ya) = attach conv1 (attach conv2 res))", "prefer 4"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>conv1 conv2 res y x ya.\n       rel_prod (=) (\\<lambda>(l, r) s2. s2 = attach l r) x\n        ya \\<Longrightarrow>\n       fst (fst x) = fst (fst ya) \\<and>\n       (\\<exists>conv1 conv2 res.\n           attach (comp_converter (snd (fst x)) (fst (snd x)))\n            (snd (snd x)) =\n           attach (comp_converter conv1 conv2) res \\<and>\n           attach (snd (fst ya)) (snd ya) = attach conv1 (attach conv2 res))\n 2. \\<And>conv1 conv2 res y.\n       ((\\<lambda>(l, r) s2. s2 = attach l r) ===>\n        (=) ===>\n        rel_spmf (rel_prod (=) (\\<lambda>(l, r) s2. s2 = attach l r)))\n        (\\<lambda>(s', s) y.\n            map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n             (exec_gpv run_resource (run_converter s' y) s))\n        run_resource\n 3. \\<And>conv1 conv2 res y.\n       rel_gpv (=) (=) (run_converter conv1 y) (run_converter conv1 y)\n 4. \\<And>conv1 conv2 res y.\n       (case (conv2, res) of\n        (l, r) \\<Rightarrow> \\<lambda>s2. s2 = attach l r)\n        (attach conv2 res)", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b a ba.\n       \\<exists>conv1 conv2 res.\n          attach (comp_converter b a) ba =\n          attach (comp_converter conv1 conv2) res \\<and>\n          attach b (attach a ba) = attach conv1 (attach conv2 res)\n 2. \\<And>conv1 conv2 res y.\n       ((\\<lambda>(l, r) s2. s2 = attach l r) ===>\n        (=) ===>\n        rel_spmf (rel_prod (=) (\\<lambda>(l, r) s2. s2 = attach l r)))\n        (\\<lambda>(s', s) y.\n            map_spmf (\\<lambda>((x, s'), s). (x, s', s))\n             (exec_gpv run_resource (run_converter s' y) s))\n        run_resource\n 3. \\<And>conv1 conv2 res y.\n       rel_gpv (=) (=) (run_converter conv1 y) (run_converter conv1 y)\n 4. \\<And>conv1 conv2 res y.\n       (case (conv2, res) of\n        (l, r) \\<Rightarrow> \\<lambda>s2. s2 = attach l r)\n        (attach conv2 res)", "by(auto simp add: case_prod_def spmf_rel_map gpv.rel_eq split_def intro!: rel_funI rel_spmf_reflI)"], ["", "lemma comp_converter_assoc:\n  \"comp_converter (comp_converter conv1 conv2) conv3 = comp_converter conv1 (comp_converter conv2 conv3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter (comp_converter conv1 conv2) conv3 =\n    comp_converter conv1 (comp_converter conv2 conv3)", "apply(coinduction arbitrary: conv1 conv2 conv3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 conv3.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>conv1 conv2 conv3.\n                   converter__ =\n                   comp_converter (comp_converter conv1 conv2) conv3 \\<and>\n                   converter'__ =\n                   comp_converter conv1 (comp_converter conv2 conv3)))\n          (=))\n        (run_converter (comp_converter (comp_converter conv1 conv2) conv3))\n        (run_converter (comp_converter conv1 (comp_converter conv2 conv3)))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 conv3 x y.\n       x = y \\<Longrightarrow>\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1 conv2 conv3.\n                 converter__ =\n                 comp_converter (comp_converter conv1 conv2) conv3 \\<and>\n                 converter'__ =\n                 comp_converter conv1 (comp_converter conv2 conv3)))\n        (=)\n        (run_converter (comp_converter (comp_converter conv1 conv2) conv3)\n          x)\n        (run_converter (comp_converter conv1 (comp_converter conv2 conv3))\n          y)", "apply(clarsimp simp add: gpv.rel_map inline_map_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 conv3 x.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv1 conv2 conv3.\n                    converter__ =\n                    comp_converter (comp_converter conv1 conv2) conv3 \\<and>\n                    converter'__ =\n                    comp_converter conv1 (comp_converter conv2 conv3))\n             (case x of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 (\\<lambda>((b, conv1'), conv2').\n                     (b, comp_converter conv1' conv2')))\n                 x xa)\n             (case y of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (b, conv1') \\<Rightarrow>\n                   \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                 xa))\n        (=)\n        (inline run_converter\n          (inline run_converter (run_converter conv1 x) conv2) conv3)\n        (inline run_converter (run_converter conv1 x)\n          (comp_converter conv2 conv3))", "apply(subst inline_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 conv3 x.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv1 conv2 conv3.\n                    converter__ =\n                    comp_converter (comp_converter conv1 conv2) conv3 \\<and>\n                    converter'__ =\n                    comp_converter conv1 (comp_converter conv2 conv3))\n             (case x of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 (\\<lambda>((b, conv1'), conv2').\n                     (b, comp_converter conv1' conv2')))\n                 x xa)\n             (case y of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (b, conv1') \\<Rightarrow>\n                   \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                 xa))\n        (=)\n        (map_gpv (\\<lambda>(r, s2, y). ((r, s2), y)) id\n          (inline\n            (\\<lambda>(s2, s1) c2.\n                map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                 (inline run_converter (run_converter s2 c2) s1))\n            (run_converter conv1 x) (conv2, conv3)))\n        (inline run_converter (run_converter conv1 x)\n          (comp_converter conv2 conv3))", "apply(simp add: gpv.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 conv3 x.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv1 conv2 conv3.\n                    converter__ =\n                    comp_converter (comp_converter conv1 conv2) conv3 \\<and>\n                    converter'__ =\n                    comp_converter conv1 (comp_converter conv2 conv3))\n             (case case x of (r, s2, xa) \\<Rightarrow> ((r, s2), xa) of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 (\\<lambda>((b, conv1'), conv2').\n                     (b, comp_converter conv1' conv2')))\n                 x xa)\n             (case y of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (b, conv1') \\<Rightarrow>\n                   \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                 xa))\n        (=)\n        (inline\n          (\\<lambda>(s2, s1) c2.\n              map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n               (inline run_converter (run_converter s2 c2) s1))\n          (run_converter conv1 x) (conv2, conv3))\n        (inline run_converter (run_converter conv1 x)\n          (comp_converter conv2 conv3))", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1 conv2 conv3 x.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv1 conv2 conv3.\n                    converter__ =\n                    comp_converter (comp_converter conv1 conv2) conv3 \\<and>\n                    converter'__ =\n                    comp_converter conv1 (comp_converter conv2 conv3))\n             (case case x of (r, s2, xa) \\<Rightarrow> ((r, s2), xa) of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 (\\<lambda>((b, conv1'), conv2').\n                     (b, comp_converter conv1' conv2')))\n                 x xa)\n             (case y of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (b, conv1') \\<Rightarrow>\n                   \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                 xa))\n        (=)\n        (inline\n          (\\<lambda>(s2, s1) c2.\n              map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n               (inline run_converter (run_converter s2 c2) s1))\n          (run_converter conv1 x) (conv2, conv3))\n        (inline run_converter (run_converter conv1 x)\n          (comp_converter conv2 conv3))", "apply(rule gpv.rel_mono_strong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conv1 conv2 conv3 x.\n       rel_gpv (?R1.4 conv1 conv2 conv3 x) (?R2.4 conv1 conv2 conv3 x)\n        (inline\n          (\\<lambda>(s2, s1) c2.\n              map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n               (inline run_converter (run_converter s2 c2) s1))\n          (run_converter conv1 x) (conv2, conv3))\n        (inline run_converter (run_converter conv1 x)\n          (comp_converter conv2 conv3))\n 2. \\<And>conv1 conv2 conv3 x z1 y1.\n       \\<lbrakk>z1 \\<in> results'_gpv\n                          (inline\n                            (\\<lambda>(s2, s1) c2.\n                                map_gpv\n                                 (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                                 (inline run_converter (run_converter s2 c2)\n                                   s1))\n                            (run_converter conv1 x) (conv2, conv3));\n        y1 \\<in> results'_gpv\n                  (inline run_converter (run_converter conv1 x)\n                    (comp_converter conv2 conv3));\n        ?R1.4 conv1 conv2 conv3 x z1 y1\\<rbrakk>\n       \\<Longrightarrow> rel_prod (=)\n                          (\\<lambda>converter__ converter'__.\n                              \\<exists>conv1 conv2 conv3.\n                                 converter__ =\n                                 comp_converter (comp_converter conv1 conv2)\n                                  conv3 \\<and>\n                                 converter'__ =\n                                 comp_converter conv1\n                                  (comp_converter conv2 conv3))\n                          (case case z1 of\n                                (r, s2, xa) \\<Rightarrow> ((r, s2), xa) of\n                           (x, xa) \\<Rightarrow>\n                             ((\\<lambda>(b, conv1') conv2'.\n                                  (b, comp_converter conv1' conv2')) \\<circ>\n                              (\\<lambda>((b, conv1'), conv2').\n                                  (b, comp_converter conv1' conv2')))\n                              x xa)\n                          (case y1 of\n                           (x, xa) \\<Rightarrow>\n                             (case x of\n                              (b, conv1') \\<Rightarrow>\n                                \\<lambda>conv2'.\n                                   (b, comp_converter conv1' conv2'))\n                              xa)\n 3. \\<And>conv1 conv2 conv3 x z2 y2.\n       \\<lbrakk>z2 \\<in> outs'_gpv\n                          (inline\n                            (\\<lambda>(s2, s1) c2.\n                                map_gpv\n                                 (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                                 (inline run_converter (run_converter s2 c2)\n                                   s1))\n                            (run_converter conv1 x) (conv2, conv3));\n        y2 \\<in> outs'_gpv\n                  (inline run_converter (run_converter conv1 x)\n                    (comp_converter conv2 conv3));\n        ?R2.4 conv1 conv2 conv3 x z2 y2\\<rbrakk>\n       \\<Longrightarrow> z2 = y2", "apply(rule inline_parametric[where C=\"(=)\" and C'=\"(=)\" and A=\"(=)\" and S=\"\\<lambda>(l, r) s2. s2 = comp_converter l r\", THEN rel_funD, THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>conv1 conv2 conv3 x.\n       ((\\<lambda>(l, r) s2. s2 = comp_converter l r) ===>\n        (=) ===>\n        rel_gpv (rel_prod (=) (\\<lambda>(l, r) s2. s2 = comp_converter l r))\n         (=))\n        (\\<lambda>(s2, s1) c2.\n            map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n             (inline run_converter (run_converter s2 c2) s1))\n        run_converter\n 2. \\<And>conv1 conv2 conv3 x.\n       rel_gpv (=) (=) (run_converter conv1 x) (run_converter conv1 x)\n 3. \\<And>conv1 conv2 conv3 x.\n       (case (conv2, conv3) of\n        (l, r) \\<Rightarrow> \\<lambda>s2. s2 = comp_converter l r)\n        (comp_converter conv2 conv3)\n 4. \\<And>conv1 conv2 conv3 x z1 y1.\n       \\<lbrakk>z1 \\<in> results'_gpv\n                          (inline\n                            (\\<lambda>(s2, s1) c2.\n                                map_gpv\n                                 (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                                 (inline run_converter (run_converter s2 c2)\n                                   s1))\n                            (run_converter conv1 x) (conv2, conv3));\n        y1 \\<in> results'_gpv\n                  (inline run_converter (run_converter conv1 x)\n                    (comp_converter conv2 conv3));\n        rel_prod (=) (\\<lambda>(l, r) s2. s2 = comp_converter l r) z1\n         y1\\<rbrakk>\n       \\<Longrightarrow> rel_prod (=)\n                          (\\<lambda>converter__ converter'__.\n                              \\<exists>conv1 conv2 conv3.\n                                 converter__ =\n                                 comp_converter (comp_converter conv1 conv2)\n                                  conv3 \\<and>\n                                 converter'__ =\n                                 comp_converter conv1\n                                  (comp_converter conv2 conv3))\n                          (case case z1 of\n                                (r, s2, xa) \\<Rightarrow> ((r, s2), xa) of\n                           (x, xa) \\<Rightarrow>\n                             ((\\<lambda>(b, conv1') conv2'.\n                                  (b, comp_converter conv1' conv2')) \\<circ>\n                              (\\<lambda>((b, conv1'), conv2').\n                                  (b, comp_converter conv1' conv2')))\n                              x xa)\n                          (case y1 of\n                           (x, xa) \\<Rightarrow>\n                             (case x of\n                              (b, conv1') \\<Rightarrow>\n                                \\<lambda>conv2'.\n                                   (b, comp_converter conv1' conv2'))\n                              xa)\n 5. \\<And>conv1 conv2 conv3 x z2 y2.\n       \\<lbrakk>z2 \\<in> outs'_gpv\n                          (inline\n                            (\\<lambda>(s2, s1) c2.\n                                map_gpv\n                                 (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                                 (inline run_converter (run_converter s2 c2)\n                                   s1))\n                            (run_converter conv1 x) (conv2, conv3));\n        y2 \\<in> outs'_gpv\n                  (inline run_converter (run_converter conv1 x)\n                    (comp_converter conv2 conv3));\n        z2 = y2\\<rbrakk>\n       \\<Longrightarrow> z2 = y2", "prefer 4"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>conv1 conv2 conv3 x z1 y1.\n       \\<lbrakk>z1 \\<in> results'_gpv\n                          (inline\n                            (\\<lambda>(s2, s1) c2.\n                                map_gpv\n                                 (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                                 (inline run_converter (run_converter s2 c2)\n                                   s1))\n                            (run_converter conv1 x) (conv2, conv3));\n        y1 \\<in> results'_gpv\n                  (inline run_converter (run_converter conv1 x)\n                    (comp_converter conv2 conv3));\n        rel_prod (=) (\\<lambda>(l, r) s2. s2 = comp_converter l r) z1\n         y1\\<rbrakk>\n       \\<Longrightarrow> rel_prod (=)\n                          (\\<lambda>converter__ converter'__.\n                              \\<exists>conv1 conv2 conv3.\n                                 converter__ =\n                                 comp_converter (comp_converter conv1 conv2)\n                                  conv3 \\<and>\n                                 converter'__ =\n                                 comp_converter conv1\n                                  (comp_converter conv2 conv3))\n                          (case case z1 of\n                                (r, s2, xa) \\<Rightarrow> ((r, s2), xa) of\n                           (x, xa) \\<Rightarrow>\n                             ((\\<lambda>(b, conv1') conv2'.\n                                  (b, comp_converter conv1' conv2')) \\<circ>\n                              (\\<lambda>((b, conv1'), conv2').\n                                  (b, comp_converter conv1' conv2')))\n                              x xa)\n                          (case y1 of\n                           (x, xa) \\<Rightarrow>\n                             (case x of\n                              (b, conv1') \\<Rightarrow>\n                                \\<lambda>conv2'.\n                                   (b, comp_converter conv1' conv2'))\n                              xa)\n 2. \\<And>conv1 conv2 conv3 x.\n       ((\\<lambda>(l, r) s2. s2 = comp_converter l r) ===>\n        (=) ===>\n        rel_gpv (rel_prod (=) (\\<lambda>(l, r) s2. s2 = comp_converter l r))\n         (=))\n        (\\<lambda>(s2, s1) c2.\n            map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n             (inline run_converter (run_converter s2 c2) s1))\n        run_converter\n 3. \\<And>conv1 conv2 conv3 x.\n       rel_gpv (=) (=) (run_converter conv1 x) (run_converter conv1 x)\n 4. \\<And>conv1 conv2 conv3 x.\n       (case (conv2, conv3) of\n        (l, r) \\<Rightarrow> \\<lambda>s2. s2 = comp_converter l r)\n        (comp_converter conv2 conv3)\n 5. \\<And>conv1 conv2 conv3 x z2 y2.\n       \\<lbrakk>z2 \\<in> outs'_gpv\n                          (inline\n                            (\\<lambda>(s2, s1) c2.\n                                map_gpv\n                                 (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                                 (inline run_converter (run_converter s2 c2)\n                                   s1))\n                            (run_converter conv1 x) (conv2, conv3));\n        y2 \\<in> outs'_gpv\n                  (inline run_converter (run_converter conv1 x)\n                    (comp_converter conv2 conv3));\n        z2 = y2\\<rbrakk>\n       \\<Longrightarrow> z2 = y2", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>conv1 conv2 conv3 x b aa ba ab.\n       \\<lbrakk>((ab, b), aa, ba)\n                \\<in> results'_gpv\n                       (inline\n                         (\\<lambda>(s2, s1) c2.\n                             map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1))\n                              id (inline run_converter (run_converter s2 c2)\n                                   s1))\n                         (run_converter conv1 x) (conv2, conv3));\n        ((ab, b), comp_converter aa ba)\n        \\<in> results'_gpv\n               (inline run_converter (run_converter conv1 x)\n                 (comp_converter conv2 conv3))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2 conv3.\n                            comp_converter (comp_converter b aa) ba =\n                            comp_converter (comp_converter conv1 conv2)\n                             conv3 \\<and>\n                            comp_converter b (comp_converter aa ba) =\n                            comp_converter conv1\n                             (comp_converter conv2 conv3)\n 2. \\<And>conv1 conv2 conv3 x.\n       ((\\<lambda>(l, r) s2. s2 = comp_converter l r) ===>\n        (=) ===>\n        rel_gpv (rel_prod (=) (\\<lambda>(l, r) s2. s2 = comp_converter l r))\n         (=))\n        (\\<lambda>(s2, s1) c2.\n            map_gpv (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n             (inline run_converter (run_converter s2 c2) s1))\n        run_converter\n 3. \\<And>conv1 conv2 conv3 x.\n       rel_gpv (=) (=) (run_converter conv1 x) (run_converter conv1 x)\n 4. \\<And>conv1 conv2 conv3 x.\n       (case (conv2, conv3) of\n        (l, r) \\<Rightarrow> \\<lambda>s2. s2 = comp_converter l r)\n        (comp_converter conv2 conv3)\n 5. \\<And>conv1 conv2 conv3 x z2 y2.\n       \\<lbrakk>z2 \\<in> outs'_gpv\n                          (inline\n                            (\\<lambda>(s2, s1) c2.\n                                map_gpv\n                                 (\\<lambda>((r, s2), s1). (r, s2, s1)) id\n                                 (inline run_converter (run_converter s2 c2)\n                                   s1))\n                            (run_converter conv1 x) (conv2, conv3));\n        y2 \\<in> outs'_gpv\n                  (inline run_converter (run_converter conv1 x)\n                    (comp_converter conv2 conv3));\n        z2 = y2\\<rbrakk>\n       \\<Longrightarrow> z2 = y2", "by(auto simp add: gpv.rel_eq gpv.rel_map split_beta intro!: rel_funI gpv.rel_refl_strong)"], ["", "lemma comp_converter_assoc_left:\n  assumes \"comp_converter conv1 conv2 = conv3\"\n  shows \"comp_converter conv1 (comp_converter conv2 conv) = comp_converter conv3 conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter conv1 (comp_converter conv2 conv) =\n    comp_converter conv3 conv", "by(fold comp_converter_assoc)(simp add: assms)"], ["", "lemma comp_converter_attach_left:\n  assumes \"comp_converter conv1 conv2 = conv3\"\n  shows \"attach conv1 (attach conv2 res) = attach conv3 res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach conv1 (attach conv2 res) = attach conv3 res", "by(fold attach_compose)(simp add: assms)"], ["", "lemmas comp_converter_eqs = \n  asm_rl[where psi=\"x = y\" for x y :: \"(_, _, _, _) converter\"]\n  comp_converter_assoc_left\n  comp_converter_attach_left"], ["", "lemma WT_converter_comp [WT_intro]:\n  \"\\<lbrakk> \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>; \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd> \\<rbrakk> \\<Longrightarrow> \\<I>, \\<I>'' \\<turnstile>\\<^sub>C comp_converter conv conv' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\\<rbrakk>\n    \\<Longrightarrow> \\<I>, \\<I>'' \\<turnstile>\\<^sub>C\n                      comp_converter conv conv' \\<surd>", "by(coinduction arbitrary: conv conv')\n    (auto; auto 4 4 dest: WT_converterD run_converter.results_gpv_inline intro: run_converter.WT_gpv_inline_invar[where \\<I>=\\<I>' and \\<I>'=\\<I>''])"], ["", "lemma plossless_comp_converter [plossless_intro]:\n  assumes \"plossless_converter \\<I> \\<I>' conv\"\n    and \"plossless_converter \\<I>' \\<I>'' conv'\"\n    and \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" \"\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\"\n  shows \"plossless_converter \\<I> \\<I>'' (comp_converter conv conv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>'' (comp_converter conv conv')", "using assms"], ["proof (prove)\nusing this:\n  plossless_converter \\<I> \\<I>' conv\n  plossless_converter \\<I>' \\<I>'' conv'\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\n\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>'' (comp_converter conv conv')", "proof(coinduction arbitrary: conv conv')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a conva conv'.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conva;\n        plossless_converter \\<I>' \\<I>'' conv';\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>''\n                          (run_converter (comp_converter conva conv')\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>''\n   (run_converter (comp_converter conva conv') a).\n                             (\\<exists>conv conv'a.\n                                 conv' = comp_converter conv conv'a \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 plossless_converter \\<I>' \\<I>''\n                                  conv'a \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>',\n                                 \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv'a \\<surd>) \\<or>\n                             plossless_converter \\<I> \\<I>'' conv')", "case (plossless_converter a conv conv')"], ["proof (state)\nthis:\n  plossless_converter \\<I> \\<I>' conv\n  plossless_converter \\<I>' \\<I>'' conv'\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>a conva conv'.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conva;\n        plossless_converter \\<I>' \\<I>'' conv';\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>''\n                          (run_converter (comp_converter conva conv')\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>''\n   (run_converter (comp_converter conva conv') a).\n                             (\\<exists>conv conv'a.\n                                 conv' = comp_converter conv conv'a \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 plossless_converter \\<I>' \\<I>''\n                                  conv'a \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>',\n                                 \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv'a \\<surd>) \\<or>\n                             plossless_converter \\<I> \\<I>'' conv')", "have conv1: \"plossless_gpv \\<I>' (run_converter conv a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (run_converter conv a)", "using plossless_converter(1, 5)"], ["proof (prove)\nusing this:\n  plossless_converter \\<I> \\<I>' conv\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>' (run_converter conv a)", "by(simp add: plossless_converterD)"], ["proof (state)\nthis:\n  plossless_gpv \\<I>' (run_converter conv a)\n\ngoal (1 subgoal):\n 1. \\<And>a conva conv'.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conva;\n        plossless_converter \\<I>' \\<I>'' conv';\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>''\n                          (run_converter (comp_converter conva conv')\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>''\n   (run_converter (comp_converter conva conv') a).\n                             (\\<exists>conv conv'a.\n                                 conv' = comp_converter conv conv'a \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 plossless_converter \\<I>' \\<I>''\n                                  conv'a \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>',\n                                 \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv'a \\<surd>) \\<or>\n                             plossless_converter \\<I> \\<I>'' conv')", "have conv2: \"\\<I>' \\<turnstile>g run_converter conv a \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g run_converter conv a \\<surd>", "using plossless_converter(3, 5)"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g run_converter conv a \\<surd>", "by(simp add: WT_converterD)"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g run_converter conv a \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>a conva conv'.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conva;\n        plossless_converter \\<I>' \\<I>'' conv';\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>''\n                          (run_converter (comp_converter conva conv')\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>''\n   (run_converter (comp_converter conva conv') a).\n                             (\\<exists>conv conv'a.\n                                 conv' = comp_converter conv conv'a \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 plossless_converter \\<I>' \\<I>''\n                                  conv'a \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>',\n                                 \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv'a \\<surd>) \\<or>\n                             plossless_converter \\<I> \\<I>'' conv')", "have ?plossless"], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>'' (run_converter (comp_converter conv conv') a)", "using plossless_converter(2,4,5)"], ["proof (prove)\nusing this:\n  plossless_converter \\<I>' \\<I>'' conv'\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>'' (run_converter (comp_converter conv conv') a)", "by(auto intro: run_plossless_converter.plossless_inline[OF conv1] dest: plossless_converterD intro: conv2)"], ["proof (state)\nthis:\n  plossless_gpv \\<I>'' (run_converter (comp_converter conv conv') a)\n\ngoal (1 subgoal):\n 1. \\<And>a conva conv'.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conva;\n        plossless_converter \\<I>' \\<I>'' conv';\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>''\n                          (run_converter (comp_converter conva conv')\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>''\n   (run_converter (comp_converter conva conv') a).\n                             (\\<exists>conv conv'a.\n                                 conv' = comp_converter conv conv'a \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 plossless_converter \\<I>' \\<I>''\n                                  conv'a \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>',\n                                 \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv'a \\<surd>) \\<or>\n                             plossless_converter \\<I> \\<I>'' conv')", "moreover"], ["proof (state)\nthis:\n  plossless_gpv \\<I>'' (run_converter (comp_converter conv conv') a)\n\ngoal (1 subgoal):\n 1. \\<And>a conva conv'.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conva;\n        plossless_converter \\<I>' \\<I>'' conv';\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>''\n                          (run_converter (comp_converter conva conv')\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>''\n   (run_converter (comp_converter conva conv') a).\n                             (\\<exists>conv conv'a.\n                                 conv' = comp_converter conv conv'a \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 plossless_converter \\<I>' \\<I>''\n                                  conv'a \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>',\n                                 \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv'a \\<surd>) \\<or>\n                             plossless_converter \\<I> \\<I>'' conv')", "have ?step (is \"\\<forall>(b, conv')\\<in>?res. ?P b conv' \\<or> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(b, conv')\n             \\<in>results_gpv \\<I>''\n                   (run_converter (comp_converter conv conv') a).\n       (\\<exists>conv conv'a.\n           conv' = comp_converter conv conv'a \\<and>\n           plossless_converter \\<I> \\<I>' conv \\<and>\n           plossless_converter \\<I>' \\<I>'' conv'a \\<and>\n           \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n           \\<I>'' \\<turnstile>\\<^sub>C conv'a \\<surd>) \\<or>\n       plossless_converter \\<I> \\<I>'' conv'", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>''\n                       (run_converter (comp_converter conv conv') a);\n        \\<not> plossless_converter \\<I> \\<I>'' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv conv'.\n                            b = comp_converter conv conv' \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            plossless_converter \\<I>' \\<I>'' conv' \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>',\n                            \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>", "fix b conv''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>''\n                       (run_converter (comp_converter conv conv') a);\n        \\<not> plossless_converter \\<I> \\<I>'' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv conv'.\n                            b = comp_converter conv conv' \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            plossless_converter \\<I>' \\<I>'' conv' \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>',\n                            \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>", "assume \"(b, conv'') \\<in> ?res\""], ["proof (state)\nthis:\n  (b, conv'')\n  \\<in> results_gpv \\<I>'' (run_converter (comp_converter conv conv') a)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>''\n                       (run_converter (comp_converter conv conv') a);\n        \\<not> plossless_converter \\<I> \\<I>'' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv conv'.\n                            b = comp_converter conv conv' \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            plossless_converter \\<I>' \\<I>'' conv' \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>',\n                            \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>", "then"], ["proof (chain)\npicking this:\n  (b, conv'')\n  \\<in> results_gpv \\<I>'' (run_converter (comp_converter conv conv') a)", "obtain conv1 conv2 where [simp]: \"conv'' = comp_converter conv1 conv2\" \n      and inline: \"((b, conv1), conv2) \\<in> results_gpv \\<I>'' (inline run_converter (run_converter conv a) conv')\""], ["proof (prove)\nusing this:\n  (b, conv'')\n  \\<in> results_gpv \\<I>'' (run_converter (comp_converter conv conv') a)\n\ngoal (1 subgoal):\n 1. (\\<And>conv1 conv2.\n        \\<lbrakk>conv'' = comp_converter conv1 conv2;\n         ((b, conv1), conv2)\n         \\<in> results_gpv \\<I>''\n                (inline run_converter (run_converter conv a) conv')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  conv'' = comp_converter conv1 conv2\n  ((b, conv1), conv2)\n  \\<in> results_gpv \\<I>''\n         (inline run_converter (run_converter conv a) conv')\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>''\n                       (run_converter (comp_converter conv conv') a);\n        \\<not> plossless_converter \\<I> \\<I>'' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv conv'.\n                            b = comp_converter conv conv' \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            plossless_converter \\<I>' \\<I>'' conv' \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>',\n                            \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>", "from run_plossless_converter.results_gpv_inline[OF inline conv2] plossless_converter(2,4)"], ["proof (chain)\npicking this:\n  plossless_converter \\<I>' \\<I>'' conv' \\<and> \\<I>',\n  \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd> \\<Longrightarrow>\n  (b, conv1) \\<in> results_gpv \\<I>' (run_converter conv a) \\<and>\n  plossless_converter \\<I>' \\<I>'' conv2 \\<and> \\<I>',\n  \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  plossless_converter \\<I>' \\<I>'' conv'\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>", "have run: \"(b, conv1) \\<in> results_gpv \\<I>' (run_converter conv a)\"\n      and *: \"plossless_converter \\<I>' \\<I>'' conv2\" \"\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\""], ["proof (prove)\nusing this:\n  plossless_converter \\<I>' \\<I>'' conv' \\<and> \\<I>',\n  \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd> \\<Longrightarrow>\n  (b, conv1) \\<in> results_gpv \\<I>' (run_converter conv a) \\<and>\n  plossless_converter \\<I>' \\<I>'' conv2 \\<and> \\<I>',\n  \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  plossless_converter \\<I>' \\<I>'' conv'\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\n\ngoal (1 subgoal):\n 1. (b, conv1) \\<in> results_gpv \\<I>' (run_converter conv a) &&&\n    plossless_converter \\<I>' \\<I>'' conv2 &&&\n    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>", "by auto"], ["proof (state)\nthis:\n  (b, conv1) \\<in> results_gpv \\<I>' (run_converter conv a)\n  plossless_converter \\<I>' \\<I>'' conv2\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>''\n                       (run_converter (comp_converter conv conv') a);\n        \\<not> plossless_converter \\<I> \\<I>'' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv conv'.\n                            b = comp_converter conv conv' \\<and>\n                            plossless_converter \\<I> \\<I>' conv \\<and>\n                            plossless_converter \\<I>' \\<I>'' conv' \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv \\<surd> \\<and> \\<I>',\n                            \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>", "with WT_converterD(2)[OF plossless_converter(3,5) run] plossless_converterD[THEN conjunct2, rule_format, OF plossless_converter(1,5) run]"], ["proof (chain)\npicking this:\n  b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n  conv1 \\<surd>\n  case (b, conv1) of (b, x) \\<Rightarrow> plossless_converter \\<I> \\<I>' x\n  (b, conv1) \\<in> results_gpv \\<I>' (run_converter conv a)\n  plossless_converter \\<I>' \\<I>'' conv2\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>", "show \"?P b conv''\""], ["proof (prove)\nusing this:\n  b \\<in> responses_\\<I> \\<I> a \\<and> \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n  conv1 \\<surd>\n  case (b, conv1) of (b, x) \\<Rightarrow> plossless_converter \\<I> \\<I>' x\n  (b, conv1) \\<in> results_gpv \\<I>' (run_converter conv a)\n  plossless_converter \\<I>' \\<I>'' conv2\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>conv conv'.\n       conv'' = comp_converter conv conv' \\<and>\n       plossless_converter \\<I> \\<I>' conv \\<and>\n       plossless_converter \\<I>' \\<I>'' conv' \\<and>\n       \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n       \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>", "by auto"], ["proof (state)\nthis:\n  \\<exists>conv conv'.\n     conv'' = comp_converter conv conv' \\<and>\n     plossless_converter \\<I> \\<I>' conv \\<and>\n     plossless_converter \\<I>' \\<I>'' conv' \\<and>\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n     \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>''\n                 (run_converter (comp_converter conv conv') a).\n     (\\<exists>conv conv'a.\n         conv' = comp_converter conv conv'a \\<and>\n         plossless_converter \\<I> \\<I>' conv \\<and>\n         plossless_converter \\<I>' \\<I>'' conv'a \\<and>\n         \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n         \\<I>'' \\<turnstile>\\<^sub>C conv'a \\<surd>) \\<or>\n     plossless_converter \\<I> \\<I>'' conv'\n\ngoal (1 subgoal):\n 1. \\<And>a conva conv'.\n       \\<lbrakk>plossless_converter \\<I> \\<I>' conva;\n        plossless_converter \\<I>' \\<I>'' conv';\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conva \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv' \\<surd>;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> plossless_gpv \\<I>''\n                          (run_converter (comp_converter conva conv')\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>''\n   (run_converter (comp_converter conva conv') a).\n                             (\\<exists>conv conv'a.\n                                 conv' = comp_converter conv conv'a \\<and>\n                                 plossless_converter \\<I> \\<I>' conv \\<and>\n                                 plossless_converter \\<I>' \\<I>''\n                                  conv'a \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>',\n                                 \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv'a \\<surd>) \\<or>\n                             plossless_converter \\<I> \\<I>'' conv')", "ultimately"], ["proof (chain)\npicking this:\n  plossless_gpv \\<I>'' (run_converter (comp_converter conv conv') a)\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>''\n                 (run_converter (comp_converter conv conv') a).\n     (\\<exists>conv conv'a.\n         conv' = comp_converter conv conv'a \\<and>\n         plossless_converter \\<I> \\<I>' conv \\<and>\n         plossless_converter \\<I>' \\<I>'' conv'a \\<and>\n         \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n         \\<I>'' \\<turnstile>\\<^sub>C conv'a \\<surd>) \\<or>\n     plossless_converter \\<I> \\<I>'' conv'", "show ?case"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I>'' (run_converter (comp_converter conv conv') a)\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>''\n                 (run_converter (comp_converter conv conv') a).\n     (\\<exists>conv conv'a.\n         conv' = comp_converter conv conv'a \\<and>\n         plossless_converter \\<I> \\<I>' conv \\<and>\n         plossless_converter \\<I>' \\<I>'' conv'a \\<and>\n         \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n         \\<I>'' \\<turnstile>\\<^sub>C conv'a \\<surd>) \\<or>\n     plossless_converter \\<I> \\<I>'' conv'\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I>''\n     (run_converter (comp_converter conv conv') a) \\<and>\n    (\\<forall>(b, conv')\n              \\<in>results_gpv \\<I>''\n                    (run_converter (comp_converter conv conv') a).\n        (\\<exists>conv conv'a.\n            conv' = comp_converter conv conv'a \\<and>\n            plossless_converter \\<I> \\<I>' conv \\<and>\n            plossless_converter \\<I>' \\<I>'' conv'a \\<and>\n            \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n            \\<I>'' \\<turnstile>\\<^sub>C conv'a \\<surd>) \\<or>\n        plossless_converter \\<I> \\<I>'' conv')", ".."], ["proof (state)\nthis:\n  plossless_gpv \\<I>'' (run_converter (comp_converter conv conv') a) \\<and>\n  (\\<forall>(b, conv')\n            \\<in>results_gpv \\<I>''\n                  (run_converter (comp_converter conv conv') a).\n      (\\<exists>conv conv'a.\n          conv' = comp_converter conv conv'a \\<and>\n          plossless_converter \\<I> \\<I>' conv \\<and>\n          plossless_converter \\<I>' \\<I>'' conv'a \\<and>\n          \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>',\n          \\<I>'' \\<turnstile>\\<^sub>C conv'a \\<surd>) \\<or>\n      plossless_converter \\<I> \\<I>'' conv')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_converter_id_left: \"comp_converter id_converter conv = conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter id_converter conv = conv", "by (coinduction arbitrary:conv)\n    (auto simp add: gpv.rel_map split_def map_gpv_conv_bind[symmetric]  intro!:rel_funI gpv.rel_refl_strong)"], ["", "lemma comp_converter_id_right: \"comp_converter conv id_converter = conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter conv id_converter = conv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comp_converter conv id_converter = conv", "have lem4: \"inline run_converter gpv id_converter = inline id_oracle gpv id_converter\" for gpv"], ["proof (prove)\ngoal (1 subgoal):\n 1. inline run_converter gpv id_converter =\n    inline id_oracle gpv id_converter", "by (simp only: gpv.rel_eq[symmetric])\n      (rule gpv.rel_mono_strong\n        , rule inline_parametric[where A=\"(=)\" and C=\"(=)\" and C'=\"(=)\" and S=\"\\<lambda>l r. l = r \\<and> r = id_converter\", THEN rel_funD, THEN rel_funD, THEN rel_funD]\n        , auto simp add: id_oracle_def intro!: rel_funI  gpv.rel_refl_strong)"], ["proof (state)\nthis:\n  inline run_converter ?gpv1 id_converter =\n  inline id_oracle ?gpv1 id_converter\n\ngoal (1 subgoal):\n 1. comp_converter conv id_converter = conv", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter conv id_converter = conv", "by (coinduction arbitrary:conv)\n      (auto simp add: lem4 gpv.rel_map intro!:rel_funI gpv.rel_refl_strong)"], ["proof (state)\nthis:\n  comp_converter conv id_converter = conv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_coverter_of_callee: \"comp_converter (converter_of_callee callee1 s1) (converter_of_callee callee2 s2)\n  = converter_of_callee (\\<lambda>(s1, s2) q. map_gpv rprodl id (inline callee2 (callee1 s1 q) s2)) (s1, s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter (converter_of_callee callee1 s1)\n     (converter_of_callee callee2 s2) =\n    converter_of_callee\n     (\\<lambda>(s1, s2) q.\n         map_gpv rprodl id (inline callee2 (callee1 s1 q) s2))\n     (s1, s2)", "apply (coinduction arbitrary: callee1 s1 callee2 s2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee1 s1 callee2 s2.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>callee1 s1 callee2 s2.\n                   converter__ =\n                   comp_converter (converter_of_callee callee1 s1)\n                    (converter_of_callee callee2 s2) \\<and>\n                   converter'__ =\n                   converter_of_callee\n                    (\\<lambda>(s1, s2) q.\n                        map_gpv rprodl id\n                         (inline callee2 (callee1 s1 q) s2))\n                    (s1, s2)))\n          (=))\n        (run_converter\n          (comp_converter (converter_of_callee callee1 s1)\n            (converter_of_callee callee2 s2)))\n        (run_converter\n          (converter_of_callee\n            (\\<lambda>(s1, s2) q.\n                map_gpv rprodl id (inline callee2 (callee1 s1 q) s2))\n            (s1, s2)))", "apply (rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee1 s1 callee2 s2 x y.\n       x = y \\<Longrightarrow>\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee1 s1 callee2 s2.\n                 converter__ =\n                 comp_converter (converter_of_callee callee1 s1)\n                  (converter_of_callee callee2 s2) \\<and>\n                 converter'__ =\n                 converter_of_callee\n                  (\\<lambda>(s1, s2) q.\n                      map_gpv rprodl id (inline callee2 (callee1 s1 q) s2))\n                  (s1, s2)))\n        (=)\n        (run_converter\n          (comp_converter (converter_of_callee callee1 s1)\n            (converter_of_callee callee2 s2))\n          x)\n        (run_converter\n          (converter_of_callee\n            (\\<lambda>(s1, s2) q.\n                map_gpv rprodl id (inline callee2 (callee1 s1 q) s2))\n            (s1, s2))\n          y)", "apply (clarsimp simp add: gpv.rel_map inline_map_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee1 s1 callee2 s2 x.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>callee1 s1 callee2 s2.\n                    converter__ =\n                    comp_converter (converter_of_callee callee1 s1)\n                     (converter_of_callee callee2 s2) \\<and>\n                    converter'__ =\n                    converter_of_callee\n                     (\\<lambda>(s1, s2) q.\n                         map_gpv rprodl id\n                          (inline callee2 (callee1 s1 q) s2))\n                     (s1, s2))\n             (case x of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 map_prod id (converter_of_callee callee1))\n                 x xa)\n             (map_prod id\n               (converter_of_callee\n                 (\\<lambda>(s1, s2) q.\n                     map_gpv rprodl id (inline callee2 (callee1 s1 q) s2)))\n               (rprodl y)))\n        (=)\n        (inline run_converter (callee1 s1 x)\n          (converter_of_callee callee2 s2))\n        (inline callee2 (callee1 s1 x) s2)", "subgoal for cal1 s1 cal2 s2 y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee1 s1 callee2 s2.\n                 converter__ =\n                 comp_converter (converter_of_callee callee1 s1)\n                  (converter_of_callee callee2 s2) \\<and>\n                 converter'__ =\n                 converter_of_callee\n                  (\\<lambda>(s1, s2) q.\n                      map_gpv rprodl id (inline callee2 (callee1 s1 q) s2))\n                  (s1, s2))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod id (converter_of_callee cal1))\n              x xa)\n          (map_prod id\n            (converter_of_callee\n              (\\<lambda>(s1, s2) q.\n                  map_gpv rprodl id (inline cal2 (cal1 s1 q) s2)))\n            (rprodl y)))\n     (=) (inline run_converter (cal1 s1 y) (converter_of_callee cal2 s2))\n     (inline cal2 (cal1 s1 y) s2)", "apply (rule gpv.rel_mono_strong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rel_gpv ?R1.0 ?R2.0\n     (inline run_converter (cal1 s1 y) (converter_of_callee cal2 s2))\n     (inline cal2 (cal1 s1 y) s2)\n 2. \\<And>z1 y1.\n       \\<lbrakk>z1 \\<in> results'_gpv\n                          (inline run_converter (cal1 s1 y)\n                            (converter_of_callee cal2 s2));\n        y1 \\<in> results'_gpv (inline cal2 (cal1 s1 y) s2);\n        ?R1.0 z1 y1\\<rbrakk>\n       \\<Longrightarrow> rel_prod (=)\n                          (\\<lambda>converter__ converter'__.\n                              \\<exists>callee1 s1 callee2 s2.\n                                 converter__ =\n                                 comp_converter\n                                  (converter_of_callee callee1 s1)\n                                  (converter_of_callee callee2 s2) \\<and>\n                                 converter'__ =\n                                 converter_of_callee\n                                  (\\<lambda>(s1, s2) q.\nmap_gpv rprodl id (inline callee2 (callee1 s1 q) s2))\n                                  (s1, s2))\n                          (case z1 of\n                           (x, xa) \\<Rightarrow>\n                             ((\\<lambda>(b, conv1') conv2'.\n                                  (b, comp_converter conv1' conv2')) \\<circ>\n                              map_prod id (converter_of_callee cal1))\n                              x xa)\n                          (map_prod id\n                            (converter_of_callee\n                              (\\<lambda>(s1, s2) q.\n                                  map_gpv rprodl id\n                                   (inline cal2 (cal1 s1 q) s2)))\n                            (rprodl y1))\n 3. \\<And>z2 y2.\n       \\<lbrakk>z2 \\<in> outs'_gpv\n                          (inline run_converter (cal1 s1 y)\n                            (converter_of_callee cal2 s2));\n        y2 \\<in> outs'_gpv (inline cal2 (cal1 s1 y) s2);\n        ?R2.0 z2 y2\\<rbrakk>\n       \\<Longrightarrow> z2 = y2", "apply (rule inline_parametric[where A=\"(=)\" and C=\"(=)\" and C'=\"(=)\" and S=\"\\<lambda>c s. c = converter_of_callee cal2 s\", THEN rel_funD, THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (5 subgoals):\n 1. rel_fun (\\<lambda>c s. c = converter_of_callee cal2 s)\n     (rel_fun (=)\n       (rel_gpv\n         (rel_prod (=) (\\<lambda>c s. c = converter_of_callee cal2 s)) (=)))\n     run_converter cal2\n 2. rel_gpv (=) (=) (cal1 s1 y) (cal1 s1 y)\n 3. converter_of_callee cal2 s2 = converter_of_callee cal2 s2\n 4. \\<And>z1 y1.\n       \\<lbrakk>z1 \\<in> results'_gpv\n                          (inline run_converter (cal1 s1 y)\n                            (converter_of_callee cal2 s2));\n        y1 \\<in> results'_gpv (inline cal2 (cal1 s1 y) s2);\n        rel_prod (=) (\\<lambda>c s. c = converter_of_callee cal2 s) z1\n         y1\\<rbrakk>\n       \\<Longrightarrow> rel_prod (=)\n                          (\\<lambda>converter__ converter'__.\n                              \\<exists>callee1 s1 callee2 s2.\n                                 converter__ =\n                                 comp_converter\n                                  (converter_of_callee callee1 s1)\n                                  (converter_of_callee callee2 s2) \\<and>\n                                 converter'__ =\n                                 converter_of_callee\n                                  (\\<lambda>(s1, s2) q.\nmap_gpv rprodl id (inline callee2 (callee1 s1 q) s2))\n                                  (s1, s2))\n                          (case z1 of\n                           (x, xa) \\<Rightarrow>\n                             ((\\<lambda>(b, conv1') conv2'.\n                                  (b, comp_converter conv1' conv2')) \\<circ>\n                              map_prod id (converter_of_callee cal1))\n                              x xa)\n                          (map_prod id\n                            (converter_of_callee\n                              (\\<lambda>(s1, s2) q.\n                                  map_gpv rprodl id\n                                   (inline cal2 (cal1 s1 q) s2)))\n                            (rprodl y1))\n 5. \\<And>z2 y2.\n       \\<lbrakk>z2 \\<in> outs'_gpv\n                          (inline run_converter (cal1 s1 y)\n                            (converter_of_callee cal2 s2));\n        y2 \\<in> outs'_gpv (inline cal2 (cal1 s1 y) s2); z2 = y2\\<rbrakk>\n       \\<Longrightarrow> z2 = y2", "apply(auto simp add: gpv.rel_eq rel_fun_def gpv.rel_map intro!: gpv.rel_refl_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b bb.\n       \\<lbrakk>((a, b), converter_of_callee cal2 bb)\n                \\<in> results'_gpv\n                       (inline run_converter (cal1 s1 y)\n                         (converter_of_callee cal2 s2));\n        ((a, b), bb)\n        \\<in> results'_gpv (inline cal2 (cal1 s1 y) s2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>callee1 s1 callee2 s2.\n                            comp_converter (converter_of_callee cal1 b)\n                             (converter_of_callee cal2 bb) =\n                            comp_converter (converter_of_callee callee1 s1)\n                             (converter_of_callee callee2 s2) \\<and>\n                            converter_of_callee\n                             (\\<lambda>(s1, s2) q.\n                                 map_gpv rprodl id\n                                  (inline cal2 (cal1 s1 q) s2))\n                             (b, bb) =\n                            converter_of_callee\n                             (\\<lambda>(s1, s2) q.\n                                 map_gpv rprodl id\n                                  (inline callee2 (callee1 s1 q) s2))\n                             (s1, s2)", "by (auto simp add: rprodl_def intro!:exI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas comp_converter_of_callee' = comp_converter_eqs[OF comp_coverter_of_callee]"], ["", "lemma comp_converter_parallel2: \"comp_converter (parallel_converter2 conv1l conv1r) (parallel_converter2 conv2l conv2r) =\n  parallel_converter2 (comp_converter conv1l conv2l) (comp_converter conv1r conv2r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter (parallel_converter2 conv1l conv1r)\n     (parallel_converter2 conv2l conv2r) =\n    parallel_converter2 (comp_converter conv1l conv2l)\n     (comp_converter conv1r conv2r)", "apply (coinduction arbitrary: conv1l conv1r conv2l conv2r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1l conv1r conv2l conv2r.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>conv1l conv1r conv2l conv2r.\n                   converter__ =\n                   comp_converter (parallel_converter2 conv1l conv1r)\n                    (parallel_converter2 conv2l conv2r) \\<and>\n                   converter'__ =\n                   parallel_converter2 (comp_converter conv1l conv2l)\n                    (comp_converter conv1r conv2r)))\n          (=))\n        (run_converter\n          (comp_converter (parallel_converter2 conv1l conv1r)\n            (parallel_converter2 conv2l conv2r)))\n        (run_converter\n          (parallel_converter2 (comp_converter conv1l conv2l)\n            (comp_converter conv1r conv2r)))", "apply (rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1l conv1r conv2l conv2r x y.\n       x = y \\<Longrightarrow>\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r)))\n        (=)\n        (run_converter\n          (comp_converter (parallel_converter2 conv1l conv1r)\n            (parallel_converter2 conv2l conv2r))\n          x)\n        (run_converter\n          (parallel_converter2 (comp_converter conv1l conv2l)\n            (comp_converter conv1r conv2r))\n          y)", "apply (clarsimp simp add: gpv.rel_map inline_map_gpv split!: sum.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conv1l conv1r conv2l conv2r x1.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv1l conv1r conv2l conv2r.\n                    converter__ =\n                    comp_converter (parallel_converter2 conv1l conv1r)\n                     (parallel_converter2 conv2l conv2r) \\<and>\n                    converter'__ =\n                    parallel_converter2 (comp_converter conv1l conv2l)\n                     (comp_converter conv1r conv2r))\n             (case x of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 map_prod Inl\n                  (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n                 x xa)\n             (map_prod Inl\n               (\\<lambda>conv1'.\n                   parallel_converter2 conv1'\n                    (comp_converter conv1r conv2r))\n               y))\n        (=)\n        (inline run_converter (left_gpv (run_converter conv1l x1))\n          (parallel_converter2 conv2l conv2r))\n        (left_gpv\n          (map_gpv\n            (\\<lambda>((b, conv1'), conv2').\n                (b, comp_converter conv1' conv2'))\n            id (inline run_converter (run_converter conv1l x1) conv2l)))\n 2. \\<And>conv1l conv1r conv2l conv2r x2.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv1l conv1r conv2l conv2r.\n                    converter__ =\n                    comp_converter (parallel_converter2 conv1l conv1r)\n                     (parallel_converter2 conv2l conv2r) \\<and>\n                    converter'__ =\n                    parallel_converter2 (comp_converter conv1l conv2l)\n                     (comp_converter conv1r conv2r))\n             (case x of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 map_prod Inr (parallel_converter2 conv1l))\n                 x xa)\n             (map_prod Inr\n               (parallel_converter2 (comp_converter conv1l conv2l)) y))\n        (=)\n        (inline run_converter (right_gpv (run_converter conv1r x2))\n          (parallel_converter2 conv2l conv2r))\n        (right_gpv\n          (map_gpv\n            (\\<lambda>((b, conv1'), conv2').\n                (b, comp_converter conv1' conv2'))\n            id (inline run_converter (run_converter conv1r x2) conv2r)))", "subgoal for conv1l conv1r conv2l conv2r input"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inl\n               (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n              x xa)\n          (map_prod Inl\n            (\\<lambda>conv1'.\n                parallel_converter2 conv1' (comp_converter conv1r conv2r))\n            y))\n     (=)\n     (inline run_converter (left_gpv (run_converter conv1l input))\n       (parallel_converter2 conv2l conv2r))\n     (left_gpv\n       (map_gpv\n         (\\<lambda>((b, conv1'), conv2'). (b, comp_converter conv1' conv2'))\n         id (inline run_converter (run_converter conv1l input) conv2l)))", "apply(subst left_gpv_map[where h=id])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inl\n               (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n              x xa)\n          (map_prod Inl\n            (\\<lambda>conv1'.\n                parallel_converter2 conv1' (comp_converter conv1r conv2r))\n            y))\n     (=)\n     (inline run_converter (left_gpv (run_converter conv1l input))\n       (parallel_converter2 conv2l conv2r))\n     (map_gpv\n       (\\<lambda>((b, conv1'), conv2'). (b, comp_converter conv1' conv2'))\n       (map_sum id id)\n       (left_gpv\n         (inline run_converter (run_converter conv1l input) conv2l)))", "apply(simp add: gpv.rel_map left_gpv_inline)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inl\n               (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n              x xa)\n          (map_prod Inl\n            (\\<lambda>conv1'.\n                parallel_converter2 conv1' (comp_converter conv1r conv2r))\n            (case y of\n             (x, xa) \\<Rightarrow>\n               (case x of\n                (b, conv1') \\<Rightarrow>\n                  \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                xa)))\n     (\\<lambda>x y. x = map_sum id id y)\n     (inline run_converter (left_gpv (run_converter conv1l input))\n       (parallel_converter2 conv2l conv2r))\n     (inline (\\<lambda>s q. left_gpv (run_converter s q))\n       (run_converter conv1l input) conv2l)", "apply(unfold rel_gpv_conv_rel_gpv'')"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv''\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inl\n               (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n              x xa)\n          (map_prod Inl\n            (\\<lambda>conv1'.\n                parallel_converter2 conv1' (comp_converter conv1r conv2r))\n            (case y of\n             (x, xa) \\<Rightarrow>\n               (case x of\n                (b, conv1') \\<Rightarrow>\n                  \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                xa)))\n     (\\<lambda>x y. x = map_sum id id y) (=)\n     (inline run_converter (left_gpv (run_converter conv1l input))\n       (parallel_converter2 conv2l conv2r))\n     (inline (\\<lambda>s q. left_gpv (run_converter s q))\n       (run_converter conv1l input) conv2l)", "apply(rule rel_gpv''_mono[THEN predicate2D, rotated -1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. rel_gpv'' ?A1 ?C1 ?R1\n     (inline run_converter (left_gpv (run_converter conv1l input))\n       (parallel_converter2 conv2l conv2r))\n     (inline (\\<lambda>s q. left_gpv (run_converter s q))\n       (run_converter conv1l input) conv2l)\n 2. ?A1\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inl\n                    (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n                   x xa)\n               (map_prod Inl\n                 (\\<lambda>conv1'.\n                     parallel_converter2 conv1'\n                      (comp_converter conv1r conv2r))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 3. ?C1 \\<le> (\\<lambda>x y. x = map_sum id id y)\n 4. (=) \\<le> ?R1", "apply(rule inline_parametric'[where S=\"\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r\" and C=\"\\<lambda>l r. l = Inl r\" and R=\"\\<lambda>l r. l = Inl r\" and C' = \"(=)\" and R'=\"(=)\",\n          THEN rel_funD, THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (6 subgoals):\n 1. rel_fun (\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r)\n     (rel_fun (\\<lambda>l r. l = Inl r)\n       (rel_gpv''\n         (rel_prod (\\<lambda>l r. l = Inl r)\n           (\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r))\n         (=) (=)))\n     run_converter (\\<lambda>s q. left_gpv (run_converter s q))\n 2. rel_gpv'' ?A9 (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r)\n     (left_gpv (run_converter conv1l input)) (run_converter conv1l input)\n 3. parallel_converter2 conv2l conv2r = parallel_converter2 conv2l conv2r\n 4. rel_prod ?A9 (\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r)\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inl\n                    (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n                   x xa)\n               (map_prod Inl\n                 (\\<lambda>conv1'.\n                     parallel_converter2 conv1'\n                      (comp_converter conv1r conv2r))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 5. (=) \\<le> (\\<lambda>x y. x = map_sum id id y)\n 6. (=) \\<le> (=)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r)\n     (rel_fun (\\<lambda>l r. l = Inl r)\n       (rel_gpv''\n         (rel_prod (\\<lambda>l r. l = Inl r)\n           (\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r))\n         (=) (=)))\n     run_converter (\\<lambda>s q. left_gpv (run_converter s q))", "by(auto split: sum.split simp add: gpv.rel_map rel_gpv_conv_rel_gpv''[symmetric] intro!:  gpv.rel_refl_strong rel_funI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. rel_gpv'' ?A9 (\\<lambda>l r. l = Inl r) (\\<lambda>l r. l = Inl r)\n     (left_gpv (run_converter conv1l input)) (run_converter conv1l input)\n 2. parallel_converter2 conv2l conv2r = parallel_converter2 conv2l conv2r\n 3. rel_prod ?A9 (\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r)\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inl\n                    (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n                   x xa)\n               (map_prod Inl\n                 (\\<lambda>conv1'.\n                     parallel_converter2 conv1'\n                      (comp_converter conv1r conv2r))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 4. (=) \\<le> (\\<lambda>x y. x = map_sum id id y)\n 5. (=) \\<le> (=)", "apply(rule left_gpv_Inl_transfer)"], ["proof (prove)\ngoal (4 subgoals):\n 1. parallel_converter2 conv2l conv2r = parallel_converter2 conv2l conv2r\n 2. rel_prod (=) (\\<lambda>c1 c2. c1 = parallel_converter2 c2 conv2r)\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inl\n                    (\\<lambda>conv1'. parallel_converter2 conv1' conv1r))\n                   x xa)\n               (map_prod Inl\n                 (\\<lambda>conv1'.\n                     parallel_converter2 conv1'\n                      (comp_converter conv1r conv2r))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 3. (=) \\<le> (\\<lambda>x y. x = map_sum id id y)\n 4. (=) \\<le> (=)", "apply(auto 4 6 simp add: sum.map_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conv1l conv1r conv2l conv2r x2.\n       rel_gpv\n        (\\<lambda>x y.\n            rel_prod (=)\n             (\\<lambda>converter__ converter'__.\n                 \\<exists>conv1l conv1r conv2l conv2r.\n                    converter__ =\n                    comp_converter (parallel_converter2 conv1l conv1r)\n                     (parallel_converter2 conv2l conv2r) \\<and>\n                    converter'__ =\n                    parallel_converter2 (comp_converter conv1l conv2l)\n                     (comp_converter conv1r conv2r))\n             (case x of\n              (x, xa) \\<Rightarrow>\n                ((\\<lambda>(b, conv1') conv2'.\n                     (b, comp_converter conv1' conv2')) \\<circ>\n                 map_prod Inr (parallel_converter2 conv1l))\n                 x xa)\n             (map_prod Inr\n               (parallel_converter2 (comp_converter conv1l conv2l)) y))\n        (=)\n        (inline run_converter (right_gpv (run_converter conv1r x2))\n          (parallel_converter2 conv2l conv2r))\n        (right_gpv\n          (map_gpv\n            (\\<lambda>((b, conv1'), conv2').\n                (b, comp_converter conv1' conv2'))\n            id (inline run_converter (run_converter conv1r x2) conv2r)))", "subgoal for conv1l conv1r conv2l conv2r input"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inr (parallel_converter2 conv1l))\n              x xa)\n          (map_prod Inr (parallel_converter2 (comp_converter conv1l conv2l))\n            y))\n     (=)\n     (inline run_converter (right_gpv (run_converter conv1r input))\n       (parallel_converter2 conv2l conv2r))\n     (right_gpv\n       (map_gpv\n         (\\<lambda>((b, conv1'), conv2'). (b, comp_converter conv1' conv2'))\n         id (inline run_converter (run_converter conv1r input) conv2r)))", "apply(subst right_gpv_map[where h=id])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inr (parallel_converter2 conv1l))\n              x xa)\n          (map_prod Inr (parallel_converter2 (comp_converter conv1l conv2l))\n            y))\n     (=)\n     (inline run_converter (right_gpv (run_converter conv1r input))\n       (parallel_converter2 conv2l conv2r))\n     (map_gpv\n       (\\<lambda>((b, conv1'), conv2'). (b, comp_converter conv1' conv2'))\n       (map_sum id id)\n       (right_gpv\n         (inline run_converter (run_converter conv1r input) conv2r)))", "apply(simp add: gpv.rel_map right_gpv_inline)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inr (parallel_converter2 conv1l))\n              x xa)\n          (map_prod Inr (parallel_converter2 (comp_converter conv1l conv2l))\n            (case y of\n             (x, xa) \\<Rightarrow>\n               (case x of\n                (b, conv1') \\<Rightarrow>\n                  \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                xa)))\n     (\\<lambda>x y. x = map_sum id id y)\n     (inline run_converter (right_gpv (run_converter conv1r input))\n       (parallel_converter2 conv2l conv2r))\n     (inline (\\<lambda>s q. right_gpv (run_converter s q))\n       (run_converter conv1r input) conv2r)", "apply(unfold rel_gpv_conv_rel_gpv'')"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv''\n     (\\<lambda>x y.\n         rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>conv1l conv1r conv2l conv2r.\n                 converter__ =\n                 comp_converter (parallel_converter2 conv1l conv1r)\n                  (parallel_converter2 conv2l conv2r) \\<and>\n                 converter'__ =\n                 parallel_converter2 (comp_converter conv1l conv2l)\n                  (comp_converter conv1r conv2r))\n          (case x of\n           (x, xa) \\<Rightarrow>\n             ((\\<lambda>(b, conv1') conv2'.\n                  (b, comp_converter conv1' conv2')) \\<circ>\n              map_prod Inr (parallel_converter2 conv1l))\n              x xa)\n          (map_prod Inr (parallel_converter2 (comp_converter conv1l conv2l))\n            (case y of\n             (x, xa) \\<Rightarrow>\n               (case x of\n                (b, conv1') \\<Rightarrow>\n                  \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                xa)))\n     (\\<lambda>x y. x = map_sum id id y) (=)\n     (inline run_converter (right_gpv (run_converter conv1r input))\n       (parallel_converter2 conv2l conv2r))\n     (inline (\\<lambda>s q. right_gpv (run_converter s q))\n       (run_converter conv1r input) conv2r)", "apply(rule rel_gpv''_mono[THEN predicate2D, rotated -1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. rel_gpv'' ?A1 ?C1 ?R1\n     (inline run_converter (right_gpv (run_converter conv1r input))\n       (parallel_converter2 conv2l conv2r))\n     (inline (\\<lambda>s q. right_gpv (run_converter s q))\n       (run_converter conv1r input) conv2r)\n 2. ?A1\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inr (parallel_converter2 conv1l))\n                   x xa)\n               (map_prod Inr\n                 (parallel_converter2 (comp_converter conv1l conv2l))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 3. ?C1 \\<le> (\\<lambda>x y. x = map_sum id id y)\n 4. (=) \\<le> ?R1", "apply(rule inline_parametric'[where S=\"\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2\" and C=\"\\<lambda>l r. l = Inr r\" and R=\"\\<lambda>l r. l = Inr r\" and C' = \"(=)\" and R'=\"(=)\",\n          THEN rel_funD, THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (6 subgoals):\n 1. rel_fun (\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2)\n     (rel_fun (\\<lambda>l r. l = Inr r)\n       (rel_gpv''\n         (rel_prod (\\<lambda>l r. l = Inr r)\n           (\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2))\n         (=) (=)))\n     run_converter (\\<lambda>s q. right_gpv (run_converter s q))\n 2. rel_gpv'' ?A9 (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r)\n     (right_gpv (run_converter conv1r input)) (run_converter conv1r input)\n 3. parallel_converter2 conv2l conv2r = parallel_converter2 conv2l conv2r\n 4. rel_prod ?A9 (\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2)\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inr (parallel_converter2 conv1l))\n                   x xa)\n               (map_prod Inr\n                 (parallel_converter2 (comp_converter conv1l conv2l))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 5. (=) \\<le> (\\<lambda>x y. x = map_sum id id y)\n 6. (=) \\<le> (=)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2)\n     (rel_fun (\\<lambda>l r. l = Inr r)\n       (rel_gpv''\n         (rel_prod (\\<lambda>l r. l = Inr r)\n           (\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2))\n         (=) (=)))\n     run_converter (\\<lambda>s q. right_gpv (run_converter s q))", "by(auto split: sum.split simp add: gpv.rel_map rel_gpv_conv_rel_gpv''[symmetric] intro!:  gpv.rel_refl_strong rel_funI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. rel_gpv'' ?A9 (\\<lambda>l r. l = Inr r) (\\<lambda>l r. l = Inr r)\n     (right_gpv (run_converter conv1r input)) (run_converter conv1r input)\n 2. parallel_converter2 conv2l conv2r = parallel_converter2 conv2l conv2r\n 3. rel_prod ?A9 (\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2)\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inr (parallel_converter2 conv1l))\n                   x xa)\n               (map_prod Inr\n                 (parallel_converter2 (comp_converter conv1l conv2l))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 4. (=) \\<le> (\\<lambda>x y. x = map_sum id id y)\n 5. (=) \\<le> (=)", "apply(rule right_gpv_Inr_transfer)"], ["proof (prove)\ngoal (4 subgoals):\n 1. parallel_converter2 conv2l conv2r = parallel_converter2 conv2l conv2r\n 2. rel_prod (=) (\\<lambda>c1 c2. c1 = parallel_converter2 conv2l c2)\n    \\<le> (\\<lambda>x y.\n              rel_prod (=)\n               (\\<lambda>converter__ converter'__.\n                   \\<exists>conv1l conv1r conv2l conv2r.\n                      converter__ =\n                      comp_converter (parallel_converter2 conv1l conv1r)\n                       (parallel_converter2 conv2l conv2r) \\<and>\n                      converter'__ =\n                      parallel_converter2 (comp_converter conv1l conv2l)\n                       (comp_converter conv1r conv2r))\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  ((\\<lambda>(b, conv1') conv2'.\n                       (b, comp_converter conv1' conv2')) \\<circ>\n                   map_prod Inr (parallel_converter2 conv1l))\n                   x xa)\n               (map_prod Inr\n                 (parallel_converter2 (comp_converter conv1l conv2l))\n                 (case y of\n                  (x, xa) \\<Rightarrow>\n                    (case x of\n                     (b, conv1') \\<Rightarrow>\n                       \\<lambda>conv2'. (b, comp_converter conv1' conv2'))\n                     xa)))\n 3. (=) \\<le> (\\<lambda>x y. x = map_sum id id y)\n 4. (=) \\<le> (=)", "apply(auto 4 6 simp add: sum.map_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas comp_converter_parallel2' = comp_converter_eqs[OF comp_converter_parallel2]"], ["", "lemma comp_converter_map1_out:\n  \"comp_converter (map_converter f g id id conv) conv' = map_converter f g id id (comp_converter conv conv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_converter (map_converter f g id id conv) conv' =\n    map_converter f g id id (comp_converter conv conv')", "by(simp add: comp_converter_map_converter1)"], ["", "lemma parallel_converter2_comp1_out:\n  \"parallel_converter2 (comp_converter conv conv') conv'' = comp_converter (parallel_converter2 conv id_converter) (parallel_converter2 conv' conv'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_converter2 (comp_converter conv conv') conv'' =\n    comp_converter (parallel_converter2 conv id_converter)\n     (parallel_converter2 conv' conv'')", "by(simp add: comp_converter_parallel2 comp_converter_id_left)"], ["", "lemma parallel_converter2_comp2_out:\n  \"parallel_converter2 conv'' (comp_converter conv conv') = comp_converter (parallel_converter2 id_converter conv) (parallel_converter2 conv'' conv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_converter2 conv'' (comp_converter conv conv') =\n    comp_converter (parallel_converter2 id_converter conv)\n     (parallel_converter2 conv'' conv')", "by(simp add: comp_converter_parallel2 comp_converter_id_left)"], ["", "subsection \\<open>Interaction bound\\<close>"], ["", "coinductive interaction_any_bounded_converter :: \"('a, 'b, 'c, 'd) converter \\<Rightarrow> enat \\<Rightarrow> bool\" where\n  \"interaction_any_bounded_converter conv n\" if\n  \"\\<And>a. interaction_any_bounded_by (run_converter conv a) n\"\n  \"\\<And>a b conv'. (b, conv') \\<in> results'_gpv (run_converter conv a) \\<Longrightarrow> interaction_any_bounded_converter conv' n\""], ["", "lemma interaction_any_bounded_converterD:\n  assumes \"interaction_any_bounded_converter conv n\"\n  shows \"interaction_any_bounded_by (run_converter conv a) n \\<and> (\\<forall>(b, conv')\\<in>results'_gpv (run_converter conv a). interaction_any_bounded_converter conv' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_by (run_converter conv a) n \\<and>\n    (\\<forall>(b, conv')\\<in>results'_gpv (run_converter conv a).\n        interaction_any_bounded_converter conv' n)", "using assms"], ["proof (prove)\nusing this:\n  interaction_any_bounded_converter conv n\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_by (run_converter conv a) n \\<and>\n    (\\<forall>(b, conv')\\<in>results'_gpv (run_converter conv a).\n        interaction_any_bounded_converter conv' n)", "by(auto elim: interaction_any_bounded_converter.cases)"], ["", "lemma interaction_any_bounded_converter_mono:\n  assumes \"interaction_any_bounded_converter conv n\"\n    and \"n \\<le> m\"\n  shows \"interaction_any_bounded_converter conv m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter conv m", "using assms"], ["proof (prove)\nusing this:\n  interaction_any_bounded_converter conv n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter conv m", "by(coinduction arbitrary: conv)(auto elim: interaction_any_bounded_converter.cases intro: interaction_bounded_by_mono)"], ["", "lemma interaction_any_bounded_converter_trivial [simp]: \"interaction_any_bounded_converter conv \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter conv \\<infinity>", "by(coinduction arbitrary: conv)\n    (auto simp add: interaction_bounded_by.simps)"], ["", "lemmas interaction_any_bounded_converter_start = \n  interaction_any_bounded_converter_mono\n  interaction_bounded_by_mono"], ["", "method interaction_bound_converter_start = (rule interaction_any_bounded_converter_start)"], ["", "method interaction_bound_converter_step uses add simp =\n  ((match conclusion in \"interaction_bounded_by _ _ _\" \\<Rightarrow> fail \\<bar> \"interaction_any_bounded_converter _ _\" \\<Rightarrow> fail \\<bar> _ \\<Rightarrow> \\<open>solves \\<open>clarsimp simp add: simp\\<close>\\<close>) | rule add interaction_bound)"], ["", "method interaction_bound_converter_rec uses add simp = \n  (interaction_bound_converter_step add: add simp: simp; (interaction_bound_converter_rec add: add simp: simp)?)"], ["", "method interaction_bound_converter uses add simp =\n  ((* use in *) interaction_bound_converter_start, interaction_bound_converter_rec add: add simp: simp)"], ["", "lemma interaction_any_bounded_converter_id [interaction_bound]:\n  \"interaction_any_bounded_converter id_converter 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter id_converter 1", "by(coinduction) simp"], ["", "lemma raw_converter_invariant_interaction_any_bounded_converter:\n  \"raw_converter_invariant \\<I>_full \\<I>_full run_converter (\\<lambda>conv. interaction_any_bounded_converter conv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I>_full \\<I>_full run_converter\n     (\\<lambda>conv. interaction_any_bounded_converter conv n)", "by(unfold_locales)(auto simp add: results_gpv_\\<I>_full dest: interaction_any_bounded_converterD)"], ["", "lemma interaction_bounded_by_left_gpv [interaction_bound]:\n  assumes \"interaction_bounded_by consider gpv n\"\n    and \"\\<And>x. consider' (Inl x) \\<Longrightarrow> consider x\"\n  shows \"interaction_bounded_by consider' (left_gpv gpv) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (left_gpv gpv) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (left_gpv gpv) n", "define ib :: \"('b, 'a, 'c) gpv \\<Rightarrow> _\" where \"ib \\<equiv> interaction_bound consider\""], ["proof (state)\nthis:\n  ib \\<equiv> interaction_bound consider\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (left_gpv gpv) n", "have \"interaction_bound consider' (left_gpv gpv) \\<le> ib gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bound consider' (left_gpv gpv) \\<le> ib gpv", "proof(induction arbitrary: gpv rule: interaction_bound_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible (\\<lambda>a. \\<forall>x. a (left_gpv x) \\<le> ib x)\n 2. \\<And>gpv. 0 \\<le> ib gpv\n 3. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv. interaction_bound' (left_gpv gpv) \\<le> ib gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider' gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider' out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider' out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (left_gpv gpv)))\n                         \\<le> ib gpv", "case (step interaction_bound')"], ["proof (state)\nthis:\n  interaction_bound' (left_gpv ?gpv) \\<le> ib ?gpv\n  interaction_bound' ?gpv \\<le> interaction_bound consider' ?gpv\n  interaction_bound' ?gpv\n  \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv ?gpv).\n            case generat of Pure x \\<Rightarrow> 0\n            | IO out c \\<Rightarrow>\n                if consider' out\n                then eSuc (\\<Squnion>input. interaction_bound' (c input))\n                else \\<Squnion>input. interaction_bound' (c input))\n\ngoal (3 subgoals):\n 1. lfp.admissible (\\<lambda>a. \\<forall>x. a (left_gpv x) \\<le> ib x)\n 2. \\<And>gpv. 0 \\<le> ib gpv\n 3. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv. interaction_bound' (left_gpv gpv) \\<le> ib gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider' gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider' out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider' out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (left_gpv gpv)))\n                         \\<le> ib gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (left_gpv gpv)).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider' out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> ib gpv", "unfolding ib_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (left_gpv gpv)).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider' out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> interaction_bound consider gpv", "apply(subst interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (case_generat (\\<lambda>x. 0)\n                 (\\<lambda>out c.\n                     if consider' out\n                     then eSuc\n                           (\\<Squnion>input. interaction_bound' (c input))\n                     else \\<Squnion>input. interaction_bound' (c input)) `\n                set_spmf (the_gpv (left_gpv gpv)))\n    \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv))", "apply(rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set_spmf (the_gpv (left_gpv gpv)) \\<Longrightarrow>\n       (case i of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider' out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n       \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n                          (\\<lambda>out c.\n                              if consider out\n                              then eSuc\n                                    (\\<Squnion>input.\n  interaction_bound consider (c input))\n                              else \\<Squnion>input.\ninteraction_bound consider (c input)) `\n                         set_spmf (the_gpv gpv))", "apply(clarsimp split!: generat.split if_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(rule SUP_upper2, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (left_rpv c' input))\n                         \\<le> (case IO out' c' of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(clarsimp split!: if_split simp add: assms(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c' input.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inl out'); input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                            interaction_bound' (left_rpv c' input)\n                            \\<le> interaction_bound consider (c' m)\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "subgoal for \\<dots> input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out'_ c'_ \\<in> set_spmf (the_gpv gpv);\n     consider' (Inl out'_); input \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                         interaction_bound' (left_rpv c'_ input)\n                         \\<le> interaction_bound consider (c'_ m)", "by(cases input)(auto 4 3 intro: step.IH[unfolded ib_def] order_trans[OF step.hyps(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(rule SUP_upper2, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (case IO out' c' of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input))", "apply(clarsimp split!: if_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> eSuc\n                                (\\<Squnion>input.\n                                    interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(rule order_trans, rule ile_eSuc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); consider out'\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (left_rpv c' input))\n                         \\<le> eSuc\n                                (\\<Squnion>input.\n                                    interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c' input.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); consider out';\n        input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                            interaction_bound' (left_rpv c' input)\n                            \\<le> interaction_bound consider (c' m)\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "subgoal for \\<dots> input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out'_ c'_ \\<in> set_spmf (the_gpv gpv);\n     \\<not> consider' (Inl out'_); consider out'_; input \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                         interaction_bound' (left_rpv c'_ input)\n                         \\<le> interaction_bound consider (c'_ m)", "by(cases input)(auto 4 3 intro: step.IH[unfolded ib_def] order_trans[OF step.hyps(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (left_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c' input.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inl out'); \\<not> consider out';\n        input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                            interaction_bound' (left_rpv c' input)\n                            \\<le> interaction_bound consider (c' m)", "subgoal for \\<dots> input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out'_ c'_ \\<in> set_spmf (the_gpv gpv);\n     \\<not> consider' (Inl out'_); \\<not> consider out'_;\n     input \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                         interaction_bound' (left_rpv c'_ input)\n                         \\<le> interaction_bound consider (c'_ m)", "by(cases input)(auto 4 3 intro: step.IH[unfolded ib_def] order_trans[OF step.hyps(1)])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>generat\\<in>set_spmf (the_gpv (left_gpv gpv)).\n      case generat of Pure x \\<Rightarrow> 0\n      | IO out c \\<Rightarrow>\n          if consider' out\n          then eSuc (\\<Squnion>input. interaction_bound' (c input))\n          else \\<Squnion>input. interaction_bound' (c input))\n  \\<le> ib gpv\n\ngoal (2 subgoals):\n 1. lfp.admissible (\\<lambda>a. \\<forall>x. a (left_gpv x) \\<le> ib x)\n 2. \\<And>gpv. 0 \\<le> ib gpv", "qed simp_all"], ["proof (state)\nthis:\n  interaction_bound consider' (left_gpv gpv) \\<le> ib gpv\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (left_gpv gpv) n", "then"], ["proof (chain)\npicking this:\n  interaction_bound consider' (left_gpv gpv) \\<le> ib gpv", "show ?thesis"], ["proof (prove)\nusing this:\n  interaction_bound consider' (left_gpv gpv) \\<le> ib gpv\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (left_gpv gpv) n", "using assms(1)"], ["proof (prove)\nusing this:\n  interaction_bound consider' (left_gpv gpv) \\<le> ib gpv\n  interaction_bounded_by consider gpv n\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (left_gpv gpv) n", "by(auto simp add: ib_def interaction_bounded_by.simps intro: order_trans)"], ["proof (state)\nthis:\n  interaction_bounded_by consider' (left_gpv gpv) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interaction_bounded_by_right_gpv [interaction_bound]:\n  assumes \"interaction_bounded_by consider gpv n\"\n    and \"\\<And>x. consider' (Inr x) \\<Longrightarrow> consider x\"\n  shows \"interaction_bounded_by consider' (right_gpv gpv) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (right_gpv gpv) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (right_gpv gpv) n", "define ib :: \"('b, 'a, 'c) gpv \\<Rightarrow> _\" where \"ib \\<equiv> interaction_bound consider\""], ["proof (state)\nthis:\n  ib \\<equiv> interaction_bound consider\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (right_gpv gpv) n", "have \"interaction_bound consider' (right_gpv gpv) \\<le> ib gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bound consider' (right_gpv gpv) \\<le> ib gpv", "proof(induction arbitrary: gpv rule: interaction_bound_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible (\\<lambda>a. \\<forall>x. a (right_gpv x) \\<le> ib x)\n 2. \\<And>gpv. 0 \\<le> ib gpv\n 3. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv. interaction_bound' (right_gpv gpv) \\<le> ib gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider' gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider' out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider' out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (right_gpv gpv)))\n                         \\<le> ib gpv", "case (step interaction_bound')"], ["proof (state)\nthis:\n  interaction_bound' (right_gpv ?gpv) \\<le> ib ?gpv\n  interaction_bound' ?gpv \\<le> interaction_bound consider' ?gpv\n  interaction_bound' ?gpv\n  \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv ?gpv).\n            case generat of Pure x \\<Rightarrow> 0\n            | IO out c \\<Rightarrow>\n                if consider' out\n                then eSuc (\\<Squnion>input. interaction_bound' (c input))\n                else \\<Squnion>input. interaction_bound' (c input))\n\ngoal (3 subgoals):\n 1. lfp.admissible (\\<lambda>a. \\<forall>x. a (right_gpv x) \\<le> ib x)\n 2. \\<And>gpv. 0 \\<le> ib gpv\n 3. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv. interaction_bound' (right_gpv gpv) \\<le> ib gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider' gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider' out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider' out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (right_gpv gpv)))\n                         \\<le> ib gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (right_gpv gpv)).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider' out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> ib gpv", "unfolding ib_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (right_gpv gpv)).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider' out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> interaction_bound consider gpv", "apply(subst interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (case_generat (\\<lambda>x. 0)\n                 (\\<lambda>out c.\n                     if consider' out\n                     then eSuc\n                           (\\<Squnion>input. interaction_bound' (c input))\n                     else \\<Squnion>input. interaction_bound' (c input)) `\n                set_spmf (the_gpv (right_gpv gpv)))\n    \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv))", "apply(rule SUP_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set_spmf (the_gpv (right_gpv gpv)) \\<Longrightarrow>\n       (case i of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider' out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n       \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n                          (\\<lambda>out c.\n                              if consider out\n                              then eSuc\n                                    (\\<Squnion>input.\n  interaction_bound consider (c input))\n                              else \\<Squnion>input.\ninteraction_bound consider (c input)) `\n                         set_spmf (the_gpv gpv))", "apply(clarsimp split!: generat.split if_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(rule SUP_upper2, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (right_rpv c' input))\n                         \\<le> (case IO out' c' of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(clarsimp split!: if_split simp add: assms(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c' input.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        consider' (Inr out'); input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                            interaction_bound' (right_rpv c' input)\n                            \\<le> interaction_bound consider (c' m)\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "subgoal for \\<dots> input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out'_ c'_ \\<in> set_spmf (the_gpv gpv);\n     consider' (Inr out'_); input \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                         interaction_bound' (right_rpv c'_ input)\n                         \\<le> interaction_bound consider (c'_ m)", "by(cases input)(auto 4 3 intro: step.IH[unfolded ib_def] order_trans[OF step.hyps(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                   case x of Pure x \\<Rightarrow> 0\n                                   | IO out c \\<Rightarrow>\n if consider out\n then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n else \\<Squnion>input. interaction_bound consider (c input))", "apply(rule SUP_upper2, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out')\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (case IO out' c' of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input))", "apply(clarsimp split!: if_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> eSuc\n                                (\\<Squnion>input.\n                                    interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(rule order_trans, rule ile_eSuc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); consider out'\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (right_rpv c' input))\n                         \\<le> eSuc\n                                (\\<Squnion>input.\n                                    interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>out' c' input.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); consider out';\n        input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                            interaction_bound' (right_rpv c' input)\n                            \\<le> interaction_bound consider (c' m)\n 2. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "subgoal for \\<dots> input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out'_ c'_ \\<in> set_spmf (the_gpv gpv);\n     \\<not> consider' (Inr out'_); consider out'_; input \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                         interaction_bound' (right_rpv c'_ input)\n                         \\<le> interaction_bound consider (c'_ m)", "by(cases input)(auto 4 3 intro: step.IH[unfolded ib_def] order_trans[OF step.hyps(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c'.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); \\<not> consider out'\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>input.\n                             interaction_bound' (right_rpv c' input))\n                         \\<le> (\\<Squnion>input.\n                                   interaction_bound consider (c' input))", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>out' c' input.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpv);\n        \\<not> consider' (Inr out'); \\<not> consider out';\n        input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                            interaction_bound' (right_rpv c' input)\n                            \\<le> interaction_bound consider (c' m)", "subgoal for \\<dots> input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out'_ c'_ \\<in> set_spmf (the_gpv gpv);\n     \\<not> consider' (Inr out'_); \\<not> consider out'_;\n     input \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m\\<in>UNIV.\n                         interaction_bound' (right_rpv c'_ input)\n                         \\<le> interaction_bound consider (c'_ m)", "by(cases input)(auto 4 3 intro: step.IH[unfolded ib_def] order_trans[OF step.hyps(1)])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>generat\\<in>set_spmf (the_gpv (right_gpv gpv)).\n      case generat of Pure x \\<Rightarrow> 0\n      | IO out c \\<Rightarrow>\n          if consider' out\n          then eSuc (\\<Squnion>input. interaction_bound' (c input))\n          else \\<Squnion>input. interaction_bound' (c input))\n  \\<le> ib gpv\n\ngoal (2 subgoals):\n 1. lfp.admissible (\\<lambda>a. \\<forall>x. a (right_gpv x) \\<le> ib x)\n 2. \\<And>gpv. 0 \\<le> ib gpv", "qed simp_all"], ["proof (state)\nthis:\n  interaction_bound consider' (right_gpv gpv) \\<le> ib gpv\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (right_gpv gpv) n", "then"], ["proof (chain)\npicking this:\n  interaction_bound consider' (right_gpv gpv) \\<le> ib gpv", "show ?thesis"], ["proof (prove)\nusing this:\n  interaction_bound consider' (right_gpv gpv) \\<le> ib gpv\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (right_gpv gpv) n", "using assms(1)"], ["proof (prove)\nusing this:\n  interaction_bound consider' (right_gpv gpv) \\<le> ib gpv\n  interaction_bounded_by consider gpv n\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider' (right_gpv gpv) n", "by(auto simp add: ib_def interaction_bounded_by.simps intro: order_trans)"], ["proof (state)\nthis:\n  interaction_bounded_by consider' (right_gpv gpv) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interaction_any_bounded_converter_parallel_converter2:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 n\"\n  shows \"interaction_any_bounded_converter (parallel_converter2 conv1 conv2) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (parallel_converter2 conv1 conv2) n", "using assms"], ["proof (prove)\nusing this:\n  interaction_any_bounded_converter conv1 n\n  interaction_any_bounded_converter conv2 n\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (parallel_converter2 conv1 conv2) n", "by(coinduction arbitrary: conv1 conv2)\n    (auto 4 4 split: sum.split intro!: interaction_bounded_by_map_gpv_id intro: interaction_bounded_by_left_gpv interaction_bounded_by_right_gpv elim: interaction_any_bounded_converter.cases)"], ["", "lemma interaction_any_bounded_converter_parallel_converter2' [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 m\"\n  shows \"interaction_any_bounded_converter (parallel_converter2 conv1 conv2) (max n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (parallel_converter2 conv1 conv2)\n     (max n m)", "by(rule interaction_any_bounded_converter_parallel_converter2; rule assms[THEN interaction_any_bounded_converter_mono]; simp)"], ["", "lemma interaction_any_bounded_converter_compose [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 m\"\n  shows \"interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)", "have [simp]: \"\\<lbrakk>interaction_any_bounded_converter conv1 n; interaction_any_bounded_converter conv2 m\\<rbrakk> \\<Longrightarrow>\n    interaction_any_bounded_by (inline run_converter (run_converter conv1 x) conv2) (n * m)\" for conv1 conv2 x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>interaction_any_bounded_converter conv1 n;\n     interaction_any_bounded_converter conv2 m\\<rbrakk>\n    \\<Longrightarrow> interaction_any_bounded_by\n                       (inline run_converter (run_converter conv1 x) conv2)\n                       (n * m)", "by (rule interaction_bounded_by_inline_invariant[where I=\"\\<lambda>conv2. interaction_any_bounded_converter conv2 m\" and consider'=\"\\<lambda>_. True\"])\n      (auto dest: interaction_any_bounded_converterD)"], ["proof (state)\nthis:\n  \\<lbrakk>interaction_any_bounded_converter ?conv1.1 n;\n   interaction_any_bounded_converter ?conv2.1 m\\<rbrakk>\n  \\<Longrightarrow> interaction_any_bounded_by\n                     (inline run_converter (run_converter ?conv1.1 ?x1)\n                       ?conv2.1)\n                     (n * m)\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)", "using assms"], ["proof (prove)\nusing this:\n  interaction_any_bounded_converter conv1 n\n  interaction_any_bounded_converter conv2 m\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)", "by(coinduction arbitrary: conv1 conv2)\n      ((clarsimp simp add: results_gpv_\\<I>_full[symmetric] | intro conjI strip interaction_bounded_by_map_gpv_id)+\n        , drule raw_converter_invariant.results_gpv_inline[OF raw_converter_invariant_interaction_any_bounded_converter]\n        , (rule exI conjI refl WT_gpv_full |  auto simp add: results_gpv_\\<I>_full dest: interaction_any_bounded_converterD\n          raw_converter_invariant.results_gpv_inline[OF raw_converter_invariant_interaction_any_bounded_converter])+ )"], ["proof (state)\nthis:\n  interaction_any_bounded_converter (comp_converter conv1 conv2) (n * m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interaction_any_bounded_converter_of_callee [interaction_bound]:\n  assumes \"\\<And>s x. interaction_any_bounded_by (conv s x) n\"\n  shows \"interaction_any_bounded_converter (converter_of_callee conv s) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (converter_of_callee conv s) n", "by(coinduction arbitrary: s)(auto intro!: interaction_bounded_by_map_gpv_id assms)"], ["", "lemma interaction_any_bounded_converter_map_converter [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv n\"\n    and \"surj k\"\n  shows \"interaction_any_bounded_converter (map_converter f g h k conv) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (map_converter f g h k conv) n", "using assms"], ["proof (prove)\nusing this:\n  interaction_any_bounded_converter conv n\n  surj k\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (map_converter f g h k conv) n", "by(coinduction arbitrary: conv)\n    (auto 4 3 simp add: assms results'_gpv_map_gpv'[OF \\<open>surj k\\<close>]  intro: assms  interaction_any_bounded_by_map_gpv' dest: interaction_any_bounded_converterD)"], ["", "lemma interaction_any_bounded_converter_parallel_converter:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 n\"\n  shows \"interaction_any_bounded_converter (parallel_converter conv1 conv2) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (parallel_converter conv1 conv2) n", "using assms"], ["proof (prove)\nusing this:\n  interaction_any_bounded_converter conv1 n\n  interaction_any_bounded_converter conv2 n\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (parallel_converter conv1 conv2) n", "by(coinduction arbitrary: conv1 conv2)\n    (auto 4 4 split: sum.split intro!: interaction_bounded_by_map_gpv_id elim: interaction_any_bounded_converter.cases)"], ["", "lemma interaction_any_bounded_converter_parallel_converter' [interaction_bound]:\n  assumes \"interaction_any_bounded_converter conv1 n\"\n    and \"interaction_any_bounded_converter conv2 m\"\n  shows \"interaction_any_bounded_converter (parallel_converter conv1 conv2) (max n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (parallel_converter conv1 conv2)\n     (max n m)", "by(rule interaction_any_bounded_converter_parallel_converter; rule assms[THEN interaction_any_bounded_converter_mono]; simp)"], ["", "lemma interaction_any_bounded_converter_converter_of_resource:\n  \"interaction_any_bounded_converter (converter_of_resource res) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (converter_of_resource res) n", "by(coinduction arbitrary: res)(auto intro: interaction_bounded_by_map_gpv_id)"], ["", "lemma interaction_any_bounded_converter_converter_of_resource' [interaction_bound]:\n  \"interaction_any_bounded_converter (converter_of_resource res) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (converter_of_resource res) 0", "by(rule interaction_any_bounded_converter_converter_of_resource)"], ["", "lemma interaction_any_bounded_converter_restrict_converter [interaction_bound]:\n  \"interaction_any_bounded_converter (restrict_converter A \\<I> cnv) bound\"\n  if \"interaction_any_bounded_converter cnv bound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (restrict_converter A \\<I> cnv) bound", "using that"], ["proof (prove)\nusing this:\n  interaction_any_bounded_converter cnv bound\n\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (restrict_converter A \\<I> cnv) bound", "by(coinduction arbitrary: cnv)\n    (auto 4 3 dest: interaction_any_bounded_converterD dest!: in_results'_gpv_restrict_gpvD intro!: interaction_bound)"], ["", "end"]]}