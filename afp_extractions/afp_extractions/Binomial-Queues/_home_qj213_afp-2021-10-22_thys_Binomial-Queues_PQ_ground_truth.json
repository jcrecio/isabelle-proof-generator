{"file_name": "/home/qj213/afp-2021-10-22/thys/Binomial-Queues/PQ.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binomial-Queues", "problem_names": ["lemma tl_set:\n  \"distinct q \\<Longrightarrow> set (tl q) = set q - {hd q}\"", "lemma alist_of_Abs_pq:\n  assumes \"distinct (map fst xs)\"\n    and \"sorted (map snd xs)\"\n  shows \"alist_of (Abs_pq xs) = xs\"", "lemma [code abstype]:\n  \"Abs_pq (alist_of q) = q\"", "lemma distinct_fst_alist_of [simp]:\n  \"distinct (map fst (alist_of q))\"", "lemma distinct_alist_of [simp]:\n  \"distinct (alist_of q)\"", "lemma sorted_snd_alist_of [simp]:\n  \"sorted (map snd (alist_of q))\"", "lemma alist_of_eqI:\n  \"alist_of p = alist_of q \\<Longrightarrow> p = q\"", "lemma values_set:\n  \"set |q| = fst ` set (alist_of q)\"", "lemma priorities_set:\n  \"set \\<parallel>q\\<parallel> = snd ` set (alist_of q)\"", "lemma is_empty_alist_of [dest]:\n  \"is_empty q \\<Longrightarrow> alist_of q = []\"", "lemma not_is_empty_alist_of [dest]:\n  \"\\<not> is_empty q \\<Longrightarrow> alist_of q \\<noteq> []\"", "lemma alist_of_empty [simp, code abstract]:\n  \"alist_of empty = []\"", "lemma values_empty [simp]:\n  \"|empty| = []\"", "lemma priorities_empty [simp]:\n  \"\\<parallel>empty\\<parallel> = []\"", "lemma values_empty_nothing [simp]:\n  \"\\<forall>k. k \\<notin> set |empty|\"", "lemma is_empty_empty:\n  \"is_empty q \\<longleftrightarrow> q = empty\"", "lemma is_empty_empty_simp [simp]:\n  \"is_empty empty\"", "lemma map_snd_alist_of:\n  \"map (the \\<circ> priority q) (values q) = map snd (alist_of q)\"", "lemma image_snd_alist_of:\n  \"the ` priority q ` set (values q) = snd ` set (alist_of q)\"", "lemma Min_snd_alist_of:\n  assumes \"\\<not> is_empty q\"\n  shows \"Min (snd ` set (alist_of q)) = snd (hd (alist_of q))\"", "lemma priority_fst:\n  assumes \"xp \\<in> set (alist_of q)\"\n  shows \"priority q (fst xp) = Some (snd xp)\"", "lemma priority_Min:\n  assumes \"\\<not> is_empty q\"\n  shows \"priority q (min q) = Some (Min (the ` priority q ` set (values q)))\"", "lemma priority_Min_priorities:\n  assumes \"\\<not> is_empty q\"\n  shows \"priority q (min q) = Some (Min (set \\<parallel>q\\<parallel>))\"", "lemma Min_snd_hd:\n  \"q \\<noteq> [] \\<Longrightarrow> sorted (map snd q) \\<Longrightarrow> Min (snd ` set q) = snd (hd q)\"", "lemma hd_construct:\n  assumes \"\\<not> is_empty q\"\n  shows \"hd (alist_of q) = (min q, the (priority q (min q)))\"", "lemma not_in_first_image:\n  \"x \\<notin> fst ` s \\<Longrightarrow> (x, p) \\<notin> s\"", "lemma alist_of_push [simp, code abstract]:\n  \"alist_of (push k p q) =\n    (if k \\<notin> set (values q) then insort_key snd (k, p) (alist_of q) else alist_of q)\"", "lemma push_values [simp]:\n  \"set |push k p q| = set |q| \\<union> {k}\"", "lemma push_priorities [simp]:\n  \"k \\<notin> set |q| \\<Longrightarrow> set \\<parallel>push k p q\\<parallel> = set \\<parallel>q\\<parallel> \\<union> {p}\"\n  \"k \\<in> set |q| \\<Longrightarrow> set \\<parallel>push k p q\\<parallel> = set \\<parallel>q\\<parallel>\"", "lemma not_is_empty_push [simp]:\n  \"\\<not> is_empty (push k p q)\"", "lemma push_commute:\n  assumes \"a \\<noteq> b\" and \"v \\<noteq> w\"\n  shows \"push w b (push v a q) = push v a (push w b q)\"", "lemma alift_of_remove_min_if [code abstract]:\n  \"alist_of (remove_min q) = (if is_empty q then [] else tl (alist_of q))\"", "lemma remove_min_empty [simp]:\n  \"is_empty q \\<Longrightarrow> remove_min q = empty\"", "lemma alist_of_remove_min [simp]:\n  \"\\<not> is_empty q \\<Longrightarrow> alist_of (remove_min q) = tl (alist_of q)\"", "lemma values_remove_min [simp]:\n  \"\\<not> is_empty q \\<Longrightarrow> values (remove_min q) = tl (values q)\"", "lemma set_alist_of_remove_min:\n  \"\\<not> is_empty q \\<Longrightarrow> set (alist_of (remove_min q)) =\n    set (alist_of q) - {(min q, the (priority q (min q)))}\"", "lemma pop_simps [simp]:\n  \"is_empty q \\<Longrightarrow> pop q = None\"\n  \"\\<not> is_empty q \\<Longrightarrow> pop q = Some (min q, remove_min q)\""], "translations": [["", "lemma tl_set:\n  \"distinct q \\<Longrightarrow> set (tl q) = set q - {hd q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct q \\<Longrightarrow> set (tl q) = set q - {hd q}", "by (cases q) simp_all"], ["", "subsection \\<open>Type of abstract priority queues\\<close>"], ["", "typedef (overloaded) ('a, 'b::linorder) pq =\n  \"{xs :: ('a \\<times> 'b) list. distinct (map fst xs) \\<and> sorted (map snd xs)}\"\n  morphisms alist_of Abs_pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}", "have \"[] \\<in> ?pq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}", "by simp"], ["proof (state)\nthis:\n  [] \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}", "then"], ["proof (chain)\npicking this:\n  [] \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}", "show ?thesis"], ["proof (prove)\nusing this:\n  [] \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alist_of_Abs_pq:\n  assumes \"distinct (map fst xs)\"\n    and \"sorted (map snd xs)\"\n  shows \"alist_of (Abs_pq xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alist_of (Abs_pq xs) = xs", "by (rule Abs_pq_inverse) (simp add: assms)"], ["", "lemma [code abstype]:\n  \"Abs_pq (alist_of q) = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_pq (alist_of q) = q", "by (fact alist_of_inverse)"], ["", "lemma distinct_fst_alist_of [simp]:\n  \"distinct (map fst (alist_of q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (alist_of q))", "using alist_of [of q]"], ["proof (prove)\nusing this:\n  alist_of q \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}\n\ngoal (1 subgoal):\n 1. distinct (map fst (alist_of q))", "by simp"], ["", "lemma distinct_alist_of [simp]:\n  \"distinct (alist_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (alist_of q)", "using distinct_fst_alist_of [of q]"], ["proof (prove)\nusing this:\n  distinct (map fst (alist_of q))\n\ngoal (1 subgoal):\n 1. distinct (alist_of q)", "by (simp add: distinct_map)"], ["", "lemma sorted_snd_alist_of [simp]:\n  \"sorted (map snd (alist_of q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map snd (alist_of q))", "using alist_of [of q]"], ["proof (prove)\nusing this:\n  alist_of q \\<in> {xs. distinct (map fst xs) \\<and> sorted (map snd xs)}\n\ngoal (1 subgoal):\n 1. sorted (map snd (alist_of q))", "by simp"], ["", "lemma alist_of_eqI:\n  \"alist_of p = alist_of q \\<Longrightarrow> p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alist_of p = alist_of q \\<Longrightarrow> p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alist_of p = alist_of q \\<Longrightarrow> p = q", "assume \"alist_of p = alist_of q\""], ["proof (state)\nthis:\n  alist_of p = alist_of q\n\ngoal (1 subgoal):\n 1. alist_of p = alist_of q \\<Longrightarrow> p = q", "then"], ["proof (chain)\npicking this:\n  alist_of p = alist_of q", "have \"Abs_pq (alist_of p) = Abs_pq (alist_of q)\""], ["proof (prove)\nusing this:\n  alist_of p = alist_of q\n\ngoal (1 subgoal):\n 1. Abs_pq (alist_of p) = Abs_pq (alist_of q)", "by simp"], ["proof (state)\nthis:\n  Abs_pq (alist_of p) = Abs_pq (alist_of q)\n\ngoal (1 subgoal):\n 1. alist_of p = alist_of q \\<Longrightarrow> p = q", "thus \"p = q\""], ["proof (prove)\nusing this:\n  Abs_pq (alist_of p) = Abs_pq (alist_of q)\n\ngoal (1 subgoal):\n 1. p = q", "by (simp add: alist_of_inverse)"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"values\" :: \"('a, 'b::linorder) pq \\<Rightarrow> 'a list\" (\"|(_)|\") where\n  \"values q = map fst (alist_of q)\""], ["", "definition priorities :: \"('a, 'b::linorder) pq \\<Rightarrow> 'b list\" (\"\\<parallel>(_)\\<parallel>\") where\n  \"priorities q = map snd (alist_of q)\""], ["", "lemma values_set:\n  \"set |q| = fst ` set (alist_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |q| = fst ` set (alist_of q)", "by (simp add: values_def)"], ["", "lemma priorities_set:\n  \"set \\<parallel>q\\<parallel> = snd ` set (alist_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<parallel>q\\<parallel> = snd ` set (alist_of q)", "by (simp add: priorities_def)"], ["", "definition is_empty :: \"('a, 'b::linorder) pq \\<Rightarrow> bool\" where\n  \"is_empty q \\<longleftrightarrow> alist_of q = []\""], ["", "definition priority :: \"('a, 'b::linorder) pq \\<Rightarrow> 'a \\<Rightarrow> 'b option\" where\n  \"priority q = map_of (alist_of q)\""], ["", "definition min :: \"('a, 'b::linorder) pq \\<Rightarrow> 'a\" where\n  \"min q = fst (hd (alist_of q))\""], ["", "definition empty :: \"('a, 'b::linorder) pq\" where \n  \"empty = Abs_pq []\""], ["", "lemma is_empty_alist_of [dest]:\n  \"is_empty q \\<Longrightarrow> alist_of q = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_empty q \\<Longrightarrow> alist_of q = []", "by (simp add: is_empty_def)"], ["", "lemma not_is_empty_alist_of [dest]:\n  \"\\<not> is_empty q \\<Longrightarrow> alist_of q \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty q \\<Longrightarrow> alist_of q \\<noteq> []", "by (simp add: is_empty_def)"], ["", "lemma alist_of_empty [simp, code abstract]:\n  \"alist_of empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alist_of PQ.empty = []", "by (simp add: empty_def Abs_pq_inverse)"], ["", "lemma values_empty [simp]:\n  \"|empty| = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |PQ.empty| = []", "by (simp add: values_def)"], ["", "lemma priorities_empty [simp]:\n  \"\\<parallel>empty\\<parallel> = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>PQ.empty\\<parallel> = []", "by (simp add: priorities_def)"], ["", "lemma values_empty_nothing [simp]:\n  \"\\<forall>k. k \\<notin> set |empty|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. k \\<notin> set |PQ.empty|", "by (simp add: values_def)"], ["", "lemma is_empty_empty:\n  \"is_empty q \\<longleftrightarrow> q = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_empty q = (q = PQ.empty)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_empty q \\<Longrightarrow> q = PQ.empty\n 2. q = PQ.empty \\<Longrightarrow> is_empty q", "assume \"is_empty q\""], ["proof (state)\nthis:\n  is_empty q\n\ngoal (2 subgoals):\n 1. is_empty q \\<Longrightarrow> q = PQ.empty\n 2. q = PQ.empty \\<Longrightarrow> is_empty q", "then"], ["proof (chain)\npicking this:\n  is_empty q", "have \"alist_of q = []\""], ["proof (prove)\nusing this:\n  is_empty q\n\ngoal (1 subgoal):\n 1. alist_of q = []", "by (simp add: is_empty_alist_of)"], ["proof (state)\nthis:\n  alist_of q = []\n\ngoal (2 subgoals):\n 1. is_empty q \\<Longrightarrow> q = PQ.empty\n 2. q = PQ.empty \\<Longrightarrow> is_empty q", "then"], ["proof (chain)\npicking this:\n  alist_of q = []", "have \"Abs_pq (alist_of q) = Abs_pq []\""], ["proof (prove)\nusing this:\n  alist_of q = []\n\ngoal (1 subgoal):\n 1. Abs_pq (alist_of q) = Abs_pq []", "by simp"], ["proof (state)\nthis:\n  Abs_pq (alist_of q) = Abs_pq []\n\ngoal (2 subgoals):\n 1. is_empty q \\<Longrightarrow> q = PQ.empty\n 2. q = PQ.empty \\<Longrightarrow> is_empty q", "then"], ["proof (chain)\npicking this:\n  Abs_pq (alist_of q) = Abs_pq []", "show \"q = empty\""], ["proof (prove)\nusing this:\n  Abs_pq (alist_of q) = Abs_pq []\n\ngoal (1 subgoal):\n 1. q = PQ.empty", "by (simp add: empty_def alist_of_inverse)"], ["proof (state)\nthis:\n  q = PQ.empty\n\ngoal (1 subgoal):\n 1. q = PQ.empty \\<Longrightarrow> is_empty q", "qed (simp add: is_empty_def)"], ["", "lemma is_empty_empty_simp [simp]:\n  \"is_empty empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_empty PQ.empty", "by (simp add: is_empty_empty)"], ["", "lemma map_snd_alist_of:\n  \"map (the \\<circ> priority q) (values q) = map snd (alist_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (the \\<circ> priority q) |q| = map snd (alist_of q)", "by (auto simp add: values_def priority_def)"], ["", "lemma image_snd_alist_of:\n  \"the ` priority q ` set (values q) = snd ` set (alist_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the ` priority q ` set |q| = snd ` set (alist_of q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the ` priority q ` set |q| = snd ` set (alist_of q)", "from map_snd_alist_of [of q]"], ["proof (chain)\npicking this:\n  map (the \\<circ> priority q) |q| = map snd (alist_of q)", "have \"set (map (the \\<circ> priority q) (values q)) = set (map snd (alist_of q))\""], ["proof (prove)\nusing this:\n  map (the \\<circ> priority q) |q| = map snd (alist_of q)\n\ngoal (1 subgoal):\n 1. set (map (the \\<circ> priority q) |q|) = set (map snd (alist_of q))", "by (simp only:)"], ["proof (state)\nthis:\n  set (map (the \\<circ> priority q) |q|) = set (map snd (alist_of q))\n\ngoal (1 subgoal):\n 1. the ` priority q ` set |q| = snd ` set (alist_of q)", "then"], ["proof (chain)\npicking this:\n  set (map (the \\<circ> priority q) |q|) = set (map snd (alist_of q))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (map (the \\<circ> priority q) |q|) = set (map snd (alist_of q))\n\ngoal (1 subgoal):\n 1. the ` priority q ` set |q| = snd ` set (alist_of q)", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  the ` priority q ` set |q| = snd ` set (alist_of q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Min_snd_alist_of:\n  assumes \"\\<not> is_empty q\"\n  shows \"Min (snd ` set (alist_of q)) = snd (hd (alist_of q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "from assms"], ["proof (chain)\npicking this:\n  \\<not> is_empty q", "obtain ps p where q: \"map snd (alist_of q) = p # ps\""], ["proof (prove)\nusing this:\n  \\<not> is_empty q\n\ngoal (1 subgoal):\n 1. (\\<And>p ps.\n        map snd (alist_of q) = p # ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"map snd (alist_of q)\") auto"], ["proof (state)\nthis:\n  map snd (alist_of q) = p # ps\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "then"], ["proof (chain)\npicking this:\n  map snd (alist_of q) = p # ps", "have \"hd (map snd (alist_of q)) = p\""], ["proof (prove)\nusing this:\n  map snd (alist_of q) = p # ps\n\ngoal (1 subgoal):\n 1. hd (map snd (alist_of q)) = p", "by simp"], ["proof (state)\nthis:\n  hd (map snd (alist_of q)) = p\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "with assms"], ["proof (chain)\npicking this:\n  \\<not> is_empty q\n  hd (map snd (alist_of q)) = p", "have p: \"snd (hd (alist_of q)) = p\""], ["proof (prove)\nusing this:\n  \\<not> is_empty q\n  hd (map snd (alist_of q)) = p\n\ngoal (1 subgoal):\n 1. snd (hd (alist_of q)) = p", "by (auto simp add: hd_map)"], ["proof (state)\nthis:\n  snd (hd (alist_of q)) = p\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "have \"sorted (map snd (alist_of q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map snd (alist_of q))", "by simp"], ["proof (state)\nthis:\n  sorted (map snd (alist_of q))\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "with q"], ["proof (chain)\npicking this:\n  map snd (alist_of q) = p # ps\n  sorted (map snd (alist_of q))", "have \"sorted (p # ps)\""], ["proof (prove)\nusing this:\n  map snd (alist_of q) = p # ps\n  sorted (map snd (alist_of q))\n\ngoal (1 subgoal):\n 1. sorted (p # ps)", "by simp"], ["proof (state)\nthis:\n  sorted (p # ps)\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "then"], ["proof (chain)\npicking this:\n  sorted (p # ps)", "have \"\\<forall>p'\\<in>set ps. p' \\<ge> p\""], ["proof (prove)\nusing this:\n  sorted (p # ps)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set ps. p \\<le> p'", "by (simp)"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>set ps. p \\<le> p'\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "then"], ["proof (chain)\npicking this:\n  \\<forall>p'\\<in>set ps. p \\<le> p'", "have \"Min (set (p # ps)) = p\""], ["proof (prove)\nusing this:\n  \\<forall>p'\\<in>set ps. p \\<le> p'\n\ngoal (1 subgoal):\n 1. Min (set (p # ps)) = p", "by (auto intro: Min_eqI)"], ["proof (state)\nthis:\n  Min (set (p # ps)) = p\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "with p q"], ["proof (chain)\npicking this:\n  snd (hd (alist_of q)) = p\n  map snd (alist_of q) = p # ps\n  Min (set (p # ps)) = p", "have \"Min (set (map snd (alist_of q))) = snd (hd (alist_of q))\""], ["proof (prove)\nusing this:\n  snd (hd (alist_of q)) = p\n  map snd (alist_of q) = p # ps\n  Min (set (p # ps)) = p\n\ngoal (1 subgoal):\n 1. Min (set (map snd (alist_of q))) = snd (hd (alist_of q))", "by simp"], ["proof (state)\nthis:\n  Min (set (map snd (alist_of q))) = snd (hd (alist_of q))\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "then"], ["proof (chain)\npicking this:\n  Min (set (map snd (alist_of q))) = snd (hd (alist_of q))", "show ?thesis"], ["proof (prove)\nusing this:\n  Min (set (map snd (alist_of q))) = snd (hd (alist_of q))\n\ngoal (1 subgoal):\n 1. Min (snd ` set (alist_of q)) = snd (hd (alist_of q))", "by simp"], ["proof (state)\nthis:\n  Min (snd ` set (alist_of q)) = snd (hd (alist_of q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma priority_fst:\n  assumes \"xp \\<in> set (alist_of q)\"\n  shows \"priority q (fst xp) = Some (snd xp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. priority q (fst xp) = Some (snd xp)", "using assms"], ["proof (prove)\nusing this:\n  xp \\<in> set (alist_of q)\n\ngoal (1 subgoal):\n 1. priority q (fst xp) = Some (snd xp)", "by (simp add: priority_def)"], ["", "lemma priority_Min:\n  assumes \"\\<not> is_empty q\"\n  shows \"priority q (min q) = Some (Min (the ` priority q ` set (values q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. priority q (PQ.min q) = Some (Min (the ` priority q ` set |q|))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_empty q\n\ngoal (1 subgoal):\n 1. priority q (PQ.min q) = Some (Min (the ` priority q ` set |q|))", "by (auto simp add: min_def image_snd_alist_of Min_snd_alist_of priority_fst)"], ["", "lemma priority_Min_priorities:\n  assumes \"\\<not> is_empty q\"\n  shows \"priority q (min q) = Some (Min (set \\<parallel>q\\<parallel>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. priority q (PQ.min q) = Some (Min (set \\<parallel>q\\<parallel>))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_empty q\n\ngoal (1 subgoal):\n 1. priority q (PQ.min q) = Some (Min (set \\<parallel>q\\<parallel>))", "by (simp add: priority_Min image_snd_alist_of priorities_def)"], ["", "definition push :: \"'a \\<Rightarrow> 'b::linorder \\<Rightarrow> ('a, 'b) pq \\<Rightarrow> ('a, 'b) pq\" where\n  \"push k p q = Abs_pq (if k \\<notin> set (values q)\n           then insort_key snd (k, p) (alist_of q)\n           else alist_of q)\""], ["", "lemma Min_snd_hd:\n  \"q \\<noteq> [] \\<Longrightarrow> sorted (map snd q) \\<Longrightarrow> Min (snd ` set q) = snd (hd q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<noteq> []; sorted (map snd q)\\<rbrakk>\n    \\<Longrightarrow> Min (snd ` set q) = snd (hd q)", "proof (induct q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted (map snd [])\\<rbrakk>\n    \\<Longrightarrow> Min (snd ` set []) = snd (hd [])\n 2. \\<And>a q.\n       \\<lbrakk>\\<lbrakk>q \\<noteq> []; sorted (map snd q)\\<rbrakk>\n                \\<Longrightarrow> Min (snd ` set q) = snd (hd q);\n        a # q \\<noteq> []; sorted (map snd (a # q))\\<rbrakk>\n       \\<Longrightarrow> Min (snd ` set (a # q)) = snd (hd (a # q))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs \\<noteq> []; sorted (map snd xs)\\<rbrakk>\n  \\<Longrightarrow> Min (snd ` set xs) = snd (hd xs)\n  x # xs \\<noteq> []\n  sorted (map snd (x # xs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; sorted (map snd [])\\<rbrakk>\n    \\<Longrightarrow> Min (snd ` set []) = snd (hd [])\n 2. \\<And>a q.\n       \\<lbrakk>\\<lbrakk>q \\<noteq> []; sorted (map snd q)\\<rbrakk>\n                \\<Longrightarrow> Min (snd ` set q) = snd (hd q);\n        a # q \\<noteq> []; sorted (map snd (a # q))\\<rbrakk>\n       \\<Longrightarrow> Min (snd ` set (a # q)) = snd (hd (a # q))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>xs \\<noteq> []; sorted (map snd xs)\\<rbrakk>\n  \\<Longrightarrow> Min (snd ` set xs) = snd (hd xs)\n  x # xs \\<noteq> []\n  sorted (map snd (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>xs \\<noteq> []; sorted (map snd xs)\\<rbrakk>\n  \\<Longrightarrow> Min (snd ` set xs) = snd (hd xs)\n  x # xs \\<noteq> []\n  sorted (map snd (x # xs))\n\ngoal (1 subgoal):\n 1. Min (snd ` set (x # xs)) = snd (hd (x # xs))", "by (cases xs) (auto simp add: ord_class.min_def)"], ["proof (state)\nthis:\n  Min (snd ` set (x # xs)) = snd (hd (x # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<noteq> []; sorted (map snd [])\\<rbrakk>\n    \\<Longrightarrow> Min (snd ` set []) = snd (hd [])", "qed simp"], ["", "lemma hd_construct:\n  assumes \"\\<not> is_empty q\"\n  shows \"hd (alist_of q) = (min q, the (priority q (min q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (alist_of q) = (PQ.min q, the (priority q (PQ.min q)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hd (alist_of q) = (PQ.min q, the (priority q (PQ.min q)))", "from assms"], ["proof (chain)\npicking this:\n  \\<not> is_empty q", "have \"the (priority q (min q)) = snd (hd (alist_of q))\""], ["proof (prove)\nusing this:\n  \\<not> is_empty q\n\ngoal (1 subgoal):\n 1. the (priority q (PQ.min q)) = snd (hd (alist_of q))", "using Min_snd_hd [of \"alist_of q\"]"], ["proof (prove)\nusing this:\n  \\<not> is_empty q\n  \\<lbrakk>alist_of q \\<noteq> []; sorted (map snd (alist_of q))\\<rbrakk>\n  \\<Longrightarrow> Min (snd ` set (alist_of q)) = snd (hd (alist_of q))\n\ngoal (1 subgoal):\n 1. the (priority q (PQ.min q)) = snd (hd (alist_of q))", "by (auto simp add: priority_Min_priorities priorities_def)"], ["proof (state)\nthis:\n  the (priority q (PQ.min q)) = snd (hd (alist_of q))\n\ngoal (1 subgoal):\n 1. hd (alist_of q) = (PQ.min q, the (priority q (PQ.min q)))", "then"], ["proof (chain)\npicking this:\n  the (priority q (PQ.min q)) = snd (hd (alist_of q))", "show ?thesis"], ["proof (prove)\nusing this:\n  the (priority q (PQ.min q)) = snd (hd (alist_of q))\n\ngoal (1 subgoal):\n 1. hd (alist_of q) = (PQ.min q, the (priority q (PQ.min q)))", "by (simp add: min_def)"], ["proof (state)\nthis:\n  hd (alist_of q) = (PQ.min q, the (priority q (PQ.min q)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_in_first_image:\n  \"x \\<notin> fst ` s \\<Longrightarrow> (x, p) \\<notin> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` s \\<Longrightarrow> (x, p) \\<notin> s", "by (auto simp add: image_def)"], ["", "lemma alist_of_push [simp, code abstract]:\n  \"alist_of (push k p q) =\n    (if k \\<notin> set (values q) then insort_key snd (k, p) (alist_of q) else alist_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alist_of (push k p q) =\n    (if k \\<notin> set |q| then insort_key snd (k, p) (alist_of q)\n     else alist_of q)", "using distinct_fst_alist_of [of q]"], ["proof (prove)\nusing this:\n  distinct (map fst (alist_of q))\n\ngoal (1 subgoal):\n 1. alist_of (push k p q) =\n    (if k \\<notin> set |q| then insort_key snd (k, p) (alist_of q)\n     else alist_of q)", "by (auto simp add: distinct_map set_insort_key distinct_insort not_in_first_image\n      push_def values_def sorted_insort_key intro: alist_of_Abs_pq)"], ["", "lemma push_values [simp]:\n  \"set |push k p q| = set |q| \\<union> {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |push k p q| = set |q| \\<union> {k}", "by (auto simp add: values_def set_insort_key)"], ["", "lemma push_priorities [simp]:\n  \"k \\<notin> set |q| \\<Longrightarrow> set \\<parallel>push k p q\\<parallel> = set \\<parallel>q\\<parallel> \\<union> {p}\"\n  \"k \\<in> set |q| \\<Longrightarrow> set \\<parallel>push k p q\\<parallel> = set \\<parallel>q\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<notin> set |q| \\<Longrightarrow>\n     set \\<parallel>push k p q\\<parallel> =\n     set \\<parallel>q\\<parallel> \\<union> {p}) &&&\n    (k \\<in> set |q| \\<Longrightarrow>\n     set \\<parallel>push k p q\\<parallel> = set \\<parallel>q\\<parallel>)", "by (auto simp add: priorities_def set_insort_key)"], ["", "lemma not_is_empty_push [simp]:\n  \"\\<not> is_empty (push k p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty (push k p q)", "by (auto simp add: values_def is_empty_def)"], ["", "lemma push_commute:\n  assumes \"a \\<noteq> b\" and \"v \\<noteq> w\"\n  shows \"push w b (push v a q) = push v a (push w b q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push w b (push v a q) = push v a (push w b q)", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. push w b (push v a q) = push v a (push w b q)", "by (auto intro!: alist_of_eqI insort_key_left_comm)"], ["", "definition remove_min :: \"('a, 'b::linorder) pq \\<Rightarrow> ('a, 'b::linorder) pq\" where\n  \"remove_min q = (if is_empty q then empty else Abs_pq (tl (alist_of q)))\""], ["", "lemma alift_of_remove_min_if [code abstract]:\n  \"alist_of (remove_min q) = (if is_empty q then [] else tl (alist_of q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alist_of (remove_min q) = (if is_empty q then [] else tl (alist_of q))", "by (auto simp add: remove_min_def map_tl sorted_tl distinct_tl alist_of_Abs_pq)"], ["", "lemma remove_min_empty [simp]:\n  \"is_empty q \\<Longrightarrow> remove_min q = empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_empty q \\<Longrightarrow> remove_min q = PQ.empty", "by (simp add: remove_min_def)"], ["", "lemma alist_of_remove_min [simp]:\n  \"\\<not> is_empty q \\<Longrightarrow> alist_of (remove_min q) = tl (alist_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty q \\<Longrightarrow>\n    alist_of (remove_min q) = tl (alist_of q)", "by (simp add: alift_of_remove_min_if)"], ["", "lemma values_remove_min [simp]:\n  \"\\<not> is_empty q \\<Longrightarrow> values (remove_min q) = tl (values q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty q \\<Longrightarrow> |remove_min q| = tl |q|", "by (simp add: values_def map_tl)"], ["", "lemma set_alist_of_remove_min:\n  \"\\<not> is_empty q \\<Longrightarrow> set (alist_of (remove_min q)) =\n    set (alist_of q) - {(min q, the (priority q (min q)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty q \\<Longrightarrow>\n    set (alist_of (remove_min q)) =\n    set (alist_of q) - {(PQ.min q, the (priority q (PQ.min q)))}", "by (simp add: tl_set hd_construct)"], ["", "definition pop :: \"('a, 'b::linorder) pq \\<Rightarrow> ('a \\<times> ('a, 'b) pq) option\" where\n  \"pop q = (if is_empty q then None else Some (min q, remove_min q))\""], ["", "lemma pop_simps [simp]:\n  \"is_empty q \\<Longrightarrow> pop q = None\"\n  \"\\<not> is_empty q \\<Longrightarrow> pop q = Some (min q, remove_min q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_empty q \\<Longrightarrow> pop q = None) &&&\n    (\\<not> is_empty q \\<Longrightarrow>\n     pop q = Some (PQ.min q, remove_min q))", "by (simp_all add: pop_def)"], ["", "hide_const (open) Abs_pq alist_of \"values\" priority empty is_empty push min pop"], ["", "no_notation\n  \"PQ.values\" (\"|(_)|\")\n  and \"PQ.priorities\" (\"\\<parallel>(_)\\<parallel>\")"], ["", "end"]]}