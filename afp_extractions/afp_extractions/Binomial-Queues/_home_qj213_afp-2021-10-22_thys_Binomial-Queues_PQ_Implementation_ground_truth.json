{"file_name": "/home/qj213/afp-2021-10-22/thys/Binomial-Queues/PQ_Implementation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binomial-Queues", "problem_names": ["lemma bt_dfs_simp:\n  \"bt_dfs f t = f t # bts_dfs f (children t)\"", "lemma bts_dfs_append [simp]:\n  \"bts_dfs f (ts @ rs) = bts_dfs f ts @ bts_dfs f rs\"", "lemma set_bts_dfs_rev:\n  \"set (bts_dfs f (rev ts)) = set (bts_dfs f ts)\"", "lemma bts_dfs_rev_distinct:\n  \"distinct (bts_dfs f ts) \\<Longrightarrow> distinct (bts_dfs f (rev ts))\"", "lemma bt_dfs_comp:\n  \"bt_dfs (f \\<circ> g) t = map f (bt_dfs g t)\"\n  \"bts_dfs (f \\<circ> g) ts = map f (bts_dfs g ts)\"", "lemma bt_dfs_comp_distinct:\n  \"distinct (bt_dfs (f \\<circ> g) t) \\<Longrightarrow> distinct (bt_dfs g t)\"\n  \"distinct (bts_dfs (f \\<circ> g) ts) \\<Longrightarrow> distinct (bts_dfs g ts)\"", "lemma bt_dfs_distinct_children:\n  \"distinct (bt_dfs f x) \\<Longrightarrow> distinct (bts_dfs f (children x))\"", "lemma dfs_append:\n  \"dfs f (xs @ ys) = (dfs f xs) @ (dfs f ys)\"", "lemma set_dfs_rev:\n  \"set (dfs f (rev xs)) = set (dfs f xs)\"", "lemma set_dfs_Cons:\n  \"set (dfs f (x # xs)) = set (dfs f xs) \\<union> set (dfs f [x])\"", "lemma dfs_comp:\n  \"dfs (f \\<circ> g) xs = map f (dfs g xs)\"", "lemma dfs_comp_distinct:\n  \"distinct (dfs (f \\<circ> g) xs) \\<Longrightarrow> distinct (dfs g xs)\"", "lemma dfs_distinct_member:\n  \"distinct (dfs f xs) \\<Longrightarrow> \n   Some x \\<in> set xs \\<Longrightarrow> \n   distinct (bt_dfs f x)\"", "lemma dfs_map_Some_idem:\n  \"dfs f (map Some xs) = bts_dfs f xs\"", "lemma alist_split_pre:\n  \"val t = (fst \\<circ> alist) t\"\n  \"priority t = (snd \\<circ> alist) t\"", "lemma alist_split:\n  \"val = fst \\<circ> alist\"\n  \"priority = snd \\<circ> alist\"", "lemma alist_split_set:\n  \"set (dfs val xs) = fst ` set (dfs alist xs)\"\n  \"set (dfs priority xs) = snd ` set (dfs alist xs)\"", "lemma in_set_in_alist:\n  assumes \"Some t \\<in> set xs\"\n  shows \"(val t, priority t) \\<in> set (dfs alist xs)\"", "lemma bts_augment [simp]:\n  \"bts_augment = fold bt_augment\"", "lemma bt_augment_Node [simp]:\n  \"bt_augment (Node a v ts) q = PQ.push v a (fold bt_augment ts q)\"", "lemma bt_augment_simp:\n  \"bt_augment t q = PQ.push (val t) (priority t) (fold bt_augment (children t) q)\"", "lemma bt_augment_v_subset:\n  \"set |q| \\<subseteq> set |bt_augment t q|\"\n  \"set |q| \\<subseteq> set |bts_augment ts q|\"", "lemma bt_augment_v_in:\n  \"v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bt_augment t q|\"\n  \"v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bts_augment ts q|\"", "lemma bt_augment_v_union:\n  \"set |bt_augment t (bt_augment r q)| =\n    set |bt_augment t q| \\<union> set |bt_augment r q|\"\n  \"set |bts_augment ts (bt_augment r q)| =\n    set |bts_augment ts q| \\<union> set |bt_augment r q|\"", "lemma bt_val_augment:\n  shows \"set (bt_dfs val t) \\<union> set |q| = set |bt_augment t q|\"\n  and   \"set (bts_dfs val ts) \\<union> set |q| = set |bts_augment ts q|\"", "lemma vals_pqueue:\n  \"set (vals xs) = set |pqueue xs|\"", "lemma bt_augment_v_push:\n  \"set |bt_augment t (PQ.push v a q)| = set |bt_augment t q| \\<union> {v}\"\n  \"set |bts_augment ts (PQ.push v a q)| = set |bts_augment ts q| \\<union> {v}\"", "lemma bt_augment_v_push_commute:\n  \"set |bt_augment t (PQ.push v a q)| = set |PQ.push v a (bt_augment t q)|\"\n  \"set |bts_augment ts (PQ.push v a q)| = set |PQ.push v a (bts_augment ts q)|\"", "lemma bts_augment_v_union:\n  \"set |bt_augment t (bts_augment rs q)| =\n    set |bt_augment t q| \\<union> set |bts_augment rs q|\"\n  \"set |bts_augment ts (bts_augment rs q)| =\n    set |bts_augment ts q| \\<union> set |bts_augment rs q|\"", "lemma bt_augment_v_commute:\n  \"set |bt_augment t (bt_augment r q)| = set |bt_augment r (bt_augment t q)|\"\n  \"set |bt_augment t (bts_augment rs q)| = set |bts_augment rs (bt_augment t q)|\"\n  \"set |bts_augment ts (bts_augment rs q)| =\n    set |bts_augment rs (bts_augment ts q)|\"", "lemma bt_augment_v_merge:\n  \"set |bt_augment (merge t r) q| = set |bt_augment t (bt_augment r q)|\"", "lemma vals_merge [simp]:\n  \"set (bt_dfs val (merge t r)) = set (bt_dfs val t) \\<union> set (bt_dfs val r)\"", "lemma vals_merge_distinct:\n  \"distinct (bt_dfs val t) \\<Longrightarrow> distinct (bt_dfs val r) \\<Longrightarrow>\n   set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {} \\<Longrightarrow> \n   distinct (bt_dfs val (merge t r))\"", "lemma vals_add_Cons:\n  \"set (vals (add x xs)) = set (vals (x # xs))\"", "lemma vals_add_distinct:\n  assumes \"distinct (vals xs)\"\n  and \"distinct (dfs val [x])\"\n  and \"set (vals xs) \\<inter> set (dfs val [x]) = {}\"\n  shows \"distinct (vals (add x xs))\"", "lemma vals_insert [simp]:\n  \"set (vals (insert a v xs)) = set (vals xs) \\<union> {v}\"", "lemma insert_v_push:\n  \"set (vals (insert a v xs)) = set |PQ.push v a (pqueue xs)|\"", "lemma vals_meld:\n  \"set (dfs val (meld xs ys)) = set (dfs val xs) \\<union> set (dfs val ys)\"", "lemma vals_meld_distinct:\n  \"distinct (dfs val xs) \\<Longrightarrow> distinct (dfs val ys) \\<Longrightarrow>\n   set (dfs val xs) \\<inter> set (dfs val ys) = {} \\<Longrightarrow>\n   distinct (dfs val (meld xs ys))\"", "lemma bt_augment_alist_subset:\n  \"set (PQ.alist_of q) \\<subseteq> set (PQ.alist_of (bt_augment t q))\"\n  \"set (PQ.alist_of q) \\<subseteq> set (PQ.alist_of (bts_augment ts q))\"", "lemma bt_augment_alist_in:\n  \"(v,a) \\<in> set (PQ.alist_of q) \\<Longrightarrow> (v,a) \\<in> set (PQ.alist_of (bt_augment t q))\"\n  \"(v,a) \\<in> set (PQ.alist_of q) \\<Longrightarrow> (v,a) \\<in> set (PQ.alist_of (bts_augment ts q))\"", "lemma bt_augment_alist_union:\n  \"distinct (bts_dfs val (r # [t])) \\<Longrightarrow> \n   set (bts_dfs val (r # [t])) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (PQ.alist_of (bt_augment t (bt_augment r q))) =\n     set (PQ.alist_of (bt_augment t q)) \\<union> set (PQ.alist_of (bt_augment r q))\"\n  \n  \"distinct (bts_dfs val (r # ts)) \\<Longrightarrow> \n   set (bts_dfs val (r # ts)) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (PQ.alist_of (bts_augment ts (bt_augment r q))) =\n     set (PQ.alist_of (bts_augment ts q)) \\<union> set (PQ.alist_of (bt_augment r q))\"", "lemma bt_alist_augment:\n  \"distinct (bt_dfs val t) \\<Longrightarrow> \n   set (bt_dfs val t) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (bt_dfs alist t) \\<union> set (PQ.alist_of q) = set (PQ.alist_of (bt_augment t q))\"\n  \n  \"distinct (bts_dfs val ts) \\<Longrightarrow> \n   set (bts_dfs val ts) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (bts_dfs alist ts) \\<union> set (PQ.alist_of q) =\n     set (PQ.alist_of (bts_augment ts q))\"", "lemma alist_pqueue:\n  \"distinct (vals xs) \\<Longrightarrow> set (dfs alist xs) = set (PQ.alist_of (pqueue xs))\"", "lemma alist_pqueue_priority:\n  \"distinct (vals xs) \\<Longrightarrow> (v, a) \\<in> set (dfs alist xs)\n    \\<Longrightarrow> PQ.priority (pqueue xs) v = Some a\"", "lemma prios_pqueue:\n  \"distinct (vals xs) \\<Longrightarrow> set (prios xs) = set \\<parallel>pqueue xs\\<parallel>\"", "lemma alist_merge [simp]:\n  \"distinct (bt_dfs val t) \\<Longrightarrow> distinct (bt_dfs val r) \\<Longrightarrow>\n   set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {} \\<Longrightarrow> \n   set (bt_dfs alist (merge t r)) = set (bt_dfs alist t) \\<union> set (bt_dfs alist r)\"", "lemma alist_add_Cons:\n  assumes \"distinct (vals (x#xs))\"\n  shows \"set (dfs alist (add x xs)) = set (dfs alist (x # xs))\"", "lemma alist_insert [simp]:\n  \"distinct (vals xs) \\<Longrightarrow> \n   v \\<notin> set (vals xs) \\<Longrightarrow>\n   set (dfs alist (insert a v xs)) = set (dfs alist xs) \\<union> {(v,a)}\"", "lemma insert_push:\n  \"distinct (vals xs) \\<Longrightarrow>\n   v \\<notin> set (vals xs) \\<Longrightarrow>\n   set (dfs alist (insert a v xs)) = set (PQ.alist_of (PQ.push v a (pqueue xs)))\"", "lemma insert_p_push:\n  assumes \"distinct (vals xs)\"\n  and \"v \\<notin> set (vals xs)\"\n  shows \"set (prios (insert a v xs)) = set \\<parallel>PQ.push v a (pqueue xs)\\<parallel>\"", "lemma empty_empty:\n  \"normalized xs \\<Longrightarrow> xs = empty \\<longleftrightarrow> PQ.is_empty (pqueue xs)\"", "lemma bt_dfs_Min_priority:\n  assumes \"is_heap t\"\n  shows \"priority t = Min (set (bt_dfs priority t))\"", "lemma is_binqueue_min_Min_prios:\n  assumes \"is_binqueue l xs\"\n  and \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  shows \"min xs = Some (Min (set (prios xs)))\"", "lemma min_p_min:\n  assumes \"is_binqueue l xs\"\n  and \"xs \\<noteq> []\"\n  and \"normalized xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  shows \"min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))\"", "lemma find_min_p_min:\n  assumes \"is_binqueue l xs\"\n  and \"xs \\<noteq> []\"\n  and \"normalized xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  shows \"priority (the (find_min xs)) =\n    the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\"", "lemma find_min_v_min:\n  assumes \"is_binqueue l xs\"\n  and \"xs \\<noteq> []\"\n  and \"normalized xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  shows \"val (the (find_min xs)) = PQ.min (pqueue xs)\"", "lemma alist_normalize_idem:\n  \"dfs alist (normalize xs) = dfs alist xs\"", "lemma dfs_match_not_in:\n  \"(\\<forall> t. Some t \\<in> set xs \\<longrightarrow> priority t \\<noteq> a) \\<Longrightarrow>\n    set (dfs f (map (match a) xs)) = set (dfs f xs)\"", "lemma dfs_match_subset:\n  \"set (dfs f (map (match a) xs)) \\<subseteq> set (dfs f xs)\"", "lemma dfs_match_distinct:\n  \"distinct (dfs f xs) \\<Longrightarrow> distinct (dfs f (map (match a) xs))\"", "lemma dfs_match:\n  \"distinct (prios xs) \\<Longrightarrow> \n   distinct (dfs f xs) \\<Longrightarrow>\n   Some t \\<in> set xs \\<Longrightarrow> \n   priority t = a \\<Longrightarrow> \n   set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)\"", "lemma alist_meld:\n  \"distinct (dfs val xs) \\<Longrightarrow> distinct (dfs val ys) \\<Longrightarrow>\n   set (dfs val xs) \\<inter> set (dfs val ys) = {} \\<Longrightarrow>\n   set (dfs alist (meld xs ys)) = set (dfs alist xs) \\<union> set (dfs alist ys)\"", "lemma alist_delete_min:\n  assumes \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  and \"find_min xs = Some (Node a v ts)\"\n  shows \"set (dfs alist (delete_min xs)) = set (dfs alist xs) - {(v, a)}\"", "lemma alist_remove_min:\n  assumes \"is_binqueue l xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  and \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  shows \"set (dfs alist (delete_min xs)) =\n  set (PQ.alist_of (PQ.remove_min (pqueue xs)))\""], "translations": [["", "lemma bt_dfs_simp:\n  \"bt_dfs f t = f t # bts_dfs f (children t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bt_dfs f t = f t # bts_dfs f (children t)", "by (cases t) simp_all"], ["", "lemma bts_dfs_append [simp]:\n  \"bts_dfs f (ts @ rs) = bts_dfs f ts @ bts_dfs f rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bts_dfs f (ts @ rs) = bts_dfs f ts @ bts_dfs f rs", "by (induct ts) simp_all"], ["", "lemma set_bts_dfs_rev:\n  \"set (bts_dfs f (rev ts)) = set (bts_dfs f ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (bts_dfs f (rev ts)) = set (bts_dfs f ts)", "by (induct ts) auto"], ["", "lemma bts_dfs_rev_distinct:\n  \"distinct (bts_dfs f ts) \\<Longrightarrow> distinct (bts_dfs f (rev ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (bts_dfs f ts) \\<Longrightarrow> distinct (bts_dfs f (rev ts))", "by (induct ts) (auto simp add: set_bts_dfs_rev)"], ["", "lemma bt_dfs_comp:\n  \"bt_dfs (f \\<circ> g) t = map f (bt_dfs g t)\"\n  \"bts_dfs (f \\<circ> g) ts = map f (bts_dfs g ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bt_dfs (f \\<circ> g) t = map f (bt_dfs g t) &&&\n    bts_dfs (f \\<circ> g) ts = map f (bts_dfs g ts)", "by (induct t and ts rule: bt_dfs.induct bts_dfs.induct) simp_all"], ["", "lemma bt_dfs_comp_distinct:\n  \"distinct (bt_dfs (f \\<circ> g) t) \\<Longrightarrow> distinct (bt_dfs g t)\"\n  \"distinct (bts_dfs (f \\<circ> g) ts) \\<Longrightarrow> distinct (bts_dfs g ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct (bt_dfs (f \\<circ> g) t) \\<Longrightarrow>\n     distinct (bt_dfs g t)) &&&\n    (distinct (bts_dfs (f \\<circ> g) ts) \\<Longrightarrow>\n     distinct (bts_dfs g ts))", "by (simp_all add: bt_dfs_comp distinct_map [of f])"], ["", "lemma bt_dfs_distinct_children:\n  \"distinct (bt_dfs f x) \\<Longrightarrow> distinct (bts_dfs f (children x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (bt_dfs f x) \\<Longrightarrow>\n    distinct (bts_dfs f (children x))", "by (cases x) simp"], ["", "fun dfs :: \"(('a::linorder, 'b) bintree \\<Rightarrow> 'c) \\<Rightarrow> ('a, 'b) binqueue \\<Rightarrow> 'c list\" where\n  \"dfs f [] = []\"\n| \"dfs f (None # xs) = dfs f xs\"\n| \"dfs f (Some t # xs) = bt_dfs f t @ dfs f xs\""], ["", "lemma dfs_append:\n  \"dfs f (xs @ ys) = (dfs f xs) @ (dfs f ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs f (xs @ ys) = dfs f xs @ dfs f ys", "by (induct xs) simp_all"], ["", "lemma set_dfs_rev:\n  \"set (dfs f (rev xs)) = set (dfs f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs f (rev xs)) = set (dfs f xs)", "by (induct xs) (auto simp add: dfs_append)"], ["", "lemma set_dfs_Cons:\n  \"set (dfs f (x # xs)) = set (dfs f xs) \\<union> set (dfs f [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs f (x # xs)) = set (dfs f xs) \\<union> set (dfs f [x])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (dfs f (x # xs)) = set (dfs f xs) \\<union> set (dfs f [x])", "have \"set (dfs f (x # xs)) = set (dfs f (rev xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs f (x # xs)) = set (dfs f (rev xs @ [x]))", "using set_dfs_rev[of f \"rev xs @ [x]\"]"], ["proof (prove)\nusing this:\n  set (dfs f (rev (rev xs @ [x]))) = set (dfs f (rev xs @ [x]))\n\ngoal (1 subgoal):\n 1. set (dfs f (x # xs)) = set (dfs f (rev xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  set (dfs f (x # xs)) = set (dfs f (rev xs @ [x]))\n\ngoal (1 subgoal):\n 1. set (dfs f (x # xs)) = set (dfs f xs) \\<union> set (dfs f [x])", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (dfs f (x # xs)) = set (dfs f (rev xs @ [x]))\n\ngoal (1 subgoal):\n 1. set (dfs f (x # xs)) = set (dfs f xs) \\<union> set (dfs f [x])", "by (simp add: dfs_append set_dfs_rev)"], ["proof (state)\nthis:\n  set (dfs f (x # xs)) = set (dfs f xs) \\<union> set (dfs f [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dfs_comp:\n  \"dfs (f \\<circ> g) xs = map f (dfs g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs (f \\<circ> g) xs = map f (dfs g xs)", "by (induct xs) (simp_all add: bt_dfs_comp del: o_apply)"], ["", "lemma dfs_comp_distinct:\n  \"distinct (dfs (f \\<circ> g) xs) \\<Longrightarrow> distinct (dfs g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (dfs (f \\<circ> g) xs) \\<Longrightarrow> distinct (dfs g xs)", "by (simp add: dfs_comp distinct_map[of f])"], ["", "lemma dfs_distinct_member:\n  \"distinct (dfs f xs) \\<Longrightarrow> \n   Some x \\<in> set xs \\<Longrightarrow> \n   distinct (bt_dfs f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (dfs f xs); Some x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> distinct (bt_dfs f x)", "proof (induct xs arbitrary: x)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct (dfs f []); Some x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f x)\n 2. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>distinct (dfs f xs);\n                    Some x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (bt_dfs f x);\n        distinct (dfs f (None # xs)); Some x \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f x)\n 3. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>distinct (dfs f xs);\n                    Some x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (bt_dfs f x);\n        distinct (dfs f (Some x # xs));\n        Some xa \\<in> set (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f xa)", "case (Some r xs t)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (dfs f xs); Some ?x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (bt_dfs f ?x)\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct (dfs f []); Some x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f x)\n 2. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>distinct (dfs f xs);\n                    Some x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (bt_dfs f x);\n        distinct (dfs f (None # xs)); Some x \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f x)\n 3. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>distinct (dfs f xs);\n                    Some x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (bt_dfs f x);\n        distinct (dfs f (Some x # xs));\n        Some xa \\<in> set (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f xa)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (dfs f xs); Some ?x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (bt_dfs f ?x)\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (dfs f xs); Some ?x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (bt_dfs f ?x)\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n\ngoal (1 subgoal):\n 1. distinct (bt_dfs f t)", "by (cases \"t = r\") simp_all"], ["proof (state)\nthis:\n  distinct (bt_dfs f t)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct (dfs f []); Some x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f x)\n 2. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>distinct (dfs f xs);\n                    Some x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> distinct (bt_dfs f x);\n        distinct (dfs f (None # xs)); Some x \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct (bt_dfs f x)", "qed simp_all"], ["", "lemma dfs_map_Some_idem:\n  \"dfs f (map Some xs) = bts_dfs f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs f (map Some xs) = bts_dfs f xs", "by (induct xs) simp_all"], ["", "primrec alist :: \"('a, 'b) bintree \\<Rightarrow> ('b \\<times> 'a)\" where\n  \"alist (Node a v _) = (v, a)\""], ["", "lemma alist_split_pre:\n  \"val t = (fst \\<circ> alist) t\"\n  \"priority t = (snd \\<circ> alist) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val t = (fst \\<circ> alist) t &&& priority t = (snd \\<circ> alist) t", "by (cases t, simp)+"], ["", "lemma alist_split:\n  \"val = fst \\<circ> alist\"\n  \"priority = snd \\<circ> alist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val = fst \\<circ> alist &&& priority = snd \\<circ> alist", "by (auto intro!: ext simp add: alist_split_pre)"], ["", "lemma alist_split_set:\n  \"set (dfs val xs) = fst ` set (dfs alist xs)\"\n  \"set (dfs priority xs) = snd ` set (dfs alist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs val xs) = fst ` set (dfs alist xs) &&&\n    set (dfs priority xs) = snd ` set (dfs alist xs)", "by (auto simp add: dfs_comp alist_split)"], ["", "lemma in_set_in_alist:\n  assumes \"Some t \\<in> set xs\"\n  shows \"(val t, priority t) \\<in> set (dfs alist xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (val t, priority t) \\<in> set (dfs alist xs)", "using assms"], ["proof (prove)\nusing this:\n  Some t \\<in> set xs\n\ngoal (1 subgoal):\n 1. (val t, priority t) \\<in> set (dfs alist xs)", "proof (induct xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. Some t \\<in> set [] \\<Longrightarrow>\n    (val t, priority t) \\<in> set (dfs alist [])\n 2. \\<And>xs.\n       \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n                (val t, priority t) \\<in> set (dfs alist xs);\n        Some t \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (val t, priority t)\n                         \\<in> set (dfs alist (None # xs))\n 3. \\<And>x xs.\n       \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n                (val t, priority t) \\<in> set (dfs alist xs);\n        Some t \\<in> set (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> (val t, priority t)\n                         \\<in> set (dfs alist (Some x # xs))", "case (Some x xs)"], ["proof (state)\nthis:\n  Some t \\<in> set xs \\<Longrightarrow>\n  (val t, priority t) \\<in> set (dfs alist xs)\n  Some t \\<in> set (Some x # xs)\n\ngoal (3 subgoals):\n 1. Some t \\<in> set [] \\<Longrightarrow>\n    (val t, priority t) \\<in> set (dfs alist [])\n 2. \\<And>xs.\n       \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n                (val t, priority t) \\<in> set (dfs alist xs);\n        Some t \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (val t, priority t)\n                         \\<in> set (dfs alist (None # xs))\n 3. \\<And>x xs.\n       \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n                (val t, priority t) \\<in> set (dfs alist xs);\n        Some t \\<in> set (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> (val t, priority t)\n                         \\<in> set (dfs alist (Some x # xs))", "then"], ["proof (chain)\npicking this:\n  Some t \\<in> set xs \\<Longrightarrow>\n  (val t, priority t) \\<in> set (dfs alist xs)\n  Some t \\<in> set (Some x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  Some t \\<in> set xs \\<Longrightarrow>\n  (val t, priority t) \\<in> set (dfs alist xs)\n  Some t \\<in> set (Some x # xs)\n\ngoal (1 subgoal):\n 1. (val t, priority t) \\<in> set (dfs alist (Some x # xs))", "proof (cases \"Some t \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n             (val t, priority t) \\<in> set (dfs alist xs);\n     Some t \\<in> set (Some x # xs); Some t \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> (val t, priority t)\n                      \\<in> set (dfs alist (Some x # xs))\n 2. \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n             (val t, priority t) \\<in> set (dfs alist xs);\n     Some t \\<in> set (Some x # xs); Some t \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> (val t, priority t)\n                      \\<in> set (dfs alist (Some x # xs))", "case False"], ["proof (state)\nthis:\n  Some t \\<notin> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n             (val t, priority t) \\<in> set (dfs alist xs);\n     Some t \\<in> set (Some x # xs); Some t \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> (val t, priority t)\n                      \\<in> set (dfs alist (Some x # xs))\n 2. \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n             (val t, priority t) \\<in> set (dfs alist xs);\n     Some t \\<in> set (Some x # xs); Some t \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> (val t, priority t)\n                      \\<in> set (dfs alist (Some x # xs))", "with Some"], ["proof (chain)\npicking this:\n  Some t \\<in> set xs \\<Longrightarrow>\n  (val t, priority t) \\<in> set (dfs alist xs)\n  Some t \\<in> set (Some x # xs)\n  Some t \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  Some t \\<in> set xs \\<Longrightarrow>\n  (val t, priority t) \\<in> set (dfs alist xs)\n  Some t \\<in> set (Some x # xs)\n  Some t \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (val t, priority t) \\<in> set (dfs alist (Some x # xs))", "by (cases t) (auto simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  (val t, priority t) \\<in> set (dfs alist (Some x # xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n             (val t, priority t) \\<in> set (dfs alist xs);\n     Some t \\<in> set (Some x # xs); Some t \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> (val t, priority t)\n                      \\<in> set (dfs alist (Some x # xs))", "qed simp"], ["proof (state)\nthis:\n  (val t, priority t) \\<in> set (dfs alist (Some x # xs))\n\ngoal (2 subgoals):\n 1. Some t \\<in> set [] \\<Longrightarrow>\n    (val t, priority t) \\<in> set (dfs alist [])\n 2. \\<And>xs.\n       \\<lbrakk>Some t \\<in> set xs \\<Longrightarrow>\n                (val t, priority t) \\<in> set (dfs alist xs);\n        Some t \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> (val t, priority t)\n                         \\<in> set (dfs alist (None # xs))", "qed simp_all"], ["", "abbreviation vals where \"vals \\<equiv> dfs val\""], ["", "abbreviation prios where \"prios \\<equiv> dfs priority\""], ["", "abbreviation elements where \"elements \\<equiv> dfs alist\""], ["", "primrec\n  bt_augment :: \"('a::linorder, 'b) bintree \\<Rightarrow> ('b, 'a) PQ.pq \\<Rightarrow> ('b, 'a) PQ.pq\"\nand\n  bts_augment :: \"('a::linorder, 'b) bintree list \\<Rightarrow> ('b, 'a) PQ.pq \\<Rightarrow> ('b, 'a) PQ.pq\"\nwhere\n  \"bt_augment (Node a v ts) q = PQ.push v a (bts_augment ts q)\"\n| \"bts_augment [] q = q\"\n| \"bts_augment (t # ts) q = bts_augment ts (bt_augment t q)\""], ["", "lemma bts_augment [simp]:\n  \"bts_augment = fold bt_augment\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bts_augment = fold bt_augment", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. bts_augment x = fold bt_augment x", "fix ts :: \"('a, 'b) bintree list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. bts_augment x = fold bt_augment x", "show \"bts_augment ts = fold bt_augment ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bts_augment ts = fold bt_augment ts", "by (induct ts) simp_all"], ["proof (state)\nthis:\n  bts_augment ts = fold bt_augment ts\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bt_augment_Node [simp]:\n  \"bt_augment (Node a v ts) q = PQ.push v a (fold bt_augment ts q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bt_augment (Node a v ts) q = PQ.push v a (fold bt_augment ts q)", "by (simp add: bts_augment)"], ["", "lemma bt_augment_simp:\n  \"bt_augment t q = PQ.push (val t) (priority t) (fold bt_augment (children t) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bt_augment t q =\n    PQ.push (val t) (priority t) (fold bt_augment (children t) q)", "by (cases t) (simp_all add: bts_augment)"], ["", "declare bt_augment.simps [simp del] bts_augment.simps [simp del]"], ["", "fun pqueue :: \"('a::linorder, 'b) binqueue \\<Rightarrow> ('b, 'a) PQ.pq\" where\n  Empty: \"pqueue [] = PQ.empty\"\n| None: \"pqueue (None # xs) = pqueue xs\"\n| Some: \"pqueue (Some t # xs) = bt_augment t (pqueue xs)\""], ["", "lemma bt_augment_v_subset:\n  \"set |q| \\<subseteq> set |bt_augment t q|\"\n  \"set |q| \\<subseteq> set |bts_augment ts q|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |q| \\<subseteq> set |bt_augment t q| &&&\n    set |q| \\<subseteq> set |bts_augment ts q|", "by (induct t and ts arbitrary: q and q rule: bt_augment.induct bts_augment.induct) auto"], ["", "lemma bt_augment_v_in:\n  \"v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bt_augment t q|\"\n  \"v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bts_augment ts q|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bt_augment t q|) &&&\n    (v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bts_augment ts q|)", "using bt_augment_v_subset[of q]"], ["proof (prove)\nusing this:\n  set |q| \\<subseteq> set |bt_augment ?t q|\n  set |q| \\<subseteq> set |bts_augment ?ts q|\n\ngoal (1 subgoal):\n 1. (v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bt_augment t q|) &&&\n    (v \\<in> set |q| \\<Longrightarrow> v \\<in> set |bts_augment ts q|)", "by auto"], ["", "lemma bt_augment_v_union:\n  \"set |bt_augment t (bt_augment r q)| =\n    set |bt_augment t q| \\<union> set |bt_augment r q|\"\n  \"set |bts_augment ts (bt_augment r q)| =\n    set |bts_augment ts q| \\<union> set |bt_augment r q|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bt_augment t (bt_augment r q)| =\n    set |bt_augment t q| \\<union> set |bt_augment r q| &&&\n    set |bts_augment ts (bt_augment r q)| =\n    set |bts_augment ts q| \\<union> set |bt_augment r q|", "proof (induct t and ts arbitrary: q r and q r rule: bt_augment.induct bts_augment.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       (\\<And>q r.\n           set |bts_augment x3 (bt_augment r q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bt_augment r q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bt_augment r q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bt_augment r q|\n 2. \\<And>q r.\n       set |bts_augment [] (bt_augment r q)| =\n       set |bts_augment [] q| \\<union> set |bt_augment r q|\n 3. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   set |bt_augment x1 (bt_augment r q)| =\n                   set |bt_augment x1 q| \\<union> set |bt_augment r q|;\n        \\<And>q r.\n           set |bts_augment x2 (bt_augment r q)| =\n           set |bts_augment x2 q| \\<union> set |bt_augment r q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bt_augment r q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bt_augment r q|", "case Nil_bintree"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       (\\<And>q r.\n           set |bts_augment x3 (bt_augment r q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bt_augment r q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bt_augment r q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bt_augment r q|\n 2. \\<And>q r.\n       set |bts_augment [] (bt_augment r q)| =\n       set |bts_augment [] q| \\<union> set |bt_augment r q|\n 3. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   set |bt_augment x1 (bt_augment r q)| =\n                   set |bt_augment x1 q| \\<union> set |bt_augment r q|;\n        \\<And>q r.\n           set |bts_augment x2 (bt_augment r q)| =\n           set |bts_augment x2 q| \\<union> set |bt_augment r q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bt_augment r q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bt_augment r q|", "from bt_augment_v_subset[of q]"], ["proof (chain)\npicking this:\n  set |q| \\<subseteq> set |bt_augment ?t q|\n  set |q| \\<subseteq> set |bts_augment ?ts q|", "show ?case"], ["proof (prove)\nusing this:\n  set |q| \\<subseteq> set |bt_augment ?t q|\n  set |q| \\<subseteq> set |bts_augment ?ts q|\n\ngoal (1 subgoal):\n 1. set |bts_augment [] (bt_augment r q)| =\n    set |bts_augment [] q| \\<union> set |bt_augment r q|", "by auto"], ["proof (state)\nthis:\n  set |bts_augment [] (bt_augment r q)| =\n  set |bts_augment [] q| \\<union> set |bt_augment r q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       (\\<And>q r.\n           set |bts_augment x3 (bt_augment r q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bt_augment r q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bt_augment r q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bt_augment r q|\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   set |bt_augment x1 (bt_augment r q)| =\n                   set |bt_augment x1 q| \\<union> set |bt_augment r q|;\n        \\<And>q r.\n           set |bts_augment x2 (bt_augment r q)| =\n           set |bts_augment x2 q| \\<union> set |bt_augment r q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bt_augment r q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bt_augment r q|", "qed auto"], ["", "lemma bt_val_augment:\n  shows \"set (bt_dfs val t) \\<union> set |q| = set |bt_augment t q|\"\n  and   \"set (bts_dfs val ts) \\<union> set |q| = set |bts_augment ts q|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<union> set |q| = set |bt_augment t q| &&&\n    set (bts_dfs val ts) \\<union> set |q| = set |bts_augment ts q|", "proof (induct t and ts rule: bt_augment.induct bts_augment.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       set (bts_dfs val x3) \\<union> set |q| =\n       set |bts_augment x3 q| \\<Longrightarrow>\n       set (bt_dfs val (Node x1 x2 x3)) \\<union> set |q| =\n       set |bt_augment (Node x1 x2 x3) q|\n 2. set (bts_dfs val []) \\<union> set |q| = set |bts_augment [] q|\n 3. \\<And>x1 x2.\n       \\<lbrakk>set (bt_dfs val x1) \\<union> set |q| =\n                set |bt_augment x1 q|;\n        set (bts_dfs val x2) \\<union> set |q| =\n        set |bts_augment x2 q|\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs val (x1 # x2)) \\<union> set |q| =\n                         set |bts_augment (x1 # x2) q|", "case (Cons_bintree r rs)"], ["proof (state)\nthis:\n  set (bt_dfs val r) \\<union> set |q| = set |bt_augment r q|\n  set (bts_dfs val rs) \\<union> set |q| = set |bts_augment rs q|\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       set (bts_dfs val x3) \\<union> set |q| =\n       set |bts_augment x3 q| \\<Longrightarrow>\n       set (bt_dfs val (Node x1 x2 x3)) \\<union> set |q| =\n       set |bt_augment (Node x1 x2 x3) q|\n 2. set (bts_dfs val []) \\<union> set |q| = set |bts_augment [] q|\n 3. \\<And>x1 x2.\n       \\<lbrakk>set (bt_dfs val x1) \\<union> set |q| =\n                set |bt_augment x1 q|;\n        set (bts_dfs val x2) \\<union> set |q| =\n        set |bts_augment x2 q|\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs val (x1 # x2)) \\<union> set |q| =\n                         set |bts_augment (x1 # x2) q|", "have \"set |bts_augment rs (bt_augment r q)| =\n    set |bts_augment rs q| \\<union> set |bt_augment r q|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bts_augment rs (bt_augment r q)| =\n    set |bts_augment rs q| \\<union> set |bt_augment r q|", "by (simp only: bt_augment_v_union)"], ["proof (state)\nthis:\n  set |bts_augment rs (bt_augment r q)| =\n  set |bts_augment rs q| \\<union> set |bt_augment r q|\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       set (bts_dfs val x3) \\<union> set |q| =\n       set |bts_augment x3 q| \\<Longrightarrow>\n       set (bt_dfs val (Node x1 x2 x3)) \\<union> set |q| =\n       set |bt_augment (Node x1 x2 x3) q|\n 2. set (bts_dfs val []) \\<union> set |q| = set |bts_augment [] q|\n 3. \\<And>x1 x2.\n       \\<lbrakk>set (bt_dfs val x1) \\<union> set |q| =\n                set |bt_augment x1 q|;\n        set (bts_dfs val x2) \\<union> set |q| =\n        set |bts_augment x2 q|\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs val (x1 # x2)) \\<union> set |q| =\n                         set |bts_augment (x1 # x2) q|", "with bt_augment_v_subset[of q]"], ["proof (chain)\npicking this:\n  set |q| \\<subseteq> set |bt_augment ?t q|\n  set |q| \\<subseteq> set |bts_augment ?ts q|\n  set |bts_augment rs (bt_augment r q)| =\n  set |bts_augment rs q| \\<union> set |bt_augment r q|", "have \"set |bts_augment rs (bt_augment r q)| =\n      set |bts_augment rs q| \\<union> set |bt_augment r q| \\<union> set |q|\""], ["proof (prove)\nusing this:\n  set |q| \\<subseteq> set |bt_augment ?t q|\n  set |q| \\<subseteq> set |bts_augment ?ts q|\n  set |bts_augment rs (bt_augment r q)| =\n  set |bts_augment rs q| \\<union> set |bt_augment r q|\n\ngoal (1 subgoal):\n 1. set |bts_augment rs (bt_augment r q)| =\n    set |bts_augment rs q| \\<union> set |bt_augment r q| \\<union> set |q|", "by auto"], ["proof (state)\nthis:\n  set |bts_augment rs (bt_augment r q)| =\n  set |bts_augment rs q| \\<union> set |bt_augment r q| \\<union> set |q|\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       set (bts_dfs val x3) \\<union> set |q| =\n       set |bts_augment x3 q| \\<Longrightarrow>\n       set (bt_dfs val (Node x1 x2 x3)) \\<union> set |q| =\n       set |bt_augment (Node x1 x2 x3) q|\n 2. set (bts_dfs val []) \\<union> set |q| = set |bts_augment [] q|\n 3. \\<And>x1 x2.\n       \\<lbrakk>set (bt_dfs val x1) \\<union> set |q| =\n                set |bt_augment x1 q|;\n        set (bts_dfs val x2) \\<union> set |q| =\n        set |bts_augment x2 q|\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs val (x1 # x2)) \\<union> set |q| =\n                         set |bts_augment (x1 # x2) q|", "with Cons_bintree"], ["proof (chain)\npicking this:\n  set (bt_dfs val r) \\<union> set |q| = set |bt_augment r q|\n  set (bts_dfs val rs) \\<union> set |q| = set |bts_augment rs q|\n  set |bts_augment rs (bt_augment r q)| =\n  set |bts_augment rs q| \\<union> set |bt_augment r q| \\<union> set |q|", "show ?case"], ["proof (prove)\nusing this:\n  set (bt_dfs val r) \\<union> set |q| = set |bt_augment r q|\n  set (bts_dfs val rs) \\<union> set |q| = set |bts_augment rs q|\n  set |bts_augment rs (bt_augment r q)| =\n  set |bts_augment rs q| \\<union> set |bt_augment r q| \\<union> set |q|\n\ngoal (1 subgoal):\n 1. set (bts_dfs val (r # rs)) \\<union> set |q| =\n    set |bts_augment (r # rs) q|", "by auto"], ["proof (state)\nthis:\n  set (bts_dfs val (r # rs)) \\<union> set |q| = set |bts_augment (r # rs) q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       set (bts_dfs val x3) \\<union> set |q| =\n       set |bts_augment x3 q| \\<Longrightarrow>\n       set (bt_dfs val (Node x1 x2 x3)) \\<union> set |q| =\n       set |bt_augment (Node x1 x2 x3) q|\n 2. set (bts_dfs val []) \\<union> set |q| = set |bts_augment [] q|", "qed auto"], ["", "lemma vals_pqueue:\n  \"set (vals xs) = set |pqueue xs|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (vals xs) = set |pqueue xs|", "by (induct xs) (simp_all add: bt_val_augment)"], ["", "lemma bt_augment_v_push:\n  \"set |bt_augment t (PQ.push v a q)| = set |bt_augment t q| \\<union> {v}\"\n  \"set |bts_augment ts (PQ.push v a q)| = set |bts_augment ts q| \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bt_augment t (PQ.push v a q)| =\n    set |bt_augment t q| \\<union> {v} &&&\n    set |bts_augment ts (PQ.push v a q)| =\n    set |bts_augment ts q| \\<union> {v}", "using bt_val_augment[where q = \"PQ.push v a q\"]"], ["proof (prove)\nusing this:\n  set (bt_dfs val ?t) \\<union> set |PQ.push v a q| =\n  set |bt_augment ?t (PQ.push v a q)|\n  set (bts_dfs val ?ts) \\<union> set |PQ.push v a q| =\n  set |bts_augment ?ts (PQ.push v a q)|\n\ngoal (1 subgoal):\n 1. set |bt_augment t (PQ.push v a q)| =\n    set |bt_augment t q| \\<union> {v} &&&\n    set |bts_augment ts (PQ.push v a q)| =\n    set |bts_augment ts q| \\<union> {v}", "by (simp_all add: bt_val_augment)"], ["", "lemma bt_augment_v_push_commute:\n  \"set |bt_augment t (PQ.push v a q)| = set |PQ.push v a (bt_augment t q)|\"\n  \"set |bts_augment ts (PQ.push v a q)| = set |PQ.push v a (bts_augment ts q)|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bt_augment t (PQ.push v a q)| =\n    set |PQ.push v a (bt_augment t q)| &&&\n    set |bts_augment ts (PQ.push v a q)| =\n    set |PQ.push v a (bts_augment ts q)|", "by (simp_all add: bt_augment_v_push del: bts_augment)"], ["", "lemma bts_augment_v_union:\n  \"set |bt_augment t (bts_augment rs q)| =\n    set |bt_augment t q| \\<union> set |bts_augment rs q|\"\n  \"set |bts_augment ts (bts_augment rs q)| =\n    set |bts_augment ts q| \\<union> set |bts_augment rs q|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bt_augment t (bts_augment rs q)| =\n    set |bt_augment t q| \\<union> set |bts_augment rs q| &&&\n    set |bts_augment ts (bts_augment rs q)| =\n    set |bts_augment ts q| \\<union> set |bts_augment rs q|", "proof (induct t and ts arbitrary: q rs and q rs rule: bt_augment.induct bts_augment.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>q rs.\n       set |bts_augment [] (bts_augment rs q)| =\n       set |bts_augment [] q| \\<union> set |bts_augment rs q|\n 3. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "case Nil_bintree"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>q rs.\n       set |bts_augment [] (bts_augment rs q)| =\n       set |bts_augment [] q| \\<union> set |bts_augment rs q|\n 3. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "from bt_augment_v_subset[of q]"], ["proof (chain)\npicking this:\n  set |q| \\<subseteq> set |bt_augment ?t q|\n  set |q| \\<subseteq> set |bts_augment ?ts q|", "show ?case"], ["proof (prove)\nusing this:\n  set |q| \\<subseteq> set |bt_augment ?t q|\n  set |q| \\<subseteq> set |bts_augment ?ts q|\n\ngoal (1 subgoal):\n 1. set |bts_augment [] (bts_augment rs q)| =\n    set |bts_augment [] q| \\<union> set |bts_augment rs q|", "by auto"], ["proof (state)\nthis:\n  set |bts_augment [] (bts_augment rs q)| =\n  set |bts_augment [] q| \\<union> set |bts_augment rs q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "case (Cons_bintree x xs)"], ["proof (state)\nthis:\n  set |bt_augment x (bts_augment ?rs ?q)| =\n  set |bt_augment x ?q| \\<union> set |bts_augment ?rs ?q|\n  set |bts_augment xs (bts_augment ?rs ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bts_augment ?rs ?q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "let ?L = \"set |bts_augment xs (bt_augment x (bts_augment rs q))|\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "from bt_augment_v_union"], ["proof (chain)\npicking this:\n  set |bt_augment ?t (bt_augment ?r ?q)| =\n  set |bt_augment ?t ?q| \\<union> set |bt_augment ?r ?q|\n  set |bts_augment ?ts (bt_augment ?r ?q)| =\n  set |bts_augment ?ts ?q| \\<union> set |bt_augment ?r ?q|", "have *: \"\\<And> q. set |bts_augment xs (bt_augment x q)| =\n      set |bts_augment xs q| \\<union> set |bt_augment x q|\""], ["proof (prove)\nusing this:\n  set |bt_augment ?t (bt_augment ?r ?q)| =\n  set |bt_augment ?t ?q| \\<union> set |bt_augment ?r ?q|\n  set |bts_augment ?ts (bt_augment ?r ?q)| =\n  set |bts_augment ?ts ?q| \\<union> set |bt_augment ?r ?q|\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       set |bts_augment xs (bt_augment x q)| =\n       set |bts_augment xs q| \\<union> set |bt_augment x q|", "by simp"], ["proof (state)\nthis:\n  set |bts_augment xs (bt_augment x ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bt_augment x ?q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "with Cons_bintree"], ["proof (chain)\npicking this:\n  set |bt_augment x (bts_augment ?rs ?q)| =\n  set |bt_augment x ?q| \\<union> set |bts_augment ?rs ?q|\n  set |bts_augment xs (bts_augment ?rs ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bts_augment ?rs ?q|\n  set |bts_augment xs (bt_augment x ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bt_augment x ?q|", "have \"?L =\n      set |bts_augment xs q| \\<union> set |bts_augment rs q| \\<union> set |bt_augment x q|\""], ["proof (prove)\nusing this:\n  set |bt_augment x (bts_augment ?rs ?q)| =\n  set |bt_augment x ?q| \\<union> set |bts_augment ?rs ?q|\n  set |bts_augment xs (bts_augment ?rs ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bts_augment ?rs ?q|\n  set |bts_augment xs (bt_augment x ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bt_augment x ?q|\n\ngoal (1 subgoal):\n 1. set |bts_augment xs (bt_augment x (bts_augment rs q))| =\n    set |bts_augment xs q| \\<union> set |bts_augment rs q| \\<union>\n    set |bt_augment x q|", "by auto"], ["proof (state)\nthis:\n  set |bts_augment xs (bt_augment x (bts_augment rs q))| =\n  set |bts_augment xs q| \\<union> set |bts_augment rs q| \\<union>\n  set |bt_augment x q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|\n 2. \\<And>x1 x2 q rs.\n       \\<lbrakk>\\<And>q rs.\n                   set |bt_augment x1 (bts_augment rs q)| =\n                   set |bt_augment x1 q| \\<union> set |bts_augment rs q|;\n        \\<And>q rs.\n           set |bts_augment x2 (bts_augment rs q)| =\n           set |bts_augment x2 q| \\<union> set |bts_augment rs q|\\<rbrakk>\n       \\<Longrightarrow> set |bts_augment (x1 # x2) (bts_augment rs q)| =\n                         set |bts_augment (x1 # x2) q| \\<union>\n                         set |bts_augment rs q|", "with *"], ["proof (chain)\npicking this:\n  set |bts_augment xs (bt_augment x ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bt_augment x ?q|\n  set |bts_augment xs (bt_augment x (bts_augment rs q))| =\n  set |bts_augment xs q| \\<union> set |bts_augment rs q| \\<union>\n  set |bt_augment x q|", "show ?case"], ["proof (prove)\nusing this:\n  set |bts_augment xs (bt_augment x ?q)| =\n  set |bts_augment xs ?q| \\<union> set |bt_augment x ?q|\n  set |bts_augment xs (bt_augment x (bts_augment rs q))| =\n  set |bts_augment xs q| \\<union> set |bts_augment rs q| \\<union>\n  set |bt_augment x q|\n\ngoal (1 subgoal):\n 1. set |bts_augment (x # xs) (bts_augment rs q)| =\n    set |bts_augment (x # xs) q| \\<union> set |bts_augment rs q|", "by auto"], ["proof (state)\nthis:\n  set |bts_augment (x # xs) (bts_augment rs q)| =\n  set |bts_augment (x # xs) q| \\<union> set |bts_augment rs q|\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 q rs.\n       (\\<And>q rs.\n           set |bts_augment x3 (bts_augment rs q)| =\n           set |bts_augment x3 q| \\<union>\n           set |bts_augment rs q|) \\<Longrightarrow>\n       set |bt_augment (Node x1 x2 x3) (bts_augment rs q)| =\n       set |bt_augment (Node x1 x2 x3) q| \\<union> set |bts_augment rs q|", "qed simp"], ["", "lemma bt_augment_v_commute:\n  \"set |bt_augment t (bt_augment r q)| = set |bt_augment r (bt_augment t q)|\"\n  \"set |bt_augment t (bts_augment rs q)| = set |bts_augment rs (bt_augment t q)|\"\n  \"set |bts_augment ts (bts_augment rs q)| =\n    set |bts_augment rs (bts_augment ts q)|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bt_augment t (bt_augment r q)| =\n    set |bt_augment r (bt_augment t q)| &&&\n    set |bt_augment t (bts_augment rs q)| =\n    set |bts_augment rs (bt_augment t q)| &&&\n    set |bts_augment ts (bts_augment rs q)| =\n    set |bts_augment rs (bts_augment ts q)|", "unfolding bts_augment_v_union bt_augment_v_union"], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bt_augment t q| \\<union> set |bt_augment r q| =\n    set |bt_augment r q| \\<union> set |bt_augment t q| &&&\n    set |bt_augment t q| \\<union> set |bts_augment rs q| =\n    set |bts_augment rs q| \\<union> set |bt_augment t q| &&&\n    set |bts_augment ts q| \\<union> set |bts_augment rs q| =\n    set |bts_augment rs q| \\<union> set |bts_augment ts q|", "by auto"], ["", "lemma bt_augment_v_merge:\n  \"set |bt_augment (merge t r) q| = set |bt_augment t (bt_augment r q)|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set |bt_augment (merge t r) q| = set |bt_augment t (bt_augment r q)|", "by (simp add: bt_augment_simp [symmetric] bt_augment_v_push\n    bt_augment_v_commute merge_def)"], ["", "lemma vals_merge [simp]:\n  \"set (bt_dfs val (merge t r)) = set (bt_dfs val t) \\<union> set (bt_dfs val r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (bt_dfs val (merge t r)) =\n    set (bt_dfs val t) \\<union> set (bt_dfs val r)", "by (auto simp add: bt_dfs_simp merge_def)"], ["", "lemma vals_merge_distinct:\n  \"distinct (bt_dfs val t) \\<Longrightarrow> distinct (bt_dfs val r) \\<Longrightarrow>\n   set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {} \\<Longrightarrow> \n   distinct (bt_dfs val (merge t r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (bt_dfs val t); distinct (bt_dfs val r);\n     set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {}\\<rbrakk>\n    \\<Longrightarrow> distinct (bt_dfs val (merge t r))", "by (auto simp add: bt_dfs_simp merge_def)"], ["", "lemma vals_add_Cons:\n  \"set (vals (add x xs)) = set (vals (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (vals (add x xs)) = set (vals (x # xs))", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = None \\<Longrightarrow> set (vals (add x xs)) = set (vals (x # xs))\n 2. \\<And>a.\n       x = Some a \\<Longrightarrow>\n       set (vals (add x xs)) = set (vals (x # xs))", "case (Some t)"], ["proof (state)\nthis:\n  x = Some t\n\ngoal (2 subgoals):\n 1. x = None \\<Longrightarrow> set (vals (add x xs)) = set (vals (x # xs))\n 2. \\<And>a.\n       x = Some a \\<Longrightarrow>\n       set (vals (add x xs)) = set (vals (x # xs))", "then"], ["proof (chain)\npicking this:\n  x = Some t", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Some t\n\ngoal (1 subgoal):\n 1. set (vals (add x xs)) = set (vals (x # xs))", "by (induct xs arbitrary: x t) auto"], ["proof (state)\nthis:\n  set (vals (add x xs)) = set (vals (x # xs))\n\ngoal (1 subgoal):\n 1. x = None \\<Longrightarrow> set (vals (add x xs)) = set (vals (x # xs))", "qed simp"], ["", "lemma vals_add_distinct:\n  assumes \"distinct (vals xs)\"\n  and \"distinct (dfs val [x])\"\n  and \"set (vals xs) \\<inter> set (dfs val [x]) = {}\"\n  shows \"distinct (vals (add x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (vals (add x xs))", "using assms"], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (vals [x])\n  set (vals xs) \\<inter> set (vals [x]) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (add x xs))", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n     set (vals xs) \\<inter> set (vals [x]) = {}; x = None\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (add x xs))\n 2. \\<And>a.\n       \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n        set (vals xs) \\<inter> set (vals [x]) = {}; x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x xs))", "case (Some t)"], ["proof (state)\nthis:\n  x = Some t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n     set (vals xs) \\<inter> set (vals [x]) = {}; x = None\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (add x xs))\n 2. \\<And>a.\n       \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n        set (vals xs) \\<inter> set (vals [x]) = {}; x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x xs))", "with assms"], ["proof (chain)\npicking this:\n  distinct (vals xs)\n  distinct (vals [x])\n  set (vals xs) \\<inter> set (vals [x]) = {}\n  x = Some t", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (vals [x])\n  set (vals xs) \\<inter> set (vals [x]) = {}\n  x = Some t\n\ngoal (1 subgoal):\n 1. distinct (vals (add x xs))", "proof (induct xs arbitrary: x t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "case (Some r xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t", "have \"set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {}", "by auto"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {}\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "with Some"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n  set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {}", "have \"distinct (bt_dfs val (merge t r))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n  set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {}\n\ngoal (1 subgoal):\n 1. distinct (bt_dfs val (merge t r))", "by (simp add: vals_merge_distinct)"], ["proof (state)\nthis:\n  distinct (bt_dfs val (merge t r))\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "moreover"], ["proof (state)\nthis:\n  distinct (bt_dfs val (merge t r))\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "with Some"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n  distinct (bt_dfs val (merge t r))", "have \"set (vals xs) \\<inter> set (bt_dfs val (merge t r)) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n  distinct (bt_dfs val (merge t r))\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (bt_dfs val (merge t r)) = {}", "by auto"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (bt_dfs val (merge t r)) = {}\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "moreover"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (bt_dfs val (merge t r)) = {}\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "note Some"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n\ngoal (3 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))\n 3. \\<And>x xs xa t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (Some x # xs)); distinct (vals [xa]);\n        set (vals (Some x # xs)) \\<inter> set (vals [xa]) = {};\n        xa = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add xa (Some x # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (bt_dfs val (merge t r))\n  set (vals xs) \\<inter> set (bt_dfs val (merge t r)) = {}\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t", "show ?case"], ["proof (prove)\nusing this:\n  distinct (bt_dfs val (merge t r))\n  set (vals xs) \\<inter> set (bt_dfs val (merge t r)) = {}\n  \\<lbrakk>distinct (vals xs); distinct (vals [?x]);\n   set (vals xs) \\<inter> set (vals [?x]) = {}; ?x = Some ?t\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (add ?x xs))\n  distinct (vals (Some r # xs))\n  distinct (vals [x])\n  set (vals (Some r # xs)) \\<inter> set (vals [x]) = {}\n  x = Some t\n\ngoal (1 subgoal):\n 1. distinct (vals (add x (Some r # xs)))", "by simp"], ["proof (state)\nthis:\n  distinct (vals (add x (Some r # xs)))\n\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>distinct (vals []); distinct (vals [x]);\n        set (vals []) \\<inter> set (vals [x]) = {}; x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x []))\n 2. \\<And>xs x t.\n       \\<lbrakk>\\<And>x t.\n                   \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n                    set (vals xs) \\<inter> set (vals [x]) = {};\n                    x = Some t\\<rbrakk>\n                   \\<Longrightarrow> distinct (vals (add x xs));\n        distinct (vals (None # xs)); distinct (vals [x]);\n        set (vals (None # xs)) \\<inter> set (vals [x]) = {};\n        x = Some t\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (add x (None # xs)))", "qed auto"], ["proof (state)\nthis:\n  distinct (vals (add x xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (vals xs); distinct (vals [x]);\n     set (vals xs) \\<inter> set (vals [x]) = {}; x = None\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (add x xs))", "qed simp"], ["", "lemma vals_insert [simp]:\n  \"set (vals (insert a v xs)) = set (vals xs) \\<union> {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (vals (Binomial_Queue.insert a v xs)) = set (vals xs) \\<union> {v}", "by (simp add: insert_def vals_add_Cons)"], ["", "lemma insert_v_push:\n  \"set (vals (insert a v xs)) = set |PQ.push v a (pqueue xs)|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (vals (Binomial_Queue.insert a v xs)) =\n    set |PQ.push v a (pqueue xs)|", "by (simp add: vals_pqueue[symmetric])"], ["", "lemma vals_meld:\n  \"set (dfs val (meld xs ys)) = set (dfs val xs) \\<union> set (dfs val ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)", "proof (induct xs ys rule: meld.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>xs y ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (None # xs) (y # ys))) =\n       set (vals (None # xs)) \\<union> set (vals (y # ys))\n 4. \\<And>x xs ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (x # xs) (None # ys))) =\n       set (vals (x # xs)) \\<union> set (vals (None # ys))\n 5. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "case (3 xs y ys)"], ["proof (state)\nthis:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n\ngoal (5 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>xs y ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (None # xs) (y # ys))) =\n       set (vals (None # xs)) \\<union> set (vals (y # ys))\n 4. \\<And>x xs ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (x # xs) (None # ys))) =\n       set (vals (x # xs)) \\<union> set (vals (None # ys))\n 5. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)", "show ?case"], ["proof (prove)\nusing this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n\ngoal (1 subgoal):\n 1. set (vals (meld (None # xs) (y # ys))) =\n    set (vals (None # xs)) \\<union> set (vals (y # ys))", "using set_dfs_Cons[of val y \"meld xs ys\"]"], ["proof (prove)\nusing this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n  set (vals (y # meld xs ys)) =\n  set (vals (meld xs ys)) \\<union> set (vals [y])\n\ngoal (1 subgoal):\n 1. set (vals (meld (None # xs) (y # ys))) =\n    set (vals (None # xs)) \\<union> set (vals (y # ys))", "using set_dfs_Cons[of val y ys]"], ["proof (prove)\nusing this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n  set (vals (y # meld xs ys)) =\n  set (vals (meld xs ys)) \\<union> set (vals [y])\n  set (vals (y # ys)) = set (vals ys) \\<union> set (vals [y])\n\ngoal (1 subgoal):\n 1. set (vals (meld (None # xs) (y # ys))) =\n    set (vals (None # xs)) \\<union> set (vals (y # ys))", "by auto"], ["proof (state)\nthis:\n  set (vals (meld (None # xs) (y # ys))) =\n  set (vals (None # xs)) \\<union> set (vals (y # ys))\n\ngoal (4 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>x xs ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (x # xs) (None # ys))) =\n       set (vals (x # xs)) \\<union> set (vals (None # ys))\n 4. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>x xs ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (x # xs) (None # ys))) =\n       set (vals (x # xs)) \\<union> set (vals (None # ys))\n 4. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "case (4 x xs ys)"], ["proof (state)\nthis:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n\ngoal (4 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>x xs ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (x # xs) (None # ys))) =\n       set (vals (x # xs)) \\<union> set (vals (None # ys))\n 4. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)", "show ?case"], ["proof (prove)\nusing this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n\ngoal (1 subgoal):\n 1. set (vals (meld (x # xs) (None # ys))) =\n    set (vals (x # xs)) \\<union> set (vals (None # ys))", "using set_dfs_Cons[of val x \"meld xs ys\"]"], ["proof (prove)\nusing this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n  set (vals (x # meld xs ys)) =\n  set (vals (meld xs ys)) \\<union> set (vals [x])\n\ngoal (1 subgoal):\n 1. set (vals (meld (x # xs) (None # ys))) =\n    set (vals (x # xs)) \\<union> set (vals (None # ys))", "using set_dfs_Cons[of val x xs]"], ["proof (prove)\nusing this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n  set (vals (x # meld xs ys)) =\n  set (vals (meld xs ys)) \\<union> set (vals [x])\n  set (vals (x # xs)) = set (vals xs) \\<union> set (vals [x])\n\ngoal (1 subgoal):\n 1. set (vals (meld (x # xs) (None # ys))) =\n    set (vals (x # xs)) \\<union> set (vals (None # ys))", "by auto"], ["proof (state)\nthis:\n  set (vals (meld (x # xs) (None # ys))) =\n  set (vals (x # xs)) \\<union> set (vals (None # ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "case (5 x xs y ys)"], ["proof (state)\nthis:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n\ngoal (3 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])\n 3. \\<And>t xs r ys.\n       set (vals (meld xs ys)) =\n       set (vals xs) \\<union> set (vals ys) \\<Longrightarrow>\n       set (vals (meld (Some t # xs) (Some r # ys))) =\n       set (vals (Some t # xs)) \\<union> set (vals (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)", "show ?case"], ["proof (prove)\nusing this:\n  set (vals (meld xs ys)) = set (vals xs) \\<union> set (vals ys)\n\ngoal (1 subgoal):\n 1. set (vals (meld (Some x # xs) (Some y # ys))) =\n    set (vals (Some x # xs)) \\<union> set (vals (Some y # ys))", "by (auto simp add: vals_add_Cons)"], ["proof (state)\nthis:\n  set (vals (meld (Some x # xs) (Some y # ys))) =\n  set (vals (Some x # xs)) \\<union> set (vals (Some y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>ys. set (vals (meld [] ys)) = set (vals []) \\<union> set (vals ys)\n 2. \\<And>xs. set (vals (meld xs [])) = set (vals xs) \\<union> set (vals [])", "qed simp_all"], ["", "lemma vals_meld_distinct:\n  \"distinct (dfs val xs) \\<Longrightarrow> distinct (dfs val ys) \\<Longrightarrow>\n   set (dfs val xs) \\<inter> set (dfs val ys) = {} \\<Longrightarrow>\n   distinct (dfs val (meld xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (vals xs); distinct (vals ys);\n     set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (meld xs ys))", "proof (induct xs ys rule: meld.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "case (3 xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (meld (None # xs) (y # ys)))", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> distinct (vals (meld xs ys));\n     distinct (vals (None # xs)); distinct (vals (y # ys));\n     set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n     y = None\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "case None"], ["proof (state)\nthis:\n  y = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> distinct (vals (meld xs ys));\n     distinct (vals (None # xs)); distinct (vals (y # ys));\n     set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n     y = None\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "with \"3\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n  y = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n  y = None\n\ngoal (1 subgoal):\n 1. distinct (vals (meld (None # xs) (y # ys)))", "by simp"], ["proof (state)\nthis:\n  distinct (vals (meld (None # xs) (y # ys)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "case (Some t)"], ["proof (state)\nthis:\n  y = Some t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "from \"3\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "have A: \"set (vals xs) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "using set_dfs_Cons[of val y ys]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n  set (vals (y # ys)) = set (vals ys) \\<union> set (vals [y])\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "by auto"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "moreover"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "from Some \"3\""], ["proof (chain)\npicking this:\n  y = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "have \"set (bt_dfs val t) \\<inter> set (vals xs) = {}\""], ["proof (prove)\nusing this:\n  y = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (vals xs) = {}", "by auto"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "moreover"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "from Some \"3\""], ["proof (chain)\npicking this:\n  y = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "have \"set (bt_dfs val t) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  y = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (vals ys) = {}", "by simp"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "ultimately"], ["proof (chain)\npicking this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n  set (bt_dfs val t) \\<inter> set (vals ys) = {}", "have \"set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}\""], ["proof (prove)\nusing this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n  set (bt_dfs val t) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}", "by (auto simp add: vals_meld)"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {};\n        y = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (None # xs) (y # ys)))", "with \"3\" Some"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n  y = Some t\n  set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n  y = Some t\n  set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (meld (None # xs) (y # ys)))", "by auto"], ["proof (state)\nthis:\n  distinct (vals (meld (None # xs) (y # ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (vals (meld (None # xs) (y # ys)))\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "case (4 x xs ys)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (meld (x # xs) (None # ys)))", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> distinct (vals (meld xs ys));\n     distinct (vals (x # xs)); distinct (vals (None # ys));\n     set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n     x = None\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "case None"], ["proof (state)\nthis:\n  x = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> distinct (vals (meld xs ys));\n     distinct (vals (x # xs)); distinct (vals (None # ys));\n     set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n     x = None\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "with \"4\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n  x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n  x = None\n\ngoal (1 subgoal):\n 1. distinct (vals (meld (x # xs) (None # ys)))", "by simp"], ["proof (state)\nthis:\n  distinct (vals (meld (x # xs) (None # ys)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "case (Some t)"], ["proof (state)\nthis:\n  x = Some t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "from \"4\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "have \"set (vals xs) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "using set_dfs_Cons[of val x xs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n  set (vals (x # xs)) = set (vals xs) \\<union> set (vals [x])\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "by auto"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "moreover"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "from Some \"4\""], ["proof (chain)\npicking this:\n  x = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "have \"set (bt_dfs val t) \\<inter> set (vals xs) = {}\""], ["proof (prove)\nusing this:\n  x = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (vals xs) = {}", "by simp"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "moreover"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "from Some \"4\""], ["proof (chain)\npicking this:\n  x = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "have \"set (bt_dfs val t) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  x = Some t\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (vals ys) = {}", "by auto"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "ultimately"], ["proof (chain)\npicking this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n  set (bt_dfs val t) \\<inter> set (vals ys) = {}", "have \"set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}\""], ["proof (prove)\nusing this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  set (bt_dfs val t) \\<inter> set (vals xs) = {}\n  set (bt_dfs val t) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}", "by (auto simp add: vals_meld)"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {};\n        x = Some a\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (x # xs) (None # ys)))", "with \"4\" Some"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n  x = Some t\n  set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n  x = Some t\n  set (bt_dfs val t) \\<inter> set (vals (meld xs ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (meld (x # xs) (None # ys)))", "by auto"], ["proof (state)\nthis:\n  distinct (vals (meld (x # xs) (None # ys)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (vals (meld (x # xs) (None # ys)))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "case (5 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have \"set (vals xs) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "by (auto simp add: set_dfs_Cons)"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "with \"5\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n  set (vals xs) \\<inter> set (vals ys) = {}", "have \"distinct (vals (meld xs ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (meld xs ys))", "by simp"], ["proof (state)\nthis:\n  distinct (vals (meld xs ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "moreover"], ["proof (state)\nthis:\n  distinct (vals (meld xs ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "from \"5\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have \"set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}", "by auto"], ["proof (state)\nthis:\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "with \"5\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}", "have \"distinct (bt_dfs val (merge x y))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}\n\ngoal (1 subgoal):\n 1. distinct (bt_dfs val (merge x y))", "by (simp add: vals_merge_distinct)"], ["proof (state)\nthis:\n  distinct (bt_dfs val (merge x y))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "moreover"], ["proof (state)\nthis:\n  distinct (bt_dfs val (merge x y))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "from \"5\""], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have \"set (vals (meld xs ys)) \\<inter> set (bt_dfs val (merge x y)) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> distinct (vals (meld xs ys))\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (vals (meld xs ys)) \\<inter> set (bt_dfs val (merge x y)) = {}", "by (auto simp add: vals_meld)"], ["proof (state)\nthis:\n  set (vals (meld xs ys)) \\<inter> set (bt_dfs val (merge x y)) = {}\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> distinct (vals (meld xs ys));\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld (Some t # xs) (Some r # ys)))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (vals (meld xs ys))\n  distinct (bt_dfs val (merge x y))\n  set (vals (meld xs ys)) \\<inter> set (bt_dfs val (merge x y)) = {}", "show ?case"], ["proof (prove)\nusing this:\n  distinct (vals (meld xs ys))\n  distinct (bt_dfs val (merge x y))\n  set (vals (meld xs ys)) \\<inter> set (bt_dfs val (merge x y)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (meld (Some x # xs) (Some y # ys)))", "by (simp add: vals_add_distinct)"], ["proof (state)\nthis:\n  distinct (vals (meld (Some x # xs) (Some y # ys)))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld [] ys))\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> distinct (vals (meld xs []))", "qed simp_all"], ["", "lemma bt_augment_alist_subset:\n  \"set (PQ.alist_of q) \\<subseteq> set (PQ.alist_of (bt_augment t q))\"\n  \"set (PQ.alist_of q) \\<subseteq> set (PQ.alist_of (bts_augment ts q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bt_augment t q)) &&&\n    set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment ts q))", "proof (induct t and ts arbitrary: q and q rule: bt_augment.induct bts_augment.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q.\n       (\\<And>q.\n           set (pq.alist_of q)\n           \\<subseteq> set (pq.alist_of\n                             (bts_augment x3 q))) \\<Longrightarrow>\n       set (pq.alist_of q)\n       \\<subseteq> set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<And>q.\n       set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment [] q))\n 3. \\<And>x1 x2 q.\n       \\<lbrakk>\\<And>q.\n                   set (pq.alist_of q)\n                   \\<subseteq> set (pq.alist_of (bt_augment x1 q));\n        \\<And>q.\n           set (pq.alist_of q)\n           \\<subseteq> set (pq.alist_of (bts_augment x2 q))\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of q)\n                         \\<subseteq> set\n(pq.alist_of (bts_augment (x1 # x2) q))", "case (Node a v rs)"], ["proof (state)\nthis:\n  set (pq.alist_of ?q) \\<subseteq> set (pq.alist_of (bts_augment rs ?q))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q.\n       (\\<And>q.\n           set (pq.alist_of q)\n           \\<subseteq> set (pq.alist_of\n                             (bts_augment x3 q))) \\<Longrightarrow>\n       set (pq.alist_of q)\n       \\<subseteq> set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<And>q.\n       set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment [] q))\n 3. \\<And>x1 x2 q.\n       \\<lbrakk>\\<And>q.\n                   set (pq.alist_of q)\n                   \\<subseteq> set (pq.alist_of (bt_augment x1 q));\n        \\<And>q.\n           set (pq.alist_of q)\n           \\<subseteq> set (pq.alist_of (bts_augment x2 q))\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of q)\n                         \\<subseteq> set\n(pq.alist_of (bts_augment (x1 # x2) q))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pq.alist_of q)\n    \\<subseteq> set (pq.alist_of (bt_augment (Node a v rs) q))", "using Node[of q]"], ["proof (prove)\nusing this:\n  set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment rs q))\n\ngoal (1 subgoal):\n 1. set (pq.alist_of q)\n    \\<subseteq> set (pq.alist_of (bt_augment (Node a v rs) q))", "by (auto simp add: bt_augment_simp set_insort_key)"], ["proof (state)\nthis:\n  set (pq.alist_of q)\n  \\<subseteq> set (pq.alist_of (bt_augment (Node a v rs) q))\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment [] q))\n 2. \\<And>x1 x2 q.\n       \\<lbrakk>\\<And>q.\n                   set (pq.alist_of q)\n                   \\<subseteq> set (pq.alist_of (bt_augment x1 q));\n        \\<And>q.\n           set (pq.alist_of q)\n           \\<subseteq> set (pq.alist_of (bts_augment x2 q))\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of q)\n                         \\<subseteq> set\n(pq.alist_of (bts_augment (x1 # x2) q))", "qed auto"], ["", "lemma bt_augment_alist_in:\n  \"(v,a) \\<in> set (PQ.alist_of q) \\<Longrightarrow> (v,a) \\<in> set (PQ.alist_of (bt_augment t q))\"\n  \"(v,a) \\<in> set (PQ.alist_of q) \\<Longrightarrow> (v,a) \\<in> set (PQ.alist_of (bts_augment ts q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v, a) \\<in> set (pq.alist_of q) \\<Longrightarrow>\n     (v, a) \\<in> set (pq.alist_of (bt_augment t q))) &&&\n    ((v, a) \\<in> set (pq.alist_of q) \\<Longrightarrow>\n     (v, a) \\<in> set (pq.alist_of (bts_augment ts q)))", "using bt_augment_alist_subset[of q]"], ["proof (prove)\nusing this:\n  set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bt_augment ?t q))\n  set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment ?ts q))\n\ngoal (1 subgoal):\n 1. ((v, a) \\<in> set (pq.alist_of q) \\<Longrightarrow>\n     (v, a) \\<in> set (pq.alist_of (bt_augment t q))) &&&\n    ((v, a) \\<in> set (pq.alist_of q) \\<Longrightarrow>\n     (v, a) \\<in> set (pq.alist_of (bts_augment ts q)))", "by auto"], ["", "lemma bt_augment_alist_union:\n  \"distinct (bts_dfs val (r # [t])) \\<Longrightarrow> \n   set (bts_dfs val (r # [t])) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (PQ.alist_of (bt_augment t (bt_augment r q))) =\n     set (PQ.alist_of (bt_augment t q)) \\<union> set (PQ.alist_of (bt_augment r q))\"\n  \n  \"distinct (bts_dfs val (r # ts)) \\<Longrightarrow> \n   set (bts_dfs val (r # ts)) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (PQ.alist_of (bts_augment ts (bt_augment r q))) =\n     set (PQ.alist_of (bts_augment ts q)) \\<union> set (PQ.alist_of (bt_augment r q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>distinct (bts_dfs val [r, t]);\n      set (bts_dfs val [r, t]) \\<inter> set |q| = {}\\<rbrakk>\n     \\<Longrightarrow> set (pq.alist_of (bt_augment t (bt_augment r q))) =\n                       set (pq.alist_of (bt_augment t q)) \\<union>\n                       set (pq.alist_of (bt_augment r q))) &&&\n    (\\<lbrakk>distinct (bts_dfs val (r # ts));\n      set (bts_dfs val (r # ts)) \\<inter> set |q| = {}\\<rbrakk>\n     \\<Longrightarrow> set (pq.alist_of (bts_augment ts (bt_augment r q))) =\n                       set (pq.alist_of (bts_augment ts q)) \\<union>\n                       set (pq.alist_of (bt_augment r q)))", "proof (induct t and ts arbitrary: q r and q r rule: bt_augment.induct bts_augment.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>q r.\n       \\<lbrakk>distinct (bts_dfs val [r]);\n        set (bts_dfs val [r]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment [] (bt_augment r q))) =\n                         set (pq.alist_of (bts_augment [] q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 3. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "case Nil_bintree"], ["proof (state)\nthis:\n  distinct (bts_dfs val [r])\n  set (bts_dfs val [r]) \\<inter> set |q| = {}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>q r.\n       \\<lbrakk>distinct (bts_dfs val [r]);\n        set (bts_dfs val [r]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment [] (bt_augment r q))) =\n                         set (pq.alist_of (bts_augment [] q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 3. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "from bt_augment_alist_subset[of q]"], ["proof (chain)\npicking this:\n  set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bt_augment ?t q))\n  set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment ?ts q))", "show ?case"], ["proof (prove)\nusing this:\n  set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bt_augment ?t q))\n  set (pq.alist_of q) \\<subseteq> set (pq.alist_of (bts_augment ?ts q))\n\ngoal (1 subgoal):\n 1. set (pq.alist_of (bts_augment [] (bt_augment r q))) =\n    set (pq.alist_of (bts_augment [] q)) \\<union>\n    set (pq.alist_of (bt_augment r q))", "by auto"], ["proof (state)\nthis:\n  set (pq.alist_of (bts_augment [] (bt_augment r q))) =\n  set (pq.alist_of (bts_augment [] q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "case (Node a v rs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (bts_dfs val (?r # rs));\n   set (bts_dfs val (?r # rs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment rs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment rs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val [r, Node a v rs])\n  set (bts_dfs val [r, Node a v rs]) \\<inter> set |q| = {}\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (bts_dfs val (?r # rs));\n   set (bts_dfs val (?r # rs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment rs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment rs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val [r, Node a v rs])\n  set (bts_dfs val [r, Node a v rs]) \\<inter> set |q| = {}", "have\n    \"set (PQ.alist_of (bts_augment rs (bt_augment r q))) =\n     set (PQ.alist_of (bts_augment rs q)) \\<union> set (PQ.alist_of (bt_augment r q))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bts_dfs val (?r # rs));\n   set (bts_dfs val (?r # rs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment rs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment rs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val [r, Node a v rs])\n  set (bts_dfs val [r, Node a v rs]) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. set (pq.alist_of (bts_augment rs (bt_augment r q))) =\n    set (pq.alist_of (bts_augment rs q)) \\<union>\n    set (pq.alist_of (bt_augment r q))", "by simp"], ["proof (state)\nthis:\n  set (pq.alist_of (bts_augment rs (bt_augment r q))) =\n  set (pq.alist_of (bts_augment rs q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "moreover"], ["proof (state)\nthis:\n  set (pq.alist_of (bts_augment rs (bt_augment r q))) =\n  set (pq.alist_of (bts_augment rs q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "from Node.prems"], ["proof (chain)\npicking this:\n  distinct (bts_dfs val [r, Node a v rs])\n  set (bts_dfs val [r, Node a v rs]) \\<inter> set |q| = {}", "have *: \"v \\<notin> set |bts_augment rs q| \\<union> set |bt_augment r q|\""], ["proof (prove)\nusing this:\n  distinct (bts_dfs val [r, Node a v rs])\n  set (bts_dfs val [r, Node a v rs]) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. v \\<notin> set |bts_augment rs q| \\<union> set |bt_augment r q|", "unfolding bt_val_augment[symmetric]"], ["proof (prove)\nusing this:\n  distinct (bts_dfs val [r, Node a v rs])\n  set (bts_dfs val [r, Node a v rs]) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (bts_dfs val rs) \\<union> set |q| \\<union>\n               (set (bt_dfs val r) \\<union> set |q|)", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set |bts_augment rs q| \\<union> set |bt_augment r q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "hence \"v \\<notin> set |bts_augment rs (bt_augment r q)|\""], ["proof (prove)\nusing this:\n  v \\<notin> set |bts_augment rs q| \\<union> set |bt_augment r q|\n\ngoal (1 subgoal):\n 1. v \\<notin> set |bts_augment rs (bt_augment r q)|", "by (unfold bt_augment_v_union)"], ["proof (state)\nthis:\n  v \\<notin> set |bts_augment rs (bt_augment r q)|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "moreover"], ["proof (state)\nthis:\n  v \\<notin> set |bts_augment rs (bt_augment r q)|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "from *"], ["proof (chain)\npicking this:\n  v \\<notin> set |bts_augment rs q| \\<union> set |bt_augment r q|", "have \"v \\<notin> set |bts_augment rs q|\""], ["proof (prove)\nusing this:\n  v \\<notin> set |bts_augment rs q| \\<union> set |bt_augment r q|\n\ngoal (1 subgoal):\n 1. v \\<notin> set |bts_augment rs q|", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set |bts_augment rs q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val (r # x3));\n                    set (bts_dfs val (r # x3)) \\<inter> set |q| =\n                    {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bts_augment x3 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bts_augment x3 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val [r, Node x1 x2 x3]);\n        set (bts_dfs val [r, Node x1 x2 x3]) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3)\n                                 (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bt_augment (Node x1 x2 x3) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))\n 2. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "ultimately"], ["proof (chain)\npicking this:\n  set (pq.alist_of (bts_augment rs (bt_augment r q))) =\n  set (pq.alist_of (bts_augment rs q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n  v \\<notin> set |bts_augment rs (bt_augment r q)|\n  v \\<notin> set |bts_augment rs q|", "show ?case"], ["proof (prove)\nusing this:\n  set (pq.alist_of (bts_augment rs (bt_augment r q))) =\n  set (pq.alist_of (bts_augment rs q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n  v \\<notin> set |bts_augment rs (bt_augment r q)|\n  v \\<notin> set |bts_augment rs q|\n\ngoal (1 subgoal):\n 1. set (pq.alist_of (bt_augment (Node a v rs) (bt_augment r q))) =\n    set (pq.alist_of (bt_augment (Node a v rs) q)) \\<union>\n    set (pq.alist_of (bt_augment r q))", "by (simp add: set_insort_key)"], ["proof (state)\nthis:\n  set (pq.alist_of (bt_augment (Node a v rs) (bt_augment r q))) =\n  set (pq.alist_of (bt_augment (Node a v rs) q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "case (Cons_bintree x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (bts_dfs val [?r, x]);\n   set (bts_dfs val [?r, x]) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bt_augment x (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bt_augment x ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  \\<lbrakk>distinct (bts_dfs val (?r # xs));\n   set (bts_dfs val (?r # xs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment xs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment xs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val (r # x # xs))\n  set (bts_dfs val (r # x # xs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (bts_dfs val [?r, x]);\n   set (bts_dfs val [?r, x]) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bt_augment x (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bt_augment x ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  \\<lbrakk>distinct (bts_dfs val (?r # xs));\n   set (bts_dfs val (?r # xs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment xs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment xs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val (r # x # xs))\n  set (bts_dfs val (r # x # xs)) \\<inter> set |q| = {}", "have \\<comment> \\<open>FIXME: ugly... and slow\\<close>\n    \"distinct (bts_dfs val (x # xs))\" and\n    \"distinct (bts_dfs val (r # xs))\" and\n    \"distinct (bts_dfs val [r,x])\" and\n    \"set (bts_dfs val (x # xs)) \\<inter> set |bt_augment r q| = {}\" and\n    \"set (bts_dfs val (x # xs)) \\<inter> set |q| = {}\" and\n    \"set (bts_dfs val [r, x]) \\<inter> set |q| = {}\" and\n    \"set (bts_dfs val (r # xs)) \\<inter> set |q| = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bts_dfs val [?r, x]);\n   set (bts_dfs val [?r, x]) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bt_augment x (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bt_augment x ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  \\<lbrakk>distinct (bts_dfs val (?r # xs));\n   set (bts_dfs val (?r # xs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment xs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment xs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val (r # x # xs))\n  set (bts_dfs val (r # x # xs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. (distinct (bts_dfs val (x # xs)) &&&\n     distinct (bts_dfs val (r # xs)) &&& distinct (bts_dfs val [r, x])) &&&\n    (set (bts_dfs val (x # xs)) \\<inter> set |bt_augment r q| = {} &&&\n     set (bts_dfs val (x # xs)) \\<inter> set |q| = {}) &&&\n    set (bts_dfs val [r, x]) \\<inter> set |q| = {} &&&\n    set (bts_dfs val (r # xs)) \\<inter> set |q| = {}", "unfolding bt_val_augment[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bts_dfs val [?r, x]);\n   set (bts_dfs val [?r, x]) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bt_augment x (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bt_augment x ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  \\<lbrakk>distinct (bts_dfs val (?r # xs));\n   set (bts_dfs val (?r # xs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment xs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment xs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val (r # x # xs))\n  set (bts_dfs val (r # x # xs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. (distinct (bts_dfs val (x # xs)) &&&\n     distinct (bts_dfs val (r # xs)) &&& distinct (bts_dfs val [r, x])) &&&\n    (set (bts_dfs val (x # xs)) \\<inter>\n     (set (bt_dfs val r) \\<union> set |q|) =\n     {} &&&\n     set (bts_dfs val (x # xs)) \\<inter> set |q| = {}) &&&\n    set (bts_dfs val [r, x]) \\<inter> set |q| = {} &&&\n    set (bts_dfs val (r # xs)) \\<inter> set |q| = {}", "by auto"], ["proof (state)\nthis:\n  distinct (bts_dfs val (x # xs))\n  distinct (bts_dfs val (r # xs))\n  distinct (bts_dfs val [r, x])\n  set (bts_dfs val (x # xs)) \\<inter> set |bt_augment r q| = {}\n  set (bts_dfs val (x # xs)) \\<inter> set |q| = {}\n  set (bts_dfs val [r, x]) \\<inter> set |q| = {}\n  set (bts_dfs val (r # xs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 q r.\n       \\<lbrakk>\\<And>q r.\n                   \\<lbrakk>distinct (bts_dfs val [r, x1]);\n                    set (bts_dfs val [r, x1]) \\<inter> set |q| = {}\\<rbrakk>\n                   \\<Longrightarrow> set\n(pq.alist_of (bt_augment x1 (bt_augment r q))) =\n                                     set\n(pq.alist_of (bt_augment x1 q)) \\<union>\n                                     set (pq.alist_of (bt_augment r q));\n        \\<And>q r.\n           \\<lbrakk>distinct (bts_dfs val (r # x2));\n            set (bts_dfs val (r # x2)) \\<inter> set |q| = {}\\<rbrakk>\n           \\<Longrightarrow> set (pq.alist_of\n                                   (bts_augment x2 (bt_augment r q))) =\n                             set (pq.alist_of (bts_augment x2 q)) \\<union>\n                             set (pq.alist_of (bt_augment r q));\n        distinct (bts_dfs val (r # x1 # x2));\n        set (bts_dfs val (r # x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (pq.alist_of\n                               (bts_augment (x1 # x2) (bt_augment r q))) =\n                         set (pq.alist_of\n                               (bts_augment (x1 # x2) q)) \\<union>\n                         set (pq.alist_of (bt_augment r q))", "with Cons_bintree.hyps"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (bts_dfs val [?r, x]);\n   set (bts_dfs val [?r, x]) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bt_augment x (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bt_augment x ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  \\<lbrakk>distinct (bts_dfs val (?r # xs));\n   set (bts_dfs val (?r # xs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment xs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment xs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val (x # xs))\n  distinct (bts_dfs val (r # xs))\n  distinct (bts_dfs val [r, x])\n  set (bts_dfs val (x # xs)) \\<inter> set |bt_augment r q| = {}\n  set (bts_dfs val (x # xs)) \\<inter> set |q| = {}\n  set (bts_dfs val [r, x]) \\<inter> set |q| = {}\n  set (bts_dfs val (r # xs)) \\<inter> set |q| = {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bts_dfs val [?r, x]);\n   set (bts_dfs val [?r, x]) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bt_augment x (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bt_augment x ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  \\<lbrakk>distinct (bts_dfs val (?r # xs));\n   set (bts_dfs val (?r # xs)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment xs (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment xs ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  distinct (bts_dfs val (x # xs))\n  distinct (bts_dfs val (r # xs))\n  distinct (bts_dfs val [r, x])\n  set (bts_dfs val (x # xs)) \\<inter> set |bt_augment r q| = {}\n  set (bts_dfs val (x # xs)) \\<inter> set |q| = {}\n  set (bts_dfs val [r, x]) \\<inter> set |q| = {}\n  set (bts_dfs val (r # xs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. set (pq.alist_of (bts_augment (x # xs) (bt_augment r q))) =\n    set (pq.alist_of (bts_augment (x # xs) q)) \\<union>\n    set (pq.alist_of (bt_augment r q))", "by auto"], ["proof (state)\nthis:\n  set (pq.alist_of (bts_augment (x # xs) (bt_augment r q))) =\n  set (pq.alist_of (bts_augment (x # xs) q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bt_alist_augment:\n  \"distinct (bt_dfs val t) \\<Longrightarrow> \n   set (bt_dfs val t) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (bt_dfs alist t) \\<union> set (PQ.alist_of q) = set (PQ.alist_of (bt_augment t q))\"\n  \n  \"distinct (bts_dfs val ts) \\<Longrightarrow> \n   set (bts_dfs val ts) \\<inter> set |q| = {} \\<Longrightarrow> \n   set (bts_dfs alist ts) \\<union> set (PQ.alist_of q) =\n     set (PQ.alist_of (bts_augment ts q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>distinct (bt_dfs val t);\n      set (bt_dfs val t) \\<inter> set |q| = {}\\<rbrakk>\n     \\<Longrightarrow> set (bt_dfs alist t) \\<union> set (pq.alist_of q) =\n                       set (pq.alist_of (bt_augment t q))) &&&\n    (\\<lbrakk>distinct (bts_dfs val ts);\n      set (bts_dfs val ts) \\<inter> set |q| = {}\\<rbrakk>\n     \\<Longrightarrow> set (bts_dfs alist ts) \\<union> set (pq.alist_of q) =\n                       set (pq.alist_of (bts_augment ts q)))", "proof (induct t and ts rule: bt_augment.induct bts_augment.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<lbrakk>distinct (bts_dfs val x3);\n                 set (bts_dfs val x3) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bts_dfs alist x3) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bts_augment x3 q));\n        distinct (bt_dfs val (Node x1 x2 x3));\n        set (bt_dfs val (Node x1 x2 x3)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bt_dfs alist (Node x1 x2 x3)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<lbrakk>distinct (bts_dfs val []);\n     set (bts_dfs val []) \\<inter> set |q| = {}\\<rbrakk>\n    \\<Longrightarrow> set (bts_dfs alist []) \\<union> set (pq.alist_of q) =\n                      set (pq.alist_of (bts_augment [] q))\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "case Nil_bintree"], ["proof (state)\nthis:\n  distinct (bts_dfs val [])\n  set (bts_dfs val []) \\<inter> set |q| = {}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<lbrakk>distinct (bts_dfs val x3);\n                 set (bts_dfs val x3) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bts_dfs alist x3) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bts_augment x3 q));\n        distinct (bt_dfs val (Node x1 x2 x3));\n        set (bt_dfs val (Node x1 x2 x3)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bt_dfs alist (Node x1 x2 x3)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<lbrakk>distinct (bts_dfs val []);\n     set (bts_dfs val []) \\<inter> set |q| = {}\\<rbrakk>\n    \\<Longrightarrow> set (bts_dfs alist []) \\<union> set (pq.alist_of q) =\n                      set (pq.alist_of (bts_augment [] q))\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "then"], ["proof (chain)\npicking this:\n  distinct (bts_dfs val [])\n  set (bts_dfs val []) \\<inter> set |q| = {}", "show ?case"], ["proof (prove)\nusing this:\n  distinct (bts_dfs val [])\n  set (bts_dfs val []) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. set (bts_dfs alist []) \\<union> set (pq.alist_of q) =\n    set (pq.alist_of (bts_augment [] q))", "by simp"], ["proof (state)\nthis:\n  set (bts_dfs alist []) \\<union> set (pq.alist_of q) =\n  set (pq.alist_of (bts_augment [] q))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<lbrakk>distinct (bts_dfs val x3);\n                 set (bts_dfs val x3) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bts_dfs alist x3) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bts_augment x3 q));\n        distinct (bt_dfs val (Node x1 x2 x3));\n        set (bt_dfs val (Node x1 x2 x3)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bt_dfs alist (Node x1 x2 x3)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<lbrakk>distinct (bts_dfs val x3);\n                 set (bts_dfs val x3) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bts_dfs alist x3) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bts_augment x3 q));\n        distinct (bt_dfs val (Node x1 x2 x3));\n        set (bt_dfs val (Node x1 x2 x3)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bt_dfs alist (Node x1 x2 x3)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "case (Node a v rs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bt_dfs val (Node a v rs))\n  set (bt_dfs val (Node a v rs)) \\<inter> set |q| = {}\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<lbrakk>distinct (bts_dfs val x3);\n                 set (bts_dfs val x3) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bts_dfs alist x3) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bts_augment x3 q));\n        distinct (bt_dfs val (Node x1 x2 x3));\n        set (bt_dfs val (Node x1 x2 x3)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bt_dfs alist (Node x1 x2 x3)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "hence \"v \\<notin> set |bts_augment rs q|\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bt_dfs val (Node a v rs))\n  set (bt_dfs val (Node a v rs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. v \\<notin> set |bts_augment rs q|", "unfolding bt_val_augment[symmetric]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bt_dfs val (Node a v rs))\n  set (bt_dfs val (Node a v rs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (bts_dfs val rs) \\<union> set |q|", "by simp"], ["proof (state)\nthis:\n  v \\<notin> set |bts_augment rs q|\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<lbrakk>distinct (bts_dfs val x3);\n                 set (bts_dfs val x3) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bts_dfs alist x3) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bts_augment x3 q));\n        distinct (bt_dfs val (Node x1 x2 x3));\n        set (bt_dfs val (Node x1 x2 x3)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bt_dfs alist (Node x1 x2 x3)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bt_augment (Node x1 x2 x3) q))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "with Node"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bt_dfs val (Node a v rs))\n  set (bt_dfs val (Node a v rs)) \\<inter> set |q| = {}\n  v \\<notin> set |bts_augment rs q|", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bt_dfs val (Node a v rs))\n  set (bt_dfs val (Node a v rs)) \\<inter> set |q| = {}\n  v \\<notin> set |bts_augment rs q|\n\ngoal (1 subgoal):\n 1. set (bt_dfs alist (Node a v rs)) \\<union> set (pq.alist_of q) =\n    set (pq.alist_of (bt_augment (Node a v rs) q))", "by (simp add: set_insort_key)"], ["proof (state)\nthis:\n  set (bt_dfs alist (Node a v rs)) \\<union> set (pq.alist_of q) =\n  set (pq.alist_of (bt_augment (Node a v rs) q))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "case (Cons_bintree r rs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (bt_dfs val r);\n   set (bt_dfs val r) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bt_dfs alist r) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bt_augment r q))\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bts_dfs val (r # rs))\n  set (bts_dfs val (r # rs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (bt_dfs val r);\n   set (bt_dfs val r) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bt_dfs alist r) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bt_augment r q))\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bts_dfs val (r # rs))\n  set (bts_dfs val (r # rs)) \\<inter> set |q| = {}", "have \"set (PQ.alist_of (bts_augment (r # rs) q)) =\n    set (PQ.alist_of (bts_augment rs q)) \\<union> set (PQ.alist_of (bt_augment r q))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bt_dfs val r);\n   set (bt_dfs val r) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bt_dfs alist r) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bt_augment r q))\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bts_dfs val (r # rs))\n  set (bts_dfs val (r # rs)) \\<inter> set |q| = {}\n\ngoal (1 subgoal):\n 1. set (pq.alist_of (bts_augment (r # rs) q)) =\n    set (pq.alist_of (bts_augment rs q)) \\<union>\n    set (pq.alist_of (bt_augment r q))", "using bt_augment_alist_union"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bt_dfs val r);\n   set (bt_dfs val r) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bt_dfs alist r) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bt_augment r q))\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bts_dfs val (r # rs))\n  set (bts_dfs val (r # rs)) \\<inter> set |q| = {}\n  \\<lbrakk>distinct (bts_dfs val [?r, ?t]);\n   set (bts_dfs val [?r, ?t]) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bt_augment ?t (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bt_augment ?t ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n  \\<lbrakk>distinct (bts_dfs val (?r # ?ts));\n   set (bts_dfs val (?r # ?ts)) \\<inter> set |?q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (pq.alist_of (bts_augment ?ts (bt_augment ?r ?q))) =\n                    set (pq.alist_of (bts_augment ?ts ?q)) \\<union>\n                    set (pq.alist_of (bt_augment ?r ?q))\n\ngoal (1 subgoal):\n 1. set (pq.alist_of (bts_augment (r # rs) q)) =\n    set (pq.alist_of (bts_augment rs q)) \\<union>\n    set (pq.alist_of (bt_augment r q))", "by simp"], ["proof (state)\nthis:\n  set (pq.alist_of (bts_augment (r # rs) q)) =\n  set (pq.alist_of (bts_augment rs q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>distinct (bt_dfs val x1);\n                 set (bt_dfs val x1) \\<inter> set |q| = {}\\<rbrakk>\n                \\<Longrightarrow> set (bt_dfs alist x1) \\<union>\n                                  set (pq.alist_of q) =\n                                  set (pq.alist_of (bt_augment x1 q));\n        \\<lbrakk>distinct (bts_dfs val x2);\n         set (bts_dfs val x2) \\<inter> set |q| = {}\\<rbrakk>\n        \\<Longrightarrow> set (bts_dfs alist x2) \\<union>\n                          set (pq.alist_of q) =\n                          set (pq.alist_of (bts_augment x2 q));\n        distinct (bts_dfs val (x1 # x2));\n        set (bts_dfs val (x1 # x2)) \\<inter> set |q| = {}\\<rbrakk>\n       \\<Longrightarrow> set (bts_dfs alist (x1 # x2)) \\<union>\n                         set (pq.alist_of q) =\n                         set (pq.alist_of (bts_augment (x1 # x2) q))", "with Cons_bintree bt_augment_alist_subset"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (bt_dfs val r);\n   set (bt_dfs val r) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bt_dfs alist r) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bt_augment r q))\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bts_dfs val (r # rs))\n  set (bts_dfs val (r # rs)) \\<inter> set |q| = {}\n  set (pq.alist_of ?q) \\<subseteq> set (pq.alist_of (bt_augment ?t ?q))\n  set (pq.alist_of ?q) \\<subseteq> set (pq.alist_of (bts_augment ?ts ?q))\n  set (pq.alist_of (bts_augment (r # rs) q)) =\n  set (pq.alist_of (bts_augment rs q)) \\<union>\n  set (pq.alist_of (bt_augment r q))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (bt_dfs val r);\n   set (bt_dfs val r) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bt_dfs alist r) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bt_augment r q))\n  \\<lbrakk>distinct (bts_dfs val rs);\n   set (bts_dfs val rs) \\<inter> set |q| = {}\\<rbrakk>\n  \\<Longrightarrow> set (bts_dfs alist rs) \\<union> set (pq.alist_of q) =\n                    set (pq.alist_of (bts_augment rs q))\n  distinct (bts_dfs val (r # rs))\n  set (bts_dfs val (r # rs)) \\<inter> set |q| = {}\n  set (pq.alist_of ?q) \\<subseteq> set (pq.alist_of (bt_augment ?t ?q))\n  set (pq.alist_of ?q) \\<subseteq> set (pq.alist_of (bts_augment ?ts ?q))\n  set (pq.alist_of (bts_augment (r # rs) q)) =\n  set (pq.alist_of (bts_augment rs q)) \\<union>\n  set (pq.alist_of (bt_augment r q))\n\ngoal (1 subgoal):\n 1. set (bts_dfs alist (r # rs)) \\<union> set (pq.alist_of q) =\n    set (pq.alist_of (bts_augment (r # rs) q))", "by auto"], ["proof (state)\nthis:\n  set (bts_dfs alist (r # rs)) \\<union> set (pq.alist_of q) =\n  set (pq.alist_of (bts_augment (r # rs) q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alist_pqueue:\n  \"distinct (vals xs) \\<Longrightarrow> set (dfs alist xs) = set (PQ.alist_of (pqueue xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (vals xs) \\<Longrightarrow>\n    set (elements xs) = set (pq.alist_of (pqueue xs))", "by (induct xs) (simp_all add: vals_pqueue bt_alist_augment)"], ["", "lemma alist_pqueue_priority:\n  \"distinct (vals xs) \\<Longrightarrow> (v, a) \\<in> set (dfs alist xs)\n    \\<Longrightarrow> PQ.priority (pqueue xs) v = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (vals xs); (v, a) \\<in> set (elements xs)\\<rbrakk>\n    \\<Longrightarrow> PQ.priority (pqueue xs) v = Some a", "by (simp add: alist_pqueue PQ.priority_def)"], ["", "lemma prios_pqueue:\n  \"distinct (vals xs) \\<Longrightarrow> set (prios xs) = set \\<parallel>pqueue xs\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (vals xs) \\<Longrightarrow>\n    set (prios xs) = set \\<parallel>pqueue xs\\<parallel>", "by (auto simp add: alist_pqueue priorities_set alist_split_set)"], ["", "lemma alist_merge [simp]:\n  \"distinct (bt_dfs val t) \\<Longrightarrow> distinct (bt_dfs val r) \\<Longrightarrow>\n   set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {} \\<Longrightarrow> \n   set (bt_dfs alist (merge t r)) = set (bt_dfs alist t) \\<union> set (bt_dfs alist r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (bt_dfs val t); distinct (bt_dfs val r);\n     set (bt_dfs val t) \\<inter> set (bt_dfs val r) = {}\\<rbrakk>\n    \\<Longrightarrow> set (bt_dfs alist (merge t r)) =\n                      set (bt_dfs alist t) \\<union> set (bt_dfs alist r)", "by (auto simp add: bt_dfs_simp merge_def alist_split)"], ["", "lemma alist_add_Cons:\n  assumes \"distinct (vals (x#xs))\"\n  shows \"set (dfs alist (add x xs)) = set (dfs alist (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elements (add x xs)) = set (elements (x # xs))", "using assms"], ["proof (prove)\nusing this:\n  distinct (vals (x # xs))\n\ngoal (1 subgoal):\n 1. set (elements (add x xs)) = set (elements (x # xs))", "proof (induct xs arbitrary: x)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       distinct (vals [x]) \\<Longrightarrow>\n       set (elements (add x [])) = set (elements [x])\n 2. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (x # None # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (None # xs))) =\n                         set (elements (x # None # xs))\n 3. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "case Empty"], ["proof (state)\nthis:\n  distinct (vals [x])\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       distinct (vals [x]) \\<Longrightarrow>\n       set (elements (add x [])) = set (elements [x])\n 2. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (x # None # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (None # xs))) =\n                         set (elements (x # None # xs))\n 3. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "then"], ["proof (chain)\npicking this:\n  distinct (vals [x])", "show ?case"], ["proof (prove)\nusing this:\n  distinct (vals [x])\n\ngoal (1 subgoal):\n 1. set (elements (add x [])) = set (elements [x])", "by (cases x) simp_all"], ["proof (state)\nthis:\n  set (elements (add x [])) = set (elements [x])\n\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (x # None # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (None # xs))) =\n                         set (elements (x # None # xs))\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (x # None # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (None # xs))) =\n                         set (elements (x # None # xs))\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "case None"], ["proof (state)\nthis:\n  distinct (vals (?x # xs_)) \\<Longrightarrow>\n  set (elements (add ?x xs_)) = set (elements (?x # xs_))\n  distinct (vals (x # None # xs_))\n\ngoal (2 subgoals):\n 1. \\<And>xs x.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (x # None # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (None # xs))) =\n                         set (elements (x # None # xs))\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "then"], ["proof (chain)\npicking this:\n  distinct (vals (?x # xs_)) \\<Longrightarrow>\n  set (elements (add ?x xs_)) = set (elements (?x # xs_))\n  distinct (vals (x # None # xs_))", "show ?case"], ["proof (prove)\nusing this:\n  distinct (vals (?x # xs_)) \\<Longrightarrow>\n  set (elements (add ?x xs_)) = set (elements (?x # xs_))\n  distinct (vals (x # None # xs_))\n\ngoal (1 subgoal):\n 1. set (elements (add x (None # xs_))) = set (elements (x # None # xs_))", "by (cases x) simp_all"], ["proof (state)\nthis:\n  set (elements (add x (None # xs_))) = set (elements (x # None # xs_))\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "case (Some y ys)"], ["proof (state)\nthis:\n  distinct (vals (?x # ys)) \\<Longrightarrow>\n  set (elements (add ?x ys)) = set (elements (?x # ys))\n  distinct (vals (x # Some y # ys))\n\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # xs)) \\<Longrightarrow>\n                   set (elements (add x xs)) = set (elements (x # xs));\n        distinct (vals (xa # Some x # xs))\\<rbrakk>\n       \\<Longrightarrow> set (elements (add xa (Some x # xs))) =\n                         set (elements (xa # Some x # xs))", "then"], ["proof (chain)\npicking this:\n  distinct (vals (?x # ys)) \\<Longrightarrow>\n  set (elements (add ?x ys)) = set (elements (?x # ys))\n  distinct (vals (x # Some y # ys))", "show ?case"], ["proof (prove)\nusing this:\n  distinct (vals (?x # ys)) \\<Longrightarrow>\n  set (elements (add ?x ys)) = set (elements (?x # ys))\n  distinct (vals (x # Some y # ys))\n\ngoal (1 subgoal):\n 1. set (elements (add x (Some y # ys))) = set (elements (x # Some y # ys))", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "case (Some t)"], ["proof (state)\nthis:\n  x = Some t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "note prem = Some.prems Some"], ["proof (state)\nthis:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "from prem"], ["proof (chain)\npicking this:\n  distinct (vals (x # Some y # ys))\n  x = Some t", "have \"distinct (bt_dfs val (merge t y))\""], ["proof (prove)\nusing this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n\ngoal (1 subgoal):\n 1. distinct (bt_dfs val (merge t y))", "by (auto simp add: bt_dfs_simp merge_def)"], ["proof (state)\nthis:\n  distinct (bt_dfs val (merge t y))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "with prem"], ["proof (chain)\npicking this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  distinct (bt_dfs val (merge t y))", "have \"distinct (vals (Some (merge t y) # ys))\""], ["proof (prove)\nusing this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  distinct (bt_dfs val (merge t y))\n\ngoal (1 subgoal):\n 1. distinct (vals (Some (merge t y) # ys))", "by auto"], ["proof (state)\nthis:\n  distinct (vals (Some (merge t y) # ys))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "with prem Some.hyps"], ["proof (chain)\npicking this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  distinct (vals (?x # ys)) \\<Longrightarrow>\n  set (elements (add ?x ys)) = set (elements (?x # ys))\n  distinct (vals (Some (merge t y) # ys))", "have \"set (dfs alist (add (Some (merge t y)) ys)) =\n        set (dfs alist (Some (merge t y) # ys))\""], ["proof (prove)\nusing this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  distinct (vals (?x # ys)) \\<Longrightarrow>\n  set (elements (add ?x ys)) = set (elements (?x # ys))\n  distinct (vals (Some (merge t y) # ys))\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge t y)) ys)) =\n    set (elements (Some (merge t y) # ys))", "by simp"], ["proof (state)\nthis:\n  set (elements (add (Some (merge t y)) ys)) =\n  set (elements (Some (merge t y) # ys))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "moreover"], ["proof (state)\nthis:\n  set (elements (add (Some (merge t y)) ys)) =\n  set (elements (Some (merge t y) # ys))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "from prem"], ["proof (chain)\npicking this:\n  distinct (vals (x # Some y # ys))\n  x = Some t", "have \"set (bt_dfs val t) \\<inter> set (bt_dfs val y) = {}\""], ["proof (prove)\nusing this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n\ngoal (1 subgoal):\n 1. set (bt_dfs val t) \\<inter> set (bt_dfs val y) = {}", "by auto"], ["proof (state)\nthis:\n  set (bt_dfs val t) \\<inter> set (bt_dfs val y) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "with prem"], ["proof (chain)\npicking this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  set (bt_dfs val t) \\<inter> set (bt_dfs val y) = {}", "have \"set (bt_dfs alist (merge t y)) =\n        set (bt_dfs alist t) \\<union> set (bt_dfs alist y)\""], ["proof (prove)\nusing this:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  set (bt_dfs val t) \\<inter> set (bt_dfs val y) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs alist (merge t y)) =\n    set (bt_dfs alist t) \\<union> set (bt_dfs alist y)", "by simp"], ["proof (state)\nthis:\n  set (bt_dfs alist (merge t y)) =\n  set (bt_dfs alist t) \\<union> set (bt_dfs alist y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "moreover"], ["proof (state)\nthis:\n  set (bt_dfs alist (merge t y)) =\n  set (bt_dfs alist t) \\<union> set (bt_dfs alist y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "note prem and Un_assoc"], ["proof (state)\nthis:\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  ?A \\<union> ?B \\<union> ?C = ?A \\<union> (?B \\<union> ?C)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))\n 2. \\<And>a.\n       \\<lbrakk>\\<And>x.\n                   distinct (vals (x # ys)) \\<Longrightarrow>\n                   set (elements (add x ys)) = set (elements (x # ys));\n        distinct (vals (x # Some y # ys)); x = Some a\\<rbrakk>\n       \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                         set (elements (x # Some y # ys))", "ultimately"], ["proof (chain)\npicking this:\n  set (elements (add (Some (merge t y)) ys)) =\n  set (elements (Some (merge t y) # ys))\n  set (bt_dfs alist (merge t y)) =\n  set (bt_dfs alist t) \\<union> set (bt_dfs alist y)\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  ?A \\<union> ?B \\<union> ?C = ?A \\<union> (?B \\<union> ?C)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (elements (add (Some (merge t y)) ys)) =\n  set (elements (Some (merge t y) # ys))\n  set (bt_dfs alist (merge t y)) =\n  set (bt_dfs alist t) \\<union> set (bt_dfs alist y)\n  distinct (vals (x # Some y # ys))\n  x = Some t\n  ?A \\<union> ?B \\<union> ?C = ?A \\<union> (?B \\<union> ?C)\n\ngoal (1 subgoal):\n 1. set (elements (add x (Some y # ys))) = set (elements (x # Some y # ys))", "by simp"], ["proof (state)\nthis:\n  set (elements (add x (Some y # ys))) = set (elements (x # Some y # ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                distinct (vals (x # ys)) \\<Longrightarrow>\n                set (elements (add x ys)) = set (elements (x # ys));\n     distinct (vals (x # Some y # ys)); x = None\\<rbrakk>\n    \\<Longrightarrow> set (elements (add x (Some y # ys))) =\n                      set (elements (x # Some y # ys))", "qed simp"], ["proof (state)\nthis:\n  set (elements (add x (Some y # ys))) = set (elements (x # Some y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alist_insert [simp]:\n  \"distinct (vals xs) \\<Longrightarrow> \n   v \\<notin> set (vals xs) \\<Longrightarrow>\n   set (dfs alist (insert a v xs)) = set (dfs alist xs) \\<union> {(v,a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (vals xs); v \\<notin> set (vals xs)\\<rbrakk>\n    \\<Longrightarrow> set (elements (Binomial_Queue.insert a v xs)) =\n                      set (elements xs) \\<union> {(v, a)}", "by (simp add: insert_def alist_add_Cons)"], ["", "lemma insert_push:\n  \"distinct (vals xs) \\<Longrightarrow>\n   v \\<notin> set (vals xs) \\<Longrightarrow>\n   set (dfs alist (insert a v xs)) = set (PQ.alist_of (PQ.push v a (pqueue xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (vals xs); v \\<notin> set (vals xs)\\<rbrakk>\n    \\<Longrightarrow> set (elements (Binomial_Queue.insert a v xs)) =\n                      set (pq.alist_of (PQ.push v a (pqueue xs)))", "by (simp add: alist_pqueue vals_pqueue set_insort_key)"], ["", "lemma insert_p_push:\n  assumes \"distinct (vals xs)\"\n  and \"v \\<notin> set (vals xs)\"\n  shows \"set (prios (insert a v xs)) = set \\<parallel>PQ.push v a (pqueue xs)\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (prios (Binomial_Queue.insert a v xs)) =\n    set \\<parallel>PQ.push v a (pqueue xs)\\<parallel>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (prios (Binomial_Queue.insert a v xs)) =\n    set \\<parallel>PQ.push v a (pqueue xs)\\<parallel>", "from assms"], ["proof (chain)\npicking this:\n  distinct (vals xs)\n  v \\<notin> set (vals xs)", "have \"set (dfs alist (insert a v xs)) =\n      set (PQ.alist_of (PQ.push v a (pqueue xs)))\""], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  v \\<notin> set (vals xs)\n\ngoal (1 subgoal):\n 1. set (elements (Binomial_Queue.insert a v xs)) =\n    set (pq.alist_of (PQ.push v a (pqueue xs)))", "by (rule insert_push)"], ["proof (state)\nthis:\n  set (elements (Binomial_Queue.insert a v xs)) =\n  set (pq.alist_of (PQ.push v a (pqueue xs)))\n\ngoal (1 subgoal):\n 1. set (prios (Binomial_Queue.insert a v xs)) =\n    set \\<parallel>PQ.push v a (pqueue xs)\\<parallel>", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (elements (Binomial_Queue.insert a v xs)) =\n  set (pq.alist_of (PQ.push v a (pqueue xs)))\n\ngoal (1 subgoal):\n 1. set (prios (Binomial_Queue.insert a v xs)) =\n    set \\<parallel>PQ.push v a (pqueue xs)\\<parallel>", "by (simp add: alist_split_set priorities_set)"], ["proof (state)\nthis:\n  set (prios (Binomial_Queue.insert a v xs)) =\n  set \\<parallel>PQ.push v a (pqueue xs)\\<parallel>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma empty_empty:\n  \"normalized xs \\<Longrightarrow> xs = empty \\<longleftrightarrow> PQ.is_empty (pqueue xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized xs \\<Longrightarrow> (xs = []) = PQ.is_empty (pqueue xs)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized xs; xs = []\\<rbrakk>\n    \\<Longrightarrow> PQ.is_empty (pqueue xs)\n 2. \\<lbrakk>normalized xs; PQ.is_empty (pqueue xs)\\<rbrakk>\n    \\<Longrightarrow> xs = []", "assume \"xs = []\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>normalized xs; xs = []\\<rbrakk>\n    \\<Longrightarrow> PQ.is_empty (pqueue xs)\n 2. \\<lbrakk>normalized xs; PQ.is_empty (pqueue xs)\\<rbrakk>\n    \\<Longrightarrow> xs = []", "then"], ["proof (chain)\npicking this:\n  xs = []", "show \"PQ.is_empty (pqueue xs)\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. PQ.is_empty (pqueue xs)", "by simp"], ["proof (state)\nthis:\n  PQ.is_empty (pqueue xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; PQ.is_empty (pqueue xs)\\<rbrakk>\n    \\<Longrightarrow> xs = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; PQ.is_empty (pqueue xs)\\<rbrakk>\n    \\<Longrightarrow> xs = []", "assume N: \"normalized xs\" and E: \"PQ.is_empty (pqueue xs)\""], ["proof (state)\nthis:\n  normalized xs\n  PQ.is_empty (pqueue xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; PQ.is_empty (pqueue xs)\\<rbrakk>\n    \\<Longrightarrow> xs = []", "show \"xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "assume \"xs \\<noteq> []\""], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "with N"], ["proof (chain)\npicking this:\n  normalized xs\n  xs \\<noteq> []", "have \"set (vals xs) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  normalized xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<noteq> {}", "by (induct xs) (simp_all add: bt_dfs_simp dfs_append)"], ["proof (state)\nthis:\n  set (vals xs) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "hence \"set |pqueue xs| \\<noteq> {}\""], ["proof (prove)\nusing this:\n  set (vals xs) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set |pqueue xs| \\<noteq> {}", "by (simp add: vals_pqueue)"], ["proof (state)\nthis:\n  set |pqueue xs| \\<noteq> {}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  set |pqueue xs| \\<noteq> {}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "from E"], ["proof (chain)\npicking this:\n  PQ.is_empty (pqueue xs)", "have \"set |pqueue xs| = {}\""], ["proof (prove)\nusing this:\n  PQ.is_empty (pqueue xs)\n\ngoal (1 subgoal):\n 1. set |pqueue xs| = {}", "by (simp add: is_empty_empty)"], ["proof (state)\nthis:\n  set |pqueue xs| = {}\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  set |pqueue xs| \\<noteq> {}\n  set |pqueue xs| = {}", "show False"], ["proof (prove)\nusing this:\n  set |pqueue xs| \\<noteq> {}\n  set |pqueue xs| = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bt_dfs_Min_priority:\n  assumes \"is_heap t\"\n  shows \"priority t = Min (set (bt_dfs priority t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. priority t = Min (set (bt_dfs priority t))", "using assms"], ["proof (prove)\nusing this:\n  is_heap_list (priority t) (children t)\n\ngoal (1 subgoal):\n 1. priority t = Min (set (bt_dfs priority t))", "proof (induct \"priority t\" \"children t\" arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       [] = children t \\<Longrightarrow>\n       priority t = Min (set (bt_dfs priority t))\n 2. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "case is_heap_list_Nil"], ["proof (state)\nthis:\n  [] = children t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       [] = children t \\<Longrightarrow>\n       priority t = Min (set (bt_dfs priority t))\n 2. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "then"], ["proof (chain)\npicking this:\n  [] = children t", "show ?case"], ["proof (prove)\nusing this:\n  [] = children t\n\ngoal (1 subgoal):\n 1. priority t = Min (set (bt_dfs priority t))", "by (simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  priority t = Min (set (bt_dfs priority t))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "case (is_heap_list_Cons rs r t)"], ["proof (state)\nthis:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "note cons = this"], ["proof (state)\nthis:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "let ?M = \"Min (set (bt_dfs priority t))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "obtain t' where \"t' = Node (priority t) (val t) rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        t' = Node (priority t) (val t) rs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t' = Node (priority t) (val t) rs\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "hence ot: \"rs = children t'\" \"priority t' = priority t\""], ["proof (prove)\nusing this:\n  t' = Node (priority t) (val t) rs\n\ngoal (1 subgoal):\n 1. rs = children t' &&& priority t' = priority t", "by simp_all"], ["proof (state)\nthis:\n  rs = children t'\n  priority t' = priority t\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "with is_heap_list_Cons"], ["proof (chain)\npicking this:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t\n  rs = children t'\n  priority t' = priority t", "have \"priority t = Min (set (bt_dfs priority t'))\""], ["proof (prove)\nusing this:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t\n  rs = children t'\n  priority t' = priority t\n\ngoal (1 subgoal):\n 1. priority t = Min (set (bt_dfs priority t'))", "by simp"], ["proof (state)\nthis:\n  priority t = Min (set (bt_dfs priority t'))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "with ot"], ["proof (chain)\npicking this:\n  rs = children t'\n  priority t' = priority t\n  priority t = Min (set (bt_dfs priority t'))", "have \"priority t = Min (Set.insert (priority t) (set (bts_dfs priority rs)))\""], ["proof (prove)\nusing this:\n  rs = children t'\n  priority t' = priority t\n  priority t = Min (set (bt_dfs priority t'))\n\ngoal (1 subgoal):\n 1. priority t = Min (Set.insert (priority t) (set (bts_dfs priority rs)))", "by (simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  priority t = Min (Set.insert (priority t) (set (bts_dfs priority rs)))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "moreover"], ["proof (state)\nthis:\n  priority t = Min (Set.insert (priority t) (set (bts_dfs priority rs)))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "from cons"], ["proof (chain)\npicking this:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t", "have \"priority r = Min (set (bt_dfs priority r))\""], ["proof (prove)\nusing this:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t\n\ngoal (1 subgoal):\n 1. priority r = Min (set (bt_dfs priority r))", "by simp"], ["proof (state)\nthis:\n  priority r = Min (set (bt_dfs priority r))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "moreover"], ["proof (state)\nthis:\n  priority r = Min (set (bt_dfs priority r))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "from cons"], ["proof (chain)\npicking this:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t", "have \"children t = r # rs\""], ["proof (prove)\nusing this:\n  is_heap_list (priority t) rs\n  \\<lbrakk>priority t = priority ?t; rs = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  is_heap_list (priority r) (children r)\n  \\<lbrakk>priority r = priority ?t; children r = children ?t\\<rbrakk>\n  \\<Longrightarrow> priority ?t = Min (set (bt_dfs priority ?t))\n  priority t \\<le> priority r\n  r # rs = children t\n\ngoal (1 subgoal):\n 1. children t = r # rs", "by simp"], ["proof (state)\nthis:\n  children t = r # rs\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "then"], ["proof (chain)\npicking this:\n  children t = r # rs", "have \"bts_dfs priority (children t) =\n    (bt_dfs priority r) @ (bts_dfs priority rs)\""], ["proof (prove)\nusing this:\n  children t = r # rs\n\ngoal (1 subgoal):\n 1. bts_dfs priority (children t) = bt_dfs priority r @ bts_dfs priority rs", "by simp"], ["proof (state)\nthis:\n  bts_dfs priority (children t) = bt_dfs priority r @ bts_dfs priority rs\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "hence \"bt_dfs priority t =\n    priority t # (bt_dfs priority r @ bts_dfs priority rs)\""], ["proof (prove)\nusing this:\n  bts_dfs priority (children t) = bt_dfs priority r @ bts_dfs priority rs\n\ngoal (1 subgoal):\n 1. bt_dfs priority t = priority t # bt_dfs priority r @ bts_dfs priority rs", "by (simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  bt_dfs priority t = priority t # bt_dfs priority r @ bts_dfs priority rs\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "hence A: \"?M = Min\n    (Set.insert (priority t) (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)))\""], ["proof (prove)\nusing this:\n  bt_dfs priority t = priority t # bt_dfs priority r @ bts_dfs priority rs\n\ngoal (1 subgoal):\n 1. Min (set (bt_dfs priority t)) =\n    Min (Set.insert (priority t)\n          (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)))", "by simp"], ["proof (state)\nthis:\n  Min (set (bt_dfs priority t)) =\n  Min (Set.insert (priority t)\n        (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "have \"Set.insert (priority t) (set (bt_dfs priority r)\n    \\<union> set (bts_dfs priority rs)) =\n    Set.insert (priority t) (set (bts_dfs priority rs)) \\<union> set (bt_dfs priority r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.insert (priority t)\n     (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)) =\n    Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n    set (bt_dfs priority r)", "by auto"], ["proof (state)\nthis:\n  Set.insert (priority t)\n   (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)) =\n  Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n  set (bt_dfs priority r)\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "with A"], ["proof (chain)\npicking this:\n  Min (set (bt_dfs priority t)) =\n  Min (Set.insert (priority t)\n        (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)))\n  Set.insert (priority t)\n   (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)) =\n  Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n  set (bt_dfs priority r)", "have \"?M = Min\n    (Set.insert (priority t) (set (bts_dfs priority rs)) \\<union> set (bt_dfs priority r))\""], ["proof (prove)\nusing this:\n  Min (set (bt_dfs priority t)) =\n  Min (Set.insert (priority t)\n        (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)))\n  Set.insert (priority t)\n   (set (bt_dfs priority r) \\<union> set (bts_dfs priority rs)) =\n  Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n  set (bt_dfs priority r)\n\ngoal (1 subgoal):\n 1. Min (set (bt_dfs priority t)) =\n    Min (Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n         set (bt_dfs priority r))", "by simp"], ["proof (state)\nthis:\n  Min (set (bt_dfs priority t)) =\n  Min (Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n       set (bt_dfs priority r))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "with Min_Un\n    [of \"Set.insert (priority t) (set (bts_dfs priority rs))\" \"set (bt_dfs priority r)\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (Set.insert (priority t) (set (bts_dfs priority rs)));\n   Set.insert (priority t) (set (bts_dfs priority rs)) \\<noteq> {};\n   finite (set (bt_dfs priority r));\n   set (bt_dfs priority r) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min (Set.insert (priority t)\n                          (set (bts_dfs priority rs)) \\<union>\n                         set (bt_dfs priority r)) =\n                    ord_class.min\n                     (Min (Set.insert (priority t)\n                            (set (bts_dfs priority rs))))\n                     (Min (set (bt_dfs priority r)))\n  Min (set (bt_dfs priority t)) =\n  Min (Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n       set (bt_dfs priority r))", "have \"?M =\n    ord_class.min (Min (Set.insert (priority t) (set (bts_dfs priority rs))))\n      (Min (set (bt_dfs priority r)))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (Set.insert (priority t) (set (bts_dfs priority rs)));\n   Set.insert (priority t) (set (bts_dfs priority rs)) \\<noteq> {};\n   finite (set (bt_dfs priority r));\n   set (bt_dfs priority r) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min (Set.insert (priority t)\n                          (set (bts_dfs priority rs)) \\<union>\n                         set (bt_dfs priority r)) =\n                    ord_class.min\n                     (Min (Set.insert (priority t)\n                            (set (bts_dfs priority rs))))\n                     (Min (set (bt_dfs priority r)))\n  Min (set (bt_dfs priority t)) =\n  Min (Set.insert (priority t) (set (bts_dfs priority rs)) \\<union>\n       set (bt_dfs priority r))\n\ngoal (1 subgoal):\n 1. Min (set (bt_dfs priority t)) =\n    ord_class.min\n     (Min (Set.insert (priority t) (set (bts_dfs priority rs))))\n     (Min (set (bt_dfs priority r)))", "by (auto simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  Min (set (bt_dfs priority t)) =\n  ord_class.min (Min (Set.insert (priority t) (set (bts_dfs priority rs))))\n   (Min (set (bt_dfs priority r)))\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "ultimately"], ["proof (chain)\npicking this:\n  priority t = Min (Set.insert (priority t) (set (bts_dfs priority rs)))\n  priority r = Min (set (bt_dfs priority r))\n  Min (set (bt_dfs priority t)) =\n  ord_class.min (Min (Set.insert (priority t) (set (bts_dfs priority rs))))\n   (Min (set (bt_dfs priority r)))", "have \"?M = ord_class.min (priority t) (priority r)\""], ["proof (prove)\nusing this:\n  priority t = Min (Set.insert (priority t) (set (bts_dfs priority rs)))\n  priority r = Min (set (bt_dfs priority r))\n  Min (set (bt_dfs priority t)) =\n  ord_class.min (Min (Set.insert (priority t) (set (bts_dfs priority rs))))\n   (Min (set (bt_dfs priority r)))\n\ngoal (1 subgoal):\n 1. Min (set (bt_dfs priority t)) = ord_class.min (priority t) (priority r)", "by simp"], ["proof (state)\nthis:\n  Min (set (bt_dfs priority t)) = ord_class.min (priority t) (priority r)\n\ngoal (1 subgoal):\n 1. \\<And>ts t ta.\n       \\<lbrakk>is_heap_list (priority ta) ts;\n        \\<And>t.\n           \\<lbrakk>priority ta = priority t; ts = children t\\<rbrakk>\n           \\<Longrightarrow> priority t = Min (set (bt_dfs priority t));\n        is_heap_list (priority t) (children t);\n        \\<And>ta.\n           \\<lbrakk>priority t = priority ta;\n            children t = children ta\\<rbrakk>\n           \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta));\n        priority ta \\<le> priority t; t # ts = children ta\\<rbrakk>\n       \\<Longrightarrow> priority ta = Min (set (bt_dfs priority ta))", "with \\<open>priority t \\<le> priority r\\<close>"], ["proof (chain)\npicking this:\n  priority t \\<le> priority r\n  Min (set (bt_dfs priority t)) = ord_class.min (priority t) (priority r)", "show ?case"], ["proof (prove)\nusing this:\n  priority t \\<le> priority r\n  Min (set (bt_dfs priority t)) = ord_class.min (priority t) (priority r)\n\ngoal (1 subgoal):\n 1. priority t = Min (set (bt_dfs priority t))", "by (auto simp add: ord_class.min_def)"], ["proof (state)\nthis:\n  priority t = Min (set (bt_dfs priority t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_binqueue_min_Min_prios:\n  assumes \"is_binqueue l xs\"\n  and \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  shows \"min xs = Some (Min (set (prios xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = Some (Min (set (prios xs)))", "using assms"], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  normalized xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = Some (Min (set (prios xs)))", "proof (induct xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>normalized []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min [] = Some (Min (set (prios [])))\n 2. \\<And>l xs.\n       \\<lbrakk>is_binqueue (Suc l) xs;\n        \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> Binomial_Queue.min xs =\n                          Some (Min (set (prios xs)));\n        normalized (None # xs); None # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (None # xs) =\n                         Some (Min (set (prios (None # xs))))\n 3. \\<And>l xs t.\n       \\<lbrakk>is_binqueue (Suc l) xs;\n        \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> Binomial_Queue.min xs =\n                          Some (Min (set (prios xs)));\n        is_bintree_list l (children t);\n        is_heap_list (priority t) (children t); normalized (Some t # xs);\n        Some t # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (Some t # xs) =\n                         Some (Min (set (prios (Some t # xs))))", "case (Some l xs x)"], ["proof (state)\nthis:\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>normalized []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min [] = Some (Min (set (prios [])))\n 2. \\<And>l xs.\n       \\<lbrakk>is_binqueue (Suc l) xs;\n        \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> Binomial_Queue.min xs =\n                          Some (Min (set (prios xs)));\n        normalized (None # xs); None # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (None # xs) =\n                         Some (Min (set (prios (None # xs))))\n 3. \\<And>l xs t.\n       \\<lbrakk>is_binqueue (Suc l) xs;\n        \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> Binomial_Queue.min xs =\n                          Some (Min (set (prios xs)));\n        is_bintree_list l (children t);\n        is_heap_list (priority t) (children t); normalized (Some t # xs);\n        Some t # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (Some t # xs) =\n                         Some (Min (set (prios (Some t # xs))))", "then"], ["proof (chain)\npicking this:\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some x # xs) =\n    Some (Min (set (prios (Some x # xs))))", "proof (cases \"xs \\<noteq> []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))\n 2. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     \\<not> xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "case False"], ["proof (state)\nthis:\n  \\<not> xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))\n 2. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     \\<not> xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "with Some"], ["proof (chain)\npicking this:\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n  \\<not> xs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n  \\<not> xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some x # xs) =\n    Some (Min (set (prios (Some x # xs))))", "using bt_dfs_Min_priority[of x]"], ["proof (prove)\nusing this:\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n  \\<not> xs \\<noteq> []\n  is_heap_list (priority x) (children x) \\<Longrightarrow>\n  priority x = Min (set (bt_dfs priority x))\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some x # xs) =\n    Some (Min (set (prios (Some x # xs))))", "by (simp add: min_single)"], ["proof (state)\nthis:\n  Binomial_Queue.min (Some x # xs) = Some (Min (set (prios (Some x # xs))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "case True"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "note T = this Some"], ["proof (state)\nthis:\n  xs \\<noteq> []\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "from T"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []", "have \"normalized xs\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. normalized xs", "by simp"], ["proof (state)\nthis:\n  normalized xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "with \\<open>xs \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  normalized xs", "have \"prios xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  normalized xs\n\ngoal (1 subgoal):\n 1. prios xs \\<noteq> []", "by (induct xs) (simp_all add: bt_dfs_simp)"], ["proof (state)\nthis:\n  prios xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue (Suc l) xs;\n     \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)));\n     is_bintree_list l (children x); is_heap_list (priority x) (children x);\n     normalized (Some x # xs); Some x # xs \\<noteq> [];\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min (Some x # xs) =\n                      Some (Min (set (prios (Some x # xs))))", "with T"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n  prios xs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n  prios xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some x # xs) =\n    Some (Min (set (prios (Some x # xs))))", "using Min_Un[of \"set (bt_dfs priority x)\" \"set (prios xs)\"]"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n  prios xs \\<noteq> []\n  \\<lbrakk>finite (set (bt_dfs priority x));\n   set (bt_dfs priority x) \\<noteq> {}; finite (set (prios xs));\n   set (prios xs) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min (set (bt_dfs priority x) \\<union> set (prios xs)) =\n                    ord_class.min (Min (set (bt_dfs priority x)))\n                     (Min (set (prios xs)))\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some x # xs) =\n    Some (Min (set (prios (Some x # xs))))", "using bt_dfs_Min_priority[of x]"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  is_binqueue (Suc l) xs\n  \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Binomial_Queue.min xs = Some (Min (set (prios xs)))\n  is_bintree_list l (children x)\n  is_heap_list (priority x) (children x)\n  normalized (Some x # xs)\n  Some x # xs \\<noteq> []\n  prios xs \\<noteq> []\n  \\<lbrakk>finite (set (bt_dfs priority x));\n   set (bt_dfs priority x) \\<noteq> {}; finite (set (prios xs));\n   set (prios xs) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min (set (bt_dfs priority x) \\<union> set (prios xs)) =\n                    ord_class.min (Min (set (bt_dfs priority x)))\n                     (Min (set (prios xs)))\n  is_heap_list (priority x) (children x) \\<Longrightarrow>\n  priority x = Min (set (bt_dfs priority x))\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some x # xs) =\n    Some (Min (set (prios (Some x # xs))))", "by (auto simp add: bt_dfs_simp ord_class.min_def)"], ["proof (state)\nthis:\n  Binomial_Queue.min (Some x # xs) = Some (Min (set (prios (Some x # xs))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Binomial_Queue.min (Some x # xs) = Some (Min (set (prios (Some x # xs))))\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>normalized []; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min [] = Some (Min (set (prios [])))\n 2. \\<And>l xs.\n       \\<lbrakk>is_binqueue (Suc l) xs;\n        \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> Binomial_Queue.min xs =\n                          Some (Min (set (prios xs)));\n        normalized (None # xs); None # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (None # xs) =\n                         Some (Min (set (prios (None # xs))))", "qed simp_all"], ["", "lemma min_p_min:\n  assumes \"is_binqueue l xs\"\n  and \"xs \\<noteq> []\"\n  and \"normalized xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  shows \"min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "from \\<open>xs \\<noteq> []\\<close> \\<open>normalized xs\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> []\n  normalized xs", "have \"\\<not> PQ.is_empty (pqueue xs)\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  normalized xs\n\ngoal (1 subgoal):\n 1. \\<not> PQ.is_empty (pqueue xs)", "by (simp add: empty_empty)"], ["proof (state)\nthis:\n  \\<not> PQ.is_empty (pqueue xs)\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "moreover"], ["proof (state)\nthis:\n  \\<not> PQ.is_empty (pqueue xs)\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "from assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)", "have \"min xs = Some (Min (set (prios xs)))\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = Some (Min (set (prios xs)))", "by (simp add: is_binqueue_min_Min_prios)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = Some (Min (set (prios xs)))\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "with \\<open>distinct (vals xs)\\<close>"], ["proof (chain)\npicking this:\n  distinct (vals xs)\n  Binomial_Queue.min xs = Some (Min (set (prios xs)))", "have \"min xs = Some (Min (set \\<parallel>pqueue xs\\<parallel> ))\""], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  Binomial_Queue.min xs = Some (Min (set (prios xs)))\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = Some (Min (set \\<parallel>pqueue xs\\<parallel>))", "by (simp add: prios_pqueue)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = Some (Min (set \\<parallel>pqueue xs\\<parallel>))\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> PQ.is_empty (pqueue xs)\n  Binomial_Queue.min xs = Some (Min (set \\<parallel>pqueue xs\\<parallel>))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> PQ.is_empty (pqueue xs)\n  Binomial_Queue.min xs = Some (Min (set \\<parallel>pqueue xs\\<parallel>))\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "by (simp add: priority_Min_priorities [where q = \"pqueue xs\"] )"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_min_p_min:\n  assumes \"is_binqueue l xs\"\n  and \"xs \\<noteq> []\"\n  and \"normalized xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  shows \"priority (the (find_min xs)) =\n    the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. priority (the (find_min xs)) =\n    the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. priority (the (find_min xs)) =\n    the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))", "from assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)", "have \"min xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> None", "by (simp add: normalized_min_not_None)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. priority (the (find_min xs)) =\n    the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))", "from assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)", "have \"min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "by (simp add: min_p_min)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))\n\ngoal (1 subgoal):\n 1. priority (the (find_min xs)) =\n    the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))", "with \\<open>min xs \\<noteq> None\\<close>"], ["proof (chain)\npicking this:\n  Binomial_Queue.min xs \\<noteq> None\n  Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs \\<noteq> None\n  Binomial_Queue.min xs = PQ.priority (pqueue xs) (PQ.min (pqueue xs))\n\ngoal (1 subgoal):\n 1. priority (the (find_min xs)) =\n    the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))", "by (auto simp add: min_eq_find_min_Some)"], ["proof (state)\nthis:\n  priority (the (find_min xs)) =\n  the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_min_v_min:\n  assumes \"is_binqueue l xs\"\n  and \"xs \\<noteq> []\"\n  and \"normalized xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  shows \"val (the (find_min xs)) = PQ.min (pqueue xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "from assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)", "have \"min xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> None", "by (simp add: normalized_min_not_None)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "then"], ["proof (chain)\npicking this:\n  Binomial_Queue.min xs \\<noteq> None", "obtain a where oa: \"Some a = min xs\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        Some a = Binomial_Queue.min xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Some a = Binomial_Queue.min xs\n\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "then"], ["proof (chain)\npicking this:\n  Some a = Binomial_Queue.min xs", "obtain t where ot: \"find_min xs = Some t\" \"priority t = a\""], ["proof (prove)\nusing this:\n  Some a = Binomial_Queue.min xs\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>find_min xs = Some t; priority t = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using min_eq_find_min_Some [of xs a]"], ["proof (prove)\nusing this:\n  Some a = Binomial_Queue.min xs\n  (Binomial_Queue.min xs = Some a) =\n  (\\<exists>t. find_min xs = Some t \\<and> priority t = a)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>find_min xs = Some t; priority t = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  find_min xs = Some t\n  priority t = a\n\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "hence *: \"(val t, a) \\<in> set (dfs alist xs)\""], ["proof (prove)\nusing this:\n  find_min xs = Some t\n  priority t = a\n\ngoal (1 subgoal):\n 1. (val t, a) \\<in> set (elements xs)", "by (auto simp add: find_min_exist in_set_in_alist)"], ["proof (state)\nthis:\n  (val t, a) \\<in> set (elements xs)\n\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "have \"PQ.min (pqueue xs) = val t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PQ.min (pqueue xs) = val t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. PQ.min (pqueue xs) \\<noteq> val t \\<Longrightarrow> False", "assume A: \"PQ.min (pqueue xs) \\<noteq> val t\""], ["proof (state)\nthis:\n  PQ.min (pqueue xs) \\<noteq> val t\n\ngoal (1 subgoal):\n 1. PQ.min (pqueue xs) \\<noteq> val t \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  PQ.min (pqueue xs) \\<noteq> val t", "obtain t' where ot':\"PQ.min (pqueue xs) = t'\""], ["proof (prove)\nusing this:\n  PQ.min (pqueue xs) \\<noteq> val t\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        PQ.min (pqueue xs) = t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  PQ.min (pqueue xs) = t'\n\ngoal (1 subgoal):\n 1. PQ.min (pqueue xs) \\<noteq> val t \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  PQ.min (pqueue xs) \\<noteq> val t\n  PQ.min (pqueue xs) = t'", "have NE: \"val t \\<noteq> t'\""], ["proof (prove)\nusing this:\n  PQ.min (pqueue xs) \\<noteq> val t\n  PQ.min (pqueue xs) = t'\n\ngoal (1 subgoal):\n 1. val t \\<noteq> t'", "by simp"], ["proof (state)\nthis:\n  val t \\<noteq> t'\n\ngoal (1 subgoal):\n 1. PQ.min (pqueue xs) \\<noteq> val t \\<Longrightarrow> False", "from ot' oa assms"], ["proof (chain)\npicking this:\n  PQ.min (pqueue xs) = t'\n  Some a = Binomial_Queue.min xs\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)", "have \"(t', a) \\<in> set (dfs alist xs)\""], ["proof (prove)\nusing this:\n  PQ.min (pqueue xs) = t'\n  Some a = Binomial_Queue.min xs\n  is_binqueue l xs\n  xs \\<noteq> []\n  normalized xs\n  distinct (vals xs)\n  distinct (prios xs)\n\ngoal (1 subgoal):\n 1. (t', a) \\<in> set (elements xs)", "by (simp add: alist_pqueue PQ.priority_def min_p_min)"], ["proof (state)\nthis:\n  (t', a) \\<in> set (elements xs)\n\ngoal (1 subgoal):\n 1. PQ.min (pqueue xs) \\<noteq> val t \\<Longrightarrow> False", "with * NE"], ["proof (chain)\npicking this:\n  (val t, a) \\<in> set (elements xs)\n  val t \\<noteq> t'\n  (t', a) \\<in> set (elements xs)", "have \"\\<not> distinct (prios xs)\""], ["proof (prove)\nusing this:\n  (val t, a) \\<in> set (elements xs)\n  val t \\<noteq> t'\n  (t', a) \\<in> set (elements xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (prios xs)", "unfolding alist_split(2)"], ["proof (prove)\nusing this:\n  (val t, a) \\<in> set (elements xs)\n  val t \\<noteq> t'\n  (t', a) \\<in> set (elements xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (dfs (snd \\<circ> alist) xs)", "unfolding dfs_comp"], ["proof (prove)\nusing this:\n  (val t, a) \\<in> set (elements xs)\n  val t \\<noteq> t'\n  (t', a) \\<in> set (elements xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (map snd (elements xs))", "by (induct (\"dfs alist xs\")) (auto simp add: rev_image_eqI)"], ["proof (state)\nthis:\n  \\<not> distinct (prios xs)\n\ngoal (1 subgoal):\n 1. PQ.min (pqueue xs) \\<noteq> val t \\<Longrightarrow> False", "with \\<open>distinct (prios xs)\\<close>"], ["proof (chain)\npicking this:\n  distinct (prios xs)\n  \\<not> distinct (prios xs)", "show False"], ["proof (prove)\nusing this:\n  distinct (prios xs)\n  \\<not> distinct (prios xs)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  PQ.min (pqueue xs) = val t\n\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "with ot"], ["proof (chain)\npicking this:\n  find_min xs = Some t\n  priority t = a\n  PQ.min (pqueue xs) = val t", "show ?thesis"], ["proof (prove)\nusing this:\n  find_min xs = Some t\n  priority t = a\n  PQ.min (pqueue xs) = val t\n\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = PQ.min (pqueue xs)", "by auto"], ["proof (state)\nthis:\n  val (the (find_min xs)) = PQ.min (pqueue xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alist_normalize_idem:\n  \"dfs alist (normalize xs) = dfs alist xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements (Binomial_Queue.normalize xs) = elements xs", "unfolding normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. elements (rev (normalize' (rev xs))) = elements xs", "proof (induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. elements (rev (normalize' (rev []))) = elements []\n 2. \\<And>x xs.\n       elements (rev (normalize' (rev xs))) = elements xs \\<Longrightarrow>\n       elements (rev (normalize' (rev (xs @ [x])))) = elements (xs @ [x])", "case (snoc x xs)"], ["proof (state)\nthis:\n  elements (rev (normalize' (rev xs))) = elements xs\n\ngoal (2 subgoals):\n 1. elements (rev (normalize' (rev []))) = elements []\n 2. \\<And>x xs.\n       elements (rev (normalize' (rev xs))) = elements xs \\<Longrightarrow>\n       elements (rev (normalize' (rev (xs @ [x])))) = elements (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  elements (rev (normalize' (rev xs))) = elements xs", "show ?case"], ["proof (prove)\nusing this:\n  elements (rev (normalize' (rev xs))) = elements xs\n\ngoal (1 subgoal):\n 1. elements (rev (normalize' (rev (xs @ [x])))) = elements (xs @ [x])", "by (cases x) (simp_all add: dfs_append)"], ["proof (state)\nthis:\n  elements (rev (normalize' (rev (xs @ [x])))) = elements (xs @ [x])\n\ngoal (1 subgoal):\n 1. elements (rev (normalize' (rev []))) = elements []", "qed simp"], ["", "lemma dfs_match_not_in:\n  \"(\\<forall> t. Some t \\<in> set xs \\<longrightarrow> priority t \\<noteq> a) \\<Longrightarrow>\n    set (dfs f (map (match a) xs)) = set (dfs f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       Some t \\<in> set xs \\<longrightarrow>\n       priority t \\<noteq> a \\<Longrightarrow>\n    set (dfs f (map (match a) xs)) = set (dfs f xs)", "by (induct xs) simp_all"], ["", "lemma dfs_match_subset:\n  \"set (dfs f (map (match a) xs)) \\<subseteq> set (dfs f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) xs)) \\<subseteq> set (dfs f xs)", "proof (induct xs rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (dfs f (map (match a) [])) \\<subseteq> set (dfs f [])\n 2. \\<And>x1 x2.\n       set (dfs f (map (match a) x2))\n       \\<subseteq> set (dfs f x2) \\<Longrightarrow>\n       set (dfs f (map (match a) (x1 # x2)))\n       \\<subseteq> set (dfs f (x1 # x2))", "case (Cons x xs)"], ["proof (state)\nthis:\n  set (dfs f (map (match a) xs)) \\<subseteq> set (dfs f xs)\n\ngoal (2 subgoals):\n 1. set (dfs f (map (match a) [])) \\<subseteq> set (dfs f [])\n 2. \\<And>x1 x2.\n       set (dfs f (map (match a) x2))\n       \\<subseteq> set (dfs f x2) \\<Longrightarrow>\n       set (dfs f (map (match a) (x1 # x2)))\n       \\<subseteq> set (dfs f (x1 # x2))", "then"], ["proof (chain)\npicking this:\n  set (dfs f (map (match a) xs)) \\<subseteq> set (dfs f xs)", "show ?case"], ["proof (prove)\nusing this:\n  set (dfs f (map (match a) xs)) \\<subseteq> set (dfs f xs)\n\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) (x # xs))) \\<subseteq> set (dfs f (x # xs))", "by (cases x) auto"], ["proof (state)\nthis:\n  set (dfs f (map (match a) (x # xs))) \\<subseteq> set (dfs f (x # xs))\n\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) [])) \\<subseteq> set (dfs f [])", "qed simp"], ["", "lemma dfs_match_distinct:\n  \"distinct (dfs f xs) \\<Longrightarrow> distinct (dfs f (map (match a) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (dfs f xs) \\<Longrightarrow>\n    distinct (dfs f (map (match a) xs))", "proof (induct xs rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (dfs f []) \\<Longrightarrow>\n    distinct (dfs f (map (match a) []))\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (dfs f x2) \\<Longrightarrow>\n                distinct (dfs f (map (match a) x2));\n        distinct (dfs f (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> distinct (dfs f (map (match a) (x1 # x2)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct (dfs f xs) \\<Longrightarrow> distinct (dfs f (map (match a) xs))\n  distinct (dfs f (x # xs))\n\ngoal (2 subgoals):\n 1. distinct (dfs f []) \\<Longrightarrow>\n    distinct (dfs f (map (match a) []))\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (dfs f x2) \\<Longrightarrow>\n                distinct (dfs f (map (match a) x2));\n        distinct (dfs f (x1 # x2))\\<rbrakk>\n       \\<Longrightarrow> distinct (dfs f (map (match a) (x1 # x2)))", "then"], ["proof (chain)\npicking this:\n  distinct (dfs f xs) \\<Longrightarrow> distinct (dfs f (map (match a) xs))\n  distinct (dfs f (x # xs))", "show ?case"], ["proof (prove)\nusing this:\n  distinct (dfs f xs) \\<Longrightarrow> distinct (dfs f (map (match a) xs))\n  distinct (dfs f (x # xs))\n\ngoal (1 subgoal):\n 1. distinct (dfs f (map (match a) (x # xs)))", "using dfs_match_subset[of f a xs]"], ["proof (prove)\nusing this:\n  distinct (dfs f xs) \\<Longrightarrow> distinct (dfs f (map (match a) xs))\n  distinct (dfs f (x # xs))\n  set (dfs f (map (match a) xs)) \\<subseteq> set (dfs f xs)\n\ngoal (1 subgoal):\n 1. distinct (dfs f (map (match a) (x # xs)))", "by (cases x, auto)"], ["proof (state)\nthis:\n  distinct (dfs f (map (match a) (x # xs)))\n\ngoal (1 subgoal):\n 1. distinct (dfs f []) \\<Longrightarrow>\n    distinct (dfs f (map (match a) []))", "qed simp"], ["", "lemma dfs_match:\n  \"distinct (prios xs) \\<Longrightarrow> \n   distinct (dfs f xs) \\<Longrightarrow>\n   Some t \\<in> set xs \\<Longrightarrow> \n   priority t = a \\<Longrightarrow> \n   set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some t \\<in> set xs;\n     priority t = a\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                      set (dfs f xs) - set (bt_dfs f t)", "proof (induct xs arbitrary: t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>distinct (prios []); distinct (dfs f []);\n        Some t \\<in> set []; priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) [])) =\n                         set (dfs f []) - set (bt_dfs f t)\n 2. \\<And>xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                    Some t \\<in> set xs; priority t = a\\<rbrakk>\n                   \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                     set (dfs f xs) - set (bt_dfs f t);\n        distinct (prios (None # xs)); distinct (dfs f (None # xs));\n        Some t \\<in> set (None # xs); priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) (None # xs))) =\n                         set (dfs f (None # xs)) - set (bt_dfs f t)\n 3. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                    Some t \\<in> set xs; priority t = a\\<rbrakk>\n                   \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                     set (dfs f xs) - set (bt_dfs f t);\n        distinct (prios (Some x # xs)); distinct (dfs f (Some x # xs));\n        Some t \\<in> set (Some x # xs); priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) (Some x # xs))) =\n                         set (dfs f (Some x # xs)) - set (bt_dfs f t)", "case (Some r xs t)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>distinct (prios []); distinct (dfs f []);\n        Some t \\<in> set []; priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) [])) =\n                         set (dfs f []) - set (bt_dfs f t)\n 2. \\<And>xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                    Some t \\<in> set xs; priority t = a\\<rbrakk>\n                   \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                     set (dfs f xs) - set (bt_dfs f t);\n        distinct (prios (None # xs)); distinct (dfs f (None # xs));\n        Some t \\<in> set (None # xs); priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) (None # xs))) =\n                         set (dfs f (None # xs)) - set (bt_dfs f t)\n 3. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                    Some t \\<in> set xs; priority t = a\\<rbrakk>\n                   \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                     set (dfs f xs) - set (bt_dfs f t);\n        distinct (prios (Some x # xs)); distinct (dfs f (Some x # xs));\n        Some t \\<in> set (Some x # xs); priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) (Some x # xs))) =\n                         set (dfs f (Some x # xs)) - set (bt_dfs f t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) (Some r # xs))) =\n    set (dfs f (Some r # xs)) - set (bt_dfs f t)", "proof (cases \"t = r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t = r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "case True"], ["proof (state)\nthis:\n  t = r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t = r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "from Some"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a", "have \"priority r \\<notin> set (prios xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n\ngoal (1 subgoal):\n 1. priority r \\<notin> set (prios xs)", "by (auto simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  priority r \\<notin> set (prios xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t = r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "with Some True"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t = r\n  priority r \\<notin> set (prios xs)", "have \"a \\<notin> set (prios xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t = r\n  priority r \\<notin> set (prios xs)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (prios xs)", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set (prios xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t = r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "hence \"\\<forall> s. Some s \\<in> set xs \\<longrightarrow> priority s \\<noteq> a\""], ["proof (prove)\nusing this:\n  a \\<notin> set (prios xs)\n\ngoal (1 subgoal):\n 1. \\<forall>s. Some s \\<in> set xs \\<longrightarrow> priority s \\<noteq> a", "by (induct xs) (auto simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  \\<forall>s. Some s \\<in> set xs \\<longrightarrow> priority s \\<noteq> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t = r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "hence \"set (dfs f (map (match a) xs)) = set (dfs f xs)\""], ["proof (prove)\nusing this:\n  \\<forall>s. Some s \\<in> set xs \\<longrightarrow> priority s \\<noteq> a\n\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) xs)) = set (dfs f xs)", "by (simp add: dfs_match_not_in)"], ["proof (state)\nthis:\n  set (dfs f (map (match a) xs)) = set (dfs f xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t = r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "with True Some"], ["proof (chain)\npicking this:\n  t = r\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  set (dfs f (map (match a) xs)) = set (dfs f xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  t = r\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  set (dfs f (map (match a) xs)) = set (dfs f xs)\n\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) (Some r # xs))) =\n    set (dfs f (Some r # xs)) - set (bt_dfs f t)", "by auto"], ["proof (state)\nthis:\n  set (dfs f (map (match a) (Some r # xs))) =\n  set (dfs f (Some r # xs)) - set (bt_dfs f t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "case False"], ["proof (state)\nthis:\n  t \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "with Some.prems"], ["proof (chain)\npicking this:\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t \\<noteq> r", "have \"Some t \\<in> set xs\""], ["proof (prove)\nusing this:\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t \\<noteq> r\n\ngoal (1 subgoal):\n 1. Some t \\<in> set xs", "by simp"], ["proof (state)\nthis:\n  Some t \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "with \\<open>priority t = a\\<close>"], ["proof (chain)\npicking this:\n  priority t = a\n  Some t \\<in> set xs", "have \"a \\<in> set (prios xs)\""], ["proof (prove)\nusing this:\n  priority t = a\n  Some t \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<in> set (prios xs)", "proof (induct xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>priority t = a; Some t \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (prios [])\n 2. \\<And>xs.\n       \\<lbrakk>\\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> a \\<in> set (prios xs);\n        priority t = a; Some t \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (prios (None # xs))\n 3. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> a \\<in> set (prios xs);\n        priority t = a; Some t \\<in> set (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (prios (Some x # xs))", "case (Some x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> a \\<in> set (prios xs)\n  priority t = a\n  Some t \\<in> set (Some x # xs)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>priority t = a; Some t \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (prios [])\n 2. \\<And>xs.\n       \\<lbrakk>\\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> a \\<in> set (prios xs);\n        priority t = a; Some t \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (prios (None # xs))\n 3. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> a \\<in> set (prios xs);\n        priority t = a; Some t \\<in> set (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (prios (Some x # xs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> a \\<in> set (prios xs)\n  priority t = a\n  Some t \\<in> set (Some x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> a \\<in> set (prios xs)\n  priority t = a\n  Some t \\<in> set (Some x # xs)\n\ngoal (1 subgoal):\n 1. a \\<in> set (prios (Some x # xs))", "by (cases \"t = x\") (simp_all add: bt_dfs_simp)"], ["proof (state)\nthis:\n  a \\<in> set (prios (Some x # xs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>priority t = a; Some t \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> a \\<in> set (prios [])\n 2. \\<And>xs.\n       \\<lbrakk>\\<lbrakk>priority t = a; Some t \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> a \\<in> set (prios xs);\n        priority t = a; Some t \\<in> set (None # xs)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (prios (None # xs))", "qed simp_all"], ["proof (state)\nthis:\n  a \\<in> set (prios xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "with False Some"], ["proof (chain)\npicking this:\n  t \\<noteq> r\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  a \\<in> set (prios xs)", "have \"priority r \\<noteq> a\""], ["proof (prove)\nusing this:\n  t \\<noteq> r\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  a \\<in> set (prios xs)\n\ngoal (1 subgoal):\n 1. priority r \\<noteq> a", "by (auto simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  priority r \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "moreover"], ["proof (state)\nthis:\n  priority r \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "from Some False"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t \\<noteq> r", "have \"set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (prios xs); distinct (dfs f xs); Some ?t \\<in> set xs;\n   priority ?t = a\\<rbrakk>\n  \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                    set (dfs f xs) - set (bt_dfs f ?t)\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t \\<noteq> r\n\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)", "by simp"], ["proof (state)\nthis:\n  set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "moreover"], ["proof (state)\nthis:\n  set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "from Some.prems False"], ["proof (chain)\npicking this:\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t \\<noteq> r", "have \"set (bt_dfs f t) \\<inter> set (bt_dfs f r) = {}\""], ["proof (prove)\nusing this:\n  distinct (prios (Some r # xs))\n  distinct (dfs f (Some r # xs))\n  Some t \\<in> set (Some r # xs)\n  priority t = a\n  t \\<noteq> r\n\ngoal (1 subgoal):\n 1. set (bt_dfs f t) \\<inter> set (bt_dfs f r) = {}", "by (induct xs) auto"], ["proof (state)\nthis:\n  set (bt_dfs f t) \\<inter> set (bt_dfs f r) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "hence \"set (bt_dfs f r) - set (bt_dfs f t) = set (bt_dfs f r)\""], ["proof (prove)\nusing this:\n  set (bt_dfs f t) \\<inter> set (bt_dfs f r) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs f r) - set (bt_dfs f t) = set (bt_dfs f r)", "by auto"], ["proof (state)\nthis:\n  set (bt_dfs f r) - set (bt_dfs f t) = set (bt_dfs f r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                 Some t \\<in> set xs; priority t = a\\<rbrakk>\n                \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                  set (dfs f xs) - set (bt_dfs f t);\n     distinct (prios (Some r # xs)); distinct (dfs f (Some r # xs));\n     Some t \\<in> set (Some r # xs); priority t = a; t \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> set (dfs f (map (match a) (Some r # xs))) =\n                      set (dfs f (Some r # xs)) - set (bt_dfs f t)", "ultimately"], ["proof (chain)\npicking this:\n  priority r \\<noteq> a\n  set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)\n  set (bt_dfs f r) - set (bt_dfs f t) = set (bt_dfs f r)", "show ?thesis"], ["proof (prove)\nusing this:\n  priority r \\<noteq> a\n  set (dfs f (map (match a) xs)) = set (dfs f xs) - set (bt_dfs f t)\n  set (bt_dfs f r) - set (bt_dfs f t) = set (bt_dfs f r)\n\ngoal (1 subgoal):\n 1. set (dfs f (map (match a) (Some r # xs))) =\n    set (dfs f (Some r # xs)) - set (bt_dfs f t)", "by auto"], ["proof (state)\nthis:\n  set (dfs f (map (match a) (Some r # xs))) =\n  set (dfs f (Some r # xs)) - set (bt_dfs f t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (dfs f (map (match a) (Some r # xs))) =\n  set (dfs f (Some r # xs)) - set (bt_dfs f t)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>distinct (prios []); distinct (dfs f []);\n        Some t \\<in> set []; priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) [])) =\n                         set (dfs f []) - set (bt_dfs f t)\n 2. \\<And>xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (prios xs); distinct (dfs f xs);\n                    Some t \\<in> set xs; priority t = a\\<rbrakk>\n                   \\<Longrightarrow> set (dfs f (map (match a) xs)) =\n                                     set (dfs f xs) - set (bt_dfs f t);\n        distinct (prios (None # xs)); distinct (dfs f (None # xs));\n        Some t \\<in> set (None # xs); priority t = a\\<rbrakk>\n       \\<Longrightarrow> set (dfs f (map (match a) (None # xs))) =\n                         set (dfs f (None # xs)) - set (bt_dfs f t)", "qed simp_all"], ["", "lemma alist_meld:\n  \"distinct (dfs val xs) \\<Longrightarrow> distinct (dfs val ys) \\<Longrightarrow>\n   set (dfs val xs) \\<inter> set (dfs val ys) = {} \\<Longrightarrow>\n   set (dfs alist (meld xs ys)) = set (dfs alist xs) \\<union> set (dfs alist ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (vals xs); distinct (vals ys);\n     set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n    \\<Longrightarrow> set (elements (meld xs ys)) =\n                      set (elements xs) \\<union> set (elements ys)", "proof (induct xs ys rule: meld.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (None # xs) (y # ys))) =\n                         set (elements (None # xs)) \\<union>\n                         set (elements (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (x # xs) (None # ys))) =\n                         set (elements (x # xs)) \\<union>\n                         set (elements (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "case (3 xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (None # xs) (y # ys))) =\n                         set (elements (None # xs)) \\<union>\n                         set (elements (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (x # xs) (None # ys))) =\n                         set (elements (x # xs)) \\<union>\n                         set (elements (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "have \"set (dfs alist (y # meld xs ys)) =\n    set (dfs alist xs) \\<union> set (dfs alist (y # ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "note assms = \"3\""], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "have \"set (vals xs) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "using set_dfs_Cons[of val y ys]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n  set (vals (y # ys)) = set (vals ys) \\<union> set (vals [y])\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "by auto"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "moreover"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "have \"distinct (vals ys)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals ys)", "by (cases y) simp_all"], ["proof (state)\nthis:\n  distinct (vals ys)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "moreover"], ["proof (state)\nthis:\n  distinct (vals ys)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "have \"distinct (vals xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals xs)", "by simp"], ["proof (state)\nthis:\n  distinct (vals xs)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "moreover"], ["proof (state)\nthis:\n  distinct (vals xs)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "note assms"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "ultimately"], ["proof (chain)\npicking this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  distinct (vals ys)\n  distinct (vals xs)\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}", "have \"set (dfs alist (meld xs ys)) =\n      set (dfs alist xs) \\<union> set (dfs alist ys)\""], ["proof (prove)\nusing this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  distinct (vals ys)\n  distinct (vals xs)\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (None # xs))\n  distinct (vals (y # ys))\n  set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (meld xs ys)) =\n    set (elements xs) \\<union> set (elements ys)", "by simp"], ["proof (state)\nthis:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "hence \"set (dfs alist (y # meld xs ys)) =\n      set (dfs alist [y]) \\<union> set (dfs alist xs) \\<union> set (dfs alist ys)\""], ["proof (prove)\nusing this:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements [y]) \\<union> set (elements xs) \\<union> set (elements ys)", "using set_dfs_Cons[of alist y \"meld xs ys\"]"], ["proof (prove)\nusing this:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n  set (elements (y # meld xs ys)) =\n  set (elements (meld xs ys)) \\<union> set (elements [y])\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements [y]) \\<union> set (elements xs) \\<union> set (elements ys)", "by auto"], ["proof (state)\nthis:\n  set (elements (y # meld xs ys)) =\n  set (elements [y]) \\<union> set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "then"], ["proof (chain)\npicking this:\n  set (elements (y # meld xs ys)) =\n  set (elements [y]) \\<union> set (elements xs) \\<union> set (elements ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (elements (y # meld xs ys)) =\n  set (elements [y]) \\<union> set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "using set_dfs_Cons[of alist y ys]"], ["proof (prove)\nusing this:\n  set (elements (y # meld xs ys)) =\n  set (elements [y]) \\<union> set (elements xs) \\<union> set (elements ys)\n  set (elements (y # ys)) = set (elements ys) \\<union> set (elements [y])\n\ngoal (1 subgoal):\n 1. set (elements (y # meld xs ys)) =\n    set (elements xs) \\<union> set (elements (y # ys))", "by auto"], ["proof (state)\nthis:\n  set (elements (y # meld xs ys)) =\n  set (elements xs) \\<union> set (elements (y # ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (elements (y # meld xs ys)) =\n  set (elements xs) \\<union> set (elements (y # ys))\n\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (None # xs)); distinct (vals (y # ys));\n        set (vals (None # xs)) \\<inter> set (vals (y # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (None # xs) (y # ys))) =\n                         set (elements (None # xs)) \\<union>\n                         set (elements (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (x # xs) (None # ys))) =\n                         set (elements (x # xs)) \\<union>\n                         set (elements (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "thus ?case"], ["proof (prove)\nusing this:\n  set (elements (y # meld xs ys)) =\n  set (elements xs) \\<union> set (elements (y # ys))\n\ngoal (1 subgoal):\n 1. set (elements (meld (None # xs) (y # ys))) =\n    set (elements (None # xs)) \\<union> set (elements (y # ys))", "by simp"], ["proof (state)\nthis:\n  set (elements (meld (None # xs) (y # ys))) =\n  set (elements (None # xs)) \\<union> set (elements (y # ys))\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (x # xs) (None # ys))) =\n                         set (elements (x # xs)) \\<union>\n                         set (elements (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (x # xs) (None # ys))) =\n                         set (elements (x # xs)) \\<union>\n                         set (elements (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "case (4 x xs ys)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (x # xs) (None # ys))) =\n                         set (elements (x # xs)) \\<union>\n                         set (elements (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "have \"set (dfs alist (x # meld xs ys)) =\n    set (dfs alist (x # xs)) \\<union> set (dfs alist ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "(* this is the same as for 3 minus some renaming *)"], ["proof (state)\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "note assms = \"4\""], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "have \"set (vals xs) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "using set_dfs_Cons[of val x xs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n  set (vals (x # xs)) = set (vals xs) \\<union> set (vals [x])\n\ngoal (1 subgoal):\n 1. set (vals xs) \\<inter> set (vals ys) = {}", "by auto"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "moreover"], ["proof (state)\nthis:\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "have \"distinct (vals xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals xs)", "by (cases x) simp_all"], ["proof (state)\nthis:\n  distinct (vals xs)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "moreover"], ["proof (state)\nthis:\n  distinct (vals xs)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "have \"distinct (vals ys)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals ys)", "by simp"], ["proof (state)\nthis:\n  distinct (vals ys)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "moreover"], ["proof (state)\nthis:\n  distinct (vals ys)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "note assms"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "ultimately"], ["proof (chain)\npicking this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  distinct (vals xs)\n  distinct (vals ys)\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}", "have \"set (dfs alist (meld xs ys)) =\n      set (dfs alist xs) \\<union> set (dfs alist ys)\""], ["proof (prove)\nusing this:\n  set (vals xs) \\<inter> set (vals ys) = {}\n  distinct (vals xs)\n  distinct (vals ys)\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (x # xs))\n  distinct (vals (None # ys))\n  set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (meld xs ys)) =\n    set (elements xs) \\<union> set (elements ys)", "by simp"], ["proof (state)\nthis:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "hence \"set (dfs alist (x # meld xs ys)) =\n      set (dfs alist [x]) \\<union> set (dfs alist xs) \\<union> set (dfs alist ys)\""], ["proof (prove)\nusing this:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements [x]) \\<union> set (elements xs) \\<union> set (elements ys)", "using set_dfs_Cons[of alist x \"meld xs ys\"]"], ["proof (prove)\nusing this:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n  set (elements (x # meld xs ys)) =\n  set (elements (meld xs ys)) \\<union> set (elements [x])\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements [x]) \\<union> set (elements xs) \\<union> set (elements ys)", "by auto"], ["proof (state)\nthis:\n  set (elements (x # meld xs ys)) =\n  set (elements [x]) \\<union> set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "then"], ["proof (chain)\npicking this:\n  set (elements (x # meld xs ys)) =\n  set (elements [x]) \\<union> set (elements xs) \\<union> set (elements ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (elements (x # meld xs ys)) =\n  set (elements [x]) \\<union> set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "using set_dfs_Cons[of alist x xs]"], ["proof (prove)\nusing this:\n  set (elements (x # meld xs ys)) =\n  set (elements [x]) \\<union> set (elements xs) \\<union> set (elements ys)\n  set (elements (x # xs)) = set (elements xs) \\<union> set (elements [x])\n\ngoal (1 subgoal):\n 1. set (elements (x # meld xs ys)) =\n    set (elements (x # xs)) \\<union> set (elements ys)", "by auto"], ["proof (state)\nthis:\n  set (elements (x # meld xs ys)) =\n  set (elements (x # xs)) \\<union> set (elements ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (elements (x # meld xs ys)) =\n  set (elements (x # xs)) \\<union> set (elements ys)\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (x # xs)); distinct (vals (None # ys));\n        set (vals (x # xs)) \\<inter> set (vals (None # ys)) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (x # xs) (None # ys))) =\n                         set (elements (x # xs)) \\<union>\n                         set (elements (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "thus ?case"], ["proof (prove)\nusing this:\n  set (elements (x # meld xs ys)) =\n  set (elements (x # xs)) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (meld (x # xs) (None # ys))) =\n    set (elements (x # xs)) \\<union> set (elements (None # ys))", "by simp"], ["proof (state)\nthis:\n  set (elements (meld (x # xs) (None # ys))) =\n  set (elements (x # xs)) \\<union> set (elements (None # ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "case (5 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "have \"set (dfs alist (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (dfs alist xs)\n    \\<union> set (bt_dfs alist y) \\<union> set (dfs alist ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "note assms = \"5\""], ["proof (state)\nthis:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have \"distinct (bt_dfs val x)\" \"distinct (bt_dfs val y)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (bt_dfs val x) &&& distinct (bt_dfs val y)", "by simp_all"], ["proof (state)\nthis:\n  distinct (bt_dfs val x)\n  distinct (bt_dfs val y)\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "moreover"], ["proof (state)\nthis:\n  distinct (bt_dfs val x)\n  distinct (bt_dfs val y)\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have xyint:\n      \"set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}", "by (auto simp add: set_dfs_Cons)"], ["proof (state)\nthis:\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (bt_dfs val x)\n  distinct (bt_dfs val y)\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}", "have *: \"set (dfs alist [Some (merge x y)]) =\n      set (bt_dfs alist x) \\<union> set (bt_dfs alist y)\""], ["proof (prove)\nusing this:\n  distinct (bt_dfs val x)\n  distinct (bt_dfs val y)\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}\n\ngoal (1 subgoal):\n 1. set (elements [Some (merge x y)]) =\n    set (bt_dfs alist x) \\<union> set (bt_dfs alist y)", "by auto"], ["proof (state)\nthis:\n  set (elements [Some (merge x y)]) =\n  set (bt_dfs alist x) \\<union> set (bt_dfs alist y)\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "moreover"], ["proof (state)\nthis:\n  set (elements [Some (merge x y)]) =\n  set (bt_dfs alist x) \\<union> set (bt_dfs alist y)\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have **: \"set (dfs alist (meld xs ys)) = set (dfs alist xs) \\<union> set (dfs alist ys)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (elements (meld xs ys)) =\n    set (elements xs) \\<union> set (elements ys)", "by (auto simp add: set_dfs_Cons)"], ["proof (state)\nthis:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "moreover"], ["proof (state)\nthis:\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have \"distinct (vals (Some (merge x y) # meld xs ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (Some (merge x y) # meld xs ys))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> set (elements (meld xs ys)) =\n                               set (elements xs) \\<union> set (elements ys);\n     distinct (vals (Some x # xs)); distinct (vals (Some y # ys));\n     set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (Some (merge x y) # meld xs ys))", "from assms xyint"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}", "have \"distinct (bt_dfs val (merge x y))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n  set (bt_dfs val x) \\<inter> set (bt_dfs val y) = {}\n\ngoal (1 subgoal):\n 1. distinct (bt_dfs val (merge x y))", "by (simp add: vals_merge_distinct)"], ["proof (state)\nthis:\n  distinct (bt_dfs val (merge x y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> set (elements (meld xs ys)) =\n                               set (elements xs) \\<union> set (elements ys);\n     distinct (vals (Some x # xs)); distinct (vals (Some y # ys));\n     set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (Some (merge x y) # meld xs ys))", "moreover"], ["proof (state)\nthis:\n  distinct (bt_dfs val (merge x y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> set (elements (meld xs ys)) =\n                               set (elements xs) \\<union> set (elements ys);\n     distinct (vals (Some x # xs)); distinct (vals (Some y # ys));\n     set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (Some (merge x y) # meld xs ys))", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have \n        \"distinct (vals xs)\" \n        and \"distinct (vals ys)\" \n        and \"set (vals xs) \\<inter> set (vals ys) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals xs) &&&\n    distinct (vals ys) &&& set (vals xs) \\<inter> set (vals ys) = {}", "by (auto simp add: set_dfs_Cons)"], ["proof (state)\nthis:\n  distinct (vals xs)\n  distinct (vals ys)\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> set (elements (meld xs ys)) =\n                               set (elements xs) \\<union> set (elements ys);\n     distinct (vals (Some x # xs)); distinct (vals (Some y # ys));\n     set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (Some (merge x y) # meld xs ys))", "hence \"distinct (vals (meld xs ys))\""], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (vals ys)\n  set (vals xs) \\<inter> set (vals ys) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (meld xs ys))", "by (rule vals_meld_distinct)"], ["proof (state)\nthis:\n  distinct (vals (meld xs ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> set (elements (meld xs ys)) =\n                               set (elements xs) \\<union> set (elements ys);\n     distinct (vals (Some x # xs)); distinct (vals (Some y # ys));\n     set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (Some (merge x y) # meld xs ys))", "moreover"], ["proof (state)\nthis:\n  distinct (vals (meld xs ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> set (elements (meld xs ys)) =\n                               set (elements xs) \\<union> set (elements ys);\n     distinct (vals (Some x # xs)); distinct (vals (Some y # ys));\n     set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (Some (merge x y) # meld xs ys))", "from assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}", "have \"set (bt_dfs val (merge x y)) \\<inter> set (vals (meld xs ys)) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (vals xs); distinct (vals ys);\n   set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld xs ys)) =\n                    set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some x # xs))\n  distinct (vals (Some y # ys))\n  set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) = {}\n\ngoal (1 subgoal):\n 1. set (bt_dfs val (merge x y)) \\<inter> set (vals (meld xs ys)) = {}", "by (auto simp add: vals_meld)"], ["proof (state)\nthis:\n  set (bt_dfs val (merge x y)) \\<inter> set (vals (meld xs ys)) = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n              set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n             \\<Longrightarrow> set (elements (meld xs ys)) =\n                               set (elements xs) \\<union> set (elements ys);\n     distinct (vals (Some x # xs)); distinct (vals (Some y # ys));\n     set (vals (Some x # xs)) \\<inter> set (vals (Some y # ys)) =\n     {}\\<rbrakk>\n    \\<Longrightarrow> distinct (vals (Some (merge x y) # meld xs ys))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (bt_dfs val (merge x y))\n  distinct (vals (meld xs ys))\n  set (bt_dfs val (merge x y)) \\<inter> set (vals (meld xs ys)) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (bt_dfs val (merge x y))\n  distinct (vals (meld xs ys))\n  set (bt_dfs val (merge x y)) \\<inter> set (vals (meld xs ys)) = {}\n\ngoal (1 subgoal):\n 1. distinct (vals (Some (merge x y) # meld xs ys))", "by simp"], ["proof (state)\nthis:\n  distinct (vals (Some (merge x y) # meld xs ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (vals (Some (merge x y) # meld xs ys))\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "ultimately"], ["proof (chain)\npicking this:\n  set (elements [Some (merge x y)]) =\n  set (bt_dfs alist x) \\<union> set (bt_dfs alist y)\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some (merge x y) # meld xs ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (elements [Some (merge x y)]) =\n  set (bt_dfs alist x) \\<union> set (bt_dfs alist y)\n  set (elements (meld xs ys)) = set (elements xs) \\<union> set (elements ys)\n  distinct (vals (Some (merge x y) # meld xs ys))\n\ngoal (1 subgoal):\n 1. set (elements (add (Some (merge x y)) (meld xs ys))) =\n    set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n    set (bt_dfs alist y) \\<union>\n    set (elements ys)", "by (auto simp add: alist_add_Cons)"], ["proof (state)\nthis:\n  set (elements (add (Some (merge x y)) (meld xs ys))) =\n  set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n  set (bt_dfs alist y) \\<union>\n  set (elements ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (elements (add (Some (merge x y)) (meld xs ys))) =\n  set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n  set (bt_dfs alist y) \\<union>\n  set (elements ys)\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>distinct (vals xs); distinct (vals ys);\n                 set (vals xs) \\<inter> set (vals ys) = {}\\<rbrakk>\n                \\<Longrightarrow> set (elements (meld xs ys)) =\n                                  set (elements xs) \\<union>\n                                  set (elements ys);\n        distinct (vals (Some t # xs)); distinct (vals (Some r # ys));\n        set (vals (Some t # xs)) \\<inter> set (vals (Some r # ys)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld (Some t # xs) (Some r # ys))) =\n                         set (elements (Some t # xs)) \\<union>\n                         set (elements (Some r # ys))", "thus ?case"], ["proof (prove)\nusing this:\n  set (elements (add (Some (merge x y)) (meld xs ys))) =\n  set (bt_dfs alist x) \\<union> set (elements xs) \\<union>\n  set (bt_dfs alist y) \\<union>\n  set (elements ys)\n\ngoal (1 subgoal):\n 1. set (elements (meld (Some x # xs) (Some y # ys))) =\n    set (elements (Some x # xs)) \\<union> set (elements (Some y # ys))", "by auto"], ["proof (state)\nthis:\n  set (elements (meld (Some x # xs) (Some y # ys))) =\n  set (elements (Some x # xs)) \\<union> set (elements (Some y # ys))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>distinct (vals []); distinct (vals ys);\n        set (vals []) \\<inter> set (vals ys) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld [] ys)) =\n                         set (elements []) \\<union> set (elements ys)\n 2. \\<And>xs.\n       \\<lbrakk>distinct (vals xs); distinct (vals []);\n        set (vals xs) \\<inter> set (vals []) = {}\\<rbrakk>\n       \\<Longrightarrow> set (elements (meld xs [])) =\n                         set (elements xs) \\<union> set (elements [])", "qed simp_all"], ["", "lemma alist_delete_min:\n  assumes \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  and \"find_min xs = Some (Node a v ts)\"\n  shows \"set (dfs alist (delete_min xs)) = set (dfs alist xs) - {(v, a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "from \\<open>distinct (vals xs)\\<close>"], ["proof (chain)\npicking this:\n  distinct (vals xs)", "have d: \"distinct (dfs alist xs)\""], ["proof (prove)\nusing this:\n  distinct (vals xs)\n\ngoal (1 subgoal):\n 1. distinct (elements xs)", "using dfs_comp_distinct[of fst alist \"xs\"]"], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (dfs (fst \\<circ> alist) xs) \\<Longrightarrow>\n  distinct (elements xs)\n\ngoal (1 subgoal):\n 1. distinct (elements xs)", "by (simp only: alist_split)"], ["proof (state)\nthis:\n  distinct (elements xs)\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "from assms"], ["proof (chain)\npicking this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)", "have IN: \"Some (Node a v ts) \\<in> set xs\""], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n\ngoal (1 subgoal):\n 1. Some (Node a v ts) \\<in> set xs", "by (simp add: find_min_exist)"], ["proof (state)\nthis:\n  Some (Node a v ts) \\<in> set xs\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "hence sub: \"set (bts_dfs alist ts) \\<subseteq> set (dfs alist xs)\""], ["proof (prove)\nusing this:\n  Some (Node a v ts) \\<in> set xs\n\ngoal (1 subgoal):\n 1. set (bts_dfs alist ts) \\<subseteq> set (elements xs)", "by (induct xs) (auto simp add: bt_dfs_simp)"], ["proof (state)\nthis:\n  set (bts_dfs alist ts) \\<subseteq> set (elements xs)\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "from d IN"], ["proof (chain)\npicking this:\n  distinct (elements xs)\n  Some (Node a v ts) \\<in> set xs", "have \"(v,a) \\<notin> set (bts_dfs alist ts)\""], ["proof (prove)\nusing this:\n  distinct (elements xs)\n  Some (Node a v ts) \\<in> set xs\n\ngoal (1 subgoal):\n 1. (v, a) \\<notin> set (bts_dfs alist ts)", "using dfs_distinct_member[of alist xs \"Node a v ts\"]"], ["proof (prove)\nusing this:\n  distinct (elements xs)\n  Some (Node a v ts) \\<in> set xs\n  \\<lbrakk>distinct (elements xs); Some (Node a v ts) \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (bt_dfs alist (Node a v ts))\n\ngoal (1 subgoal):\n 1. (v, a) \\<notin> set (bts_dfs alist ts)", "by simp"], ["proof (state)\nthis:\n  (v, a) \\<notin> set (bts_dfs alist ts)\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "with sub"], ["proof (chain)\npicking this:\n  set (bts_dfs alist ts) \\<subseteq> set (elements xs)\n  (v, a) \\<notin> set (bts_dfs alist ts)", "have \"set (bts_dfs alist ts) \\<subseteq> set (dfs alist xs) - {(v,a)}\""], ["proof (prove)\nusing this:\n  set (bts_dfs alist ts) \\<subseteq> set (elements xs)\n  (v, a) \\<notin> set (bts_dfs alist ts)\n\ngoal (1 subgoal):\n 1. set (bts_dfs alist ts) \\<subseteq> set (elements xs) - {(v, a)}", "by blast"], ["proof (state)\nthis:\n  set (bts_dfs alist ts) \\<subseteq> set (elements xs) - {(v, a)}\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "hence nu: \"set (bts_dfs alist ts) \\<union> (set (dfs alist xs) - {(v,a)}) =\n    set (dfs alist xs) - {(v,a)}\""], ["proof (prove)\nusing this:\n  set (bts_dfs alist ts) \\<subseteq> set (elements xs) - {(v, a)}\n\ngoal (1 subgoal):\n 1. set (bts_dfs alist ts) \\<union> (set (elements xs) - {(v, a)}) =\n    set (elements xs) - {(v, a)}", "by auto"], ["proof (state)\nthis:\n  set (bts_dfs alist ts) \\<union> (set (elements xs) - {(v, a)}) =\n  set (elements xs) - {(v, a)}\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "from assms"], ["proof (chain)\npicking this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)", "have \"distinct (vals (map (match a) xs))\""], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n\ngoal (1 subgoal):\n 1. distinct (vals (map (match a) xs))", "by (simp add: dfs_match_distinct)"], ["proof (state)\nthis:\n  distinct (vals (map (match a) xs))\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "moreover"], ["proof (state)\nthis:\n  distinct (vals (map (match a) xs))\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "from IN assms"], ["proof (chain)\npicking this:\n  Some (Node a v ts) \\<in> set xs\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)", "have \"distinct (bts_dfs val ts)\""], ["proof (prove)\nusing this:\n  Some (Node a v ts) \\<in> set xs\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n\ngoal (1 subgoal):\n 1. distinct (bts_dfs val ts)", "using dfs_distinct_member[of val xs \"Node a v ts\"]"], ["proof (prove)\nusing this:\n  Some (Node a v ts) \\<in> set xs\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n  \\<lbrakk>distinct (vals xs); Some (Node a v ts) \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> distinct (bt_dfs val (Node a v ts))\n\ngoal (1 subgoal):\n 1. distinct (bts_dfs val ts)", "by (simp add: bt_dfs_distinct_children)"], ["proof (state)\nthis:\n  distinct (bts_dfs val ts)\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "hence \"distinct (vals (map Some (rev ts)))\""], ["proof (prove)\nusing this:\n  distinct (bts_dfs val ts)\n\ngoal (1 subgoal):\n 1. distinct (vals (map Some (rev ts)))", "by (simp add: bts_dfs_rev_distinct dfs_map_Some_idem)"], ["proof (state)\nthis:\n  distinct (vals (map Some (rev ts)))\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "moreover"], ["proof (state)\nthis:\n  distinct (vals (map Some (rev ts)))\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "from assms IN"], ["proof (chain)\npicking this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n  Some (Node a v ts) \\<in> set xs", "have \"set (dfs val (map (match a) xs)) =\n    set (dfs val xs) - set (bt_dfs val (Node a v ts))\""], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n  Some (Node a v ts) \\<in> set xs\n\ngoal (1 subgoal):\n 1. set (vals (map (match a) xs)) =\n    set (vals xs) - set (bt_dfs val (Node a v ts))", "by (simp add: dfs_match)"], ["proof (state)\nthis:\n  set (vals (map (match a) xs)) =\n  set (vals xs) - set (bt_dfs val (Node a v ts))\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "hence \"set (vals (map (match a) xs)) \\<inter> set (vals (map Some (rev ts))) = {}\""], ["proof (prove)\nusing this:\n  set (vals (map (match a) xs)) =\n  set (vals xs) - set (bt_dfs val (Node a v ts))\n\ngoal (1 subgoal):\n 1. set (vals (map (match a) xs)) \\<inter> set (vals (map Some (rev ts))) =\n    {}", "by (auto simp add: dfs_map_Some_idem set_bts_dfs_rev)"], ["proof (state)\nthis:\n  set (vals (map (match a) xs)) \\<inter> set (vals (map Some (rev ts))) = {}\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "ultimately"], ["proof (chain)\npicking this:\n  distinct (vals (map (match a) xs))\n  distinct (vals (map Some (rev ts)))\n  set (vals (map (match a) xs)) \\<inter> set (vals (map Some (rev ts))) = {}", "have \"set (dfs alist (meld (map Some (rev ts)) (map (match a) xs))) =\n    set (dfs alist (map Some (rev ts))) \\<union> set (dfs alist (map (match a) xs))\""], ["proof (prove)\nusing this:\n  distinct (vals (map (match a) xs))\n  distinct (vals (map Some (rev ts)))\n  set (vals (map (match a) xs)) \\<inter> set (vals (map Some (rev ts))) = {}\n\ngoal (1 subgoal):\n 1. set (elements (meld (map Some (rev ts)) (map (match a) xs))) =\n    set (elements (map Some (rev ts))) \\<union>\n    set (elements (map (match a) xs))", "using alist_meld"], ["proof (prove)\nusing this:\n  distinct (vals (map (match a) xs))\n  distinct (vals (map Some (rev ts)))\n  set (vals (map (match a) xs)) \\<inter> set (vals (map Some (rev ts))) = {}\n  \\<lbrakk>distinct (vals ?xs); distinct (vals ?ys);\n   set (vals ?xs) \\<inter> set (vals ?ys) = {}\\<rbrakk>\n  \\<Longrightarrow> set (elements (meld ?xs ?ys)) =\n                    set (elements ?xs) \\<union> set (elements ?ys)\n\ngoal (1 subgoal):\n 1. set (elements (meld (map Some (rev ts)) (map (match a) xs))) =\n    set (elements (map Some (rev ts))) \\<union>\n    set (elements (map (match a) xs))", "by auto"], ["proof (state)\nthis:\n  set (elements (meld (map Some (rev ts)) (map (match a) xs))) =\n  set (elements (map Some (rev ts))) \\<union>\n  set (elements (map (match a) xs))\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "with assms d IN nu"], ["proof (chain)\npicking this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n  distinct (elements xs)\n  Some (Node a v ts) \\<in> set xs\n  set (bts_dfs alist ts) \\<union> (set (elements xs) - {(v, a)}) =\n  set (elements xs) - {(v, a)}\n  set (elements (meld (map Some (rev ts)) (map (match a) xs))) =\n  set (elements (map Some (rev ts))) \\<union>\n  set (elements (map (match a) xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (vals xs)\n  distinct (prios xs)\n  find_min xs = Some (Node a v ts)\n  distinct (elements xs)\n  Some (Node a v ts) \\<in> set xs\n  set (bts_dfs alist ts) \\<union> (set (elements xs) - {(v, a)}) =\n  set (elements xs) - {(v, a)}\n  set (elements (meld (map Some (rev ts)) (map (match a) xs))) =\n  set (elements (map Some (rev ts))) \\<union>\n  set (elements (map (match a) xs))\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "by (simp add: delete_min_def alist_normalize_idem set_bts_dfs_rev dfs_map_Some_idem\n     dfs_match Diff_insert2 [of \"set (dfs alist xs)\" \"(v,a)\" \"set (bts_dfs alist ts)\"])"], ["proof (state)\nthis:\n  set (elements (delete_min xs)) = set (elements xs) - {(v, a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alist_remove_min:\n  assumes \"is_binqueue l xs\"\n  and \"distinct (vals xs)\"\n  and \"distinct (prios xs)\"\n  and \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  shows \"set (dfs alist (delete_min xs)) =\n  set (PQ.alist_of (PQ.remove_min (pqueue xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) =\n    set (pq.alist_of (remove_min (pqueue xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) =\n    set (pq.alist_of (remove_min (pqueue xs)))", "from assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []", "obtain t where ot: \"find_min xs = Some t\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        find_min xs = Some t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using normalized_find_min_exists"], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  \\<lbrakk>normalized ?xs; ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t. find_min ?xs = Some t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        find_min xs = Some t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) =\n    set (pq.alist_of (remove_min (pqueue xs)))", "with assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  find_min xs = Some t", "show ?thesis"], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) =\n    set (pq.alist_of (remove_min (pqueue xs)))", "proof (cases t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "case (Node a v ys)"], ["proof (state)\nthis:\n  t = Node a v ys\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "from assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []", "have \"\\<not> PQ.is_empty (pqueue xs)\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> PQ.is_empty (pqueue xs)", "by (simp add: empty_empty)"], ["proof (state)\nthis:\n  \\<not> PQ.is_empty (pqueue xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "hence \"set (PQ.alist_of (PQ.remove_min (pqueue xs))) =\n      set (PQ.alist_of (pqueue xs)) - {(PQ.min (pqueue xs),\n        the (PQ.priority (pqueue xs) (PQ.min (pqueue xs))))}\""], ["proof (prove)\nusing this:\n  \\<not> PQ.is_empty (pqueue xs)\n\ngoal (1 subgoal):\n 1. set (pq.alist_of (remove_min (pqueue xs))) =\n    set (pq.alist_of (pqueue xs)) -\n    {(PQ.min (pqueue xs),\n      the (PQ.priority (pqueue xs) (PQ.min (pqueue xs))))}", "by (simp add: set_alist_of_remove_min[of \"pqueue xs\"] del: alist_of_remove_min)"], ["proof (state)\nthis:\n  set (pq.alist_of (remove_min (pqueue xs))) =\n  set (pq.alist_of (pqueue xs)) -\n  {(PQ.min (pqueue xs), the (PQ.priority (pqueue xs) (PQ.min (pqueue xs))))}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "moreover"], ["proof (state)\nthis:\n  set (pq.alist_of (remove_min (pqueue xs))) =\n  set (pq.alist_of (pqueue xs)) -\n  {(PQ.min (pqueue xs), the (PQ.priority (pqueue xs) (PQ.min (pqueue xs))))}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "from assms ot Node"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  find_min xs = Some t\n  t = Node a v ys", "have \"set (dfs alist (delete_min xs)) = set (dfs alist xs) - {(v, a)}\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  find_min xs = Some t\n  t = Node a v ys\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "using alist_delete_min[of xs]"], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  find_min xs = Some t\n  t = Node a v ys\n  \\<lbrakk>distinct (vals xs); distinct (prios xs);\n   find_min xs = Some (Node ?a ?v ?ts)\\<rbrakk>\n  \\<Longrightarrow> set (elements (delete_min xs)) =\n                    set (elements xs) - {(?v, ?a)}\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) = set (elements xs) - {(v, a)}", "by simp"], ["proof (state)\nthis:\n  set (elements (delete_min xs)) = set (elements xs) - {(v, a)}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "moreover"], ["proof (state)\nthis:\n  set (elements (delete_min xs)) = set (elements xs) - {(v, a)}\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "from Node ot"], ["proof (chain)\npicking this:\n  t = Node a v ys\n  find_min xs = Some t", "have \"priority (the (find_min xs)) = a\""], ["proof (prove)\nusing this:\n  t = Node a v ys\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. priority (the (find_min xs)) = a", "by simp"], ["proof (state)\nthis:\n  priority (the (find_min xs)) = a\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "with assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  priority (the (find_min xs)) = a", "have \"a = the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  priority (the (find_min xs)) = a\n\ngoal (1 subgoal):\n 1. a = the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))", "by (simp add: find_min_p_min)"], ["proof (state)\nthis:\n  a = the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "moreover"], ["proof (state)\nthis:\n  a = the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "from Node ot"], ["proof (chain)\npicking this:\n  t = Node a v ys\n  find_min xs = Some t", "have \"val (the (find_min xs)) = v\""], ["proof (prove)\nusing this:\n  t = Node a v ys\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. val (the (find_min xs)) = v", "by simp"], ["proof (state)\nthis:\n  val (the (find_min xs)) = v\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "with assms"], ["proof (chain)\npicking this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  val (the (find_min xs)) = v", "have \"v = PQ.min (pqueue xs)\""], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  distinct (vals xs)\n  distinct (prios xs)\n  normalized xs\n  xs \\<noteq> []\n  val (the (find_min xs)) = v\n\ngoal (1 subgoal):\n 1. v = PQ.min (pqueue xs)", "by (simp add: find_min_v_min)"], ["proof (state)\nthis:\n  v = PQ.min (pqueue xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "moreover"], ["proof (state)\nthis:\n  v = PQ.min (pqueue xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "note \\<open>distinct (vals xs)\\<close>"], ["proof (state)\nthis:\n  distinct (vals xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>is_binqueue l xs; distinct (vals xs); distinct (prios xs);\n        normalized xs; xs \\<noteq> []; find_min xs = Some t;\n        t = Node x1 x2 x3\\<rbrakk>\n       \\<Longrightarrow> set (elements (delete_min xs)) =\n                         set (pq.alist_of (remove_min (pqueue xs)))", "ultimately"], ["proof (chain)\npicking this:\n  set (pq.alist_of (remove_min (pqueue xs))) =\n  set (pq.alist_of (pqueue xs)) -\n  {(PQ.min (pqueue xs), the (PQ.priority (pqueue xs) (PQ.min (pqueue xs))))}\n  set (elements (delete_min xs)) = set (elements xs) - {(v, a)}\n  a = the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\n  v = PQ.min (pqueue xs)\n  distinct (vals xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (pq.alist_of (remove_min (pqueue xs))) =\n  set (pq.alist_of (pqueue xs)) -\n  {(PQ.min (pqueue xs), the (PQ.priority (pqueue xs) (PQ.min (pqueue xs))))}\n  set (elements (delete_min xs)) = set (elements xs) - {(v, a)}\n  a = the (PQ.priority (pqueue xs) (PQ.min (pqueue xs)))\n  v = PQ.min (pqueue xs)\n  distinct (vals xs)\n\ngoal (1 subgoal):\n 1. set (elements (delete_min xs)) =\n    set (pq.alist_of (remove_min (pqueue xs)))", "by (simp add: alist_pqueue)"], ["proof (state)\nthis:\n  set (elements (delete_min xs)) =\n  set (pq.alist_of (remove_min (pqueue xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (elements (delete_min xs)) =\n  set (pq.alist_of (remove_min (pqueue xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "no_notation\n  \"PQ.values\" (\"|(_)|\")\n  and \"PQ.priorities\" (\"\\<parallel>(_)\\<parallel>\")"], ["", "end"]]}