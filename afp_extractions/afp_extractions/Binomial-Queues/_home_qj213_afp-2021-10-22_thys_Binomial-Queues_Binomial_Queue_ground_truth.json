{"file_name": "/home/qj213/afp-2021-10-22/thys/Binomial-Queues/Binomial_Queue.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Binomial-Queues", "problem_names": ["lemma binqueue_induct [case_names Empty None Some, induct type: binqueue]:\n  assumes \"P []\"\n    and \"\\<And>xs. P xs \\<Longrightarrow> P (None # xs)\"\n    and \"\\<And>x xs. P xs \\<Longrightarrow> P (Some x # xs)\"\n  shows \"P xs\"", "lemma is_bintree_list_triv [simp]:\n  \"is_bintree_list 0 ts \\<longleftrightarrow> ts = []\"\n  \"is_bintree_list l [] \\<longleftrightarrow> l = 0\"", "lemma is_bintree_list_simp [simp]:\n  \"is_bintree_list (Suc l) (t # ts) \\<longleftrightarrow>\n    is_bintree_list l (children t) \\<and> is_bintree_list l ts\"", "lemma is_bintree_list_length [simp]:\n  \"is_bintree_list l ts \\<Longrightarrow> length ts = l\"", "lemma is_bintree_list_children_last:\n  assumes \"is_bintree_list l ts\" and \"ts \\<noteq> []\"\n  shows \"children (last ts) = []\"", "lemma is_bintree_children_length_desc:\n  assumes \"is_bintree_list l ts\"\n  shows \"map (length \\<circ> children) ts = rev [0..<l]\"", "lemma is_heap_list_simps [simp]:\n  \"is_heap_list h [] \\<longleftrightarrow> True\"\n  \"is_heap_list h (t # ts) \\<longleftrightarrow>\n    is_heap_list h ts \\<and> is_heap_list (priority t) (children t) \\<and> priority t \\<ge> h\"", "lemma is_heap_list_append_dest [dest]:\n  \"is_heap_list l (ts@rs) \\<Longrightarrow> is_heap_list l ts\"\n  \"is_heap_list l (ts@rs) \\<Longrightarrow> is_heap_list l rs\"", "lemma is_heap_list_rev:\n  \"is_heap_list l ts \\<Longrightarrow> is_heap_list l (rev ts)\"", "lemma is_heap_children_larger:\n  \"is_heap t \\<Longrightarrow> \\<forall> x \\<in> set (children t). priority x \\<ge> priority t\"", "lemma is_heap_Min_children_larger:\n  \"is_heap t \\<Longrightarrow> children t \\<noteq> [] \\<Longrightarrow> \n   priority t \\<le> Min (priority ` set (children t))\"", "lemma is_binqueue_simp [simp]:\n  \"is_binqueue l [] \\<longleftrightarrow> True\"\n  \"is_binqueue l (Some t # xs) \\<longleftrightarrow>\n    is_bintree l t \\<and> is_heap t \\<and> is_binqueue (Suc l) xs\"\n  \"is_binqueue l (None # xs) \\<longleftrightarrow> is_binqueue (Suc l) xs\"", "lemma is_binqueue_trans:\n  \"is_binqueue l (x#xs) \\<Longrightarrow> is_binqueue (Suc l) xs\"", "lemma is_binqueue_head:\n  \"is_binqueue l (x#xs) \\<Longrightarrow> is_binqueue l [x]\"", "lemma is_binqueue_append:\n  \"is_binqueue l xs \\<Longrightarrow> is_binqueue (length xs + l) ys \\<Longrightarrow> is_binqueue l (xs @ ys)\"", "lemma is_binqueue_append_dest [dest]:\n  \"is_binqueue l (xs @ ys) \\<Longrightarrow> is_binqueue l xs\"", "lemma is_binqueue_children:\n  assumes \"is_bintree_list l ts\"\n  and \"is_heap_list t ts\"\n  shows \"is_binqueue 0 (map Some (rev ts))\"", "lemma is_binqueue_select:\n  \"is_binqueue l xs \\<Longrightarrow> Some t \\<in> set xs \\<Longrightarrow> \\<exists>k. is_bintree k t \\<and> is_heap t\"", "lemma normalized_last_not_None:\n  \\<comment> \\<open>\\ sometimes the inductive definition might work better\\<close>\n  \"normalized xs \\<longleftrightarrow> xs = [] \\<or> last xs \\<noteq> None\"", "lemma normalized_simps [simp]:\n  \"normalized [] \\<longleftrightarrow> True\"\n  \"normalized (Some t # xs) \\<longleftrightarrow> normalized xs\"\n  \"normalized (None # xs) \\<longleftrightarrow> xs \\<noteq> [] \\<and> normalized xs\"", "lemma normalized_map_Some [simp]:\n  \"normalized (map Some xs)\"", "lemma normalized_Cons:\n  \"normalized (x#xs) \\<Longrightarrow> normalized xs\"", "lemma normalized_append:\n  \"normalized xs \\<Longrightarrow> normalized ys \\<Longrightarrow> normalized (xs@ys)\"", "lemma normalized_not_None:\n  \"normalized xs \\<Longrightarrow> set xs \\<noteq> {None}\"", "lemma normalized_normalize:\n  \"normalized (normalize xs)\"", "lemma is_binqueue_normalize:\n  \"is_binqueue l xs \\<Longrightarrow> is_binqueue l (normalize xs)\"", "lemma is_bintree_list_merge:\n  assumes \"is_bintree l t1\" \"is_bintree l t2\"\n  shows \"is_bintree (Suc l) (merge t1 t2)\"", "lemma is_heap_merge:\n  assumes \"is_heap t1\" \"is_heap t2\"\n  shows \"is_heap (merge t1 t2)\"", "lemma add_Some_not_Nil [simp]:\n  \"add (Some t) xs \\<noteq> []\"", "lemma normalized_add:\n  assumes \"normalized xs\"\n  shows \"normalized (add x xs)\"", "lemma is_binqueue_add_None:\n  assumes \"is_binqueue l xs\"\n  shows \"is_binqueue l (add None xs)\"", "lemma is_binqueue_add_Some:\n  assumes \"is_binqueue l xs\"\n  and     \"is_bintree l t\"\n  and     \"is_heap t\"\n  shows \"is_binqueue l (add (Some t) xs)\"", "lemma meld_singleton_add [simp]:\n  \"meld [Some t] xs = add (Some t) xs\"", "lemma nonempty_meld [simp]:\n  \"xs \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []\"\n  \"ys \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []\"", "lemma nonempty_meld_commute:\n  \"meld xs ys \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []\"", "lemma is_binqueue_meld:\n  assumes \"is_binqueue l xs\"\n  and     \"is_binqueue l ys\"\n  shows \"is_binqueue l (meld xs ys)\"", "lemma normalized_meld:\n  assumes \"normalized xs\"\n  and     \"normalized ys\"\n  shows   \"normalized (meld xs ys)\"", "lemma normalized_meld_weak:\n  assumes \"normalized xs\"\n  and \"length ys \\<le> length xs\"\n  shows \"normalized (meld xs ys)\"", "lemma least_simps [simp, code]:\n  \"least None x = x\"\n  \"least x None = x\"\n  \"least (Some x') (Some y') = (if x' \\<le> y' then Some x' else Some y')\"", "lemma least_split:\n  assumes \"least x y = Some z\"\n  shows \"x = Some z \\<or> y = Some z\"", "lemma min_simps [simp]:\n  \"min [] = None\"\n  \"min (None # xs) = min xs\"\n  \"min (Some t # xs) = least (Some (priority t)) (min xs)\"", "lemma [code]:\n  \"min xs = fold (\\<lambda> x. least (map_option priority x)) xs None\"", "lemma min_single:\n  \"min [x] = Some a \\<Longrightarrow> priority (the x) = a\"\n  \"min [x] = None \\<Longrightarrow> x = None\"", "lemma min_Some_not_None:\n  \"min (Some t # xs) \\<noteq> None\"", "lemma min_None_trans:\n  assumes \"min (x#xs) = None\"\n  shows \"min xs = None\"", "lemma min_None_None:\n  \"min xs = None \\<longleftrightarrow> xs = [] \\<or> set xs = {None}\"", "lemma normalized_min_not_None:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> min xs \\<noteq> None\"", "lemma min_is_min:\n  assumes \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  and \"min xs = Some a\"\n  shows \"\\<forall>x \\<in> set xs. x = None \\<or> a \\<le> priority (the x)\"", "lemma min_exists:\n  assumes \"min xs = Some a\"\n  shows \"Some a \\<in> map_option priority ` set xs\"", "lemma find_simps [simp, code]:\n  \"find a [] = None\"\n  \"find a (None # xs) = find a xs\"\n  \"find a (Some t # xs) = (if priority t = a then Some t else find a xs)\"", "lemma find_works:\n  assumes \"Some a \\<in> set (map (map_option priority) xs)\"\n  shows \"\\<exists>t. find a xs = Some t \\<and> priority t = a\"", "lemma find_works_not_None:\n  \"Some a \\<in> set (map (map_option priority) xs) \\<Longrightarrow> find a xs \\<noteq> None\"", "lemma find_None:\n  \"find a xs = None \\<Longrightarrow> Some a \\<notin> set (map (map_option priority) xs)\"", "lemma find_exist:\n  \"find a xs = Some t \\<Longrightarrow> Some t \\<in> set xs\"", "lemma find_min_simps [simp]:\n  \"find_min [] = None\"\n  \"find_min (None # xs) = find_min xs\"", "lemma find_min_single:\n  \"find_min [x] = x\"", "lemma min_eq_find_min_None:\n  \"min xs = None \\<longleftrightarrow> find_min xs = None\"", "lemma min_eq_find_min_Some:\n  \"min xs = Some a \\<longleftrightarrow> (\\<exists> t. find_min xs = Some t \\<and> priority t = a)\"", "lemma find_min_exist:\n  assumes \"find_min xs = Some t\"\n  shows \"Some t \\<in> set xs\"", "lemma find_min_is_min:\n  assumes \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  and \"find_min xs = Some t\"\n  shows \"\\<forall>x \\<in> set xs. x = None \\<or> (priority t) \\<le> priority (the x)\"", "lemma normalized_find_min_exists:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> \\<exists>t. find_min xs = Some t\"", "lemma delete_min_empty [simp]:\n  \"delete_min [] = []\"", "lemma delete_min_nonempty [simp]:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> find_min xs = Some t\n    \\<Longrightarrow> delete_min xs = normalize\n      (meld (map Some (rev (children t))) (map (match (priority t)) xs))\"", "lemma is_binqueue_delete_min:\n  assumes \"is_binqueue 0 xs\"\n  shows \"is_binqueue 0 (delete_min xs)\"", "lemma normalized_delete_min:\n  \"normalized (delete_min xs)\"", "lemma [code]:\n  \"add z xs = meld' z [] xs\"\n  \"meld xs ys = meld' None xs ys\"", "lemma [code]:\n  \"meld' z (Some t # xs) (Some r # ys) =\n    z # (meld' (Some (merge t r)) xs ys)\"\n  \"meld' (Some t) (Some r # xs) (None # ys) =\n    None # (meld' (Some (merge t r)) xs ys)\"\n  \"meld' (Some t) (None # xs) (Some r # ys) =\n    None # (meld' (Some (merge t r)) xs ys)\"\n  \"meld' None (x # xs) (None # ys) = x # (meld' None xs ys)\"\n  \"meld' None (None # xs) (y # ys) = y # (meld' None xs ys)\"\n  \"meld' z (None # xs) (None # ys) = z # (meld' None xs ys)\"\n  \"meld' z xs [] = meld' z [] xs\"\n  \"meld' z [] (y # ys) = meld' None [z] (y # ys)\"\n  \"meld' (Some t) [] ys = meld' None [Some t] ys\"\n  \"meld' None [] ys = ys\"", "lemma insert_simps [simp]:\n  \"insert a v [] = [Some (Node a v [])]\"\n  \"insert a v (None # xs) = Some (Node a v []) # xs\"\n  \"insert a v (Some t # xs) = None # add (Some (merge (Node a v []) t)) xs\"", "lemma is_binqueue_insert:\n  \"is_binqueue 0 xs \\<Longrightarrow> is_binqueue 0 (insert a v xs)\"", "lemma normalized_insert:\n  \"normalized xs \\<Longrightarrow> normalized (insert a v xs)\"", "lemma pop_empty [simp]:\n  \"pop empty = (None, empty)\"", "lemma pop_nonempty [simp]:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> find_min xs = Some t\n    \\<Longrightarrow> pop xs = (Some (val t, priority t), normalize\n      (meld (map Some (rev (children t))) (map (match (priority t)) xs)))\"", "lemma pop_code [code]:\n  \"pop xs = (case find_min xs of \n      None \\<Rightarrow> (None, xs) \n    | Some t  \\<Rightarrow> (Some (val t, priority t), normalize\n       (meld (map Some (rev (children t))) (map (match (priority t)) xs))))\""], "translations": [["", "lemma binqueue_induct [case_names Empty None Some, induct type: binqueue]:\n  assumes \"P []\"\n    and \"\\<And>xs. P xs \\<Longrightarrow> P (None # xs)\"\n    and \"\\<And>x xs. P xs \\<Longrightarrow> P (Some x # xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using assms"], ["proof (prove)\nusing this:\n  P []\n  P ?xs \\<Longrightarrow> P (None # ?xs)\n  P ?xs \\<Longrightarrow> P (Some ?x # ?xs)\n\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n     \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n    \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>P [];\n                 \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n                 \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n        \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case Nil"], ["proof (state)\nthis:\n  P []\n  P ?xs \\<Longrightarrow> P (None # ?xs)\n  P ?xs \\<Longrightarrow> P (Some ?x # ?xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n     \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n    \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>P [];\n                 \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n                 \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n        \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "then"], ["proof (chain)\npicking this:\n  P []\n  P ?xs \\<Longrightarrow> P (None # ?xs)\n  P ?xs \\<Longrightarrow> P (Some ?x # ?xs)", "show ?case"], ["proof (prove)\nusing this:\n  P []\n  P ?xs \\<Longrightarrow> P (None # ?xs)\n  P ?xs \\<Longrightarrow> P (Some ?x # ?xs)\n\ngoal (1 subgoal):\n 1. P []", "by simp"], ["proof (state)\nthis:\n  P []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>P [];\n                 \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n                 \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n        \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>P [];\n                 \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n                 \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n        \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n   \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n  \\<Longrightarrow> P xs\n  P []\n  P ?xs \\<Longrightarrow> P (None # ?xs)\n  P ?xs \\<Longrightarrow> P (Some ?x # ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>P [];\n                 \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n                 \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n        \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n   \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n  \\<Longrightarrow> P xs\n  P []\n  P ?xs \\<Longrightarrow> P (None # ?xs)\n  P ?xs \\<Longrightarrow> P (Some ?x # ?xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>P []; \\<And>xs. P xs \\<Longrightarrow> P (None # xs);\n   \\<And>xs x. P xs \\<Longrightarrow> P (Some x # xs)\\<rbrakk>\n  \\<Longrightarrow> P xs\n  P []\n  P ?xs \\<Longrightarrow> P (None # ?xs)\n  P ?xs \\<Longrightarrow> P (Some ?x # ?xs)\n\ngoal (1 subgoal):\n 1. P (x # xs)", "by (cases x) simp_all"], ["proof (state)\nthis:\n  P (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  \\noindent Terminology:\n\n  \\begin{itemize}\n\n    \\item values \\<open>v, w\\<close> or \\<open>v1, v2\\<close>\n\n    \\item priorities \\<open>a, b\\<close> or \\<open>a1, a2\\<close>\n\n    \\item bintrees \\<open>t, r\\<close> or \\<open>t1, t2\\<close>\n\n    \\item bintree lists \\<open>ts, rs\\<close> or \\<open>ts1, ts2\\<close>\n\n    \\item binqueue element \\<open>x, y\\<close> or \\<open>x1, x2\\<close>\n\n    \\item binqueues = binqueue element lists \\<open>xs, ys\\<close> or \\<open>xs1, xs2\\<close>\n\n    \\item abstract priority queues \\<open>q, p\\<close> or \\<open>q1, q2\\<close>\n\n  \\end{itemize}\n\\<close>"], ["", "subsection \\<open>Binomial queue properties\\<close>"], ["", "subsubsection \\<open>Binomial tree property\\<close>"], ["", "inductive is_bintree_list :: \"nat \\<Rightarrow> ('a, 'b) bintree list \\<Rightarrow> bool\" where\n  is_bintree_list_Nil [simp]: \"is_bintree_list 0 []\"\n| is_bintree_list_Cons: \"is_bintree_list l ts \\<Longrightarrow> is_bintree_list l (children t)\n    \\<Longrightarrow> is_bintree_list (Suc l) (t # ts)\""], ["", "abbreviation (input) \"is_bintree k t \\<equiv> is_bintree_list k (children t)\""], ["", "lemma is_bintree_list_triv [simp]:\n  \"is_bintree_list 0 ts \\<longleftrightarrow> ts = []\"\n  \"is_bintree_list l [] \\<longleftrightarrow> l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bintree_list 0 ts = (ts = []) &&& is_bintree_list l [] = (l = 0)", "by (auto intro: is_bintree_list.intros elim: is_bintree_list.cases)"], ["", "lemma is_bintree_list_simp [simp]:\n  \"is_bintree_list (Suc l) (t # ts) \\<longleftrightarrow>\n    is_bintree_list l (children t) \\<and> is_bintree_list l ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bintree_list (Suc l) (t # ts) =\n    (is_bintree_list l (children t) \\<and> is_bintree_list l ts)", "by (auto intro: is_bintree_list.intros elim: is_bintree_list.cases)"], ["", "lemma is_bintree_list_length [simp]:\n  \"is_bintree_list l ts \\<Longrightarrow> length ts = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bintree_list l ts \\<Longrightarrow> length ts = l", "by (erule is_bintree_list.induct) simp_all"], ["", "lemma is_bintree_list_children_last:\n  assumes \"is_bintree_list l ts\" and \"ts \\<noteq> []\"\n  shows \"children (last ts) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. children (last ts) = []", "using assms"], ["proof (prove)\nusing this:\n  is_bintree_list l ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. children (last ts) = []", "by induct auto"], ["", "lemma is_bintree_children_length_desc:\n  assumes \"is_bintree_list l ts\"\n  shows \"map (length \\<circ> children) ts = rev [0..<l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (length \\<circ> children) ts = rev [0..<l]", "using assms"], ["proof (prove)\nusing this:\n  is_bintree_list l ts\n\ngoal (1 subgoal):\n 1. map (length \\<circ> children) ts = rev [0..<l]", "by (induct ts) simp_all"], ["", "subsubsection \\<open>Heap property\\<close>"], ["", "inductive is_heap_list :: \"'a::linorder \\<Rightarrow> ('a, 'b) bintree list \\<Rightarrow> bool\" where\n  is_heap_list_Nil: \"is_heap_list h []\"\n| is_heap_list_Cons: \"is_heap_list h ts \\<Longrightarrow> is_heap_list (priority t) (children t)\n    \\<Longrightarrow> (priority t) \\<ge> h \\<Longrightarrow> is_heap_list h (t # ts)\""], ["", "abbreviation (input) \"is_heap t \\<equiv> is_heap_list (priority t) (children t)\""], ["", "lemma is_heap_list_simps [simp]:\n  \"is_heap_list h [] \\<longleftrightarrow> True\"\n  \"is_heap_list h (t # ts) \\<longleftrightarrow>\n    is_heap_list h ts \\<and> is_heap_list (priority t) (children t) \\<and> priority t \\<ge> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap_list h [] = True &&&\n    is_heap_list h (t # ts) =\n    (is_heap_list h ts \\<and>\n     is_heap_list (priority t) (children t) \\<and> h \\<le> priority t)", "by (auto intro: is_heap_list.intros elim: is_heap_list.cases)"], ["", "lemma is_heap_list_append_dest [dest]:\n  \"is_heap_list l (ts@rs) \\<Longrightarrow> is_heap_list l ts\"\n  \"is_heap_list l (ts@rs) \\<Longrightarrow> is_heap_list l rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_heap_list l (ts @ rs) \\<Longrightarrow> is_heap_list l ts) &&&\n    (is_heap_list l (ts @ rs) \\<Longrightarrow> is_heap_list l rs)", "by (induct ts) (auto intro: is_heap_list.intros elim: is_heap_list.cases)"], ["", "lemma is_heap_list_rev:\n  \"is_heap_list l ts \\<Longrightarrow> is_heap_list l (rev ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap_list l ts \\<Longrightarrow> is_heap_list l (rev ts)", "by (induct ts rule: rev_induct) auto"], ["", "lemma is_heap_children_larger:\n  \"is_heap t \\<Longrightarrow> \\<forall> x \\<in> set (children t). priority x \\<ge> priority t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap_list (priority t) (children t) \\<Longrightarrow>\n    \\<forall>x\\<in>set (children t). priority t \\<le> priority x", "by (erule is_heap_list.induct) simp_all"], ["", "lemma is_heap_Min_children_larger:\n  \"is_heap t \\<Longrightarrow> children t \\<noteq> [] \\<Longrightarrow> \n   priority t \\<le> Min (priority ` set (children t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap_list (priority t) (children t);\n     children t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> priority t \\<le> Min (priority ` set (children t))", "by (simp add: is_heap_children_larger)"], ["", "subsubsection \\<open>Combination of both: binqueue property\\<close>"], ["", "inductive is_binqueue :: \"nat \\<Rightarrow> ('a::linorder, 'b) binqueue \\<Rightarrow> bool\" where\n  Empty: \"is_binqueue l []\"\n| None: \"is_binqueue (Suc l) xs \\<Longrightarrow> is_binqueue l (None # xs)\"\n| Some: \"is_binqueue (Suc l) xs \\<Longrightarrow> is_bintree l t\n    \\<Longrightarrow> is_heap t \\<Longrightarrow> is_binqueue l (Some t # xs)\""], ["", "lemma is_binqueue_simp [simp]:\n  \"is_binqueue l [] \\<longleftrightarrow> True\"\n  \"is_binqueue l (Some t # xs) \\<longleftrightarrow>\n    is_bintree l t \\<and> is_heap t \\<and> is_binqueue (Suc l) xs\"\n  \"is_binqueue l (None # xs) \\<longleftrightarrow> is_binqueue (Suc l) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l [] = True &&&\n    is_binqueue l (Some t # xs) =\n    (is_bintree_list l (children t) \\<and>\n     is_heap_list (priority t) (children t) \\<and>\n     is_binqueue (Suc l) xs) &&&\n    is_binqueue l (None # xs) = is_binqueue (Suc l) xs", "by (auto intro: is_binqueue.intros elim: is_binqueue.cases)"], ["", "lemma is_binqueue_trans:\n  \"is_binqueue l (x#xs) \\<Longrightarrow> is_binqueue (Suc l) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l (x # xs) \\<Longrightarrow> is_binqueue (Suc l) xs", "by (cases x) simp_all"], ["", "lemma is_binqueue_head:\n  \"is_binqueue l (x#xs) \\<Longrightarrow> is_binqueue l [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l (x # xs) \\<Longrightarrow> is_binqueue l [x]", "by (cases x) simp_all"], ["", "lemma is_binqueue_append:\n  \"is_binqueue l xs \\<Longrightarrow> is_binqueue (length xs + l) ys \\<Longrightarrow> is_binqueue l (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue l xs; is_binqueue (length xs + l) ys\\<rbrakk>\n    \\<Longrightarrow> is_binqueue l (xs @ ys)", "by (induct xs arbitrary: l) (auto intro: is_binqueue.intros elim: is_binqueue.cases)"], ["", "lemma is_binqueue_append_dest [dest]:\n  \"is_binqueue l (xs @ ys) \\<Longrightarrow> is_binqueue l xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l (xs @ ys) \\<Longrightarrow> is_binqueue l xs", "by (induct xs arbitrary: l) (auto intro: is_binqueue.intros elim: is_binqueue.cases)"], ["", "lemma is_binqueue_children:\n  assumes \"is_bintree_list l ts\"\n  and \"is_heap_list t ts\"\n  shows \"is_binqueue 0 (map Some (rev ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue 0 (map Some (rev ts))", "using assms"], ["proof (prove)\nusing this:\n  is_bintree_list l ts\n  is_heap_list t ts\n\ngoal (1 subgoal):\n 1. is_binqueue 0 (map Some (rev ts))", "by (induct ts) (auto simp add: is_binqueue_append)"], ["", "lemma is_binqueue_select:\n  \"is_binqueue l xs \\<Longrightarrow> Some t \\<in> set xs \\<Longrightarrow> \\<exists>k. is_bintree k t \\<and> is_heap t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_binqueue l xs; Some t \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         is_bintree_list k (children t) \\<and>\n                         is_heap_list (priority t) (children t)", "by (induct xs arbitrary: l) (auto intro: is_binqueue.intros elim: is_binqueue.cases)"], ["", "subsubsection \\<open>Normalized representation\\<close>"], ["", "inductive normalized :: \"('a, 'b) binqueue \\<Rightarrow> bool\" where\n  normalized_Nil: \"normalized []\"\n| normalized_single: \"normalized [Some t]\"\n| normalized_append: \"xs \\<noteq> [] \\<Longrightarrow> normalized xs \\<Longrightarrow> normalized (ys @ xs)\""], ["", "lemma normalized_last_not_None:\n  \\<comment> \\<open>\\ sometimes the inductive definition might work better\\<close>\n  \"normalized xs \\<longleftrightarrow> xs = [] \\<or> last xs \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized xs = (xs = [] \\<or> last xs \\<noteq> None)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. normalized xs \\<Longrightarrow> xs = [] \\<or> last xs \\<noteq> None\n 2. xs = [] \\<or> last xs \\<noteq> None \\<Longrightarrow> normalized xs", "assume \"normalized xs\""], ["proof (state)\nthis:\n  normalized xs\n\ngoal (2 subgoals):\n 1. normalized xs \\<Longrightarrow> xs = [] \\<or> last xs \\<noteq> None\n 2. xs = [] \\<or> last xs \\<noteq> None \\<Longrightarrow> normalized xs", "then"], ["proof (chain)\npicking this:\n  normalized xs", "show \"xs = [] \\<or> last xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  normalized xs\n\ngoal (1 subgoal):\n 1. xs = [] \\<or> last xs \\<noteq> None", "by (rule normalized.induct) simp_all"], ["proof (state)\nthis:\n  xs = [] \\<or> last xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. xs = [] \\<or> last xs \\<noteq> None \\<Longrightarrow> normalized xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = [] \\<or> last xs \\<noteq> None \\<Longrightarrow> normalized xs", "assume *: \"xs = [] \\<or> last xs \\<noteq> None\""], ["proof (state)\nthis:\n  xs = [] \\<or> last xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. xs = [] \\<or> last xs \\<noteq> None \\<Longrightarrow> normalized xs", "show \"normalized xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized xs", "proof (cases xs rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> normalized xs\n 2. \\<And>ys y. xs = ys @ [y] \\<Longrightarrow> normalized xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> normalized xs\n 2. \\<And>ys y. xs = ys @ [y] \\<Longrightarrow> normalized xs", "then"], ["proof (chain)\npicking this:\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. normalized xs", "by (simp add: normalized.intros)"], ["proof (state)\nthis:\n  normalized xs\n\ngoal (1 subgoal):\n 1. \\<And>ys y. xs = ys @ [y] \\<Longrightarrow> normalized xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys y. xs = ys @ [y] \\<Longrightarrow> normalized xs", "case (snoc ys x)"], ["proof (state)\nthis:\n  xs = ys @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>ys y. xs = ys @ [y] \\<Longrightarrow> normalized xs", "with *"], ["proof (chain)\npicking this:\n  xs = [] \\<or> last xs \\<noteq> None\n  xs = ys @ [x]", "obtain t where \"last xs = Some t\""], ["proof (prove)\nusing this:\n  xs = [] \\<or> last xs \\<noteq> None\n  xs = ys @ [x]\n\ngoal (1 subgoal):\n 1. (\\<And>t. last xs = Some t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  last xs = Some t\n\ngoal (1 subgoal):\n 1. \\<And>ys y. xs = ys @ [y] \\<Longrightarrow> normalized xs", "with snoc"], ["proof (chain)\npicking this:\n  xs = ys @ [x]\n  last xs = Some t", "have \"xs = ys @ [Some t]\""], ["proof (prove)\nusing this:\n  xs = ys @ [x]\n  last xs = Some t\n\ngoal (1 subgoal):\n 1. xs = ys @ [Some t]", "by simp"], ["proof (state)\nthis:\n  xs = ys @ [Some t]\n\ngoal (1 subgoal):\n 1. \\<And>ys y. xs = ys @ [y] \\<Longrightarrow> normalized xs", "then"], ["proof (chain)\npicking this:\n  xs = ys @ [Some t]", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = ys @ [Some t]\n\ngoal (1 subgoal):\n 1. normalized xs", "by (simp add: normalized.intros)"], ["proof (state)\nthis:\n  normalized xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normalized xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_simps [simp]:\n  \"normalized [] \\<longleftrightarrow> True\"\n  \"normalized (Some t # xs) \\<longleftrightarrow> normalized xs\"\n  \"normalized (None # xs) \\<longleftrightarrow> xs \\<noteq> [] \\<and> normalized xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized [] = True &&&\n    normalized (Some t # xs) = normalized xs &&&\n    normalized (None # xs) = (xs \\<noteq> [] \\<and> normalized xs)", "by (simp_all add: normalized_last_not_None)"], ["", "lemma normalized_map_Some [simp]:\n  \"normalized (map Some xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized (map Some xs)", "by (induct xs) simp_all"], ["", "lemma normalized_Cons:\n  \"normalized (x#xs) \\<Longrightarrow> normalized xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized (x # xs) \\<Longrightarrow> normalized xs", "by (auto simp add: normalized_last_not_None)"], ["", "lemma normalized_append:\n  \"normalized xs \\<Longrightarrow> normalized ys \\<Longrightarrow> normalized (xs@ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n    \\<Longrightarrow> normalized (xs @ ys)", "by (cases ys) (simp_all add: normalized_last_not_None)"], ["", "lemma normalized_not_None:\n  \"normalized xs \\<Longrightarrow> set xs \\<noteq> {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized xs \\<Longrightarrow> set xs \\<noteq> {None}", "by (induct xs) (auto simp add: normalized_Cons [of _ ts] dest: subset_singletonD)"], ["", "primrec normalize' :: \"('a, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue\" where\n  \"normalize' [] = []\"\n| \"normalize' (x # xs) =\n    (case x of None \\<Rightarrow> normalize' xs | Some t \\<Rightarrow> (x # xs))\""], ["", "definition normalize :: \"('a, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue\" where\n  \"normalize xs = rev (normalize' (rev xs))\""], ["", "lemma normalized_normalize:\n  \"normalized (normalize xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized (Binomial_Queue.normalize xs)", "proof (induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. normalized (Binomial_Queue.normalize [])\n 2. \\<And>x xs.\n       normalized (Binomial_Queue.normalize xs) \\<Longrightarrow>\n       normalized (Binomial_Queue.normalize (xs @ [x]))", "case (snoc y ys)"], ["proof (state)\nthis:\n  normalized (Binomial_Queue.normalize ys)\n\ngoal (2 subgoals):\n 1. normalized (Binomial_Queue.normalize [])\n 2. \\<And>x xs.\n       normalized (Binomial_Queue.normalize xs) \\<Longrightarrow>\n       normalized (Binomial_Queue.normalize (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  normalized (Binomial_Queue.normalize ys)", "show ?case"], ["proof (prove)\nusing this:\n  normalized (Binomial_Queue.normalize ys)\n\ngoal (1 subgoal):\n 1. normalized (Binomial_Queue.normalize (ys @ [y]))", "by (cases y) (simp_all add: normalized_last_not_None normalize_def)"], ["proof (state)\nthis:\n  normalized (Binomial_Queue.normalize (ys @ [y]))\n\ngoal (1 subgoal):\n 1. normalized (Binomial_Queue.normalize [])", "qed (simp add: normalize_def)"], ["", "lemma is_binqueue_normalize:\n  \"is_binqueue l xs \\<Longrightarrow> is_binqueue l (normalize xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l xs \\<Longrightarrow>\n    is_binqueue l (Binomial_Queue.normalize xs)", "unfolding normalize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l xs \\<Longrightarrow>\n    is_binqueue l (rev (normalize' (rev xs)))", "by (induct xs arbitrary: l rule: rev_induct) (auto split: option.split)"], ["", "subsection \\<open>Operations\\<close>"], ["", "subsubsection \\<open>Adding data\\<close>"], ["", "definition merge :: \"('a::linorder, 'b) bintree \\<Rightarrow> ('a, 'b) bintree \\<Rightarrow> ('a, 'b) bintree\" where\n  \"merge t1 t2 = (if priority t1 < priority t2\n    then Node (priority t1) (val t1) (t2 # children t1) \n    else Node (priority t2) (val t2) (t1 # children t2))\""], ["", "lemma is_bintree_list_merge:\n  assumes \"is_bintree l t1\" \"is_bintree l t2\"\n  shows \"is_bintree (Suc l) (merge t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bintree_list (Suc l) (children (merge t1 t2))", "using assms"], ["proof (prove)\nusing this:\n  is_bintree_list l (children t1)\n  is_bintree_list l (children t2)\n\ngoal (1 subgoal):\n 1. is_bintree_list (Suc l) (children (merge t1 t2))", "by (simp add: merge_def)"], ["", "lemma is_heap_merge:\n  assumes \"is_heap t1\" \"is_heap t2\"\n  shows \"is_heap (merge t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap_list (priority (merge t1 t2)) (children (merge t1 t2))", "using assms"], ["proof (prove)\nusing this:\n  is_heap_list (priority t1) (children t1)\n  is_heap_list (priority t2) (children t2)\n\ngoal (1 subgoal):\n 1. is_heap_list (priority (merge t1 t2)) (children (merge t1 t2))", "by (auto simp add: merge_def)"], ["", "fun\n  add :: \"('a::linorder, 'b) bintree option \\<Rightarrow> ('a, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue\"\nwhere\n  \"add None xs = xs\"\n| \"add (Some t) [] = [Some t]\"\n| \"add (Some t) (None # xs) = Some t # xs\"\n| \"add (Some t) (Some r # xs) = None # add (Some (merge t r)) xs\""], ["", "lemma add_Some_not_Nil [simp]:\n  \"add (Some t) xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add (Some t) xs \\<noteq> []", "by (induct \"Some t\" xs rule: add.induct) simp_all"], ["", "lemma normalized_add:\n  assumes \"normalized xs\"\n  shows \"normalized (add x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized (add x xs)", "using assms"], ["proof (prove)\nusing this:\n  normalized xs\n\ngoal (1 subgoal):\n 1. normalized (add x xs)", "by (induct xs rule: add.induct) simp_all"], ["", "lemma is_binqueue_add_None:\n  assumes \"is_binqueue l xs\"\n  shows \"is_binqueue l (add None xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l (add None xs)", "using assms"], ["proof (prove)\nusing this:\n  is_binqueue l xs\n\ngoal (1 subgoal):\n 1. is_binqueue l (add None xs)", "by simp"], ["", "lemma is_binqueue_add_Some:\n  assumes \"is_binqueue l xs\"\n  and     \"is_bintree l t\"\n  and     \"is_heap t\"\n  shows \"is_binqueue l (add (Some t) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l (add (Some t) xs)", "using assms"], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  is_bintree_list l (children t)\n  is_heap_list (priority t) (children t)\n\ngoal (1 subgoal):\n 1. is_binqueue l (add (Some t) xs)", "by (induct xs arbitrary: t) (simp_all add: is_bintree_list_merge is_heap_merge)"], ["", "function\n  meld :: \"('a::linorder, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue\"\nwhere\n  \"meld [] ys = ys\"\n| \"meld xs [] = xs\"\n| \"meld (None # xs) (y # ys) = y # meld xs ys\"\n| \"meld (x # xs) (None # ys) = x # meld xs ys\"\n| \"meld (Some t # xs) (Some r # ys) =\n    None # add (Some (merge t r)) (meld xs ys)\""], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>ys. x = ([], ys) \\<Longrightarrow> P;\n        \\<And>xs. x = (xs, []) \\<Longrightarrow> P;\n        \\<And>xs y ys. x = (None # xs, y # ys) \\<Longrightarrow> P;\n        \\<And>xa xs ys. x = (xa # xs, None # ys) \\<Longrightarrow> P;\n        \\<And>t xs r ys.\n           x = (Some t # xs, Some r # ys) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>ys ysa. ([], ys) = ([], ysa) \\<Longrightarrow> ys = ysa\n 3. \\<And>ys xs. ([], ys) = (xs, []) \\<Longrightarrow> ys = xs\n 4. \\<And>ys xs y ysa.\n       ([], ys) = (None # xs, y # ysa) \\<Longrightarrow>\n       ys = y # meld_sumC (xs, ysa)\n 5. \\<And>ys x xs ysa.\n       ([], ys) = (x # xs, None # ysa) \\<Longrightarrow>\n       ys = x # meld_sumC (xs, ysa)\n 6. \\<And>ys t xs r ysa.\n       ([], ys) = (Some t # xs, Some r # ysa) \\<Longrightarrow>\n       ys = None # add (Some (merge t r)) (meld_sumC (xs, ysa))\n 7. \\<And>xs xsa. (xs, []) = (xsa, []) \\<Longrightarrow> xs = xsa\n 8. \\<And>xs xsa y ys.\n       (xs, []) = (None # xsa, y # ys) \\<Longrightarrow>\n       xs = y # meld_sumC (xsa, ys)\n 9. \\<And>xs x xsa ys.\n       (xs, []) = (x # xsa, None # ys) \\<Longrightarrow>\n       xs = x # meld_sumC (xsa, ys)\n 10. \\<And>xs t xsa r ys.\n        (xs, []) = (Some t # xsa, Some r # ys) \\<Longrightarrow>\n        xs = None # add (Some (merge t r)) (meld_sumC (xsa, ys))\nA total of 16 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All meld_dom", "by lexicographic_order"], ["", "lemma meld_singleton_add [simp]:\n  \"meld [Some t] xs = add (Some t) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meld [Some t] xs = add (Some t) xs", "by (induct \"Some t\" xs rule: add.induct) simp_all"], ["", "lemma nonempty_meld [simp]:\n  \"xs \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []\"\n  \"ys \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []) &&&\n    (ys \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> [])", "by (induct xs ys rule: meld.induct) auto"], ["", "lemma nonempty_meld_commute:\n  \"meld xs ys \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meld xs ys \\<noteq> [] \\<Longrightarrow> meld xs ys \\<noteq> []", "by (induct xs ys rule: meld.induct) auto"], ["", "lemma is_binqueue_meld:\n  assumes \"is_binqueue l xs\"\n  and     \"is_binqueue l ys\"\n  shows \"is_binqueue l (meld xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue l (meld xs ys)", "using assms"], ["proof (prove)\nusing this:\n  is_binqueue l xs\n  is_binqueue l ys\n\ngoal (1 subgoal):\n 1. is_binqueue l (meld xs ys)", "proof (induct xs ys arbitrary: l rule: meld.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>xs y ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (None # xs); is_binqueue l (y # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "fix xs ys :: \"('a, 'b) binqueue\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>xs y ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (None # xs); is_binqueue l (y # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "fix y :: \"('a, 'b) bintree option\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>xs y ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (None # xs); is_binqueue l (y # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "fix l :: nat"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>xs y ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (None # xs); is_binqueue l (y # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "assume \"\\<And> l. is_binqueue l xs \\<Longrightarrow> is_binqueue l ys\n      \\<Longrightarrow> is_binqueue l (meld xs ys)\"\n    and \"is_binqueue l (None # xs)\"\n    and \"is_binqueue l (y # ys)\""], ["proof (state)\nthis:\n  \\<lbrakk>is_binqueue ?l xs; is_binqueue ?l ys\\<rbrakk>\n  \\<Longrightarrow> is_binqueue ?l (meld xs ys)\n  is_binqueue l (None # xs)\n  is_binqueue l (y # ys)\n\ngoal (5 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>xs y ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (None # xs); is_binqueue l (y # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_binqueue ?l xs; is_binqueue ?l ys\\<rbrakk>\n  \\<Longrightarrow> is_binqueue ?l (meld xs ys)\n  is_binqueue l (None # xs)\n  is_binqueue l (y # ys)", "show \"is_binqueue l (meld (None # xs) (y # ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_binqueue ?l xs; is_binqueue ?l ys\\<rbrakk>\n  \\<Longrightarrow> is_binqueue ?l (meld xs ys)\n  is_binqueue l (None # xs)\n  is_binqueue l (y # ys)\n\ngoal (1 subgoal):\n 1. is_binqueue l (meld (None # xs) (y # ys))", "by (cases y) simp_all"], ["proof (state)\nthis:\n  is_binqueue l (meld (None # xs) (y # ys))\n\ngoal (4 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "fix xs ys :: \"('a, 'b) binqueue\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "fix x :: \"('a, 'b) bintree option\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "fix l :: nat"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "assume \"\\<And> l. is_binqueue l xs \\<Longrightarrow> is_binqueue l ys\n      \\<Longrightarrow> is_binqueue l (meld xs ys)\"\n    and \"is_binqueue l (x # xs)\"\n    and \"is_binqueue l (None # ys)\""], ["proof (state)\nthis:\n  \\<lbrakk>is_binqueue ?l xs; is_binqueue ?l ys\\<rbrakk>\n  \\<Longrightarrow> is_binqueue ?l (meld xs ys)\n  is_binqueue l (x # xs)\n  is_binqueue l (None # ys)\n\ngoal (4 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>x xs ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (x # xs); is_binqueue l (None # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_binqueue ?l xs; is_binqueue ?l ys\\<rbrakk>\n  \\<Longrightarrow> is_binqueue ?l (meld xs ys)\n  is_binqueue l (x # xs)\n  is_binqueue l (None # ys)", "show \"is_binqueue l (meld (x # xs) (None # ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_binqueue ?l xs; is_binqueue ?l ys\\<rbrakk>\n  \\<Longrightarrow> is_binqueue ?l (meld xs ys)\n  is_binqueue l (x # xs)\n  is_binqueue l (None # ys)\n\ngoal (1 subgoal):\n 1. is_binqueue l (meld (x # xs) (None # ys))", "by (cases x) simp_all"], ["proof (state)\nthis:\n  is_binqueue l (meld (x # xs) (None # ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys l.\n       \\<lbrakk>is_binqueue l []; is_binqueue l ys\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld [] ys)\n 2. \\<And>xs l.\n       \\<lbrakk>is_binqueue l xs; is_binqueue l []\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld xs [])\n 3. \\<And>t xs r ys l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>is_binqueue l xs; is_binqueue l ys\\<rbrakk>\n                   \\<Longrightarrow> is_binqueue l (meld xs ys);\n        is_binqueue l (Some t # xs); is_binqueue l (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> is_binqueue l (meld (Some t # xs) (Some r # ys))", "qed (simp_all add: is_bintree_list_merge is_heap_merge is_binqueue_add_Some)"], ["", "lemma normalized_meld:\n  assumes \"normalized xs\"\n  and     \"normalized ys\"\n  shows   \"normalized (meld xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized (meld xs ys)", "using assms"], ["proof (prove)\nusing this:\n  normalized xs\n  normalized ys\n\ngoal (1 subgoal):\n 1. normalized (meld xs ys)", "proof (induct xs ys rule: meld.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs); normalized (y # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix xs ys :: \"('a, 'b) binqueue\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs); normalized (y # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix y :: \"('a, 'b) bintree option\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs); normalized (y # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "assume \"normalized xs \\<Longrightarrow> normalized ys \\<Longrightarrow> normalized (meld xs ys)\"\n    and  \"normalized (None # xs)\"\n    and  \"normalized (y # ys)\""], ["proof (state)\nthis:\n  \\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (None # xs)\n  normalized (y # ys)\n\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs); normalized (y # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (None # xs)\n  normalized (y # ys)", "show \"normalized (meld (None # xs) (y # ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (None # xs)\n  normalized (y # ys)\n\ngoal (1 subgoal):\n 1. normalized (meld (None # xs) (y # ys))", "by (cases y) simp_all"], ["proof (state)\nthis:\n  normalized (meld (None # xs) (y # ys))\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix xs ys :: \"('a, 'b) binqueue\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix x :: \"('a, 'b) bintree option\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "assume \"normalized xs \\<Longrightarrow> normalized ys \\<Longrightarrow> normalized (meld xs ys)\"\n    and  \"normalized (x # xs)\"\n    and  \"normalized (None # ys)\""], ["proof (state)\nthis:\n  \\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (x # xs)\n  normalized (None # ys)\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs); normalized (None # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (x # xs)\n  normalized (None # ys)", "show \"normalized (meld (x # xs) (None # ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (x # xs)\n  normalized (None # ys)\n\ngoal (1 subgoal):\n 1. normalized (meld (x # xs) (None # ys))", "by (cases x) simp_all"], ["proof (state)\nthis:\n  normalized (meld (x # xs) (None # ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; normalized ys\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; normalized []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; normalized ys\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs); normalized (Some r # ys)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "qed (simp_all add: normalized_add)"], ["", "lemma normalized_meld_weak:\n  assumes \"normalized xs\"\n  and \"length ys \\<le> length xs\"\n  shows \"normalized (meld xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized (meld xs ys)", "using assms"], ["proof (prove)\nusing this:\n  normalized xs\n  length ys \\<le> length xs\n\ngoal (1 subgoal):\n 1. normalized (meld xs ys)", "proof (induct xs ys rule: meld.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs);\n        length (y # ys) \\<le> length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix xs ys :: \"('a, 'b) binqueue\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs);\n        length (y # ys) \\<le> length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix y :: \"('a, 'b) bintree option\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs);\n        length (y # ys) \\<le> length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "assume \"normalized xs \\<Longrightarrow> length ys \\<le> length xs \\<Longrightarrow> normalized (meld xs ys)\"\n    and  \"normalized (None # xs)\"\n    and  \"length (y # ys) \\<le> length (None # xs)\""], ["proof (state)\nthis:\n  \\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (None # xs)\n  length (y # ys) \\<le> length (None # xs)\n\ngoal (5 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>xs y ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (None # xs);\n        length (y # ys) \\<le> length (None # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (None # xs) (y # ys))\n 4. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 5. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (None # xs)\n  length (y # ys) \\<le> length (None # xs)", "show \"normalized (meld (None # xs) (y # ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (None # xs)\n  length (y # ys) \\<le> length (None # xs)\n\ngoal (1 subgoal):\n 1. normalized (meld (None # xs) (y # ys))", "by (cases y) simp_all"], ["proof (state)\nthis:\n  normalized (meld (None # xs) (y # ys))\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix xs ys :: \"('a, 'b) binqueue\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "fix x :: \"('a, 'b) bintree option\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "assume \"normalized xs \\<Longrightarrow> length ys \\<le> length xs \\<Longrightarrow> normalized (meld xs ys)\"\n    and  \"normalized (x # xs)\"\n    and  \"length (None # ys) \\<le> length (x # xs)\""], ["proof (state)\nthis:\n  \\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (x # xs)\n  length (None # ys) \\<le> length (x # xs)\n\ngoal (4 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>x xs ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (x # xs);\n        length (None # ys) \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (x # xs) (None # ys))\n 4. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (x # xs)\n  length (None # ys) \\<le> length (x # xs)", "show \"normalized (meld (x # xs) (None # ys))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> normalized (meld xs ys)\n  normalized (x # xs)\n  length (None # ys) \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. normalized (meld (x # xs) (None # ys))", "by (cases x) simp_all"], ["proof (state)\nthis:\n  normalized (meld (x # xs) (None # ys))\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>normalized []; length ys \\<le> length []\\<rbrakk>\n       \\<Longrightarrow> normalized (meld [] ys)\n 2. \\<And>xs.\n       \\<lbrakk>normalized xs; length [] \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> normalized (meld xs [])\n 3. \\<And>t xs r ys.\n       \\<lbrakk>\\<lbrakk>normalized xs; length ys \\<le> length xs\\<rbrakk>\n                \\<Longrightarrow> normalized (meld xs ys);\n        normalized (Some t # xs);\n        length (Some r # ys) \\<le> length (Some t # xs)\\<rbrakk>\n       \\<Longrightarrow> normalized (meld (Some t # xs) (Some r # ys))", "qed (simp_all add: normalized_add)"], ["", "definition least :: \"'a::linorder option \\<Rightarrow> 'a option \\<Rightarrow> 'a option\" where\n  \"least x y = (case x of\n      None \\<Rightarrow> y\n    | Some x' \\<Rightarrow> (case y of\n           None \\<Rightarrow> x\n         | Some y' \\<Rightarrow> if x' \\<le> y' then x else y))\""], ["", "lemma least_simps [simp, code]:\n  \"least None x = x\"\n  \"least x None = x\"\n  \"least (Some x') (Some y') = (if x' \\<le> y' then Some x' else Some y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least None x = x &&&\n    least x None = x &&&\n    least (Some x') (Some y') = (if x' \\<le> y' then Some x' else Some y')", "unfolding least_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case None of None \\<Rightarrow> x\n     | Some x' \\<Rightarrow>\n         case x of None \\<Rightarrow> None\n         | Some y' \\<Rightarrow> if x' \\<le> y' then None else x) =\n    x &&&\n    (case x of None \\<Rightarrow> None\n     | Some x' \\<Rightarrow>\n         case None of None \\<Rightarrow> x\n         | Some y' \\<Rightarrow> if x' \\<le> y' then x else None) =\n    x &&&\n    (case Some x' of None \\<Rightarrow> Some y'\n     | Some x'a \\<Rightarrow>\n         case Some y' of None \\<Rightarrow> Some x'\n         | Some y'a \\<Rightarrow>\n             if x'a \\<le> y'a then Some x' else Some y') =\n    (if x' \\<le> y' then Some x' else Some y')", "by (simp_all) (cases x, simp_all)"], ["", "lemma least_split:\n  assumes \"least x y = Some z\"\n  shows \"x = Some z \\<or> y = Some z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Some z \\<or> y = Some z", "using assms"], ["proof (prove)\nusing this:\n  least x y = Some z\n\ngoal (1 subgoal):\n 1. x = Some z \\<or> y = Some z", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>least x y = Some z; x = None\\<rbrakk>\n    \\<Longrightarrow> x = Some z \\<or> y = Some z\n 2. \\<And>a.\n       \\<lbrakk>least x y = Some z; x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = Some z \\<or> y = Some z", "case (Some x')"], ["proof (state)\nthis:\n  x = Some x'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>least x y = Some z; x = None\\<rbrakk>\n    \\<Longrightarrow> x = Some z \\<or> y = Some z\n 2. \\<And>a.\n       \\<lbrakk>least x y = Some z; x = Some a\\<rbrakk>\n       \\<Longrightarrow> x = Some z \\<or> y = Some z", "with assms"], ["proof (chain)\npicking this:\n  least x y = Some z\n  x = Some x'", "show ?thesis"], ["proof (prove)\nusing this:\n  least x y = Some z\n  x = Some x'\n\ngoal (1 subgoal):\n 1. x = Some z \\<or> y = Some z", "by (cases y) (simp_all add: eq_commute)"], ["proof (state)\nthis:\n  x = Some z \\<or> y = Some z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>least x y = Some z; x = None\\<rbrakk>\n    \\<Longrightarrow> x = Some z \\<or> y = Some z", "qed simp"], ["", "interpretation least: semilattice least"], ["proof (prove)\ngoal (1 subgoal):\n 1. semilattice least", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. least (least a b) c = least a (least b c)\n 2. \\<And>a b. least a b = least b a\n 3. \\<And>a. least a a = a", "qed (auto simp add: least_def split: option.split)"], ["", "definition min :: \"('a::linorder, 'b) binqueue \\<Rightarrow> 'a option\" where\n  \"min xs = fold least (map (map_option priority) xs) None\""], ["", "lemma min_simps [simp]:\n  \"min [] = None\"\n  \"min (None # xs) = min xs\"\n  \"min (Some t # xs) = least (Some (priority t)) (min xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min [] = None &&&\n    Binomial_Queue.min (None # xs) = Binomial_Queue.min xs &&&\n    Binomial_Queue.min (Some t # xs) =\n    least (Some (priority t)) (Binomial_Queue.min xs)", "by (simp_all add: min_def fold_commute_apply [symmetric]\n    fun_eq_iff least.left_commute del: least_simps)"], ["", "lemma [code]:\n  \"min xs = fold (\\<lambda> x. least (map_option priority x)) xs None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs =\n    fold (\\<lambda>x. least (map_option priority x)) xs None", "by (simp add: min_def fold_map o_def)"], ["", "lemma min_single:\n  \"min [x] = Some a \\<Longrightarrow> priority (the x) = a\"\n  \"min [x] = None \\<Longrightarrow> x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Binomial_Queue.min [x] = Some a \\<Longrightarrow>\n     priority (the x) = a) &&&\n    (Binomial_Queue.min [x] = None \\<Longrightarrow> x = None)", "by (auto simp add: min_def)"], ["", "lemma min_Some_not_None:\n  \"min (Some t # xs) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some t # xs) \\<noteq> None", "by (cases \"min xs\") simp_all"], ["", "lemma min_None_trans:\n  assumes \"min (x#xs) = None\"\n  shows \"min xs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = None", "using assms"], ["proof (prove)\nusing this:\n  Binomial_Queue.min (x # xs) = None\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = None", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Binomial_Queue.min (x # xs) = None; x = None\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min xs = None\n 2. \\<And>a.\n       \\<lbrakk>Binomial_Queue.min (x # xs) = None; x = Some a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min xs = None", "case None"], ["proof (state)\nthis:\n  x = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Binomial_Queue.min (x # xs) = None; x = None\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min xs = None\n 2. \\<And>a.\n       \\<lbrakk>Binomial_Queue.min (x # xs) = None; x = Some a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min xs = None", "with assms"], ["proof (chain)\npicking this:\n  Binomial_Queue.min (x # xs) = None\n  x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  Binomial_Queue.min (x # xs) = None\n  x = None\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = None", "by simp"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = None\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Binomial_Queue.min (x # xs) = None; x = Some a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min xs = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Binomial_Queue.min (x # xs) = None; x = Some a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min xs = None", "case (Some t)"], ["proof (state)\nthis:\n  x = Some t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Binomial_Queue.min (x # xs) = None; x = Some a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min xs = None", "with assms"], ["proof (chain)\npicking this:\n  Binomial_Queue.min (x # xs) = None\n  x = Some t", "show ?thesis"], ["proof (prove)\nusing this:\n  Binomial_Queue.min (x # xs) = None\n  x = Some t\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = None", "by (simp only: min_Some_not_None)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_None_None:\n  \"min xs = None \\<longleftrightarrow> xs = [] \\<or> set xs = {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Binomial_Queue.min xs = None) = (xs = [] \\<or> set xs = {None})", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Binomial_Queue.min xs = None \\<Longrightarrow>\n    xs = [] \\<or> set xs = {None}\n 2. xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n    Binomial_Queue.min xs = None", "have splitQ: \"\\<And> xs. xs \\<subseteq> {None} \\<Longrightarrow> xs = {} \\<or> xs = {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<subseteq> {None} \\<Longrightarrow> xs = {} \\<or> xs = {None}", "by auto"], ["proof (state)\nthis:\n  ?xs \\<subseteq> {None} \\<Longrightarrow> ?xs = {} \\<or> ?xs = {None}\n\ngoal (2 subgoals):\n 1. Binomial_Queue.min xs = None \\<Longrightarrow>\n    xs = [] \\<or> set xs = {None}\n 2. xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n    Binomial_Queue.min xs = None", "assume \"min xs = None\""], ["proof (state)\nthis:\n  Binomial_Queue.min xs = None\n\ngoal (2 subgoals):\n 1. Binomial_Queue.min xs = None \\<Longrightarrow>\n    xs = [] \\<or> set xs = {None}\n 2. xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n    Binomial_Queue.min xs = None", "then"], ["proof (chain)\npicking this:\n  Binomial_Queue.min xs = None", "have \"set xs \\<subseteq> {None}\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs = None\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> {None}", "proof (induct xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. Binomial_Queue.min [] = None \\<Longrightarrow> set [] \\<subseteq> {None}\n 2. \\<And>xs.\n       \\<lbrakk>Binomial_Queue.min xs = None \\<Longrightarrow>\n                set xs \\<subseteq> {None};\n        Binomial_Queue.min (None # xs) = None\\<rbrakk>\n       \\<Longrightarrow> set (None # xs) \\<subseteq> {None}\n 3. \\<And>x xs.\n       \\<lbrakk>Binomial_Queue.min xs = None \\<Longrightarrow>\n                set xs \\<subseteq> {None};\n        Binomial_Queue.min (Some x # xs) = None\\<rbrakk>\n       \\<Longrightarrow> set (Some x # xs) \\<subseteq> {None}", "case (None ys)"], ["proof (state)\nthis:\n  Binomial_Queue.min ys = None \\<Longrightarrow> set ys \\<subseteq> {None}\n  Binomial_Queue.min (None # ys) = None\n\ngoal (3 subgoals):\n 1. Binomial_Queue.min [] = None \\<Longrightarrow> set [] \\<subseteq> {None}\n 2. \\<And>xs.\n       \\<lbrakk>Binomial_Queue.min xs = None \\<Longrightarrow>\n                set xs \\<subseteq> {None};\n        Binomial_Queue.min (None # xs) = None\\<rbrakk>\n       \\<Longrightarrow> set (None # xs) \\<subseteq> {None}\n 3. \\<And>x xs.\n       \\<lbrakk>Binomial_Queue.min xs = None \\<Longrightarrow>\n                set xs \\<subseteq> {None};\n        Binomial_Queue.min (Some x # xs) = None\\<rbrakk>\n       \\<Longrightarrow> set (Some x # xs) \\<subseteq> {None}", "thus ?case"], ["proof (prove)\nusing this:\n  Binomial_Queue.min ys = None \\<Longrightarrow> set ys \\<subseteq> {None}\n  Binomial_Queue.min (None # ys) = None\n\ngoal (1 subgoal):\n 1. set (None # ys) \\<subseteq> {None}", "using min_None_trans[of _ ys]"], ["proof (prove)\nusing this:\n  Binomial_Queue.min ys = None \\<Longrightarrow> set ys \\<subseteq> {None}\n  Binomial_Queue.min (None # ys) = None\n  Binomial_Queue.min (?x # ys) = None \\<Longrightarrow>\n  Binomial_Queue.min ys = None\n\ngoal (1 subgoal):\n 1. set (None # ys) \\<subseteq> {None}", "by simp_all"], ["proof (state)\nthis:\n  set (None # ys) \\<subseteq> {None}\n\ngoal (2 subgoals):\n 1. Binomial_Queue.min [] = None \\<Longrightarrow> set [] \\<subseteq> {None}\n 2. \\<And>x xs.\n       \\<lbrakk>Binomial_Queue.min xs = None \\<Longrightarrow>\n                set xs \\<subseteq> {None};\n        Binomial_Queue.min (Some x # xs) = None\\<rbrakk>\n       \\<Longrightarrow> set (Some x # xs) \\<subseteq> {None}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Binomial_Queue.min [] = None \\<Longrightarrow> set [] \\<subseteq> {None}\n 2. \\<And>x xs.\n       \\<lbrakk>Binomial_Queue.min xs = None \\<Longrightarrow>\n                set xs \\<subseteq> {None};\n        Binomial_Queue.min (Some x # xs) = None\\<rbrakk>\n       \\<Longrightarrow> set (Some x # xs) \\<subseteq> {None}", "case (Some t ys)"], ["proof (state)\nthis:\n  Binomial_Queue.min ys = None \\<Longrightarrow> set ys \\<subseteq> {None}\n  Binomial_Queue.min (Some t # ys) = None\n\ngoal (2 subgoals):\n 1. Binomial_Queue.min [] = None \\<Longrightarrow> set [] \\<subseteq> {None}\n 2. \\<And>x xs.\n       \\<lbrakk>Binomial_Queue.min xs = None \\<Longrightarrow>\n                set xs \\<subseteq> {None};\n        Binomial_Queue.min (Some x # xs) = None\\<rbrakk>\n       \\<Longrightarrow> set (Some x # xs) \\<subseteq> {None}", "thus ?case"], ["proof (prove)\nusing this:\n  Binomial_Queue.min ys = None \\<Longrightarrow> set ys \\<subseteq> {None}\n  Binomial_Queue.min (Some t # ys) = None\n\ngoal (1 subgoal):\n 1. set (Some t # ys) \\<subseteq> {None}", "using min_Some_not_None[of t ys]"], ["proof (prove)\nusing this:\n  Binomial_Queue.min ys = None \\<Longrightarrow> set ys \\<subseteq> {None}\n  Binomial_Queue.min (Some t # ys) = None\n  Binomial_Queue.min (Some t # ys) \\<noteq> None\n\ngoal (1 subgoal):\n 1. set (Some t # ys) \\<subseteq> {None}", "by simp"], ["proof (state)\nthis:\n  set (Some t # ys) \\<subseteq> {None}\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min [] = None \\<Longrightarrow> set [] \\<subseteq> {None}", "qed simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> {None}\n\ngoal (2 subgoals):\n 1. Binomial_Queue.min xs = None \\<Longrightarrow>\n    xs = [] \\<or> set xs = {None}\n 2. xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n    Binomial_Queue.min xs = None", "with splitQ"], ["proof (chain)\npicking this:\n  ?xs \\<subseteq> {None} \\<Longrightarrow> ?xs = {} \\<or> ?xs = {None}\n  set xs \\<subseteq> {None}", "show \"xs = [] \\<or> set xs = {None}\""], ["proof (prove)\nusing this:\n  ?xs \\<subseteq> {None} \\<Longrightarrow> ?xs = {} \\<or> ?xs = {None}\n  set xs \\<subseteq> {None}\n\ngoal (1 subgoal):\n 1. xs = [] \\<or> set xs = {None}", "by auto"], ["proof (state)\nthis:\n  xs = [] \\<or> set xs = {None}\n\ngoal (1 subgoal):\n 1. xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n    Binomial_Queue.min xs = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n    Binomial_Queue.min xs = None", "show \"xs = [] \\<or> set xs = {None} \\<Longrightarrow> min xs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n    Binomial_Queue.min xs = None", "by (induct xs) (auto dest: subset_singletonD)"], ["proof (state)\nthis:\n  xs = [] \\<or> set xs = {None} \\<Longrightarrow>\n  Binomial_Queue.min xs = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalized_min_not_None:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> min xs \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> Binomial_Queue.min xs \\<noteq> None", "by (simp add: min_None_None normalized_not_None)"], ["", "lemma min_is_min:\n  assumes \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  and \"min xs = Some a\"\n  shows \"\\<forall>x \\<in> set xs. x = None \\<or> a \\<le> priority (the x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = None \\<or> a \\<le> priority (the x)", "using assms"], ["proof (prove)\nusing this:\n  normalized xs\n  xs \\<noteq> []\n  Binomial_Queue.min xs = Some a\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = None \\<or> a \\<le> priority (the x)", "proof (induct xs arbitrary: a rule: binqueue_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>normalized []; [] \\<noteq> [];\n        Binomial_Queue.min [] = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set [].\n                            x = None \\<or> a \\<le> priority (the x)\n 2. \\<And>xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>normalized xs; xs \\<noteq> [];\n                    Binomial_Queue.min xs = Some a\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set xs.\n  x = None \\<or> a \\<le> priority (the x);\n        normalized (None # xs); None # xs \\<noteq> [];\n        Binomial_Queue.min (None # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (None # xs).\n                            x = None \\<or> a \\<le> priority (the x)\n 3. \\<And>x xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>normalized xs; xs \\<noteq> [];\n                    Binomial_Queue.min xs = Some a\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set xs.\n  x = None \\<or> a \\<le> priority (the x);\n        normalized (Some x # xs); Some x # xs \\<noteq> [];\n        Binomial_Queue.min (Some x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (Some x # xs).\n                            x = None \\<or> a \\<le> priority (the x)", "case (Some t ys)"], ["proof (state)\nthis:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>normalized []; [] \\<noteq> [];\n        Binomial_Queue.min [] = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set [].\n                            x = None \\<or> a \\<le> priority (the x)\n 2. \\<And>xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>normalized xs; xs \\<noteq> [];\n                    Binomial_Queue.min xs = Some a\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set xs.\n  x = None \\<or> a \\<le> priority (the x);\n        normalized (None # xs); None # xs \\<noteq> [];\n        Binomial_Queue.min (None # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (None # xs).\n                            x = None \\<or> a \\<le> priority (the x)\n 3. \\<And>x xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>normalized xs; xs \\<noteq> [];\n                    Binomial_Queue.min xs = Some a\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set xs.\n  x = None \\<or> a \\<le> priority (the x);\n        normalized (Some x # xs); Some x # xs \\<noteq> [];\n        Binomial_Queue.min (Some x # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (Some x # xs).\n                            x = None \\<or> a \\<le> priority (the x)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (Some t # ys).\n       x = None \\<or> a \\<le> priority (the x)", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)\n 2. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)\n 2. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)", "with Some"], ["proof (chain)\npicking this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n  ys \\<noteq> []", "have N: \"normalized ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. normalized ys", "using normalized_Cons[of _ ys]"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n  ys \\<noteq> []\n  normalized (?x # ys) \\<Longrightarrow> normalized ys\n\ngoal (1 subgoal):\n 1. normalized ys", "by simp"], ["proof (state)\nthis:\n  normalized ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)\n 2. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)", "with \\<open>ys \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ys \\<noteq> []\n  normalized ys", "have \"min ys \\<noteq> None\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  normalized ys\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min ys \\<noteq> None", "by (simp add: normalized_min_not_None)"], ["proof (state)\nthis:\n  Binomial_Queue.min ys \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)\n 2. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)", "then"], ["proof (chain)\npicking this:\n  Binomial_Queue.min ys \\<noteq> None", "obtain a' where oa': \"min ys = Some a'\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min ys \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        Binomial_Queue.min ys = Some a' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Binomial_Queue.min ys = Some a'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)\n 2. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)", "with Some N False"], ["proof (chain)\npicking this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n  normalized ys\n  ys \\<noteq> []\n  Binomial_Queue.min ys = Some a'", "have \"\\<forall>y \\<in> set ys. y = None \\<or> a' \\<le> priority (the y)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n  normalized ys\n  ys \\<noteq> []\n  Binomial_Queue.min ys = Some a'\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ys. y = None \\<or> a' \\<le> priority (the y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ys. y = None \\<or> a' \\<le> priority (the y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)\n 2. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)", "with Some oa'"], ["proof (chain)\npicking this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n  Binomial_Queue.min ys = Some a'\n  \\<forall>y\\<in>set ys. y = None \\<or> a' \\<le> priority (the y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>normalized ys; ys \\<noteq> [];\n   Binomial_Queue.min ys = Some ?a\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                       x = None \\<or> ?a \\<le> priority (the x)\n  normalized (Some t # ys)\n  Some t # ys \\<noteq> []\n  Binomial_Queue.min (Some t # ys) = Some a\n  Binomial_Queue.min ys = Some a'\n  \\<forall>y\\<in>set ys. y = None \\<or> a' \\<le> priority (the y)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (Some t # ys).\n       x = None \\<or> a \\<le> priority (the x)", "by (cases \"a' \\<le> priority t\") (auto simp add: least.commute)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (Some t # ys). x = None \\<or> a \\<le> priority (the x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a.\n                \\<lbrakk>normalized ys; ys \\<noteq> [];\n                 Binomial_Queue.min ys = Some a\\<rbrakk>\n                \\<Longrightarrow> \\<forall>x\\<in>set ys.\n                                     x = None \\<or>\n                                     a \\<le> priority (the x);\n     normalized (Some t # ys); Some t # ys \\<noteq> [];\n     Binomial_Queue.min (Some t # ys) = Some a; ys = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (Some t # ys).\n                         x = None \\<or> a \\<le> priority (the x)", "qed simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (Some t # ys). x = None \\<or> a \\<le> priority (the x)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>normalized []; [] \\<noteq> [];\n        Binomial_Queue.min [] = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set [].\n                            x = None \\<or> a \\<le> priority (the x)\n 2. \\<And>xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>normalized xs; xs \\<noteq> [];\n                    Binomial_Queue.min xs = Some a\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set xs.\n  x = None \\<or> a \\<le> priority (the x);\n        normalized (None # xs); None # xs \\<noteq> [];\n        Binomial_Queue.min (None # xs) = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (None # xs).\n                            x = None \\<or> a \\<le> priority (the x)", "qed simp_all"], ["", "lemma min_exists:\n  assumes \"min xs = Some a\"\n  shows \"Some a \\<in> map_option priority ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some a \\<in> map_option priority ` set xs", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. Some a \\<notin> map_option priority ` set xs \\<Longrightarrow> False", "assume \"Some a \\<notin> map_option priority ` set xs\""], ["proof (state)\nthis:\n  Some a \\<notin> map_option priority ` set xs\n\ngoal (1 subgoal):\n 1. Some a \\<notin> map_option priority ` set xs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Some a \\<notin> map_option priority ` set xs", "have \"\\<forall>x \\<in> set xs. x = None \\<or> priority (the x) \\<noteq> a\""], ["proof (prove)\nusing this:\n  Some a \\<notin> map_option priority ` set xs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = None \\<or> priority (the x) \\<noteq> a", "by (induct xs) auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. x = None \\<or> priority (the x) \\<noteq> a\n\ngoal (1 subgoal):\n 1. Some a \\<notin> map_option priority ` set xs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs. x = None \\<or> priority (the x) \\<noteq> a", "have \"min xs \\<noteq> Some a\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. x = None \\<or> priority (the x) \\<noteq> a\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> Some a", "proof (induct xs arbitrary: a)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<forall>x\\<in>set [].\n          x = None \\<or> priority (the x) \\<noteq> a \\<Longrightarrow>\n       Binomial_Queue.min [] \\<noteq> Some a\n 2. \\<And>xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<forall>x\\<in>set xs.\n                      x = None \\<or>\n                      priority (the x) \\<noteq> a \\<Longrightarrow>\n                   Binomial_Queue.min xs \\<noteq> Some a;\n        \\<forall>x\\<in>set (None # xs).\n           x = None \\<or> priority (the x) \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (None # xs) \\<noteq> Some a\n 3. \\<And>x xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<forall>x\\<in>set xs.\n                      x = None \\<or>\n                      priority (the x) \\<noteq> a \\<Longrightarrow>\n                   Binomial_Queue.min xs \\<noteq> Some a;\n        \\<forall>x\\<in>set (Some x # xs).\n           x = None \\<or> priority (the x) \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (Some x # xs) \\<noteq> Some a", "case (Some t ys)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ys.\n     x = None \\<or> priority (the x) \\<noteq> ?a \\<Longrightarrow>\n  Binomial_Queue.min ys \\<noteq> Some ?a\n  \\<forall>x\\<in>set (Some t # ys).\n     x = None \\<or> priority (the x) \\<noteq> a\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<forall>x\\<in>set [].\n          x = None \\<or> priority (the x) \\<noteq> a \\<Longrightarrow>\n       Binomial_Queue.min [] \\<noteq> Some a\n 2. \\<And>xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<forall>x\\<in>set xs.\n                      x = None \\<or>\n                      priority (the x) \\<noteq> a \\<Longrightarrow>\n                   Binomial_Queue.min xs \\<noteq> Some a;\n        \\<forall>x\\<in>set (None # xs).\n           x = None \\<or> priority (the x) \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (None # xs) \\<noteq> Some a\n 3. \\<And>x xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<forall>x\\<in>set xs.\n                      x = None \\<or>\n                      priority (the x) \\<noteq> a \\<Longrightarrow>\n                   Binomial_Queue.min xs \\<noteq> Some a;\n        \\<forall>x\\<in>set (Some x # xs).\n           x = None \\<or> priority (the x) \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (Some x # xs) \\<noteq> Some a", "hence \"priority t \\<noteq> a\" and \"min ys \\<noteq> Some a\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ys.\n     x = None \\<or> priority (the x) \\<noteq> ?a \\<Longrightarrow>\n  Binomial_Queue.min ys \\<noteq> Some ?a\n  \\<forall>x\\<in>set (Some t # ys).\n     x = None \\<or> priority (the x) \\<noteq> a\n\ngoal (1 subgoal):\n 1. priority t \\<noteq> a &&& Binomial_Queue.min ys \\<noteq> Some a", "by simp_all"], ["proof (state)\nthis:\n  priority t \\<noteq> a\n  Binomial_Queue.min ys \\<noteq> Some a\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<forall>x\\<in>set [].\n          x = None \\<or> priority (the x) \\<noteq> a \\<Longrightarrow>\n       Binomial_Queue.min [] \\<noteq> Some a\n 2. \\<And>xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<forall>x\\<in>set xs.\n                      x = None \\<or>\n                      priority (the x) \\<noteq> a \\<Longrightarrow>\n                   Binomial_Queue.min xs \\<noteq> Some a;\n        \\<forall>x\\<in>set (None # xs).\n           x = None \\<or> priority (the x) \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (None # xs) \\<noteq> Some a\n 3. \\<And>x xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<forall>x\\<in>set xs.\n                      x = None \\<or>\n                      priority (the x) \\<noteq> a \\<Longrightarrow>\n                   Binomial_Queue.min xs \\<noteq> Some a;\n        \\<forall>x\\<in>set (Some x # xs).\n           x = None \\<or> priority (the x) \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (Some x # xs) \\<noteq> Some a", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min (Some t # ys) \\<noteq> Some a", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. least (Some (priority t)) (Binomial_Queue.min ys) =\n    Some a \\<Longrightarrow>\n    False", "assume \"least (Some (priority t)) (min ys) = Some a\""], ["proof (state)\nthis:\n  least (Some (priority t)) (Binomial_Queue.min ys) = Some a\n\ngoal (1 subgoal):\n 1. least (Some (priority t)) (Binomial_Queue.min ys) =\n    Some a \\<Longrightarrow>\n    False", "hence \"Some (priority t) = Some a \\<or> min ys = Some a\""], ["proof (prove)\nusing this:\n  least (Some (priority t)) (Binomial_Queue.min ys) = Some a\n\ngoal (1 subgoal):\n 1. Some (priority t) = Some a \\<or> Binomial_Queue.min ys = Some a", "by (rule least_split)"], ["proof (state)\nthis:\n  Some (priority t) = Some a \\<or> Binomial_Queue.min ys = Some a\n\ngoal (1 subgoal):\n 1. least (Some (priority t)) (Binomial_Queue.min ys) =\n    Some a \\<Longrightarrow>\n    False", "with \\<open>min ys \\<noteq> Some a\\<close>"], ["proof (chain)\npicking this:\n  Binomial_Queue.min ys \\<noteq> Some a\n  Some (priority t) = Some a \\<or> Binomial_Queue.min ys = Some a", "have \"priority t = a\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min ys \\<noteq> Some a\n  Some (priority t) = Some a \\<or> Binomial_Queue.min ys = Some a\n\ngoal (1 subgoal):\n 1. priority t = a", "by simp"], ["proof (state)\nthis:\n  priority t = a\n\ngoal (1 subgoal):\n 1. least (Some (priority t)) (Binomial_Queue.min ys) =\n    Some a \\<Longrightarrow>\n    False", "with \\<open>priority t \\<noteq> a\\<close>"], ["proof (chain)\npicking this:\n  priority t \\<noteq> a\n  priority t = a", "show False"], ["proof (prove)\nusing this:\n  priority t \\<noteq> a\n  priority t = a\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Binomial_Queue.min (Some t # ys) \\<noteq> Some a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<forall>x\\<in>set [].\n          x = None \\<or> priority (the x) \\<noteq> a \\<Longrightarrow>\n       Binomial_Queue.min [] \\<noteq> Some a\n 2. \\<And>xs a.\n       \\<lbrakk>\\<And>a.\n                   \\<forall>x\\<in>set xs.\n                      x = None \\<or>\n                      priority (the x) \\<noteq> a \\<Longrightarrow>\n                   Binomial_Queue.min xs \\<noteq> Some a;\n        \\<forall>x\\<in>set (None # xs).\n           x = None \\<or> priority (the x) \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> Binomial_Queue.min (None # xs) \\<noteq> Some a", "qed simp_all"], ["proof (state)\nthis:\n  Binomial_Queue.min xs \\<noteq> Some a\n\ngoal (1 subgoal):\n 1. Some a \\<notin> map_option priority ` set xs \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  Binomial_Queue.min xs = Some a\n  Binomial_Queue.min xs \\<noteq> Some a", "show False"], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs = Some a\n  Binomial_Queue.min xs \\<noteq> Some a\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec find :: \"'a::linorder \\<Rightarrow> ('a, 'b) binqueue \\<Rightarrow> ('a, 'b) bintree option\" where\n  \"find a [] = None\"\n| \"find a (x#xs) = (case x of None \\<Rightarrow> find a xs\n    | Some t \\<Rightarrow> if priority t = a then Some t else find a xs)\""], ["", "declare find.simps [simp del]"], ["", "lemma find_simps [simp, code]:\n  \"find a [] = None\"\n  \"find a (None # xs) = find a xs\"\n  \"find a (Some t # xs) = (if priority t = a then Some t else find a xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.find a [] = None &&&\n    Binomial_Queue.find a (None # xs) = Binomial_Queue.find a xs &&&\n    Binomial_Queue.find a (Some t # xs) =\n    (if priority t = a then Some t else Binomial_Queue.find a xs)", "by (simp_all add: find_def)"], ["", "lemma find_works:\n  assumes \"Some a \\<in> set (map (map_option priority) xs)\"\n  shows \"\\<exists>t. find a xs = Some t \\<and> priority t = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. Binomial_Queue.find a xs = Some t \\<and> priority t = a", "using assms"], ["proof (prove)\nusing this:\n  Some a \\<in> set (map (map_option priority) xs)\n\ngoal (1 subgoal):\n 1. \\<exists>t. Binomial_Queue.find a xs = Some t \\<and> priority t = a", "by (induct xs) auto"], ["", "lemma find_works_not_None:\n  \"Some a \\<in> set (map (map_option priority) xs) \\<Longrightarrow> find a xs \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some a \\<in> set (map (map_option priority) xs) \\<Longrightarrow>\n    Binomial_Queue.find a xs \\<noteq> None", "by (drule find_works) auto"], ["", "lemma find_None:\n  \"find a xs = None \\<Longrightarrow> Some a \\<notin> set (map (map_option priority) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.find a xs = None \\<Longrightarrow>\n    Some a \\<notin> set (map (map_option priority) xs)", "by (auto simp add: find_works_not_None)"], ["", "lemma find_exist:\n  \"find a xs = Some t \\<Longrightarrow> Some t \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.find a xs = Some t \\<Longrightarrow> Some t \\<in> set xs", "by (induct xs) (simp_all add: eq_commute)"], ["", "definition find_min :: \"('a::linorder, 'b) binqueue \\<Rightarrow> ('a, 'b) bintree option\" where\n  \"find_min xs = (case min xs of None \\<Rightarrow> None | Some a \\<Rightarrow> find a xs)\""], ["", "lemma find_min_simps [simp]:\n  \"find_min [] = None\"\n  \"find_min (None # xs) = find_min xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_min [] = None &&& find_min (None # xs) = find_min xs", "by (auto simp add: find_min_def split: option.split)"], ["", "lemma find_min_single:\n  \"find_min [x] = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_min [x] = x", "by (cases x) (auto simp add: find_min_def)"], ["", "lemma min_eq_find_min_None:\n  \"min xs = None \\<longleftrightarrow> find_min xs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Binomial_Queue.min xs = None) = (find_min xs = None)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Binomial_Queue.min xs = None \\<Longrightarrow> find_min xs = None\n 2. find_min xs = None \\<Longrightarrow> Binomial_Queue.min xs = None", "show \"min xs = None \\<Longrightarrow> find_min xs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = None \\<Longrightarrow> find_min xs = None", "by (simp add: find_min_def)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = None \\<Longrightarrow> find_min xs = None\n\ngoal (1 subgoal):\n 1. find_min xs = None \\<Longrightarrow> Binomial_Queue.min xs = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. find_min xs = None \\<Longrightarrow> Binomial_Queue.min xs = None", "assume *: \"find_min xs = None\""], ["proof (state)\nthis:\n  find_min xs = None\n\ngoal (1 subgoal):\n 1. find_min xs = None \\<Longrightarrow> Binomial_Queue.min xs = None", "show \"min xs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = None", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> None \\<Longrightarrow> False", "assume \"min xs \\<noteq> None\""], ["proof (state)\nthis:\n  Binomial_Queue.min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> None \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Binomial_Queue.min xs \\<noteq> None", "obtain a where \"min xs = Some a\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        Binomial_Queue.min xs = Some a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = Some a\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> None \\<Longrightarrow> False", "hence \"find_min xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs = Some a\n\ngoal (1 subgoal):\n 1. find_min xs \\<noteq> None", "by (simp add: find_min_def min_exists find_works_not_None)"], ["proof (state)\nthis:\n  find_min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> None \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  find_min xs = None\n  find_min xs \\<noteq> None", "show False"], ["proof (prove)\nusing this:\n  find_min xs = None\n  find_min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_eq_find_min_Some:\n  \"min xs = Some a \\<longleftrightarrow> (\\<exists> t. find_min xs = Some t \\<and> priority t = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Binomial_Queue.min xs = Some a) =\n    (\\<exists>t. find_min xs = Some t \\<and> priority t = a)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Binomial_Queue.min xs = Some a \\<Longrightarrow>\n    \\<exists>t. find_min xs = Some t \\<and> priority t = a\n 2. \\<exists>t. find_min xs = Some t \\<and> priority t = a \\<Longrightarrow>\n    Binomial_Queue.min xs = Some a", "show D1: \"\\<And>a. min xs = Some a\n    \\<Longrightarrow> (\\<exists> t. find_min xs = Some t \\<and> priority t = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       Binomial_Queue.min xs = Some a \\<Longrightarrow>\n       \\<exists>t. find_min xs = Some t \\<and> priority t = a", "by (simp add: find_min_def find_works min_exists)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = Some ?a \\<Longrightarrow>\n  \\<exists>t. find_min xs = Some t \\<and> priority t = ?a\n\ngoal (1 subgoal):\n 1. \\<exists>t. find_min xs = Some t \\<and> priority t = a \\<Longrightarrow>\n    Binomial_Queue.min xs = Some a", "(* no 'next' here to keep D1 in scope as it is needed in the other part *)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = Some ?a \\<Longrightarrow>\n  \\<exists>t. find_min xs = Some t \\<and> priority t = ?a\n\ngoal (1 subgoal):\n 1. \\<exists>t. find_min xs = Some t \\<and> priority t = a \\<Longrightarrow>\n    Binomial_Queue.min xs = Some a", "assume *: \"\\<exists> t. find_min xs = Some t \\<and> priority t = a\""], ["proof (state)\nthis:\n  \\<exists>t. find_min xs = Some t \\<and> priority t = a\n\ngoal (1 subgoal):\n 1. \\<exists>t. find_min xs = Some t \\<and> priority t = a \\<Longrightarrow>\n    Binomial_Queue.min xs = Some a", "show \"min xs = Some a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs = Some a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> Some a \\<Longrightarrow> False", "assume \"min xs \\<noteq> Some a\""], ["proof (state)\nthis:\n  Binomial_Queue.min xs \\<noteq> Some a\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> Some a \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs \\<noteq> Some a\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"min xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n     Binomial_Queue.min xs = None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>aa.\n       \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n        Binomial_Queue.min xs = Some aa\\<rbrakk>\n       \\<Longrightarrow> False", "case None"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n     Binomial_Queue.min xs = None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>aa.\n       \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n        Binomial_Queue.min xs = Some aa\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"find_min xs = None\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs = None\n\ngoal (1 subgoal):\n 1. find_min xs = None", "by (simp only: min_eq_find_min_None)"], ["proof (state)\nthis:\n  find_min xs = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n     Binomial_Queue.min xs = None\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>aa.\n       \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n        Binomial_Queue.min xs = Some aa\\<rbrakk>\n       \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  \\<exists>t. find_min xs = Some t \\<and> priority t = a\n  find_min xs = None", "show False"], ["proof (prove)\nusing this:\n  \\<exists>t. find_min xs = Some t \\<and> priority t = a\n  find_min xs = None\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n        Binomial_Queue.min xs = Some aa\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n        Binomial_Queue.min xs = Some aa\\<rbrakk>\n       \\<Longrightarrow> False", "case (Some b)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = Some b\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n        Binomial_Queue.min xs = Some aa\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>min xs \\<noteq> Some a\\<close>"], ["proof (chain)\npicking this:\n  Binomial_Queue.min xs \\<noteq> Some a\n  Binomial_Queue.min xs = Some b", "have \"a \\<noteq> b\""], ["proof (prove)\nusing this:\n  Binomial_Queue.min xs \\<noteq> Some a\n  Binomial_Queue.min xs = Some b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by simp"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>Binomial_Queue.min xs \\<noteq> Some a;\n        Binomial_Queue.min xs = Some aa\\<rbrakk>\n       \\<Longrightarrow> False", "with * Some"], ["proof (chain)\npicking this:\n  \\<exists>t. find_min xs = Some t \\<and> priority t = a\n  Binomial_Queue.min xs = Some b\n  a \\<noteq> b", "show False"], ["proof (prove)\nusing this:\n  \\<exists>t. find_min xs = Some t \\<and> priority t = a\n  Binomial_Queue.min xs = Some b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. False", "using D1"], ["proof (prove)\nusing this:\n  \\<exists>t. find_min xs = Some t \\<and> priority t = a\n  Binomial_Queue.min xs = Some b\n  a \\<noteq> b\n  Binomial_Queue.min xs = Some ?a \\<Longrightarrow>\n  \\<exists>t. find_min xs = Some t \\<and> priority t = ?a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Binomial_Queue.min xs = Some a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_min_exist:\n  assumes \"find_min xs = Some t\"\n  shows \"Some t \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some t \\<in> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Some t \\<in> set xs", "from assms"], ["proof (chain)\npicking this:\n  find_min xs = Some t", "have \"min xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. Binomial_Queue.min xs \\<noteq> None", "by (simp add: min_eq_find_min_None)"], ["proof (state)\nthis:\n  Binomial_Queue.min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. Some t \\<in> set xs", "with assms"], ["proof (chain)\npicking this:\n  find_min xs = Some t\n  Binomial_Queue.min xs \\<noteq> None", "show ?thesis"], ["proof (prove)\nusing this:\n  find_min xs = Some t\n  Binomial_Queue.min xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. Some t \\<in> set xs", "by (auto simp add: find_min_def find_exist)"], ["proof (state)\nthis:\n  Some t \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_min_is_min:\n  assumes \"normalized xs\"\n  and \"xs \\<noteq> []\"\n  and \"find_min xs = Some t\"\n  shows \"\\<forall>x \\<in> set xs. x = None \\<or> (priority t) \\<le> priority (the x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = None \\<or> priority t \\<le> priority (the x)", "using assms"], ["proof (prove)\nusing this:\n  normalized xs\n  xs \\<noteq> []\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = None \\<or> priority t \\<le> priority (the x)", "by (simp add: min_eq_find_min_Some min_is_min)"], ["", "lemma normalized_find_min_exists:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> \\<exists>t. find_min xs = Some t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t. find_min xs = Some t", "by (drule normalized_min_not_None) (simp_all add: min_eq_find_min_None)"], ["", "primrec\n  match :: \"'a::linorder \\<Rightarrow> ('a, 'b) bintree option \\<Rightarrow> ('a, 'b) bintree option\"\nwhere\n  \"match a None = None\"\n| \"match a (Some t) = (if priority t = a then None else Some t)\""], ["", "definition delete_min :: \"('a::linorder, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue\" where\n  \"delete_min xs = (case find_min xs\n    of Some (Node a v ts) \\<Rightarrow>\n         normalize (meld (map Some (rev ts)) (map (match a) xs)) \n     | None \\<Rightarrow> [])\""], ["", "lemma delete_min_empty [simp]:\n  \"delete_min [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete_min [] = []", "by (simp add: delete_min_def)"], ["", "lemma delete_min_nonempty [simp]:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> find_min xs = Some t\n    \\<Longrightarrow> delete_min xs = normalize\n      (meld (map Some (rev (children t))) (map (match (priority t)) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; xs \\<noteq> []; find_min xs = Some t\\<rbrakk>\n    \\<Longrightarrow> delete_min xs =\n                      Binomial_Queue.normalize\n                       (meld (map Some (rev (children t)))\n                         (map (match (priority t)) xs))", "unfolding delete_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; xs \\<noteq> []; find_min xs = Some t\\<rbrakk>\n    \\<Longrightarrow> (case find_min xs of None \\<Rightarrow> []\n                       | Some (Node a v ts) \\<Rightarrow>\n                           Binomial_Queue.normalize\n                            (meld (map Some (rev ts)) (map (match a) xs))) =\n                      Binomial_Queue.normalize\n                       (meld (map Some (rev (children t)))\n                         (map (match (priority t)) xs))", "by (cases t) simp"], ["", "lemma is_binqueue_delete_min:\n  assumes \"is_binqueue 0 xs\"\n  shows \"is_binqueue 0 (delete_min xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue 0 (delete_min xs)", "proof (cases \"find_min xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)\n 2. \\<And>a.\n       find_min xs = Some a \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "case (Some t)"], ["proof (state)\nthis:\n  find_min xs = Some t\n\ngoal (2 subgoals):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)\n 2. \\<And>a.\n       find_min xs = Some a \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "from assms"], ["proof (chain)\npicking this:\n  is_binqueue 0 xs", "have \"is_binqueue 0 (map (match (priority t)) xs)\""], ["proof (prove)\nusing this:\n  is_binqueue 0 xs\n\ngoal (1 subgoal):\n 1. is_binqueue 0 (map (match (priority t)) xs)", "by (induct xs) simp_all"], ["proof (state)\nthis:\n  is_binqueue 0 (map (match (priority t)) xs)\n\ngoal (2 subgoals):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)\n 2. \\<And>a.\n       find_min xs = Some a \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "moreover"], ["proof (state)\nthis:\n  is_binqueue 0 (map (match (priority t)) xs)\n\ngoal (2 subgoals):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)\n 2. \\<And>a.\n       find_min xs = Some a \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "from Some"], ["proof (chain)\npicking this:\n  find_min xs = Some t", "have \"Some t \\<in> set xs\""], ["proof (prove)\nusing this:\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. Some t \\<in> set xs", "by (rule find_min_exist)"], ["proof (state)\nthis:\n  Some t \\<in> set xs\n\ngoal (2 subgoals):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)\n 2. \\<And>a.\n       find_min xs = Some a \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "with assms"], ["proof (chain)\npicking this:\n  is_binqueue 0 xs\n  Some t \\<in> set xs", "have \"\\<exists>l. is_bintree l t\" and \"is_heap t\""], ["proof (prove)\nusing this:\n  is_binqueue 0 xs\n  Some t \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>l. is_bintree_list l (children t) &&&\n    is_heap_list (priority t) (children t)", "using is_binqueue_select[of 0 xs t]"], ["proof (prove)\nusing this:\n  is_binqueue 0 xs\n  Some t \\<in> set xs\n  \\<lbrakk>is_binqueue 0 xs; Some t \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k.\n                       is_bintree_list k (children t) \\<and>\n                       is_heap_list (priority t) (children t)\n\ngoal (1 subgoal):\n 1. \\<exists>l. is_bintree_list l (children t) &&&\n    is_heap_list (priority t) (children t)", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. is_bintree_list l (children t)\n  is_heap_list (priority t) (children t)\n\ngoal (2 subgoals):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)\n 2. \\<And>a.\n       find_min xs = Some a \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "with assms"], ["proof (chain)\npicking this:\n  is_binqueue 0 xs\n  \\<exists>l. is_bintree_list l (children t)\n  is_heap_list (priority t) (children t)", "have \"is_binqueue 0 (map Some (rev (children t)))\""], ["proof (prove)\nusing this:\n  is_binqueue 0 xs\n  \\<exists>l. is_bintree_list l (children t)\n  is_heap_list (priority t) (children t)\n\ngoal (1 subgoal):\n 1. is_binqueue 0 (map Some (rev (children t)))", "by (auto simp add: is_binqueue_children)"], ["proof (state)\nthis:\n  is_binqueue 0 (map Some (rev (children t)))\n\ngoal (2 subgoals):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)\n 2. \\<And>a.\n       find_min xs = Some a \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "ultimately"], ["proof (chain)\npicking this:\n  is_binqueue 0 (map (match (priority t)) xs)\n  is_binqueue 0 (map Some (rev (children t)))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_binqueue 0 (map (match (priority t)) xs)\n  is_binqueue 0 (map Some (rev (children t)))\n\ngoal (1 subgoal):\n 1. is_binqueue 0 (delete_min xs)", "using Some"], ["proof (prove)\nusing this:\n  is_binqueue 0 (map (match (priority t)) xs)\n  is_binqueue 0 (map Some (rev (children t)))\n  find_min xs = Some t\n\ngoal (1 subgoal):\n 1. is_binqueue 0 (delete_min xs)", "by (auto simp add: is_binqueue_meld delete_min_def is_binqueue_normalize\n      split: bintree.split)"], ["proof (state)\nthis:\n  is_binqueue 0 (delete_min xs)\n\ngoal (1 subgoal):\n 1. find_min xs = None \\<Longrightarrow> is_binqueue 0 (delete_min xs)", "qed (simp add: delete_min_def)"], ["", "lemma normalized_delete_min:\n  \"normalized (delete_min xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized (delete_min xs)", "by (cases \"find_min xs\")\n    (auto simp add: delete_min_def normalized_normalize split: bintree.split)"], ["", "subsubsection \\<open>Dedicated grand unified operation for generated program\\<close>"], ["", "definition\n  meld' :: \"('a, 'b) bintree option \\<Rightarrow> ('a::linorder, 'b) binqueue\n    \\<Rightarrow> ('a, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue\"\nwhere\n  \"meld' z xs ys = add z (meld xs ys)\""], ["", "lemma [code]:\n  \"add z xs = meld' z [] xs\"\n  \"meld xs ys = meld' None xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add z xs = meld' z [] xs &&& meld xs ys = meld' None xs ys", "by (simp_all add: meld'_def)"], ["", "lemma [code]:\n  \"meld' z (Some t # xs) (Some r # ys) =\n    z # (meld' (Some (merge t r)) xs ys)\"\n  \"meld' (Some t) (Some r # xs) (None # ys) =\n    None # (meld' (Some (merge t r)) xs ys)\"\n  \"meld' (Some t) (None # xs) (Some r # ys) =\n    None # (meld' (Some (merge t r)) xs ys)\"\n  \"meld' None (x # xs) (None # ys) = x # (meld' None xs ys)\"\n  \"meld' None (None # xs) (y # ys) = y # (meld' None xs ys)\"\n  \"meld' z (None # xs) (None # ys) = z # (meld' None xs ys)\"\n  \"meld' z xs [] = meld' z [] xs\"\n  \"meld' z [] (y # ys) = meld' None [z] (y # ys)\"\n  \"meld' (Some t) [] ys = meld' None [Some t] ys\"\n  \"meld' None [] ys = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((meld' z (Some t # xs) (Some r # ys) =\n      z # meld' (Some (merge t r)) xs ys &&&\n      meld' (Some t) (Some r # xs) (None # ys) =\n      None # meld' (Some (merge t r)) xs ys) &&&\n     meld' (Some t) (None # xs) (Some r # ys) =\n     None # meld' (Some (merge t r)) xs ys &&&\n     meld' None (x # xs) (None # ys) = x # meld' None xs ys &&&\n     meld' None (None # xs) (y # ys) = y # meld' None xs ys) &&&\n    (meld' z (None # xs) (None # ys) = z # meld' None xs ys &&&\n     meld' z xs [] = meld' z [] xs) &&&\n    meld' z [] (y # ys) = meld' None [z] (y # ys) &&&\n    meld' (Some t) [] ys = meld' None [Some t] ys &&& meld' None [] ys = ys", "by (simp add: meld'_def | cases z)+"], ["", "subsubsection \\<open>Interface operations\\<close>"], ["", "abbreviation (input) empty :: \"('a,'b) binqueue\" where\n  \"empty \\<equiv> []\""], ["", "definition\n  insert :: \"'a::linorder \\<Rightarrow> 'b \\<Rightarrow> ('a, 'b) binqueue \\<Rightarrow> ('a, 'b) binqueue\"\nwhere\n  \"insert a v xs = add (Some (Node a v [])) xs\""], ["", "lemma insert_simps [simp]:\n  \"insert a v [] = [Some (Node a v [])]\"\n  \"insert a v (None # xs) = Some (Node a v []) # xs\"\n  \"insert a v (Some t # xs) = None # add (Some (merge (Node a v []) t)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Binomial_Queue.insert a v [] = [Some (Node a v [])] &&&\n    Binomial_Queue.insert a v (None # xs) = Some (Node a v []) # xs &&&\n    Binomial_Queue.insert a v (Some t # xs) =\n    None # add (Some (merge (Node a v []) t)) xs", "by (simp_all add: insert_def)"], ["", "lemma is_binqueue_insert:\n  \"is_binqueue 0 xs \\<Longrightarrow> is_binqueue 0 (insert a v xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_binqueue 0 xs \\<Longrightarrow>\n    is_binqueue 0 (Binomial_Queue.insert a v xs)", "by (simp add: is_binqueue_add_Some insert_def)"], ["", "lemma normalized_insert:\n  \"normalized xs \\<Longrightarrow> normalized (insert a v xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalized xs \\<Longrightarrow>\n    normalized (Binomial_Queue.insert a v xs)", "by (simp add: normalized_add insert_def)"], ["", "definition\n  pop :: \"('a::linorder, 'b) binqueue \\<Rightarrow> (('b \\<times> 'a) option \\<times> ('a, 'b) binqueue)\"\nwhere\n  \"pop xs = (case find_min xs of \n      None \\<Rightarrow> (None, xs) \n    | Some t  \\<Rightarrow> (Some (val t, priority t), delete_min xs))\""], ["", "lemma pop_empty [simp]:\n  \"pop empty = (None, empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop [] = (None, [])", "by (simp add: pop_def empty_def)"], ["", "lemma pop_nonempty [simp]:\n  \"normalized xs \\<Longrightarrow> xs \\<noteq> [] \\<Longrightarrow> find_min xs = Some t\n    \\<Longrightarrow> pop xs = (Some (val t, priority t), normalize\n      (meld (map Some (rev (children t))) (map (match (priority t)) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>normalized xs; xs \\<noteq> []; find_min xs = Some t\\<rbrakk>\n    \\<Longrightarrow> pop xs =\n                      (Some (val t, priority t),\n                       Binomial_Queue.normalize\n                        (meld (map Some (rev (children t)))\n                          (map (match (priority t)) xs)))", "by (simp add: pop_def)"], ["", "lemma pop_code [code]:\n  \"pop xs = (case find_min xs of \n      None \\<Rightarrow> (None, xs) \n    | Some t  \\<Rightarrow> (Some (val t, priority t), normalize\n       (meld (map Some (rev (children t))) (map (match (priority t)) xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop xs =\n    (case find_min xs of None \\<Rightarrow> (None, xs)\n     | Some t \\<Rightarrow>\n         (Some (val t, priority t),\n          Binomial_Queue.normalize\n           (meld (map Some (rev (children t)))\n             (map (match (priority t)) xs))))", "by (cases \"find_min xs\") (simp_all add: pop_def delete_min_def split: bintree.split)"], ["", "end"]]}