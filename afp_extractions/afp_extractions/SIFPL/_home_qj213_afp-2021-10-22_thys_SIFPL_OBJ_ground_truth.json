{"file_name": "/home/qj213/afp-2021-10-22/thys/SIFPL/OBJ.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SIFPL", "problem_names": ["lemma lookupNoneAppend[rule_format]: \n\"\\<forall> l L2. (lookup L1 l = None \\<longrightarrow> lookup L2 l = None \\<longrightarrow> lookup (L1 @ L2) l = None)\"", "lemma DomAppendUnion[rule_format]: \"\\<forall> ab. Dom (a @ ab) = Dom a \\<union> Dom ab\"", "lemma DomAppend: \"Dom L \\<subseteq> Dom((a, b) # L)\"", "lemma lookupSomeAppend1[rule_format]:\n\"\\<forall> L2 l c . lookup L1 l = Some c \\<longrightarrow> lookup (L1 @ L2) l = Some c\"", "lemma DomUnion[rule_format]:\"Dom ((a,b) # L) = {a} \\<union> Dom L\"", "lemma lookupSomeAppend2[rule_format]:\n\"\\<forall> l c L2 . lookup L2 l = Some c \\<longrightarrow> Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow> lookup (L1 @ L2) l = Some c\"", "lemma Sem_no_zero_height_derivsAux: \"\\<forall> s t. ((s, c \\<rightarrow>\\<^sub>0 t) \\<longrightarrow> False)\"", "lemma Sem_no_zero_height_derivs: \"(s, c \\<rightarrow>\\<^sub>0 t) \\<Longrightarrow> False\""], "translations": [["", "lemma lookupNoneAppend[rule_format]: \n\"\\<forall> l L2. (lookup L1 l = None \\<longrightarrow> lookup L2 l = None \\<longrightarrow> lookup (L1 @ L2) l = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l L2.\n       lookup L1 l = None \\<longrightarrow>\n       lookup L2 l = None \\<longrightarrow> lookup (L1 @ L2) l = None", "by (induct L1, simp+)"], ["", "lemma DomAppendUnion[rule_format]: \"\\<forall> ab. Dom (a @ ab) = Dom a \\<union> Dom ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ab. Dom (a @ ab) = Dom a \\<union> Dom ab", "apply (induct a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>ab. Dom ([] @ ab) = Dom [] \\<union> Dom ab\n 2. \\<And>a1 a2.\n       \\<forall>ab. Dom (a2 @ ab) = Dom a2 \\<union> Dom ab \\<Longrightarrow>\n       \\<forall>ab. Dom ((a1 # a2) @ ab) = Dom (a1 # a2) \\<union> Dom ab", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>ab. Dom (a2 @ ab) = Dom a2 \\<union> Dom ab \\<Longrightarrow>\n       \\<forall>ab. Dom ((a1 # a2) @ ab) = Dom (a1 # a2) \\<union> Dom ab", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<forall>ab.\n          {l. \\<exists>a. lookup (a2 @ ab) l = Some a} =\n          {l. \\<exists>a. lookup a2 l = Some a} \\<union>\n          {l. \\<exists>a. lookup ab l = Some a} \\<Longrightarrow>\n       \\<forall>ab.\n          {l. fst a1 \\<noteq> l \\<longrightarrow>\n              (\\<exists>a. lookup (a2 @ ab) l = Some a)} =\n          {l. fst a1 \\<noteq> l \\<longrightarrow>\n              (\\<exists>a. lookup a2 l = Some a)} \\<union>\n          {l. \\<exists>a. lookup ab l = Some a}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a2 ab.\n       \\<forall>ab.\n          {l. \\<exists>a. lookup (a2 @ ab) l = Some a} =\n          {l. \\<exists>a. lookup a2 l = Some a} \\<union>\n          {l. \\<exists>a. lookup ab l = Some a} \\<Longrightarrow>\n       {l. a \\<noteq> l \\<longrightarrow>\n           (\\<exists>a. lookup (a2 @ ab) l = Some a)} =\n       {l. a \\<noteq> l \\<longrightarrow>\n           (\\<exists>a. lookup a2 l = Some a)} \\<union>\n       {l. \\<exists>a. lookup ab l = Some a}", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DomAppend: \"Dom L \\<subseteq> Dom((a, b) # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom L \\<subseteq> Dom ((a, b) # L)", "by (simp add: Dom_def, auto)"], ["", "lemma lookupSomeAppend1[rule_format]:\n\"\\<forall> L2 l c . lookup L1 l = Some c \\<longrightarrow> lookup (L1 @ L2) l = Some c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L2 l c.\n       lookup L1 l = Some c \\<longrightarrow> lookup (L1 @ L2) l = Some c", "by (induct L1, simp, simp)"], ["", "lemma DomUnion[rule_format]:\"Dom ((a,b) # L) = {a} \\<union> Dom L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom ((a, b) # L) = {a} \\<union> Dom L", "by (simp add: Dom_def DomAppendUnion, fast)"], ["", "lemma lookupSomeAppend2[rule_format]:\n\"\\<forall> l c L2 . lookup L2 l = Some c \\<longrightarrow> Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow> lookup (L1 @ L2) l = Some c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l c L2.\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n       lookup (L1 @ L2) l = Some c", "apply (induct L1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>l c L2.\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom [] \\<inter> Dom L2 = {} \\<longrightarrow>\n       lookup ([] @ L2) l = Some c\n 2. \\<And>a L1.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom (a # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup ((a # L1) @ L2) l = Some c", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a L1.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom (a # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup ((a # L1) @ L2) l = Some c", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       (a = l \\<longrightarrow>\n        lookup L2 l = Some c \\<longrightarrow>\n        Dom ((l, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n        b = c) \\<and>\n       (a \\<noteq> l \\<longrightarrow>\n        lookup L2 l = Some c \\<longrightarrow>\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n        lookup (L1 @ L2) l = Some c)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b L1 l c L2.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       a = l \\<longrightarrow>\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom ((l, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow> b = c\n 2. \\<And>a b L1 l c L2.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       a \\<noteq> l \\<longrightarrow>\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom ((a, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n       lookup (L1 @ L2) l = Some c", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b L1 l c L2.\n       \\<lbrakk>\\<forall>l c L2.\n                   lookup L2 l = Some c \\<longrightarrow>\n                   Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n                   lookup (L1 @ L2) l = Some c;\n        lookup L2 l = Some c;\n        Dom ((l, b) # L1) \\<inter> Dom L2 = {}\\<rbrakk>\n       \\<Longrightarrow> b = c\n 2. \\<And>a b L1 l c L2.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       a \\<noteq> l \\<longrightarrow>\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom ((a, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n       lookup (L1 @ L2) l = Some c", "apply (subgoal_tac \"l:Dom L2\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b L1 l c L2.\n       \\<lbrakk>\\<forall>l c L2.\n                   lookup L2 l = Some c \\<longrightarrow>\n                   Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n                   lookup (L1 @ L2) l = Some c;\n        lookup L2 l = Some c; Dom ((l, b) # L1) \\<inter> Dom L2 = {};\n        l \\<in> Dom L2\\<rbrakk>\n       \\<Longrightarrow> b = c\n 2. \\<And>b L1 l c L2.\n       \\<lbrakk>\\<forall>l c L2.\n                   lookup L2 l = Some c \\<longrightarrow>\n                   Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n                   lookup (L1 @ L2) l = Some c;\n        lookup L2 l = Some c;\n        Dom ((l, b) # L1) \\<inter> Dom L2 = {}\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom L2\n 3. \\<And>a b L1 l c L2.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       a \\<noteq> l \\<longrightarrow>\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom ((a, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n       lookup (L1 @ L2) l = Some c", "apply (simp add: DomUnion)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b L1 l c L2.\n       \\<lbrakk>\\<forall>l c L2.\n                   lookup L2 l = Some c \\<longrightarrow>\n                   Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n                   lookup (L1 @ L2) l = Some c;\n        lookup L2 l = Some c;\n        Dom ((l, b) # L1) \\<inter> Dom L2 = {}\\<rbrakk>\n       \\<Longrightarrow> l \\<in> Dom L2\n 2. \\<And>a b L1 l c L2.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       a \\<noteq> l \\<longrightarrow>\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom ((a, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n       lookup (L1 @ L2) l = Some c", "apply (simp add: Dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<forall>l c L2.\n          lookup L2 l = Some c \\<longrightarrow>\n          Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n          lookup (L1 @ L2) l = Some c \\<Longrightarrow>\n       a \\<noteq> l \\<longrightarrow>\n       lookup L2 l = Some c \\<longrightarrow>\n       Dom ((a, b) # L1) \\<inter> Dom L2 = {} \\<longrightarrow>\n       lookup (L1 @ L2) l = Some c", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<lbrakk>\\<forall>l c L2.\n                   lookup L2 l = Some c \\<longrightarrow>\n                   Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n                   lookup (L1 @ L2) l = Some c;\n        a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {}\\<rbrakk>\n       \\<Longrightarrow> lookup (L1 @ L2) l = Some c", "apply (erule_tac x=l in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<lbrakk>a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {};\n        \\<forall>c L2.\n           lookup L2 l = Some c \\<longrightarrow>\n           Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n           lookup (L1 @ L2) l = Some c\\<rbrakk>\n       \\<Longrightarrow> lookup (L1 @ L2) l = Some c", "apply (erule_tac x=c in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<lbrakk>a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {};\n        \\<forall>L2.\n           lookup L2 l = Some c \\<longrightarrow>\n           Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n           lookup (L1 @ L2) l = Some c\\<rbrakk>\n       \\<Longrightarrow> lookup (L1 @ L2) l = Some c", "apply (erule_tac x=L2 in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<lbrakk>a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {};\n        lookup L2 l = Some c \\<longrightarrow>\n        Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n        lookup (L1 @ L2) l = Some c\\<rbrakk>\n       \\<Longrightarrow> lookup (L1 @ L2) l = Some c", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<lbrakk>a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {};\n        Dom L1 \\<inter> Dom L2 = {} \\<longrightarrow>\n        lookup (L1 @ L2) l = Some c\\<rbrakk>\n       \\<Longrightarrow> lookup (L1 @ L2) l = Some c", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b L1 l c L2.\n       \\<lbrakk>a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {}\\<rbrakk>\n       \\<Longrightarrow> Dom L1 \\<inter> Dom L2 = {}\n 2. \\<And>a b L1 l c L2.\n       \\<lbrakk>a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {};\n        lookup (L1 @ L2) l = Some c\\<rbrakk>\n       \\<Longrightarrow> lookup (L1 @ L2) l = Some c", "apply (simp add: DomUnion)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b L1 l c L2.\n       \\<lbrakk>a \\<noteq> l; lookup L2 l = Some c;\n        Dom ((a, b) # L1) \\<inter> Dom L2 = {};\n        lookup (L1 @ L2) l = Some c\\<rbrakk>\n       \\<Longrightarrow> lookup (L1 @ L2) l = Some c", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Abstract types of variables, class names, field names, and\nlocations.\\<close>"], ["", "typedecl Var"], ["", "typedecl Class"], ["", "typedecl Field"], ["", "typedecl Location"], ["", "text\\<open>References are either null or a location. Values are either\nintegers or references.\\<close>"], ["", "datatype Ref = Nullref | Loc Location"], ["", "datatype Val = RVal Ref | IVal int"], ["", "text\\<open>The heap is a finite map from locations to objects. Objects have\na dynamic class and a field map.\\<close>"], ["", "type_synonym Object = \"Class \\<times> ((Field \\<times> Val) list)\""], ["", "type_synonym Heap = \"(Location \\<times> Object) list\""], ["", "text\\<open>Stores contain values for all variables, and states are pairs of\nstores and heaps.\\<close>"], ["", "type_synonym Store = \"Var \\<Rightarrow> Val\""], ["", "definition update :: \"Store \\<Rightarrow> Var \\<Rightarrow> Val \\<Rightarrow> Store\"\nwhere \"update s x v = (\\<lambda> y . if x=y then v else s y)\""], ["", "type_synonym State = \"Store \\<times> Heap\""], ["", "text\\<open>Arithmetic and boolean expressions are as before.\\<close>"], ["", "datatype Expr = \n    varE Var \n  | valE Val\n  | opE \"Val \\<Rightarrow> Val \\<Rightarrow> Val\" Expr Expr"], ["", "datatype BExpr = compB \"Val \\<Rightarrow> Val \\<Rightarrow> bool\" Expr Expr"], ["", "text\\<open>The same applies to their semantics.\\<close>"], ["", "primrec evalE::\"Expr \\<Rightarrow> Store \\<Rightarrow> Val\"\nwhere\n\"evalE (varE x) s = s x\" |\n\"evalE (valE v) s = v\" |\n\"evalE (opE f e1 e2) s = f (evalE e1 s) (evalE e2 s)\""], ["", "primrec evalB::\"BExpr \\<Rightarrow> Store \\<Rightarrow> bool\"\nwhere\n\"evalB (compB f e1 e2) s = f (evalE e1 s) (evalE e2 s)\""], ["", "text\\<open>The category of commands is extended by instructions for\nallocating a fresh object, obtaining a value from a field and assigning\na value to a field.\\<close>"], ["", "datatype OBJ =\n    Skip \n  | Assign Var Expr\n  | New Var Class\n  | Get Var Var Field\n  | Put Var Field Expr\n  | Comp OBJ OBJ\n  | While BExpr OBJ\n  | Iff BExpr OBJ OBJ\n  | Call"], ["", "text\\<open>The body of the procedure is identified by the same constant as\nbefore.\\<close>"], ["", "consts body :: OBJ"], ["", "text\\<open>The operational semantics is again a standard big-step\nrelation.\\<close>"], ["", "inductive_set Semn :: \"(State \\<times> OBJ \\<times> nat \\<times> State) set\"\nwhere\nSemSkip: \"s=t \\<Longrightarrow> (s,Skip,1, t):Semn\"\n\n| SemAssign:\n  \"\\<lbrakk> t = (update (fst s) x (evalE e (fst s)), snd s)\\<rbrakk> \n  \\<Longrightarrow> (s, Assign x e, 1, t):Semn\"\n\n| SemNew:\n  \"\\<lbrakk>l \\<notin> Dom (snd s); \n       t = (update (fst s) x (RVal (Loc l)), (l,(C,[])) # (snd s))\\<rbrakk> \n  \\<Longrightarrow> (s, New x C, 1, t):Semn\"\n\n| SemGet:\n  \"\\<lbrakk>(fst s) y = RVal(Loc l); lookup (snd s) l = Some(C,Flds); \n       lookup Flds F = Some v; t = (update (fst s) x v, snd s)\\<rbrakk> \n  \\<Longrightarrow> (s, Get x y F, 1, t):Semn\"\n\n| SemPut:\n  \"\\<lbrakk>(fst s) x = RVal(Loc l); lookup (snd s) l = Some(C,Flds); \n       t = (fst s, (l,(C,(F,evalE e (fst s)) # Flds)) # (snd s))\\<rbrakk> \n  \\<Longrightarrow> (s, Put x F e, 1, t):Semn\"\n\n| SemComp:\n  \"\\<lbrakk> (s, c, n, r):Semn; (r,d, m, t):Semn; k=(max n m)+1\\<rbrakk>\n  \\<Longrightarrow> (s, Comp c d, k, t):Semn\"\n\n| SemWhileT:\n  \"\\<lbrakk>evalB b (fst s); (s,c, n, r):Semn; (r, While b c, m, t):Semn; k=((max n m)+1)\\<rbrakk>\n  \\<Longrightarrow> (s, While b c, k, t):Semn\"\n\n| SemWhileF:\n  \"\\<lbrakk>\\<not> (evalB b (fst s)); t=s\\<rbrakk> \\<Longrightarrow> (s, While b c, 1, t):Semn\"\n\n| SemTrue:\n  \"\\<lbrakk>evalB b (fst s); (s,c1, n, t):Semn\\<rbrakk> \n  \\<Longrightarrow> (s, Iff b c1 c2, n+1, t):Semn\"\n\n| SemFalse:\n  \"\\<lbrakk>\\<not> (evalB b (fst s)); (s,c2, n, t):Semn\\<rbrakk>\n  \\<Longrightarrow> (s, Iff b c1 c2, n+1, t):Semn\"\n\n| SemCall: \"\\<lbrakk> (s,body,n, t):Semn\\<rbrakk> \\<Longrightarrow> (s,Call,n+1, t):Semn\""], ["", "abbreviation\n  SemN  :: \"[State, OBJ, nat, State] \\<Rightarrow> bool\"   (\" _ , _ \\<rightarrow>\\<^sub>_  _ \")\nwhere\n\"s,c \\<rightarrow>\\<^sub>n t == (s,c,n,t) : Semn\""], ["", "text\\<open>Often, the height index does not matter, so we define a notion\nhiding it.\\<close>"], ["", "definition\nSem :: \"[State, OBJ, State] \\<Rightarrow> bool\" (\"_ , _ \\<Down> _ \" 1000)\nwhere \"s,c \\<Down> t = (\\<exists> n. s,c \\<rightarrow>\\<^sub>n t)\""], ["", "inductive_cases Sem_eval_cases: \n \"s,Skip \\<rightarrow>\\<^sub>n t\"\n \"s,(Assign x e) \\<rightarrow>\\<^sub>n t\"\n \"s,(New x C) \\<rightarrow>\\<^sub>n t\"\n \"s,(Get x y F) \\<rightarrow>\\<^sub>n t\"\n \"s,(Put x F e) \\<rightarrow>\\<^sub>n t\"\n \"s,(Comp c1 c2) \\<rightarrow>\\<^sub>n t\"\n \"s,(While b c) \\<rightarrow>\\<^sub>n t\"\n \"s,(Iff b c1 c2) \\<rightarrow>\\<^sub>n t\"\n \"s, Call \\<rightarrow>\\<^sub>n t\""], ["", "(*<*)"], ["", "lemma Sem_no_zero_height_derivsAux: \"\\<forall> s t. ((s, c \\<rightarrow>\\<^sub>0 t) \\<longrightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.  s , c \\<rightarrow>\\<^sub>0  t  \\<longrightarrow> False", "by (induct_tac c, auto elim: Sem_eval_cases)"], ["", "(*>*)"], ["", "lemma Sem_no_zero_height_derivs: \"(s, c \\<rightarrow>\\<^sub>0 t) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  s , c \\<rightarrow>\\<^sub>0  t  \\<Longrightarrow> False", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1.  s , c \\<rightarrow>\\<^sub>0  t  \\<Longrightarrow> False", "by (insert Sem_no_zero_height_derivsAux, fastforce)"], ["", "(*>*)"], ["", "text\\<open>Determinism does not hold as allocation is nondeterministic.\\<close>"], ["", "text\\<open>End of theory OBJ\\<close>"], ["", "end"]]}