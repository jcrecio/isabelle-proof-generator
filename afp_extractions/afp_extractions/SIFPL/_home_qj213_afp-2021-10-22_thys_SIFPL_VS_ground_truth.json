{"file_name": "/home/qj213/afp-2021-10-22/thys/SIFPL/VS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SIFPL", "problem_names": ["lemma Prop1A:\"\\<Turnstile> c : (Sec \\<Phi>) \\<Longrightarrow> secure c\"", "lemma Prop1B:\n  \"secure c \\<Longrightarrow> \\<Turnstile> c : Sec (\\<lambda> (r, t) . \\<exists> s . (s , c \\<Down> r) \\<and> s \\<approx> t)\"", "lemma Prop1BB:\"secure c \\<Longrightarrow> \\<exists> \\<Phi> . \\<Turnstile> c : Sec \\<Phi>\"", "lemma Prop1:\n\"(secure c) = (\\<Turnstile> c : Sec (\\<lambda> (r, t) . \\<exists> s . (s , c \\<Down> r) \\<and> s \\<approx> t))\"", "lemma CAST[rule_format]:\n  \"G \\<rhd> c : twiddle \\<longrightarrow> G \\<rhd> c : Sec (\\<lambda> (s,t) . s \\<approx> t)\"", "lemma SKIP: \"G \\<rhd> Skip : Sec (\\<lambda> (s,t) . s \\<approx> t)\"", "lemma ASSIGN: \n  \"(\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalE e s = evalE e ss) \\<Longrightarrow>\n   G \\<rhd> (Assign x e) \n     : (Sec (\\<lambda> (s, t) . s \\<approx> (update t x (evalE e t))))\"", "lemma COMP: \n  \"\\<lbrakk> G \\<rhd> c1 : (Sec \\<Phi>); G \\<rhd> c2 : (Sec \\<Psi>)\\<rbrakk> \\<Longrightarrow>\n     G \\<rhd> (Comp c1 c2) : (Sec (\\<lambda> (s,t) . \\<exists> r . \\<Phi>(r, t) \\<and> \n                           (\\<forall> w . (r \\<approx> w \\<longrightarrow> \\<Psi>(s, w)))))\"", "lemma IFF:\n  \"\\<lbrakk> (\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalB b s = evalB b ss);\n     G \\<rhd> c1 : (Sec \\<Phi>); G \\<rhd> c2 : (Sec \\<Psi>)\\<rbrakk> \\<Longrightarrow>\n     G \\<rhd> (Iff b c1 c2) : Sec (\\<lambda> (s, t) . (evalB b t \\<longrightarrow> \\<Phi>(s,t)) \\<and> \n                                        ((\\<not> evalB b t) \\<longrightarrow> \\<Psi>(s,t)))\"", "lemma Fix2: \"\\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk> \\<Longrightarrow> FIX \\<phi> (s,t)\"", "lemma Fix1: \"\\<lbrakk>Monotone \\<phi>; FIX \\<phi> (s,t)\\<rbrakk> \\<Longrightarrow> \\<phi> (FIX \\<phi>) (s,t)\"", "lemma Fix_lemma:\"Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>\"", "lemma PhiWhileOp_Monotone: \"Monotone (PhiWhileOp b \\<Phi>)\"", "lemma WHILE:  \n  \"\\<lbrakk> (\\<forall> s t. s \\<approx> t \\<longrightarrow> evalB b s = evalB b t); G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk> \\<Longrightarrow>\n   G \\<rhd> (While b c) : (Sec (PhiWhile b \\<Phi>))\"", "lemma PhiWhileMonotone: \"Monotone (\\<lambda> \\<Phi> . PhiWhile b \\<Phi>)\"", "lemma varFIX: \"(b,\\<Phi>,s,t):var \\<Longrightarrow> PhiWhile b \\<Phi> (s,t)\"", "lemma FIXvar: \"PhiWhile b \\<Phi> (s,t) \\<Longrightarrow> (b,\\<Phi>,s,t):var\"", "lemma varFIXvar: \"(PhiWhile b \\<Phi> (s,t)) = ((b,\\<Phi>,s,t):var)\"", "lemma FIXvarFIX': \"(PhiWhile b \\<Phi>) = (\\<lambda> (s,t) . (b,\\<Phi>,s,t):var)\"", "lemma FIXvarFIX: \"(PhiWhile b) = (\\<lambda> \\<Phi> . (\\<lambda> (s,t) . (b,\\<Phi>,s,t):var))\"", "lemma WHILE_IND:\n  \"\\<lbrakk> (\\<forall> s t. s \\<approx> t \\<longrightarrow> evalB b s = evalB b t); G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk> \\<Longrightarrow>\n   G \\<rhd> (While b c) : (Sec (\\<lambda> (s,t) . (b,\\<Phi>,s,t):var))\"", "lemma varMonotoneAux[rule_format]:\n  \"(b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow> \n   (\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)) \\<longrightarrow> (b, \\<Psi>, s, t) \\<in> var\"", "lemma var_Monotone: \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t) .(b,\\<Phi>,s,t):var))\"", "lemma varMonotone_byFIX: \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t) .(b,\\<Phi>,s,t):var))\"", "lemma CALL: \n  \"\\<lbrakk> ({Sec(FIX \\<Phi>)} \\<union> G) \\<rhd> body : Sec(\\<Phi> (FIX \\<Phi>)); Monotone \\<Phi>\\<rbrakk> \\<Longrightarrow>\n   G \\<rhd> Call : Sec(FIX \\<Phi>)\"", "lemma HIGH_SKIP: \"G \\<rhd> Skip : twiddle\"", "lemma HIGH_ASSIGN:\n  \"CONTEXT x = high \\<Longrightarrow> G \\<rhd> (Assign x e) : twiddle\"", "lemma HIGH_COMP: \n  \"\\<lbrakk> G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> (Comp c1 c2): twiddle\"", "lemma HIGH_IFF:\n  \"\\<lbrakk> G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle \\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> (Iff b c1 c2) : twiddle\"", "lemma HIGH_WHILE:\n  \"\\<lbrakk> G \\<rhd> c  : twiddle\\<rbrakk> \\<Longrightarrow> G \\<rhd> (While b c)  : twiddle\"", "lemma HIGH_CALL:\n  \"({twiddle} \\<union> G) \\<rhd> body : twiddle \\<Longrightarrow> G \\<rhd> Call : twiddle\"", "lemma ExprSound: \"(e,tp):VS_expr \\<Longrightarrow> SemExpr e tp\"", "lemma BExprSound: \"(e,tp):VS_Bexpr \\<Longrightarrow> SemBExpr e tp\"", "theorem VS_com_VDM[rule_format]:\n\"(t,c):VS_com \\<Longrightarrow> (t=high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n                  (t=low \\<longrightarrow> (\\<exists> A . G \\<rhd> c : Sec A))\"", "theorem VS_SOUND: \"(t,c):VS_com \\<Longrightarrow> SemCom t c\"", "lemma DerivProp_Aux: \"(X,c,A):Deriv \\<Longrightarrow> DProp A\"", "lemma DerivMono: \n \"(X,c,A):Deriv \\<Longrightarrow> \\<exists> \\<Phi> . A =  Sec (\\<Phi> (FIX \\<Phi>)) \\<and> Monotone \\<Phi>\"", "lemma Deriv_derivable: \"(G,c,A):Deriv \\<Longrightarrow> G \\<rhd> c: A\""], "translations": [["", "lemma Prop1A:\"\\<Turnstile> c : (Sec \\<Phi>) \\<Longrightarrow> secure c\""], ["proof (prove)\ngoal (1 subgoal):\n 1.  \\<Turnstile> c : Sec \\<Phi>  \\<Longrightarrow> secure c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1.  \\<Turnstile> c : Sec \\<Phi>  \\<Longrightarrow> secure c", "by (simp add: VDM_valid_def secure_def Sec_def)"], ["", "(*>*)"], ["", "lemma Prop1B:\n  \"secure c \\<Longrightarrow> \\<Turnstile> c : Sec (\\<lambda> (r, t) . \\<exists> s . (s , c \\<Down> r) \\<and> s \\<approx> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n     \\<Turnstile> c : Sec (\\<lambda>(r, t).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>  s \\<approx> t )", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n     \\<Turnstile> c : Sec (\\<lambda>(r, t).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>  s \\<approx> t )", "apply (simp add: VDM_valid_def Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n    \\<forall>s t.\n       s , c \\<Down> t  \\<longrightarrow>\n       (\\<forall>r.\n            s \\<approx> r  \\<longrightarrow>\n           (\\<exists>s. s , c \\<Down> t  \\<and>  s \\<approx> r )) \\<and>\n       (\\<forall>r.\n           (\\<exists>sa.\n               sa , c \\<Down> r  \\<and>  sa \\<approx> s ) \\<longrightarrow>\n            r \\<approx> t )", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>secure c; s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r.\n                              s \\<approx> r  \\<longrightarrow>\n                             (\\<exists>s.\n                                 s , c \\<Down> t  \\<and>\n                                  s \\<approx> r )) \\<and>\n                         (\\<forall>r.\n                             (\\<exists>sa.\n                                 sa , c \\<Down> r  \\<and>\n                                  sa \\<approx> s ) \\<longrightarrow>\n                              r \\<approx> t )", "apply (unfold secure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r.\n                              s \\<approx> r  \\<longrightarrow>\n                             (\\<exists>s.\n                                 s , c \\<Down> t  \\<and>\n                                  s \\<approx> r )) \\<and>\n                         (\\<forall>r.\n                             (\\<exists>sa.\n                                 sa , c \\<Down> r  \\<and>\n                                  sa \\<approx> s ) \\<longrightarrow>\n                              r \\<approx> t )", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            (\\<exists>s.\n                                s , c \\<Down> t  \\<and>  s \\<approx> r )\n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>sa.\n                                sa , c \\<Down> r  \\<and>\n                                 sa \\<approx> s ) \\<longrightarrow>\n                             r \\<approx> t", "apply (rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t ;  s \\<approx> r \\<rbrakk>\n       \\<Longrightarrow> \\<exists>s. s , c \\<Down> t  \\<and>  s \\<approx> r \n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>sa.\n                                sa , c \\<Down> r  \\<and>\n                                 sa \\<approx> s ) \\<longrightarrow>\n                             r \\<approx> t", "apply (rule_tac x=s in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t ;  s \\<approx> r \\<rbrakk>\n       \\<Longrightarrow> s , c \\<Down> t  \\<and>  s \\<approx> r \n 2. \\<And>s t.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>sa.\n                                sa , c \\<Down> r  \\<and>\n                                 sa \\<approx> s ) \\<longrightarrow>\n                             r \\<approx> t", "apply(rule, assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>sa.\n                                sa , c \\<Down> r  \\<and>\n                                 sa \\<approx> s ) \\<longrightarrow>\n                             r \\<approx> t", "apply (rule, rule, erule exE, erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r sa.\n       \\<lbrakk>\\<forall>s t ss tt.\n                    s \\<approx> t  \\<longrightarrow>\n                   s , c \\<Down> ss  \\<longrightarrow>\n                   t , c \\<Down> tt  \\<longrightarrow>  ss \\<approx> tt ;\n        s , c \\<Down> t ; sa , c \\<Down> r ;  sa \\<approx> s \\<rbrakk>\n       \\<Longrightarrow>  r \\<approx> t", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma Prop1BB:\"secure c \\<Longrightarrow> \\<exists> \\<Phi> . \\<Turnstile> c : Sec \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n    \\<exists>\\<Phi>.  \\<Turnstile> c : Sec \\<Phi>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c \\<Longrightarrow>\n    \\<exists>\\<Phi>.  \\<Turnstile> c : Sec \\<Phi>", "by (drule Prop1B, fast)"], ["", "(*>*)"], ["", "lemma Prop1:\n\"(secure c) = (\\<Turnstile> c : Sec (\\<lambda> (r, t) . \\<exists> s . (s , c \\<Down> r) \\<and> s \\<approx> t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c =\n     \\<Turnstile> c : Sec (\\<lambda>(r, t).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>  s \\<approx> t )", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure c =\n     \\<Turnstile> c : Sec (\\<lambda>(r, t).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>  s \\<approx> t )", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. secure c \\<Longrightarrow>\n     \\<Turnstile> c : Sec (\\<lambda>(r, t).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>  s \\<approx> t ) \n 2.  \\<Turnstile> c : Sec (\\<lambda>(r, t).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>\n                                  s \\<approx> t )  \\<Longrightarrow>\n    secure c", "apply (erule Prop1B)"], ["proof (prove)\ngoal (1 subgoal):\n 1.  \\<Turnstile> c : Sec (\\<lambda>(r, t).\n                              \\<exists>s.\n                                 s , c \\<Down> r  \\<and>\n                                  s \\<approx> t )  \\<Longrightarrow>\n    secure c", "apply (erule Prop1A)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection\\<open>Derivation of the LOW rules\\<close>"], ["", "text\\<open>We now derive the interpretation of the LOW rules of Volpano et\nal's paper according to the constructions given in the paper. (The\nrules themselves are given later, since they are not yet needed).\\<close>"], ["", "lemma CAST[rule_format]:\n  \"G \\<rhd> c : twiddle \\<longrightarrow> G \\<rhd> c : Sec (\\<lambda> (s,t) . s \\<approx> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : twiddle \\<longrightarrow>\n    G \\<rhd> c : Sec (\\<lambda>(s, t).  s \\<approx> t )", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : twiddle \\<longrightarrow>\n    G \\<rhd> c : Sec (\\<lambda>(s, t).  s \\<approx> t )", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow>\n    G \\<rhd> c : Sec (\\<lambda>(s, t).  s \\<approx> t )", "apply (erule VDMConseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n        s \\<approx> t  \\<longrightarrow>\n       Sec (\\<lambda>(s, t).  s \\<approx> t ) s t", "apply (simp add: twiddle_def Sec_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma SKIP: \"G \\<rhd> Skip : Sec (\\<lambda> (s,t) . s \\<approx> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : Sec (\\<lambda>(s, t).  s \\<approx> t )", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : Sec (\\<lambda>(s, t).  s \\<approx> t )", "apply (rule VDMConseq, rule VDMSkip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       t = s \\<longrightarrow> Sec (\\<lambda>(s, t).  s \\<approx> t ) s t", "apply (simp add: Sec_def twiddle_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma ASSIGN: \n  \"(\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalE e s = evalE e ss) \\<Longrightarrow>\n   G \\<rhd> (Assign x e) \n     : (Sec (\\<lambda> (s, t) . s \\<approx> (update t x (evalE e t))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s ss.\n        s \\<approx> ss  \\<longrightarrow>\n       evalE e s = evalE e ss \\<Longrightarrow>\n    G \\<rhd> Assign x\n              e : Sec (\\<lambda>(s, t).\n                           s \\<approx> update t x (evalE e t) )", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s ss.\n        s \\<approx> ss  \\<longrightarrow>\n       evalE e s = evalE e ss \\<Longrightarrow>\n    G \\<rhd> Assign x\n              e : Sec (\\<lambda>(s, t).\n                           s \\<approx> update t x (evalE e t) )", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>s ss.\n        s \\<approx> ss  \\<longrightarrow>\n       evalE e s = evalE e ss \\<Longrightarrow>\n    G \\<rhd> Assign x e : ?A\n 2. \\<forall>s ss.\n        s \\<approx> ss  \\<longrightarrow>\n       evalE e s = evalE e ss \\<Longrightarrow>\n    \\<forall>s t.\n       ?A s t \\<longrightarrow>\n       Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) s t", "apply(rule VDMAssign)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s ss.\n        s \\<approx> ss  \\<longrightarrow>\n       evalE e s = evalE e ss \\<Longrightarrow>\n    \\<forall>s t.\n       t = update s x (evalE e s) \\<longrightarrow>\n       Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) s t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) s\n        (update s x (evalE e s))", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<forall>r.\n           s \\<approx> r  \\<longrightarrow>\n           update s x (evalE e r) \\<approx> update r x (evalE e r)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalE e s = evalE e ss;\n         s \\<approx> r \\<rbrakk>\n       \\<Longrightarrow>  update s x\n                           (evalE e r) \\<approx> update r x (evalE e r)", "apply (erule_tac x=s in allE, erule_tac x=r in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r.\n       \\<lbrakk> s \\<approx> r ; evalE e s = evalE e r\\<rbrakk>\n       \\<Longrightarrow>  update s x\n                           (evalE e r) \\<approx> update r x (evalE e r)", "apply (simp add: twiddle_def update_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma COMP: \n  \"\\<lbrakk> G \\<rhd> c1 : (Sec \\<Phi>); G \\<rhd> c2 : (Sec \\<Psi>)\\<rbrakk> \\<Longrightarrow>\n     G \\<rhd> (Comp c1 c2) : (Sec (\\<lambda> (s,t) . \\<exists> r . \\<Phi>(r, t) \\<and> \n                           (\\<forall> w . (r \\<approx> w \\<longrightarrow> \\<Psi>(s, w)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c1\n                                c2 : Sec\n(\\<lambda>(s, t).\n    \\<exists>r.\n       \\<Phi> (r, t) \\<and>\n       (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c1\n                                c2 : Sec\n(\\<lambda>(s, t).\n    \\<exists>r.\n       \\<Phi> (r, t) \\<and>\n       (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c1 c2 : ?A\n 2. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t).\n                                 \\<exists>r.\n                                    \\<Phi> (r, t) \\<and>\n                                    (\\<forall>w.\n   r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n                          s t", "apply (erule VDMComp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. G \\<rhd> c2 : Sec \\<Psi> \\<Longrightarrow> G \\<rhd> c2 : ?A2.3\n 2. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             Sec \\<Phi> s r \\<and>\n                             ?A2.3 r t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t).\n                                 \\<exists>r.\n                                    \\<Phi> (r, t) \\<and>\n                                    (\\<forall>w.\n   r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n                          s t", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             Sec \\<Phi> s r \\<and>\n                             Sec \\<Psi> r t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t).\n                                 \\<exists>r.\n                                    \\<Phi> (r, t) \\<and>\n                                    (\\<forall>w.\n   r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n                          s t", "apply (simp add: Sec_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra.\n           \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r.\n                              s \\<approx> r  \\<longrightarrow>\n                             (\\<exists>ra.\n                                 \\<Phi> (ra, r) \\<and>\n                                 (\\<forall>w.\n                                      ra \\<approx> w  \\<longrightarrow>\n                                     \\<Psi> (t, w)))) \\<and>\n                         (\\<forall>r.\n                             (\\<exists>ra.\n                                 \\<Phi> (ra, s) \\<and>\n                                 (\\<forall>w.\n                                      ra \\<approx> w  \\<longrightarrow>\n                                     \\<Psi> (r, w))) \\<longrightarrow>\n                              r \\<approx> t )", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra.\n           \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            (\\<exists>ra.\n                                \\<Phi> (ra, r) \\<and>\n                                (\\<forall>w.\n                                     ra \\<approx> w  \\<longrightarrow>\n                                    \\<Psi> (t, w)))\n 2. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra.\n           \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>ra.\n                                \\<Phi> (ra, s) \\<and>\n                                (\\<forall>w.\n                                     ra \\<approx> w  \\<longrightarrow>\n                                    \\<Psi> (r, w))) \\<longrightarrow>\n                             r \\<approx> t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r ra.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra. \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t ;\n         s \\<approx> ra \\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Phi> (r, ra) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                \\<Psi> (t, w))\n 2. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra.\n           \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>ra.\n                                \\<Phi> (ra, s) \\<and>\n                                (\\<forall>w.\n                                     ra \\<approx> w  \\<longrightarrow>\n                                    \\<Psi> (r, w))) \\<longrightarrow>\n                             r \\<approx> t", "apply (erule_tac x=ra in allE, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r ra.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra. \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t ;\n         s \\<approx> ra ; \\<Phi> (r, ra)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Phi> (r, ra) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                \\<Psi> (t, w))\n 2. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra.\n           \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>ra.\n                                \\<Phi> (ra, s) \\<and>\n                                (\\<forall>w.\n                                     ra \\<approx> w  \\<longrightarrow>\n                                    \\<Psi> (r, w))) \\<longrightarrow>\n                             r \\<approx> t", "apply (rule_tac x=r in exI, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.  r \\<approx> ra  \\<longrightarrow> \\<Psi> (t, ra);\n        \\<forall>ra.\n           \\<Psi> (ra, r) \\<longrightarrow>  ra \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (\\<exists>ra.\n                                \\<Phi> (ra, s) \\<and>\n                                (\\<forall>w.\n                                     ra \\<approx> w  \\<longrightarrow>\n                                    \\<Psi> (r, w))) \\<longrightarrow>\n                             r \\<approx> t", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma IFF:\n  \"\\<lbrakk> (\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalB b s = evalB b ss);\n     G \\<rhd> c1 : (Sec \\<Phi>); G \\<rhd> c2 : (Sec \\<Psi>)\\<rbrakk> \\<Longrightarrow>\n     G \\<rhd> (Iff b c1 c2) : Sec (\\<lambda> (s, t) . (evalB b t \\<longrightarrow> \\<Phi>(s,t)) \\<and> \n                                        ((\\<not> evalB b t) \\<longrightarrow> \\<Psi>(s,t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c1\n                                c2 : Sec\n(\\<lambda>(s, t).\n    (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n    (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c1\n                                c2 : Sec\n(\\<lambda>(s, t).\n    (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n    (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : ?A\n 2. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  \\<Phi> (s, t)) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                  \\<Psi> (s, t)))\n                          s t", "apply(rule VDMIff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c1 : ?A3\n 2. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c2 : ?B3\n 3. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b s \\<longrightarrow> ?A3 s t) \\<and>\n                         (\\<not> evalB b s \\<longrightarrow>\n                          ?B3 s t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  \\<Phi> (s, t)) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                  \\<Psi> (s, t)))\n                          s t", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s ss.\n                 s \\<approx> ss  \\<longrightarrow> evalB b s = evalB b ss;\n     G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b s \\<longrightarrow> Sec \\<Phi> s t) \\<and>\n                         (\\<not> evalB b s \\<longrightarrow>\n                          Sec \\<Psi> s t) \\<longrightarrow>\n                         Sec (\\<lambda>(s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  \\<Phi> (s, t)) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                  \\<Psi> (s, t)))\n                          s t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        evalB b s \\<longrightarrow> Sec \\<Phi> s t;\n        \\<not> evalB b s \\<longrightarrow> Sec \\<Psi> s t\\<rbrakk>\n       \\<Longrightarrow> Sec (\\<lambda>(s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  \\<Phi> (s, t)) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                  \\<Psi> (s, t)))\n                          s t", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Phi> (t, r)) \\<and>\n        (\\<forall>r. \\<Phi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        \\<not> evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Psi> (t, r)) \\<and>\n        (\\<forall>r.\n            \\<Psi> (r, s) \\<longrightarrow>  r \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            (evalB b s \\<longrightarrow>\n                             \\<Phi> (r, s)) \\<and>\n                            (\\<not> evalB b s \\<longrightarrow>\n                             \\<Psi> (r, s)) \\<longrightarrow>\n                             r \\<approx> t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Phi> (t, r)) \\<and>\n        (\\<forall>r. \\<Phi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        \\<not> evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Psi> (t, r)) \\<and>\n        (\\<forall>r. \\<Psi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        evalB b s \\<longrightarrow> \\<Phi> (r, s);\n        \\<not> evalB b s \\<longrightarrow> \\<Psi> (r, s)\\<rbrakk>\n       \\<Longrightarrow>  r \\<approx> t", "apply (case_tac \"evalB b s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Phi> (t, r)) \\<and>\n        (\\<forall>r. \\<Phi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        \\<not> evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Psi> (t, r)) \\<and>\n        (\\<forall>r. \\<Psi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        evalB b s \\<longrightarrow> \\<Phi> (r, s);\n        \\<not> evalB b s \\<longrightarrow> \\<Psi> (r, s); evalB b s\\<rbrakk>\n       \\<Longrightarrow>  r \\<approx> t \n 2. \\<And>s t r.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Phi> (t, r)) \\<and>\n        (\\<forall>r. \\<Phi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        \\<not> evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Psi> (t, r)) \\<and>\n        (\\<forall>r. \\<Psi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        evalB b s \\<longrightarrow> \\<Phi> (r, s);\n        \\<not> evalB b s \\<longrightarrow> \\<Psi> (r, s);\n        \\<not> evalB b s\\<rbrakk>\n       \\<Longrightarrow>  r \\<approx> t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t r.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        G \\<rhd> c1 : Sec \\<Phi>; G \\<rhd> c2 : Sec \\<Psi>;\n        evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Phi> (t, r)) \\<and>\n        (\\<forall>r. \\<Phi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        \\<not> evalB b s \\<longrightarrow>\n        (\\<forall>r.  s \\<approx> r  \\<longrightarrow> \\<Psi> (t, r)) \\<and>\n        (\\<forall>r. \\<Psi> (r, s) \\<longrightarrow>  r \\<approx> t );\n        evalB b s \\<longrightarrow> \\<Phi> (r, s);\n        \\<not> evalB b s \\<longrightarrow> \\<Psi> (r, s);\n        \\<not> evalB b s\\<rbrakk>\n       \\<Longrightarrow>  r \\<approx> t", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>We introduce an explicit fixed point construction over the type\n$TT$ of the invariants $\\Phi$.\\<close>"], ["", "type_synonym TT = \"(State \\<times> State) \\<Rightarrow> bool\""], ["", "text\\<open>We deliberately introduce a new type here since the agreement\nwith \\<open>VDMAssn\\<close> (modulo currying) is purely coincidental. In\nparticular, in the generalisation for objects in Section\n\\ref{sec:Objects} the type of invariants will differ from the\ntype of program logic assertions.\\<close>"], ["", "definition FIX::\"(TT \\<Rightarrow> TT) \\<Rightarrow> TT\"\nwhere \"FIX \\<phi> = (\\<lambda> (s,t). \\<forall> \\<Phi>. (\\<forall> ss tt . \\<phi> \\<Phi> (ss,tt) \\<longrightarrow> \\<Phi> (ss,tt)) \n         \\<longrightarrow> \\<Phi> (s,t))\""], ["", "definition Monotone::\"(TT \\<Rightarrow> TT) \\<Rightarrow> bool\"\nwhere \"Monotone \\<phi> = (\\<forall> \\<Phi> \\<Psi> . (\\<forall> s t . \\<Phi>(s,t) \\<longrightarrow> \\<Psi>(s,t)) \\<longrightarrow> \n                        (\\<forall> s t . \\<phi> \\<Phi> (s,t) \\<longrightarrow> \\<phi> \\<Psi> (s,t)))\""], ["", "(*<*)"], ["", "lemma Fix2: \"\\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk> \\<Longrightarrow> FIX \\<phi> (s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk>\n    \\<Longrightarrow> FIX \\<phi> (s, t)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<phi>\n      (\\<lambda>(s, t).\n          \\<forall>\\<Phi>.\n             (\\<forall>ss tt.\n                 \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                 \\<Phi> (ss, tt)) \\<longrightarrow>\n             \\<Phi> (s, t))\n      (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<Phi>.\n                         (\\<forall>ss tt.\n                             \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                             \\<Phi> (ss, tt)) \\<longrightarrow>\n                         \\<Phi> (s, t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (s, t)", "apply (subgoal_tac \"\\<phi> \\<Phi> (s,t)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (subgoal_tac \"\\<forall> r u . FIX \\<phi> (r,u) \\<longrightarrow> \\<Phi>(r,u)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r u.\n                            FIX \\<phi> (r, u) \\<longrightarrow>\n                            \\<Phi> (r, u)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r u.\n                            FIX \\<phi> (r, u) \\<longrightarrow>\n                            \\<Phi> (r, u)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt.\n                            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                            \\<Phi> (ss, tt)) \\<longrightarrow>\n                        \\<Phi> (s, t))\n                 (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r u.\n                            FIX \\<phi> (r, u) \\<longrightarrow>\n                            \\<Phi> (r, u)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt.\n                            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                            \\<Phi> (ss, tt)) \\<longrightarrow>\n                        \\<Phi> (s, t))\n                 (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r u.\n                            (\\<forall>\\<Phi>.\n                                (\\<forall>ss tt.\n                                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                                \\<Phi> (r, u)) \\<longrightarrow>\n                            \\<Phi> (r, u)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi> r u.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt.\n                            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                            \\<Phi> (ss, tt)) \\<longrightarrow>\n                        \\<Phi> (s, t))\n                 (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>\\<Phi>.\n           (\\<forall>ss tt.\n               \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n               \\<Phi> (ss, tt)) \\<longrightarrow>\n           \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (r, u)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (erule_tac x=\\<Phi> in allE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>Monotone \\<phi>;\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (unfold Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<forall>\\<Phi> \\<Psi>.\n                   (\\<forall>s t.\n                       \\<Phi> (s, t) \\<longrightarrow>\n                       \\<Psi> (s, t)) \\<longrightarrow>\n                   (\\<forall>s t.\n                       \\<phi> \\<Phi> (s, t) \\<longrightarrow>\n                       \\<phi> \\<Psi> (s, t));\n        \\<phi>\n         (\\<lambda>(s, t).\n             \\<forall>\\<Phi>.\n                (\\<forall>ss tt.\n                    \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                    \\<Phi> (ss, tt)) \\<longrightarrow>\n                \\<Phi> (s, t))\n         (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (erule_tac x=\"FIX \\<phi>\" in allE, erule_tac x=\"\\<Phi>\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt.\n                            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                            \\<Phi> (ss, tt)) \\<longrightarrow>\n                        \\<Phi> (s, t))\n                 (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u. FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u);\n        (\\<forall>s t.\n            FIX \\<phi> (s, t) \\<longrightarrow>\n            \\<Phi> (s, t)) \\<longrightarrow>\n        (\\<forall>s t.\n            \\<phi> (FIX \\<phi>) (s, t) \\<longrightarrow>\n            \\<phi> \\<Phi> (s, t))\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt.\n                            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                            \\<Phi> (ss, tt)) \\<longrightarrow>\n                        \\<Phi> (s, t))\n                 (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u.\n           FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s t.\n                            FIX \\<phi> (s, t) \\<longrightarrow>\n                            \\<Phi> (s, t)\n 2. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt.\n                            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                            \\<Phi> (ss, tt)) \\<longrightarrow>\n                        \\<Phi> (s, t))\n                 (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u. FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u);\n        \\<forall>s t.\n           \\<phi> (FIX \\<phi>) (s, t) \\<longrightarrow>\n           \\<phi> \\<Phi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>.\n       \\<lbrakk>\\<phi>\n                 (\\<lambda>(s, t).\n                     \\<forall>\\<Phi>.\n                        (\\<forall>ss tt.\n                            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                            \\<Phi> (ss, tt)) \\<longrightarrow>\n                        \\<Phi> (s, t))\n                 (s, t);\n        \\<forall>ss tt.\n           \\<phi> \\<Phi> (ss, tt) \\<longrightarrow> \\<Phi> (ss, tt);\n        \\<forall>r u. FIX \\<phi> (r, u) \\<longrightarrow> \\<Phi> (r, u);\n        \\<forall>s t.\n           \\<phi> (FIX \\<phi>) (s, t) \\<longrightarrow>\n           \\<phi> \\<Phi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> \\<Phi> (s, t)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Fix1: \"\\<lbrakk>Monotone \\<phi>; FIX \\<phi> (s,t)\\<rbrakk> \\<Longrightarrow> \\<phi> (FIX \\<phi>) (s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>; FIX \\<phi> (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<phi> (FIX \\<phi>) (s, t)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>\\<Phi>.\n        (\\<forall>ss tt.\n            \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n            \\<Phi> (ss, tt)) \\<longrightarrow>\n        \\<Phi> (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>ss tt.\n                                  \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                                  \\<Phi> (ss, tt)) \\<longrightarrow>\n                              \\<Phi> (s, t))\n                       (s, t)", "apply (erule_tac x=\"\\<phi>(FIX \\<phi>)\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     (\\<forall>ss tt.\n         \\<phi> (\\<phi> (FIX \\<phi>)) (ss, tt) \\<longrightarrow>\n         \\<phi> (FIX \\<phi>) (ss, tt)) \\<longrightarrow>\n     \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>ss tt.\n                                  \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                                  \\<Phi> (ss, tt)) \\<longrightarrow>\n                              \\<Phi> (s, t))\n                       (s, t)", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>ss tt.\n       \\<phi> (\\<phi> (FIX \\<phi>)) (ss, tt) \\<longrightarrow>\n       \\<phi> (FIX \\<phi>) (ss, tt)\n 2. \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>ss tt.\n                                  \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                                  \\<Phi> (ss, tt)) \\<longrightarrow>\n                              \\<Phi> (s, t))\n                       (s, t)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<phi>\n                       (\\<lambda>(s, t).\n                           \\<forall>\\<Phi>.\n                              (\\<forall>ss tt.\n                                  \\<phi> \\<Phi> (ss, tt) \\<longrightarrow>\n                                  \\<Phi> (ss, tt)) \\<longrightarrow>\n                              \\<Phi> (s, t))\n                       (s, t)\n 2. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>ss tt.\n       \\<phi> (\\<phi> (FIX \\<phi>)) (ss, tt) \\<longrightarrow>\n       \\<phi> (FIX \\<phi>) (ss, tt)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>ss tt.\n       \\<phi> (\\<phi> (FIX \\<phi>)) (ss, tt) \\<longrightarrow>\n       \\<phi> (FIX \\<phi>) (ss, tt)", "apply (subgoal_tac \"\\<forall> r u .\\<phi>(FIX \\<phi>) (r,u) \\<longrightarrow> (FIX \\<phi>) (r,u)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u.\n        \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n        FIX \\<phi> (r, u)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)\n 2. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>r u.\n       \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow> FIX \\<phi> (r, u)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotone \\<phi> \\<Longrightarrow>\n    \\<forall>r u.\n       \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow> FIX \\<phi> (r, u)\n 2. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u.\n        \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n        FIX \\<phi> (r, u)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r u.\n       \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (r, u)\\<rbrakk>\n       \\<Longrightarrow> FIX \\<phi> (r, u)\n 2. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u.\n        \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n        FIX \\<phi> (r, u)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)", "apply (erule Fix2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r u.\n       \\<phi> (FIX \\<phi>) (r, u) \\<Longrightarrow>\n       \\<phi> (FIX \\<phi>) (r, u)\n 2. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u.\n        \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n        FIX \\<phi> (r, u)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Monotone \\<phi>;\n     \\<forall>r u.\n        \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n        FIX \\<phi> (r, u)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)", "apply (unfold Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<Phi> \\<Psi>.\n                (\\<forall>s t.\n                    \\<Phi> (s, t) \\<longrightarrow>\n                    \\<Psi> (s, t)) \\<longrightarrow>\n                (\\<forall>s t.\n                    \\<phi> \\<Phi> (s, t) \\<longrightarrow>\n                    \\<phi> \\<Psi> (s, t));\n     \\<forall>r u.\n        \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n        FIX \\<phi> (r, u)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)", "apply (erule_tac x=\"\\<phi>(FIX \\<phi>)\" in allE, erule_tac x=\"(FIX \\<phi>)\" in allE, erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>r u.\n       \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n       FIX \\<phi> (r, u) \\<Longrightarrow>\n    \\<forall>s t.\n       \\<phi> (FIX \\<phi>) (s, t) \\<longrightarrow> FIX \\<phi> (s, t)\n 2. \\<lbrakk>\\<forall>r u.\n                \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n                FIX \\<phi> (r, u);\n     \\<forall>s t.\n        \\<phi> (\\<phi> (FIX \\<phi>)) (s, t) \\<longrightarrow>\n        \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r u.\n                \\<phi> (FIX \\<phi>) (r, u) \\<longrightarrow>\n                FIX \\<phi> (r, u);\n     \\<forall>s t.\n        \\<phi> (\\<phi> (FIX \\<phi>)) (s, t) \\<longrightarrow>\n        \\<phi> (FIX \\<phi>) (s, t)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ss tt.\n                         \\<phi> (\\<phi> (FIX \\<phi>))\n                          (ss, tt) \\<longrightarrow>\n                         \\<phi> (FIX \\<phi>) (ss, tt)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>For monotone invariant transformers $\\varphi$, the construction indeed\nyields a fixed point.\\<close>"], ["", "lemma Fix_lemma:\"Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone \\<phi> \\<Longrightarrow> \\<phi> (FIX \\<phi>) = FIX \\<phi>", "apply (rule ext, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) x\\<rbrakk>\n       \\<Longrightarrow> FIX \\<phi> x\n 2. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Monotone \\<phi>; \\<phi> (FIX \\<phi>) (a, b)\\<rbrakk>\n       \\<Longrightarrow> FIX \\<phi> (a, b)\n 2. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply (erule Fix2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<phi> (FIX \\<phi>) (a, b) \\<Longrightarrow>\n       \\<phi> (FIX \\<phi>) (a, b)\n 2. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> x\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Monotone \\<phi>; FIX \\<phi> (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (FIX \\<phi>) (a, b)", "apply (erule Fix1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. FIX \\<phi> (a, b) \\<Longrightarrow> FIX \\<phi> (a, b)", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>In order to derive the while rule we define the following\ntransfomer.\\<close>"], ["", "definition PhiWhileOp::\"BExpr \\<Rightarrow> TT \\<Rightarrow> TT \\<Rightarrow> TT\"\nwhere \"PhiWhileOp b \\<Phi> =\n     (\\<lambda> \\<Psi> . (\\<lambda>(s, t).\n             (evalB b t \\<longrightarrow> (\\<exists>r. \\<Phi> (r, t) \\<and> \n                                 (\\<forall>w. r \\<approx> w \\<longrightarrow> \\<Psi> (s, w)))) \\<and> \n             (\\<not> evalB b t \\<longrightarrow> s \\<approx> t)))\""], ["", "text\\<open>Since this operator is monotone, \\ldots\\<close>"], ["", "lemma PhiWhileOp_Monotone: \"Monotone (PhiWhileOp b \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhileOp b \\<Phi>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhileOp b \\<Phi>)", "apply (simp add: PhiWhileOp_def Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>.\n       (\\<forall>s t.\n           \\<Phi>' (s, t) \\<longrightarrow> \\<Psi> (s, t)) \\<longrightarrow>\n       (\\<forall>s t.\n           (evalB b t \\<longrightarrow>\n            (\\<exists>r.\n                \\<Phi> (r, t) \\<and>\n                (\\<forall>w.\n                     r \\<approx> w  \\<longrightarrow>\n                    \\<Phi>' (s, w)))) \\<and>\n           (\\<not> evalB b t \\<longrightarrow>\n             s \\<approx> t ) \\<longrightarrow>\n           evalB b t \\<longrightarrow>\n           (\\<exists>r.\n               \\<Phi> (r, t) \\<and>\n               (\\<forall>w.\n                    r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi>' \\<Psi> s t r.\n       \\<lbrakk>\\<forall>s t.\n                   \\<Phi>' (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow> \\<Phi>' (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Phi> (r, t) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                \\<Psi> (s, w))", "apply (rule_tac x=r in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>we may define its fixed point,\\<close>"], ["", "definition PhiWhile::\"BExpr \\<Rightarrow> TT \\<Rightarrow> TT\"\nwhere \"PhiWhile b \\<Phi> = FIX (PhiWhileOp b \\<Phi>)\""], ["", "text\\<open>which we can use to derive the following rule.\\<close>"], ["", "lemma WHILE:  \n  \"\\<lbrakk> (\\<forall> s t. s \\<approx> t \\<longrightarrow> evalB b s = evalB b t); G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk> \\<Longrightarrow>\n   G \\<rhd> (While b c) : (Sec (PhiWhile b \\<Phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : ?A\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A s t \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t", "apply (rule VDMWhile)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         ?A3 r t \\<longrightarrow> ?A3 s t\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t", "prefer 4"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         ?A3 r t \\<longrightarrow> ?A3 s t", "apply (subgoal_tac \"\\<forall>s t. (Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>))) s t \\<and> \\<not> evalB b t \\<longrightarrow> Sec (PhiWhile b \\<Phi>) s t\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>;\n     \\<forall>s t.\n        Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t \\<and>\n        \\<not> evalB b t \\<longrightarrow>\n        Sec (PhiWhile b \\<Phi>) s t\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s\n                          t \\<and>\n                         \\<not> evalB b t \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 5. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         ?A3 r t \\<longrightarrow> ?A3 s t", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s\n                          t \\<and>\n                         \\<not> evalB b t \\<longrightarrow>\n                         Sec (PhiWhile b \\<Phi>) s t\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b s \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t;\n        \\<not> evalB b t\\<rbrakk>\n       \\<Longrightarrow> Sec (PhiWhile b \\<Phi>) s t\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b s \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)= PhiWhile b \\<Phi>\", clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t;\n        \\<not> evalB b t\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) =\n                         PhiWhile b \\<Phi>\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b s \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))) s t;\n        \\<not> evalB b t\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b s \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>;\n        Sec (PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))) s t;\n        \\<not> evalB b t\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b s \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 4. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : ?B3\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b s \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         ?B3 s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         \\<not> evalB b s \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b s\\<rbrakk>\n       \\<Longrightarrow> Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s s\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b s\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r.\n                              s \\<approx> r  \\<longrightarrow>\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              (s, r)) \\<and>\n                         (\\<forall>r.\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              (r, s) \\<longrightarrow>\n                              r \\<approx> s )\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (rule, clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b r;  s \\<approx> r \\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (s, r)\n 2. \\<And>s.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             (r, s) \\<longrightarrow>\n                             r \\<approx> s \n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             (r, s) \\<longrightarrow>\n                             r \\<approx> s \n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; \\<not> evalB b s;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (r, s)\\<rbrakk>\n       \\<Longrightarrow>  r \\<approx> s \n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s r t.\n                         evalB b s \\<longrightarrow>\n                         Sec \\<Phi> s r \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r\n                          t \\<longrightarrow>\n                         Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s; Sec \\<Phi> s r;\n        Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) r t\\<rbrakk>\n       \\<Longrightarrow> Sec (PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)) s t", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>r.\n                              s \\<approx> r  \\<longrightarrow>\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              (t, r)) \\<and>\n                         (\\<forall>r.\n                             PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                              (r, s) \\<longrightarrow>\n                              r \\<approx> t )", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)\n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             (r, s) \\<longrightarrow>\n                             r \\<approx> t", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                             (r, s) \\<longrightarrow>\n                             r \\<approx> t \n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, s)\\<rbrakk>\n       \\<Longrightarrow>  ra \\<approx> t \n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (subgoal_tac \"\\<exists>r. \\<Phi> (r, s) \\<and> (\\<forall>w. r \\<approx> w \\<longrightarrow> (PhiWhile b \\<Phi>) (ra, w))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, s);\n        \\<exists>r.\n           \\<Phi> (r, s) \\<and>\n           (\\<forall>w.\n                r \\<approx> w  \\<longrightarrow>\n               PhiWhile b \\<Phi> (ra, w))\\<rbrakk>\n       \\<Longrightarrow>  ra \\<approx> t \n 2. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Phi> (r, s) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                PhiWhile b \\<Phi> (ra, w))\n 3. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Phi> (r, s) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                PhiWhile b \\<Phi> (ra, w))\n 2. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, s);\n        \\<exists>r.\n           \\<Phi> (r, s) \\<and>\n           (\\<forall>w.\n                r \\<approx> w  \\<longrightarrow>\n               PhiWhile b \\<Phi> (ra, w))\\<rbrakk>\n       \\<Longrightarrow>  ra \\<approx> t \n 3. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, s);\n        \\<exists>r.\n           \\<Phi> (r, s) \\<and>\n           (\\<forall>w.\n                r \\<approx> w  \\<longrightarrow>\n               PhiWhile b \\<Phi> (ra, w))\\<rbrakk>\n       \\<Longrightarrow>  ra \\<approx> t \n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, s); \\<Phi> (rb, s);\n        \\<forall>w.\n            rb \\<approx> w  \\<longrightarrow>\n           PhiWhile b \\<Phi> (ra, w)\\<rbrakk>\n       \\<Longrightarrow>  ra \\<approx> t \n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (rotate_tac -3, erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<Phi> (rb, s);\n        \\<forall>w.\n            rb \\<approx> w  \\<longrightarrow> PhiWhile b \\<Phi> (ra, w);\n        \\<forall>s t.\n            s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t \\<rbrakk>\n       \\<Longrightarrow>  ra \\<approx> t \n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (rotate_tac -1, erule_tac x=ra in allE, erule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<Phi> (rb, s);\n        \\<forall>w.\n            rb \\<approx> w  \\<longrightarrow> PhiWhile b \\<Phi> (ra, w);\n        \\<forall>s t.\n            s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r)\n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (rotate_tac 1, erule_tac x=r in allE, erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<Phi> (rb, s)\\<rbrakk>\n       \\<Longrightarrow>  rb \\<approx> r \n 2. \\<And>s r t ra rb.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<Phi> (rb, s); PhiWhile b \\<Phi> (ra, r)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r)\n 3. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<Phi> (rb, s); PhiWhile b \\<Phi> (ra, r)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r)\n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) = PhiWhile b \\<Phi>\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<Phi> (rb, s); PhiWhile b \\<Phi> (ra, r)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) =\n                         PhiWhile b \\<Phi>\n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (t, ra);\n        \\<Phi> (rb, s); FIX (PhiWhileOp b \\<Phi>) (ra, r)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra rb.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (t, ra);\n        \\<Phi> (rb, s); FIX (PhiWhileOp b \\<Phi>) (ra, r)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b s;\n        (\\<forall>ra.\n             s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra)) \\<and>\n        (\\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r );\n        (\\<forall>ra.\n             r \\<approx> ra  \\<longrightarrow>\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)) \\<and>\n        (\\<forall>ra.\n            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n             (ra, r) \\<longrightarrow>\n             ra \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> \\<forall>r.\n                             s \\<approx> r  \\<longrightarrow>\n                            PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, r)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n         s \\<approx> ra \\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra)", "apply (simp (no_asm_simp) add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n         s \\<approx> ra \\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Phi> (r, ra) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                PhiWhile b \\<Phi> (t, w))", "apply (rule_tac x=r in exI, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n         s \\<approx> ra \\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (r, ra)\n 2. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n         s \\<approx> ra \\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            PhiWhile b \\<Phi> (t, w)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n         s \\<approx> ra \\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            PhiWhile b \\<Phi> (t, w)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra w.\n       \\<lbrakk>\\<forall>s t.\n                    s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        \\<forall>ra.\n            r \\<approx> ra  \\<longrightarrow>\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, ra);\n        \\<forall>ra.\n           PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (ra, r) \\<longrightarrow>\n            ra \\<approx> t ;\n         s \\<approx> ra ;  r \\<approx> w \\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (t, w)", "apply (rotate_tac 5, erule_tac x=w in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra w.\n       \\<lbrakk>\\<forall>ra.\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    (ra, r) \\<longrightarrow>\n                    ra \\<approx> t ;\n         s \\<approx> ra ;  r \\<approx> w ;\n        \\<forall>s t.\n            s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (t, w)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) = PhiWhile b \\<Phi>\", clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra w.\n       \\<lbrakk>\\<forall>ra.\n                   PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>)\n                    (ra, r) \\<longrightarrow>\n                    ra \\<approx> t ;\n         s \\<approx> ra ;  r \\<approx> w ;\n        \\<forall>s t.\n            s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) (t, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (PhiWhile b \\<Phi>) =\n                         PhiWhile b \\<Phi>", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra w.\n       \\<lbrakk>\\<forall>ra.\n                   PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                    (ra, r) \\<longrightarrow>\n                    ra \\<approx> t ;\n         s \\<approx> ra ;  r \\<approx> w ;\n        \\<forall>s t.\n            s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (t, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s r t ra w.\n       \\<lbrakk>\\<forall>ra.\n                   PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                    (ra, r) \\<longrightarrow>\n                    ra \\<approx> t ;\n         s \\<approx> ra ;  r \\<approx> w ;\n        \\<forall>s t.\n            s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n        G \\<rhd> c : Sec \\<Phi>; evalB b ra;\n        \\<forall>ra.  s \\<approx> ra  \\<longrightarrow> \\<Phi> (r, ra);\n        \\<forall>ra. \\<Phi> (ra, s) \\<longrightarrow>  ra \\<approx> r ;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (t, w)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The operator that given $\\Phi$ returns the invariant\noccurring in the conclusion of the rule is itself monotone - this is\nthe property required for the rule for procedure invocations.\\<close>"], ["", "lemma PhiWhileMonotone: \"Monotone (\\<lambda> \\<Phi> . PhiWhile b \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhile b)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhile b)", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi> \\<Psi>.\n       (\\<forall>s t.\n           \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)) \\<longrightarrow>\n       (\\<forall>s t.\n           PhiWhile b \\<Phi> (s, t) \\<longrightarrow>\n           PhiWhile b \\<Psi> (s, t))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> s t.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        PhiWhile b \\<Phi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Psi> (s, t)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> s t.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        FIX (PhiWhileOp b \\<Phi>) (s, t)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Psi>) (s, t)", "apply (simp add: FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> s t.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        \\<forall>\\<Phi>'.\n           (\\<forall>ss tt.\n               PhiWhileOp b \\<Phi> \\<Phi>' (ss, tt) \\<longrightarrow>\n               \\<Phi>' (ss, tt)) \\<longrightarrow>\n           \\<Phi>' (s, t)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<Phi>.\n                            (\\<forall>ss tt.\n                                PhiWhileOp b \\<Psi> \\<Phi>\n                                 (ss, tt) \\<longrightarrow>\n                                \\<Phi> (ss, tt)) \\<longrightarrow>\n                            \\<Phi> (s, t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> s t \\<Phi>'.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        \\<forall>\\<Phi>'.\n           (\\<forall>ss tt.\n               PhiWhileOp b \\<Phi> \\<Phi>' (ss, tt) \\<longrightarrow>\n               \\<Phi>' (ss, tt)) \\<longrightarrow>\n           \\<Phi>' (s, t);\n        \\<forall>ss tt.\n           PhiWhileOp b \\<Psi> \\<Phi>' (ss, tt) \\<longrightarrow>\n           \\<Phi>' (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' (s, t)", "apply (erule_tac x=\\<Phi>' in allE, erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> s t \\<Phi>'.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        \\<forall>ss tt.\n           PhiWhileOp b \\<Psi> \\<Phi>' (ss, tt) \\<longrightarrow>\n           \\<Phi>' (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ss tt.\n                            PhiWhileOp b \\<Phi> \\<Phi>'\n                             (ss, tt) \\<longrightarrow>\n                            \\<Phi>' (ss, tt)", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' ss tt.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        \\<forall>ss tt.\n           PhiWhileOp b \\<Psi> \\<Phi>' (ss, tt) \\<longrightarrow>\n           \\<Phi>' (ss, tt);\n        PhiWhileOp b \\<Phi> \\<Phi>' (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>' (ss, tt)", "apply (erule_tac x=ss in allE, erule_tac x=tt in allE, erule mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' ss tt.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        PhiWhileOp b \\<Phi> \\<Phi>' (ss, tt)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Psi> \\<Phi>' (ss, tt)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' ss tt.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        (evalB b tt \\<longrightarrow>\n         (\\<exists>r.\n             \\<Phi> (r, tt) \\<and>\n             (\\<forall>w.\n                  r \\<approx> w  \\<longrightarrow> \\<Phi>' (ss, w)))) \\<and>\n        (\\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt )\\<rbrakk>\n       \\<Longrightarrow> evalB b tt \\<longrightarrow>\n                         (\\<exists>r.\n                             \\<Psi> (r, tt) \\<and>\n                             (\\<forall>w.\n                                  r \\<approx> w  \\<longrightarrow>\n                                 \\<Phi>' (ss, w)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> \\<Phi>' ss tt r.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        evalB b tt; \\<Phi> (r, tt);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow> \\<Phi>' (ss, w)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Psi> (r, tt) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                \\<Phi>' (ss, w))", "apply (rule_tac x=r in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>We now derive an alternative while rule that employs an\ninductive formulation of a variant that replaces the fixed point\nconstruction. This version is given in the paper.\\<close>"], ["", "text\\<open>First, the inductive definition of the $\\mathit{var}$ relation.\\<close>"], ["", "inductive_set var::\"(BExpr \\<times> TT \\<times> State \\<times> State) set\"\nwhere\nvarFalse: \"\\<lbrakk>\\<not> evalB b t; s \\<approx> t\\<rbrakk> \\<Longrightarrow> (b,\\<Phi>,s,t):var\"\n| varTrue:\"\\<lbrakk>evalB b t; \\<Phi>(r,t); \\<forall> w . r \\<approx> w \\<longrightarrow> (b,\\<Phi>,s,w): var\\<rbrakk>\n           \\<Longrightarrow> (b,\\<Phi>,s,t):var\""], ["", "text\\<open>It is easy to prove the equivalence of $\\mathit{var}$ and the\nfixed point:\\<close>"], ["", "(*<*)"], ["", "lemma varFIX: \"(b,\\<Phi>,s,t):var \\<Longrightarrow> PhiWhile b \\<Phi> (s,t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (erule var.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t)\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s,t)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t ;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t)\n 2. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)\n 3. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) = FIX (PhiWhileOp b \\<Phi>)\", clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t ;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)\n 3. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t ;\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)\n 3. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (simp (no_asm_simp) add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s,t)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> PhiWhile b \\<Phi> (s, w);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n       \\<Longrightarrow> FIX (PhiWhileOp b \\<Phi>) (s, t)\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) = FIX (PhiWhileOp b \\<Phi>)\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> PhiWhile b \\<Phi> (s, w);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n                         FIX (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> PhiWhile b \\<Phi> (s, w);\n        PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n       \\<Longrightarrow> Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>))\n                          (s, t)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            \\<Phi> (r, t) \\<and>\n                            (\\<forall>w.\n                                 r \\<approx> w  \\<longrightarrow>\n                                FIX (\\<lambda>\\<Psi> (s, t).\n  (evalB b t \\<longrightarrow>\n   (\\<exists>r.\n       \\<Phi> (r, t) \\<and>\n       (\\<forall>w.\n            r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n  (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n                                 (s, w))", "apply (rule_tac x=r in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            FIX (\\<lambda>\\<Psi> (s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     (\\<exists>r.\n   \\<Phi> (r, t) \\<and>\n   (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                      s \\<approx> t ))\n                             (s, w)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> PhiWhile b \\<Phi> (s, w);\n         r \\<approx> w \\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  (\\<exists>r.\n\\<Phi> (r, t) \\<and>\n(\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                   s \\<approx> t ))\n                          (s, w)", "apply (erule_tac x=w in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        (b, \\<Phi>, s, w) \\<in> var; PhiWhile b \\<Phi> (s, w)\\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  (\\<exists>r.\n\\<Phi> (r, t) \\<and>\n(\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                   s \\<approx> t ))\n                          (s, w)", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        (b, \\<Phi>, s, w) \\<in> var;\n        FIX (PhiWhileOp b \\<Phi>) (s, w)\\<rbrakk>\n       \\<Longrightarrow> FIX (\\<lambda>\\<Psi> (s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  (\\<exists>r.\n\\<Phi> (r, t) \\<and>\n(\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                   s \\<approx> t ))\n                          (s, w)", "apply (simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FIXvar: \"PhiWhile b \\<Phi> (s,t) \\<Longrightarrow> (b,\\<Phi>,s,t):var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b \\<Phi> (s, t) \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (simp add: PhiWhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t) \\<Longrightarrow>\n    (b, \\<Phi>, s, t) \\<in> var", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var\n 2. FIX (PhiWhileOp b \\<Phi>) (s, t) \\<Longrightarrow>\n    PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t) \\<Longrightarrow>\n    PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\n 2. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (subgoal_tac \"PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) = FIX (PhiWhileOp b \\<Phi>)\", clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t) \\<Longrightarrow>\n    PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) =\n    FIX (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (rule Fix_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. FIX (PhiWhileOp b \\<Phi>) (s, t) \\<Longrightarrow>\n    Monotone (PhiWhileOp b \\<Phi>)\n 2. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (rule PhiWhileOp_Monotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FIX (PhiWhileOp b \\<Phi>) (s, t);\n     PhiWhileOp b \\<Phi> (FIX (PhiWhileOp b \\<Phi>)) (s, t)\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (erule thin_rl, simp add: PhiWhileOp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (evalB b t \\<longrightarrow>\n     (\\<exists>r.\n         \\<Phi> (r, t) \\<and>\n         (\\<forall>w.\n              r \\<approx> w  \\<longrightarrow>\n             FIX (\\<lambda>\\<Psi> (s, t).\n                     (evalB b t \\<longrightarrow>\n                      (\\<exists>r.\n                          \\<Phi> (r, t) \\<and>\n                          (\\<forall>w.\n                               r \\<approx> w  \\<longrightarrow>\n                              \\<Psi> (s, w)))) \\<and>\n                     (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n              (s, w)))) \\<and>\n    (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ) \\<Longrightarrow>\n    (b, \\<Phi>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t \\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (case_tac \"evalB b t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t ; evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var\n 2. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t ;\n     \\<not> evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t ;\n     \\<not> evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var\n 2. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t ; evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk> s \\<approx> t ; \\<not> evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var\n 2. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t ; evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (rule varFalse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk> s \\<approx> t ; \\<not> evalB b t\\<rbrakk>\n    \\<Longrightarrow> \\<not> evalB b t\n 2. \\<lbrakk> s \\<approx> t ; \\<not> evalB b t\\<rbrakk>\n    \\<Longrightarrow>  s \\<approx> t \n 3. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t ; evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>evalB b t \\<longrightarrow>\n             (\\<exists>r.\n                 \\<Phi> (r, t) \\<and>\n                 (\\<forall>w.\n                      r \\<approx> w  \\<longrightarrow>\n                     FIX (\\<lambda>\\<Psi> (s, t).\n                             (evalB b t \\<longrightarrow>\n                              (\\<exists>r.\n                                  \\<Phi> (r, t) \\<and>\n                                  (\\<forall>w.\n r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))) \\<and>\n                             (\\<not> evalB b t \\<longrightarrow>\n                               s \\<approx> t ))\n                      (s, w)));\n     \\<not> evalB b t \\<longrightarrow>  s \\<approx> t ; evalB b t\\<rbrakk>\n    \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var", "apply (rule varTrue)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w)\\<rbrakk>\n       \\<Longrightarrow> evalB b t\n 2. \\<And>r.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (?r17 r, t)\n 3. \\<And>r.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             ?r17 r \\<approx> w  \\<longrightarrow>\n                            (b, \\<Phi>, s, w) \\<in> var", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (?r17 r, t)\n 2. \\<And>r.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             ?r17 r \\<approx> w  \\<longrightarrow>\n                            (b, \\<Phi>, s, w) \\<in> var", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            (b, \\<Phi>, s, w) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           FIX (\\<lambda>\\<Psi> (s, t).\n                   (evalB b t \\<longrightarrow>\n                    (\\<exists>r.\n                        \\<Phi> (r, t) \\<and>\n                        (\\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            \\<Psi> (s, w)))) \\<and>\n                   (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n            (s, w);\n         r \\<approx> w \\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, s, w) \\<in> var", "apply (erule_tac x=w in allE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        FIX (\\<lambda>\\<Psi> (s, t).\n                (evalB b t \\<longrightarrow>\n                 (\\<exists>r.\n                     \\<Phi> (r, t) \\<and>\n                     (\\<forall>w.\n                          r \\<approx> w  \\<longrightarrow>\n                         \\<Psi> (s, w)))) \\<and>\n                (\\<not> evalB b t \\<longrightarrow>  s \\<approx> t ))\n         (s, w)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, s, w) \\<in> var", "apply (unfold FIX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        case (s, w) of\n        (s, t) \\<Rightarrow>\n          \\<forall>\\<Phi>'.\n             (\\<forall>ss tt.\n                 (case (ss, tt) of\n                  (s, t) \\<Rightarrow>\n                    (evalB b t \\<longrightarrow>\n                     (\\<exists>r.\n                         \\<Phi> (r, t) \\<and>\n                         (\\<forall>w.\n                              r \\<approx> w  \\<longrightarrow>\n                             \\<Phi>' (s, w)))) \\<and>\n                    (\\<not> evalB b t \\<longrightarrow>\n                      s \\<approx> t )) \\<longrightarrow>\n                 \\<Phi>' (ss, tt)) \\<longrightarrow>\n             \\<Phi>' (s, t)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, s, w) \\<in> var", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        \\<forall>\\<Phi>'.\n           (\\<forall>ss tt.\n               (evalB b tt \\<longrightarrow>\n                (\\<exists>r.\n                    \\<Phi> (r, tt) \\<and>\n                    (\\<forall>w.\n                         r \\<approx> w  \\<longrightarrow>\n                        \\<Phi>' (ss, w)))) \\<and>\n               (\\<not> evalB b tt \\<longrightarrow>\n                 ss \\<approx> tt ) \\<longrightarrow>\n               \\<Phi>' (ss, tt)) \\<longrightarrow>\n           \\<Phi>' (s, w)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, s, w) \\<in> var", "apply (erule_tac x=\"\\<lambda> (x,y) . (b,\\<Phi>,x,y):var\" in allE, erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w \\<rbrakk>\n       \\<Longrightarrow> \\<forall>ss tt.\n                            (evalB b tt \\<longrightarrow>\n                             (\\<exists>r.\n                                 \\<Phi> (r, tt) \\<and>\n                                 (\\<forall>w.\n                                      r \\<approx> w  \\<longrightarrow>\n                                     (case (ss, w) of\n(x, y) \\<Rightarrow> (b, \\<Phi>, x, y) \\<in> var)))) \\<and>\n                            (\\<not> evalB b tt \\<longrightarrow>\n                              ss \\<approx> tt ) \\<longrightarrow>\n                            (case (ss, tt) of\n                             (x, y) \\<Rightarrow>\n                               (b, \\<Phi>, x, y) \\<in> var)\n 2. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        case (s, w) of\n        (x, y) \\<Rightarrow> (b, \\<Phi>, x, y) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, s, w) \\<in> var", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        case (s, w) of\n        (x, y) \\<Rightarrow> (b, \\<Phi>, x, y) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, s, w) \\<in> var\n 2. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w \\<rbrakk>\n       \\<Longrightarrow> \\<forall>ss tt.\n                            (evalB b tt \\<longrightarrow>\n                             (\\<exists>r.\n                                 \\<Phi> (r, tt) \\<and>\n                                 (\\<forall>w.\n                                      r \\<approx> w  \\<longrightarrow>\n                                     (case (ss, w) of\n(x, y) \\<Rightarrow> (b, \\<Phi>, x, y) \\<in> var)))) \\<and>\n                            (\\<not> evalB b tt \\<longrightarrow>\n                              ss \\<approx> tt ) \\<longrightarrow>\n                            (case (ss, tt) of\n                             (x, y) \\<Rightarrow>\n                               (b, \\<Phi>, x, y) \\<in> var)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w \\<rbrakk>\n       \\<Longrightarrow> \\<forall>ss tt.\n                            (evalB b tt \\<longrightarrow>\n                             (\\<exists>r.\n                                 \\<Phi> (r, tt) \\<and>\n                                 (\\<forall>w.\n                                      r \\<approx> w  \\<longrightarrow>\n                                     (case (ss, w) of\n(x, y) \\<Rightarrow> (b, \\<Phi>, x, y) \\<in> var)))) \\<and>\n                            (\\<not> evalB b tt \\<longrightarrow>\n                              ss \\<approx> tt ) \\<longrightarrow>\n                            (case (ss, tt) of\n                             (x, y) \\<Rightarrow>\n                               (b, \\<Phi>, x, y) \\<in> var)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt \\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var", "apply (case_tac \"evalB b tt\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt ;\n        evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var\n 2. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt ;\n        \\<not> evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt ;\n        \\<not> evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var\n 2. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt ;\n        evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n         ss \\<approx> tt ; \\<not> evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var\n 2. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt ;\n        evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var", "apply (rule varFalse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n         ss \\<approx> tt ; \\<not> evalB b tt\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalB b tt\n 2. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n         ss \\<approx> tt ; \\<not> evalB b tt\\<rbrakk>\n       \\<Longrightarrow>  ss \\<approx> tt \n 3. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt ;\n        evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w ss tt.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ;\n        evalB b tt \\<longrightarrow>\n        (\\<exists>r.\n            \\<Phi> (r, tt) \\<and>\n            (\\<forall>w.\n                 r \\<approx> w  \\<longrightarrow>\n                (b, \\<Phi>, ss, w) \\<in> var));\n        \\<not> evalB b tt \\<longrightarrow>  ss \\<approx> tt ;\n        evalB b tt\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r w ss tt ra.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ; evalB b tt;\n        \\<Phi> (ra, tt);\n        \\<forall>w.\n            ra \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, ss, w) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Phi>, ss, tt) \\<in> var", "apply (rule varTrue)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r w ss tt ra.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ; evalB b tt;\n        \\<Phi> (ra, tt);\n        \\<forall>w.\n            ra \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, ss, w) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> evalB b tt\n 2. \\<And>r w ss tt ra.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ; evalB b tt;\n        \\<Phi> (ra, tt);\n        \\<forall>w.\n            ra \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, ss, w) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (?r40 r w ss tt ra, tt)\n 3. \\<And>r w ss tt ra.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);  r \\<approx> w ; evalB b tt;\n        \\<Phi> (ra, tt);\n        \\<forall>w.\n            ra \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, ss, w) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> \\<forall>wa.\n                             ?r40 r w ss tt\n                              ra \\<approx> wa  \\<longrightarrow>\n                            (b, \\<Phi>, ss, wa) \\<in> var", "apply assumption+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma varFIXvar: \"(PhiWhile b \\<Phi> (s,t)) = ((b,\\<Phi>,s,t):var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b \\<Phi> (s, t) = ((b, \\<Phi>, s, t) \\<in> var)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. PhiWhile b \\<Phi> (s, t) \\<Longrightarrow> (b, \\<Phi>, s, t) \\<in> var\n 2. (b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (erule FIXvar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow> PhiWhile b \\<Phi> (s, t)", "apply (erule varFIX)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma FIXvarFIX': \"(PhiWhile b \\<Phi>) = (\\<lambda> (s,t) . (b,\\<Phi>,s,t):var)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b \\<Phi> = (\\<lambda>(s, t). (b, \\<Phi>, s, t) \\<in> var)", "apply (rule ext, rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       PhiWhile b \\<Phi> x \\<Longrightarrow>\n       case x of (s, t) \\<Rightarrow> (b, \\<Phi>, s, t) \\<in> var\n 2. \\<And>x.\n       case x of\n       (s, t) \\<Rightarrow> (b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> x", "apply (case_tac x, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       PhiWhile b \\<Phi> (aa, ba) \\<Longrightarrow>\n       (b, \\<Phi>, aa, ba) \\<in> var\n 2. \\<And>x.\n       case x of\n       (s, t) \\<Rightarrow> (b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> x", "apply (erule FIXvar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of\n       (s, t) \\<Rightarrow> (b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> x", "apply (case_tac x, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       (b, \\<Phi>, aa, ba) \\<in> var \\<Longrightarrow>\n       PhiWhile b \\<Phi> (aa, ba)", "apply (simp add: varFIXvar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma FIXvarFIX: \"(PhiWhile b) = (\\<lambda> \\<Phi> . (\\<lambda> (s,t) . (b,\\<Phi>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b = (\\<lambda>\\<Phi> (s, t). (b, \\<Phi>, s, t) \\<in> var)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PhiWhile b = (\\<lambda>\\<Phi> (s, t). (b, \\<Phi>, s, t) \\<in> var)", "by (rule, rule FIXvarFIX')"], ["", "(*>*)"], ["", "text\\<open>From this rule and the rule WHILE above, one may derive the\nwhile rule we gave in the paper.\\<close>"], ["", "lemma WHILE_IND:\n  \"\\<lbrakk> (\\<forall> s t. s \\<approx> t \\<longrightarrow> evalB b s = evalB b t); G \\<rhd> c : (Sec \\<Phi>)\\<rbrakk> \\<Longrightarrow>\n   G \\<rhd> (While b c) : (Sec (\\<lambda> (s,t) . (b,\\<Phi>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b\n                                c : Sec (\\<lambda>(s, t).\n      (b, \\<Phi>, s, t) \\<in> var)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b\n                                c : Sec (\\<lambda>(s, t).\n      (b, \\<Phi>, s, t) \\<in> var)", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> While b c : ?A\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         ?A s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t). (b, \\<Phi>, s, t) \\<in> var)\n                          s t", "apply (rule WHILE [of b G c \\<Phi>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                          s \\<approx> t  \\<longrightarrow>\n                         evalB b s = evalB b t\n 2. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c : Sec \\<Phi>\n 3. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhile b \\<Phi>) s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t). (b, \\<Phi>, s, t) \\<in> var)\n                          s t", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s t.\n                 s \\<approx> t  \\<longrightarrow> evalB b s = evalB b t;\n     G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         Sec (PhiWhile b \\<Phi>) s t \\<longrightarrow>\n                         Sec (\\<lambda>(s, t). (b, \\<Phi>, s, t) \\<in> var)\n                          s t", "apply (simp add: FIXvarFIX)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Not suprisingly, the construction $\\mathit{var}$ can be shown to\nbe monotone in $\\Phi$.\\<close>"], ["", "(*<*)"], ["", "lemma varMonotoneAux[rule_format]:\n  \"(b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow> \n   (\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)) \\<longrightarrow> (b, \\<Psi>, s, t) \\<in> var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, \\<Phi>, s, t) \\<in> var \\<Longrightarrow>\n    (\\<forall>s t.\n        \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)) \\<longrightarrow>\n    (b, \\<Psi>, s, t) \\<in> var", "apply (erule var.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t \\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t.\n                             \\<Phi> (s, t) \\<longrightarrow>\n                             \\<Psi> (s, t)) \\<longrightarrow>\n                         (b, \\<Psi>, s, t) \\<in> var\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t.\n                \\<Phi> (s, t) \\<longrightarrow>\n                \\<Psi> (s, t)) \\<longrightarrow>\n            (b, \\<Psi>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t.\n                             \\<Phi> (s, t) \\<longrightarrow>\n                             \\<Psi> (s, t)) \\<longrightarrow>\n                         (b, \\<Psi>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t s \\<Phi>.\n       \\<lbrakk>\\<not> evalB b t;  s \\<approx> t ;\n        \\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Psi>, s, t) \\<in> var\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t.\n                \\<Phi> (s, t) \\<longrightarrow>\n                \\<Psi> (s, t)) \\<longrightarrow>\n            (b, \\<Psi>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t.\n                             \\<Phi> (s, t) \\<longrightarrow>\n                             \\<Psi> (s, t)) \\<longrightarrow>\n                         (b, \\<Psi>, s, t) \\<in> var", "apply (erule varFalse, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and>\n           ((\\<forall>s t.\n                \\<Phi> (s, t) \\<longrightarrow>\n                \\<Psi> (s, t)) \\<longrightarrow>\n            (b, \\<Psi>, s, w) \\<in> var)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s t.\n                             \\<Phi> (s, t) \\<longrightarrow>\n                             \\<Psi> (s, t)) \\<longrightarrow>\n                         (b, \\<Psi>, s, t) \\<in> var", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>evalB b t; \\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> (b, \\<Psi>, s, w) \\<in> var;\n        \\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Psi>, s, t) \\<in> var", "apply (erule varTrue)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>\\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> (b, \\<Psi>, s, w) \\<in> var;\n        \\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> (?r16 b t \\<Phi> r s, t)\n 2. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>\\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> (b, \\<Psi>, s, w) \\<in> var;\n        \\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             ?r16 b t \\<Phi> r\n                              s \\<approx> w  \\<longrightarrow>\n                            (b, \\<Psi>, s, w) \\<in> var", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b t \\<Phi> r s.\n       \\<lbrakk>\\<Phi> (r, t);\n        \\<forall>w.\n            r \\<approx> w  \\<longrightarrow>\n           (b, \\<Phi>, s, w) \\<in> var \\<and> (b, \\<Psi>, s, w) \\<in> var;\n        \\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w.\n                             r \\<approx> w  \\<longrightarrow>\n                            (b, \\<Psi>, s, w) \\<in> var", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma var_Monotone: \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t) .(b,\\<Phi>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (\\<lambda>\\<Phi> (s, t). (b, \\<Phi>, s, t) \\<in> var)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (\\<lambda>\\<Phi> (s, t). (b, \\<Phi>, s, t) \\<in> var)", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi> \\<Psi>.\n       (\\<forall>s t.\n           \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t)) \\<longrightarrow>\n       (\\<forall>s t.\n           (b, \\<Phi>, s, t) \\<in> var \\<longrightarrow>\n           (b, \\<Psi>, s, t) \\<in> var)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> s t.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        (b, \\<Phi>, s, t) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, \\<Psi>, s, t) \\<in> var", "apply (rule varMonotoneAux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Phi> \\<Psi> s t.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        (b, \\<Phi>, s, t) \\<in> var\\<rbrakk>\n       \\<Longrightarrow> (b, ?\\<Phi>11 \\<Phi> \\<Psi> s t, s, t) \\<in> var\n 2. \\<And>\\<Phi> \\<Psi> s t sa ta.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        (b, \\<Phi>, s, t) \\<in> var;\n        ?\\<Phi>11 \\<Phi> \\<Psi> s t (sa, ta)\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> (sa, ta)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Phi> \\<Psi> s t sa ta.\n       \\<lbrakk>\\<forall>s t. \\<Phi> (s, t) \\<longrightarrow> \\<Psi> (s, t);\n        (b, \\<Phi>, s, t) \\<in> var; \\<Phi> (sa, ta)\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> (sa, ta)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(*<*)"], ["", "lemma varMonotone_byFIX: \"Monotone (\\<lambda> \\<Phi> . (\\<lambda> (s,t) .(b,\\<Phi>,s,t):var))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (\\<lambda>\\<Phi> (s, t). (b, \\<Phi>, s, t) \\<in> var)", "apply (subgoal_tac \"Monotone (\\<lambda> \\<Phi> . PhiWhile b \\<Phi>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotone (PhiWhile b) \\<Longrightarrow>\n    Monotone (\\<lambda>\\<Phi> (s, t). (b, \\<Phi>, s, t) \\<in> var)\n 2. Monotone (PhiWhile b)", "apply (simp add: FIXvarFIX)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monotone (PhiWhile b)", "apply (rule PhiWhileMonotone)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The call rule is formulated for an arbitrary fixed point of\na monotone transformer.\\<close>"], ["", "lemma CALL: \n  \"\\<lbrakk> ({Sec(FIX \\<Phi>)} \\<union> G) \\<rhd> body : Sec(\\<Phi> (FIX \\<Phi>)); Monotone \\<Phi>\\<rbrakk> \\<Longrightarrow>\n   G \\<rhd> Call : Sec(FIX \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union>\n              G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n     Monotone \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union>\n              G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n     Monotone \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)", "apply (rule VDMCall)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union>\n              G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n     Monotone \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> ({Sec (FIX \\<Phi>)} \\<union>\n                       G) \\<rhd> body : Sec (FIX \\<Phi>)", "apply (subgoal_tac \"\\<Phi> (FIX \\<Phi>) = FIX \\<Phi>\", clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union>\n              G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n     Monotone \\<Phi>\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (FIX \\<Phi>) = FIX \\<Phi>", "apply (erule Fix_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "subsection\\<open>Derivation of the HIGH rules\\<close>"], ["", "text\\<open>The HIGH rules are easy.\\<close>"], ["", "lemma HIGH_SKIP: \"G \\<rhd> Skip : twiddle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : twiddle", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> Skip : twiddle", "apply (rule VDMConseq, rule VDMSkip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t. t = s \\<longrightarrow>  s \\<approx> t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma HIGH_ASSIGN:\n  \"CONTEXT x = high \\<Longrightarrow> G \\<rhd> (Assign x e) : twiddle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle", "apply (rule VDMConseq, rule VDMAssign)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONTEXT x = high \\<Longrightarrow>\n    \\<forall>s t.\n       t = update s x (evalE e s) \\<longrightarrow>  s \\<approx> t", "apply (simp add: update_def twiddle_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma HIGH_COMP: \n  \"\\<lbrakk> G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> (Comp c1 c2): twiddle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle", "apply (rule VDMConseq, rule VDMComp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c1 : ?A1.3\n 2. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c2 : ?A2.3\n 3. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             ?A1.3 s r \\<and> ?A2.3 r t) \\<longrightarrow>\n                          s \\<approx> t", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                              s \\<approx> r  \\<and>\n                              r \\<approx> t ) \\<longrightarrow>\n                          s \\<approx> t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (\\<exists>r.\n                             (\\<forall>x.\n                                 CONTEXT x = low \\<longrightarrow>\n                                 s x = r x) \\<and>\n                             (\\<forall>x.\n                                 CONTEXT x = low \\<longrightarrow>\n                                 r x = t x)) \\<longrightarrow>\n                         (\\<forall>x.\n                             CONTEXT x = low \\<longrightarrow> s x = t x)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma HIGH_IFF:\n  \"\\<lbrakk> G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle \\<rbrakk> \n  \\<Longrightarrow> G \\<rhd> (Iff b c1 c2) : twiddle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle", "apply (rule VDMConseq, rule VDMIff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c1 : ?A3\n 2. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> G \\<rhd> c2 : ?B3\n 3. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b s \\<longrightarrow> ?A3 s t) \\<and>\n                         (\\<not> evalB b s \\<longrightarrow>\n                          ?B3 s t) \\<longrightarrow>\n                          s \\<approx> t", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s t.\n                         (evalB b s \\<longrightarrow>\n                           s \\<approx> t ) \\<and>\n                         (\\<not> evalB b s \\<longrightarrow>\n                           s \\<approx> t ) \\<longrightarrow>\n                          s \\<approx> t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma HIGH_WHILE:\n  \"\\<lbrakk> G \\<rhd> c  : twiddle\\<rbrakk> \\<Longrightarrow> G \\<rhd> (While b c)  : twiddle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow> G \\<rhd> While b c : twiddle", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow> G \\<rhd> While b c : twiddle", "apply (rule VDMConseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow> G \\<rhd> While b c : ?A\n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s t. ?A s t \\<longrightarrow>  s \\<approx> t", "apply (rule VDMWhile)"], ["proof (prove)\ngoal (4 subgoals):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow> G \\<rhd> c : ?B3\n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 3. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       ?B3 s r \\<longrightarrow> ?A3 r t \\<longrightarrow> ?A3 s t\n 4. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s t.\n       ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>  s \\<approx> t", "apply (subgoal_tac \"G \\<rhd> c : (\\<lambda>s t. evalB b s \\<longrightarrow> s \\<approx> t)\", erule thin_rl, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow>\n    G \\<rhd> c : (\\<lambda>s t. evalB b s \\<longrightarrow>  s \\<approx> t )\n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 3. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       (evalB b s \\<longrightarrow>  s \\<approx> r ) \\<longrightarrow>\n       ?A3 r t \\<longrightarrow> ?A3 s t\n 4. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s t.\n       ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>  s \\<approx> t", "apply (erule VDMConseq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>s t.\n        s \\<approx> t  \\<longrightarrow>\n       evalB b s \\<longrightarrow>  s \\<approx> t \n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 3. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       (evalB b s \\<longrightarrow>  s \\<approx> r ) \\<longrightarrow>\n       ?A3 r t \\<longrightarrow> ?A3 s t\n 4. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s t.\n       ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>  s \\<approx> t", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       (evalB b s \\<longrightarrow>  s \\<approx> r ) \\<longrightarrow>\n       ?A3 r t \\<longrightarrow> ?A3 s t\n 3. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s t.\n       ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>  s \\<approx> t", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s t.\n       ?A3 s t \\<and> \\<not> evalB b t \\<longrightarrow>  s \\<approx> t \n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s. \\<not> evalB b s \\<longrightarrow> ?A3 s s\n 3. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       (evalB b s \\<longrightarrow>  s \\<approx> r ) \\<longrightarrow>\n       ?A3 r t \\<longrightarrow> ?A3 s t", "apply (subgoal_tac \"\\<forall>s t. s \\<approx> t \\<and> \\<not> evalB b t \\<longrightarrow> s \\<approx> t\", assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s t.\n        s \\<approx> t  \\<and> \\<not> evalB b t \\<longrightarrow>\n        s \\<approx> t \n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s. \\<not> evalB b s \\<longrightarrow>  s \\<approx> s \n 3. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       (evalB b s \\<longrightarrow>  s \\<approx> r ) \\<longrightarrow>\n        r \\<approx> t  \\<longrightarrow>  s \\<approx> t", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s. \\<not> evalB b s \\<longrightarrow>  s \\<approx> s \n 2. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       (evalB b s \\<longrightarrow>  s \\<approx> r ) \\<longrightarrow>\n        r \\<approx> t  \\<longrightarrow>  s \\<approx> t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<rhd> c : twiddle \\<Longrightarrow>\n    \\<forall>s r t.\n       evalB b s \\<longrightarrow>\n       (evalB b s \\<longrightarrow>  s \\<approx> r ) \\<longrightarrow>\n        r \\<approx> t  \\<longrightarrow>  s \\<approx> t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma HIGH_CALL:\n  \"({twiddle} \\<union> G) \\<rhd> body : twiddle \\<Longrightarrow> G \\<rhd> Call : twiddle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({twiddle} \\<union> G) \\<rhd> body : twiddle \\<Longrightarrow>\n    G \\<rhd> Call : twiddle", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({twiddle} \\<union> G) \\<rhd> body : twiddle \\<Longrightarrow>\n    G \\<rhd> Call : twiddle", "by (erule VDMCall)"], ["", "(*>*)"], ["", "subsection\\<open>The type system of Volpano, Smith and Irvine\\<close>"], ["", "text\\<open>We now give the type system of Volpano et al.~and then prove its\nembedding into the system of derived rules. First, type systems for\nexpressions and boolean expressions.\\<close>"], ["", "inductive_set VS_expr :: \"(Expr \\<times> TP) set\"\nwhere\nVS_exprVar: \"CONTEXT x = t \\<Longrightarrow> (varE x, t) : VS_expr\"\n| VS_exprVal: \"(valE v, low) : VS_expr\"\n| VS_exprOp: \"\\<lbrakk>(e1,t) : VS_expr; (e2,t):VS_expr\\<rbrakk>\n             \\<Longrightarrow> (opE f e1 e2,t) : VS_expr\"\n| VS_exprHigh: \"(e, high) : VS_expr\""], ["", "inductive_set VS_Bexpr :: \"(BExpr \\<times> TP) set\"\nwhere\nVS_BexprOp: \"\\<lbrakk>(e1,t) : VS_expr; (e2,t):VS_expr\\<rbrakk>\n             \\<Longrightarrow> (compB f e1 e2,t) : VS_Bexpr\"\n| VS_BexprHigh: \"(e,high) : VS_Bexpr\""], ["", "text\\<open>Next, the core of the type system, the rules for commands.\\<close>"], ["", "inductive_set VS_com :: \"(TP \\<times> IMP) set\"\nwhere\n\nVS_comSkip: \"(pc,Skip) : VS_com\"\n\n| VS_comAssHigh:\n  \"CONTEXT x = high \\<Longrightarrow> (pc,Assign x e) : VS_com\"\n\n| VS_comAssLow:\n  \"\\<lbrakk>CONTEXT x = low; pc = low; (e,low):VS_expr\\<rbrakk> \\<Longrightarrow>\n   (pc,Assign x e) : VS_com\"\n\n| VS_comComp:\n  \"\\<lbrakk> (pc,c1):VS_com; (pc,c2):VS_com\\<rbrakk> \\<Longrightarrow>\n   (pc,Comp c1 c2) : VS_com\"\n\n| VS_comIf:\n  \"\\<lbrakk> (b,pc):VS_Bexpr; (pc,c1):VS_com; (pc,c2):VS_com\\<rbrakk> \\<Longrightarrow>\n   (pc,Iff b c1 c2):VS_com\"\n\n| VS_comWhile:\n  \"\\<lbrakk>(b,pc):VS_Bexpr; (pc,c):VS_com\\<rbrakk> \\<Longrightarrow> (pc,While b c):VS_com\"\n\n| VS_comSub: \"(high,c) : VS_com \\<Longrightarrow> (low,c):VS_com\""], ["", "text\\<open>We define the interpretation of expression typings\\ldots\\<close>"], ["", "primrec SemExpr::\"Expr \\<Rightarrow> TP \\<Rightarrow> bool\"\nwhere\n\"SemExpr e low = (\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalE e s = evalE e ss)\" |\n\"SemExpr e high = True\""], ["", "text\\<open>\\ldots and show the soundness of the typing rules.\\<close>"], ["", "lemma ExprSound: \"(e,tp):VS_expr \\<Longrightarrow> SemExpr e tp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_expr \\<Longrightarrow> SemExpr e tp", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_expr \\<Longrightarrow> SemExpr e tp", "apply (erule VS_expr.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x t. CONTEXT x = t \\<Longrightarrow> SemExpr (varE x) t\n 2. \\<And>v. SemExpr (valE v) low\n 3. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t\n 4. \\<And>e. SemExpr e high", "apply (case_tac t,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>CONTEXT x = low; t = low\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s ss.\n                             s \\<approx> ss  \\<longrightarrow> s x = ss x\n 2. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t", "apply (simp add: twiddle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; SemExpr e1 t; (e2, t) \\<in> VS_expr;\n        SemExpr e2 t\\<rbrakk>\n       \\<Longrightarrow> SemExpr (opE f e1 e2) t", "apply (case_tac t, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>Likewise for the boolean expressions.\\<close>"], ["", "primrec SemBExpr::\"BExpr \\<Rightarrow> TP \\<Rightarrow> bool\"\nwhere\n\"SemBExpr b low = (\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalB b s = evalB b ss)\" |\n\"SemBExpr b high = True\""], ["", "lemma BExprSound: \"(e,tp):VS_Bexpr \\<Longrightarrow> SemBExpr e tp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_Bexpr \\<Longrightarrow> SemBExpr e tp", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, tp) \\<in> VS_Bexpr \\<Longrightarrow> SemBExpr e tp", "apply (erule VS_Bexpr.induct, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>(e1, t) \\<in> VS_expr; (e2, t) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> SemBExpr (compB f e1 e2) t", "apply (drule ExprSound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>(e2, t) \\<in> VS_expr; SemExpr e1 t\\<rbrakk>\n       \\<Longrightarrow> SemBExpr (compB f e1 e2) t", "apply (drule ExprSound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 t e2 f.\n       \\<lbrakk>SemExpr e1 t; SemExpr e2 t\\<rbrakk>\n       \\<Longrightarrow> SemBExpr (compB f e1 e2) t", "apply (case_tac t, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The proof of the main theorem (called Theorem 2 in our paper)\nproceeds by induction on $(t,c):VS\\_com$.\\<close>"], ["", "theorem VS_com_VDM[rule_format]:\n\"(t,c):VS_com \\<Longrightarrow> (t=high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n                  (t=low \\<longrightarrow> (\\<exists> A . G \\<rhd> c : Sec A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, c) \\<in> VS_com \\<Longrightarrow>\n    (t = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n    (t = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c : Sec A))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, c) \\<in> VS_com \\<Longrightarrow>\n    (t = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n    (t = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c : Sec A))", "apply (erule VS_com.induct)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>pc.\n       (pc = high \\<longrightarrow> G \\<rhd> Skip : twiddle) \\<and>\n       (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> Skip : Sec A))\n 2. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       (pc = high \\<longrightarrow> G \\<rhd> Assign x e : twiddle) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply rule"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>pc. pc = high \\<longrightarrow> G \\<rhd> Skip : twiddle\n 2. \\<And>pc. pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> Skip : Sec A)\n 3. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       (pc = high \\<longrightarrow> G \\<rhd> Assign x e : twiddle) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 5. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 6. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 7. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 8. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (8 subgoals):\n 1. G \\<rhd> Skip : twiddle\n 2. \\<And>pc. pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> Skip : Sec A)\n 3. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       (pc = high \\<longrightarrow> G \\<rhd> Assign x e : twiddle) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 5. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 6. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 7. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 8. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule HIGH_SKIP)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>pc. pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> Skip : Sec A)\n 2. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       (pc = high \\<longrightarrow> G \\<rhd> Assign x e : twiddle) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<exists>A. G \\<rhd> Skip : Sec A\n 2. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       (pc = high \\<longrightarrow> G \\<rhd> Assign x e : twiddle) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule, rule SKIP)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       (pc = high \\<longrightarrow> G \\<rhd> Assign x e : twiddle) \\<and>\n       (pc = low \\<longrightarrow>\n        (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply rule"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       pc = high \\<longrightarrow> G \\<rhd> Assign x e : twiddle\n 2. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> Assign x e : Sec A)\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 2. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> Assign x e : Sec A)\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (erule HIGH_ASSIGN)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x pc e.\n       CONTEXT x = high \\<Longrightarrow>\n       pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> Assign x e : Sec A)\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (subgoal_tac \"\\<exists> t. (e,t):VS_expr\", clarsimp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; (e, t) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow> \\<exists>t. (e, t) \\<in> VS_expr\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "prefer 2"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow> \\<exists>t. (e, t) \\<in> VS_expr\n 2. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; (e, t) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule, rule VS_exprHigh)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; (e, t) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (drule ExprSound)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; SemExpr e t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (case_tac t)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; SemExpr e t; t = low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; SemExpr e t; t = high\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = high;\n        \\<forall>s ss.\n            s \\<approx> ss  \\<longrightarrow>\n           evalE e s = evalE e ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; SemExpr e t; t = high\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule, erule ASSIGN)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e t.\n       \\<lbrakk>CONTEXT x = high; SemExpr e t; t = high\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule_tac x=\"\\<lambda> (s,t).  s \\<approx> t\" in exI, rule VDMConseq)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : ?A60 x e\n 2. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<forall>s t.\n          ?A60 x e s t \\<longrightarrow>\n          Sec (\\<lambda>(s, t).  s \\<approx> t ) s t\n 3. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 4. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 5. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 6. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 7. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (erule HIGH_ASSIGN)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x e.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<forall>s t.\n           s \\<approx> t  \\<longrightarrow>\n          Sec (\\<lambda>(s, t).  s \\<approx> t ) s t\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (simp add: Sec_def twiddle_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Assign x e : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Assign x e : Sec A))\n 2. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply rule"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> pc = high \\<longrightarrow>\n                         G \\<rhd> Assign x e : twiddle\n 2. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Assign x e : Sec A)\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; (e, low) \\<in> VS_expr\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Assign x e : Sec A)\n 2. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (drule ExprSound)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x pc e.\n       \\<lbrakk>CONTEXT x = low; pc = low; SemExpr e low\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Assign x e : Sec A)\n 2. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>CONTEXT x = low;\n        \\<forall>s ss.\n            s \\<approx> ss  \\<longrightarrow>\n           evalE e s = evalE e ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Assign x e : Sec A\n 2. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule, erule ASSIGN)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Comp c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A))\n 2. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply rule"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = high \\<longrightarrow>\n                         G \\<rhd> Comp c1 c2 : twiddle\n 2. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A)\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c1 c2.\n       \\<lbrakk>(high, c1) \\<in> VS_com; (high, c2) \\<in> VS_com;\n        G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 2. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A)\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule HIGH_COMP)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c1 c2.\n       \\<lbrakk>(high, c1) \\<in> VS_com; (high, c2) \\<in> VS_com;\n        G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c1 : twiddle\n 2. \\<And>c1 c2.\n       \\<lbrakk>(high, c1) \\<in> VS_com; (high, c2) \\<in> VS_com;\n        G \\<rhd> c1 : twiddle; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : twiddle\n 3. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A)\n 4. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 5. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 6. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (assumption, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>pc c1 c2.\n       \\<lbrakk>(pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Comp c1 c2 : Sec A)\n 2. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c1 c2 A Aa.\n       \\<lbrakk>(low, c1) \\<in> VS_com; (low, c2) \\<in> VS_com;\n        G \\<rhd> c1 : Sec A; G \\<rhd> c2 : Sec Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Comp c1 c2 : Sec A\n 2. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule, rule COMP)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c1 c2 A Aa.\n       \\<lbrakk>(low, c1) \\<in> VS_com; (low, c2) \\<in> VS_com;\n        G \\<rhd> c1 : Sec A; G \\<rhd> c2 : Sec Aa\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c1 : Sec (?\\<Phi>97 c1 c2 A Aa)\n 2. \\<And>c1 c2 A Aa.\n       \\<lbrakk>(low, c1) \\<in> VS_com; (low, c2) \\<in> VS_com;\n        G \\<rhd> c1 : Sec A; G \\<rhd> c2 : Sec Aa\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec (?\\<Psi>97 c1 c2 A Aa)\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (assumption, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> Iff b c1 c2 : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A))\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = high \\<longrightarrow>\n                         G \\<rhd> Iff b c1 c2 : twiddle\n 2. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b c1 c2.\n       \\<lbrakk>(b, high) \\<in> VS_Bexpr; (high, c1) \\<in> VS_com;\n        (high, c2) \\<in> VS_com; G \\<rhd> c1 : twiddle;\n        G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 2. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule HIGH_IFF)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b c1 c2.\n       \\<lbrakk>(b, high) \\<in> VS_Bexpr; (high, c1) \\<in> VS_com;\n        (high, c2) \\<in> VS_com; G \\<rhd> c1 : twiddle;\n        G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c1 : twiddle\n 2. \\<And>b c1 c2.\n       \\<lbrakk>(b, high) \\<in> VS_Bexpr; (high, c1) \\<in> VS_com;\n        (high, c2) \\<in> VS_com; G \\<rhd> c1 : twiddle;\n        G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : twiddle\n 3. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A)\n 4. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 5. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (assumption, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c1 c2.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c1) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c1 : twiddle) \\<and>\n        (pc = low \\<longrightarrow> (\\<exists>A. G \\<rhd> c1 : Sec A));\n        (pc, c2) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c2 : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c2 : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A)\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b c1 c2 A Aa.\n       \\<lbrakk>(b, low) \\<in> VS_Bexpr; (low, c1) \\<in> VS_com;\n        (low, c2) \\<in> VS_com; G \\<rhd> c1 : Sec A;\n        G \\<rhd> c2 : Sec Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (drule BExprSound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b c1 c2 A Aa.\n       \\<lbrakk>(low, c1) \\<in> VS_com; (low, c2) \\<in> VS_com;\n        G \\<rhd> c1 : Sec A; G \\<rhd> c2 : Sec Aa; SemBExpr b low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b c1 c2 A Aa.\n       \\<lbrakk>(low, c1) \\<in> VS_com; (low, c2) \\<in> VS_com;\n        G \\<rhd> c1 : Sec A; G \\<rhd> c2 : Sec Aa;\n        \\<forall>s ss.\n            s \\<approx> ss  \\<longrightarrow>\n           evalB b s = evalB b ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> Iff b c1 c2 : Sec A\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule, erule IFF)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b c1 c2 A Aa.\n       \\<lbrakk>(low, c1) \\<in> VS_com; (low, c2) \\<in> VS_com;\n        G \\<rhd> c1 : Sec A; G \\<rhd> c2 : Sec Aa\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c1 : Sec (?\\<Phi>126 b c1 c2 A Aa)\n 2. \\<And>b c1 c2 A Aa.\n       \\<lbrakk>(low, c1) \\<in> VS_com; (low, c2) \\<in> VS_com;\n        G \\<rhd> c1 : Sec A; G \\<rhd> c2 : Sec Aa\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec (?\\<Psi>126 b c1 c2 A Aa)\n 3. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 4. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (assumption, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (pc = high \\<longrightarrow>\n                          G \\<rhd> While b c : twiddle) \\<and>\n                         (pc = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> While b c : Sec A))\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = high \\<longrightarrow>\n                         G \\<rhd> While b c : twiddle\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> While b c : Sec A)\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>(b, high) \\<in> VS_Bexpr; (high, c) \\<in> VS_com;\n        G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 2. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> While b c : Sec A)\n 3. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (erule HIGH_WHILE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b pc c.\n       \\<lbrakk>(b, pc) \\<in> VS_Bexpr; (pc, c) \\<in> VS_com;\n        (pc = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (pc = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> pc = low \\<longrightarrow>\n                         (\\<exists>A. G \\<rhd> While b c : Sec A)\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c A.\n       \\<lbrakk>(b, low) \\<in> VS_Bexpr; (low, c) \\<in> VS_com;\n        G \\<rhd> c : Sec A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> While b c : Sec A\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (drule BExprSound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c A.\n       \\<lbrakk>(low, c) \\<in> VS_com; G \\<rhd> c : Sec A;\n        SemBExpr b low\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> While b c : Sec A\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c A.\n       \\<lbrakk>(low, c) \\<in> VS_com; G \\<rhd> c : Sec A;\n        \\<forall>s ss.\n            s \\<approx> ss  \\<longrightarrow>\n           evalB b s = evalB b ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> While b c : Sec A\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply (rule, erule WHILE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c A.\n       \\<lbrakk>(low, c) \\<in> VS_com; G \\<rhd> c : Sec A\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c : Sec (?\\<Phi>150 b c A)\n 2. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com;\n        (high = high \\<longrightarrow> G \\<rhd> c : twiddle) \\<and>\n        (high = low \\<longrightarrow>\n         (\\<exists>A. G \\<rhd> c : Sec A))\\<rbrakk>\n       \\<Longrightarrow> (low = high \\<longrightarrow>\n                          G \\<rhd> c : twiddle) \\<and>\n                         (low = low \\<longrightarrow>\n                          (\\<exists>A. G \\<rhd> c : Sec A))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>(high, c) \\<in> VS_com; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. G \\<rhd> c : Sec A", "apply (rule, erule CAST)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>The semantic of typing judgements for commands is now the\nexpected one: HIGH commands require initial and final state be low\nequivalent (i.e.~the low variables in the final state can't depend on\nthe high variables of the initial state), while LOW commands must\nrespect the above mentioned security property.\\<close>"], ["", "primrec SemCom::\"TP \\<Rightarrow> IMP \\<Rightarrow> bool\"\nwhere\n\"SemCom low c = (\\<forall> s ss t tt. s \\<approx> ss \\<longrightarrow> (s,c \\<Down> t) \\<longrightarrow>\n                               (ss,c \\<Down> tt) \\<longrightarrow> t \\<approx> tt)\" |\n\"SemCom high c = (\\<forall> s t . (s,c \\<Down> t) \\<longrightarrow> s \\<approx> t)\""], ["", "text\\<open>Combining theorem \\<open>VS_com_VDM\\<close> with the soundness result\nof the program logic and the definition of validity yields the\nsoundness of Volpano et al.'s type system.\\<close>"], ["", "theorem VS_SOUND: \"(t,c):VS_com \\<Longrightarrow> SemCom t c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, c) \\<in> VS_com \\<Longrightarrow> SemCom t c", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, c) \\<in> VS_com \\<Longrightarrow> SemCom t c", "apply (subgoal_tac \"(t=high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and> (t=low \\<longrightarrow> (\\<exists> A . {} \\<rhd> c : Sec A))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A))\\<rbrakk>\n    \\<Longrightarrow> SemCom t c\n 2. (t, c) \\<in> VS_com \\<Longrightarrow>\n    (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n    (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. (t, c) \\<in> VS_com \\<Longrightarrow>\n    (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n    (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A))\n 2. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A))\\<rbrakk>\n    \\<Longrightarrow> SemCom t c", "apply (erule VS_com_VDM)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A))\\<rbrakk>\n    \\<Longrightarrow> SemCom t c", "apply (case_tac t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A));\n     t = low\\<rbrakk>\n    \\<Longrightarrow> SemCom t c\n 2. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A));\n     t = high\\<rbrakk>\n    \\<Longrightarrow> SemCom t c", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A s ss ta tt.\n       \\<lbrakk>(low, c) \\<in> VS_com; t = low; {} \\<rhd> c : Sec A;\n         s \\<approx> ss ; s , c \\<Down> ta ; ss , c \\<Down> tt \\<rbrakk>\n       \\<Longrightarrow>  ta \\<approx> tt \n 2. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A));\n     t = high\\<rbrakk>\n    \\<Longrightarrow> SemCom t c", "apply (drule VDM_Sound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A s ss ta tt.\n       \\<lbrakk>(low, c) \\<in> VS_com; t = low;  s \\<approx> ss ;\n        s , c \\<Down> ta ; ss , c \\<Down> tt ;\n        {} \\<Turnstile> c : Sec A \\<rbrakk>\n       \\<Longrightarrow>  ta \\<approx> tt \n 2. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A));\n     t = high\\<rbrakk>\n    \\<Longrightarrow> SemCom t c", "apply (simp add: valid_def VDM_valid_def Ctxt_valid_def Sec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(t, c) \\<in> VS_com;\n     (t = high \\<longrightarrow> {} \\<rhd> c : twiddle) \\<and>\n     (t = low \\<longrightarrow> (\\<exists>A. {} \\<rhd> c : Sec A));\n     t = high\\<rbrakk>\n    \\<Longrightarrow> SemCom t c", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<lbrakk>(high, c) \\<in> VS_com; {} \\<rhd> c : twiddle; t = high;\n        s , c \\<Down> ta \\<rbrakk>\n       \\<Longrightarrow>  s \\<approx> ta", "apply (drule VDM_Sound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s ta.\n       \\<lbrakk>(high, c) \\<in> VS_com; t = high; s , c \\<Down> ta ;\n        {} \\<Turnstile> c : twiddle \\<rbrakk>\n       \\<Longrightarrow>  s \\<approx> ta", "apply (simp add: valid_def VDM_valid_def Ctxt_valid_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>As a further minor result, we prove that all judgements\ninterpreting the low rules indeed yield assertions $A$ of the form $A\n= Sec(\\Phi(FIX \\Phi))$ for some monotone $\\Phi$.\\<close>"], ["", "inductive_set Deriv ::\"(VDMAssn set \\<times> IMP \\<times> VDMAssn) set\"\nwhere\nD_CAST: \n  \"(G,c,twiddle):Deriv \\<Longrightarrow> (G, c, Sec (\\<lambda> (s,t) . s \\<approx> t)) : Deriv\"\n\n| D_SKIP: \"(G, Skip, Sec (\\<lambda> (s,t) . s \\<approx> t)) : Deriv\"\n\n| D_ASSIGN:\n  \"(\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalE e s = evalE e ss) \\<Longrightarrow>\n   (G, Assign x e, Sec (\\<lambda> (s, t) . s \\<approx> (update t x (evalE e t)))):Deriv\"\n\n| D_COMP: \n  \"\\<lbrakk> (G, c1, Sec \\<Phi>):Deriv; (G, c2, Sec \\<Psi>):Deriv\\<rbrakk> \\<Longrightarrow>\n   (G, Comp c1 c2, Sec (\\<lambda> (s,t) . \\<exists> r . \\<Phi>(r, t) \\<and> \n                           (\\<forall> w . (r \\<approx> w \\<longrightarrow> \\<Psi>(s, w))))):Deriv\"\n\n| C_IFF:\n  \"\\<lbrakk> (\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalB b s = evalB b ss);\n     (G, c1, Sec \\<Phi>):Deriv; (G,c2, Sec \\<Psi>):Deriv\\<rbrakk> \\<Longrightarrow>\n   (G, Iff b c1 c2, Sec (\\<lambda> (s, t) . (evalB b t \\<longrightarrow> \\<Phi>(s,t)) \\<and> \n                                            ((\\<not> evalB b t) \\<longrightarrow> \\<Psi>(s,t)))):Deriv\"\n\n| D_WHILE:  \n  \"\\<lbrakk> (\\<forall> s ss. s \\<approx> ss \\<longrightarrow> evalB b s = evalB b ss); \n     (G, c, Sec \\<Phi>):Deriv\\<rbrakk> \\<Longrightarrow>\n   (G, While b c, Sec (PhiWhile b \\<Phi>)):Deriv\"\n\n| D_CALL:\n  \"\\<lbrakk> ({Sec(FIX \\<Phi>)} \\<union> G, body, Sec(\\<Phi>(FIX \\<Phi>))):Deriv;\n      Monotone \\<Phi>\\<rbrakk> \\<Longrightarrow>\n   (G, Call, Sec(FIX \\<Phi>)):Deriv\"\n\n| D_HighSKIP:\"(G, Skip, twiddle):Deriv\"\n\n| D_HighASSIGN:\n  \"CONTEXT x = high \\<Longrightarrow> (G,Assign x e, twiddle):Deriv\"\n\n| D_HighCOMP:\n  \"\\<lbrakk> (G,c1,twiddle):Deriv; (G,c2,twiddle):Deriv\\<rbrakk> \\<Longrightarrow>\n   (G, Comp c1 c2, twiddle):Deriv\"\n\n| D_HighIFF:\n  \"\\<lbrakk> (G,c1,twiddle):Deriv; (G,c2,twiddle):Deriv\\<rbrakk> \\<Longrightarrow>\n   (G, Iff b c1 c2, twiddle):Deriv\"\n\n| D_HighWHILE:\n  \"(G, c, twiddle):Deriv \\<Longrightarrow> (G, While b c, twiddle):Deriv\"\n\n| D_HighCALL:\n  \"({twiddle} \\<union> G, body, twiddle):Deriv \\<Longrightarrow> (G, Call, twiddle):Deriv\""], ["", "(*<*)"], ["", "definition DProp :: \"VDMAssn \\<Rightarrow> bool\"\nwhere \"DProp A = (\\<exists> \\<phi> . A =  Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>)\""], ["", "lemma DerivProp_Aux: \"(X,c,A):Deriv \\<Longrightarrow> DProp A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X, c, A) \\<in> Deriv \\<Longrightarrow> DProp A", "apply (erule Deriv.induct)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>G c.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; DProp twiddle\\<rbrakk>\n       \\<Longrightarrow> DProp (Sec (\\<lambda>(s, t).  s \\<approx> t ))\n 2. \\<And>G. DProp (Sec (\\<lambda>(s, t).  s \\<approx> t ))\n 3. \\<And>e G x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       DProp (Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ))\n 4. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; DProp (Sec \\<Phi>);\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; DProp (Sec \\<Psi>)\\<rbrakk>\n       \\<Longrightarrow> DProp\n                          (Sec (\\<lambda>(s, t).\n                                   \\<exists>r.\n\\<Phi> (r, t) \\<and>\n(\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))))\n 5. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv; DProp (Sec \\<Phi>);\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; DProp (Sec \\<Psi>)\\<rbrakk>\n       \\<Longrightarrow> DProp\n                          (Sec (\\<lambda>(s, t).\n                                   (evalB b t \\<longrightarrow>\n                                    \\<Phi> (s, t)) \\<and>\n                                   (\\<not> evalB b t \\<longrightarrow>\n                                    \\<Psi> (s, t))))\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; DProp (Sec \\<Phi>)\\<rbrakk>\n       \\<Longrightarrow> DProp (Sec (PhiWhile b \\<Phi>))\n 7. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        DProp (Sec (\\<Phi> (FIX \\<Phi>))); Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> DProp (Sec (FIX \\<Phi>))\n 8. \\<And>G. DProp twiddle\n 9. \\<And>x G e. CONTEXT x = high \\<Longrightarrow> DProp twiddle\n 10. \\<And>G c1 c2.\n        \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; DProp twiddle;\n         (G, c2, twiddle) \\<in> Deriv; DProp twiddle\\<rbrakk>\n        \\<Longrightarrow> DProp twiddle\nA total of 13 subgoals...", "apply (simp_all add: DProp_def)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>G c.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<exists>\\<phi>.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n       Sec (\\<phi> (FIX \\<phi>)) \\<and>\n       Monotone \\<phi>\n 3. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 4. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 8. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 9. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>G c \\<phi>.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv;\n        twiddle = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<exists>\\<phi>.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n       Sec (\\<phi> (FIX \\<phi>)) \\<and>\n       Monotone \\<phi>\n 3. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 4. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 8. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 9. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule, rule)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>G c \\<phi>.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv;\n        twiddle = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n                         Sec (?\\<phi>21 G c \\<phi>\n                               (FIX (?\\<phi>21 G c \\<phi>)))\n 2. \\<And>G c \\<phi>.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv;\n        twiddle = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone (?\\<phi>21 G c \\<phi>)\n 3. \\<exists>\\<phi>.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n       Sec (\\<phi> (FIX \\<phi>)) \\<and>\n       Monotone \\<phi>\n 4. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 5. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 8. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 9. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 10. \\<And>x.\n        CONTEXT x = high \\<Longrightarrow>\n        \\<exists>\\<phi>.\n           twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>G c \\<phi>.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv;\n        twiddle = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone\n                          (\\<lambda>a b.\n                              case b of\n                              (a, b) \\<Rightarrow>  a \\<approx> b )\n 2. \\<exists>\\<phi>.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n       Sec (\\<phi> (FIX \\<phi>)) \\<and>\n       Monotone \\<phi>\n 3. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 4. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 8. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 9. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<exists>\\<phi>.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n       Sec (\\<phi> (FIX \\<phi>)) \\<and>\n       Monotone \\<phi>\n 2. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 3. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 8. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp?"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<exists>\\<phi>.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) =\n       Sec (\\<phi> (FIX \\<phi>)) \\<and>\n       Monotone \\<phi>\n 2. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 3. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 8. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule, rule)"], ["proof (prove)\ngoal (9 subgoals):\n 1. Sec (\\<lambda>(x, y).  x \\<approx> y ) = Sec (?\\<phi>29 (FIX ?\\<phi>29))\n 2. Monotone ?\\<phi>29\n 3. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 4. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 8. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 9. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. Monotone (\\<lambda>a b. case b of (a, b) \\<Rightarrow>  a \\<approx> b )\n 2. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 3. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 8. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 2. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 7. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp?"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n          Sec (\\<phi> (FIX \\<phi>)) \\<and>\n          Monotone \\<phi>\n 2. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 7. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule, rule)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       Sec (\\<lambda>(s, t).  s \\<approx> update t x (evalE e t) ) =\n       Sec (?\\<phi>37 e x (FIX (?\\<phi>37 e x)))\n 2. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       Monotone (?\\<phi>37 e x)\n 3. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 7. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 8. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>e x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       Monotone\n        (\\<lambda>a b.\n            case b of\n            (s, t) \\<Rightarrow>  s \\<approx> update t x (evalE e t) )\n 2. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 7. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 6. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp?"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>(G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    \\<exists>r.\n \\<Phi> (r, t) \\<and>\n (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 6. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule, rule)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>(G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> Sec (\\<lambda>(s, t).\n                                 \\<exists>r.\n                                    \\<Phi> (r, t) \\<and>\n                                    (\\<forall>w.\n   r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w))) =\n                         Sec (?\\<phi>52 G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'\n                               (FIX (?\\<phi>52 G c1 \\<Phi> c2 \\<Psi> \\<phi>\n\\<phi>')))\n 2. \\<And>G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>(G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> Monotone\n                          (?\\<phi>52 G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>')\n 3. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 6. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 7. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>(G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> Monotone\n                          (\\<lambda>a b.\n                              case b of\n                              (s, t) \\<Rightarrow>\n                                \\<exists>r.\n                                   \\<Phi> (r, t) \\<and>\n                                   (\\<forall>w.\n  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 6. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Psi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 5. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp?"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (\\<lambda>(s, t).\n                                    (evalB b t \\<longrightarrow>\n                                     \\<Phi> (s, t)) \\<and>\n                                    (\\<not> evalB b t \\<longrightarrow>\n                                     \\<Psi> (s, t))) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 5. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule, rule)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> Sec (\\<lambda>(s, t).\n                                 (evalB b t \\<longrightarrow>\n                                  \\<Phi> (s, t)) \\<and>\n                                 (\\<not> evalB b t \\<longrightarrow>\n                                  \\<Psi> (s, t))) =\n                         Sec (?\\<phi>72 b G c1 \\<Phi> c2 \\<Psi> \\<phi>\n                               \\<phi>'\n                               (FIX (?\\<phi>72 b G c1 \\<Phi> c2 \\<Psi>\n\\<phi> \\<phi>')))\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> Monotone\n                          (?\\<phi>72 b G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>')\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 5. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 6. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi> \\<phi> \\<phi>'.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        (G, c2, Sec (\\<phi>' (FIX \\<phi>'))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>;\n        Sec \\<Psi> = Sec (\\<phi>' (FIX \\<phi>')); Monotone \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> Monotone\n                          (\\<lambda>a c.\n                              case c of\n                              (s, t) \\<Rightarrow>\n                                (evalB b t \\<longrightarrow>\n                                 \\<Phi> (s, t)) \\<and>\n                                (\\<not> evalB b t \\<longrightarrow>\n                                 \\<Psi> (s, t)))\n 2. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 5. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 4. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp?"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b G c \\<Phi> \\<phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (PhiWhile b \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 4. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule, rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b G c \\<Phi> \\<phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Sec (PhiWhile b \\<Phi>) =\n                         Sec (?\\<phi>90 b G c \\<Phi> \\<phi>\n                               (FIX (?\\<phi>90 b G c \\<Phi> \\<phi>)))\n 2. \\<And>b G c \\<Phi> \\<phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone (?\\<phi>90 b G c \\<Phi> \\<phi>)\n 3. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 4. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 5. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b G c \\<Phi> \\<phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec (\\<phi> (FIX \\<phi>))) \\<in> Deriv;\n        Sec \\<Phi> = Sec (\\<phi> (FIX \\<phi>)); Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone (\\<lambda>a. PhiWhile b \\<Phi>)\n 2. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 3. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 4. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<Phi> G.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        \\<exists>\\<phi>.\n           Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>)) \\<and>\n           Monotone \\<phi>;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp ?"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<Phi> G \\<phi>.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        Monotone \\<Phi>;\n        Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<phi>.\n                            Sec (FIX \\<Phi>) =\n                            Sec (\\<phi> (FIX \\<phi>)) \\<and>\n                            Monotone \\<phi>\n 2. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule, rule)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Phi> G \\<phi>.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        Monotone \\<Phi>;\n        Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Sec (FIX \\<Phi>) =\n                         Sec (?\\<phi>101 \\<Phi> G \\<phi>\n                               (FIX (?\\<phi>101 \\<Phi> G \\<phi>)))\n 2. \\<And>\\<Phi> G \\<phi>.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        Monotone \\<Phi>;\n        Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone (?\\<phi>101 \\<Phi> G \\<phi>)\n 3. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 4. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<Phi> G \\<phi>.\n       \\<lbrakk>(insert (Sec (FIX \\<Phi>)) G, body,\n                 Sec (\\<phi> (FIX \\<phi>)))\n                \\<in> Deriv;\n        Monotone \\<Phi>;\n        Sec (\\<Phi> (FIX \\<Phi>)) = Sec (\\<phi> (FIX \\<phi>));\n        Monotone \\<phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone (\\<lambda>a. FIX \\<Phi>)\n 2. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp?"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>\\<phi>.\n       twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule_tac x=\"\\<lambda> \\<Phi>. \\<lambda> (s,t) . s \\<approx> t\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. twiddle = Sec (\\<lambda>(s, t).  s \\<approx> t ) \\<and>\n    Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (subgoal_tac \"Monotone (\\<lambda> \\<Phi>. \\<lambda> (s,t) . s \\<approx> t)\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t ) \\<Longrightarrow>\n    twiddle = Sec (\\<lambda>(x, y).  x \\<approx> y )\n 2. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (drule Fix_lemma)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>(s, t).  s \\<approx> t ) =\n    FIX (\\<lambda>\\<Phi> (s, t).  s \\<approx> t ) \\<Longrightarrow>\n    twiddle = Sec (\\<lambda>(x, y).  x \\<approx> y )\n 2. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (erule thin_rl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. twiddle = Sec (\\<lambda>(x, y).  x \\<approx> y )\n 2. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule ext, rule ext, rule iffI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n        x \\<approx> xa  \\<Longrightarrow>\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) x xa\n 2. \\<And>x xa.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) x xa \\<Longrightarrow>\n        x \\<approx> xa \n 3. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 4. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: twiddle_def Sec_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       Sec (\\<lambda>(x, y).  x \\<approx> y ) x xa \\<Longrightarrow>\n        x \\<approx> xa \n 2. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       (\\<forall>r.\n            x \\<approx> r  \\<longrightarrow>  xa \\<approx> r ) \\<and>\n       (\\<forall>r.\n            r \\<approx> x  \\<longrightarrow>\n            r \\<approx> xa ) \\<Longrightarrow>\n        x \\<approx> xa \n 2. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp only: twiddle_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       (\\<forall>r.\n           (\\<forall>xa.\n               CONTEXT xa = low \\<longrightarrow>\n               x xa = r xa) \\<longrightarrow>\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow> xa x = r x)) \\<and>\n       (\\<forall>r.\n           (\\<forall>xa.\n               CONTEXT xa = low \\<longrightarrow>\n               r xa = x xa) \\<longrightarrow>\n           (\\<forall>x.\n               CONTEXT x = low \\<longrightarrow>\n               r x = xa x)) \\<Longrightarrow>\n       \\<forall>xb. CONTEXT xb = low \\<longrightarrow> x xb = xa xb\n 2. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply clarsimp?"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       \\<exists>\\<phi>.\n          twiddle = Sec (\\<phi> (FIX \\<phi>)) \\<and> Monotone \\<phi>", "apply (rule_tac x=\"\\<lambda> \\<Phi>. \\<lambda> (s,t) . s \\<approx> t\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       twiddle = Sec (\\<lambda>(s, t).  s \\<approx> t ) \\<and>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (subgoal_tac \"Monotone (\\<lambda> \\<Phi>. \\<lambda> (s,t) . s \\<approx> t)\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>CONTEXT x = high;\n        Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> twiddle = Sec (\\<lambda>(x, y).  x \\<approx> y )\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (drule Fix_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>CONTEXT x = high;\n        (\\<lambda>(s, t).  s \\<approx> t ) =\n        FIX (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )\\<rbrakk>\n       \\<Longrightarrow> twiddle = Sec (\\<lambda>(x, y).  x \\<approx> y )\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<lambda>(s, t).  s \\<approx> t ) =\n       FIX (\\<lambda>\\<Phi> (s, t).  s \\<approx> t ) \\<Longrightarrow>\n       twiddle = Sec (\\<lambda>(x, y).  x \\<approx> y )\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (rule ext, rule ext, rule iffI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(\\<lambda>(s, t).  s \\<approx> t ) =\n                FIX (\\<lambda>\\<Phi> (s, t).  s \\<approx> t );\n         xa \\<approx> xb \\<rbrakk>\n       \\<Longrightarrow> Sec (\\<lambda>(x, y).  x \\<approx> y ) xa xb\n 2. \\<And>x xa xb.\n       \\<lbrakk>(\\<lambda>(s, t).  s \\<approx> t ) =\n                FIX (\\<lambda>\\<Phi> (s, t).  s \\<approx> t );\n        Sec (\\<lambda>(x, y).  x \\<approx> y ) xa xb\\<rbrakk>\n       \\<Longrightarrow>  xa \\<approx> xb \n 3. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (simp add: twiddle_def Sec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(\\<lambda>(s, t).  s \\<approx> t ) =\n                FIX (\\<lambda>\\<Phi> (s, t).  s \\<approx> t );\n        Sec (\\<lambda>(x, y).  x \\<approx> y ) xa xb\\<rbrakk>\n       \\<Longrightarrow>  xa \\<approx> xb \n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (simp add: Sec_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>(\\<lambda>(x, y).  x \\<approx> y ) =\n                FIX (\\<lambda>\\<Phi> (x, y).  x \\<approx> y );\n        (\\<forall>r.\n             xa \\<approx> r  \\<longrightarrow>  xb \\<approx> r ) \\<and>\n        (\\<forall>r.\n             r \\<approx> xa  \\<longrightarrow>  r \\<approx> xb )\\<rbrakk>\n       \\<Longrightarrow>  xa \\<approx> xb \n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (simp only: twiddle_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>(\\<lambda>(x, y).  x \\<approx> y ) =\n                FIX (\\<lambda>\\<Phi> (x, y).  x \\<approx> y );\n        (\\<forall>r.\n            (\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                xa x = r x) \\<longrightarrow>\n            (\\<forall>x.\n                CONTEXT x = low \\<longrightarrow> xb x = r x)) \\<and>\n        (\\<forall>r.\n            (\\<forall>x.\n                CONTEXT x = low \\<longrightarrow>\n                r x = xa x) \\<longrightarrow>\n            (\\<forall>x.\n                CONTEXT x = low \\<longrightarrow> r x = xb x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            CONTEXT x = low \\<longrightarrow> xa x = xb x\n 2. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       CONTEXT x = high \\<Longrightarrow>\n       Monotone (\\<lambda>\\<Phi> (s, t).  s \\<approx> t )", "apply (simp add: Monotone_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma DerivMono: \n \"(X,c,A):Deriv \\<Longrightarrow> \\<exists> \\<Phi> . A =  Sec (\\<Phi> (FIX \\<Phi>)) \\<and> Monotone \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X, c, A) \\<in> Deriv \\<Longrightarrow>\n    \\<exists>\\<Phi>. A = Sec (\\<Phi> (FIX \\<Phi>)) \\<and> Monotone \\<Phi>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X, c, A) \\<in> Deriv \\<Longrightarrow>\n    \\<exists>\\<Phi>. A = Sec (\\<Phi> (FIX \\<Phi>)) \\<and> Monotone \\<Phi>", "by (drule DerivProp_Aux, simp add: DProp_def)"], ["", "(*>*)"], ["", "text\\<open>Also, all rules in the \\<open>Deriv\\<close> relation are indeed\nderivable in the program logic.\\<close>"], ["", "lemma Deriv_derivable: \"(G,c,A):Deriv \\<Longrightarrow> G \\<rhd> c: A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G, c, A) \\<in> Deriv \\<Longrightarrow> G \\<rhd> c : A", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G, c, A) \\<in> Deriv \\<Longrightarrow> G \\<rhd> c : A", "apply (erule Deriv.induct)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>G c.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c : Sec (\\<lambda>(s, t).  s \\<approx> t )\n 2. \\<And>G. G \\<rhd> Skip : Sec (\\<lambda>(s, t).  s \\<approx> t )\n 3. \\<And>e G x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       G \\<rhd> Assign x\n                 e : Sec (\\<lambda>(s, t).\n                              s \\<approx> update t x (evalE e t) )\n 4. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       \\<exists>r.\n          \\<Phi> (r, t) \\<and>\n          (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n 5. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n       (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))\n 6. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 7. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 8. \\<And>G. G \\<rhd> Skip : twiddle\n 9. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 10. \\<And>G c1 c2.\n        \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n         (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\nA total of 13 subgoals...", "apply (erule CAST)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>G. G \\<rhd> Skip : Sec (\\<lambda>(s, t).  s \\<approx> t )\n 2. \\<And>e G x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       G \\<rhd> Assign x\n                 e : Sec (\\<lambda>(s, t).\n                              s \\<approx> update t x (evalE e t) )\n 3. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       \\<exists>r.\n          \\<Phi> (r, t) \\<and>\n          (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n 4. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n       (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))\n 5. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 6. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 7. \\<And>G. G \\<rhd> Skip : twiddle\n 8. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 9. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 10. \\<And>G c1 c2 b.\n        \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n         (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\nA total of 12 subgoals...", "apply (rule SKIP)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>e G x.\n       \\<forall>s ss.\n           s \\<approx> ss  \\<longrightarrow>\n          evalE e s = evalE e ss \\<Longrightarrow>\n       G \\<rhd> Assign x\n                 e : Sec (\\<lambda>(s, t).\n                              s \\<approx> update t x (evalE e t) )\n 2. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       \\<exists>r.\n          \\<Phi> (r, t) \\<and>\n          (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n 3. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n       (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))\n 4. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 5. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 6. \\<And>G. G \\<rhd> Skip : twiddle\n 7. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 8. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 9. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 10. \\<And>G c b.\n        \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> While b c : twiddle\nA total of 11 subgoals...", "apply (erule ASSIGN)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       \\<exists>r.\n          \\<Phi> (r, t) \\<and>\n          (\\<forall>w.  r \\<approx> w  \\<longrightarrow> \\<Psi> (s, w)))\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n       (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 4. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 5. \\<And>G. G \\<rhd> Skip : twiddle\n 6. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 7. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 8. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 9. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 10. \\<And>G.\n        \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n         ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule COMP)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec \\<Psi>\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n       (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 4. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 5. \\<And>G. G \\<rhd> Skip : twiddle\n 6. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 7. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 8. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 9. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 10. \\<And>G.\n        \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n         ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply assumption"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1\n                                   c2 : Sec\n   (\\<lambda>(s, t).\n       (evalB b t \\<longrightarrow> \\<Phi> (s, t)) \\<and>\n       (\\<not> evalB b t \\<longrightarrow> \\<Psi> (s, t)))\n 2. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 3. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 4. \\<And>G. G \\<rhd> Skip : twiddle\n 5. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 6. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 7. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 8. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 9. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule IFF)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c1 : Sec \\<Phi>\n 2. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec \\<Psi>\n 3. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 4. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 5. \\<And>G. G \\<rhd> Skip : twiddle\n 6. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 7. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 8. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 9. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 10. \\<And>G.\n        \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n         ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n        \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply assumption"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b G c1 \\<Phi> c2 \\<Psi>.\n       \\<lbrakk>(G, c1, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c1 : Sec \\<Phi>;\n        (G, c2, Sec \\<Psi>) \\<in> Deriv; G \\<rhd> c2 : Sec \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : Sec \\<Psi>\n 2. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 3. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 4. \\<And>G. G \\<rhd> Skip : twiddle\n 5. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 6. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 7. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 8. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 9. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply assumption"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>b G c \\<Phi>.\n       \\<lbrakk>\\<forall>s ss.\n                    s \\<approx> ss  \\<longrightarrow>\n                   evalB b s = evalB b ss;\n        (G, c, Sec \\<Phi>) \\<in> Deriv; G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : Sec (PhiWhile b \\<Phi>)\n 2. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 3. \\<And>G. G \\<rhd> Skip : twiddle\n 4. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 5. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 6. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 7. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 8. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule WHILE)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>b G c \\<Phi>.\n       \\<lbrakk>(G, c, Sec \\<Phi>) \\<in> Deriv;\n        G \\<rhd> c : Sec \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c : Sec \\<Phi>\n 2. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 3. \\<And>G. G \\<rhd> Skip : twiddle\n 4. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 5. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 6. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 7. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 8. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply assumption"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        ({Sec (FIX \\<Phi>)} \\<union>\n         G) \\<rhd> body : Sec (\\<Phi> (FIX \\<Phi>));\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : Sec (FIX \\<Phi>)\n 2. \\<And>G. G \\<rhd> Skip : twiddle\n 3. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 4. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 5. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 6. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 7. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule CALL)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>\\<Phi> G.\n       \\<lbrakk>({Sec (FIX \\<Phi>)} \\<union> G, body,\n                 Sec (\\<Phi> (FIX \\<Phi>)))\n                \\<in> Deriv;\n        Monotone \\<Phi>\\<rbrakk>\n       \\<Longrightarrow> Monotone \\<Phi>\n 2. \\<And>G. G \\<rhd> Skip : twiddle\n 3. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 4. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 5. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 6. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 7. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply assumption"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>G. G \\<rhd> Skip : twiddle\n 2. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 3. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 4. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 5. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 6. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (rule HIGH_SKIP)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x G e.\n       CONTEXT x = high \\<Longrightarrow> G \\<rhd> Assign x e : twiddle\n 2. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 3. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 4. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 5. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule HIGH_ASSIGN)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Comp c1 c2 : twiddle\n 2. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 3. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 4. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule HIGH_COMP)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>G c1 c2.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; (G, c2, twiddle) \\<in> Deriv;\n        G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : twiddle\n 2. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 3. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 4. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; G \\<rhd> c1 : twiddle;\n        (G, c2, twiddle) \\<in> Deriv; G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Iff b c1 c2 : twiddle\n 2. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 3. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule HIGH_IFF)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>G c1 c2 b.\n       \\<lbrakk>(G, c1, twiddle) \\<in> Deriv; (G, c2, twiddle) \\<in> Deriv;\n        G \\<rhd> c2 : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> c2 : twiddle\n 2. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 3. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>G c b.\n       \\<lbrakk>(G, c, twiddle) \\<in> Deriv; G \\<rhd> c : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> While b c : twiddle\n 2. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule HIGH_WHILE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>({twiddle} \\<union> G, body, twiddle) \\<in> Deriv;\n        ({twiddle} \\<union> G) \\<rhd> body : twiddle\\<rbrakk>\n       \\<Longrightarrow> G \\<rhd> Call : twiddle", "apply (erule HIGH_CALL)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>End of theory VS\\<close>"], ["", "end"]]}